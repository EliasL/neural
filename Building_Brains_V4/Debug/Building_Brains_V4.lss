
Building_Brains_V4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000001c  00803e00  00001fc8  0000207c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001f60  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000068  00009f60  00001f60  00002014  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .bss          00000055  00803e1c  00803e1c  00002098  2**0
                  ALLOC
  4 .comment      0000005c  00000000  00000000  00002098  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000020f4  2**2
                  CONTENTS, READONLY
  6 .debug_aranges 000004d8  00000000  00000000  00002130  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00007914  00000000  00000000  00002608  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000030dc  00000000  00000000  00009f1c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000027ed  00000000  00000000  0000cff8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000008fc  00000000  00000000  0000f7e8  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00002fa8  00000000  00000000  000100e4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000176e  00000000  00000000  0001308c  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000318  00000000  00000000  000147fa  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	96 c0       	rjmp	.+300    	; 0x12e <__ctors_end>
       2:	b0 c0       	rjmp	.+352    	; 0x164 <__bad_interrupt>
       4:	af c0       	rjmp	.+350    	; 0x164 <__bad_interrupt>
       6:	ae c0       	rjmp	.+348    	; 0x164 <__bad_interrupt>
       8:	ad c0       	rjmp	.+346    	; 0x164 <__bad_interrupt>
       a:	ac c0       	rjmp	.+344    	; 0x164 <__bad_interrupt>
       c:	34 c6       	rjmp	.+3176   	; 0xc76 <__vector_6>
       e:	aa c0       	rjmp	.+340    	; 0x164 <__bad_interrupt>
      10:	a9 c0       	rjmp	.+338    	; 0x164 <__bad_interrupt>
      12:	a8 c0       	rjmp	.+336    	; 0x164 <__bad_interrupt>
      14:	a7 c0       	rjmp	.+334    	; 0x164 <__bad_interrupt>
      16:	a6 c0       	rjmp	.+332    	; 0x164 <__bad_interrupt>
      18:	a5 c0       	rjmp	.+330    	; 0x164 <__bad_interrupt>
      1a:	a4 c0       	rjmp	.+328    	; 0x164 <__bad_interrupt>
      1c:	a3 c0       	rjmp	.+326    	; 0x164 <__bad_interrupt>
      1e:	a2 c0       	rjmp	.+324    	; 0x164 <__bad_interrupt>
      20:	a1 c0       	rjmp	.+322    	; 0x164 <__bad_interrupt>
      22:	a0 c0       	rjmp	.+320    	; 0x164 <__bad_interrupt>
      24:	9f c0       	rjmp	.+318    	; 0x164 <__bad_interrupt>
      26:	9e c0       	rjmp	.+316    	; 0x164 <__bad_interrupt>
      28:	9d c0       	rjmp	.+314    	; 0x164 <__bad_interrupt>
      2a:	9c c0       	rjmp	.+312    	; 0x164 <__bad_interrupt>
      2c:	9b c0       	rjmp	.+310    	; 0x164 <__bad_interrupt>
      2e:	9a c0       	rjmp	.+308    	; 0x164 <__bad_interrupt>
      30:	99 c0       	rjmp	.+306    	; 0x164 <__bad_interrupt>
      32:	98 c0       	rjmp	.+304    	; 0x164 <__bad_interrupt>

00000034 <__trampolines_end>:
      34:	00 40       	sbci	r16, 0x00	; 0
      36:	7a 10       	cpse	r7, r10
      38:	f3 5a       	subi	r31, 0xA3	; 163
      3a:	00 a0       	ldd	r0, Z+32	; 0x20
      3c:	72 4e       	sbci	r23, 0xE2	; 226
      3e:	18 09       	sbc	r17, r8
      40:	00 10       	cpse	r0, r0
      42:	a5 d4       	rcall	.+2378   	; 0x98e <tinyAxon_update_potential+0x76>
      44:	e8 00       	.word	0x00e8	; ????
      46:	00 e8       	ldi	r16, 0x80	; 128
      48:	76 48       	sbci	r23, 0x86	; 134
      4a:	17 00       	.word	0x0017	; ????
      4c:	00 e4       	ldi	r16, 0x40	; 64
      4e:	0b 54       	subi	r16, 0x4B	; 75
      50:	02 00       	.word	0x0002	; ????
      52:	00 ca       	rjmp	.-3072   	; 0xfffff454 <__eeprom_end+0xff7ef454>
      54:	9a 3b       	cpi	r25, 0xBA	; 186
      56:	00 00       	nop
      58:	00 e1       	ldi	r16, 0x10	; 16
      5a:	f5 05       	cpc	r31, r5
      5c:	00 00       	nop
      5e:	80 96       	adiw	r24, 0x20	; 32
      60:	98 00       	.word	0x0098	; ????
      62:	00 00       	nop
      64:	40 42       	sbci	r20, 0x20	; 32
      66:	0f 00       	.word	0x000f	; ????
      68:	00 00       	nop
      6a:	a0 86       	std	Z+8, r10	; 0x08
      6c:	01 00       	.word	0x0001	; ????
      6e:	00 00       	nop
      70:	10 27       	eor	r17, r16
      72:	00 00       	nop
      74:	00 00       	nop
      76:	e8 03       	fmulsu	r22, r16
      78:	00 00       	nop
      7a:	00 00       	nop
      7c:	64 00       	.word	0x0064	; ????
      7e:	00 00       	nop
      80:	00 00       	nop
      82:	0a 00       	.word	0x000a	; ????
      84:	00 00       	nop
      86:	00 00       	nop
      88:	01 00       	.word	0x0001	; ????
      8a:	00 00       	nop
      8c:	00 00       	nop
      8e:	2c 76       	andi	r18, 0x6C	; 108
      90:	d8 88       	ldd	r13, Y+16	; 0x10
      92:	dc 67       	ori	r29, 0x7C	; 124
      94:	4f 08       	sbc	r4, r15
      96:	23 df       	rcall	.-442    	; 0xfffffede <__eeprom_end+0xff7efede>
      98:	c1 df       	rcall	.-126    	; 0x1c <__FUSE_REGION_LENGTH__+0x13>
      9a:	ae 59       	subi	r26, 0x9E	; 158
      9c:	e1 b1       	in	r30, 0x01	; 1
      9e:	b7 96       	adiw	r30, 0x27	; 39
      a0:	e5 e3       	ldi	r30, 0x35	; 53
      a2:	e4 53       	subi	r30, 0x34	; 52
      a4:	c6 3a       	cpi	r28, 0xA6	; 166
      a6:	e6 51       	subi	r30, 0x16	; 22
      a8:	99 76       	andi	r25, 0x69	; 105
      aa:	96 e8       	ldi	r25, 0x86	; 134
      ac:	e6 c2       	rjmp	.+1484   	; 0x67a <set_LED_fire+0x1c>
      ae:	84 26       	eor	r8, r20
      b0:	eb 89       	ldd	r30, Y+19	; 0x13
      b2:	8c 9b       	sbis	0x11, 4	; 17
      b4:	62 ed       	ldi	r22, 0xD2	; 210
      b6:	40 7c       	andi	r20, 0xC0	; 192
      b8:	6f fc       	.word	0xfc6f	; ????
      ba:	ef bc       	out	0x2f, r14	; 47
      bc:	9c 9f       	mul	r25, r28
      be:	40 f2       	brcs	.-112    	; 0x50 <__SREG__+0x11>
      c0:	ba a5       	ldd	r27, Y+42	; 0x2a
      c2:	6f a5       	ldd	r22, Y+47	; 0x2f
      c4:	f4 90       	lpm	r15, Z
      c6:	05 5a       	subi	r16, 0xA5	; 165
      c8:	2a f7       	brpl	.-54     	; 0x94 <__SREG__+0x55>
      ca:	5c 93       	st	X, r21
      cc:	6b 6c       	ori	r22, 0xCB	; 203
      ce:	f9 67       	ori	r31, 0x79	; 121
      d0:	6d c1       	rjmp	.+730    	; 0x3ac <dequeue+0x42>
      d2:	1b fc       	.word	0xfc1b	; ????
      d4:	e0 e4       	ldi	r30, 0x40	; 64
      d6:	0d 47       	sbci	r16, 0x7D	; 125
      d8:	fe f5       	brtc	.+126    	; 0x158 <.do_clear_bss_loop>
      da:	20 e6       	ldi	r18, 0x60	; 96
      dc:	b5 00       	.word	0x00b5	; ????
      de:	d0 ed       	ldi	r29, 0xD0	; 208
      e0:	90 2e       	mov	r9, r16
      e2:	03 00       	.word	0x0003	; ????
      e4:	94 35       	cpi	r25, 0x54	; 84
      e6:	77 05       	cpc	r23, r7
      e8:	00 80       	ld	r0, Z
      ea:	84 1e       	adc	r8, r20
      ec:	08 00       	.word	0x0008	; ????
      ee:	00 20       	and	r0, r0
      f0:	4e 0a       	sbc	r4, r30
      f2:	00 00       	nop
      f4:	00 c8       	rjmp	.-4096   	; 0xfffff0f6 <__eeprom_end+0xff7ef0f6>
      f6:	0c 33       	cpi	r16, 0x3C	; 60
      f8:	33 33       	cpi	r19, 0x33	; 51
      fa:	33 0f       	add	r19, r19
      fc:	98 6e       	ori	r25, 0xE8	; 232
      fe:	12 83       	std	Z+2, r17	; 0x02
     100:	11 41       	sbci	r17, 0x11	; 17
     102:	ef 8d       	ldd	r30, Y+31	; 0x1f
     104:	21 14       	cp	r2, r1
     106:	89 3b       	cpi	r24, 0xB9	; 185
     108:	e6 55       	subi	r30, 0x56	; 86
     10a:	16 cf       	rjmp	.-468    	; 0xffffff38 <__eeprom_end+0xff7eff38>
     10c:	fe e6       	ldi	r31, 0x6E	; 110
     10e:	db 18       	sub	r13, r11
     110:	d1 84       	ldd	r13, Z+9	; 0x09
     112:	4b 38       	cpi	r20, 0x8B	; 139
     114:	1b f7       	brvc	.-58     	; 0xdc <__SREG__+0x9d>
     116:	7c 1d       	adc	r23, r12
     118:	90 1d       	adc	r25, r0
     11a:	a4 bb       	out	0x14, r26	; 20
     11c:	e4 24       	eor	r14, r4
     11e:	20 32       	cpi	r18, 0x20	; 32
     120:	84 72       	andi	r24, 0x24	; 36
     122:	5e 22       	and	r5, r30
     124:	81 00       	.word	0x0081	; ????
     126:	c9 f1       	breq	.+114    	; 0x19a <ADC_get_conversion+0x1e>
     128:	24 ec       	ldi	r18, 0xC4	; 196
     12a:	a1 e5       	ldi	r26, 0x51	; 81
     12c:	3d 27       	eor	r19, r29

0000012e <__ctors_end>:
     12e:	11 24       	eor	r1, r1
     130:	1f be       	out	0x3f, r1	; 63
     132:	cf ef       	ldi	r28, 0xFF	; 255
     134:	cd bf       	out	0x3d, r28	; 61
     136:	df e3       	ldi	r29, 0x3F	; 63
     138:	de bf       	out	0x3e, r29	; 62

0000013a <__do_copy_data>:
     13a:	1e e3       	ldi	r17, 0x3E	; 62
     13c:	a0 e0       	ldi	r26, 0x00	; 0
     13e:	be e3       	ldi	r27, 0x3E	; 62
     140:	e8 ec       	ldi	r30, 0xC8	; 200
     142:	ff e1       	ldi	r31, 0x1F	; 31
     144:	02 c0       	rjmp	.+4      	; 0x14a <__do_copy_data+0x10>
     146:	05 90       	lpm	r0, Z+
     148:	0d 92       	st	X+, r0
     14a:	ac 31       	cpi	r26, 0x1C	; 28
     14c:	b1 07       	cpc	r27, r17
     14e:	d9 f7       	brne	.-10     	; 0x146 <__do_copy_data+0xc>

00000150 <__do_clear_bss>:
     150:	2e e3       	ldi	r18, 0x3E	; 62
     152:	ac e1       	ldi	r26, 0x1C	; 28
     154:	be e3       	ldi	r27, 0x3E	; 62
     156:	01 c0       	rjmp	.+2      	; 0x15a <.do_clear_bss_start>

00000158 <.do_clear_bss_loop>:
     158:	1d 92       	st	X+, r1

0000015a <.do_clear_bss_start>:
     15a:	a1 37       	cpi	r26, 0x71	; 113
     15c:	b2 07       	cpc	r27, r18
     15e:	e1 f7       	brne	.-8      	; 0x158 <.do_clear_bss_loop>
     160:	6b d2       	rcall	.+1238   	; 0x638 <main>
     162:	fc ce       	rjmp	.-520    	; 0xffffff5c <__eeprom_end+0xff7eff5c>

00000164 <__bad_interrupt>:
     164:	4d cf       	rjmp	.-358    	; 0x0 <__vectors>

00000166 <atmel_start_init>:
/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
	system_init();
     166:	c2 d0       	rcall	.+388    	; 0x2ec <system_init>
     168:	08 95       	ret

0000016a <ADC_init>:
 * \return Conversion result read from the ADC ADC module
 */
adc_result_t ADC_get_conversion_result(void)
{
	return (ADC0.RES);
}
     16a:	85 e0       	ldi	r24, 0x05	; 5
     16c:	80 93 00 06 	sts	0x0600, r24	; 0x800600 <__TEXT_REGION_LENGTH__+0x700600>
     170:	80 e0       	ldi	r24, 0x00	; 0
     172:	08 95       	ret

00000174 <ADC_is_conversion_done>:
     174:	80 91 0b 06 	lds	r24, 0x060B	; 0x80060b <__TEXT_REGION_LENGTH__+0x70060b>
     178:	81 70       	andi	r24, 0x01	; 1
     17a:	08 95       	ret

0000017c <ADC_get_conversion>:
 *
 * \return Nothing
 */
void ADC_start_conversion(adc_0_channel_t channel)
{
	ADC0.MUXPOS  = channel;
     17c:	e0 e0       	ldi	r30, 0x00	; 0
     17e:	f6 e0       	ldi	r31, 0x06	; 6
     180:	86 83       	std	Z+6, r24	; 0x06
	ADC0.COMMAND = ADC_STCONV_bm;
     182:	81 e0       	ldi	r24, 0x01	; 1
     184:	80 87       	std	Z+8, r24	; 0x08
adc_result_t ADC_get_conversion(adc_0_channel_t channel)
{
	adc_result_t res;

	ADC_start_conversion(channel);
	while (!ADC_is_conversion_done())
     186:	f6 df       	rcall	.-20     	; 0x174 <ADC_is_conversion_done>
     188:	88 23       	and	r24, r24
     18a:	e9 f3       	breq	.-6      	; 0x186 <ADC_get_conversion+0xa>
 *
 * \return Conversion result read from the ADC ADC module
 */
adc_result_t ADC_get_conversion_result(void)
{
	return (ADC0.RES);
     18c:	e0 e0       	ldi	r30, 0x00	; 0
     18e:	f6 e0       	ldi	r31, 0x06	; 6
     190:	20 89       	ldd	r18, Z+16	; 0x10
     192:	31 89       	ldd	r19, Z+17	; 0x11

	ADC_start_conversion(channel);
	while (!ADC_is_conversion_done())
		;
	res = ADC_get_conversion_result();
	ADC0.INTFLAGS |= ADC_RESRDY_bm;
     194:	93 85       	ldd	r25, Z+11	; 0x0b
     196:	91 60       	ori	r25, 0x01	; 1
     198:	93 87       	std	Z+11, r25	; 0x0b
	return res;
}
     19a:	c9 01       	movw	r24, r18
     19c:	08 95       	ret

0000019e <BOD_init>:
	//		 | BOD_VLMCFG_ABOVE_gc; /* Interrupt when supply goes above VLM level */

	// BOD.VLMCTRLA = BOD_VLMLVL_5ABOVE_gc; /* VLM threshold 5% above BOD level */

	return 0;
}
     19e:	80 e0       	ldi	r24, 0x00	; 0
     1a0:	08 95       	ret

000001a2 <DIGGSIGG_init>:
	//		 | CCL_EDGEDET_DIS_gc /* Edge detector is disabled */
	//		 | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	//		 | 0 << CCL_ENABLE_bp /* LUT Enable: disabled */
	//		 | 0 << CCL_OUTEN_bp; /* Output Enable: disabled */

	CCL.TRUTH1 = 168; /* Truth 1: 168 */
     1a2:	e0 ec       	ldi	r30, 0xC0	; 192
     1a4:	f1 e0       	ldi	r31, 0x01	; 1
     1a6:	88 ea       	ldi	r24, 0xA8	; 168
     1a8:	84 87       	std	Z+12, r24	; 0x0c

	CCL.LUT1CTRLC = CCL_INSEL2_TCA0_gc /* TCA0 WO2 input source */;
     1aa:	88 e0       	ldi	r24, 0x08	; 8
     1ac:	83 87       	std	Z+11, r24	; 0x0b

	CCL.LUT1CTRLB = CCL_INSEL0_SPI0_gc /* SPI0 SCK source */
     1ae:	8b eb       	ldi	r24, 0xBB	; 187
     1b0:	82 87       	std	Z+10, r24	; 0x0a
	                | CCL_INSEL1_SPI0_gc /* SPI0 MOSI input source */;

	CCL.LUT1CTRLA = 0 << CCL_CLKSRC_bp       /* Clock Source Selection: disabled */
     1b2:	89 e0       	ldi	r24, 0x09	; 9
     1b4:	81 87       	std	Z+9, r24	; 0x09
	                | CCL_EDGEDET_DIS_gc     /* Edge detector is disabled */
	                | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	                | 1 << CCL_ENABLE_bp     /* LUT Enable: enabled */
	                | 1 << CCL_OUTEN_bp;     /* Output Enable: enabled */

	CCL.CTRLA = 1 << CCL_ENABLE_bp      /* Enable: enabled */
     1b6:	81 e4       	ldi	r24, 0x41	; 65
     1b8:	80 83       	st	Z, r24
	            | 1 << CCL_RUNSTDBY_bp; /* Run in Standby: enabled */

	return 0;
}
     1ba:	80 e0       	ldi	r24, 0x00	; 0
     1bc:	08 95       	ret

000001be <CLKCTRL_init>:
 *       on calling convention. The memory model is not visible to the
 *       preprocessor, so it must be defined in the Assembler preprocessor directives.
 */
static inline void ccp_write_io(void *addr, uint8_t value)
{
	protected_write_io(addr, CCP_IOREG_gc, value);
     1be:	47 e0       	ldi	r20, 0x07	; 7
     1c0:	68 ed       	ldi	r22, 0xD8	; 216
     1c2:	8c e7       	ldi	r24, 0x7C	; 124
     1c4:	90 e0       	ldi	r25, 0x00	; 0
     1c6:	ad d0       	rcall	.+346    	; 0x322 <protected_write_io>
     1c8:	41 e0       	ldi	r20, 0x01	; 1
     1ca:	68 ed       	ldi	r22, 0xD8	; 216
     1cc:	81 e6       	ldi	r24, 0x61	; 97
     1ce:	90 e0       	ldi	r25, 0x00	; 0
     1d0:	a8 d0       	rcall	.+336    	; 0x322 <protected_write_io>
	//		 | 0 << CLKCTRL_CLKOUT_bp /* System clock out: disabled */);

	// ccp_write_io((void*)&(CLKCTRL.MCLKLOCK),0 << CLKCTRL_LOCKEN_bp /* lock enable: disabled */);

	return 0;
}
     1d2:	80 e0       	ldi	r24, 0x00	; 0
     1d4:	08 95       	ret

000001d6 <CPUINT_init>:

	// CPUINT.LVL0PRI = 0x0 << CPUINT_LVL0PRI_gp; /* Interrupt Level Priority: 0x0 */

	// CPUINT.LVL1VEC = 0x0 << CPUINT_LVL1VEC_gp; /* Interrupt Vector with High Priority: 0x0 */

	ENABLE_INTERRUPTS();
     1d6:	78 94       	sei

	return 0;
}
     1d8:	80 e0       	ldi	r24, 0x00	; 0
     1da:	08 95       	ret

000001dc <DAC_init>:
 *
 * \return Nothing
 */
void DAC_disable()
{
	DAC0.CTRLA &= ~DAC_ENABLE_bm;
     1dc:	81 e4       	ldi	r24, 0x41	; 65
     1de:	80 93 80 06 	sts	0x0680, r24	; 0x800680 <__TEXT_REGION_LENGTH__+0x700680>
     1e2:	80 e0       	ldi	r24, 0x00	; 0
     1e4:	08 95       	ret

000001e6 <DAC_set_output>:
 *
 * \return Nothing
 */
void DAC_set_output(dac_resolution_t value)
{
	DAC0.DATA = value;
     1e6:	80 93 81 06 	sts	0x0681, r24	; 0x800681 <__TEXT_REGION_LENGTH__+0x700681>
     1ea:	08 95       	ret

000001ec <mcu_init>:
#ifdef __cplusplus
extern "C" {
#endif

void mcu_init(void)
{
     1ec:	e0 e1       	ldi	r30, 0x10	; 16
     1ee:	f4 e0       	ldi	r31, 0x04	; 4
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     1f0:	80 81       	ld	r24, Z
     1f2:	88 60       	ori	r24, 0x08	; 8
     1f4:	81 93       	st	Z+, r24
	 * disables all peripherals to save power. Driver shall enable
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
     1f6:	e8 31       	cpi	r30, 0x18	; 24
     1f8:	84 e0       	ldi	r24, 0x04	; 4
     1fa:	f8 07       	cpc	r31, r24
     1fc:	c9 f7       	brne	.-14     	; 0x1f0 <mcu_init+0x4>
     1fe:	e0 e3       	ldi	r30, 0x30	; 48
     200:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     202:	80 81       	ld	r24, Z
     204:	88 60       	ori	r24, 0x08	; 8
     206:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     208:	e8 33       	cpi	r30, 0x38	; 56
     20a:	84 e0       	ldi	r24, 0x04	; 4
     20c:	f8 07       	cpc	r31, r24
     20e:	c9 f7       	brne	.-14     	; 0x202 <mcu_init+0x16>
     210:	e0 e5       	ldi	r30, 0x50	; 80
     212:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     214:	80 81       	ld	r24, Z
     216:	88 60       	ori	r24, 0x08	; 8
     218:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     21a:	e8 35       	cpi	r30, 0x58	; 88
     21c:	84 e0       	ldi	r24, 0x04	; 4
     21e:	f8 07       	cpc	r31, r24
     220:	c9 f7       	brne	.-14     	; 0x214 <mcu_init+0x28>
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}
}
     222:	08 95       	ret

00000224 <ADC_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     224:	e5 e1       	ldi	r30, 0x15	; 21
     226:	f4 e0       	ldi	r31, 0x04	; 4
     228:	80 81       	ld	r24, Z
     22a:	88 7f       	andi	r24, 0xF8	; 248
     22c:	84 60       	ori	r24, 0x04	; 4
     22e:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     230:	80 81       	ld	r24, Z
     232:	87 7f       	andi	r24, 0xF7	; 247
     234:	80 83       	st	Z, r24
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     236:	e7 e1       	ldi	r30, 0x17	; 23
     238:	f4 e0       	ldi	r31, 0x04	; 4
     23a:	80 81       	ld	r24, Z
     23c:	88 7f       	andi	r24, 0xF8	; 248
     23e:	84 60       	ori	r24, 0x04	; 4
     240:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     242:	80 81       	ld	r24, Z
     244:	87 7f       	andi	r24, 0xF7	; 247
     246:	80 83       	st	Z, r24
 */
static inline void PORTB_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     248:	e4 e3       	ldi	r30, 0x34	; 52
     24a:	f4 e0       	ldi	r31, 0x04	; 4
     24c:	80 81       	ld	r24, Z
     24e:	88 7f       	andi	r24, 0xF8	; 248
     250:	84 60       	ori	r24, 0x04	; 4
     252:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     254:	80 81       	ld	r24, Z
     256:	87 7f       	andi	r24, 0xF7	; 247
     258:	80 83       	st	Z, r24
 */
static inline void PORTB_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     25a:	e1 e3       	ldi	r30, 0x31	; 49
     25c:	f4 e0       	ldi	r31, 0x04	; 4
     25e:	80 81       	ld	r24, Z
     260:	88 7f       	andi	r24, 0xF8	; 248
     262:	84 60       	ori	r24, 0x04	; 4
     264:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     266:	80 81       	ld	r24, Z
     268:	87 7f       	andi	r24, 0xF7	; 247
     26a:	80 83       	st	Z, r24
 */
static inline void PORTB_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     26c:	e0 e3       	ldi	r30, 0x30	; 48
     26e:	f4 e0       	ldi	r31, 0x04	; 4
     270:	80 81       	ld	r24, Z
     272:	88 7f       	andi	r24, 0xF8	; 248
     274:	84 60       	ori	r24, 0x04	; 4
     276:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     278:	80 81       	ld	r24, Z
     27a:	87 7f       	andi	r24, 0xF7	; 247
     27c:	80 83       	st	Z, r24
	// Disable digital input buffer
	DEN4_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	DEN4_PIN_set_pull_mode(PORT_PULL_OFF);

	ADC_init();
     27e:	75 df       	rcall	.-278    	; 0x16a <ADC_init>
     280:	08 95       	ret

00000282 <USART_0_initialization>:
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     282:	23 98       	cbi	0x04, 3	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     284:	e3 e3       	ldi	r30, 0x33	; 51
     286:	f4 e0       	ldi	r31, 0x04	; 4
     288:	80 81       	ld	r24, Z
     28a:	87 7f       	andi	r24, 0xF7	; 247
     28c:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     28e:	22 9a       	sbi	0x04, 2	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     290:	2a 98       	cbi	0x05, 2	; 5
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	USART_0_init();
     292:	07 d1       	rcall	.+526    	; 0x4a2 <USART_0_init>
     294:	08 95       	ret

00000296 <TIMER_0_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     296:	25 9a       	sbi	0x04, 5	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     298:	2d 98       	cbi	0x05, 5	; 5
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLC |= PORTMUX_TCA02_bm;
     29a:	e0 e0       	ldi	r30, 0x00	; 0
     29c:	f2 e0       	ldi	r31, 0x02	; 2
     29e:	82 81       	ldd	r24, Z+2	; 0x02
     2a0:	84 60       	ori	r24, 0x04	; 4
     2a2:	82 83       	std	Z+2, r24	; 0x02

	TIMER_0_init();
     2a4:	ee d0       	rcall	.+476    	; 0x482 <TIMER_0_init>
     2a6:	08 95       	ret

000002a8 <DIGGSIGG_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTC.DIR |= (1 << pin);
     2a8:	41 9a       	sbi	0x08, 1	; 8
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
	} else {
		VPORTC.OUT &= ~(1 << pin);
     2aa:	49 98       	cbi	0x09, 1	; 9
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLA |= PORTMUX_LUT1_bm;
     2ac:	e0 e0       	ldi	r30, 0x00	; 0
     2ae:	f2 e0       	ldi	r31, 0x02	; 2
     2b0:	80 81       	ld	r24, Z
     2b2:	80 62       	ori	r24, 0x20	; 32
     2b4:	80 83       	st	Z, r24

	DIGGSIGG_init();
     2b6:	75 df       	rcall	.-278    	; 0x1a2 <DIGGSIGG_init>
     2b8:	08 95       	ret

000002ba <SPI_0_initialization>:
 */
static inline void PORTA_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
     2ba:	02 98       	cbi	0x00, 2	; 0
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2bc:	e2 e1       	ldi	r30, 0x12	; 18
     2be:	f4 e0       	ldi	r31, 0x04	; 4
     2c0:	80 81       	ld	r24, Z
     2c2:	87 7f       	andi	r24, 0xF7	; 247
     2c4:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     2c6:	01 9a       	sbi	0x00, 1	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     2c8:	09 98       	cbi	0x01, 1	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     2ca:	03 9a       	sbi	0x00, 3	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     2cc:	0b 98       	cbi	0x01, 3	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     2ce:	04 9a       	sbi	0x00, 4	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     2d0:	0c 98       	cbi	0x01, 4	; 1
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	SPI_0_init();
     2d2:	cf d0       	rcall	.+414    	; 0x472 <SPI_0_init>
     2d4:	08 95       	ret

000002d6 <DAC_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     2d6:	e6 e1       	ldi	r30, 0x16	; 22
     2d8:	f4 e0       	ldi	r31, 0x04	; 4
     2da:	80 81       	ld	r24, Z
     2dc:	88 7f       	andi	r24, 0xF8	; 248
     2de:	84 60       	ori	r24, 0x04	; 4
     2e0:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2e2:	80 81       	ld	r24, Z
     2e4:	87 7f       	andi	r24, 0xF7	; 247
     2e6:	80 83       	st	Z, r24
	// Disable digital input buffer
	AXON_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	AXON_PIN_set_pull_mode(PORT_PULL_OFF);

	DAC_init();
     2e8:	79 df       	rcall	.-270    	; 0x1dc <DAC_init>
     2ea:	08 95       	ret

000002ec <system_init>:
/**
 * \brief System initialization
 */
void system_init()
{
	mcu_init();
     2ec:	7f df       	rcall	.-258    	; 0x1ec <mcu_init>
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     2ee:	27 98       	cbi	0x04, 7	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2f0:	e7 e3       	ldi	r30, 0x37	; 55
     2f2:	f4 e0       	ldi	r31, 0x04	; 4
     2f4:	80 81       	ld	r24, Z
     2f6:	87 7f       	andi	r24, 0xF7	; 247
     2f8:	80 83       	st	Z, r24
 */
static inline void PORTC_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
     2fa:	42 98       	cbi	0x08, 2	; 8
static inline void PORTC_set_pin_pull_mode(const uint8_t pin, const enum port_pull_mode pull_mode)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
     2fc:	e2 e5       	ldi	r30, 0x52	; 82
     2fe:	f4 e0       	ldi	r31, 0x04	; 4
     300:	80 81       	ld	r24, Z
     302:	88 60       	ori	r24, 0x08	; 8
     304:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTC.DIR |= (1 << pin);
     306:	45 9a       	sbi	0x08, 5	; 8
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     308:	4d 9a       	sbi	0x09, 5	; 9
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    true);

	CLKCTRL_init();
     30a:	59 df       	rcall	.-334    	; 0x1be <CLKCTRL_init>

	RTC_init();
     30c:	94 d0       	rcall	.+296    	; 0x436 <RTC_init>

	ADC_initialization();
     30e:	8a df       	rcall	.-236    	; 0x224 <ADC_initialization>

	USART_0_initialization();
     310:	b8 df       	rcall	.-144    	; 0x282 <USART_0_initialization>

	TIMER_0_initialization();
     312:	c1 df       	rcall	.-126    	; 0x296 <TIMER_0_initialization>

	DIGGSIGG_initialization();
     314:	c9 df       	rcall	.-110    	; 0x2a8 <DIGGSIGG_initialization>

	SPI_0_initialization();
     316:	d1 df       	rcall	.-94     	; 0x2ba <SPI_0_initialization>

	DAC_initialization();
     318:	de df       	rcall	.-68     	; 0x2d6 <DAC_initialization>

	CPUINT_init();
     31a:	5d df       	rcall	.-326    	; 0x1d6 <CPUINT_init>

	SLPCTRL_init();
     31c:	a8 d0       	rcall	.+336    	; 0x46e <SLPCTRL_init>

	BOD_init();
     31e:	3f df       	rcall	.-386    	; 0x19e <BOD_init>
     320:	08 95       	ret

00000322 <protected_write_io>:
#if defined(__GNUC__)
  
#ifdef RAMPZ
	out     _SFR_IO_ADDR(RAMPZ), r1         // Clear bits 23:16 of Z
#endif
	movw    r30, r24                // Load addr into Z
     322:	fc 01       	movw	r30, r24
	out     CCP, r22                // Start CCP handshake
     324:	64 bf       	out	0x34, r22	; 52
	st      Z, r20                  // Write value to I/O register
     326:	40 83       	st	Z, r20
	ret                             // Return to caller
     328:	08 95       	ret

0000032a <enqueue>:
 */ 
#include <stdio.h>
#include <stdlib.h>
#include "include/queue.h"

void enqueue(node_t **head, uint32_t val) {
     32a:	cf 92       	push	r12
     32c:	df 92       	push	r13
     32e:	ef 92       	push	r14
     330:	ff 92       	push	r15
     332:	cf 93       	push	r28
     334:	df 93       	push	r29
     336:	ec 01       	movw	r28, r24
     338:	6a 01       	movw	r12, r20
     33a:	7b 01       	movw	r14, r22
	// remember, head is at the very BACK of the queue (The element that will wait the longest until dequeued)
	
	// we create a new empty node
	node_t *new_node = malloc(sizeof(node_t));
     33c:	86 e0       	ldi	r24, 0x06	; 6
     33e:	90 e0       	ldi	r25, 0x00	; 0
     340:	c7 d7       	rcall	.+3982   	; 0x12d0 <malloc>
	// Not quite sure what happens here, but it seems to be some sort of error handling, except you never know if there has been an error :/
	if (!new_node) return;
     342:	00 97       	sbiw	r24, 0x00	; 0
     344:	59 f0       	breq	.+22     	; 0x35c <enqueue+0x32>

	// we configure our node
	new_node->val = val;
     346:	fc 01       	movw	r30, r24
     348:	c0 82       	st	Z, r12
     34a:	d1 82       	std	Z+1, r13	; 0x01
     34c:	e2 82       	std	Z+2, r14	; 0x02
     34e:	f3 82       	std	Z+3, r15	; 0x03
	new_node->next = *head;
     350:	28 81       	ld	r18, Y
     352:	39 81       	ldd	r19, Y+1	; 0x01
     354:	24 83       	std	Z+4, r18	; 0x04
     356:	35 83       	std	Z+5, r19	; 0x05

	// and lastly, we change the pointer pointing to the previous head node, to point to our new node instead
	*head = new_node;
     358:	88 83       	st	Y, r24
     35a:	99 83       	std	Y+1, r25	; 0x01
}
     35c:	df 91       	pop	r29
     35e:	cf 91       	pop	r28
     360:	ff 90       	pop	r15
     362:	ef 90       	pop	r14
     364:	df 90       	pop	r13
     366:	cf 90       	pop	r12
     368:	08 95       	ret

0000036a <dequeue>:

uint32_t dequeue(node_t **head) {
     36a:	cf 92       	push	r12
     36c:	df 92       	push	r13
     36e:	ef 92       	push	r14
     370:	ff 92       	push	r15
     372:	0f 93       	push	r16
     374:	1f 93       	push	r17
     376:	cf 93       	push	r28
     378:	df 93       	push	r29
	node_t *current, *prev = NULL;
	uint32_t retval = 0;

	// If the queue we have been given is empty, we return an error
	// (0 is usually not an error, but it is probably the best option)
	if (*head == NULL) return 0;
     37a:	dc 01       	movw	r26, r24
     37c:	ed 91       	ld	r30, X+
     37e:	fc 91       	ld	r31, X
     380:	30 97       	sbiw	r30, 0x00	; 0
     382:	11 f1       	breq	.+68     	; 0x3c8 <dequeue+0x5e>
     384:	c0 e0       	ldi	r28, 0x00	; 0
     386:	d0 e0       	ldi	r29, 0x00	; 0
     388:	02 c0       	rjmp	.+4      	; 0x38e <dequeue+0x24>
     38a:	ef 01       	movw	r28, r30

	// Now we iterate through the queue until we reach the end
	current = *head;
	while (current->next != NULL) {
		prev = current;
		current = current->next;
     38c:	f9 01       	movw	r30, r18
	// (0 is usually not an error, but it is probably the best option)
	if (*head == NULL) return 0;

	// Now we iterate through the queue until we reach the end
	current = *head;
	while (current->next != NULL) {
     38e:	24 81       	ldd	r18, Z+4	; 0x04
     390:	35 81       	ldd	r19, Z+5	; 0x05
     392:	21 15       	cp	r18, r1
     394:	31 05       	cpc	r19, r1
     396:	c9 f7       	brne	.-14     	; 0x38a <dequeue+0x20>
     398:	8c 01       	movw	r16, r24
		prev = current;
		current = current->next;
	}

	// We retrieve the value we needed
	retval = current->val;
     39a:	c0 80       	ld	r12, Z
     39c:	d1 80       	ldd	r13, Z+1	; 0x01
     39e:	e2 80       	ldd	r14, Z+2	; 0x02
     3a0:	f3 80       	ldd	r15, Z+3	; 0x03
	// and remove the last element of the queue from the queue
	free(current);
     3a2:	cf 01       	movw	r24, r30
     3a4:	2d d8       	rcall	.-4006   	; 0xfffff400 <__eeprom_end+0xff7ef400>
	
	// Now we update the previous node so that it becomes the front of the queue
	// In case the queue only had one element, the prev will be null (false)
	if (prev){
     3a6:	20 97       	sbiw	r28, 0x00	; 0
     3a8:	39 f0       	breq	.+14     	; 0x3b8 <dequeue+0x4e>
	prev->next = NULL;}
     3aa:	1c 82       	std	Y+4, r1	; 0x04
     3ac:	1d 82       	std	Y+5, r1	; 0x05
	else{
	*head = NULL;}

	return retval;
     3ae:	6c 2d       	mov	r22, r12
     3b0:	7d 2d       	mov	r23, r13
     3b2:	8e 2d       	mov	r24, r14
     3b4:	9f 2d       	mov	r25, r15
     3b6:	0c c0       	rjmp	.+24     	; 0x3d0 <dequeue+0x66>
	// Now we update the previous node so that it becomes the front of the queue
	// In case the queue only had one element, the prev will be null (false)
	if (prev){
	prev->next = NULL;}
	else{
	*head = NULL;}
     3b8:	f8 01       	movw	r30, r16
     3ba:	10 82       	st	Z, r1
     3bc:	11 82       	std	Z+1, r1	; 0x01

	return retval;
     3be:	6c 2d       	mov	r22, r12
     3c0:	7d 2d       	mov	r23, r13
     3c2:	8e 2d       	mov	r24, r14
     3c4:	9f 2d       	mov	r25, r15
     3c6:	04 c0       	rjmp	.+8      	; 0x3d0 <dequeue+0x66>
	node_t *current, *prev = NULL;
	uint32_t retval = 0;

	// If the queue we have been given is empty, we return an error
	// (0 is usually not an error, but it is probably the best option)
	if (*head == NULL) return 0;
     3c8:	60 e0       	ldi	r22, 0x00	; 0
     3ca:	70 e0       	ldi	r23, 0x00	; 0
     3cc:	80 e0       	ldi	r24, 0x00	; 0
     3ce:	90 e0       	ldi	r25, 0x00	; 0
	prev->next = NULL;}
	else{
	*head = NULL;}

	return retval;
}
     3d0:	df 91       	pop	r29
     3d2:	cf 91       	pop	r28
     3d4:	1f 91       	pop	r17
     3d6:	0f 91       	pop	r16
     3d8:	ff 90       	pop	r15
     3da:	ef 90       	pop	r14
     3dc:	df 90       	pop	r13
     3de:	cf 90       	pop	r12
     3e0:	08 95       	ret

000003e2 <dequeue_top>:

// Here we remove the element of the queue that was added last (first in, last out)
uint32_t dequeue_top(node_t **head){
     3e2:	cf 92       	push	r12
     3e4:	df 92       	push	r13
     3e6:	ef 92       	push	r14
     3e8:	ff 92       	push	r15
     3ea:	0f 93       	push	r16
     3ec:	1f 93       	push	r17
     3ee:	cf 93       	push	r28
     3f0:	df 93       	push	r29
	node_t *oldHead;
	uint32_t retval = 0;
	
	// If the queue we have been given is empty, we return an error
	// (0 is usually not an error, but it is probably the best option)
	if (*head == NULL) return 0;
     3f2:	dc 01       	movw	r26, r24
     3f4:	ed 91       	ld	r30, X+
     3f6:	fc 91       	ld	r31, X
     3f8:	30 97       	sbiw	r30, 0x00	; 0
     3fa:	81 f0       	breq	.+32     	; 0x41c <__LOCK_REGION_LENGTH__+0x1c>
     3fc:	ec 01       	movw	r28, r24
	
	oldHead = *head;
	// We then set the new head to be the second last in the queue
	newHead = oldHead->next;
     3fe:	c4 80       	ldd	r12, Z+4	; 0x04
     400:	d5 80       	ldd	r13, Z+5	; 0x05
	
	// We retrieve the heads value
	retval = oldHead->val;
     402:	e0 80       	ld	r14, Z
     404:	f1 80       	ldd	r15, Z+1	; 0x01
     406:	02 81       	ldd	r16, Z+2	; 0x02
     408:	13 81       	ldd	r17, Z+3	; 0x03
	
	// We free the memory that was used to store the old head
	free(oldHead);
     40a:	cf 01       	movw	r24, r30
     40c:	f9 d7       	rcall	.+4082   	; 0x1400 <free>
	
	//And then we overwrite the value of head to be the second last
	*head = newHead;
     40e:	c8 82       	st	Y, r12
     410:	d9 82       	std	Y+1, r13	; 0x01
	
	return retval;
     412:	6e 2d       	mov	r22, r14
     414:	7f 2d       	mov	r23, r15
     416:	80 2f       	mov	r24, r16
     418:	91 2f       	mov	r25, r17
     41a:	04 c0       	rjmp	.+8      	; 0x424 <__LOCK_REGION_LENGTH__+0x24>
	node_t *oldHead;
	uint32_t retval = 0;
	
	// If the queue we have been given is empty, we return an error
	// (0 is usually not an error, but it is probably the best option)
	if (*head == NULL) return 0;
     41c:	60 e0       	ldi	r22, 0x00	; 0
     41e:	70 e0       	ldi	r23, 0x00	; 0
     420:	80 e0       	ldi	r24, 0x00	; 0
     422:	90 e0       	ldi	r25, 0x00	; 0
	//And then we overwrite the value of head to be the second last
	*head = newHead;
	
	return retval;
	
}
     424:	df 91       	pop	r29
     426:	cf 91       	pop	r28
     428:	1f 91       	pop	r17
     42a:	0f 91       	pop	r16
     42c:	ff 90       	pop	r15
     42e:	ef 90       	pop	r14
     430:	df 90       	pop	r13
     432:	cf 90       	pop	r12
     434:	08 95       	ret

00000436 <RTC_init>:
 * \return Initialization status.
 */
int8_t RTC_init()
{

	while (RTC.STATUS > 0) { /* Wait for all register to be synchronized */
     436:	e0 e4       	ldi	r30, 0x40	; 64
     438:	f1 e0       	ldi	r31, 0x01	; 1
     43a:	81 81       	ldd	r24, Z+1	; 0x01
     43c:	81 11       	cpse	r24, r1
     43e:	fd cf       	rjmp	.-6      	; 0x43a <RTC_init+0x4>
	}

	// RTC.CMP = 0x0; /* Compare: 0x0 */

	RTC.CNT = 0x20; /* Counter: 0x20 */
     440:	e0 e4       	ldi	r30, 0x40	; 64
     442:	f1 e0       	ldi	r31, 0x01	; 1
     444:	80 e2       	ldi	r24, 0x20	; 32
     446:	90 e0       	ldi	r25, 0x00	; 0
     448:	80 87       	std	Z+8, r24	; 0x08
     44a:	91 87       	std	Z+9, r25	; 0x09

	RTC.CTRLA = RTC_PRESCALER_DIV1_gc   /* 1 */
     44c:	81 e8       	ldi	r24, 0x81	; 129
     44e:	80 83       	st	Z, r24
	            | 1 << RTC_RTCEN_bp     /* Enable: enabled */
	            | 1 << RTC_RUNSTDBY_bp; /* Run In Standby: enabled */

	RTC.PER = 0x20 / TIMESCALE; /* Period: 0x20 */
     450:	80 e8       	ldi	r24, 0x80	; 128
     452:	9c e0       	ldi	r25, 0x0C	; 12
     454:	82 87       	std	Z+10, r24	; 0x0a
     456:	93 87       	std	Z+11, r25	; 0x0b

	// RTC.CLKSEL = RTC_CLKSEL_INT32K_gc; /* 32KHz Internal Ultra Low Power Oscillator (OSCULP32K) */

	RTC.DBGCTRL = 1 << RTC_DBGRUN_bp; /* Run in debug: enabled */
     458:	81 e0       	ldi	r24, 0x01	; 1
     45a:	85 83       	std	Z+5, r24	; 0x05

	RTC.INTCTRL = 0 << RTC_CMP_bp    /* Compare Match Interrupt enable: disabled */
     45c:	82 83       	std	Z+2, r24	; 0x02
	              | 1 << RTC_OVF_bp; /* Overflow Interrupt enable: enabled */

	while (RTC.PITSTATUS > 0) { /* Wait for all register to be synchronized */
     45e:	81 89       	ldd	r24, Z+17	; 0x11
     460:	81 11       	cpse	r24, r1
     462:	fd cf       	rjmp	.-6      	; 0x45e <RTC_init+0x28>
	}

	RTC.PITCTRLA = RTC_PERIOD_OFF_gc    /* Off */
     464:	81 e0       	ldi	r24, 0x01	; 1
     466:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <__TEXT_REGION_LENGTH__+0x700150>
	// RTC.PITDBGCTRL = 0 << RTC_DBGRUN_bp; /* Run in debug: disabled */

	// RTC.PITINTCTRL = 0 << RTC_PI_bp; /* Periodic Interrupt: disabled */

	return 0;
}
     46a:	80 e0       	ldi	r24, 0x00	; 0
     46c:	08 95       	ret

0000046e <SLPCTRL_init>:

	// SLPCTRL.CTRLA = 0 << SLPCTRL_SEN_bp /* Sleep enable: disabled */
	//		 | SLPCTRL_SMODE_IDLE_gc; /* Idle mode */

	return 0;
}
     46e:	80 e0       	ldi	r24, 0x00	; 0
     470:	08 95       	ret

00000472 <SPI_0_init>:
 * \return Initialization status
 */
int8_t SPI_0_init()
{

	SPI0.CTRLA = 0 << SPI_CLK2X_bp     /* Enable Double Speed: disabled */
     472:	e0 e2       	ldi	r30, 0x20	; 32
     474:	f8 e0       	ldi	r31, 0x08	; 8
     476:	83 e2       	ldi	r24, 0x23	; 35
     478:	80 83       	st	Z, r24
	             | 0 << SPI_DORD_bp    /* Data Order Setting: disabled */
	             | 1 << SPI_ENABLE_bp  /* Enable Module: enabled */
	             | 1 << SPI_MASTER_bp  /* SPI module in master mode */
	             | SPI_PRESC_DIV16_gc; /* System Clock / 16 */

	SPI0.CTRLB = 0 << SPI_BUFEN_bp   /* Buffer Mode Enable: disabled */
     47a:	84 e0       	ldi	r24, 0x04	; 4
     47c:	81 83       	std	Z+1, r24	; 0x01
	//		 | 0 << SPI_RXCIE_bp /* Receive Complete Interrupt Enable: disabled */
	//		 | 0 << SPI_SSIE_bp /* Slave Select Trigger Interrupt Enable: disabled */
	//		 | 0 << SPI_TXCIE_bp; /* Transfer Complete Interrupt Enable: disabled */

	return 0;
}
     47e:	80 e0       	ldi	r24, 0x00	; 0
     480:	08 95       	ret

00000482 <TIMER_0_init>:

	// TCA0.SINGLE.CMP0 = 0x0; /* Compare Register 0: 0x0 */

	// TCA0.SINGLE.CMP1 = 0x0; /* Compare Register 1: 0x0 */

	TCA0.SINGLE.CMP2 = 0x4; /* Compare Register 2: 0x4 */
     482:	e0 e0       	ldi	r30, 0x00	; 0
     484:	fa e0       	ldi	r31, 0x0A	; 10
     486:	84 e0       	ldi	r24, 0x04	; 4
     488:	90 e0       	ldi	r25, 0x00	; 0
     48a:	84 a7       	std	Z+44, r24	; 0x2c
     48c:	95 a7       	std	Z+45, r25	; 0x2d

	// TCA0.SINGLE.CNT = 0x0; /* Count: 0x0 */

	TCA0.SINGLE.CTRLB = 0 << TCA_SINGLE_ALUPD_bp            /* Auto Lock Update: disabled */
     48e:	83 e4       	ldi	r24, 0x43	; 67
     490:	81 83       	std	Z+1, r24	; 0x01
	                    | 0 << TCA_SINGLE_CMP0EN_bp         /* Compare 0 Enable: disabled */
	                    | 0 << TCA_SINGLE_CMP1EN_bp         /* Compare 1 Enable: disabled */
	                    | 1 << TCA_SINGLE_CMP2EN_bp         /* Compare 2 Enable: enabled */
	                    | TCA_SINGLE_WGMODE_SINGLESLOPE_gc; /*  */

	TCA0.SINGLE.CTRLC = 0 << TCA_SINGLE_CMP0OV_bp    /* Compare 0 Waveform Output Value: disabled */
     492:	84 e0       	ldi	r24, 0x04	; 4
     494:	82 83       	std	Z+2, r24	; 0x02
	// TCA0.SINGLE.INTCTRL = 0 << TCA_SINGLE_CMP0_bp /* Compare 0 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP1_bp /* Compare 1 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP2_bp /* Compare 2 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_OVF_bp; /* Overflow Interrupt: disabled */

	TCA0.SINGLE.PER = 0x7; /* Period: 0x7 */
     496:	87 e0       	ldi	r24, 0x07	; 7
     498:	90 e0       	ldi	r25, 0x00	; 0
     49a:	86 a3       	std	Z+38, r24	; 0x26
     49c:	97 a3       	std	Z+39, r25	; 0x27

	// TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV1_gc /* System Clock */
	//		 | 0 << TCA_SINGLE_ENABLE_bp; /* Module Enable: disabled */

	return 0;
}
     49e:	80 e0       	ldi	r24, 0x00	; 0
     4a0:	08 95       	ret

000004a2 <USART_0_init>:
uint8_t USART_0_read()
{
	while (!(USART0.STATUS & USART_RXCIF_bm))
		;
	return USART0.RXDATAL;
}
     4a2:	e0 e0       	ldi	r30, 0x00	; 0
     4a4:	f8 e0       	ldi	r31, 0x08	; 8
     4a6:	87 e4       	ldi	r24, 0x47	; 71
     4a8:	90 e1       	ldi	r25, 0x10	; 16
     4aa:	80 87       	std	Z+8, r24	; 0x08
     4ac:	91 87       	std	Z+9, r25	; 0x09
     4ae:	80 ec       	ldi	r24, 0xC0	; 192
     4b0:	86 83       	std	Z+6, r24	; 0x06
     4b2:	86 e0       	ldi	r24, 0x06	; 6
     4b4:	9e e3       	ldi	r25, 0x3E	; 62
     4b6:	80 93 6d 3e 	sts	0x3E6D, r24	; 0x803e6d <__iob+0x2>
     4ba:	90 93 6e 3e 	sts	0x3E6E, r25	; 0x803e6e <__iob+0x3>
     4be:	80 e0       	ldi	r24, 0x00	; 0
     4c0:	08 95       	ret

000004c2 <USART_0_write>:
 *
 * \return Nothing
 */
void USART_0_write(const uint8_t data)
{
	while (!(USART0.STATUS & USART_DREIF_bm))
     4c2:	e0 e0       	ldi	r30, 0x00	; 0
     4c4:	f8 e0       	ldi	r31, 0x08	; 8
     4c6:	94 81       	ldd	r25, Z+4	; 0x04
     4c8:	95 ff       	sbrs	r25, 5
     4ca:	fd cf       	rjmp	.-6      	; 0x4c6 <USART_0_write+0x4>
		;
	USART0.TXDATAL = data;
     4cc:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <__TEXT_REGION_LENGTH__+0x700802>
     4d0:	08 95       	ret

000004d2 <USART_0_printCHAR>:

#if defined(__GNUC__)

int USART_0_printCHAR(char character, FILE *stream)
{
	USART_0_write(character);
     4d2:	f7 df       	rcall	.-18     	; 0x4c2 <USART_0_write>
	return 0;
}
     4d4:	80 e0       	ldi	r24, 0x00	; 0
     4d6:	90 e0       	ldi	r25, 0x00	; 0
     4d8:	08 95       	ret

000004da <tinyCharge_is_charging>:

_Bool charging;

_Bool tinyCharge_is_charging(){
	return charging;
}
     4da:	80 91 62 3e 	lds	r24, 0x3E62	; 0x803e62 <charging>
     4de:	08 95       	ret

000004e0 <tinyCharge_set_charging>:

void tinyCharge_set_charging(_Bool charging_status){
	charging = charging_status;
     4e0:	80 93 62 3e 	sts	0x3E62, r24	; 0x803e62 <charging>
     4e4:	08 95       	ret

000004e6 <tinyCharge_set_transistors>:
}


void tinyCharge_set_transistors(){
	if(charging){
     4e6:	80 91 62 3e 	lds	r24, 0x3E62	; 0x803e62 <charging>
     4ea:	88 23       	and	r24, r24
     4ec:	11 f0       	breq	.+4      	; 0x4f2 <tinyCharge_set_transistors+0xc>
	} else {
		VPORTC.OUT &= ~(1 << pin);
     4ee:	4d 98       	cbi	0x09, 5	; 9
     4f0:	08 95       	ret
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     4f2:	4d 9a       	sbi	0x09, 5	; 9
     4f4:	08 95       	ret

000004f6 <tinyDebugger_send_int>:
	dtostrf(value,1,NUMBER_OF_DECIMALS, number);
	printf("%s:%s;", name, number);
}
void tinyDebugger_send_string(const char* name, char * value){
	printf("%s:%s;", name, value);
}
     4f6:	7f 93       	push	r23
     4f8:	6f 93       	push	r22
     4fa:	9f 93       	push	r25
     4fc:	8f 93       	push	r24
     4fe:	80 e6       	ldi	r24, 0x60	; 96
     500:	9f e9       	ldi	r25, 0x9F	; 159
     502:	9f 93       	push	r25
     504:	8f 93       	push	r24
     506:	05 d8       	rcall	.-4086   	; 0xfffff512 <__eeprom_end+0xff7ef512>
     508:	0f 90       	pop	r0
     50a:	0f 90       	pop	r0
     50c:	0f 90       	pop	r0
     50e:	0f 90       	pop	r0
     510:	0f 90       	pop	r0
     512:	0f 90       	pop	r0
     514:	08 95       	ret

00000516 <tinyDebugger_send_float>:
     516:	cf 92       	push	r12
     518:	df 92       	push	r13
     51a:	ef 92       	push	r14
     51c:	ff 92       	push	r15
     51e:	0f 93       	push	r16
     520:	1f 93       	push	r17
     522:	cf 93       	push	r28
     524:	df 93       	push	r29
     526:	cd b7       	in	r28, 0x3d	; 61
     528:	de b7       	in	r29, 0x3e	; 62
     52a:	64 97       	sbiw	r28, 0x14	; 20
     52c:	cd bf       	out	0x3d, r28	; 61
     52e:	de bf       	out	0x3e, r29	; 62
     530:	d8 2e       	mov	r13, r24
     532:	c9 2e       	mov	r12, r25
     534:	cb 01       	movw	r24, r22
     536:	ba 01       	movw	r22, r20
     538:	9e 01       	movw	r18, r28
     53a:	2f 5f       	subi	r18, 0xFF	; 255
     53c:	3f 4f       	sbci	r19, 0xFF	; 255
     53e:	79 01       	movw	r14, r18
     540:	89 01       	movw	r16, r18
     542:	21 e0       	ldi	r18, 0x01	; 1
     544:	41 e0       	ldi	r20, 0x01	; 1
     546:	a5 d6       	rcall	.+3402   	; 0x1292 <dtostrf>
     548:	ff 92       	push	r15
     54a:	ef 92       	push	r14
     54c:	cf 92       	push	r12
     54e:	df 92       	push	r13
     550:	87 e6       	ldi	r24, 0x67	; 103
     552:	9f e9       	ldi	r25, 0x9F	; 159
     554:	9f 93       	push	r25
     556:	8f 93       	push	r24
     558:	dc d7       	rcall	.+4024   	; 0x1512 <printf>
     55a:	0f 90       	pop	r0
     55c:	0f 90       	pop	r0
     55e:	0f 90       	pop	r0
     560:	0f 90       	pop	r0
     562:	0f 90       	pop	r0
     564:	0f 90       	pop	r0
     566:	64 96       	adiw	r28, 0x14	; 20
     568:	cd bf       	out	0x3d, r28	; 61
     56a:	de bf       	out	0x3e, r29	; 62
     56c:	df 91       	pop	r29
     56e:	cf 91       	pop	r28
     570:	1f 91       	pop	r17
     572:	0f 91       	pop	r16
     574:	ff 90       	pop	r15
     576:	ef 90       	pop	r14
     578:	df 90       	pop	r13
     57a:	cf 90       	pop	r12
     57c:	08 95       	ret

0000057e <tinyDebugger_end_line>:
void tinyDebugger_end_line(){
	printf("\r\n");
     57e:	8e e6       	ldi	r24, 0x6E	; 110
     580:	9f e9       	ldi	r25, 0x9F	; 159
     582:	da d7       	rcall	.+4020   	; 0x1538 <puts>
     584:	08 95       	ret

00000586 <tinyPulse_toggle_pulse_mode>:
uint32_t time_of_last_pulse = 0;
uint16_t time_since_last_pulse = 0;
uint16_t ideal_time_between_pulses = 1000/PULSEMODE_FREQUENCY;

void tinyPulse_toggle_pulse_mode(){
	pulse_mode = !pulse_mode;
     586:	90 91 22 3e 	lds	r25, 0x3E22	; 0x803e22 <pulse_mode>
     58a:	81 e0       	ldi	r24, 0x01	; 1
     58c:	89 27       	eor	r24, r25
     58e:	80 93 22 3e 	sts	0x3E22, r24	; 0x803e22 <pulse_mode>
     592:	08 95       	ret

00000594 <tinyPulse_update_potential>:
}

double tinyPulse_update_potential(double potential){
     594:	cf 92       	push	r12
     596:	df 92       	push	r13
     598:	ef 92       	push	r14
     59a:	ff 92       	push	r15
     59c:	6b 01       	movw	r12, r22
     59e:	7c 01       	movw	r14, r24
	if(pulse_mode){
     5a0:	80 91 22 3e 	lds	r24, 0x3E22	; 0x803e22 <pulse_mode>
     5a4:	88 23       	and	r24, r24
     5a6:	21 f1       	breq	.+72     	; 0x5f0 <tinyPulse_update_potential+0x5c>
		
		time_since_last_pulse = tinyTime_now() - time_of_last_pulse;
     5a8:	3e d0       	rcall	.+124    	; 0x626 <tinyTime_now>
     5aa:	20 91 1e 3e 	lds	r18, 0x3E1E	; 0x803e1e <time_of_last_pulse>
     5ae:	30 91 1f 3e 	lds	r19, 0x3E1F	; 0x803e1f <time_of_last_pulse+0x1>
     5b2:	62 1b       	sub	r22, r18
     5b4:	73 0b       	sbc	r23, r19
     5b6:	60 93 1c 3e 	sts	0x3E1C, r22	; 0x803e1c <__data_end>
     5ba:	70 93 1d 3e 	sts	0x3E1D, r23	; 0x803e1d <__data_end+0x1>
		
		if(time_since_last_pulse >= ideal_time_between_pulses){
     5be:	80 91 14 3e 	lds	r24, 0x3E14	; 0x803e14 <ideal_time_between_pulses>
     5c2:	90 91 15 3e 	lds	r25, 0x3E15	; 0x803e15 <ideal_time_between_pulses+0x1>
     5c6:	68 17       	cp	r22, r24
     5c8:	79 07       	cpc	r23, r25
     5ca:	90 f0       	brcs	.+36     	; 0x5f0 <tinyPulse_update_potential+0x5c>
			potential += BUTTON_PRESS_REACTION;
     5cc:	20 e0       	ldi	r18, 0x00	; 0
     5ce:	30 e0       	ldi	r19, 0x00	; 0
     5d0:	40 ed       	ldi	r20, 0xD0	; 208
     5d2:	51 e4       	ldi	r21, 0x41	; 65
     5d4:	c7 01       	movw	r24, r14
     5d6:	b6 01       	movw	r22, r12
     5d8:	d2 d3       	rcall	.+1956   	; 0xd7e <__addsf3>
     5da:	6b 01       	movw	r12, r22
     5dc:	7c 01       	movw	r14, r24
			time_of_last_pulse = tinyTime_now();			
     5de:	23 d0       	rcall	.+70     	; 0x626 <tinyTime_now>
     5e0:	60 93 1e 3e 	sts	0x3E1E, r22	; 0x803e1e <time_of_last_pulse>
     5e4:	70 93 1f 3e 	sts	0x3E1F, r23	; 0x803e1f <time_of_last_pulse+0x1>
     5e8:	80 93 20 3e 	sts	0x3E20, r24	; 0x803e20 <time_of_last_pulse+0x2>
     5ec:	90 93 21 3e 	sts	0x3E21, r25	; 0x803e21 <time_of_last_pulse+0x3>
		}
	}
	return potential;
}
     5f0:	c7 01       	movw	r24, r14
     5f2:	b6 01       	movw	r22, r12
     5f4:	ff 90       	pop	r15
     5f6:	ef 90       	pop	r14
     5f8:	df 90       	pop	r13
     5fa:	cf 90       	pop	r12
     5fc:	08 95       	ret

000005fe <tinyTime_counter_increment>:
If the Interrupt Service Routine is clocked by a crystal oscillator
it gives a very precise timer-counter.
*/
void tinyTime_counter_increment(void)
{
	time_counter++;
     5fe:	80 91 23 3e 	lds	r24, 0x3E23	; 0x803e23 <time_counter>
     602:	90 91 24 3e 	lds	r25, 0x3E24	; 0x803e24 <time_counter+0x1>
     606:	a0 91 25 3e 	lds	r26, 0x3E25	; 0x803e25 <time_counter+0x2>
     60a:	b0 91 26 3e 	lds	r27, 0x3E26	; 0x803e26 <time_counter+0x3>
     60e:	01 96       	adiw	r24, 0x01	; 1
     610:	a1 1d       	adc	r26, r1
     612:	b1 1d       	adc	r27, r1
     614:	80 93 23 3e 	sts	0x3E23, r24	; 0x803e23 <time_counter>
     618:	90 93 24 3e 	sts	0x3E24, r25	; 0x803e24 <time_counter+0x1>
     61c:	a0 93 25 3e 	sts	0x3E25, r26	; 0x803e25 <time_counter+0x2>
     620:	b0 93 26 3e 	sts	0x3E26, r27	; 0x803e26 <time_counter+0x3>
     624:	08 95       	ret

00000626 <tinyTime_now>:
/*
This function is callable by external libraries to give them the counted time so far.
*/
uint32_t tinyTime_now(void)
{
	return time_counter;
     626:	60 91 23 3e 	lds	r22, 0x3E23	; 0x803e23 <time_counter>
     62a:	70 91 24 3e 	lds	r23, 0x3E24	; 0x803e24 <time_counter+0x1>
     62e:	80 91 25 3e 	lds	r24, 0x3E25	; 0x803e25 <time_counter+0x2>
     632:	90 91 26 3e 	lds	r25, 0x3E26	; 0x803e26 <time_counter+0x3>
     636:	08 95       	ret

00000638 <main>:


int main(void)
{	
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
     638:	96 dd       	rcall	.-1236   	; 0x166 <atmel_start_init>
	Setting this value will mean that the ADC (Analog to Digital Converter) will read 4.32v as 255, and 0v as 0.
	For some reason, instead of the reference voltage being 4.32v, it is 3.3v. 
	A plausible explanation is that the microchip does not up the voltage, so that if the microchip is only ever 
	supplied with 3.3v, it will output 3.3v as the max.
	*/
	VREF.CTRLA = VREF_ADC0REFSEL_4V34_gc;
     63a:	80 e3       	ldi	r24, 0x30	; 48
     63c:	80 93 a0 00 	sts	0x00A0, r24	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
	
	while (1)
	{
		// We don't want to update the neuron too often because of various reasons. The tinyISR_getflag is set every ms, and so the loop is only run once every ms.  
		if(tinyISR_getflag())
     640:	47 d3       	rcall	.+1678   	; 0xcd0 <tinyISR_getflag>
     642:	88 23       	and	r24, r24
     644:	e9 f3       	breq	.-6      	; 0x640 <main+0x8>
		{			
			
			if(tinyCharge_is_charging()){
     646:	49 df       	rcall	.-366    	; 0x4da <tinyCharge_is_charging>
     648:	88 23       	and	r24, r24
     64a:	11 f0       	breq	.+4      	; 0x650 <main+0x18>
				// Charge loop
				
				// We check the Dendrites in order to detect if we have stopped charging
				tinyDendrite_update_signals();
     64c:	21 d2       	rcall	.+1090   	; 0xa90 <tinyDendrite_update_signals>
     64e:	02 c0       	rjmp	.+4      	; 0x654 <main+0x1c>
				// Update led
				
			}
			else{
				// Main loop				
				tinyButton_update();
     650:	a6 d0       	rcall	.+332    	; 0x79e <tinyButton_update>
				
				tinyPotential_update();
     652:	41 d3       	rcall	.+1666   	; 0xcd6 <tinyPotential_update>
			}
			
			
			// Switch transistors
			tinyCharge_set_transistors();
     654:	48 df       	rcall	.-368    	; 0x4e6 <tinyCharge_set_transistors>
			
			// Prepare for next cycle
			tinyISR_setflag(false);
     656:	80 e0       	ldi	r24, 0x00	; 0
     658:	38 d3       	rcall	.+1648   	; 0xcca <tinyISR_setflag>
			tinyDebugger_end_line();
     65a:	91 df       	rcall	.-222    	; 0x57e <tinyDebugger_end_line>
     65c:	f1 cf       	rjmp	.-30     	; 0x640 <main+0x8>

0000065e <set_LED_fire>:



//function to be called upon when firing flag has been raised.
void set_LED_fire(void)
{
     65e:	cf 93       	push	r28
	fire_flash_time_counter = tinyTime_now();
     660:	e2 df       	rcall	.-60     	; 0x626 <tinyTime_now>
     662:	60 93 27 3e 	sts	0x3E27, r22	; 0x803e27 <fire_flash_time_counter>
     666:	70 93 28 3e 	sts	0x3E28, r23	; 0x803e28 <fire_flash_time_counter+0x1>
     66a:	80 93 29 3e 	sts	0x3E29, r24	; 0x803e29 <fire_flash_time_counter+0x2>
     66e:	90 93 2a 3e 	sts	0x3E2A, r25	; 0x803e2a <fire_flash_time_counter+0x3>
     672:	c0 e0       	ldi	r28, 0x00	; 0
	for (int i = 0; i < NUMBER_OF_LEDS; i++)
	{
		tinyCCLRGB_setColor(i, MAX_BRIGHTNESS, MAX_BRIGHTNESS, MAX_BRIGHTNESS);//As per the specs, all LEDs should be blue while firing.
     674:	20 e3       	ldi	r18, 0x30	; 48
     676:	40 e3       	ldi	r20, 0x30	; 48
     678:	60 e3       	ldi	r22, 0x30	; 48
     67a:	8c 2f       	mov	r24, r28
     67c:	fc d0       	rcall	.+504    	; 0x876 <tinyCCLRGB_setColor>
     67e:	cf 5f       	subi	r28, 0xFF	; 255

//function to be called upon when firing flag has been raised.
void set_LED_fire(void)
{
	fire_flash_time_counter = tinyTime_now();
	for (int i = 0; i < NUMBER_OF_LEDS; i++)
     680:	c6 30       	cpi	r28, 0x06	; 6
     682:	c1 f7       	brne	.-16     	; 0x674 <set_LED_fire+0x16>
	{
		tinyCCLRGB_setColor(i, MAX_BRIGHTNESS, MAX_BRIGHTNESS, MAX_BRIGHTNESS);//As per the specs, all LEDs should be blue while firing.
	}
}
     684:	cf 91       	pop	r28
     686:	08 95       	ret

00000688 <potential_to_RGB_update_LEDs>:



void potential_to_RGB_update_LEDs(double potential)
{
     688:	8f 92       	push	r8
     68a:	9f 92       	push	r9
     68c:	af 92       	push	r10
     68e:	bf 92       	push	r11
     690:	cf 92       	push	r12
     692:	df 92       	push	r13
     694:	ef 92       	push	r14
     696:	ff 92       	push	r15
     698:	0f 93       	push	r16
     69a:	1f 93       	push	r17
     69c:	cf 93       	push	r28
     69e:	6b 01       	movw	r12, r22
     6a0:	7c 01       	movw	r14, r24
	if ((tinyTime_now() - fire_flash_time_counter) < FIRE_FLASH_TIME)
     6a2:	c1 df       	rcall	.-126    	; 0x626 <tinyTime_now>
     6a4:	00 91 27 3e 	lds	r16, 0x3E27	; 0x803e27 <fire_flash_time_counter>
     6a8:	10 91 28 3e 	lds	r17, 0x3E28	; 0x803e28 <fire_flash_time_counter+0x1>
     6ac:	20 91 29 3e 	lds	r18, 0x3E29	; 0x803e29 <fire_flash_time_counter+0x2>
     6b0:	30 91 2a 3e 	lds	r19, 0x3E2A	; 0x803e2a <fire_flash_time_counter+0x3>
     6b4:	dc 01       	movw	r26, r24
     6b6:	cb 01       	movw	r24, r22
     6b8:	80 1b       	sub	r24, r16
     6ba:	91 0b       	sbc	r25, r17
     6bc:	a2 0b       	sbc	r26, r18
     6be:	b3 0b       	sbc	r27, r19
     6c0:	84 36       	cpi	r24, 0x64	; 100
     6c2:	91 05       	cpc	r25, r1
     6c4:	a1 05       	cpc	r26, r1
     6c6:	b1 05       	cpc	r27, r1
     6c8:	50 f4       	brcc	.+20     	; 0x6de <potential_to_RGB_update_LEDs+0x56>
     6ca:	c0 e0       	ldi	r28, 0x00	; 0
	{
		for (int i = 0; i < NUMBER_OF_LEDS; i++)
		{
			tinyCCLRGB_setColor(i, MAX_BRIGHTNESS, MAX_BRIGHTNESS, MAX_BRIGHTNESS);
     6cc:	20 e3       	ldi	r18, 0x30	; 48
     6ce:	40 e3       	ldi	r20, 0x30	; 48
     6d0:	60 e3       	ldi	r22, 0x30	; 48
     6d2:	8c 2f       	mov	r24, r28
     6d4:	d0 d0       	rcall	.+416    	; 0x876 <tinyCCLRGB_setColor>
     6d6:	cf 5f       	subi	r28, 0xFF	; 255

void potential_to_RGB_update_LEDs(double potential)
{
	if ((tinyTime_now() - fire_flash_time_counter) < FIRE_FLASH_TIME)
	{
		for (int i = 0; i < NUMBER_OF_LEDS; i++)
     6d8:	c6 30       	cpi	r28, 0x06	; 6
     6da:	c1 f7       	brne	.-16     	; 0x6cc <potential_to_RGB_update_LEDs+0x44>
     6dc:	53 c0       	rjmp	.+166    	; 0x784 <potential_to_RGB_update_LEDs+0xfc>
     6de:	c0 e0       	ldi	r28, 0x00	; 0
*/
static void potential_to_RGB_set_color(double potential)
{
	for (int i = 0; i < NUMBER_OF_LEDS; i++)
	{
		tinyCCLRGB_setColor(i, 0x0, 0x0, 0x0);//Clear all LED stored values on the MCU before writing again.
     6e0:	20 e0       	ldi	r18, 0x00	; 0
     6e2:	40 e0       	ldi	r20, 0x00	; 0
     6e4:	60 e0       	ldi	r22, 0x00	; 0
     6e6:	8c 2f       	mov	r24, r28
     6e8:	c6 d0       	rcall	.+396    	; 0x876 <tinyCCLRGB_setColor>
     6ea:	cf 5f       	subi	r28, 0xFF	; 255
When firing all lights turn blue for ~100ms, but this needs to be tested.
LEDs are numbered right way on top of PCB, but opposite way on bottom of PCB.
*/
static void potential_to_RGB_set_color(double potential)
{
	for (int i = 0; i < NUMBER_OF_LEDS; i++)
     6ec:	c6 30       	cpi	r28, 0x06	; 6
     6ee:	c1 f7       	brne	.-16     	; 0x6e0 <potential_to_RGB_update_LEDs+0x58>
	{
		tinyCCLRGB_setColor(i, 0x0, 0x0, 0x0);//Clear all LED stored values on the MCU before writing again.
	}
	double absolute_potential = abs(potential);//setting variable for absolute potential so it won't have to be calculated more than once.
     6f0:	c7 01       	movw	r24, r14
     6f2:	b6 01       	movw	r22, r12
     6f4:	27 d4       	rcall	.+2126   	; 0xf44 <__fixsfsi>
     6f6:	9b 01       	movw	r18, r22
     6f8:	77 23       	and	r23, r23
     6fa:	24 f4       	brge	.+8      	; 0x704 <potential_to_RGB_update_LEDs+0x7c>
     6fc:	22 27       	eor	r18, r18
     6fe:	33 27       	eor	r19, r19
     700:	26 1b       	sub	r18, r22
     702:	37 0b       	sbc	r19, r23
     704:	b9 01       	movw	r22, r18
     706:	33 0f       	add	r19, r19
     708:	88 0b       	sbc	r24, r24
     70a:	99 0b       	sbc	r25, r25
     70c:	53 d4       	rcall	.+2214   	; 0xfb4 <__floatsisf>
     70e:	4b 01       	movw	r8, r22
     710:	5c 01       	movw	r10, r24
	if (absolute_potential < 1)//set the middle lights as white both top side and bottom side.
     712:	20 e0       	ldi	r18, 0x00	; 0
     714:	30 e0       	ldi	r19, 0x00	; 0
     716:	40 e8       	ldi	r20, 0x80	; 128
     718:	5f e3       	ldi	r21, 0x3F	; 63
     71a:	9d d3       	rcall	.+1850   	; 0xe56 <__cmpsf2>
     71c:	88 23       	and	r24, r24
     71e:	34 f4       	brge	.+12     	; 0x72c <potential_to_RGB_update_LEDs+0xa4>
	{
		tinyCCLRGB_setColor(2, MAX_BRIGHTNESS/3, MAX_BRIGHTNESS/3, MAX_BRIGHTNESS/3);
     720:	20 e1       	ldi	r18, 0x10	; 16
     722:	40 e1       	ldi	r20, 0x10	; 16
     724:	60 e1       	ldi	r22, 0x10	; 16
     726:	82 e0       	ldi	r24, 0x02	; 2
     728:	a6 d0       	rcall	.+332    	; 0x876 <tinyCCLRGB_setColor>
     72a:	2c c0       	rjmp	.+88     	; 0x784 <potential_to_RGB_update_LEDs+0xfc>
		//tinyCCLRGB_setColor(4, max_brightness/3, max_brightness/3, max_brightness/3);
	}
	else
	{
		uint8_t brightness_intensity = round((absolute_potential/25)*MAX_BRIGHTNESS);//brightness intensity for the LED that shows potential.
     72c:	20 e0       	ldi	r18, 0x00	; 0
     72e:	30 e0       	ldi	r19, 0x00	; 0
     730:	48 ec       	ldi	r20, 0xC8	; 200
     732:	51 e4       	ldi	r21, 0x41	; 65
     734:	c5 01       	movw	r24, r10
     736:	b4 01       	movw	r22, r8
     738:	93 d3       	rcall	.+1830   	; 0xe60 <__divsf3>
     73a:	20 e0       	ldi	r18, 0x00	; 0
     73c:	30 e0       	ldi	r19, 0x00	; 0
     73e:	40 e4       	ldi	r20, 0x40	; 64
     740:	52 e4       	ldi	r21, 0x42	; 66
     742:	ed d4       	rcall	.+2522   	; 0x111e <__mulsf3>
     744:	59 d5       	rcall	.+2738   	; 0x11f8 <round>
     746:	05 d4       	rcall	.+2058   	; 0xf52 <__fixunssfsi>
     748:	c6 2f       	mov	r28, r22
		if (potential < 0)
     74a:	20 e0       	ldi	r18, 0x00	; 0
     74c:	30 e0       	ldi	r19, 0x00	; 0
     74e:	a9 01       	movw	r20, r18
     750:	c7 01       	movw	r24, r14
     752:	b6 01       	movw	r22, r12
     754:	80 d3       	rcall	.+1792   	; 0xe56 <__cmpsf2>
     756:	88 23       	and	r24, r24
     758:	5c f4       	brge	.+22     	; 0x770 <potential_to_RGB_update_LEDs+0xe8>
		{
			tinyCCLRGB_setColor(0, brightness_intensity, 0x0, 0x0);
     75a:	20 e0       	ldi	r18, 0x00	; 0
     75c:	40 e0       	ldi	r20, 0x00	; 0
     75e:	6c 2f       	mov	r22, r28
     760:	80 e0       	ldi	r24, 0x00	; 0
     762:	89 d0       	rcall	.+274    	; 0x876 <tinyCCLRGB_setColor>
			tinyCCLRGB_setColor(1, brightness_intensity, 0x0, 0x0);//sets lower LEDs red if potential is negative.
     764:	20 e0       	ldi	r18, 0x00	; 0
     766:	40 e0       	ldi	r20, 0x00	; 0
     768:	6c 2f       	mov	r22, r28
     76a:	81 e0       	ldi	r24, 0x01	; 1
     76c:	84 d0       	rcall	.+264    	; 0x876 <tinyCCLRGB_setColor>
     76e:	0a c0       	rjmp	.+20     	; 0x784 <potential_to_RGB_update_LEDs+0xfc>
		} 
		else
		{
			tinyCCLRGB_setColor(3, 0x0, brightness_intensity, 0x0);//sets upper LEDs green if potential is positive.
     770:	20 e0       	ldi	r18, 0x00	; 0
     772:	4c 2f       	mov	r20, r28
     774:	60 e0       	ldi	r22, 0x00	; 0
     776:	83 e0       	ldi	r24, 0x03	; 3
     778:	7e d0       	rcall	.+252    	; 0x876 <tinyCCLRGB_setColor>
			tinyCCLRGB_setColor(4, 0x0, brightness_intensity, 0x0);
     77a:	20 e0       	ldi	r18, 0x00	; 0
     77c:	4c 2f       	mov	r20, r28
     77e:	60 e0       	ldi	r22, 0x00	; 0
     780:	84 e0       	ldi	r24, 0x04	; 4
     782:	79 d0       	rcall	.+242    	; 0x876 <tinyCCLRGB_setColor>
	}
	else
	{
		potential_to_RGB_set_color(potential);
	}
	tinyCCLRGB_uploadColorsToLeds();
     784:	85 d0       	rcall	.+266    	; 0x890 <tinyCCLRGB_uploadColorsToLeds>
}
     786:	cf 91       	pop	r28
     788:	1f 91       	pop	r17
     78a:	0f 91       	pop	r16
     78c:	ff 90       	pop	r15
     78e:	ef 90       	pop	r14
     790:	df 90       	pop	r13
     792:	cf 90       	pop	r12
     794:	bf 90       	pop	r11
     796:	af 90       	pop	r10
     798:	9f 90       	pop	r9
     79a:	8f 90       	pop	r8
     79c:	08 95       	ret

0000079e <tinyButton_update>:
/*
If the button has been let go, we change button_press to true. This only lasts one cycle, before it is set to false again.
If the button is held down for longer than PULSEMODE_BUTTON_PRESS_TIME, we toggle the pulse mode state.
*/
void tinyButton_update(void)
{
     79e:	0f 93       	push	r16
     7a0:	1f 93       	push	r17
     7a2:	cf 93       	push	r28
     7a4:	df 93       	push	r29
	button_press = false;
     7a6:	10 92 2f 3e 	sts	0x3E2F, r1	; 0x803e2f <button_press>
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTC_get_pin_level(const uint8_t pin)
{
	return VPORTC.IN & (1 << pin);
     7aa:	8a b1       	in	r24, 0x0a	; 10
	_Bool button_is_pushed_down = !BUTTON_PIN_get_level(); // The digital port will be read as low if the button is pushed down.
     7ac:	d1 e0       	ldi	r29, 0x01	; 1
     7ae:	c8 2f       	mov	r28, r24
     7b0:	c4 70       	andi	r28, 0x04	; 4
     7b2:	82 fd       	sbrc	r24, 2
     7b4:	d0 e0       	ldi	r29, 0x00	; 0

	if (button_is_pushed_down && !button_was_pushed_down)
     7b6:	c1 11       	cpse	r28, r1
     7b8:	30 c0       	rjmp	.+96     	; 0x81a <tinyButton_update+0x7c>
     7ba:	80 91 30 3e 	lds	r24, 0x3E30	; 0x803e30 <button_was_pushed_down>
     7be:	81 11       	cpse	r24, r1
     7c0:	0d c0       	rjmp	.+26     	; 0x7dc <tinyButton_update+0x3e>
	{
		tinyButton_start_time = tinyTime_now();
     7c2:	31 df       	rcall	.-414    	; 0x626 <tinyTime_now>
     7c4:	60 93 2b 3e 	sts	0x3E2B, r22	; 0x803e2b <tinyButton_start_time>
     7c8:	70 93 2c 3e 	sts	0x3E2C, r23	; 0x803e2c <tinyButton_start_time+0x1>
     7cc:	80 93 2d 3e 	sts	0x3E2D, r24	; 0x803e2d <tinyButton_start_time+0x2>
     7d0:	90 93 2e 3e 	sts	0x3E2E, r25	; 0x803e2e <tinyButton_start_time+0x3>
	}
	if (button_is_pushed_down && button_was_pushed_down)
     7d4:	80 91 30 3e 	lds	r24, 0x3E30	; 0x803e30 <button_was_pushed_down>
     7d8:	88 23       	and	r24, r24
     7da:	41 f1       	breq	.+80     	; 0x82c <tinyButton_update+0x8e>
	{
		if ((tinyTime_now() - tinyButton_start_time) > PULSEMODE_BUTTON_PRESS_TIME)
     7dc:	24 df       	rcall	.-440    	; 0x626 <tinyTime_now>
     7de:	00 91 2b 3e 	lds	r16, 0x3E2B	; 0x803e2b <tinyButton_start_time>
     7e2:	10 91 2c 3e 	lds	r17, 0x3E2C	; 0x803e2c <tinyButton_start_time+0x1>
     7e6:	20 91 2d 3e 	lds	r18, 0x3E2D	; 0x803e2d <tinyButton_start_time+0x2>
     7ea:	30 91 2e 3e 	lds	r19, 0x3E2E	; 0x803e2e <tinyButton_start_time+0x3>
     7ee:	60 1b       	sub	r22, r16
     7f0:	71 0b       	sbc	r23, r17
     7f2:	82 0b       	sbc	r24, r18
     7f4:	93 0b       	sbc	r25, r19
     7f6:	dc d3       	rcall	.+1976   	; 0xfb0 <__floatunsisf>
     7f8:	20 e0       	ldi	r18, 0x00	; 0
     7fa:	30 e0       	ldi	r19, 0x00	; 0
     7fc:	40 ea       	ldi	r20, 0xA0	; 160
     7fe:	51 e4       	ldi	r21, 0x41	; 65
     800:	89 d4       	rcall	.+2322   	; 0x1114 <__gesf2>
     802:	18 16       	cp	r1, r24
     804:	54 f4       	brge	.+20     	; 0x81a <tinyButton_update+0x7c>
		{
			tinyPulse_toggle_pulse_mode();
     806:	bf de       	rcall	.-642    	; 0x586 <tinyPulse_toggle_pulse_mode>
			tinyButton_start_time = tinyTime_now();
     808:	0e df       	rcall	.-484    	; 0x626 <tinyTime_now>
     80a:	60 93 2b 3e 	sts	0x3E2B, r22	; 0x803e2b <tinyButton_start_time>
     80e:	70 93 2c 3e 	sts	0x3E2C, r23	; 0x803e2c <tinyButton_start_time+0x1>
     812:	80 93 2d 3e 	sts	0x3E2D, r24	; 0x803e2d <tinyButton_start_time+0x2>
     816:	90 93 2e 3e 	sts	0x3E2E, r25	; 0x803e2e <tinyButton_start_time+0x3>
		}
	}
	if (!button_is_pushed_down && button_was_pushed_down)
     81a:	cc 23       	and	r28, r28
     81c:	39 f0       	breq	.+14     	; 0x82c <tinyButton_update+0x8e>
     81e:	80 91 30 3e 	lds	r24, 0x3E30	; 0x803e30 <button_was_pushed_down>
     822:	88 23       	and	r24, r24
     824:	19 f0       	breq	.+6      	; 0x82c <tinyButton_update+0x8e>
	{
		button_press = true;
     826:	81 e0       	ldi	r24, 0x01	; 1
     828:	80 93 2f 3e 	sts	0x3E2F, r24	; 0x803e2f <button_press>
	}
	button_was_pushed_down = button_is_pushed_down;
     82c:	d0 93 30 3e 	sts	0x3E30, r29	; 0x803e30 <button_was_pushed_down>
}
     830:	df 91       	pop	r29
     832:	cf 91       	pop	r28
     834:	1f 91       	pop	r17
     836:	0f 91       	pop	r16
     838:	08 95       	ret

0000083a <tinyButton_update_potential>:

double tinyButton_update_potential(double potential){
	if(button_press){
     83a:	20 91 2f 3e 	lds	r18, 0x3E2F	; 0x803e2f <button_press>
     83e:	22 23       	and	r18, r18
     840:	29 f0       	breq	.+10     	; 0x84c <tinyButton_update_potential+0x12>
		potential += BUTTON_PRESS_REACTION;
     842:	20 e0       	ldi	r18, 0x00	; 0
     844:	30 e0       	ldi	r19, 0x00	; 0
     846:	40 ed       	ldi	r20, 0xD0	; 208
     848:	51 e4       	ldi	r21, 0x41	; 65
     84a:	99 d2       	rcall	.+1330   	; 0xd7e <__addsf3>
	}
	return potential;
}
     84c:	08 95       	ret

0000084e <tinyCCLRGB_SPIWriteByte>:
Function used to send a byte over SPI, which in turn gets
translated to the bit-sequence required by the LEDs over the CCL.
*/
static void tinyCCLRGB_SPIWriteByte(uint8_t byte)
{
	SPI0.INTFLAGS = SPI0_INTFLAGS; // clear the write collision flag to allow writing
     84e:	90 91 23 08 	lds	r25, 0x0823	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
     852:	90 93 23 08 	sts	0x0823, r25	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
	TCA0.SINGLE.CNT = 0; // reset TCA counter register to ensure the first rising edge of the PWM is predictable
     856:	e0 e0       	ldi	r30, 0x00	; 0
     858:	fa e0       	ldi	r31, 0x0A	; 10
     85a:	10 a2       	std	Z+32, r1	; 0x20
     85c:	11 a2       	std	Z+33, r1	; 0x21
	
	// start TCA
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 1 << TCA_SPLIT_ENABLE_bp;
     85e:	91 e0       	ldi	r25, 0x01	; 1
     860:	90 83       	st	Z, r25
	SPI0_DATA = byte;
     862:	80 93 24 08 	sts	0x0824, r24	; 0x800824 <__TEXT_REGION_LENGTH__+0x700824>

	while((SPI0.INTFLAGS & SPI_RXCIE_bm) == 0){} // wait for transfer to complete
     866:	e0 e2       	ldi	r30, 0x20	; 32
     868:	f8 e0       	ldi	r31, 0x08	; 8
     86a:	83 81       	ldd	r24, Z+3	; 0x03
     86c:	88 23       	and	r24, r24
     86e:	ec f7       	brge	.-6      	; 0x86a <tinyCCLRGB_SPIWriteByte+0x1c>
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 0 << TCA_SPLIT_ENABLE_bp; //Stop TCA
     870:	10 92 00 0a 	sts	0x0A00, r1	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
     874:	08 95       	ret

00000876 <tinyCCLRGB_setColor>:
/*
changes the values in the variables stored in the led-array.
*/
void tinyCCLRGB_setColor(uint8_t led, uint8_t red, uint8_t green, uint8_t blue) 
{
	tinyCCLRGB_colors[led].red = red;
     876:	90 e0       	ldi	r25, 0x00	; 0
     878:	fc 01       	movw	r30, r24
     87a:	ee 0f       	add	r30, r30
     87c:	ff 1f       	adc	r31, r31
     87e:	8e 0f       	add	r24, r30
     880:	9f 1f       	adc	r25, r31
     882:	fc 01       	movw	r30, r24
     884:	ef 5c       	subi	r30, 0xCF	; 207
     886:	f1 4c       	sbci	r31, 0xC1	; 193
     888:	60 83       	st	Z, r22
	tinyCCLRGB_colors[led].green = green;
     88a:	41 83       	std	Z+1, r20	; 0x01
	tinyCCLRGB_colors[led].blue = blue;
     88c:	22 83       	std	Z+2, r18	; 0x02
     88e:	08 95       	ret

00000890 <tinyCCLRGB_uploadColorsToLeds>:
/*
function to write the current LED-array on to the LEDs and
effectively update the values stored in the LEDs to the values stored in the MCU.
*/
void tinyCCLRGB_uploadColorsToLeds(void)
{
     890:	0f 93       	push	r16
     892:	1f 93       	push	r17
     894:	cf 93       	push	r28
     896:	df 93       	push	r29
     898:	c1 e3       	ldi	r28, 0x31	; 49
     89a:	de e3       	ldi	r29, 0x3E	; 62
     89c:	03 e4       	ldi	r16, 0x43	; 67
     89e:	1e e3       	ldi	r17, 0x3E	; 62
	for (uint8_t i = 0; i < TINYCCLRGB_LEDCOUNT; i++)
	{
		//For some reason unknown to the writer the data-bus to the LEDs is serialized as GRB
		//which means the 24-bit data-bus will look like [Green[0:7], Red[0:7], Blue[0:7]]
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].green);
     8a0:	89 81       	ldd	r24, Y+1	; 0x01
     8a2:	d5 df       	rcall	.-86     	; 0x84e <tinyCCLRGB_SPIWriteByte>
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].red);
     8a4:	88 81       	ld	r24, Y
     8a6:	d3 df       	rcall	.-90     	; 0x84e <tinyCCLRGB_SPIWriteByte>
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].blue);
     8a8:	8a 81       	ldd	r24, Y+2	; 0x02
     8aa:	d1 df       	rcall	.-94     	; 0x84e <tinyCCLRGB_SPIWriteByte>
     8ac:	23 96       	adiw	r28, 0x03	; 3
function to write the current LED-array on to the LEDs and
effectively update the values stored in the LEDs to the values stored in the MCU.
*/
void tinyCCLRGB_uploadColorsToLeds(void)
{
	for (uint8_t i = 0; i < TINYCCLRGB_LEDCOUNT; i++)
     8ae:	c0 17       	cp	r28, r16
     8b0:	d1 07       	cpc	r29, r17
     8b2:	b1 f7       	brne	.-20     	; 0x8a0 <tinyCCLRGB_uploadColorsToLeds+0x10>
		//which means the 24-bit data-bus will look like [Green[0:7], Red[0:7], Blue[0:7]]
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].green);
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].red);
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].blue);
	}
}
     8b4:	df 91       	pop	r29
     8b6:	cf 91       	pop	r28
     8b8:	1f 91       	pop	r17
     8ba:	0f 91       	pop	r16
     8bc:	08 95       	ret

000008be <tinyAxon_remove_pulse>:
/*
solution to remove future firing if a inhibitory signal is received
shortly after a excitatory signal.
*/
bool tinyAxon_remove_pulse(void)
{
     8be:	cf 92       	push	r12
     8c0:	df 92       	push	r13
     8c2:	ef 92       	push	r14
     8c4:	ff 92       	push	r15
	// We want to remove the pulse last added to the queue
	// We also want to return a bool indicating whether or not a pulse actually was removed
	uint32_t now = tinyTime_now();
     8c6:	af de       	rcall	.-674    	; 0x626 <tinyTime_now>
     8c8:	6b 01       	movw	r12, r22
     8ca:	7c 01       	movw	r14, r24
	uint32_t pulse_time = dequeue_top(&pulse_queue);
     8cc:	84 e4       	ldi	r24, 0x44	; 68
     8ce:	9e e3       	ldi	r25, 0x3E	; 62
     8d0:	88 dd       	rcall	.-1264   	; 0x3e2 <dequeue_top>
	if(pulse_time == 0){ // Here, 0 is regarded as an error
     8d2:	61 15       	cp	r22, r1
     8d4:	71 05       	cpc	r23, r1
     8d6:	81 05       	cpc	r24, r1
     8d8:	91 05       	cpc	r25, r1
     8da:	c1 f0       	breq	.+48     	; 0x90c <tinyAxon_remove_pulse+0x4e>
		return false;
	}
	
	// Now we want to check if the pulse is too far away to be affected by the low potential, or close enough that we decide to remove it
	// (When we say that the pulse is too far away, it refers to the biological process of how the potential spreads from Dendrites to axon)
	else if((now + UNDO_PERIOD) < pulse_time){
     8dc:	2c e3       	ldi	r18, 0x3C	; 60
     8de:	c2 0e       	add	r12, r18
     8e0:	d1 1c       	adc	r13, r1
     8e2:	e1 1c       	adc	r14, r1
     8e4:	f1 1c       	adc	r15, r1
     8e6:	c6 16       	cp	r12, r22
     8e8:	d7 06       	cpc	r13, r23
     8ea:	e8 06       	cpc	r14, r24
     8ec:	f9 06       	cpc	r15, r25
     8ee:	38 f4       	brcc	.+14     	; 0x8fe <tinyAxon_remove_pulse+0x40>
		// We decided to remove the pulse
		pulses_in_queue--;
     8f0:	80 91 46 3e 	lds	r24, 0x3E46	; 0x803e46 <pulses_in_queue>
     8f4:	81 50       	subi	r24, 0x01	; 1
     8f6:	80 93 46 3e 	sts	0x3E46, r24	; 0x803e46 <pulses_in_queue>
		return true;
     8fa:	81 e0       	ldi	r24, 0x01	; 1
     8fc:	08 c0       	rjmp	.+16     	; 0x90e <tinyAxon_remove_pulse+0x50>
	}
	// Here we have found that there is a pulse queued, but it is old enough to let pass anyway, so now we need to put it back into the queue
	else{
		enqueue(&pulse_queue, pulse_time);
     8fe:	ab 01       	movw	r20, r22
     900:	bc 01       	movw	r22, r24
     902:	84 e4       	ldi	r24, 0x44	; 68
     904:	9e e3       	ldi	r25, 0x3E	; 62
     906:	11 dd       	rcall	.-1502   	; 0x32a <enqueue>
		return false;
     908:	80 e0       	ldi	r24, 0x00	; 0
     90a:	01 c0       	rjmp	.+2      	; 0x90e <tinyAxon_remove_pulse+0x50>
	// We also want to return a bool indicating whether or not a pulse actually was removed
	uint32_t now = tinyTime_now();
	uint32_t pulse_time = dequeue_top(&pulse_queue);
	if(pulse_time == 0){ // Here, 0 is regarded as an error
		//There was no pulse to remove
		return false;
     90c:	80 e0       	ldi	r24, 0x00	; 0
	// Here we have found that there is a pulse queued, but it is old enough to let pass anyway, so now we need to put it back into the queue
	else{
		enqueue(&pulse_queue, pulse_time);
		return false;
	}
}
     90e:	ff 90       	pop	r15
     910:	ef 90       	pop	r14
     912:	df 90       	pop	r13
     914:	cf 90       	pop	r12
     916:	08 95       	ret

00000918 <tinyAxon_update_potential>:
/*
Decides whether or not the axon should fire
If the axon does fire, the potential is reduced
*/
double tinyAxon_update_potential(double potential)
{
     918:	4f 92       	push	r4
     91a:	5f 92       	push	r5
     91c:	6f 92       	push	r6
     91e:	7f 92       	push	r7
     920:	8f 92       	push	r8
     922:	9f 92       	push	r9
     924:	af 92       	push	r10
     926:	bf 92       	push	r11
     928:	cf 92       	push	r12
     92a:	df 92       	push	r13
     92c:	ef 92       	push	r14
     92e:	ff 92       	push	r15
     930:	cf 93       	push	r28
     932:	df 93       	push	r29
     934:	6b 01       	movw	r12, r22
     936:	7c 01       	movw	r14, r24
	int pulse_nr = 0;
	uint32_t now = tinyTime_now();
     938:	76 de       	rcall	.-788    	; 0x626 <tinyTime_now>
     93a:	2b 01       	movw	r4, r22
     93c:	3c 01       	movw	r6, r24
	
	//While the neuron has enough potential to fire, we want to fire more
	while (potential > THRESHOLD_POTENTIAL)
     93e:	20 e0       	ldi	r18, 0x00	; 0
     940:	30 e0       	ldi	r19, 0x00	; 0
     942:	48 ec       	ldi	r20, 0xC8	; 200
     944:	51 e4       	ldi	r21, 0x41	; 65
     946:	c7 01       	movw	r24, r14
     948:	b6 01       	movw	r22, r12
     94a:	e4 d3       	rcall	.+1992   	; 0x1114 <__gesf2>
     94c:	18 16       	cp	r1, r24
     94e:	5c f5       	brge	.+86     	; 0x9a6 <tinyAxon_update_potential+0x8e>
     950:	c0 e0       	ldi	r28, 0x00	; 0
     952:	d0 e0       	ldi	r29, 0x00	; 0
/*
Adds an element to the queue
*/
static void tinyAxon_enqueue_pulse(uint32_t new_pulse)
{
	enqueue(&pulse_queue, new_pulse);
     954:	53 01       	movw	r10, r6
     956:	42 01       	movw	r8, r4
     958:	84 e6       	ldi	r24, 0x64	; 100
     95a:	88 0e       	add	r8, r24
     95c:	91 1c       	adc	r9, r1
     95e:	a1 1c       	adc	r10, r1
     960:	b1 1c       	adc	r11, r1
     962:	ae 01       	movw	r20, r28
     964:	0d 2e       	mov	r0, r29
     966:	00 0c       	add	r0, r0
     968:	66 0b       	sbc	r22, r22
     96a:	77 0b       	sbc	r23, r23
     96c:	48 0d       	add	r20, r8
     96e:	59 1d       	adc	r21, r9
     970:	6a 1d       	adc	r22, r10
     972:	7b 1d       	adc	r23, r11
     974:	84 e4       	ldi	r24, 0x44	; 68
     976:	9e e3       	ldi	r25, 0x3E	; 62
     978:	d8 dc       	rcall	.-1616   	; 0x32a <enqueue>
	pulses_in_queue++;
     97a:	80 91 46 3e 	lds	r24, 0x3E46	; 0x803e46 <pulses_in_queue>
     97e:	8f 5f       	subi	r24, 0xFF	; 255
     980:	80 93 46 3e 	sts	0x3E46, r24	; 0x803e46 <pulses_in_queue>
	{
		tinyAxon_enqueue_pulse(now + TRAVLE_DELAY + FIRE_DELAY*pulse_nr);
		pulse_nr++;
		
		// I want to test reducing the potential by -30 instead of -25 to simulate the hyperpolarization
		potential += POSTFIRE_POTENTIAL_REACTION; // This is usually defined as a negative value, don't be confused by the +=
     984:	20 e0       	ldi	r18, 0x00	; 0
     986:	30 e0       	ldi	r19, 0x00	; 0
     988:	40 ef       	ldi	r20, 0xF0	; 240
     98a:	51 e4       	ldi	r21, 0x41	; 65
     98c:	c7 01       	movw	r24, r14
     98e:	b6 01       	movw	r22, r12
     990:	f5 d1       	rcall	.+1002   	; 0xd7c <__subsf3>
     992:	6b 01       	movw	r12, r22
     994:	7c 01       	movw	r14, r24
     996:	e2 96       	adiw	r28, 0x32	; 50
{
	int pulse_nr = 0;
	uint32_t now = tinyTime_now();
	
	//While the neuron has enough potential to fire, we want to fire more
	while (potential > THRESHOLD_POTENTIAL)
     998:	20 e0       	ldi	r18, 0x00	; 0
     99a:	30 e0       	ldi	r19, 0x00	; 0
     99c:	48 ec       	ldi	r20, 0xC8	; 200
     99e:	51 e4       	ldi	r21, 0x41	; 65
     9a0:	b9 d3       	rcall	.+1906   	; 0x1114 <__gesf2>
     9a2:	18 16       	cp	r1, r24
     9a4:	f4 f2       	brlt	.-68     	; 0x962 <tinyAxon_update_potential+0x4a>
		// I want to test reducing the potential by -30 instead of -25 to simulate the hyperpolarization
		potential += POSTFIRE_POTENTIAL_REACTION; // This is usually defined as a negative value, don't be confused by the +=
	}
	
	// If the neuron has a very low potential, we want to remove a pulse from the queue (if there is one)
	if(potential < -THRESHOLD_POTENTIAL && pulses_in_queue > 0) // Perhaps this should be a separate variable? For now, we will just simply use -THRESHOLD_POTENTIAL
     9a6:	20 e0       	ldi	r18, 0x00	; 0
     9a8:	30 e0       	ldi	r19, 0x00	; 0
     9aa:	48 ec       	ldi	r20, 0xC8	; 200
     9ac:	51 ec       	ldi	r21, 0xC1	; 193
     9ae:	c7 01       	movw	r24, r14
     9b0:	b6 01       	movw	r22, r12
     9b2:	51 d2       	rcall	.+1186   	; 0xe56 <__cmpsf2>
     9b4:	88 23       	and	r24, r24
     9b6:	84 f4       	brge	.+32     	; 0x9d8 <tinyAxon_update_potential+0xc0>
     9b8:	80 91 46 3e 	lds	r24, 0x3E46	; 0x803e46 <pulses_in_queue>
     9bc:	88 23       	and	r24, r24
     9be:	79 f1       	breq	.+94     	; 0xa1e <tinyAxon_update_potential+0x106>
	{
		// The neurons potential is low enough to attempt to remove a queued fire (Fire less)
		if(tinyAxon_remove_pulse())
     9c0:	7e df       	rcall	.-260    	; 0x8be <tinyAxon_remove_pulse>
     9c2:	88 23       	and	r24, r24
     9c4:	49 f0       	breq	.+18     	; 0x9d8 <tinyAxon_update_potential+0xc0>
		{
			// The potential has evened out a bit
			potential += THRESHOLD_POTENTIAL;
     9c6:	20 e0       	ldi	r18, 0x00	; 0
     9c8:	30 e0       	ldi	r19, 0x00	; 0
     9ca:	48 ec       	ldi	r20, 0xC8	; 200
     9cc:	51 e4       	ldi	r21, 0x41	; 65
     9ce:	c7 01       	movw	r24, r14
     9d0:	b6 01       	movw	r22, r12
     9d2:	d5 d1       	rcall	.+938    	; 0xd7e <__addsf3>
     9d4:	6b 01       	movw	r12, r22
     9d6:	7c 01       	movw	r14, r24
		}
	}
	
	// If there are pulses in the queue, and the pulse has been scheduled to fire
	if ((pulses_in_queue > 0) && (next_pulse <= now))
     9d8:	80 91 46 3e 	lds	r24, 0x3E46	; 0x803e46 <pulses_in_queue>
     9dc:	88 23       	and	r24, r24
     9de:	f9 f0       	breq	.+62     	; 0xa1e <tinyAxon_update_potential+0x106>
     9e0:	40 91 63 3e 	lds	r20, 0x3E63	; 0x803e63 <next_pulse>
     9e4:	50 91 64 3e 	lds	r21, 0x3E64	; 0x803e64 <next_pulse+0x1>
     9e8:	60 91 65 3e 	lds	r22, 0x3E65	; 0x803e65 <next_pulse+0x2>
     9ec:	70 91 66 3e 	lds	r23, 0x3E66	; 0x803e66 <next_pulse+0x3>
     9f0:	44 16       	cp	r4, r20
     9f2:	55 06       	cpc	r5, r21
     9f4:	66 06       	cpc	r6, r22
     9f6:	77 06       	cpc	r7, r23
     9f8:	90 f0       	brcs	.+36     	; 0xa1e <tinyAxon_update_potential+0x106>
Function to set firing.
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
     9fa:	91 e0       	ldi	r25, 0x01	; 1
     9fc:	90 93 47 3e 	sts	0x3E47, r25	; 0x803e47 <tinyAxon_should_fire>
	pulses_in_queue--;
     a00:	81 50       	subi	r24, 0x01	; 1
     a02:	80 93 46 3e 	sts	0x3E46, r24	; 0x803e46 <pulses_in_queue>
	next_pulse = dequeue(&pulse_queue);
     a06:	84 e4       	ldi	r24, 0x44	; 68
     a08:	9e e3       	ldi	r25, 0x3E	; 62
     a0a:	af dc       	rcall	.-1698   	; 0x36a <dequeue>
     a0c:	60 93 63 3e 	sts	0x3E63, r22	; 0x803e63 <next_pulse>
     a10:	70 93 64 3e 	sts	0x3E64, r23	; 0x803e64 <next_pulse+0x1>
     a14:	80 93 65 3e 	sts	0x3E65, r24	; 0x803e65 <next_pulse+0x2>
     a18:	90 93 66 3e 	sts	0x3E66, r25	; 0x803e66 <next_pulse+0x3>
	// If there are pulses in the queue, and the pulse has been scheduled to fire
	if ((pulses_in_queue > 0) && (next_pulse <= now))
	{
		// We fire the axon
		tinyAxon_fire_pulse();
		set_LED_fire();
     a1c:	20 de       	rcall	.-960    	; 0x65e <set_LED_fire>
The function should set the DAC to fire for two
update cycles once the pulse flag is set high.
*/
static void tinyAxon_update_pulse_transmitter(void)
{
	if (tinyAxon_should_fire)
     a1e:	80 91 47 3e 	lds	r24, 0x3E47	; 0x803e47 <tinyAxon_should_fire>
     a22:	88 23       	and	r24, r24
     a24:	61 f0       	breq	.+24     	; 0xa3e <tinyAxon_update_potential+0x126>
	{
		tinyAxon_should_fire = false;
     a26:	10 92 47 3e 	sts	0x3E47, r1	; 0x803e47 <tinyAxon_should_fire>
		tinyAxon_has_fired = true;
     a2a:	81 e0       	ldi	r24, 0x01	; 1
     a2c:	80 93 48 3e 	sts	0x3E48, r24	; 0x803e48 <tinyAxon_has_fired>
*/
static void tinyAxon_start_sending_pulse()
{
	if (NEURONTYPE == EXCITATORY_NEURON)
	{
		DAC_set_output(EXCITATORY_NEURON_OUTPUT);
     a30:	87 ed       	ldi	r24, 0xD7	; 215
     a32:	90 e0       	ldi	r25, 0x00	; 0
     a34:	d8 db       	rcall	.-2128   	; 0x1e6 <DAC_set_output>
		axonOutputValue=EXCITATORY_NEURON_OUTPUT;
     a36:	87 ed       	ldi	r24, 0xD7	; 215
     a38:	80 93 43 3e 	sts	0x3E43, r24	; 0x803e43 <axonOutputValue>
     a3c:	0c c0       	rjmp	.+24     	; 0xa56 <tinyAxon_update_potential+0x13e>
		tinyAxon_should_fire = false;
		tinyAxon_has_fired = true;
		
		tinyAxon_start_sending_pulse();
	}
	else if (tinyAxon_has_fired)
     a3e:	80 91 48 3e 	lds	r24, 0x3E48	; 0x803e48 <tinyAxon_has_fired>
     a42:	88 23       	and	r24, r24
     a44:	19 f0       	breq	.+6      	; 0xa4c <tinyAxon_update_potential+0x134>
	{
		tinyAxon_has_fired = false;
     a46:	10 92 48 3e 	sts	0x3E48, r1	; 0x803e48 <tinyAxon_has_fired>
     a4a:	05 c0       	rjmp	.+10     	; 0xa56 <tinyAxon_update_potential+0x13e>
}

static void tinyAxon_stop_sending_pulse()
{
	
	DAC_set_output(NO_SIGNAL_OUTPUT);
     a4c:	80 e0       	ldi	r24, 0x00	; 0
     a4e:	90 e0       	ldi	r25, 0x00	; 0
     a50:	ca db       	rcall	.-2156   	; 0x1e6 <DAC_set_output>
	axonOutputValue=NO_SIGNAL_OUTPUT;
     a52:	10 92 43 3e 	sts	0x3E43, r1	; 0x803e43 <axonOutputValue>
	}
	
	// Here we set the actual output of the DAC (Digital to Analog Converter)
	tinyAxon_update_pulse_transmitter();
	
	tinyDebugger_send_int("Axon output", axonOutputValue);
     a56:	60 91 43 3e 	lds	r22, 0x3E43	; 0x803e43 <axonOutputValue>
     a5a:	70 e0       	ldi	r23, 0x00	; 0
     a5c:	80 e7       	ldi	r24, 0x70	; 112
     a5e:	9f e9       	ldi	r25, 0x9F	; 159
     a60:	4a dd       	rcall	.-1388   	; 0x4f6 <tinyDebugger_send_int>
	tinyDebugger_send_int("Pulses in queue", pulses_in_queue);
     a62:	60 91 46 3e 	lds	r22, 0x3E46	; 0x803e46 <pulses_in_queue>
     a66:	70 e0       	ldi	r23, 0x00	; 0
     a68:	8c e7       	ldi	r24, 0x7C	; 124
     a6a:	9f e9       	ldi	r25, 0x9F	; 159
     a6c:	44 dd       	rcall	.-1400   	; 0x4f6 <tinyDebugger_send_int>
	
	return potential;
}
     a6e:	c7 01       	movw	r24, r14
     a70:	b6 01       	movw	r22, r12
     a72:	df 91       	pop	r29
     a74:	cf 91       	pop	r28
     a76:	ff 90       	pop	r15
     a78:	ef 90       	pop	r14
     a7a:	df 90       	pop	r13
     a7c:	cf 90       	pop	r12
     a7e:	bf 90       	pop	r11
     a80:	af 90       	pop	r10
     a82:	9f 90       	pop	r9
     a84:	8f 90       	pop	r8
     a86:	7f 90       	pop	r7
     a88:	6f 90       	pop	r6
     a8a:	5f 90       	pop	r5
     a8c:	4f 90       	pop	r4
     a8e:	08 95       	ret

00000a90 <tinyDendrite_update_signals>:
/*
This function converts the 8 bit value from the ADC into one of the signal types defined in DendriteSignal
We also update the charging state
*/
void tinyDendrite_update_signals(void)
{
     a90:	2f 92       	push	r2
     a92:	3f 92       	push	r3
     a94:	4f 92       	push	r4
     a96:	5f 92       	push	r5
     a98:	6f 92       	push	r6
     a9a:	7f 92       	push	r7
     a9c:	8f 92       	push	r8
     a9e:	9f 92       	push	r9
     aa0:	af 92       	push	r10
     aa2:	bf 92       	push	r11
     aa4:	cf 92       	push	r12
     aa6:	df 92       	push	r13
     aa8:	ef 92       	push	r14
     aaa:	ff 92       	push	r15
     aac:	0f 93       	push	r16
     aae:	1f 93       	push	r17
     ab0:	cf 93       	push	r28
     ab2:	df 93       	push	r29
     ab4:	06 e1       	ldi	r16, 0x16	; 22
     ab6:	1e e3       	ldi	r17, 0x3E	; 62
     ab8:	0f 2e       	mov	r0, r31
     aba:	f3 e5       	ldi	r31, 0x53	; 83
     abc:	cf 2e       	mov	r12, r31
     abe:	fe e3       	ldi	r31, 0x3E	; 62
     ac0:	df 2e       	mov	r13, r31
     ac2:	f0 2d       	mov	r31, r0
     ac4:	0f 2e       	mov	r0, r31
     ac6:	fd e5       	ldi	r31, 0x5D	; 93
     ac8:	ef 2e       	mov	r14, r31
     aca:	fe e3       	ldi	r31, 0x3E	; 62
     acc:	ff 2e       	mov	r15, r31
     ace:	f0 2d       	mov	r31, r0
     ad0:	e6 01       	movw	r28, r12
*/
static void tinyDendrite_read_signals(void)
{
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_values[i] = ADC_get_conversion(Dendrite_ports[i]);
     ad2:	f8 01       	movw	r30, r16
     ad4:	81 91       	ld	r24, Z+
     ad6:	8f 01       	movw	r16, r30
     ad8:	51 db       	rcall	.-2398   	; 0x17c <ADC_get_conversion>
     ada:	89 93       	st	Y+, r24
     adc:	99 93       	st	Y+, r25
/*
This function reads the voltage at the Dendrite inputs with the ADC
*/
static void tinyDendrite_read_signals(void)
{
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
     ade:	ce 15       	cp	r28, r14
     ae0:	df 05       	cpc	r29, r15
     ae2:	b9 f7       	brne	.-18     	; 0xad2 <tinyDendrite_update_signals+0x42>
	{
		tinyDendrite_values[i] = ADC_get_conversion(Dendrite_ports[i]);
	}
	tinyDebugger_send_int("Dendrite1", tinyDendrite_values[0]);
     ae4:	c3 e5       	ldi	r28, 0x53	; 83
     ae6:	de e3       	ldi	r29, 0x3E	; 62
     ae8:	68 81       	ld	r22, Y
     aea:	79 81       	ldd	r23, Y+1	; 0x01
     aec:	8c e8       	ldi	r24, 0x8C	; 140
     aee:	9f e9       	ldi	r25, 0x9F	; 159
     af0:	02 dd       	rcall	.-1532   	; 0x4f6 <tinyDebugger_send_int>
	tinyDebugger_send_int("Dendrite2", tinyDendrite_values[1]);
     af2:	6a 81       	ldd	r22, Y+2	; 0x02
     af4:	7b 81       	ldd	r23, Y+3	; 0x03
     af6:	86 e9       	ldi	r24, 0x96	; 150
     af8:	9f e9       	ldi	r25, 0x9F	; 159
     afa:	fd dc       	rcall	.-1542   	; 0x4f6 <tinyDebugger_send_int>
	tinyDebugger_send_int("Dendrite3", tinyDendrite_values[2]);
     afc:	6c 81       	ldd	r22, Y+4	; 0x04
     afe:	7d 81       	ldd	r23, Y+5	; 0x05
     b00:	80 ea       	ldi	r24, 0xA0	; 160
     b02:	9f e9       	ldi	r25, 0x9F	; 159
     b04:	f8 dc       	rcall	.-1552   	; 0x4f6 <tinyDebugger_send_int>
	tinyDebugger_send_int("Dendrite4", tinyDendrite_values[3]);
     b06:	6e 81       	ldd	r22, Y+6	; 0x06
     b08:	7f 81       	ldd	r23, Y+7	; 0x07
     b0a:	8a ea       	ldi	r24, 0xAA	; 170
     b0c:	9f e9       	ldi	r25, 0x9F	; 159
     b0e:	f3 dc       	rcall	.-1562   	; 0x4f6 <tinyDebugger_send_int>
	tinyDebugger_send_int("Dendrite5", tinyDendrite_values[4]);
     b10:	68 85       	ldd	r22, Y+8	; 0x08
     b12:	79 85       	ldd	r23, Y+9	; 0x09
     b14:	84 eb       	ldi	r24, 0xB4	; 180
     b16:	9f e9       	ldi	r25, 0x9F	; 159
     b18:	ee dc       	rcall	.-1572   	; 0x4f6 <tinyDebugger_send_int>
{
	
	//Read the analog voltage values on each of the Dendrites
	tinyDendrite_read_signals();
	
	tinyCharge_set_charging(false);
     b1a:	80 e0       	ldi	r24, 0x00	; 0
     b1c:	e1 dc       	rcall	.-1598   	; 0x4e0 <tinyCharge_set_charging>
     b1e:	ce e4       	ldi	r28, 0x4E	; 78
     b20:	de e3       	ldi	r29, 0x3E	; 62
     b22:	09 e4       	ldi	r16, 0x49	; 73
     b24:	1e e3       	ldi	r17, 0x3E	; 62
     b26:	0f 2e       	mov	r0, r31
     b28:	f3 e5       	ldi	r31, 0x53	; 83
     b2a:	8f 2e       	mov	r8, r31
     b2c:	fe e3       	ldi	r31, 0x3E	; 62
     b2e:	9f 2e       	mov	r9, r31
     b30:	f0 2d       	mov	r31, r0
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     b32:	66 24       	eor	r6, r6
     b34:	63 94       	inc	r6
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     b36:	68 94       	set
     b38:	22 24       	eor	r2, r2
     b3a:	21 f8       	bld	r2, 1
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     b3c:	68 94       	set
     b3e:	33 24       	eor	r3, r3
     b40:	32 f8       	bld	r3, 2
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     b42:	0f 2e       	mov	r0, r31
     b44:	f6 e0       	ldi	r31, 0x06	; 6
     b46:	4f 2e       	mov	r4, r31
     b48:	f0 2d       	mov	r31, r0
			tinyDendrite_current_signals[i] = CHARGING;
			tinyCharge_set_charging(true);
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     b4a:	0f 2e       	mov	r0, r31
     b4c:	f5 e0       	ldi	r31, 0x05	; 5
     b4e:	7f 2e       	mov	r7, r31
     b50:	f0 2d       	mov	r31, r0
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = CHARGING;
     b52:	0f 2e       	mov	r0, r31
     b54:	f7 e0       	ldi	r31, 0x07	; 7
     b56:	5f 2e       	mov	r5, r31
     b58:	f0 2d       	mov	r31, r0
     b5a:	7e 01       	movw	r14, r28
     b5c:	58 01       	movw	r10, r16
	
	tinyCharge_set_charging(false);
	
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
     b5e:	88 81       	ld	r24, Y
     b60:	f8 01       	movw	r30, r16
     b62:	80 83       	st	Z, r24
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
     b64:	f6 01       	movw	r30, r12
     b66:	81 91       	ld	r24, Z+
     b68:	91 91       	ld	r25, Z+
     b6a:	6f 01       	movw	r12, r30
     b6c:	89 3e       	cpi	r24, 0xE9	; 233
     b6e:	91 05       	cpc	r25, r1
     b70:	20 f0       	brcs	.+8      	; 0xb7a <tinyDendrite_update_signals+0xea>
		{
			tinyDendrite_current_signals[i] = CHARGING;
     b72:	58 82       	st	Y, r5
			tinyCharge_set_charging(true);
     b74:	86 2d       	mov	r24, r6
     b76:	b4 dc       	rcall	.-1688   	; 0x4e0 <tinyCharge_set_charging>
     b78:	1f c0       	rjmp	.+62     	; 0xbb8 <tinyDendrite_update_signals+0x128>
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
     b7a:	88 3c       	cpi	r24, 0xC8	; 200
     b7c:	91 05       	cpc	r25, r1
     b7e:	10 f0       	brcs	.+4      	; 0xb84 <tinyDendrite_update_signals+0xf4>
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     b80:	78 82       	st	Y, r7
     b82:	1a c0       	rjmp	.+52     	; 0xbb8 <tinyDendrite_update_signals+0x128>
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
     b84:	87 3a       	cpi	r24, 0xA7	; 167
     b86:	91 05       	cpc	r25, r1
     b88:	10 f0       	brcs	.+4      	; 0xb8e <tinyDendrite_update_signals+0xfe>
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     b8a:	48 82       	st	Y, r4
     b8c:	15 c0       	rjmp	.+42     	; 0xbb8 <tinyDendrite_update_signals+0x128>
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
     b8e:	85 38       	cpi	r24, 0x85	; 133
     b90:	91 05       	cpc	r25, r1
     b92:	10 f0       	brcs	.+4      	; 0xb98 <tinyDendrite_update_signals+0x108>
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     b94:	38 82       	st	Y, r3
     b96:	10 c0       	rjmp	.+32     	; 0xbb8 <tinyDendrite_update_signals+0x128>
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
     b98:	84 36       	cpi	r24, 0x64	; 100
     b9a:	91 05       	cpc	r25, r1
     b9c:	10 f0       	brcs	.+4      	; 0xba2 <tinyDendrite_update_signals+0x112>
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     b9e:	28 82       	st	Y, r2
     ba0:	0b c0       	rjmp	.+22     	; 0xbb8 <tinyDendrite_update_signals+0x128>
		}
		else if (tinyDendrite_values[i] > HIGH_INHIB_THRESHOLD)
     ba2:	83 34       	cpi	r24, 0x43	; 67
     ba4:	91 05       	cpc	r25, r1
     ba6:	18 f0       	brcs	.+6      	; 0xbae <tinyDendrite_update_signals+0x11e>
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
     ba8:	83 e0       	ldi	r24, 0x03	; 3
     baa:	88 83       	st	Y, r24
     bac:	05 c0       	rjmp	.+10     	; 0xbb8 <tinyDendrite_update_signals+0x128>
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
     bae:	82 97       	sbiw	r24, 0x22	; 34
     bb0:	10 f0       	brcs	.+4      	; 0xbb6 <tinyDendrite_update_signals+0x126>
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     bb2:	68 82       	st	Y, r6
     bb4:	01 c0       	rjmp	.+2      	; 0xbb8 <tinyDendrite_update_signals+0x128>
		}
		else
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     bb6:	18 82       	st	Y, r1
     bb8:	0f 5f       	subi	r16, 0xFF	; 255
     bba:	1f 4f       	sbci	r17, 0xFF	; 255
		}
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
     bbc:	f7 01       	movw	r30, r14
     bbe:	90 81       	ld	r25, Z
     bc0:	f5 01       	movw	r30, r10
     bc2:	80 81       	ld	r24, Z
     bc4:	98 13       	cpse	r25, r24
     bc6:	02 c0       	rjmp	.+4      	; 0xbcc <tinyDendrite_update_signals+0x13c>
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     bc8:	f7 01       	movw	r30, r14
     bca:	10 82       	st	Z, r1
     bcc:	21 96       	adiw	r28, 0x01	; 1
	//Read the analog voltage values on each of the Dendrites
	tinyDendrite_read_signals();
	
	tinyCharge_set_charging(false);
	
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
     bce:	c8 15       	cp	r28, r8
     bd0:	d9 05       	cpc	r29, r9
     bd2:	19 f6       	brne	.-122    	; 0xb5a <tinyDendrite_update_signals+0xca>
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
		}
	}
}
     bd4:	df 91       	pop	r29
     bd6:	cf 91       	pop	r28
     bd8:	1f 91       	pop	r17
     bda:	0f 91       	pop	r16
     bdc:	ff 90       	pop	r15
     bde:	ef 90       	pop	r14
     be0:	df 90       	pop	r13
     be2:	cf 90       	pop	r12
     be4:	bf 90       	pop	r11
     be6:	af 90       	pop	r10
     be8:	9f 90       	pop	r9
     bea:	8f 90       	pop	r8
     bec:	7f 90       	pop	r7
     bee:	6f 90       	pop	r6
     bf0:	5f 90       	pop	r5
     bf2:	4f 90       	pop	r4
     bf4:	3f 90       	pop	r3
     bf6:	2f 90       	pop	r2
     bf8:	08 95       	ret

00000bfa <tinyDendrite_get_potential>:
outside. It uses the previously declared functions to return the potential.
*/
int16_t tinyDendrite_get_potential()
{
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
     bfa:	4a df       	rcall	.-364    	; 0xa90 <tinyDendrite_update_signals>
     bfc:	ee e4       	ldi	r30, 0x4E	; 78
     bfe:	fe e3       	ldi	r31, 0x3E	; 62
     c00:	43 e5       	ldi	r20, 0x53	; 83
     c02:	5e e3       	ldi	r21, 0x3E	; 62
	
	int16_t return_potential_val = 0;
     c04:	20 e0       	ldi	r18, 0x00	; 0
     c06:	30 e0       	ldi	r19, 0x00	; 0
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		switch(tinyDendrite_current_signals[i])
     c08:	91 91       	ld	r25, Z+
     c0a:	93 30       	cpi	r25, 0x03	; 3
     c0c:	a1 f0       	breq	.+40     	; 0xc36 <tinyDendrite_get_potential+0x3c>
     c0e:	28 f4       	brcc	.+10     	; 0xc1a <tinyDendrite_get_potential+0x20>
     c10:	91 30       	cpi	r25, 0x01	; 1
     c12:	b9 f0       	breq	.+46     	; 0xc42 <tinyDendrite_get_potential+0x48>
     c14:	92 30       	cpi	r25, 0x02	; 2
     c16:	91 f0       	breq	.+36     	; 0xc3c <tinyDendrite_get_potential+0x42>
     c18:	16 c0       	rjmp	.+44     	; 0xc46 <tinyDendrite_get_potential+0x4c>
     c1a:	95 30       	cpi	r25, 0x05	; 5
     c1c:	31 f0       	breq	.+12     	; 0xc2a <tinyDendrite_get_potential+0x30>
     c1e:	40 f0       	brcs	.+16     	; 0xc30 <tinyDendrite_get_potential+0x36>
     c20:	96 30       	cpi	r25, 0x06	; 6
     c22:	89 f4       	brne	.+34     	; 0xc46 <tinyDendrite_get_potential+0x4c>
		{
			case NO_SIGNAL:
				return_potential_val += NO_SIGNAL_REACTION;
				break;
			case HIGH_EXCITE:
				return_potential_val += HIGH_EXCITE_REACTION;
     c24:	2c 5c       	subi	r18, 0xCC	; 204
     c26:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     c28:	0e c0       	rjmp	.+28     	; 0xc46 <tinyDendrite_get_potential+0x4c>
			case NORMAL_EXCITE:
				return_potential_val += NORMAL_EXCITE_REACTION;
     c2a:	26 5e       	subi	r18, 0xE6	; 230
     c2c:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     c2e:	0b c0       	rjmp	.+22     	; 0xc46 <tinyDendrite_get_potential+0x4c>
			case LOW_EXCITE:
				return_potential_val += LOW_EXCITE_REACTION;
     c30:	2c 5e       	subi	r18, 0xEC	; 236
     c32:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     c34:	08 c0       	rjmp	.+16     	; 0xc46 <tinyDendrite_get_potential+0x4c>
			case HIGH_INHIB:
				return_potential_val += HIGH_INHIB_REACTION;
     c36:	22 53       	subi	r18, 0x32	; 50
     c38:	31 09       	sbc	r19, r1
				break;
     c3a:	05 c0       	rjmp	.+10     	; 0xc46 <tinyDendrite_get_potential+0x4c>
			case NORMAL_INHIB:
				return_potential_val += NORMAL_INHIB_REACTION;
     c3c:	2a 51       	subi	r18, 0x1A	; 26
     c3e:	31 09       	sbc	r19, r1
				break;
     c40:	02 c0       	rjmp	.+4      	; 0xc46 <tinyDendrite_get_potential+0x4c>
			case LOW_INHIB:
				return_potential_val += LOW_INHIB_REACTION;
     c42:	24 51       	subi	r18, 0x14	; 20
     c44:	31 09       	sbc	r19, r1
{
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
	
	int16_t return_potential_val = 0;
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
     c46:	e4 17       	cp	r30, r20
     c48:	f5 07       	cpc	r31, r21
     c4a:	f1 f6       	brne	.-68     	; 0xc08 <tinyDendrite_get_potential+0xe>
			default:
				break;
		}
	}
	return return_potential_val;
}
     c4c:	c9 01       	movw	r24, r18
     c4e:	08 95       	ret

00000c50 <tinyDendrite_update_potential>:

double tinyDendrite_update_potential(double potential){
     c50:	cf 92       	push	r12
     c52:	df 92       	push	r13
     c54:	ef 92       	push	r14
     c56:	ff 92       	push	r15
     c58:	6b 01       	movw	r12, r22
     c5a:	7c 01       	movw	r14, r24
	
	uint16_t potential_change = tinyDendrite_get_potential();
     c5c:	ce df       	rcall	.-100    	; 0xbfa <tinyDendrite_get_potential>
	potential += potential_change;
	return potential;
     c5e:	bc 01       	movw	r22, r24
     c60:	80 e0       	ldi	r24, 0x00	; 0
     c62:	90 e0       	ldi	r25, 0x00	; 0
     c64:	a5 d1       	rcall	.+842    	; 0xfb0 <__floatunsisf>
     c66:	a7 01       	movw	r20, r14
     c68:	96 01       	movw	r18, r12
     c6a:	89 d0       	rcall	.+274    	; 0xd7e <__addsf3>
     c6c:	ff 90       	pop	r15
     c6e:	ef 90       	pop	r14
     c70:	df 90       	pop	r13
     c72:	cf 90       	pop	r12
     c74:	08 95       	ret

00000c76 <__vector_6>:
This function is called every time the RTC (Real Time Clock) counter overflows.
With the current settings, it will be called every ms.
The RTC clock runs at 1kHz, and the number of cycles before overflow is set with RTC.PER = someHexValue (e.g. 0x20) in src/rtc.c
*/
ISR(RTC_CNT_vect)
{
     c76:	1f 92       	push	r1
     c78:	0f 92       	push	r0
     c7a:	0f b6       	in	r0, 0x3f	; 63
     c7c:	0f 92       	push	r0
     c7e:	11 24       	eor	r1, r1
     c80:	2f 93       	push	r18
     c82:	3f 93       	push	r19
     c84:	4f 93       	push	r20
     c86:	5f 93       	push	r21
     c88:	6f 93       	push	r22
     c8a:	7f 93       	push	r23
     c8c:	8f 93       	push	r24
     c8e:	9f 93       	push	r25
     c90:	af 93       	push	r26
     c92:	bf 93       	push	r27
     c94:	cf 93       	push	r28
     c96:	ef 93       	push	r30
     c98:	ff 93       	push	r31
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     c9a:	c1 e0       	ldi	r28, 0x01	; 1
     c9c:	c0 93 5d 3e 	sts	0x3E5D, r28	; 0x803e5d <tinyISR_interrupt_flag>
{
	// Set flag to let main loop run a new cycle
	tinyISR_setflag(true);
	
	// Timer counter incrementation
	tinyTime_counter_increment();
     ca0:	ae dc       	rcall	.-1700   	; 0x5fe <tinyTime_counter_increment>

	/* Overflow interrupt flag has to be cleared manually */
	RTC.INTFLAGS = RTC_OVF_bm;
     ca2:	c0 93 43 01 	sts	0x0143, r28	; 0x800143 <__TEXT_REGION_LENGTH__+0x700143>
}
     ca6:	ff 91       	pop	r31
     ca8:	ef 91       	pop	r30
     caa:	cf 91       	pop	r28
     cac:	bf 91       	pop	r27
     cae:	af 91       	pop	r26
     cb0:	9f 91       	pop	r25
     cb2:	8f 91       	pop	r24
     cb4:	7f 91       	pop	r23
     cb6:	6f 91       	pop	r22
     cb8:	5f 91       	pop	r21
     cba:	4f 91       	pop	r20
     cbc:	3f 91       	pop	r19
     cbe:	2f 91       	pop	r18
     cc0:	0f 90       	pop	r0
     cc2:	0f be       	out	0x3f, r0	; 63
     cc4:	0f 90       	pop	r0
     cc6:	1f 90       	pop	r1
     cc8:	18 95       	reti

00000cca <tinyISR_setflag>:
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     cca:	80 93 5d 3e 	sts	0x3E5D, r24	; 0x803e5d <tinyISR_interrupt_flag>
     cce:	08 95       	ret

00000cd0 <tinyISR_getflag>:
}

_Bool tinyISR_getflag(void)
{
	return tinyISR_interrupt_flag;
}
     cd0:	80 91 5d 3e 	lds	r24, 0x3E5D	; 0x803e5d <tinyISR_interrupt_flag>
     cd4:	08 95       	ret

00000cd6 <tinyPotential_update>:
The function which will run in the main loop.
This function will run on interrupts by the RTC module.
*/
void tinyPotential_update()
{
	tinyDebugger_send_float("Potential", tinyPotential_potential);
     cd6:	40 91 5e 3e 	lds	r20, 0x3E5E	; 0x803e5e <tinyPotential_potential>
     cda:	50 91 5f 3e 	lds	r21, 0x3E5F	; 0x803e5f <tinyPotential_potential+0x1>
     cde:	60 91 60 3e 	lds	r22, 0x3E60	; 0x803e60 <tinyPotential_potential+0x2>
     ce2:	70 91 61 3e 	lds	r23, 0x3E61	; 0x803e61 <tinyPotential_potential+0x3>
     ce6:	8e eb       	ldi	r24, 0xBE	; 190
     ce8:	9f e9       	ldi	r25, 0x9F	; 159
     cea:	15 dc       	rcall	.-2006   	; 0x516 <tinyDebugger_send_float>
	// but for simplification, we just assume that each cycle will take one ms. The consequences for a cycle taking longer
	// are negligible. 
	
	uint8_t time_since_last_update = 1;
	tinyPotential_potential *= (exp(-(time_since_last_update/TINYPOTENTIAL_TIME_CONST)));
	if(fabs(tinyPotential_potential)<0.01){
     cec:	80 91 5e 3e 	lds	r24, 0x3E5E	; 0x803e5e <tinyPotential_potential>
     cf0:	90 91 5f 3e 	lds	r25, 0x3E5F	; 0x803e5f <tinyPotential_potential+0x1>
     cf4:	a0 91 60 3e 	lds	r26, 0x3E60	; 0x803e60 <tinyPotential_potential+0x2>
     cf8:	b0 91 61 3e 	lds	r27, 0x3E61	; 0x803e61 <tinyPotential_potential+0x3>
     cfc:	bc 01       	movw	r22, r24
     cfe:	cd 01       	movw	r24, r26
     d00:	9f 77       	andi	r25, 0x7F	; 127
     d02:	2a e0       	ldi	r18, 0x0A	; 10
     d04:	37 ed       	ldi	r19, 0xD7	; 215
     d06:	43 e2       	ldi	r20, 0x23	; 35
     d08:	5c e3       	ldi	r21, 0x3C	; 60
     d0a:	a5 d0       	rcall	.+330    	; 0xe56 <__cmpsf2>
     d0c:	88 23       	and	r24, r24
     d0e:	44 f4       	brge	.+16     	; 0xd20 <tinyPotential_update+0x4a>
		tinyPotential_potential=0;
     d10:	10 92 5e 3e 	sts	0x3E5E, r1	; 0x803e5e <tinyPotential_potential>
     d14:	10 92 5f 3e 	sts	0x3E5F, r1	; 0x803e5f <tinyPotential_potential+0x1>
     d18:	10 92 60 3e 	sts	0x3E60, r1	; 0x803e60 <tinyPotential_potential+0x2>
     d1c:	10 92 61 3e 	sts	0x3E61, r1	; 0x803e61 <tinyPotential_potential+0x3>
	tinyDebugger_send_float("Potential", tinyPotential_potential);
	//Some of the potential in the neuron has decayed away
	tinyPotential_decay();
	
	// Update potential with values from Dendrites
	tinyPotential_potential = tinyDendrite_update_potential(tinyPotential_potential);
     d20:	60 91 5e 3e 	lds	r22, 0x3E5E	; 0x803e5e <tinyPotential_potential>
     d24:	70 91 5f 3e 	lds	r23, 0x3E5F	; 0x803e5f <tinyPotential_potential+0x1>
     d28:	80 91 60 3e 	lds	r24, 0x3E60	; 0x803e60 <tinyPotential_potential+0x2>
     d2c:	90 91 61 3e 	lds	r25, 0x3E61	; 0x803e61 <tinyPotential_potential+0x3>
     d30:	8f df       	rcall	.-226    	; 0xc50 <tinyDendrite_update_potential>
     d32:	60 93 5e 3e 	sts	0x3E5E, r22	; 0x803e5e <tinyPotential_potential>
     d36:	70 93 5f 3e 	sts	0x3E5F, r23	; 0x803e5f <tinyPotential_potential+0x1>
     d3a:	80 93 60 3e 	sts	0x3E60, r24	; 0x803e60 <tinyPotential_potential+0x2>
     d3e:	90 93 61 3e 	sts	0x3E61, r25	; 0x803e61 <tinyPotential_potential+0x3>
	
	// Update potential from button press
	tinyPotential_potential = tinyButton_update_potential(tinyPotential_potential);
     d42:	7b dd       	rcall	.-1290   	; 0x83a <tinyButton_update_potential>
     d44:	60 93 5e 3e 	sts	0x3E5E, r22	; 0x803e5e <tinyPotential_potential>
     d48:	70 93 5f 3e 	sts	0x3E5F, r23	; 0x803e5f <tinyPotential_potential+0x1>
     d4c:	80 93 60 3e 	sts	0x3E60, r24	; 0x803e60 <tinyPotential_potential+0x2>
     d50:	90 93 61 3e 	sts	0x3E61, r25	; 0x803e61 <tinyPotential_potential+0x3>
	
	// Update potential with values from spontaneous pulse.
	tinyPotential_potential = tinyPulse_update_potential(tinyPotential_potential);
     d54:	1f dc       	rcall	.-1986   	; 0x594 <tinyPulse_update_potential>
     d56:	60 93 5e 3e 	sts	0x3E5E, r22	; 0x803e5e <tinyPotential_potential>
     d5a:	70 93 5f 3e 	sts	0x3E5F, r23	; 0x803e5f <tinyPotential_potential+0x1>
     d5e:	80 93 60 3e 	sts	0x3E60, r24	; 0x803e60 <tinyPotential_potential+0x2>
     d62:	90 93 61 3e 	sts	0x3E61, r25	; 0x803e61 <tinyPotential_potential+0x3>
	
	// Let the axon affect the potential
	// This is also where we decide whether or not the axon should fire
	tinyPotential_potential = tinyAxon_update_potential(tinyPotential_potential);
     d66:	d8 dd       	rcall	.-1104   	; 0x918 <tinyAxon_update_potential>
     d68:	60 93 5e 3e 	sts	0x3E5E, r22	; 0x803e5e <tinyPotential_potential>
     d6c:	70 93 5f 3e 	sts	0x3E5F, r23	; 0x803e5f <tinyPotential_potential+0x1>
     d70:	80 93 60 3e 	sts	0x3E60, r24	; 0x803e60 <tinyPotential_potential+0x2>
     d74:	90 93 61 3e 	sts	0x3E61, r25	; 0x803e61 <tinyPotential_potential+0x3>

	//Update the led
	potential_to_RGB_update_LEDs(tinyPotential_potential);
     d78:	87 dc       	rcall	.-1778   	; 0x688 <potential_to_RGB_update_LEDs>
     d7a:	08 95       	ret

00000d7c <__subsf3>:
     d7c:	50 58       	subi	r21, 0x80	; 128

00000d7e <__addsf3>:
     d7e:	bb 27       	eor	r27, r27
     d80:	aa 27       	eor	r26, r26
     d82:	0e 94 d6 06 	call	0xdac	; 0xdac <__addsf3x>
     d86:	0c 94 50 08 	jmp	0x10a0	; 0x10a0 <__fp_round>
     d8a:	0e 94 42 08 	call	0x1084	; 0x1084 <__fp_pscA>
     d8e:	38 f0       	brcs	.+14     	; 0xd9e <__addsf3+0x20>
     d90:	0e 94 49 08 	call	0x1092	; 0x1092 <__fp_pscB>
     d94:	20 f0       	brcs	.+8      	; 0xd9e <__addsf3+0x20>
     d96:	39 f4       	brne	.+14     	; 0xda6 <__addsf3+0x28>
     d98:	9f 3f       	cpi	r25, 0xFF	; 255
     d9a:	19 f4       	brne	.+6      	; 0xda2 <__addsf3+0x24>
     d9c:	26 f4       	brtc	.+8      	; 0xda6 <__addsf3+0x28>
     d9e:	0c 94 3f 08 	jmp	0x107e	; 0x107e <__fp_nan>
     da2:	0e f4       	brtc	.+2      	; 0xda6 <__addsf3+0x28>
     da4:	e0 95       	com	r30
     da6:	e7 fb       	bst	r30, 7
     da8:	0c 94 39 08 	jmp	0x1072	; 0x1072 <__fp_inf>

00000dac <__addsf3x>:
     dac:	e9 2f       	mov	r30, r25
     dae:	0e 94 61 08 	call	0x10c2	; 0x10c2 <__fp_split3>
     db2:	58 f3       	brcs	.-42     	; 0xd8a <__addsf3+0xc>
     db4:	ba 17       	cp	r27, r26
     db6:	62 07       	cpc	r22, r18
     db8:	73 07       	cpc	r23, r19
     dba:	84 07       	cpc	r24, r20
     dbc:	95 07       	cpc	r25, r21
     dbe:	20 f0       	brcs	.+8      	; 0xdc8 <__addsf3x+0x1c>
     dc0:	79 f4       	brne	.+30     	; 0xde0 <__addsf3x+0x34>
     dc2:	a6 f5       	brtc	.+104    	; 0xe2c <__addsf3x+0x80>
     dc4:	0c 94 83 08 	jmp	0x1106	; 0x1106 <__fp_zero>
     dc8:	0e f4       	brtc	.+2      	; 0xdcc <__addsf3x+0x20>
     dca:	e0 95       	com	r30
     dcc:	0b 2e       	mov	r0, r27
     dce:	ba 2f       	mov	r27, r26
     dd0:	a0 2d       	mov	r26, r0
     dd2:	0b 01       	movw	r0, r22
     dd4:	b9 01       	movw	r22, r18
     dd6:	90 01       	movw	r18, r0
     dd8:	0c 01       	movw	r0, r24
     dda:	ca 01       	movw	r24, r20
     ddc:	a0 01       	movw	r20, r0
     dde:	11 24       	eor	r1, r1
     de0:	ff 27       	eor	r31, r31
     de2:	59 1b       	sub	r21, r25
     de4:	99 f0       	breq	.+38     	; 0xe0c <__addsf3x+0x60>
     de6:	59 3f       	cpi	r21, 0xF9	; 249
     de8:	50 f4       	brcc	.+20     	; 0xdfe <__addsf3x+0x52>
     dea:	50 3e       	cpi	r21, 0xE0	; 224
     dec:	68 f1       	brcs	.+90     	; 0xe48 <__addsf3x+0x9c>
     dee:	1a 16       	cp	r1, r26
     df0:	f0 40       	sbci	r31, 0x00	; 0
     df2:	a2 2f       	mov	r26, r18
     df4:	23 2f       	mov	r18, r19
     df6:	34 2f       	mov	r19, r20
     df8:	44 27       	eor	r20, r20
     dfa:	58 5f       	subi	r21, 0xF8	; 248
     dfc:	f3 cf       	rjmp	.-26     	; 0xde4 <__addsf3x+0x38>
     dfe:	46 95       	lsr	r20
     e00:	37 95       	ror	r19
     e02:	27 95       	ror	r18
     e04:	a7 95       	ror	r26
     e06:	f0 40       	sbci	r31, 0x00	; 0
     e08:	53 95       	inc	r21
     e0a:	c9 f7       	brne	.-14     	; 0xdfe <__addsf3x+0x52>
     e0c:	7e f4       	brtc	.+30     	; 0xe2c <__addsf3x+0x80>
     e0e:	1f 16       	cp	r1, r31
     e10:	ba 0b       	sbc	r27, r26
     e12:	62 0b       	sbc	r22, r18
     e14:	73 0b       	sbc	r23, r19
     e16:	84 0b       	sbc	r24, r20
     e18:	ba f0       	brmi	.+46     	; 0xe48 <__addsf3x+0x9c>
     e1a:	91 50       	subi	r25, 0x01	; 1
     e1c:	a1 f0       	breq	.+40     	; 0xe46 <__addsf3x+0x9a>
     e1e:	ff 0f       	add	r31, r31
     e20:	bb 1f       	adc	r27, r27
     e22:	66 1f       	adc	r22, r22
     e24:	77 1f       	adc	r23, r23
     e26:	88 1f       	adc	r24, r24
     e28:	c2 f7       	brpl	.-16     	; 0xe1a <__addsf3x+0x6e>
     e2a:	0e c0       	rjmp	.+28     	; 0xe48 <__addsf3x+0x9c>
     e2c:	ba 0f       	add	r27, r26
     e2e:	62 1f       	adc	r22, r18
     e30:	73 1f       	adc	r23, r19
     e32:	84 1f       	adc	r24, r20
     e34:	48 f4       	brcc	.+18     	; 0xe48 <__addsf3x+0x9c>
     e36:	87 95       	ror	r24
     e38:	77 95       	ror	r23
     e3a:	67 95       	ror	r22
     e3c:	b7 95       	ror	r27
     e3e:	f7 95       	ror	r31
     e40:	9e 3f       	cpi	r25, 0xFE	; 254
     e42:	08 f0       	brcs	.+2      	; 0xe46 <__addsf3x+0x9a>
     e44:	b0 cf       	rjmp	.-160    	; 0xda6 <__addsf3+0x28>
     e46:	93 95       	inc	r25
     e48:	88 0f       	add	r24, r24
     e4a:	08 f0       	brcs	.+2      	; 0xe4e <__addsf3x+0xa2>
     e4c:	99 27       	eor	r25, r25
     e4e:	ee 0f       	add	r30, r30
     e50:	97 95       	ror	r25
     e52:	87 95       	ror	r24
     e54:	08 95       	ret

00000e56 <__cmpsf2>:
     e56:	0e 94 15 08 	call	0x102a	; 0x102a <__fp_cmp>
     e5a:	08 f4       	brcc	.+2      	; 0xe5e <__cmpsf2+0x8>
     e5c:	81 e0       	ldi	r24, 0x01	; 1
     e5e:	08 95       	ret

00000e60 <__divsf3>:
     e60:	0e 94 44 07 	call	0xe88	; 0xe88 <__divsf3x>
     e64:	0c 94 50 08 	jmp	0x10a0	; 0x10a0 <__fp_round>
     e68:	0e 94 49 08 	call	0x1092	; 0x1092 <__fp_pscB>
     e6c:	58 f0       	brcs	.+22     	; 0xe84 <__divsf3+0x24>
     e6e:	0e 94 42 08 	call	0x1084	; 0x1084 <__fp_pscA>
     e72:	40 f0       	brcs	.+16     	; 0xe84 <__divsf3+0x24>
     e74:	29 f4       	brne	.+10     	; 0xe80 <__divsf3+0x20>
     e76:	5f 3f       	cpi	r21, 0xFF	; 255
     e78:	29 f0       	breq	.+10     	; 0xe84 <__divsf3+0x24>
     e7a:	0c 94 39 08 	jmp	0x1072	; 0x1072 <__fp_inf>
     e7e:	51 11       	cpse	r21, r1
     e80:	0c 94 84 08 	jmp	0x1108	; 0x1108 <__fp_szero>
     e84:	0c 94 3f 08 	jmp	0x107e	; 0x107e <__fp_nan>

00000e88 <__divsf3x>:
     e88:	0e 94 61 08 	call	0x10c2	; 0x10c2 <__fp_split3>
     e8c:	68 f3       	brcs	.-38     	; 0xe68 <__divsf3+0x8>

00000e8e <__divsf3_pse>:
     e8e:	99 23       	and	r25, r25
     e90:	b1 f3       	breq	.-20     	; 0xe7e <__divsf3+0x1e>
     e92:	55 23       	and	r21, r21
     e94:	91 f3       	breq	.-28     	; 0xe7a <__divsf3+0x1a>
     e96:	95 1b       	sub	r25, r21
     e98:	55 0b       	sbc	r21, r21
     e9a:	bb 27       	eor	r27, r27
     e9c:	aa 27       	eor	r26, r26
     e9e:	62 17       	cp	r22, r18
     ea0:	73 07       	cpc	r23, r19
     ea2:	84 07       	cpc	r24, r20
     ea4:	38 f0       	brcs	.+14     	; 0xeb4 <__divsf3_pse+0x26>
     ea6:	9f 5f       	subi	r25, 0xFF	; 255
     ea8:	5f 4f       	sbci	r21, 0xFF	; 255
     eaa:	22 0f       	add	r18, r18
     eac:	33 1f       	adc	r19, r19
     eae:	44 1f       	adc	r20, r20
     eb0:	aa 1f       	adc	r26, r26
     eb2:	a9 f3       	breq	.-22     	; 0xe9e <__divsf3_pse+0x10>
     eb4:	35 d0       	rcall	.+106    	; 0xf20 <__divsf3_pse+0x92>
     eb6:	0e 2e       	mov	r0, r30
     eb8:	3a f0       	brmi	.+14     	; 0xec8 <__divsf3_pse+0x3a>
     eba:	e0 e8       	ldi	r30, 0x80	; 128
     ebc:	32 d0       	rcall	.+100    	; 0xf22 <__divsf3_pse+0x94>
     ebe:	91 50       	subi	r25, 0x01	; 1
     ec0:	50 40       	sbci	r21, 0x00	; 0
     ec2:	e6 95       	lsr	r30
     ec4:	00 1c       	adc	r0, r0
     ec6:	ca f7       	brpl	.-14     	; 0xeba <__divsf3_pse+0x2c>
     ec8:	2b d0       	rcall	.+86     	; 0xf20 <__divsf3_pse+0x92>
     eca:	fe 2f       	mov	r31, r30
     ecc:	29 d0       	rcall	.+82     	; 0xf20 <__divsf3_pse+0x92>
     ece:	66 0f       	add	r22, r22
     ed0:	77 1f       	adc	r23, r23
     ed2:	88 1f       	adc	r24, r24
     ed4:	bb 1f       	adc	r27, r27
     ed6:	26 17       	cp	r18, r22
     ed8:	37 07       	cpc	r19, r23
     eda:	48 07       	cpc	r20, r24
     edc:	ab 07       	cpc	r26, r27
     ede:	b0 e8       	ldi	r27, 0x80	; 128
     ee0:	09 f0       	breq	.+2      	; 0xee4 <__divsf3_pse+0x56>
     ee2:	bb 0b       	sbc	r27, r27
     ee4:	80 2d       	mov	r24, r0
     ee6:	bf 01       	movw	r22, r30
     ee8:	ff 27       	eor	r31, r31
     eea:	93 58       	subi	r25, 0x83	; 131
     eec:	5f 4f       	sbci	r21, 0xFF	; 255
     eee:	3a f0       	brmi	.+14     	; 0xefe <__divsf3_pse+0x70>
     ef0:	9e 3f       	cpi	r25, 0xFE	; 254
     ef2:	51 05       	cpc	r21, r1
     ef4:	78 f0       	brcs	.+30     	; 0xf14 <__divsf3_pse+0x86>
     ef6:	0c 94 39 08 	jmp	0x1072	; 0x1072 <__fp_inf>
     efa:	0c 94 84 08 	jmp	0x1108	; 0x1108 <__fp_szero>
     efe:	5f 3f       	cpi	r21, 0xFF	; 255
     f00:	e4 f3       	brlt	.-8      	; 0xefa <__divsf3_pse+0x6c>
     f02:	98 3e       	cpi	r25, 0xE8	; 232
     f04:	d4 f3       	brlt	.-12     	; 0xefa <__divsf3_pse+0x6c>
     f06:	86 95       	lsr	r24
     f08:	77 95       	ror	r23
     f0a:	67 95       	ror	r22
     f0c:	b7 95       	ror	r27
     f0e:	f7 95       	ror	r31
     f10:	9f 5f       	subi	r25, 0xFF	; 255
     f12:	c9 f7       	brne	.-14     	; 0xf06 <__divsf3_pse+0x78>
     f14:	88 0f       	add	r24, r24
     f16:	91 1d       	adc	r25, r1
     f18:	96 95       	lsr	r25
     f1a:	87 95       	ror	r24
     f1c:	97 f9       	bld	r25, 7
     f1e:	08 95       	ret
     f20:	e1 e0       	ldi	r30, 0x01	; 1
     f22:	66 0f       	add	r22, r22
     f24:	77 1f       	adc	r23, r23
     f26:	88 1f       	adc	r24, r24
     f28:	bb 1f       	adc	r27, r27
     f2a:	62 17       	cp	r22, r18
     f2c:	73 07       	cpc	r23, r19
     f2e:	84 07       	cpc	r24, r20
     f30:	ba 07       	cpc	r27, r26
     f32:	20 f0       	brcs	.+8      	; 0xf3c <__divsf3_pse+0xae>
     f34:	62 1b       	sub	r22, r18
     f36:	73 0b       	sbc	r23, r19
     f38:	84 0b       	sbc	r24, r20
     f3a:	ba 0b       	sbc	r27, r26
     f3c:	ee 1f       	adc	r30, r30
     f3e:	88 f7       	brcc	.-30     	; 0xf22 <__divsf3_pse+0x94>
     f40:	e0 95       	com	r30
     f42:	08 95       	ret

00000f44 <__fixsfsi>:
     f44:	0e 94 a9 07 	call	0xf52	; 0xf52 <__fixunssfsi>
     f48:	68 94       	set
     f4a:	b1 11       	cpse	r27, r1
     f4c:	0c 94 84 08 	jmp	0x1108	; 0x1108 <__fp_szero>
     f50:	08 95       	ret

00000f52 <__fixunssfsi>:
     f52:	0e 94 69 08 	call	0x10d2	; 0x10d2 <__fp_splitA>
     f56:	88 f0       	brcs	.+34     	; 0xf7a <__fixunssfsi+0x28>
     f58:	9f 57       	subi	r25, 0x7F	; 127
     f5a:	98 f0       	brcs	.+38     	; 0xf82 <__fixunssfsi+0x30>
     f5c:	b9 2f       	mov	r27, r25
     f5e:	99 27       	eor	r25, r25
     f60:	b7 51       	subi	r27, 0x17	; 23
     f62:	b0 f0       	brcs	.+44     	; 0xf90 <__fixunssfsi+0x3e>
     f64:	e1 f0       	breq	.+56     	; 0xf9e <__fixunssfsi+0x4c>
     f66:	66 0f       	add	r22, r22
     f68:	77 1f       	adc	r23, r23
     f6a:	88 1f       	adc	r24, r24
     f6c:	99 1f       	adc	r25, r25
     f6e:	1a f0       	brmi	.+6      	; 0xf76 <__fixunssfsi+0x24>
     f70:	ba 95       	dec	r27
     f72:	c9 f7       	brne	.-14     	; 0xf66 <__fixunssfsi+0x14>
     f74:	14 c0       	rjmp	.+40     	; 0xf9e <__fixunssfsi+0x4c>
     f76:	b1 30       	cpi	r27, 0x01	; 1
     f78:	91 f0       	breq	.+36     	; 0xf9e <__fixunssfsi+0x4c>
     f7a:	0e 94 83 08 	call	0x1106	; 0x1106 <__fp_zero>
     f7e:	b1 e0       	ldi	r27, 0x01	; 1
     f80:	08 95       	ret
     f82:	0c 94 83 08 	jmp	0x1106	; 0x1106 <__fp_zero>
     f86:	67 2f       	mov	r22, r23
     f88:	78 2f       	mov	r23, r24
     f8a:	88 27       	eor	r24, r24
     f8c:	b8 5f       	subi	r27, 0xF8	; 248
     f8e:	39 f0       	breq	.+14     	; 0xf9e <__fixunssfsi+0x4c>
     f90:	b9 3f       	cpi	r27, 0xF9	; 249
     f92:	cc f3       	brlt	.-14     	; 0xf86 <__fixunssfsi+0x34>
     f94:	86 95       	lsr	r24
     f96:	77 95       	ror	r23
     f98:	67 95       	ror	r22
     f9a:	b3 95       	inc	r27
     f9c:	d9 f7       	brne	.-10     	; 0xf94 <__fixunssfsi+0x42>
     f9e:	3e f4       	brtc	.+14     	; 0xfae <__fixunssfsi+0x5c>
     fa0:	90 95       	com	r25
     fa2:	80 95       	com	r24
     fa4:	70 95       	com	r23
     fa6:	61 95       	neg	r22
     fa8:	7f 4f       	sbci	r23, 0xFF	; 255
     faa:	8f 4f       	sbci	r24, 0xFF	; 255
     fac:	9f 4f       	sbci	r25, 0xFF	; 255
     fae:	08 95       	ret

00000fb0 <__floatunsisf>:
     fb0:	e8 94       	clt
     fb2:	09 c0       	rjmp	.+18     	; 0xfc6 <__floatsisf+0x12>

00000fb4 <__floatsisf>:
     fb4:	97 fb       	bst	r25, 7
     fb6:	3e f4       	brtc	.+14     	; 0xfc6 <__floatsisf+0x12>
     fb8:	90 95       	com	r25
     fba:	80 95       	com	r24
     fbc:	70 95       	com	r23
     fbe:	61 95       	neg	r22
     fc0:	7f 4f       	sbci	r23, 0xFF	; 255
     fc2:	8f 4f       	sbci	r24, 0xFF	; 255
     fc4:	9f 4f       	sbci	r25, 0xFF	; 255
     fc6:	99 23       	and	r25, r25
     fc8:	a9 f0       	breq	.+42     	; 0xff4 <__floatsisf+0x40>
     fca:	f9 2f       	mov	r31, r25
     fcc:	96 e9       	ldi	r25, 0x96	; 150
     fce:	bb 27       	eor	r27, r27
     fd0:	93 95       	inc	r25
     fd2:	f6 95       	lsr	r31
     fd4:	87 95       	ror	r24
     fd6:	77 95       	ror	r23
     fd8:	67 95       	ror	r22
     fda:	b7 95       	ror	r27
     fdc:	f1 11       	cpse	r31, r1
     fde:	f8 cf       	rjmp	.-16     	; 0xfd0 <__floatsisf+0x1c>
     fe0:	fa f4       	brpl	.+62     	; 0x1020 <__floatsisf+0x6c>
     fe2:	bb 0f       	add	r27, r27
     fe4:	11 f4       	brne	.+4      	; 0xfea <__floatsisf+0x36>
     fe6:	60 ff       	sbrs	r22, 0
     fe8:	1b c0       	rjmp	.+54     	; 0x1020 <__floatsisf+0x6c>
     fea:	6f 5f       	subi	r22, 0xFF	; 255
     fec:	7f 4f       	sbci	r23, 0xFF	; 255
     fee:	8f 4f       	sbci	r24, 0xFF	; 255
     ff0:	9f 4f       	sbci	r25, 0xFF	; 255
     ff2:	16 c0       	rjmp	.+44     	; 0x1020 <__floatsisf+0x6c>
     ff4:	88 23       	and	r24, r24
     ff6:	11 f0       	breq	.+4      	; 0xffc <__floatsisf+0x48>
     ff8:	96 e9       	ldi	r25, 0x96	; 150
     ffa:	11 c0       	rjmp	.+34     	; 0x101e <__floatsisf+0x6a>
     ffc:	77 23       	and	r23, r23
     ffe:	21 f0       	breq	.+8      	; 0x1008 <__floatsisf+0x54>
    1000:	9e e8       	ldi	r25, 0x8E	; 142
    1002:	87 2f       	mov	r24, r23
    1004:	76 2f       	mov	r23, r22
    1006:	05 c0       	rjmp	.+10     	; 0x1012 <__floatsisf+0x5e>
    1008:	66 23       	and	r22, r22
    100a:	71 f0       	breq	.+28     	; 0x1028 <__floatsisf+0x74>
    100c:	96 e8       	ldi	r25, 0x86	; 134
    100e:	86 2f       	mov	r24, r22
    1010:	70 e0       	ldi	r23, 0x00	; 0
    1012:	60 e0       	ldi	r22, 0x00	; 0
    1014:	2a f0       	brmi	.+10     	; 0x1020 <__floatsisf+0x6c>
    1016:	9a 95       	dec	r25
    1018:	66 0f       	add	r22, r22
    101a:	77 1f       	adc	r23, r23
    101c:	88 1f       	adc	r24, r24
    101e:	da f7       	brpl	.-10     	; 0x1016 <__floatsisf+0x62>
    1020:	88 0f       	add	r24, r24
    1022:	96 95       	lsr	r25
    1024:	87 95       	ror	r24
    1026:	97 f9       	bld	r25, 7
    1028:	08 95       	ret

0000102a <__fp_cmp>:
    102a:	99 0f       	add	r25, r25
    102c:	00 08       	sbc	r0, r0
    102e:	55 0f       	add	r21, r21
    1030:	aa 0b       	sbc	r26, r26
    1032:	e0 e8       	ldi	r30, 0x80	; 128
    1034:	fe ef       	ldi	r31, 0xFE	; 254
    1036:	16 16       	cp	r1, r22
    1038:	17 06       	cpc	r1, r23
    103a:	e8 07       	cpc	r30, r24
    103c:	f9 07       	cpc	r31, r25
    103e:	c0 f0       	brcs	.+48     	; 0x1070 <__fp_cmp+0x46>
    1040:	12 16       	cp	r1, r18
    1042:	13 06       	cpc	r1, r19
    1044:	e4 07       	cpc	r30, r20
    1046:	f5 07       	cpc	r31, r21
    1048:	98 f0       	brcs	.+38     	; 0x1070 <__fp_cmp+0x46>
    104a:	62 1b       	sub	r22, r18
    104c:	73 0b       	sbc	r23, r19
    104e:	84 0b       	sbc	r24, r20
    1050:	95 0b       	sbc	r25, r21
    1052:	39 f4       	brne	.+14     	; 0x1062 <__fp_cmp+0x38>
    1054:	0a 26       	eor	r0, r26
    1056:	61 f0       	breq	.+24     	; 0x1070 <__fp_cmp+0x46>
    1058:	23 2b       	or	r18, r19
    105a:	24 2b       	or	r18, r20
    105c:	25 2b       	or	r18, r21
    105e:	21 f4       	brne	.+8      	; 0x1068 <__fp_cmp+0x3e>
    1060:	08 95       	ret
    1062:	0a 26       	eor	r0, r26
    1064:	09 f4       	brne	.+2      	; 0x1068 <__fp_cmp+0x3e>
    1066:	a1 40       	sbci	r26, 0x01	; 1
    1068:	a6 95       	lsr	r26
    106a:	8f ef       	ldi	r24, 0xFF	; 255
    106c:	81 1d       	adc	r24, r1
    106e:	81 1d       	adc	r24, r1
    1070:	08 95       	ret

00001072 <__fp_inf>:
    1072:	97 f9       	bld	r25, 7
    1074:	9f 67       	ori	r25, 0x7F	; 127
    1076:	80 e8       	ldi	r24, 0x80	; 128
    1078:	70 e0       	ldi	r23, 0x00	; 0
    107a:	60 e0       	ldi	r22, 0x00	; 0
    107c:	08 95       	ret

0000107e <__fp_nan>:
    107e:	9f ef       	ldi	r25, 0xFF	; 255
    1080:	80 ec       	ldi	r24, 0xC0	; 192
    1082:	08 95       	ret

00001084 <__fp_pscA>:
    1084:	00 24       	eor	r0, r0
    1086:	0a 94       	dec	r0
    1088:	16 16       	cp	r1, r22
    108a:	17 06       	cpc	r1, r23
    108c:	18 06       	cpc	r1, r24
    108e:	09 06       	cpc	r0, r25
    1090:	08 95       	ret

00001092 <__fp_pscB>:
    1092:	00 24       	eor	r0, r0
    1094:	0a 94       	dec	r0
    1096:	12 16       	cp	r1, r18
    1098:	13 06       	cpc	r1, r19
    109a:	14 06       	cpc	r1, r20
    109c:	05 06       	cpc	r0, r21
    109e:	08 95       	ret

000010a0 <__fp_round>:
    10a0:	09 2e       	mov	r0, r25
    10a2:	03 94       	inc	r0
    10a4:	00 0c       	add	r0, r0
    10a6:	11 f4       	brne	.+4      	; 0x10ac <__fp_round+0xc>
    10a8:	88 23       	and	r24, r24
    10aa:	52 f0       	brmi	.+20     	; 0x10c0 <__fp_round+0x20>
    10ac:	bb 0f       	add	r27, r27
    10ae:	40 f4       	brcc	.+16     	; 0x10c0 <__fp_round+0x20>
    10b0:	bf 2b       	or	r27, r31
    10b2:	11 f4       	brne	.+4      	; 0x10b8 <__fp_round+0x18>
    10b4:	60 ff       	sbrs	r22, 0
    10b6:	04 c0       	rjmp	.+8      	; 0x10c0 <__fp_round+0x20>
    10b8:	6f 5f       	subi	r22, 0xFF	; 255
    10ba:	7f 4f       	sbci	r23, 0xFF	; 255
    10bc:	8f 4f       	sbci	r24, 0xFF	; 255
    10be:	9f 4f       	sbci	r25, 0xFF	; 255
    10c0:	08 95       	ret

000010c2 <__fp_split3>:
    10c2:	57 fd       	sbrc	r21, 7
    10c4:	90 58       	subi	r25, 0x80	; 128
    10c6:	44 0f       	add	r20, r20
    10c8:	55 1f       	adc	r21, r21
    10ca:	59 f0       	breq	.+22     	; 0x10e2 <__fp_splitA+0x10>
    10cc:	5f 3f       	cpi	r21, 0xFF	; 255
    10ce:	71 f0       	breq	.+28     	; 0x10ec <__fp_splitA+0x1a>
    10d0:	47 95       	ror	r20

000010d2 <__fp_splitA>:
    10d2:	88 0f       	add	r24, r24
    10d4:	97 fb       	bst	r25, 7
    10d6:	99 1f       	adc	r25, r25
    10d8:	61 f0       	breq	.+24     	; 0x10f2 <__fp_splitA+0x20>
    10da:	9f 3f       	cpi	r25, 0xFF	; 255
    10dc:	79 f0       	breq	.+30     	; 0x10fc <__fp_splitA+0x2a>
    10de:	87 95       	ror	r24
    10e0:	08 95       	ret
    10e2:	12 16       	cp	r1, r18
    10e4:	13 06       	cpc	r1, r19
    10e6:	14 06       	cpc	r1, r20
    10e8:	55 1f       	adc	r21, r21
    10ea:	f2 cf       	rjmp	.-28     	; 0x10d0 <__fp_split3+0xe>
    10ec:	46 95       	lsr	r20
    10ee:	f1 df       	rcall	.-30     	; 0x10d2 <__fp_splitA>
    10f0:	08 c0       	rjmp	.+16     	; 0x1102 <__fp_splitA+0x30>
    10f2:	16 16       	cp	r1, r22
    10f4:	17 06       	cpc	r1, r23
    10f6:	18 06       	cpc	r1, r24
    10f8:	99 1f       	adc	r25, r25
    10fa:	f1 cf       	rjmp	.-30     	; 0x10de <__fp_splitA+0xc>
    10fc:	86 95       	lsr	r24
    10fe:	71 05       	cpc	r23, r1
    1100:	61 05       	cpc	r22, r1
    1102:	08 94       	sec
    1104:	08 95       	ret

00001106 <__fp_zero>:
    1106:	e8 94       	clt

00001108 <__fp_szero>:
    1108:	bb 27       	eor	r27, r27
    110a:	66 27       	eor	r22, r22
    110c:	77 27       	eor	r23, r23
    110e:	cb 01       	movw	r24, r22
    1110:	97 f9       	bld	r25, 7
    1112:	08 95       	ret

00001114 <__gesf2>:
    1114:	0e 94 15 08 	call	0x102a	; 0x102a <__fp_cmp>
    1118:	08 f4       	brcc	.+2      	; 0x111c <__gesf2+0x8>
    111a:	8f ef       	ldi	r24, 0xFF	; 255
    111c:	08 95       	ret

0000111e <__mulsf3>:
    111e:	0e 94 a2 08 	call	0x1144	; 0x1144 <__mulsf3x>
    1122:	0c 94 50 08 	jmp	0x10a0	; 0x10a0 <__fp_round>
    1126:	0e 94 42 08 	call	0x1084	; 0x1084 <__fp_pscA>
    112a:	38 f0       	brcs	.+14     	; 0x113a <__mulsf3+0x1c>
    112c:	0e 94 49 08 	call	0x1092	; 0x1092 <__fp_pscB>
    1130:	20 f0       	brcs	.+8      	; 0x113a <__mulsf3+0x1c>
    1132:	95 23       	and	r25, r21
    1134:	11 f0       	breq	.+4      	; 0x113a <__mulsf3+0x1c>
    1136:	0c 94 39 08 	jmp	0x1072	; 0x1072 <__fp_inf>
    113a:	0c 94 3f 08 	jmp	0x107e	; 0x107e <__fp_nan>
    113e:	11 24       	eor	r1, r1
    1140:	0c 94 84 08 	jmp	0x1108	; 0x1108 <__fp_szero>

00001144 <__mulsf3x>:
    1144:	0e 94 61 08 	call	0x10c2	; 0x10c2 <__fp_split3>
    1148:	70 f3       	brcs	.-36     	; 0x1126 <__mulsf3+0x8>

0000114a <__mulsf3_pse>:
    114a:	95 9f       	mul	r25, r21
    114c:	c1 f3       	breq	.-16     	; 0x113e <__mulsf3+0x20>
    114e:	95 0f       	add	r25, r21
    1150:	50 e0       	ldi	r21, 0x00	; 0
    1152:	55 1f       	adc	r21, r21
    1154:	62 9f       	mul	r22, r18
    1156:	f0 01       	movw	r30, r0
    1158:	72 9f       	mul	r23, r18
    115a:	bb 27       	eor	r27, r27
    115c:	f0 0d       	add	r31, r0
    115e:	b1 1d       	adc	r27, r1
    1160:	63 9f       	mul	r22, r19
    1162:	aa 27       	eor	r26, r26
    1164:	f0 0d       	add	r31, r0
    1166:	b1 1d       	adc	r27, r1
    1168:	aa 1f       	adc	r26, r26
    116a:	64 9f       	mul	r22, r20
    116c:	66 27       	eor	r22, r22
    116e:	b0 0d       	add	r27, r0
    1170:	a1 1d       	adc	r26, r1
    1172:	66 1f       	adc	r22, r22
    1174:	82 9f       	mul	r24, r18
    1176:	22 27       	eor	r18, r18
    1178:	b0 0d       	add	r27, r0
    117a:	a1 1d       	adc	r26, r1
    117c:	62 1f       	adc	r22, r18
    117e:	73 9f       	mul	r23, r19
    1180:	b0 0d       	add	r27, r0
    1182:	a1 1d       	adc	r26, r1
    1184:	62 1f       	adc	r22, r18
    1186:	83 9f       	mul	r24, r19
    1188:	a0 0d       	add	r26, r0
    118a:	61 1d       	adc	r22, r1
    118c:	22 1f       	adc	r18, r18
    118e:	74 9f       	mul	r23, r20
    1190:	33 27       	eor	r19, r19
    1192:	a0 0d       	add	r26, r0
    1194:	61 1d       	adc	r22, r1
    1196:	23 1f       	adc	r18, r19
    1198:	84 9f       	mul	r24, r20
    119a:	60 0d       	add	r22, r0
    119c:	21 1d       	adc	r18, r1
    119e:	82 2f       	mov	r24, r18
    11a0:	76 2f       	mov	r23, r22
    11a2:	6a 2f       	mov	r22, r26
    11a4:	11 24       	eor	r1, r1
    11a6:	9f 57       	subi	r25, 0x7F	; 127
    11a8:	50 40       	sbci	r21, 0x00	; 0
    11aa:	9a f0       	brmi	.+38     	; 0x11d2 <__mulsf3_pse+0x88>
    11ac:	f1 f0       	breq	.+60     	; 0x11ea <__mulsf3_pse+0xa0>
    11ae:	88 23       	and	r24, r24
    11b0:	4a f0       	brmi	.+18     	; 0x11c4 <__mulsf3_pse+0x7a>
    11b2:	ee 0f       	add	r30, r30
    11b4:	ff 1f       	adc	r31, r31
    11b6:	bb 1f       	adc	r27, r27
    11b8:	66 1f       	adc	r22, r22
    11ba:	77 1f       	adc	r23, r23
    11bc:	88 1f       	adc	r24, r24
    11be:	91 50       	subi	r25, 0x01	; 1
    11c0:	50 40       	sbci	r21, 0x00	; 0
    11c2:	a9 f7       	brne	.-22     	; 0x11ae <__mulsf3_pse+0x64>
    11c4:	9e 3f       	cpi	r25, 0xFE	; 254
    11c6:	51 05       	cpc	r21, r1
    11c8:	80 f0       	brcs	.+32     	; 0x11ea <__mulsf3_pse+0xa0>
    11ca:	0c 94 39 08 	jmp	0x1072	; 0x1072 <__fp_inf>
    11ce:	0c 94 84 08 	jmp	0x1108	; 0x1108 <__fp_szero>
    11d2:	5f 3f       	cpi	r21, 0xFF	; 255
    11d4:	e4 f3       	brlt	.-8      	; 0x11ce <__mulsf3_pse+0x84>
    11d6:	98 3e       	cpi	r25, 0xE8	; 232
    11d8:	d4 f3       	brlt	.-12     	; 0x11ce <__mulsf3_pse+0x84>
    11da:	86 95       	lsr	r24
    11dc:	77 95       	ror	r23
    11de:	67 95       	ror	r22
    11e0:	b7 95       	ror	r27
    11e2:	f7 95       	ror	r31
    11e4:	e7 95       	ror	r30
    11e6:	9f 5f       	subi	r25, 0xFF	; 255
    11e8:	c1 f7       	brne	.-16     	; 0x11da <__mulsf3_pse+0x90>
    11ea:	fe 2b       	or	r31, r30
    11ec:	88 0f       	add	r24, r24
    11ee:	91 1d       	adc	r25, r1
    11f0:	96 95       	lsr	r25
    11f2:	87 95       	ror	r24
    11f4:	97 f9       	bld	r25, 7
    11f6:	08 95       	ret

000011f8 <round>:
    11f8:	0e 94 69 08 	call	0x10d2	; 0x10d2 <__fp_splitA>
    11fc:	e8 f0       	brcs	.+58     	; 0x1238 <round+0x40>
    11fe:	9e 37       	cpi	r25, 0x7E	; 126
    1200:	e8 f0       	brcs	.+58     	; 0x123c <round+0x44>
    1202:	96 39       	cpi	r25, 0x96	; 150
    1204:	b8 f4       	brcc	.+46     	; 0x1234 <round+0x3c>
    1206:	9e 38       	cpi	r25, 0x8E	; 142
    1208:	48 f4       	brcc	.+18     	; 0x121c <round+0x24>
    120a:	67 2f       	mov	r22, r23
    120c:	78 2f       	mov	r23, r24
    120e:	88 27       	eor	r24, r24
    1210:	98 5f       	subi	r25, 0xF8	; 248
    1212:	f9 cf       	rjmp	.-14     	; 0x1206 <round+0xe>
    1214:	86 95       	lsr	r24
    1216:	77 95       	ror	r23
    1218:	67 95       	ror	r22
    121a:	93 95       	inc	r25
    121c:	95 39       	cpi	r25, 0x95	; 149
    121e:	d0 f3       	brcs	.-12     	; 0x1214 <round+0x1c>
    1220:	b6 2f       	mov	r27, r22
    1222:	b1 70       	andi	r27, 0x01	; 1
    1224:	6b 0f       	add	r22, r27
    1226:	71 1d       	adc	r23, r1
    1228:	81 1d       	adc	r24, r1
    122a:	20 f4       	brcc	.+8      	; 0x1234 <round+0x3c>
    122c:	87 95       	ror	r24
    122e:	77 95       	ror	r23
    1230:	67 95       	ror	r22
    1232:	93 95       	inc	r25
    1234:	0c 94 20 09 	jmp	0x1240	; 0x1240 <__fp_mintl>
    1238:	0c 94 3b 09 	jmp	0x1276	; 0x1276 <__fp_mpack>
    123c:	0c 94 84 08 	jmp	0x1108	; 0x1108 <__fp_szero>

00001240 <__fp_mintl>:
    1240:	88 23       	and	r24, r24
    1242:	71 f4       	brne	.+28     	; 0x1260 <__fp_mintl+0x20>
    1244:	77 23       	and	r23, r23
    1246:	21 f0       	breq	.+8      	; 0x1250 <__fp_mintl+0x10>
    1248:	98 50       	subi	r25, 0x08	; 8
    124a:	87 2b       	or	r24, r23
    124c:	76 2f       	mov	r23, r22
    124e:	07 c0       	rjmp	.+14     	; 0x125e <__fp_mintl+0x1e>
    1250:	66 23       	and	r22, r22
    1252:	11 f4       	brne	.+4      	; 0x1258 <__fp_mintl+0x18>
    1254:	99 27       	eor	r25, r25
    1256:	0d c0       	rjmp	.+26     	; 0x1272 <__fp_mintl+0x32>
    1258:	90 51       	subi	r25, 0x10	; 16
    125a:	86 2b       	or	r24, r22
    125c:	70 e0       	ldi	r23, 0x00	; 0
    125e:	60 e0       	ldi	r22, 0x00	; 0
    1260:	2a f0       	brmi	.+10     	; 0x126c <__fp_mintl+0x2c>
    1262:	9a 95       	dec	r25
    1264:	66 0f       	add	r22, r22
    1266:	77 1f       	adc	r23, r23
    1268:	88 1f       	adc	r24, r24
    126a:	da f7       	brpl	.-10     	; 0x1262 <__fp_mintl+0x22>
    126c:	88 0f       	add	r24, r24
    126e:	96 95       	lsr	r25
    1270:	87 95       	ror	r24
    1272:	97 f9       	bld	r25, 7
    1274:	08 95       	ret

00001276 <__fp_mpack>:
    1276:	9f 3f       	cpi	r25, 0xFF	; 255
    1278:	31 f0       	breq	.+12     	; 0x1286 <__fp_mpack_finite+0xc>

0000127a <__fp_mpack_finite>:
    127a:	91 50       	subi	r25, 0x01	; 1
    127c:	20 f4       	brcc	.+8      	; 0x1286 <__fp_mpack_finite+0xc>
    127e:	87 95       	ror	r24
    1280:	77 95       	ror	r23
    1282:	67 95       	ror	r22
    1284:	b7 95       	ror	r27
    1286:	88 0f       	add	r24, r24
    1288:	91 1d       	adc	r25, r1
    128a:	96 95       	lsr	r25
    128c:	87 95       	ror	r24
    128e:	97 f9       	bld	r25, 7
    1290:	08 95       	ret

00001292 <dtostrf>:
    1292:	ef 92       	push	r14
    1294:	0f 93       	push	r16
    1296:	1f 93       	push	r17
    1298:	cf 93       	push	r28
    129a:	df 93       	push	r29
    129c:	e8 01       	movw	r28, r16
    129e:	47 fd       	sbrc	r20, 7
    12a0:	02 c0       	rjmp	.+4      	; 0x12a6 <dtostrf+0x14>
    12a2:	34 e0       	ldi	r19, 0x04	; 4
    12a4:	01 c0       	rjmp	.+2      	; 0x12a8 <dtostrf+0x16>
    12a6:	34 e1       	ldi	r19, 0x14	; 20
    12a8:	04 2e       	mov	r0, r20
    12aa:	00 0c       	add	r0, r0
    12ac:	55 0b       	sbc	r21, r21
    12ae:	57 ff       	sbrs	r21, 7
    12b0:	03 c0       	rjmp	.+6      	; 0x12b8 <dtostrf+0x26>
    12b2:	51 95       	neg	r21
    12b4:	41 95       	neg	r20
    12b6:	51 09       	sbc	r21, r1
    12b8:	e3 2e       	mov	r14, r19
    12ba:	02 2f       	mov	r16, r18
    12bc:	24 2f       	mov	r18, r20
    12be:	ae 01       	movw	r20, r28
    12c0:	3d d3       	rcall	.+1658   	; 0x193c <dtoa_prf>
    12c2:	ce 01       	movw	r24, r28
    12c4:	df 91       	pop	r29
    12c6:	cf 91       	pop	r28
    12c8:	1f 91       	pop	r17
    12ca:	0f 91       	pop	r16
    12cc:	ef 90       	pop	r14
    12ce:	08 95       	ret

000012d0 <malloc>:
    12d0:	0f 93       	push	r16
    12d2:	1f 93       	push	r17
    12d4:	cf 93       	push	r28
    12d6:	df 93       	push	r29
    12d8:	82 30       	cpi	r24, 0x02	; 2
    12da:	91 05       	cpc	r25, r1
    12dc:	10 f4       	brcc	.+4      	; 0x12e2 <malloc+0x12>
    12de:	82 e0       	ldi	r24, 0x02	; 2
    12e0:	90 e0       	ldi	r25, 0x00	; 0
    12e2:	e0 91 69 3e 	lds	r30, 0x3E69	; 0x803e69 <__flp>
    12e6:	f0 91 6a 3e 	lds	r31, 0x3E6A	; 0x803e6a <__flp+0x1>
    12ea:	20 e0       	ldi	r18, 0x00	; 0
    12ec:	30 e0       	ldi	r19, 0x00	; 0
    12ee:	a0 e0       	ldi	r26, 0x00	; 0
    12f0:	b0 e0       	ldi	r27, 0x00	; 0
    12f2:	30 97       	sbiw	r30, 0x00	; 0
    12f4:	19 f1       	breq	.+70     	; 0x133c <malloc+0x6c>
    12f6:	40 81       	ld	r20, Z
    12f8:	51 81       	ldd	r21, Z+1	; 0x01
    12fa:	02 81       	ldd	r16, Z+2	; 0x02
    12fc:	13 81       	ldd	r17, Z+3	; 0x03
    12fe:	48 17       	cp	r20, r24
    1300:	59 07       	cpc	r21, r25
    1302:	c8 f0       	brcs	.+50     	; 0x1336 <malloc+0x66>
    1304:	84 17       	cp	r24, r20
    1306:	95 07       	cpc	r25, r21
    1308:	69 f4       	brne	.+26     	; 0x1324 <malloc+0x54>
    130a:	10 97       	sbiw	r26, 0x00	; 0
    130c:	31 f0       	breq	.+12     	; 0x131a <malloc+0x4a>
    130e:	12 96       	adiw	r26, 0x02	; 2
    1310:	0c 93       	st	X, r16
    1312:	12 97       	sbiw	r26, 0x02	; 2
    1314:	13 96       	adiw	r26, 0x03	; 3
    1316:	1c 93       	st	X, r17
    1318:	27 c0       	rjmp	.+78     	; 0x1368 <malloc+0x98>
    131a:	00 93 69 3e 	sts	0x3E69, r16	; 0x803e69 <__flp>
    131e:	10 93 6a 3e 	sts	0x3E6A, r17	; 0x803e6a <__flp+0x1>
    1322:	22 c0       	rjmp	.+68     	; 0x1368 <malloc+0x98>
    1324:	21 15       	cp	r18, r1
    1326:	31 05       	cpc	r19, r1
    1328:	19 f0       	breq	.+6      	; 0x1330 <malloc+0x60>
    132a:	42 17       	cp	r20, r18
    132c:	53 07       	cpc	r21, r19
    132e:	18 f4       	brcc	.+6      	; 0x1336 <malloc+0x66>
    1330:	9a 01       	movw	r18, r20
    1332:	bd 01       	movw	r22, r26
    1334:	ef 01       	movw	r28, r30
    1336:	df 01       	movw	r26, r30
    1338:	f8 01       	movw	r30, r16
    133a:	db cf       	rjmp	.-74     	; 0x12f2 <malloc+0x22>
    133c:	21 15       	cp	r18, r1
    133e:	31 05       	cpc	r19, r1
    1340:	f9 f0       	breq	.+62     	; 0x1380 <malloc+0xb0>
    1342:	28 1b       	sub	r18, r24
    1344:	39 0b       	sbc	r19, r25
    1346:	24 30       	cpi	r18, 0x04	; 4
    1348:	31 05       	cpc	r19, r1
    134a:	80 f4       	brcc	.+32     	; 0x136c <malloc+0x9c>
    134c:	8a 81       	ldd	r24, Y+2	; 0x02
    134e:	9b 81       	ldd	r25, Y+3	; 0x03
    1350:	61 15       	cp	r22, r1
    1352:	71 05       	cpc	r23, r1
    1354:	21 f0       	breq	.+8      	; 0x135e <malloc+0x8e>
    1356:	fb 01       	movw	r30, r22
    1358:	82 83       	std	Z+2, r24	; 0x02
    135a:	93 83       	std	Z+3, r25	; 0x03
    135c:	04 c0       	rjmp	.+8      	; 0x1366 <malloc+0x96>
    135e:	80 93 69 3e 	sts	0x3E69, r24	; 0x803e69 <__flp>
    1362:	90 93 6a 3e 	sts	0x3E6A, r25	; 0x803e6a <__flp+0x1>
    1366:	fe 01       	movw	r30, r28
    1368:	32 96       	adiw	r30, 0x02	; 2
    136a:	44 c0       	rjmp	.+136    	; 0x13f4 <malloc+0x124>
    136c:	fe 01       	movw	r30, r28
    136e:	e2 0f       	add	r30, r18
    1370:	f3 1f       	adc	r31, r19
    1372:	81 93       	st	Z+, r24
    1374:	91 93       	st	Z+, r25
    1376:	22 50       	subi	r18, 0x02	; 2
    1378:	31 09       	sbc	r19, r1
    137a:	28 83       	st	Y, r18
    137c:	39 83       	std	Y+1, r19	; 0x01
    137e:	3a c0       	rjmp	.+116    	; 0x13f4 <malloc+0x124>
    1380:	20 91 67 3e 	lds	r18, 0x3E67	; 0x803e67 <__brkval>
    1384:	30 91 68 3e 	lds	r19, 0x3E68	; 0x803e68 <__brkval+0x1>
    1388:	23 2b       	or	r18, r19
    138a:	41 f4       	brne	.+16     	; 0x139c <malloc+0xcc>
    138c:	20 91 02 3e 	lds	r18, 0x3E02	; 0x803e02 <__malloc_heap_start>
    1390:	30 91 03 3e 	lds	r19, 0x3E03	; 0x803e03 <__malloc_heap_start+0x1>
    1394:	20 93 67 3e 	sts	0x3E67, r18	; 0x803e67 <__brkval>
    1398:	30 93 68 3e 	sts	0x3E68, r19	; 0x803e68 <__brkval+0x1>
    139c:	20 91 00 3e 	lds	r18, 0x3E00	; 0x803e00 <__data_start>
    13a0:	30 91 01 3e 	lds	r19, 0x3E01	; 0x803e01 <__data_start+0x1>
    13a4:	21 15       	cp	r18, r1
    13a6:	31 05       	cpc	r19, r1
    13a8:	41 f4       	brne	.+16     	; 0x13ba <malloc+0xea>
    13aa:	2d b7       	in	r18, 0x3d	; 61
    13ac:	3e b7       	in	r19, 0x3e	; 62
    13ae:	40 91 04 3e 	lds	r20, 0x3E04	; 0x803e04 <__malloc_margin>
    13b2:	50 91 05 3e 	lds	r21, 0x3E05	; 0x803e05 <__malloc_margin+0x1>
    13b6:	24 1b       	sub	r18, r20
    13b8:	35 0b       	sbc	r19, r21
    13ba:	e0 91 67 3e 	lds	r30, 0x3E67	; 0x803e67 <__brkval>
    13be:	f0 91 68 3e 	lds	r31, 0x3E68	; 0x803e68 <__brkval+0x1>
    13c2:	e2 17       	cp	r30, r18
    13c4:	f3 07       	cpc	r31, r19
    13c6:	a0 f4       	brcc	.+40     	; 0x13f0 <malloc+0x120>
    13c8:	2e 1b       	sub	r18, r30
    13ca:	3f 0b       	sbc	r19, r31
    13cc:	28 17       	cp	r18, r24
    13ce:	39 07       	cpc	r19, r25
    13d0:	78 f0       	brcs	.+30     	; 0x13f0 <malloc+0x120>
    13d2:	ac 01       	movw	r20, r24
    13d4:	4e 5f       	subi	r20, 0xFE	; 254
    13d6:	5f 4f       	sbci	r21, 0xFF	; 255
    13d8:	24 17       	cp	r18, r20
    13da:	35 07       	cpc	r19, r21
    13dc:	48 f0       	brcs	.+18     	; 0x13f0 <malloc+0x120>
    13de:	4e 0f       	add	r20, r30
    13e0:	5f 1f       	adc	r21, r31
    13e2:	40 93 67 3e 	sts	0x3E67, r20	; 0x803e67 <__brkval>
    13e6:	50 93 68 3e 	sts	0x3E68, r21	; 0x803e68 <__brkval+0x1>
    13ea:	81 93       	st	Z+, r24
    13ec:	91 93       	st	Z+, r25
    13ee:	02 c0       	rjmp	.+4      	; 0x13f4 <malloc+0x124>
    13f0:	e0 e0       	ldi	r30, 0x00	; 0
    13f2:	f0 e0       	ldi	r31, 0x00	; 0
    13f4:	cf 01       	movw	r24, r30
    13f6:	df 91       	pop	r29
    13f8:	cf 91       	pop	r28
    13fa:	1f 91       	pop	r17
    13fc:	0f 91       	pop	r16
    13fe:	08 95       	ret

00001400 <free>:
    1400:	cf 93       	push	r28
    1402:	df 93       	push	r29
    1404:	00 97       	sbiw	r24, 0x00	; 0
    1406:	09 f4       	brne	.+2      	; 0x140a <free+0xa>
    1408:	81 c0       	rjmp	.+258    	; 0x150c <free+0x10c>
    140a:	fc 01       	movw	r30, r24
    140c:	32 97       	sbiw	r30, 0x02	; 2
    140e:	12 82       	std	Z+2, r1	; 0x02
    1410:	13 82       	std	Z+3, r1	; 0x03
    1412:	a0 91 69 3e 	lds	r26, 0x3E69	; 0x803e69 <__flp>
    1416:	b0 91 6a 3e 	lds	r27, 0x3E6A	; 0x803e6a <__flp+0x1>
    141a:	10 97       	sbiw	r26, 0x00	; 0
    141c:	81 f4       	brne	.+32     	; 0x143e <free+0x3e>
    141e:	20 81       	ld	r18, Z
    1420:	31 81       	ldd	r19, Z+1	; 0x01
    1422:	82 0f       	add	r24, r18
    1424:	93 1f       	adc	r25, r19
    1426:	20 91 67 3e 	lds	r18, 0x3E67	; 0x803e67 <__brkval>
    142a:	30 91 68 3e 	lds	r19, 0x3E68	; 0x803e68 <__brkval+0x1>
    142e:	28 17       	cp	r18, r24
    1430:	39 07       	cpc	r19, r25
    1432:	51 f5       	brne	.+84     	; 0x1488 <free+0x88>
    1434:	e0 93 67 3e 	sts	0x3E67, r30	; 0x803e67 <__brkval>
    1438:	f0 93 68 3e 	sts	0x3E68, r31	; 0x803e68 <__brkval+0x1>
    143c:	67 c0       	rjmp	.+206    	; 0x150c <free+0x10c>
    143e:	ed 01       	movw	r28, r26
    1440:	20 e0       	ldi	r18, 0x00	; 0
    1442:	30 e0       	ldi	r19, 0x00	; 0
    1444:	ce 17       	cp	r28, r30
    1446:	df 07       	cpc	r29, r31
    1448:	40 f4       	brcc	.+16     	; 0x145a <free+0x5a>
    144a:	4a 81       	ldd	r20, Y+2	; 0x02
    144c:	5b 81       	ldd	r21, Y+3	; 0x03
    144e:	9e 01       	movw	r18, r28
    1450:	41 15       	cp	r20, r1
    1452:	51 05       	cpc	r21, r1
    1454:	f1 f0       	breq	.+60     	; 0x1492 <free+0x92>
    1456:	ea 01       	movw	r28, r20
    1458:	f5 cf       	rjmp	.-22     	; 0x1444 <free+0x44>
    145a:	c2 83       	std	Z+2, r28	; 0x02
    145c:	d3 83       	std	Z+3, r29	; 0x03
    145e:	40 81       	ld	r20, Z
    1460:	51 81       	ldd	r21, Z+1	; 0x01
    1462:	84 0f       	add	r24, r20
    1464:	95 1f       	adc	r25, r21
    1466:	c8 17       	cp	r28, r24
    1468:	d9 07       	cpc	r29, r25
    146a:	59 f4       	brne	.+22     	; 0x1482 <free+0x82>
    146c:	88 81       	ld	r24, Y
    146e:	99 81       	ldd	r25, Y+1	; 0x01
    1470:	84 0f       	add	r24, r20
    1472:	95 1f       	adc	r25, r21
    1474:	02 96       	adiw	r24, 0x02	; 2
    1476:	80 83       	st	Z, r24
    1478:	91 83       	std	Z+1, r25	; 0x01
    147a:	8a 81       	ldd	r24, Y+2	; 0x02
    147c:	9b 81       	ldd	r25, Y+3	; 0x03
    147e:	82 83       	std	Z+2, r24	; 0x02
    1480:	93 83       	std	Z+3, r25	; 0x03
    1482:	21 15       	cp	r18, r1
    1484:	31 05       	cpc	r19, r1
    1486:	29 f4       	brne	.+10     	; 0x1492 <free+0x92>
    1488:	e0 93 69 3e 	sts	0x3E69, r30	; 0x803e69 <__flp>
    148c:	f0 93 6a 3e 	sts	0x3E6A, r31	; 0x803e6a <__flp+0x1>
    1490:	3d c0       	rjmp	.+122    	; 0x150c <free+0x10c>
    1492:	e9 01       	movw	r28, r18
    1494:	ea 83       	std	Y+2, r30	; 0x02
    1496:	fb 83       	std	Y+3, r31	; 0x03
    1498:	49 91       	ld	r20, Y+
    149a:	59 91       	ld	r21, Y+
    149c:	c4 0f       	add	r28, r20
    149e:	d5 1f       	adc	r29, r21
    14a0:	ec 17       	cp	r30, r28
    14a2:	fd 07       	cpc	r31, r29
    14a4:	61 f4       	brne	.+24     	; 0x14be <free+0xbe>
    14a6:	80 81       	ld	r24, Z
    14a8:	91 81       	ldd	r25, Z+1	; 0x01
    14aa:	84 0f       	add	r24, r20
    14ac:	95 1f       	adc	r25, r21
    14ae:	02 96       	adiw	r24, 0x02	; 2
    14b0:	e9 01       	movw	r28, r18
    14b2:	88 83       	st	Y, r24
    14b4:	99 83       	std	Y+1, r25	; 0x01
    14b6:	82 81       	ldd	r24, Z+2	; 0x02
    14b8:	93 81       	ldd	r25, Z+3	; 0x03
    14ba:	8a 83       	std	Y+2, r24	; 0x02
    14bc:	9b 83       	std	Y+3, r25	; 0x03
    14be:	e0 e0       	ldi	r30, 0x00	; 0
    14c0:	f0 e0       	ldi	r31, 0x00	; 0
    14c2:	12 96       	adiw	r26, 0x02	; 2
    14c4:	8d 91       	ld	r24, X+
    14c6:	9c 91       	ld	r25, X
    14c8:	13 97       	sbiw	r26, 0x03	; 3
    14ca:	00 97       	sbiw	r24, 0x00	; 0
    14cc:	19 f0       	breq	.+6      	; 0x14d4 <free+0xd4>
    14ce:	fd 01       	movw	r30, r26
    14d0:	dc 01       	movw	r26, r24
    14d2:	f7 cf       	rjmp	.-18     	; 0x14c2 <free+0xc2>
    14d4:	8d 91       	ld	r24, X+
    14d6:	9c 91       	ld	r25, X
    14d8:	11 97       	sbiw	r26, 0x01	; 1
    14da:	9d 01       	movw	r18, r26
    14dc:	2e 5f       	subi	r18, 0xFE	; 254
    14de:	3f 4f       	sbci	r19, 0xFF	; 255
    14e0:	82 0f       	add	r24, r18
    14e2:	93 1f       	adc	r25, r19
    14e4:	20 91 67 3e 	lds	r18, 0x3E67	; 0x803e67 <__brkval>
    14e8:	30 91 68 3e 	lds	r19, 0x3E68	; 0x803e68 <__brkval+0x1>
    14ec:	28 17       	cp	r18, r24
    14ee:	39 07       	cpc	r19, r25
    14f0:	69 f4       	brne	.+26     	; 0x150c <free+0x10c>
    14f2:	30 97       	sbiw	r30, 0x00	; 0
    14f4:	29 f4       	brne	.+10     	; 0x1500 <free+0x100>
    14f6:	10 92 69 3e 	sts	0x3E69, r1	; 0x803e69 <__flp>
    14fa:	10 92 6a 3e 	sts	0x3E6A, r1	; 0x803e6a <__flp+0x1>
    14fe:	02 c0       	rjmp	.+4      	; 0x1504 <free+0x104>
    1500:	12 82       	std	Z+2, r1	; 0x02
    1502:	13 82       	std	Z+3, r1	; 0x03
    1504:	a0 93 67 3e 	sts	0x3E67, r26	; 0x803e67 <__brkval>
    1508:	b0 93 68 3e 	sts	0x3E68, r27	; 0x803e68 <__brkval+0x1>
    150c:	df 91       	pop	r29
    150e:	cf 91       	pop	r28
    1510:	08 95       	ret

00001512 <printf>:
    1512:	a0 e0       	ldi	r26, 0x00	; 0
    1514:	b0 e0       	ldi	r27, 0x00	; 0
    1516:	ee e8       	ldi	r30, 0x8E	; 142
    1518:	fa e0       	ldi	r31, 0x0A	; 10
    151a:	ff c4       	rjmp	.+2558   	; 0x1f1a <__prologue_saves__+0x20>
    151c:	ae 01       	movw	r20, r28
    151e:	4b 5f       	subi	r20, 0xFB	; 251
    1520:	5f 4f       	sbci	r21, 0xFF	; 255
    1522:	fa 01       	movw	r30, r20
    1524:	61 91       	ld	r22, Z+
    1526:	71 91       	ld	r23, Z+
    1528:	af 01       	movw	r20, r30
    152a:	80 91 6d 3e 	lds	r24, 0x3E6D	; 0x803e6d <__iob+0x2>
    152e:	90 91 6e 3e 	lds	r25, 0x3E6E	; 0x803e6e <__iob+0x3>
    1532:	32 d0       	rcall	.+100    	; 0x1598 <vfprintf>
    1534:	e2 e0       	ldi	r30, 0x02	; 2
    1536:	0a c5       	rjmp	.+2580   	; 0x1f4c <__epilogue_restores__+0x20>

00001538 <puts>:
    1538:	0f 93       	push	r16
    153a:	1f 93       	push	r17
    153c:	cf 93       	push	r28
    153e:	df 93       	push	r29
    1540:	e0 91 6d 3e 	lds	r30, 0x3E6D	; 0x803e6d <__iob+0x2>
    1544:	f0 91 6e 3e 	lds	r31, 0x3E6E	; 0x803e6e <__iob+0x3>
    1548:	23 81       	ldd	r18, Z+3	; 0x03
    154a:	21 ff       	sbrs	r18, 1
    154c:	1b c0       	rjmp	.+54     	; 0x1584 <puts+0x4c>
    154e:	8c 01       	movw	r16, r24
    1550:	d0 e0       	ldi	r29, 0x00	; 0
    1552:	c0 e0       	ldi	r28, 0x00	; 0
    1554:	f8 01       	movw	r30, r16
    1556:	81 91       	ld	r24, Z+
    1558:	8f 01       	movw	r16, r30
    155a:	60 91 6d 3e 	lds	r22, 0x3E6D	; 0x803e6d <__iob+0x2>
    155e:	70 91 6e 3e 	lds	r23, 0x3E6E	; 0x803e6e <__iob+0x3>
    1562:	db 01       	movw	r26, r22
    1564:	18 96       	adiw	r26, 0x08	; 8
    1566:	ed 91       	ld	r30, X+
    1568:	fc 91       	ld	r31, X
    156a:	19 97       	sbiw	r26, 0x09	; 9
    156c:	88 23       	and	r24, r24
    156e:	31 f0       	breq	.+12     	; 0x157c <puts+0x44>
    1570:	09 95       	icall
    1572:	89 2b       	or	r24, r25
    1574:	79 f3       	breq	.-34     	; 0x1554 <puts+0x1c>
    1576:	df ef       	ldi	r29, 0xFF	; 255
    1578:	cf ef       	ldi	r28, 0xFF	; 255
    157a:	ec cf       	rjmp	.-40     	; 0x1554 <puts+0x1c>
    157c:	8a e0       	ldi	r24, 0x0A	; 10
    157e:	09 95       	icall
    1580:	89 2b       	or	r24, r25
    1582:	19 f0       	breq	.+6      	; 0x158a <puts+0x52>
    1584:	8f ef       	ldi	r24, 0xFF	; 255
    1586:	9f ef       	ldi	r25, 0xFF	; 255
    1588:	02 c0       	rjmp	.+4      	; 0x158e <puts+0x56>
    158a:	8d 2f       	mov	r24, r29
    158c:	9c 2f       	mov	r25, r28
    158e:	df 91       	pop	r29
    1590:	cf 91       	pop	r28
    1592:	1f 91       	pop	r17
    1594:	0f 91       	pop	r16
    1596:	08 95       	ret

00001598 <vfprintf>:
    1598:	ab e0       	ldi	r26, 0x0B	; 11
    159a:	b0 e0       	ldi	r27, 0x00	; 0
    159c:	e1 ed       	ldi	r30, 0xD1	; 209
    159e:	fa e0       	ldi	r31, 0x0A	; 10
    15a0:	ac c4       	rjmp	.+2392   	; 0x1efa <__prologue_saves__>
    15a2:	6c 01       	movw	r12, r24
    15a4:	7b 01       	movw	r14, r22
    15a6:	8a 01       	movw	r16, r20
    15a8:	fc 01       	movw	r30, r24
    15aa:	16 82       	std	Z+6, r1	; 0x06
    15ac:	17 82       	std	Z+7, r1	; 0x07
    15ae:	83 81       	ldd	r24, Z+3	; 0x03
    15b0:	81 ff       	sbrs	r24, 1
    15b2:	bf c1       	rjmp	.+894    	; 0x1932 <vfprintf+0x39a>
    15b4:	ce 01       	movw	r24, r28
    15b6:	01 96       	adiw	r24, 0x01	; 1
    15b8:	3c 01       	movw	r6, r24
    15ba:	f6 01       	movw	r30, r12
    15bc:	93 81       	ldd	r25, Z+3	; 0x03
    15be:	f7 01       	movw	r30, r14
    15c0:	93 fd       	sbrc	r25, 3
    15c2:	85 91       	lpm	r24, Z+
    15c4:	93 ff       	sbrs	r25, 3
    15c6:	81 91       	ld	r24, Z+
    15c8:	7f 01       	movw	r14, r30
    15ca:	88 23       	and	r24, r24
    15cc:	09 f4       	brne	.+2      	; 0x15d0 <vfprintf+0x38>
    15ce:	ad c1       	rjmp	.+858    	; 0x192a <vfprintf+0x392>
    15d0:	85 32       	cpi	r24, 0x25	; 37
    15d2:	39 f4       	brne	.+14     	; 0x15e2 <vfprintf+0x4a>
    15d4:	93 fd       	sbrc	r25, 3
    15d6:	85 91       	lpm	r24, Z+
    15d8:	93 ff       	sbrs	r25, 3
    15da:	81 91       	ld	r24, Z+
    15dc:	7f 01       	movw	r14, r30
    15de:	85 32       	cpi	r24, 0x25	; 37
    15e0:	21 f4       	brne	.+8      	; 0x15ea <vfprintf+0x52>
    15e2:	b6 01       	movw	r22, r12
    15e4:	90 e0       	ldi	r25, 0x00	; 0
    15e6:	ef d3       	rcall	.+2014   	; 0x1dc6 <fputc>
    15e8:	e8 cf       	rjmp	.-48     	; 0x15ba <vfprintf+0x22>
    15ea:	91 2c       	mov	r9, r1
    15ec:	21 2c       	mov	r2, r1
    15ee:	31 2c       	mov	r3, r1
    15f0:	ff e1       	ldi	r31, 0x1F	; 31
    15f2:	f3 15       	cp	r31, r3
    15f4:	d8 f0       	brcs	.+54     	; 0x162c <vfprintf+0x94>
    15f6:	8b 32       	cpi	r24, 0x2B	; 43
    15f8:	79 f0       	breq	.+30     	; 0x1618 <vfprintf+0x80>
    15fa:	38 f4       	brcc	.+14     	; 0x160a <vfprintf+0x72>
    15fc:	80 32       	cpi	r24, 0x20	; 32
    15fe:	79 f0       	breq	.+30     	; 0x161e <vfprintf+0x86>
    1600:	83 32       	cpi	r24, 0x23	; 35
    1602:	a1 f4       	brne	.+40     	; 0x162c <vfprintf+0x94>
    1604:	23 2d       	mov	r18, r3
    1606:	20 61       	ori	r18, 0x10	; 16
    1608:	1d c0       	rjmp	.+58     	; 0x1644 <vfprintf+0xac>
    160a:	8d 32       	cpi	r24, 0x2D	; 45
    160c:	61 f0       	breq	.+24     	; 0x1626 <vfprintf+0x8e>
    160e:	80 33       	cpi	r24, 0x30	; 48
    1610:	69 f4       	brne	.+26     	; 0x162c <vfprintf+0x94>
    1612:	23 2d       	mov	r18, r3
    1614:	21 60       	ori	r18, 0x01	; 1
    1616:	16 c0       	rjmp	.+44     	; 0x1644 <vfprintf+0xac>
    1618:	83 2d       	mov	r24, r3
    161a:	82 60       	ori	r24, 0x02	; 2
    161c:	38 2e       	mov	r3, r24
    161e:	e3 2d       	mov	r30, r3
    1620:	e4 60       	ori	r30, 0x04	; 4
    1622:	3e 2e       	mov	r3, r30
    1624:	2a c0       	rjmp	.+84     	; 0x167a <vfprintf+0xe2>
    1626:	f3 2d       	mov	r31, r3
    1628:	f8 60       	ori	r31, 0x08	; 8
    162a:	1d c0       	rjmp	.+58     	; 0x1666 <vfprintf+0xce>
    162c:	37 fc       	sbrc	r3, 7
    162e:	2d c0       	rjmp	.+90     	; 0x168a <vfprintf+0xf2>
    1630:	20 ed       	ldi	r18, 0xD0	; 208
    1632:	28 0f       	add	r18, r24
    1634:	2a 30       	cpi	r18, 0x0A	; 10
    1636:	40 f0       	brcs	.+16     	; 0x1648 <vfprintf+0xb0>
    1638:	8e 32       	cpi	r24, 0x2E	; 46
    163a:	b9 f4       	brne	.+46     	; 0x166a <vfprintf+0xd2>
    163c:	36 fc       	sbrc	r3, 6
    163e:	75 c1       	rjmp	.+746    	; 0x192a <vfprintf+0x392>
    1640:	23 2d       	mov	r18, r3
    1642:	20 64       	ori	r18, 0x40	; 64
    1644:	32 2e       	mov	r3, r18
    1646:	19 c0       	rjmp	.+50     	; 0x167a <vfprintf+0xe2>
    1648:	36 fe       	sbrs	r3, 6
    164a:	06 c0       	rjmp	.+12     	; 0x1658 <vfprintf+0xc0>
    164c:	8a e0       	ldi	r24, 0x0A	; 10
    164e:	98 9e       	mul	r9, r24
    1650:	20 0d       	add	r18, r0
    1652:	11 24       	eor	r1, r1
    1654:	92 2e       	mov	r9, r18
    1656:	11 c0       	rjmp	.+34     	; 0x167a <vfprintf+0xe2>
    1658:	ea e0       	ldi	r30, 0x0A	; 10
    165a:	2e 9e       	mul	r2, r30
    165c:	20 0d       	add	r18, r0
    165e:	11 24       	eor	r1, r1
    1660:	22 2e       	mov	r2, r18
    1662:	f3 2d       	mov	r31, r3
    1664:	f0 62       	ori	r31, 0x20	; 32
    1666:	3f 2e       	mov	r3, r31
    1668:	08 c0       	rjmp	.+16     	; 0x167a <vfprintf+0xe2>
    166a:	8c 36       	cpi	r24, 0x6C	; 108
    166c:	21 f4       	brne	.+8      	; 0x1676 <vfprintf+0xde>
    166e:	83 2d       	mov	r24, r3
    1670:	80 68       	ori	r24, 0x80	; 128
    1672:	38 2e       	mov	r3, r24
    1674:	02 c0       	rjmp	.+4      	; 0x167a <vfprintf+0xe2>
    1676:	88 36       	cpi	r24, 0x68	; 104
    1678:	41 f4       	brne	.+16     	; 0x168a <vfprintf+0xf2>
    167a:	f7 01       	movw	r30, r14
    167c:	93 fd       	sbrc	r25, 3
    167e:	85 91       	lpm	r24, Z+
    1680:	93 ff       	sbrs	r25, 3
    1682:	81 91       	ld	r24, Z+
    1684:	7f 01       	movw	r14, r30
    1686:	81 11       	cpse	r24, r1
    1688:	b3 cf       	rjmp	.-154    	; 0x15f0 <vfprintf+0x58>
    168a:	98 2f       	mov	r25, r24
    168c:	9f 7d       	andi	r25, 0xDF	; 223
    168e:	95 54       	subi	r25, 0x45	; 69
    1690:	93 30       	cpi	r25, 0x03	; 3
    1692:	28 f4       	brcc	.+10     	; 0x169e <vfprintf+0x106>
    1694:	0c 5f       	subi	r16, 0xFC	; 252
    1696:	1f 4f       	sbci	r17, 0xFF	; 255
    1698:	9f e3       	ldi	r25, 0x3F	; 63
    169a:	99 83       	std	Y+1, r25	; 0x01
    169c:	0d c0       	rjmp	.+26     	; 0x16b8 <vfprintf+0x120>
    169e:	83 36       	cpi	r24, 0x63	; 99
    16a0:	31 f0       	breq	.+12     	; 0x16ae <vfprintf+0x116>
    16a2:	83 37       	cpi	r24, 0x73	; 115
    16a4:	71 f0       	breq	.+28     	; 0x16c2 <vfprintf+0x12a>
    16a6:	83 35       	cpi	r24, 0x53	; 83
    16a8:	09 f0       	breq	.+2      	; 0x16ac <vfprintf+0x114>
    16aa:	55 c0       	rjmp	.+170    	; 0x1756 <vfprintf+0x1be>
    16ac:	20 c0       	rjmp	.+64     	; 0x16ee <vfprintf+0x156>
    16ae:	f8 01       	movw	r30, r16
    16b0:	80 81       	ld	r24, Z
    16b2:	89 83       	std	Y+1, r24	; 0x01
    16b4:	0e 5f       	subi	r16, 0xFE	; 254
    16b6:	1f 4f       	sbci	r17, 0xFF	; 255
    16b8:	88 24       	eor	r8, r8
    16ba:	83 94       	inc	r8
    16bc:	91 2c       	mov	r9, r1
    16be:	53 01       	movw	r10, r6
    16c0:	12 c0       	rjmp	.+36     	; 0x16e6 <vfprintf+0x14e>
    16c2:	28 01       	movw	r4, r16
    16c4:	f2 e0       	ldi	r31, 0x02	; 2
    16c6:	4f 0e       	add	r4, r31
    16c8:	51 1c       	adc	r5, r1
    16ca:	f8 01       	movw	r30, r16
    16cc:	a0 80       	ld	r10, Z
    16ce:	b1 80       	ldd	r11, Z+1	; 0x01
    16d0:	36 fe       	sbrs	r3, 6
    16d2:	03 c0       	rjmp	.+6      	; 0x16da <vfprintf+0x142>
    16d4:	69 2d       	mov	r22, r9
    16d6:	70 e0       	ldi	r23, 0x00	; 0
    16d8:	02 c0       	rjmp	.+4      	; 0x16de <vfprintf+0x146>
    16da:	6f ef       	ldi	r22, 0xFF	; 255
    16dc:	7f ef       	ldi	r23, 0xFF	; 255
    16de:	c5 01       	movw	r24, r10
    16e0:	67 d3       	rcall	.+1742   	; 0x1db0 <strnlen>
    16e2:	4c 01       	movw	r8, r24
    16e4:	82 01       	movw	r16, r4
    16e6:	f3 2d       	mov	r31, r3
    16e8:	ff 77       	andi	r31, 0x7F	; 127
    16ea:	3f 2e       	mov	r3, r31
    16ec:	15 c0       	rjmp	.+42     	; 0x1718 <vfprintf+0x180>
    16ee:	28 01       	movw	r4, r16
    16f0:	22 e0       	ldi	r18, 0x02	; 2
    16f2:	42 0e       	add	r4, r18
    16f4:	51 1c       	adc	r5, r1
    16f6:	f8 01       	movw	r30, r16
    16f8:	a0 80       	ld	r10, Z
    16fa:	b1 80       	ldd	r11, Z+1	; 0x01
    16fc:	36 fe       	sbrs	r3, 6
    16fe:	03 c0       	rjmp	.+6      	; 0x1706 <vfprintf+0x16e>
    1700:	69 2d       	mov	r22, r9
    1702:	70 e0       	ldi	r23, 0x00	; 0
    1704:	02 c0       	rjmp	.+4      	; 0x170a <vfprintf+0x172>
    1706:	6f ef       	ldi	r22, 0xFF	; 255
    1708:	7f ef       	ldi	r23, 0xFF	; 255
    170a:	c5 01       	movw	r24, r10
    170c:	46 d3       	rcall	.+1676   	; 0x1d9a <strnlen_P>
    170e:	4c 01       	movw	r8, r24
    1710:	f3 2d       	mov	r31, r3
    1712:	f0 68       	ori	r31, 0x80	; 128
    1714:	3f 2e       	mov	r3, r31
    1716:	82 01       	movw	r16, r4
    1718:	33 fc       	sbrc	r3, 3
    171a:	19 c0       	rjmp	.+50     	; 0x174e <vfprintf+0x1b6>
    171c:	82 2d       	mov	r24, r2
    171e:	90 e0       	ldi	r25, 0x00	; 0
    1720:	88 16       	cp	r8, r24
    1722:	99 06       	cpc	r9, r25
    1724:	a0 f4       	brcc	.+40     	; 0x174e <vfprintf+0x1b6>
    1726:	b6 01       	movw	r22, r12
    1728:	80 e2       	ldi	r24, 0x20	; 32
    172a:	90 e0       	ldi	r25, 0x00	; 0
    172c:	4c d3       	rcall	.+1688   	; 0x1dc6 <fputc>
    172e:	2a 94       	dec	r2
    1730:	f5 cf       	rjmp	.-22     	; 0x171c <vfprintf+0x184>
    1732:	f5 01       	movw	r30, r10
    1734:	37 fc       	sbrc	r3, 7
    1736:	85 91       	lpm	r24, Z+
    1738:	37 fe       	sbrs	r3, 7
    173a:	81 91       	ld	r24, Z+
    173c:	5f 01       	movw	r10, r30
    173e:	b6 01       	movw	r22, r12
    1740:	90 e0       	ldi	r25, 0x00	; 0
    1742:	41 d3       	rcall	.+1666   	; 0x1dc6 <fputc>
    1744:	21 10       	cpse	r2, r1
    1746:	2a 94       	dec	r2
    1748:	21 e0       	ldi	r18, 0x01	; 1
    174a:	82 1a       	sub	r8, r18
    174c:	91 08       	sbc	r9, r1
    174e:	81 14       	cp	r8, r1
    1750:	91 04       	cpc	r9, r1
    1752:	79 f7       	brne	.-34     	; 0x1732 <vfprintf+0x19a>
    1754:	e1 c0       	rjmp	.+450    	; 0x1918 <vfprintf+0x380>
    1756:	84 36       	cpi	r24, 0x64	; 100
    1758:	11 f0       	breq	.+4      	; 0x175e <vfprintf+0x1c6>
    175a:	89 36       	cpi	r24, 0x69	; 105
    175c:	39 f5       	brne	.+78     	; 0x17ac <vfprintf+0x214>
    175e:	f8 01       	movw	r30, r16
    1760:	37 fe       	sbrs	r3, 7
    1762:	07 c0       	rjmp	.+14     	; 0x1772 <vfprintf+0x1da>
    1764:	60 81       	ld	r22, Z
    1766:	71 81       	ldd	r23, Z+1	; 0x01
    1768:	82 81       	ldd	r24, Z+2	; 0x02
    176a:	93 81       	ldd	r25, Z+3	; 0x03
    176c:	0c 5f       	subi	r16, 0xFC	; 252
    176e:	1f 4f       	sbci	r17, 0xFF	; 255
    1770:	08 c0       	rjmp	.+16     	; 0x1782 <vfprintf+0x1ea>
    1772:	60 81       	ld	r22, Z
    1774:	71 81       	ldd	r23, Z+1	; 0x01
    1776:	07 2e       	mov	r0, r23
    1778:	00 0c       	add	r0, r0
    177a:	88 0b       	sbc	r24, r24
    177c:	99 0b       	sbc	r25, r25
    177e:	0e 5f       	subi	r16, 0xFE	; 254
    1780:	1f 4f       	sbci	r17, 0xFF	; 255
    1782:	f3 2d       	mov	r31, r3
    1784:	ff 76       	andi	r31, 0x6F	; 111
    1786:	3f 2e       	mov	r3, r31
    1788:	97 ff       	sbrs	r25, 7
    178a:	09 c0       	rjmp	.+18     	; 0x179e <vfprintf+0x206>
    178c:	90 95       	com	r25
    178e:	80 95       	com	r24
    1790:	70 95       	com	r23
    1792:	61 95       	neg	r22
    1794:	7f 4f       	sbci	r23, 0xFF	; 255
    1796:	8f 4f       	sbci	r24, 0xFF	; 255
    1798:	9f 4f       	sbci	r25, 0xFF	; 255
    179a:	f0 68       	ori	r31, 0x80	; 128
    179c:	3f 2e       	mov	r3, r31
    179e:	2a e0       	ldi	r18, 0x0A	; 10
    17a0:	30 e0       	ldi	r19, 0x00	; 0
    17a2:	a3 01       	movw	r20, r6
    17a4:	4c d3       	rcall	.+1688   	; 0x1e3e <__ultoa_invert>
    17a6:	88 2e       	mov	r8, r24
    17a8:	86 18       	sub	r8, r6
    17aa:	44 c0       	rjmp	.+136    	; 0x1834 <vfprintf+0x29c>
    17ac:	85 37       	cpi	r24, 0x75	; 117
    17ae:	31 f4       	brne	.+12     	; 0x17bc <vfprintf+0x224>
    17b0:	23 2d       	mov	r18, r3
    17b2:	2f 7e       	andi	r18, 0xEF	; 239
    17b4:	b2 2e       	mov	r11, r18
    17b6:	2a e0       	ldi	r18, 0x0A	; 10
    17b8:	30 e0       	ldi	r19, 0x00	; 0
    17ba:	25 c0       	rjmp	.+74     	; 0x1806 <vfprintf+0x26e>
    17bc:	93 2d       	mov	r25, r3
    17be:	99 7f       	andi	r25, 0xF9	; 249
    17c0:	b9 2e       	mov	r11, r25
    17c2:	8f 36       	cpi	r24, 0x6F	; 111
    17c4:	c1 f0       	breq	.+48     	; 0x17f6 <vfprintf+0x25e>
    17c6:	18 f4       	brcc	.+6      	; 0x17ce <vfprintf+0x236>
    17c8:	88 35       	cpi	r24, 0x58	; 88
    17ca:	79 f0       	breq	.+30     	; 0x17ea <vfprintf+0x252>
    17cc:	ae c0       	rjmp	.+348    	; 0x192a <vfprintf+0x392>
    17ce:	80 37       	cpi	r24, 0x70	; 112
    17d0:	19 f0       	breq	.+6      	; 0x17d8 <vfprintf+0x240>
    17d2:	88 37       	cpi	r24, 0x78	; 120
    17d4:	21 f0       	breq	.+8      	; 0x17de <vfprintf+0x246>
    17d6:	a9 c0       	rjmp	.+338    	; 0x192a <vfprintf+0x392>
    17d8:	e9 2f       	mov	r30, r25
    17da:	e0 61       	ori	r30, 0x10	; 16
    17dc:	be 2e       	mov	r11, r30
    17de:	b4 fe       	sbrs	r11, 4
    17e0:	0d c0       	rjmp	.+26     	; 0x17fc <vfprintf+0x264>
    17e2:	fb 2d       	mov	r31, r11
    17e4:	f4 60       	ori	r31, 0x04	; 4
    17e6:	bf 2e       	mov	r11, r31
    17e8:	09 c0       	rjmp	.+18     	; 0x17fc <vfprintf+0x264>
    17ea:	34 fe       	sbrs	r3, 4
    17ec:	0a c0       	rjmp	.+20     	; 0x1802 <vfprintf+0x26a>
    17ee:	29 2f       	mov	r18, r25
    17f0:	26 60       	ori	r18, 0x06	; 6
    17f2:	b2 2e       	mov	r11, r18
    17f4:	06 c0       	rjmp	.+12     	; 0x1802 <vfprintf+0x26a>
    17f6:	28 e0       	ldi	r18, 0x08	; 8
    17f8:	30 e0       	ldi	r19, 0x00	; 0
    17fa:	05 c0       	rjmp	.+10     	; 0x1806 <vfprintf+0x26e>
    17fc:	20 e1       	ldi	r18, 0x10	; 16
    17fe:	30 e0       	ldi	r19, 0x00	; 0
    1800:	02 c0       	rjmp	.+4      	; 0x1806 <vfprintf+0x26e>
    1802:	20 e1       	ldi	r18, 0x10	; 16
    1804:	32 e0       	ldi	r19, 0x02	; 2
    1806:	f8 01       	movw	r30, r16
    1808:	b7 fe       	sbrs	r11, 7
    180a:	07 c0       	rjmp	.+14     	; 0x181a <vfprintf+0x282>
    180c:	60 81       	ld	r22, Z
    180e:	71 81       	ldd	r23, Z+1	; 0x01
    1810:	82 81       	ldd	r24, Z+2	; 0x02
    1812:	93 81       	ldd	r25, Z+3	; 0x03
    1814:	0c 5f       	subi	r16, 0xFC	; 252
    1816:	1f 4f       	sbci	r17, 0xFF	; 255
    1818:	06 c0       	rjmp	.+12     	; 0x1826 <vfprintf+0x28e>
    181a:	60 81       	ld	r22, Z
    181c:	71 81       	ldd	r23, Z+1	; 0x01
    181e:	80 e0       	ldi	r24, 0x00	; 0
    1820:	90 e0       	ldi	r25, 0x00	; 0
    1822:	0e 5f       	subi	r16, 0xFE	; 254
    1824:	1f 4f       	sbci	r17, 0xFF	; 255
    1826:	a3 01       	movw	r20, r6
    1828:	0a d3       	rcall	.+1556   	; 0x1e3e <__ultoa_invert>
    182a:	88 2e       	mov	r8, r24
    182c:	86 18       	sub	r8, r6
    182e:	fb 2d       	mov	r31, r11
    1830:	ff 77       	andi	r31, 0x7F	; 127
    1832:	3f 2e       	mov	r3, r31
    1834:	36 fe       	sbrs	r3, 6
    1836:	0d c0       	rjmp	.+26     	; 0x1852 <vfprintf+0x2ba>
    1838:	23 2d       	mov	r18, r3
    183a:	2e 7f       	andi	r18, 0xFE	; 254
    183c:	a2 2e       	mov	r10, r18
    183e:	89 14       	cp	r8, r9
    1840:	58 f4       	brcc	.+22     	; 0x1858 <vfprintf+0x2c0>
    1842:	34 fe       	sbrs	r3, 4
    1844:	0b c0       	rjmp	.+22     	; 0x185c <vfprintf+0x2c4>
    1846:	32 fc       	sbrc	r3, 2
    1848:	09 c0       	rjmp	.+18     	; 0x185c <vfprintf+0x2c4>
    184a:	83 2d       	mov	r24, r3
    184c:	8e 7e       	andi	r24, 0xEE	; 238
    184e:	a8 2e       	mov	r10, r24
    1850:	05 c0       	rjmp	.+10     	; 0x185c <vfprintf+0x2c4>
    1852:	b8 2c       	mov	r11, r8
    1854:	a3 2c       	mov	r10, r3
    1856:	03 c0       	rjmp	.+6      	; 0x185e <vfprintf+0x2c6>
    1858:	b8 2c       	mov	r11, r8
    185a:	01 c0       	rjmp	.+2      	; 0x185e <vfprintf+0x2c6>
    185c:	b9 2c       	mov	r11, r9
    185e:	a4 fe       	sbrs	r10, 4
    1860:	0f c0       	rjmp	.+30     	; 0x1880 <vfprintf+0x2e8>
    1862:	fe 01       	movw	r30, r28
    1864:	e8 0d       	add	r30, r8
    1866:	f1 1d       	adc	r31, r1
    1868:	80 81       	ld	r24, Z
    186a:	80 33       	cpi	r24, 0x30	; 48
    186c:	21 f4       	brne	.+8      	; 0x1876 <vfprintf+0x2de>
    186e:	9a 2d       	mov	r25, r10
    1870:	99 7e       	andi	r25, 0xE9	; 233
    1872:	a9 2e       	mov	r10, r25
    1874:	09 c0       	rjmp	.+18     	; 0x1888 <vfprintf+0x2f0>
    1876:	a2 fe       	sbrs	r10, 2
    1878:	06 c0       	rjmp	.+12     	; 0x1886 <vfprintf+0x2ee>
    187a:	b3 94       	inc	r11
    187c:	b3 94       	inc	r11
    187e:	04 c0       	rjmp	.+8      	; 0x1888 <vfprintf+0x2f0>
    1880:	8a 2d       	mov	r24, r10
    1882:	86 78       	andi	r24, 0x86	; 134
    1884:	09 f0       	breq	.+2      	; 0x1888 <vfprintf+0x2f0>
    1886:	b3 94       	inc	r11
    1888:	a3 fc       	sbrc	r10, 3
    188a:	10 c0       	rjmp	.+32     	; 0x18ac <vfprintf+0x314>
    188c:	a0 fe       	sbrs	r10, 0
    188e:	06 c0       	rjmp	.+12     	; 0x189c <vfprintf+0x304>
    1890:	b2 14       	cp	r11, r2
    1892:	80 f4       	brcc	.+32     	; 0x18b4 <vfprintf+0x31c>
    1894:	28 0c       	add	r2, r8
    1896:	92 2c       	mov	r9, r2
    1898:	9b 18       	sub	r9, r11
    189a:	0d c0       	rjmp	.+26     	; 0x18b6 <vfprintf+0x31e>
    189c:	b2 14       	cp	r11, r2
    189e:	58 f4       	brcc	.+22     	; 0x18b6 <vfprintf+0x31e>
    18a0:	b6 01       	movw	r22, r12
    18a2:	80 e2       	ldi	r24, 0x20	; 32
    18a4:	90 e0       	ldi	r25, 0x00	; 0
    18a6:	8f d2       	rcall	.+1310   	; 0x1dc6 <fputc>
    18a8:	b3 94       	inc	r11
    18aa:	f8 cf       	rjmp	.-16     	; 0x189c <vfprintf+0x304>
    18ac:	b2 14       	cp	r11, r2
    18ae:	18 f4       	brcc	.+6      	; 0x18b6 <vfprintf+0x31e>
    18b0:	2b 18       	sub	r2, r11
    18b2:	02 c0       	rjmp	.+4      	; 0x18b8 <vfprintf+0x320>
    18b4:	98 2c       	mov	r9, r8
    18b6:	21 2c       	mov	r2, r1
    18b8:	a4 fe       	sbrs	r10, 4
    18ba:	0f c0       	rjmp	.+30     	; 0x18da <vfprintf+0x342>
    18bc:	b6 01       	movw	r22, r12
    18be:	80 e3       	ldi	r24, 0x30	; 48
    18c0:	90 e0       	ldi	r25, 0x00	; 0
    18c2:	81 d2       	rcall	.+1282   	; 0x1dc6 <fputc>
    18c4:	a2 fe       	sbrs	r10, 2
    18c6:	16 c0       	rjmp	.+44     	; 0x18f4 <vfprintf+0x35c>
    18c8:	a1 fc       	sbrc	r10, 1
    18ca:	03 c0       	rjmp	.+6      	; 0x18d2 <vfprintf+0x33a>
    18cc:	88 e7       	ldi	r24, 0x78	; 120
    18ce:	90 e0       	ldi	r25, 0x00	; 0
    18d0:	02 c0       	rjmp	.+4      	; 0x18d6 <vfprintf+0x33e>
    18d2:	88 e5       	ldi	r24, 0x58	; 88
    18d4:	90 e0       	ldi	r25, 0x00	; 0
    18d6:	b6 01       	movw	r22, r12
    18d8:	0c c0       	rjmp	.+24     	; 0x18f2 <vfprintf+0x35a>
    18da:	8a 2d       	mov	r24, r10
    18dc:	86 78       	andi	r24, 0x86	; 134
    18de:	51 f0       	breq	.+20     	; 0x18f4 <vfprintf+0x35c>
    18e0:	a1 fe       	sbrs	r10, 1
    18e2:	02 c0       	rjmp	.+4      	; 0x18e8 <vfprintf+0x350>
    18e4:	8b e2       	ldi	r24, 0x2B	; 43
    18e6:	01 c0       	rjmp	.+2      	; 0x18ea <vfprintf+0x352>
    18e8:	80 e2       	ldi	r24, 0x20	; 32
    18ea:	a7 fc       	sbrc	r10, 7
    18ec:	8d e2       	ldi	r24, 0x2D	; 45
    18ee:	b6 01       	movw	r22, r12
    18f0:	90 e0       	ldi	r25, 0x00	; 0
    18f2:	69 d2       	rcall	.+1234   	; 0x1dc6 <fputc>
    18f4:	89 14       	cp	r8, r9
    18f6:	30 f4       	brcc	.+12     	; 0x1904 <vfprintf+0x36c>
    18f8:	b6 01       	movw	r22, r12
    18fa:	80 e3       	ldi	r24, 0x30	; 48
    18fc:	90 e0       	ldi	r25, 0x00	; 0
    18fe:	63 d2       	rcall	.+1222   	; 0x1dc6 <fputc>
    1900:	9a 94       	dec	r9
    1902:	f8 cf       	rjmp	.-16     	; 0x18f4 <vfprintf+0x35c>
    1904:	8a 94       	dec	r8
    1906:	f3 01       	movw	r30, r6
    1908:	e8 0d       	add	r30, r8
    190a:	f1 1d       	adc	r31, r1
    190c:	80 81       	ld	r24, Z
    190e:	b6 01       	movw	r22, r12
    1910:	90 e0       	ldi	r25, 0x00	; 0
    1912:	59 d2       	rcall	.+1202   	; 0x1dc6 <fputc>
    1914:	81 10       	cpse	r8, r1
    1916:	f6 cf       	rjmp	.-20     	; 0x1904 <vfprintf+0x36c>
    1918:	22 20       	and	r2, r2
    191a:	09 f4       	brne	.+2      	; 0x191e <vfprintf+0x386>
    191c:	4e ce       	rjmp	.-868    	; 0x15ba <vfprintf+0x22>
    191e:	b6 01       	movw	r22, r12
    1920:	80 e2       	ldi	r24, 0x20	; 32
    1922:	90 e0       	ldi	r25, 0x00	; 0
    1924:	50 d2       	rcall	.+1184   	; 0x1dc6 <fputc>
    1926:	2a 94       	dec	r2
    1928:	f7 cf       	rjmp	.-18     	; 0x1918 <vfprintf+0x380>
    192a:	f6 01       	movw	r30, r12
    192c:	86 81       	ldd	r24, Z+6	; 0x06
    192e:	97 81       	ldd	r25, Z+7	; 0x07
    1930:	02 c0       	rjmp	.+4      	; 0x1936 <vfprintf+0x39e>
    1932:	8f ef       	ldi	r24, 0xFF	; 255
    1934:	9f ef       	ldi	r25, 0xFF	; 255
    1936:	2b 96       	adiw	r28, 0x0b	; 11
    1938:	e2 e1       	ldi	r30, 0x12	; 18
    193a:	f8 c2       	rjmp	.+1520   	; 0x1f2c <__epilogue_restores__>

0000193c <dtoa_prf>:
    193c:	a9 e0       	ldi	r26, 0x09	; 9
    193e:	b0 e0       	ldi	r27, 0x00	; 0
    1940:	e3 ea       	ldi	r30, 0xA3	; 163
    1942:	fc e0       	ldi	r31, 0x0C	; 12
    1944:	e0 c2       	rjmp	.+1472   	; 0x1f06 <__prologue_saves__+0xc>
    1946:	6a 01       	movw	r12, r20
    1948:	12 2f       	mov	r17, r18
    194a:	b0 2e       	mov	r11, r16
    194c:	2b e3       	ldi	r18, 0x3B	; 59
    194e:	20 17       	cp	r18, r16
    1950:	20 f0       	brcs	.+8      	; 0x195a <dtoa_prf+0x1e>
    1952:	ff 24       	eor	r15, r15
    1954:	f3 94       	inc	r15
    1956:	f0 0e       	add	r15, r16
    1958:	02 c0       	rjmp	.+4      	; 0x195e <dtoa_prf+0x22>
    195a:	2c e3       	ldi	r18, 0x3C	; 60
    195c:	f2 2e       	mov	r15, r18
    195e:	0f 2d       	mov	r16, r15
    1960:	27 e0       	ldi	r18, 0x07	; 7
    1962:	ae 01       	movw	r20, r28
    1964:	4f 5f       	subi	r20, 0xFF	; 255
    1966:	5f 4f       	sbci	r21, 0xFF	; 255
    1968:	40 d1       	rcall	.+640    	; 0x1bea <__ftoa_engine>
    196a:	bc 01       	movw	r22, r24
    196c:	49 81       	ldd	r20, Y+1	; 0x01
    196e:	84 2f       	mov	r24, r20
    1970:	89 70       	andi	r24, 0x09	; 9
    1972:	81 30       	cpi	r24, 0x01	; 1
    1974:	31 f0       	breq	.+12     	; 0x1982 <dtoa_prf+0x46>
    1976:	e1 fc       	sbrc	r14, 1
    1978:	06 c0       	rjmp	.+12     	; 0x1986 <dtoa_prf+0x4a>
    197a:	e0 fe       	sbrs	r14, 0
    197c:	06 c0       	rjmp	.+12     	; 0x198a <dtoa_prf+0x4e>
    197e:	90 e2       	ldi	r25, 0x20	; 32
    1980:	05 c0       	rjmp	.+10     	; 0x198c <dtoa_prf+0x50>
    1982:	9d e2       	ldi	r25, 0x2D	; 45
    1984:	03 c0       	rjmp	.+6      	; 0x198c <dtoa_prf+0x50>
    1986:	9b e2       	ldi	r25, 0x2B	; 43
    1988:	01 c0       	rjmp	.+2      	; 0x198c <dtoa_prf+0x50>
    198a:	90 e0       	ldi	r25, 0x00	; 0
    198c:	5e 2d       	mov	r21, r14
    198e:	50 71       	andi	r21, 0x10	; 16
    1990:	43 ff       	sbrs	r20, 3
    1992:	3c c0       	rjmp	.+120    	; 0x1a0c <dtoa_prf+0xd0>
    1994:	91 11       	cpse	r25, r1
    1996:	02 c0       	rjmp	.+4      	; 0x199c <dtoa_prf+0x60>
    1998:	83 e0       	ldi	r24, 0x03	; 3
    199a:	01 c0       	rjmp	.+2      	; 0x199e <dtoa_prf+0x62>
    199c:	84 e0       	ldi	r24, 0x04	; 4
    199e:	81 17       	cp	r24, r17
    19a0:	18 f4       	brcc	.+6      	; 0x19a8 <dtoa_prf+0x6c>
    19a2:	21 2f       	mov	r18, r17
    19a4:	28 1b       	sub	r18, r24
    19a6:	01 c0       	rjmp	.+2      	; 0x19aa <dtoa_prf+0x6e>
    19a8:	20 e0       	ldi	r18, 0x00	; 0
    19aa:	51 11       	cpse	r21, r1
    19ac:	0b c0       	rjmp	.+22     	; 0x19c4 <dtoa_prf+0x88>
    19ae:	f6 01       	movw	r30, r12
    19b0:	82 2f       	mov	r24, r18
    19b2:	30 e2       	ldi	r19, 0x20	; 32
    19b4:	88 23       	and	r24, r24
    19b6:	19 f0       	breq	.+6      	; 0x19be <dtoa_prf+0x82>
    19b8:	31 93       	st	Z+, r19
    19ba:	81 50       	subi	r24, 0x01	; 1
    19bc:	fb cf       	rjmp	.-10     	; 0x19b4 <dtoa_prf+0x78>
    19be:	c2 0e       	add	r12, r18
    19c0:	d1 1c       	adc	r13, r1
    19c2:	20 e0       	ldi	r18, 0x00	; 0
    19c4:	99 23       	and	r25, r25
    19c6:	29 f0       	breq	.+10     	; 0x19d2 <dtoa_prf+0x96>
    19c8:	d6 01       	movw	r26, r12
    19ca:	9c 93       	st	X, r25
    19cc:	f6 01       	movw	r30, r12
    19ce:	31 96       	adiw	r30, 0x01	; 1
    19d0:	6f 01       	movw	r12, r30
    19d2:	c6 01       	movw	r24, r12
    19d4:	03 96       	adiw	r24, 0x03	; 3
    19d6:	e2 fe       	sbrs	r14, 2
    19d8:	0a c0       	rjmp	.+20     	; 0x19ee <dtoa_prf+0xb2>
    19da:	3e e4       	ldi	r19, 0x4E	; 78
    19dc:	d6 01       	movw	r26, r12
    19de:	3c 93       	st	X, r19
    19e0:	41 e4       	ldi	r20, 0x41	; 65
    19e2:	11 96       	adiw	r26, 0x01	; 1
    19e4:	4c 93       	st	X, r20
    19e6:	11 97       	sbiw	r26, 0x01	; 1
    19e8:	12 96       	adiw	r26, 0x02	; 2
    19ea:	3c 93       	st	X, r19
    19ec:	06 c0       	rjmp	.+12     	; 0x19fa <dtoa_prf+0xbe>
    19ee:	3e e6       	ldi	r19, 0x6E	; 110
    19f0:	f6 01       	movw	r30, r12
    19f2:	30 83       	st	Z, r19
    19f4:	41 e6       	ldi	r20, 0x61	; 97
    19f6:	41 83       	std	Z+1, r20	; 0x01
    19f8:	32 83       	std	Z+2, r19	; 0x02
    19fa:	fc 01       	movw	r30, r24
    19fc:	32 2f       	mov	r19, r18
    19fe:	40 e2       	ldi	r20, 0x20	; 32
    1a00:	33 23       	and	r19, r19
    1a02:	09 f4       	brne	.+2      	; 0x1a06 <dtoa_prf+0xca>
    1a04:	42 c0       	rjmp	.+132    	; 0x1a8a <dtoa_prf+0x14e>
    1a06:	41 93       	st	Z+, r20
    1a08:	31 50       	subi	r19, 0x01	; 1
    1a0a:	fa cf       	rjmp	.-12     	; 0x1a00 <dtoa_prf+0xc4>
    1a0c:	42 ff       	sbrs	r20, 2
    1a0e:	44 c0       	rjmp	.+136    	; 0x1a98 <dtoa_prf+0x15c>
    1a10:	91 11       	cpse	r25, r1
    1a12:	02 c0       	rjmp	.+4      	; 0x1a18 <dtoa_prf+0xdc>
    1a14:	83 e0       	ldi	r24, 0x03	; 3
    1a16:	01 c0       	rjmp	.+2      	; 0x1a1a <dtoa_prf+0xde>
    1a18:	84 e0       	ldi	r24, 0x04	; 4
    1a1a:	81 17       	cp	r24, r17
    1a1c:	18 f4       	brcc	.+6      	; 0x1a24 <dtoa_prf+0xe8>
    1a1e:	21 2f       	mov	r18, r17
    1a20:	28 1b       	sub	r18, r24
    1a22:	01 c0       	rjmp	.+2      	; 0x1a26 <dtoa_prf+0xea>
    1a24:	20 e0       	ldi	r18, 0x00	; 0
    1a26:	51 11       	cpse	r21, r1
    1a28:	0b c0       	rjmp	.+22     	; 0x1a40 <dtoa_prf+0x104>
    1a2a:	f6 01       	movw	r30, r12
    1a2c:	82 2f       	mov	r24, r18
    1a2e:	30 e2       	ldi	r19, 0x20	; 32
    1a30:	88 23       	and	r24, r24
    1a32:	19 f0       	breq	.+6      	; 0x1a3a <dtoa_prf+0xfe>
    1a34:	31 93       	st	Z+, r19
    1a36:	81 50       	subi	r24, 0x01	; 1
    1a38:	fb cf       	rjmp	.-10     	; 0x1a30 <dtoa_prf+0xf4>
    1a3a:	c2 0e       	add	r12, r18
    1a3c:	d1 1c       	adc	r13, r1
    1a3e:	20 e0       	ldi	r18, 0x00	; 0
    1a40:	99 23       	and	r25, r25
    1a42:	29 f0       	breq	.+10     	; 0x1a4e <dtoa_prf+0x112>
    1a44:	d6 01       	movw	r26, r12
    1a46:	9c 93       	st	X, r25
    1a48:	f6 01       	movw	r30, r12
    1a4a:	31 96       	adiw	r30, 0x01	; 1
    1a4c:	6f 01       	movw	r12, r30
    1a4e:	c6 01       	movw	r24, r12
    1a50:	03 96       	adiw	r24, 0x03	; 3
    1a52:	e2 fe       	sbrs	r14, 2
    1a54:	0b c0       	rjmp	.+22     	; 0x1a6c <dtoa_prf+0x130>
    1a56:	39 e4       	ldi	r19, 0x49	; 73
    1a58:	d6 01       	movw	r26, r12
    1a5a:	3c 93       	st	X, r19
    1a5c:	3e e4       	ldi	r19, 0x4E	; 78
    1a5e:	11 96       	adiw	r26, 0x01	; 1
    1a60:	3c 93       	st	X, r19
    1a62:	11 97       	sbiw	r26, 0x01	; 1
    1a64:	36 e4       	ldi	r19, 0x46	; 70
    1a66:	12 96       	adiw	r26, 0x02	; 2
    1a68:	3c 93       	st	X, r19
    1a6a:	07 c0       	rjmp	.+14     	; 0x1a7a <dtoa_prf+0x13e>
    1a6c:	39 e6       	ldi	r19, 0x69	; 105
    1a6e:	f6 01       	movw	r30, r12
    1a70:	30 83       	st	Z, r19
    1a72:	3e e6       	ldi	r19, 0x6E	; 110
    1a74:	31 83       	std	Z+1, r19	; 0x01
    1a76:	36 e6       	ldi	r19, 0x66	; 102
    1a78:	32 83       	std	Z+2, r19	; 0x02
    1a7a:	fc 01       	movw	r30, r24
    1a7c:	32 2f       	mov	r19, r18
    1a7e:	40 e2       	ldi	r20, 0x20	; 32
    1a80:	33 23       	and	r19, r19
    1a82:	19 f0       	breq	.+6      	; 0x1a8a <dtoa_prf+0x14e>
    1a84:	41 93       	st	Z+, r20
    1a86:	31 50       	subi	r19, 0x01	; 1
    1a88:	fb cf       	rjmp	.-10     	; 0x1a80 <dtoa_prf+0x144>
    1a8a:	fc 01       	movw	r30, r24
    1a8c:	e2 0f       	add	r30, r18
    1a8e:	f1 1d       	adc	r31, r1
    1a90:	10 82       	st	Z, r1
    1a92:	8e ef       	ldi	r24, 0xFE	; 254
    1a94:	9f ef       	ldi	r25, 0xFF	; 255
    1a96:	a6 c0       	rjmp	.+332    	; 0x1be4 <dtoa_prf+0x2a8>
    1a98:	21 e0       	ldi	r18, 0x01	; 1
    1a9a:	30 e0       	ldi	r19, 0x00	; 0
    1a9c:	91 11       	cpse	r25, r1
    1a9e:	02 c0       	rjmp	.+4      	; 0x1aa4 <dtoa_prf+0x168>
    1aa0:	20 e0       	ldi	r18, 0x00	; 0
    1aa2:	30 e0       	ldi	r19, 0x00	; 0
    1aa4:	16 16       	cp	r1, r22
    1aa6:	17 06       	cpc	r1, r23
    1aa8:	1c f4       	brge	.+6      	; 0x1ab0 <dtoa_prf+0x174>
    1aaa:	fb 01       	movw	r30, r22
    1aac:	31 96       	adiw	r30, 0x01	; 1
    1aae:	02 c0       	rjmp	.+4      	; 0x1ab4 <dtoa_prf+0x178>
    1ab0:	e1 e0       	ldi	r30, 0x01	; 1
    1ab2:	f0 e0       	ldi	r31, 0x00	; 0
    1ab4:	2e 0f       	add	r18, r30
    1ab6:	3f 1f       	adc	r19, r31
    1ab8:	bb 20       	and	r11, r11
    1aba:	21 f0       	breq	.+8      	; 0x1ac4 <dtoa_prf+0x188>
    1abc:	eb 2d       	mov	r30, r11
    1abe:	f0 e0       	ldi	r31, 0x00	; 0
    1ac0:	31 96       	adiw	r30, 0x01	; 1
    1ac2:	02 c0       	rjmp	.+4      	; 0x1ac8 <dtoa_prf+0x18c>
    1ac4:	e0 e0       	ldi	r30, 0x00	; 0
    1ac6:	f0 e0       	ldi	r31, 0x00	; 0
    1ac8:	2e 0f       	add	r18, r30
    1aca:	3f 1f       	adc	r19, r31
    1acc:	e1 2f       	mov	r30, r17
    1ace:	f0 e0       	ldi	r31, 0x00	; 0
    1ad0:	2e 17       	cp	r18, r30
    1ad2:	3f 07       	cpc	r19, r31
    1ad4:	1c f4       	brge	.+6      	; 0x1adc <dtoa_prf+0x1a0>
    1ad6:	12 1b       	sub	r17, r18
    1ad8:	21 2f       	mov	r18, r17
    1ada:	01 c0       	rjmp	.+2      	; 0x1ade <dtoa_prf+0x1a2>
    1adc:	20 e0       	ldi	r18, 0x00	; 0
    1ade:	8e 2d       	mov	r24, r14
    1ae0:	88 71       	andi	r24, 0x18	; 24
    1ae2:	59 f4       	brne	.+22     	; 0x1afa <dtoa_prf+0x1be>
    1ae4:	f6 01       	movw	r30, r12
    1ae6:	82 2f       	mov	r24, r18
    1ae8:	30 e2       	ldi	r19, 0x20	; 32
    1aea:	88 23       	and	r24, r24
    1aec:	19 f0       	breq	.+6      	; 0x1af4 <dtoa_prf+0x1b8>
    1aee:	31 93       	st	Z+, r19
    1af0:	81 50       	subi	r24, 0x01	; 1
    1af2:	fb cf       	rjmp	.-10     	; 0x1aea <dtoa_prf+0x1ae>
    1af4:	c2 0e       	add	r12, r18
    1af6:	d1 1c       	adc	r13, r1
    1af8:	20 e0       	ldi	r18, 0x00	; 0
    1afa:	99 23       	and	r25, r25
    1afc:	29 f0       	breq	.+10     	; 0x1b08 <dtoa_prf+0x1cc>
    1afe:	d6 01       	movw	r26, r12
    1b00:	9c 93       	st	X, r25
    1b02:	f6 01       	movw	r30, r12
    1b04:	31 96       	adiw	r30, 0x01	; 1
    1b06:	6f 01       	movw	r12, r30
    1b08:	51 11       	cpse	r21, r1
    1b0a:	0b c0       	rjmp	.+22     	; 0x1b22 <dtoa_prf+0x1e6>
    1b0c:	f6 01       	movw	r30, r12
    1b0e:	82 2f       	mov	r24, r18
    1b10:	90 e3       	ldi	r25, 0x30	; 48
    1b12:	88 23       	and	r24, r24
    1b14:	19 f0       	breq	.+6      	; 0x1b1c <dtoa_prf+0x1e0>
    1b16:	91 93       	st	Z+, r25
    1b18:	81 50       	subi	r24, 0x01	; 1
    1b1a:	fb cf       	rjmp	.-10     	; 0x1b12 <dtoa_prf+0x1d6>
    1b1c:	c2 0e       	add	r12, r18
    1b1e:	d1 1c       	adc	r13, r1
    1b20:	20 e0       	ldi	r18, 0x00	; 0
    1b22:	0f 2d       	mov	r16, r15
    1b24:	06 0f       	add	r16, r22
    1b26:	9a 81       	ldd	r25, Y+2	; 0x02
    1b28:	34 2f       	mov	r19, r20
    1b2a:	30 71       	andi	r19, 0x10	; 16
    1b2c:	44 ff       	sbrs	r20, 4
    1b2e:	03 c0       	rjmp	.+6      	; 0x1b36 <dtoa_prf+0x1fa>
    1b30:	91 33       	cpi	r25, 0x31	; 49
    1b32:	09 f4       	brne	.+2      	; 0x1b36 <dtoa_prf+0x1fa>
    1b34:	01 50       	subi	r16, 0x01	; 1
    1b36:	10 16       	cp	r1, r16
    1b38:	24 f4       	brge	.+8      	; 0x1b42 <dtoa_prf+0x206>
    1b3a:	09 30       	cpi	r16, 0x09	; 9
    1b3c:	18 f0       	brcs	.+6      	; 0x1b44 <dtoa_prf+0x208>
    1b3e:	08 e0       	ldi	r16, 0x08	; 8
    1b40:	01 c0       	rjmp	.+2      	; 0x1b44 <dtoa_prf+0x208>
    1b42:	01 e0       	ldi	r16, 0x01	; 1
    1b44:	ab 01       	movw	r20, r22
    1b46:	77 ff       	sbrs	r23, 7
    1b48:	02 c0       	rjmp	.+4      	; 0x1b4e <dtoa_prf+0x212>
    1b4a:	40 e0       	ldi	r20, 0x00	; 0
    1b4c:	50 e0       	ldi	r21, 0x00	; 0
    1b4e:	fb 01       	movw	r30, r22
    1b50:	e4 1b       	sub	r30, r20
    1b52:	f5 0b       	sbc	r31, r21
    1b54:	a1 e0       	ldi	r26, 0x01	; 1
    1b56:	b0 e0       	ldi	r27, 0x00	; 0
    1b58:	ac 0f       	add	r26, r28
    1b5a:	bd 1f       	adc	r27, r29
    1b5c:	ea 0f       	add	r30, r26
    1b5e:	fb 1f       	adc	r31, r27
    1b60:	8e e2       	ldi	r24, 0x2E	; 46
    1b62:	a8 2e       	mov	r10, r24
    1b64:	4b 01       	movw	r8, r22
    1b66:	80 1a       	sub	r8, r16
    1b68:	91 08       	sbc	r9, r1
    1b6a:	0b 2d       	mov	r16, r11
    1b6c:	10 e0       	ldi	r17, 0x00	; 0
    1b6e:	11 95       	neg	r17
    1b70:	01 95       	neg	r16
    1b72:	11 09       	sbc	r17, r1
    1b74:	4f 3f       	cpi	r20, 0xFF	; 255
    1b76:	bf ef       	ldi	r27, 0xFF	; 255
    1b78:	5b 07       	cpc	r21, r27
    1b7a:	21 f4       	brne	.+8      	; 0x1b84 <dtoa_prf+0x248>
    1b7c:	d6 01       	movw	r26, r12
    1b7e:	ac 92       	st	X, r10
    1b80:	11 96       	adiw	r26, 0x01	; 1
    1b82:	6d 01       	movw	r12, r26
    1b84:	64 17       	cp	r22, r20
    1b86:	75 07       	cpc	r23, r21
    1b88:	2c f0       	brlt	.+10     	; 0x1b94 <dtoa_prf+0x258>
    1b8a:	84 16       	cp	r8, r20
    1b8c:	95 06       	cpc	r9, r21
    1b8e:	14 f4       	brge	.+4      	; 0x1b94 <dtoa_prf+0x258>
    1b90:	81 81       	ldd	r24, Z+1	; 0x01
    1b92:	01 c0       	rjmp	.+2      	; 0x1b96 <dtoa_prf+0x25a>
    1b94:	80 e3       	ldi	r24, 0x30	; 48
    1b96:	41 50       	subi	r20, 0x01	; 1
    1b98:	51 09       	sbc	r21, r1
    1b9a:	31 96       	adiw	r30, 0x01	; 1
    1b9c:	d6 01       	movw	r26, r12
    1b9e:	11 96       	adiw	r26, 0x01	; 1
    1ba0:	7d 01       	movw	r14, r26
    1ba2:	40 17       	cp	r20, r16
    1ba4:	51 07       	cpc	r21, r17
    1ba6:	24 f0       	brlt	.+8      	; 0x1bb0 <dtoa_prf+0x274>
    1ba8:	d6 01       	movw	r26, r12
    1baa:	8c 93       	st	X, r24
    1bac:	67 01       	movw	r12, r14
    1bae:	e2 cf       	rjmp	.-60     	; 0x1b74 <dtoa_prf+0x238>
    1bb0:	64 17       	cp	r22, r20
    1bb2:	75 07       	cpc	r23, r21
    1bb4:	39 f4       	brne	.+14     	; 0x1bc4 <dtoa_prf+0x288>
    1bb6:	96 33       	cpi	r25, 0x36	; 54
    1bb8:	20 f4       	brcc	.+8      	; 0x1bc2 <dtoa_prf+0x286>
    1bba:	95 33       	cpi	r25, 0x35	; 53
    1bbc:	19 f4       	brne	.+6      	; 0x1bc4 <dtoa_prf+0x288>
    1bbe:	31 11       	cpse	r19, r1
    1bc0:	01 c0       	rjmp	.+2      	; 0x1bc4 <dtoa_prf+0x288>
    1bc2:	81 e3       	ldi	r24, 0x31	; 49
    1bc4:	f6 01       	movw	r30, r12
    1bc6:	80 83       	st	Z, r24
    1bc8:	f7 01       	movw	r30, r14
    1bca:	82 2f       	mov	r24, r18
    1bcc:	90 e2       	ldi	r25, 0x20	; 32
    1bce:	88 23       	and	r24, r24
    1bd0:	19 f0       	breq	.+6      	; 0x1bd8 <dtoa_prf+0x29c>
    1bd2:	91 93       	st	Z+, r25
    1bd4:	81 50       	subi	r24, 0x01	; 1
    1bd6:	fb cf       	rjmp	.-10     	; 0x1bce <dtoa_prf+0x292>
    1bd8:	f7 01       	movw	r30, r14
    1bda:	e2 0f       	add	r30, r18
    1bdc:	f1 1d       	adc	r31, r1
    1bde:	10 82       	st	Z, r1
    1be0:	80 e0       	ldi	r24, 0x00	; 0
    1be2:	90 e0       	ldi	r25, 0x00	; 0
    1be4:	29 96       	adiw	r28, 0x09	; 9
    1be6:	ec e0       	ldi	r30, 0x0C	; 12
    1be8:	a7 c1       	rjmp	.+846    	; 0x1f38 <__epilogue_restores__+0xc>

00001bea <__ftoa_engine>:
    1bea:	28 30       	cpi	r18, 0x08	; 8
    1bec:	08 f0       	brcs	.+2      	; 0x1bf0 <__ftoa_engine+0x6>
    1bee:	27 e0       	ldi	r18, 0x07	; 7
    1bf0:	33 27       	eor	r19, r19
    1bf2:	da 01       	movw	r26, r20
    1bf4:	99 0f       	add	r25, r25
    1bf6:	31 1d       	adc	r19, r1
    1bf8:	87 fd       	sbrc	r24, 7
    1bfa:	91 60       	ori	r25, 0x01	; 1
    1bfc:	00 96       	adiw	r24, 0x00	; 0
    1bfe:	61 05       	cpc	r22, r1
    1c00:	71 05       	cpc	r23, r1
    1c02:	39 f4       	brne	.+14     	; 0x1c12 <__ftoa_engine+0x28>
    1c04:	32 60       	ori	r19, 0x02	; 2
    1c06:	2e 5f       	subi	r18, 0xFE	; 254
    1c08:	3d 93       	st	X+, r19
    1c0a:	30 e3       	ldi	r19, 0x30	; 48
    1c0c:	2a 95       	dec	r18
    1c0e:	e1 f7       	brne	.-8      	; 0x1c08 <__ftoa_engine+0x1e>
    1c10:	08 95       	ret
    1c12:	9f 3f       	cpi	r25, 0xFF	; 255
    1c14:	30 f0       	brcs	.+12     	; 0x1c22 <__ftoa_engine+0x38>
    1c16:	80 38       	cpi	r24, 0x80	; 128
    1c18:	71 05       	cpc	r23, r1
    1c1a:	61 05       	cpc	r22, r1
    1c1c:	09 f0       	breq	.+2      	; 0x1c20 <__ftoa_engine+0x36>
    1c1e:	3c 5f       	subi	r19, 0xFC	; 252
    1c20:	3c 5f       	subi	r19, 0xFC	; 252
    1c22:	3d 93       	st	X+, r19
    1c24:	91 30       	cpi	r25, 0x01	; 1
    1c26:	08 f0       	brcs	.+2      	; 0x1c2a <__ftoa_engine+0x40>
    1c28:	80 68       	ori	r24, 0x80	; 128
    1c2a:	91 1d       	adc	r25, r1
    1c2c:	df 93       	push	r29
    1c2e:	cf 93       	push	r28
    1c30:	1f 93       	push	r17
    1c32:	0f 93       	push	r16
    1c34:	ff 92       	push	r15
    1c36:	ef 92       	push	r14
    1c38:	19 2f       	mov	r17, r25
    1c3a:	98 7f       	andi	r25, 0xF8	; 248
    1c3c:	96 95       	lsr	r25
    1c3e:	e9 2f       	mov	r30, r25
    1c40:	96 95       	lsr	r25
    1c42:	96 95       	lsr	r25
    1c44:	e9 0f       	add	r30, r25
    1c46:	ff 27       	eor	r31, r31
    1c48:	e2 57       	subi	r30, 0x72	; 114
    1c4a:	ff 4f       	sbci	r31, 0xFF	; 255
    1c4c:	99 27       	eor	r25, r25
    1c4e:	33 27       	eor	r19, r19
    1c50:	ee 24       	eor	r14, r14
    1c52:	ff 24       	eor	r15, r15
    1c54:	a7 01       	movw	r20, r14
    1c56:	e7 01       	movw	r28, r14
    1c58:	05 90       	lpm	r0, Z+
    1c5a:	08 94       	sec
    1c5c:	07 94       	ror	r0
    1c5e:	28 f4       	brcc	.+10     	; 0x1c6a <__ftoa_engine+0x80>
    1c60:	36 0f       	add	r19, r22
    1c62:	e7 1e       	adc	r14, r23
    1c64:	f8 1e       	adc	r15, r24
    1c66:	49 1f       	adc	r20, r25
    1c68:	51 1d       	adc	r21, r1
    1c6a:	66 0f       	add	r22, r22
    1c6c:	77 1f       	adc	r23, r23
    1c6e:	88 1f       	adc	r24, r24
    1c70:	99 1f       	adc	r25, r25
    1c72:	06 94       	lsr	r0
    1c74:	a1 f7       	brne	.-24     	; 0x1c5e <__ftoa_engine+0x74>
    1c76:	05 90       	lpm	r0, Z+
    1c78:	07 94       	ror	r0
    1c7a:	28 f4       	brcc	.+10     	; 0x1c86 <__ftoa_engine+0x9c>
    1c7c:	e7 0e       	add	r14, r23
    1c7e:	f8 1e       	adc	r15, r24
    1c80:	49 1f       	adc	r20, r25
    1c82:	56 1f       	adc	r21, r22
    1c84:	c1 1d       	adc	r28, r1
    1c86:	77 0f       	add	r23, r23
    1c88:	88 1f       	adc	r24, r24
    1c8a:	99 1f       	adc	r25, r25
    1c8c:	66 1f       	adc	r22, r22
    1c8e:	06 94       	lsr	r0
    1c90:	a1 f7       	brne	.-24     	; 0x1c7a <__ftoa_engine+0x90>
    1c92:	05 90       	lpm	r0, Z+
    1c94:	07 94       	ror	r0
    1c96:	28 f4       	brcc	.+10     	; 0x1ca2 <__ftoa_engine+0xb8>
    1c98:	f8 0e       	add	r15, r24
    1c9a:	49 1f       	adc	r20, r25
    1c9c:	56 1f       	adc	r21, r22
    1c9e:	c7 1f       	adc	r28, r23
    1ca0:	d1 1d       	adc	r29, r1
    1ca2:	88 0f       	add	r24, r24
    1ca4:	99 1f       	adc	r25, r25
    1ca6:	66 1f       	adc	r22, r22
    1ca8:	77 1f       	adc	r23, r23
    1caa:	06 94       	lsr	r0
    1cac:	a1 f7       	brne	.-24     	; 0x1c96 <__ftoa_engine+0xac>
    1cae:	05 90       	lpm	r0, Z+
    1cb0:	07 94       	ror	r0
    1cb2:	20 f4       	brcc	.+8      	; 0x1cbc <__ftoa_engine+0xd2>
    1cb4:	49 0f       	add	r20, r25
    1cb6:	56 1f       	adc	r21, r22
    1cb8:	c7 1f       	adc	r28, r23
    1cba:	d8 1f       	adc	r29, r24
    1cbc:	99 0f       	add	r25, r25
    1cbe:	66 1f       	adc	r22, r22
    1cc0:	77 1f       	adc	r23, r23
    1cc2:	88 1f       	adc	r24, r24
    1cc4:	06 94       	lsr	r0
    1cc6:	a9 f7       	brne	.-22     	; 0x1cb2 <__ftoa_engine+0xc8>
    1cc8:	84 91       	lpm	r24, Z
    1cca:	10 95       	com	r17
    1ccc:	17 70       	andi	r17, 0x07	; 7
    1cce:	41 f0       	breq	.+16     	; 0x1ce0 <__ftoa_engine+0xf6>
    1cd0:	d6 95       	lsr	r29
    1cd2:	c7 95       	ror	r28
    1cd4:	57 95       	ror	r21
    1cd6:	47 95       	ror	r20
    1cd8:	f7 94       	ror	r15
    1cda:	e7 94       	ror	r14
    1cdc:	1a 95       	dec	r17
    1cde:	c1 f7       	brne	.-16     	; 0x1cd0 <__ftoa_engine+0xe6>
    1ce0:	e4 e3       	ldi	r30, 0x34	; 52
    1ce2:	f0 e0       	ldi	r31, 0x00	; 0
    1ce4:	68 94       	set
    1ce6:	15 90       	lpm	r1, Z+
    1ce8:	15 91       	lpm	r17, Z+
    1cea:	35 91       	lpm	r19, Z+
    1cec:	65 91       	lpm	r22, Z+
    1cee:	95 91       	lpm	r25, Z+
    1cf0:	05 90       	lpm	r0, Z+
    1cf2:	7f e2       	ldi	r23, 0x2F	; 47
    1cf4:	73 95       	inc	r23
    1cf6:	e1 18       	sub	r14, r1
    1cf8:	f1 0a       	sbc	r15, r17
    1cfa:	43 0b       	sbc	r20, r19
    1cfc:	56 0b       	sbc	r21, r22
    1cfe:	c9 0b       	sbc	r28, r25
    1d00:	d0 09       	sbc	r29, r0
    1d02:	c0 f7       	brcc	.-16     	; 0x1cf4 <__ftoa_engine+0x10a>
    1d04:	e1 0c       	add	r14, r1
    1d06:	f1 1e       	adc	r15, r17
    1d08:	43 1f       	adc	r20, r19
    1d0a:	56 1f       	adc	r21, r22
    1d0c:	c9 1f       	adc	r28, r25
    1d0e:	d0 1d       	adc	r29, r0
    1d10:	7e f4       	brtc	.+30     	; 0x1d30 <__ftoa_engine+0x146>
    1d12:	70 33       	cpi	r23, 0x30	; 48
    1d14:	11 f4       	brne	.+4      	; 0x1d1a <__ftoa_engine+0x130>
    1d16:	8a 95       	dec	r24
    1d18:	e6 cf       	rjmp	.-52     	; 0x1ce6 <__ftoa_engine+0xfc>
    1d1a:	e8 94       	clt
    1d1c:	01 50       	subi	r16, 0x01	; 1
    1d1e:	30 f0       	brcs	.+12     	; 0x1d2c <__ftoa_engine+0x142>
    1d20:	08 0f       	add	r16, r24
    1d22:	0a f4       	brpl	.+2      	; 0x1d26 <__ftoa_engine+0x13c>
    1d24:	00 27       	eor	r16, r16
    1d26:	02 17       	cp	r16, r18
    1d28:	08 f4       	brcc	.+2      	; 0x1d2c <__ftoa_engine+0x142>
    1d2a:	20 2f       	mov	r18, r16
    1d2c:	23 95       	inc	r18
    1d2e:	02 2f       	mov	r16, r18
    1d30:	7a 33       	cpi	r23, 0x3A	; 58
    1d32:	28 f0       	brcs	.+10     	; 0x1d3e <__ftoa_engine+0x154>
    1d34:	79 e3       	ldi	r23, 0x39	; 57
    1d36:	7d 93       	st	X+, r23
    1d38:	2a 95       	dec	r18
    1d3a:	e9 f7       	brne	.-6      	; 0x1d36 <__ftoa_engine+0x14c>
    1d3c:	10 c0       	rjmp	.+32     	; 0x1d5e <__ftoa_engine+0x174>
    1d3e:	7d 93       	st	X+, r23
    1d40:	2a 95       	dec	r18
    1d42:	89 f6       	brne	.-94     	; 0x1ce6 <__ftoa_engine+0xfc>
    1d44:	06 94       	lsr	r0
    1d46:	97 95       	ror	r25
    1d48:	67 95       	ror	r22
    1d4a:	37 95       	ror	r19
    1d4c:	17 95       	ror	r17
    1d4e:	17 94       	ror	r1
    1d50:	e1 18       	sub	r14, r1
    1d52:	f1 0a       	sbc	r15, r17
    1d54:	43 0b       	sbc	r20, r19
    1d56:	56 0b       	sbc	r21, r22
    1d58:	c9 0b       	sbc	r28, r25
    1d5a:	d0 09       	sbc	r29, r0
    1d5c:	98 f0       	brcs	.+38     	; 0x1d84 <__ftoa_engine+0x19a>
    1d5e:	23 95       	inc	r18
    1d60:	7e 91       	ld	r23, -X
    1d62:	73 95       	inc	r23
    1d64:	7a 33       	cpi	r23, 0x3A	; 58
    1d66:	08 f0       	brcs	.+2      	; 0x1d6a <__ftoa_engine+0x180>
    1d68:	70 e3       	ldi	r23, 0x30	; 48
    1d6a:	7c 93       	st	X, r23
    1d6c:	20 13       	cpse	r18, r16
    1d6e:	b8 f7       	brcc	.-18     	; 0x1d5e <__ftoa_engine+0x174>
    1d70:	7e 91       	ld	r23, -X
    1d72:	70 61       	ori	r23, 0x10	; 16
    1d74:	7d 93       	st	X+, r23
    1d76:	30 f0       	brcs	.+12     	; 0x1d84 <__ftoa_engine+0x19a>
    1d78:	83 95       	inc	r24
    1d7a:	71 e3       	ldi	r23, 0x31	; 49
    1d7c:	7d 93       	st	X+, r23
    1d7e:	70 e3       	ldi	r23, 0x30	; 48
    1d80:	2a 95       	dec	r18
    1d82:	e1 f7       	brne	.-8      	; 0x1d7c <__ftoa_engine+0x192>
    1d84:	11 24       	eor	r1, r1
    1d86:	ef 90       	pop	r14
    1d88:	ff 90       	pop	r15
    1d8a:	0f 91       	pop	r16
    1d8c:	1f 91       	pop	r17
    1d8e:	cf 91       	pop	r28
    1d90:	df 91       	pop	r29
    1d92:	99 27       	eor	r25, r25
    1d94:	87 fd       	sbrc	r24, 7
    1d96:	90 95       	com	r25
    1d98:	08 95       	ret

00001d9a <strnlen_P>:
    1d9a:	fc 01       	movw	r30, r24
    1d9c:	05 90       	lpm	r0, Z+
    1d9e:	61 50       	subi	r22, 0x01	; 1
    1da0:	70 40       	sbci	r23, 0x00	; 0
    1da2:	01 10       	cpse	r0, r1
    1da4:	d8 f7       	brcc	.-10     	; 0x1d9c <strnlen_P+0x2>
    1da6:	80 95       	com	r24
    1da8:	90 95       	com	r25
    1daa:	8e 0f       	add	r24, r30
    1dac:	9f 1f       	adc	r25, r31
    1dae:	08 95       	ret

00001db0 <strnlen>:
    1db0:	fc 01       	movw	r30, r24
    1db2:	61 50       	subi	r22, 0x01	; 1
    1db4:	70 40       	sbci	r23, 0x00	; 0
    1db6:	01 90       	ld	r0, Z+
    1db8:	01 10       	cpse	r0, r1
    1dba:	d8 f7       	brcc	.-10     	; 0x1db2 <strnlen+0x2>
    1dbc:	80 95       	com	r24
    1dbe:	90 95       	com	r25
    1dc0:	8e 0f       	add	r24, r30
    1dc2:	9f 1f       	adc	r25, r31
    1dc4:	08 95       	ret

00001dc6 <fputc>:
    1dc6:	0f 93       	push	r16
    1dc8:	1f 93       	push	r17
    1dca:	cf 93       	push	r28
    1dcc:	df 93       	push	r29
    1dce:	fb 01       	movw	r30, r22
    1dd0:	23 81       	ldd	r18, Z+3	; 0x03
    1dd2:	21 fd       	sbrc	r18, 1
    1dd4:	03 c0       	rjmp	.+6      	; 0x1ddc <fputc+0x16>
    1dd6:	8f ef       	ldi	r24, 0xFF	; 255
    1dd8:	9f ef       	ldi	r25, 0xFF	; 255
    1dda:	2c c0       	rjmp	.+88     	; 0x1e34 <fputc+0x6e>
    1ddc:	22 ff       	sbrs	r18, 2
    1dde:	16 c0       	rjmp	.+44     	; 0x1e0c <fputc+0x46>
    1de0:	46 81       	ldd	r20, Z+6	; 0x06
    1de2:	57 81       	ldd	r21, Z+7	; 0x07
    1de4:	24 81       	ldd	r18, Z+4	; 0x04
    1de6:	35 81       	ldd	r19, Z+5	; 0x05
    1de8:	42 17       	cp	r20, r18
    1dea:	53 07       	cpc	r21, r19
    1dec:	44 f4       	brge	.+16     	; 0x1dfe <fputc+0x38>
    1dee:	a0 81       	ld	r26, Z
    1df0:	b1 81       	ldd	r27, Z+1	; 0x01
    1df2:	9d 01       	movw	r18, r26
    1df4:	2f 5f       	subi	r18, 0xFF	; 255
    1df6:	3f 4f       	sbci	r19, 0xFF	; 255
    1df8:	20 83       	st	Z, r18
    1dfa:	31 83       	std	Z+1, r19	; 0x01
    1dfc:	8c 93       	st	X, r24
    1dfe:	26 81       	ldd	r18, Z+6	; 0x06
    1e00:	37 81       	ldd	r19, Z+7	; 0x07
    1e02:	2f 5f       	subi	r18, 0xFF	; 255
    1e04:	3f 4f       	sbci	r19, 0xFF	; 255
    1e06:	26 83       	std	Z+6, r18	; 0x06
    1e08:	37 83       	std	Z+7, r19	; 0x07
    1e0a:	14 c0       	rjmp	.+40     	; 0x1e34 <fputc+0x6e>
    1e0c:	8b 01       	movw	r16, r22
    1e0e:	ec 01       	movw	r28, r24
    1e10:	fb 01       	movw	r30, r22
    1e12:	00 84       	ldd	r0, Z+8	; 0x08
    1e14:	f1 85       	ldd	r31, Z+9	; 0x09
    1e16:	e0 2d       	mov	r30, r0
    1e18:	09 95       	icall
    1e1a:	89 2b       	or	r24, r25
    1e1c:	e1 f6       	brne	.-72     	; 0x1dd6 <fputc+0x10>
    1e1e:	d8 01       	movw	r26, r16
    1e20:	16 96       	adiw	r26, 0x06	; 6
    1e22:	8d 91       	ld	r24, X+
    1e24:	9c 91       	ld	r25, X
    1e26:	17 97       	sbiw	r26, 0x07	; 7
    1e28:	01 96       	adiw	r24, 0x01	; 1
    1e2a:	16 96       	adiw	r26, 0x06	; 6
    1e2c:	8d 93       	st	X+, r24
    1e2e:	9c 93       	st	X, r25
    1e30:	17 97       	sbiw	r26, 0x07	; 7
    1e32:	ce 01       	movw	r24, r28
    1e34:	df 91       	pop	r29
    1e36:	cf 91       	pop	r28
    1e38:	1f 91       	pop	r17
    1e3a:	0f 91       	pop	r16
    1e3c:	08 95       	ret

00001e3e <__ultoa_invert>:
    1e3e:	fa 01       	movw	r30, r20
    1e40:	aa 27       	eor	r26, r26
    1e42:	28 30       	cpi	r18, 0x08	; 8
    1e44:	51 f1       	breq	.+84     	; 0x1e9a <__ultoa_invert+0x5c>
    1e46:	20 31       	cpi	r18, 0x10	; 16
    1e48:	81 f1       	breq	.+96     	; 0x1eaa <__ultoa_invert+0x6c>
    1e4a:	e8 94       	clt
    1e4c:	6f 93       	push	r22
    1e4e:	6e 7f       	andi	r22, 0xFE	; 254
    1e50:	6e 5f       	subi	r22, 0xFE	; 254
    1e52:	7f 4f       	sbci	r23, 0xFF	; 255
    1e54:	8f 4f       	sbci	r24, 0xFF	; 255
    1e56:	9f 4f       	sbci	r25, 0xFF	; 255
    1e58:	af 4f       	sbci	r26, 0xFF	; 255
    1e5a:	b1 e0       	ldi	r27, 0x01	; 1
    1e5c:	3e d0       	rcall	.+124    	; 0x1eda <__ultoa_invert+0x9c>
    1e5e:	b4 e0       	ldi	r27, 0x04	; 4
    1e60:	3c d0       	rcall	.+120    	; 0x1eda <__ultoa_invert+0x9c>
    1e62:	67 0f       	add	r22, r23
    1e64:	78 1f       	adc	r23, r24
    1e66:	89 1f       	adc	r24, r25
    1e68:	9a 1f       	adc	r25, r26
    1e6a:	a1 1d       	adc	r26, r1
    1e6c:	68 0f       	add	r22, r24
    1e6e:	79 1f       	adc	r23, r25
    1e70:	8a 1f       	adc	r24, r26
    1e72:	91 1d       	adc	r25, r1
    1e74:	a1 1d       	adc	r26, r1
    1e76:	6a 0f       	add	r22, r26
    1e78:	71 1d       	adc	r23, r1
    1e7a:	81 1d       	adc	r24, r1
    1e7c:	91 1d       	adc	r25, r1
    1e7e:	a1 1d       	adc	r26, r1
    1e80:	20 d0       	rcall	.+64     	; 0x1ec2 <__ultoa_invert+0x84>
    1e82:	09 f4       	brne	.+2      	; 0x1e86 <__ultoa_invert+0x48>
    1e84:	68 94       	set
    1e86:	3f 91       	pop	r19
    1e88:	2a e0       	ldi	r18, 0x0A	; 10
    1e8a:	26 9f       	mul	r18, r22
    1e8c:	11 24       	eor	r1, r1
    1e8e:	30 19       	sub	r19, r0
    1e90:	30 5d       	subi	r19, 0xD0	; 208
    1e92:	31 93       	st	Z+, r19
    1e94:	de f6       	brtc	.-74     	; 0x1e4c <__ultoa_invert+0xe>
    1e96:	cf 01       	movw	r24, r30
    1e98:	08 95       	ret
    1e9a:	46 2f       	mov	r20, r22
    1e9c:	47 70       	andi	r20, 0x07	; 7
    1e9e:	40 5d       	subi	r20, 0xD0	; 208
    1ea0:	41 93       	st	Z+, r20
    1ea2:	b3 e0       	ldi	r27, 0x03	; 3
    1ea4:	0f d0       	rcall	.+30     	; 0x1ec4 <__ultoa_invert+0x86>
    1ea6:	c9 f7       	brne	.-14     	; 0x1e9a <__ultoa_invert+0x5c>
    1ea8:	f6 cf       	rjmp	.-20     	; 0x1e96 <__ultoa_invert+0x58>
    1eaa:	46 2f       	mov	r20, r22
    1eac:	4f 70       	andi	r20, 0x0F	; 15
    1eae:	40 5d       	subi	r20, 0xD0	; 208
    1eb0:	4a 33       	cpi	r20, 0x3A	; 58
    1eb2:	18 f0       	brcs	.+6      	; 0x1eba <__ultoa_invert+0x7c>
    1eb4:	49 5d       	subi	r20, 0xD9	; 217
    1eb6:	31 fd       	sbrc	r19, 1
    1eb8:	40 52       	subi	r20, 0x20	; 32
    1eba:	41 93       	st	Z+, r20
    1ebc:	02 d0       	rcall	.+4      	; 0x1ec2 <__ultoa_invert+0x84>
    1ebe:	a9 f7       	brne	.-22     	; 0x1eaa <__ultoa_invert+0x6c>
    1ec0:	ea cf       	rjmp	.-44     	; 0x1e96 <__ultoa_invert+0x58>
    1ec2:	b4 e0       	ldi	r27, 0x04	; 4
    1ec4:	a6 95       	lsr	r26
    1ec6:	97 95       	ror	r25
    1ec8:	87 95       	ror	r24
    1eca:	77 95       	ror	r23
    1ecc:	67 95       	ror	r22
    1ece:	ba 95       	dec	r27
    1ed0:	c9 f7       	brne	.-14     	; 0x1ec4 <__ultoa_invert+0x86>
    1ed2:	00 97       	sbiw	r24, 0x00	; 0
    1ed4:	61 05       	cpc	r22, r1
    1ed6:	71 05       	cpc	r23, r1
    1ed8:	08 95       	ret
    1eda:	9b 01       	movw	r18, r22
    1edc:	ac 01       	movw	r20, r24
    1ede:	0a 2e       	mov	r0, r26
    1ee0:	06 94       	lsr	r0
    1ee2:	57 95       	ror	r21
    1ee4:	47 95       	ror	r20
    1ee6:	37 95       	ror	r19
    1ee8:	27 95       	ror	r18
    1eea:	ba 95       	dec	r27
    1eec:	c9 f7       	brne	.-14     	; 0x1ee0 <__ultoa_invert+0xa2>
    1eee:	62 0f       	add	r22, r18
    1ef0:	73 1f       	adc	r23, r19
    1ef2:	84 1f       	adc	r24, r20
    1ef4:	95 1f       	adc	r25, r21
    1ef6:	a0 1d       	adc	r26, r0
    1ef8:	08 95       	ret

00001efa <__prologue_saves__>:
    1efa:	2f 92       	push	r2
    1efc:	3f 92       	push	r3
    1efe:	4f 92       	push	r4
    1f00:	5f 92       	push	r5
    1f02:	6f 92       	push	r6
    1f04:	7f 92       	push	r7
    1f06:	8f 92       	push	r8
    1f08:	9f 92       	push	r9
    1f0a:	af 92       	push	r10
    1f0c:	bf 92       	push	r11
    1f0e:	cf 92       	push	r12
    1f10:	df 92       	push	r13
    1f12:	ef 92       	push	r14
    1f14:	ff 92       	push	r15
    1f16:	0f 93       	push	r16
    1f18:	1f 93       	push	r17
    1f1a:	cf 93       	push	r28
    1f1c:	df 93       	push	r29
    1f1e:	cd b7       	in	r28, 0x3d	; 61
    1f20:	de b7       	in	r29, 0x3e	; 62
    1f22:	ca 1b       	sub	r28, r26
    1f24:	db 0b       	sbc	r29, r27
    1f26:	cd bf       	out	0x3d, r28	; 61
    1f28:	de bf       	out	0x3e, r29	; 62
    1f2a:	09 94       	ijmp

00001f2c <__epilogue_restores__>:
    1f2c:	2a 88       	ldd	r2, Y+18	; 0x12
    1f2e:	39 88       	ldd	r3, Y+17	; 0x11
    1f30:	48 88       	ldd	r4, Y+16	; 0x10
    1f32:	5f 84       	ldd	r5, Y+15	; 0x0f
    1f34:	6e 84       	ldd	r6, Y+14	; 0x0e
    1f36:	7d 84       	ldd	r7, Y+13	; 0x0d
    1f38:	8c 84       	ldd	r8, Y+12	; 0x0c
    1f3a:	9b 84       	ldd	r9, Y+11	; 0x0b
    1f3c:	aa 84       	ldd	r10, Y+10	; 0x0a
    1f3e:	b9 84       	ldd	r11, Y+9	; 0x09
    1f40:	c8 84       	ldd	r12, Y+8	; 0x08
    1f42:	df 80       	ldd	r13, Y+7	; 0x07
    1f44:	ee 80       	ldd	r14, Y+6	; 0x06
    1f46:	fd 80       	ldd	r15, Y+5	; 0x05
    1f48:	0c 81       	ldd	r16, Y+4	; 0x04
    1f4a:	1b 81       	ldd	r17, Y+3	; 0x03
    1f4c:	aa 81       	ldd	r26, Y+2	; 0x02
    1f4e:	b9 81       	ldd	r27, Y+1	; 0x01
    1f50:	ce 0f       	add	r28, r30
    1f52:	d1 1d       	adc	r29, r1
    1f54:	cd bf       	out	0x3d, r28	; 61
    1f56:	de bf       	out	0x3e, r29	; 62
    1f58:	ed 01       	movw	r28, r26
    1f5a:	08 95       	ret

00001f5c <_exit>:
    1f5c:	f8 94       	cli

00001f5e <__stop_program>:
    1f5e:	ff cf       	rjmp	.-2      	; 0x1f5e <__stop_program>
