
Building_Brains_V4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000016  00803e00  00001997  00001a4b  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001954  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000043  00009954  00001954  00001a08  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .bss          00000053  00803e16  00803e16  00001a61  2**0
                  ALLOC
  4 .comment      0000005c  00000000  00000000  00001a61  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001ac0  2**2
                  CONTENTS, READONLY
  6 .debug_aranges 000004a8  00000000  00000000  00001b00  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000766d  00000000  00000000  00001fa8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00002f44  00000000  00000000  00009615  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00002554  00000000  00000000  0000c559  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000808  00000000  00000000  0000eab0  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00002f19  00000000  00000000  0000f2b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00001348  00000000  00000000  000121d1  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000320  00000000  00000000  00013519  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	96 c0       	rjmp	.+300    	; 0x12e <__ctors_end>
       2:	b0 c0       	rjmp	.+352    	; 0x164 <__bad_interrupt>
       4:	af c0       	rjmp	.+350    	; 0x164 <__bad_interrupt>
       6:	ae c0       	rjmp	.+348    	; 0x164 <__bad_interrupt>
       8:	ad c0       	rjmp	.+346    	; 0x164 <__bad_interrupt>
       a:	ac c0       	rjmp	.+344    	; 0x164 <__bad_interrupt>
       c:	28 c5       	rjmp	.+2640   	; 0xa5e <__vector_6>
       e:	aa c0       	rjmp	.+340    	; 0x164 <__bad_interrupt>
      10:	a9 c0       	rjmp	.+338    	; 0x164 <__bad_interrupt>
      12:	a8 c0       	rjmp	.+336    	; 0x164 <__bad_interrupt>
      14:	a7 c0       	rjmp	.+334    	; 0x164 <__bad_interrupt>
      16:	a6 c0       	rjmp	.+332    	; 0x164 <__bad_interrupt>
      18:	a5 c0       	rjmp	.+330    	; 0x164 <__bad_interrupt>
      1a:	a4 c0       	rjmp	.+328    	; 0x164 <__bad_interrupt>
      1c:	a3 c0       	rjmp	.+326    	; 0x164 <__bad_interrupt>
      1e:	a2 c0       	rjmp	.+324    	; 0x164 <__bad_interrupt>
      20:	a1 c0       	rjmp	.+322    	; 0x164 <__bad_interrupt>
      22:	a0 c0       	rjmp	.+320    	; 0x164 <__bad_interrupt>
      24:	9f c0       	rjmp	.+318    	; 0x164 <__bad_interrupt>
      26:	9e c0       	rjmp	.+316    	; 0x164 <__bad_interrupt>
      28:	9d c0       	rjmp	.+314    	; 0x164 <__bad_interrupt>
      2a:	9c c0       	rjmp	.+312    	; 0x164 <__bad_interrupt>
      2c:	9b c0       	rjmp	.+310    	; 0x164 <__bad_interrupt>
      2e:	9a c0       	rjmp	.+308    	; 0x164 <__bad_interrupt>
      30:	99 c0       	rjmp	.+306    	; 0x164 <__bad_interrupt>
      32:	98 c0       	rjmp	.+304    	; 0x164 <__bad_interrupt>

00000034 <__trampolines_end>:
      34:	00 40       	sbci	r16, 0x00	; 0
      36:	7a 10       	cpse	r7, r10
      38:	f3 5a       	subi	r31, 0xA3	; 163
      3a:	00 a0       	ldd	r0, Z+32	; 0x20
      3c:	72 4e       	sbci	r23, 0xE2	; 226
      3e:	18 09       	sbc	r17, r8
      40:	00 10       	cpse	r0, r0
      42:	a5 d4       	rcall	.+2378   	; 0x98e <tinyDendrite_update_signals+0x118>
      44:	e8 00       	.word	0x00e8	; ????
      46:	00 e8       	ldi	r16, 0x80	; 128
      48:	76 48       	sbci	r23, 0x86	; 134
      4a:	17 00       	.word	0x0017	; ????
      4c:	00 e4       	ldi	r16, 0x40	; 64
      4e:	0b 54       	subi	r16, 0x4B	; 75
      50:	02 00       	.word	0x0002	; ????
      52:	00 ca       	rjmp	.-3072   	; 0xfffff454 <__eeprom_end+0xff7ef454>
      54:	9a 3b       	cpi	r25, 0xBA	; 186
      56:	00 00       	nop
      58:	00 e1       	ldi	r16, 0x10	; 16
      5a:	f5 05       	cpc	r31, r5
      5c:	00 00       	nop
      5e:	80 96       	adiw	r24, 0x20	; 32
      60:	98 00       	.word	0x0098	; ????
      62:	00 00       	nop
      64:	40 42       	sbci	r20, 0x20	; 32
      66:	0f 00       	.word	0x000f	; ????
      68:	00 00       	nop
      6a:	a0 86       	std	Z+8, r10	; 0x08
      6c:	01 00       	.word	0x0001	; ????
      6e:	00 00       	nop
      70:	10 27       	eor	r17, r16
      72:	00 00       	nop
      74:	00 00       	nop
      76:	e8 03       	fmulsu	r22, r16
      78:	00 00       	nop
      7a:	00 00       	nop
      7c:	64 00       	.word	0x0064	; ????
      7e:	00 00       	nop
      80:	00 00       	nop
      82:	0a 00       	.word	0x000a	; ????
      84:	00 00       	nop
      86:	00 00       	nop
      88:	01 00       	.word	0x0001	; ????
      8a:	00 00       	nop
      8c:	00 00       	nop
      8e:	2c 76       	andi	r18, 0x6C	; 108
      90:	d8 88       	ldd	r13, Y+16	; 0x10
      92:	dc 67       	ori	r29, 0x7C	; 124
      94:	4f 08       	sbc	r4, r15
      96:	23 df       	rcall	.-442    	; 0xfffffede <__eeprom_end+0xff7efede>
      98:	c1 df       	rcall	.-126    	; 0x1c <__FUSE_REGION_LENGTH__+0x13>
      9a:	ae 59       	subi	r26, 0x9E	; 158
      9c:	e1 b1       	in	r30, 0x01	; 1
      9e:	b7 96       	adiw	r30, 0x27	; 39
      a0:	e5 e3       	ldi	r30, 0x35	; 53
      a2:	e4 53       	subi	r30, 0x34	; 52
      a4:	c6 3a       	cpi	r28, 0xA6	; 166
      a6:	e6 51       	subi	r30, 0x16	; 22
      a8:	99 76       	andi	r25, 0x69	; 105
      aa:	96 e8       	ldi	r25, 0x86	; 134
      ac:	e6 c2       	rjmp	.+1484   	; 0x67a <tinyLED_update+0xc>
      ae:	84 26       	eor	r8, r20
      b0:	eb 89       	ldd	r30, Y+19	; 0x13
      b2:	8c 9b       	sbis	0x11, 4	; 17
      b4:	62 ed       	ldi	r22, 0xD2	; 210
      b6:	40 7c       	andi	r20, 0xC0	; 192
      b8:	6f fc       	.word	0xfc6f	; ????
      ba:	ef bc       	out	0x2f, r14	; 47
      bc:	9c 9f       	mul	r25, r28
      be:	40 f2       	brcs	.-112    	; 0x50 <__SREG__+0x11>
      c0:	ba a5       	ldd	r27, Y+42	; 0x2a
      c2:	6f a5       	ldd	r22, Y+47	; 0x2f
      c4:	f4 90       	lpm	r15, Z
      c6:	05 5a       	subi	r16, 0xA5	; 165
      c8:	2a f7       	brpl	.-54     	; 0x94 <__SREG__+0x55>
      ca:	5c 93       	st	X, r21
      cc:	6b 6c       	ori	r22, 0xCB	; 203
      ce:	f9 67       	ori	r31, 0x79	; 121
      d0:	6d c1       	rjmp	.+730    	; 0x3ac <USART_0_init+0x1a>
      d2:	1b fc       	.word	0xfc1b	; ????
      d4:	e0 e4       	ldi	r30, 0x40	; 64
      d6:	0d 47       	sbci	r16, 0x7D	; 125
      d8:	fe f5       	brtc	.+126    	; 0x158 <.do_clear_bss_loop>
      da:	20 e6       	ldi	r18, 0x60	; 96
      dc:	b5 00       	.word	0x00b5	; ????
      de:	d0 ed       	ldi	r29, 0xD0	; 208
      e0:	90 2e       	mov	r9, r16
      e2:	03 00       	.word	0x0003	; ????
      e4:	94 35       	cpi	r25, 0x54	; 84
      e6:	77 05       	cpc	r23, r7
      e8:	00 80       	ld	r0, Z
      ea:	84 1e       	adc	r8, r20
      ec:	08 00       	.word	0x0008	; ????
      ee:	00 20       	and	r0, r0
      f0:	4e 0a       	sbc	r4, r30
      f2:	00 00       	nop
      f4:	00 c8       	rjmp	.-4096   	; 0xfffff0f6 <__eeprom_end+0xff7ef0f6>
      f6:	0c 33       	cpi	r16, 0x3C	; 60
      f8:	33 33       	cpi	r19, 0x33	; 51
      fa:	33 0f       	add	r19, r19
      fc:	98 6e       	ori	r25, 0xE8	; 232
      fe:	12 83       	std	Z+2, r17	; 0x02
     100:	11 41       	sbci	r17, 0x11	; 17
     102:	ef 8d       	ldd	r30, Y+31	; 0x1f
     104:	21 14       	cp	r2, r1
     106:	89 3b       	cpi	r24, 0xB9	; 185
     108:	e6 55       	subi	r30, 0x56	; 86
     10a:	16 cf       	rjmp	.-468    	; 0xffffff38 <__eeprom_end+0xff7eff38>
     10c:	fe e6       	ldi	r31, 0x6E	; 110
     10e:	db 18       	sub	r13, r11
     110:	d1 84       	ldd	r13, Z+9	; 0x09
     112:	4b 38       	cpi	r20, 0x8B	; 139
     114:	1b f7       	brvc	.-58     	; 0xdc <__SREG__+0x9d>
     116:	7c 1d       	adc	r23, r12
     118:	90 1d       	adc	r25, r0
     11a:	a4 bb       	out	0x14, r26	; 20
     11c:	e4 24       	eor	r14, r4
     11e:	20 32       	cpi	r18, 0x20	; 32
     120:	84 72       	andi	r24, 0x24	; 36
     122:	5e 22       	and	r5, r30
     124:	81 00       	.word	0x0081	; ????
     126:	c9 f1       	breq	.+114    	; 0x19a <ADC_get_conversion+0x1e>
     128:	24 ec       	ldi	r18, 0xC4	; 196
     12a:	a1 e5       	ldi	r26, 0x51	; 81
     12c:	3d 27       	eor	r19, r29

0000012e <__ctors_end>:
     12e:	11 24       	eor	r1, r1
     130:	1f be       	out	0x3f, r1	; 63
     132:	cf ef       	ldi	r28, 0xFF	; 255
     134:	cd bf       	out	0x3d, r28	; 61
     136:	df e3       	ldi	r29, 0x3F	; 63
     138:	de bf       	out	0x3e, r29	; 62

0000013a <__do_copy_data>:
     13a:	1e e3       	ldi	r17, 0x3E	; 62
     13c:	a0 e0       	ldi	r26, 0x00	; 0
     13e:	be e3       	ldi	r27, 0x3E	; 62
     140:	e7 e9       	ldi	r30, 0x97	; 151
     142:	f9 e1       	ldi	r31, 0x19	; 25
     144:	02 c0       	rjmp	.+4      	; 0x14a <__do_copy_data+0x10>
     146:	05 90       	lpm	r0, Z+
     148:	0d 92       	st	X+, r0
     14a:	a6 31       	cpi	r26, 0x16	; 22
     14c:	b1 07       	cpc	r27, r17
     14e:	d9 f7       	brne	.-10     	; 0x146 <__do_copy_data+0xc>

00000150 <__do_clear_bss>:
     150:	2e e3       	ldi	r18, 0x3E	; 62
     152:	a6 e1       	ldi	r26, 0x16	; 22
     154:	be e3       	ldi	r27, 0x3E	; 62
     156:	01 c0       	rjmp	.+2      	; 0x15a <.do_clear_bss_start>

00000158 <.do_clear_bss_loop>:
     158:	1d 92       	st	X+, r1

0000015a <.do_clear_bss_start>:
     15a:	a9 36       	cpi	r26, 0x69	; 105
     15c:	b2 07       	cpc	r27, r18
     15e:	e1 f7       	brne	.-8      	; 0x158 <.do_clear_bss_loop>
     160:	f3 d1       	rcall	.+998    	; 0x548 <main>
     162:	f6 cb       	rjmp	.-2068   	; 0xfffff950 <__eeprom_end+0xff7ef950>

00000164 <__bad_interrupt>:
     164:	4d cf       	rjmp	.-358    	; 0x0 <__vectors>

00000166 <atmel_start_init>:
/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
	system_init();
     166:	c2 d0       	rcall	.+388    	; 0x2ec <system_init>
     168:	08 95       	ret

0000016a <ADC_init>:
 * \return Conversion result read from the ADC ADC module
 */
adc_result_t ADC_get_conversion_result(void)
{
	return (ADC0.RES);
}
     16a:	85 e0       	ldi	r24, 0x05	; 5
     16c:	80 93 00 06 	sts	0x0600, r24	; 0x800600 <__TEXT_REGION_LENGTH__+0x700600>
     170:	80 e0       	ldi	r24, 0x00	; 0
     172:	08 95       	ret

00000174 <ADC_is_conversion_done>:
     174:	80 91 0b 06 	lds	r24, 0x060B	; 0x80060b <__TEXT_REGION_LENGTH__+0x70060b>
     178:	81 70       	andi	r24, 0x01	; 1
     17a:	08 95       	ret

0000017c <ADC_get_conversion>:
 *
 * \return Nothing
 */
void ADC_start_conversion(adc_0_channel_t channel)
{
	ADC0.MUXPOS  = channel;
     17c:	e0 e0       	ldi	r30, 0x00	; 0
     17e:	f6 e0       	ldi	r31, 0x06	; 6
     180:	86 83       	std	Z+6, r24	; 0x06
	ADC0.COMMAND = ADC_STCONV_bm;
     182:	81 e0       	ldi	r24, 0x01	; 1
     184:	80 87       	std	Z+8, r24	; 0x08
adc_result_t ADC_get_conversion(adc_0_channel_t channel)
{
	adc_result_t res;

	ADC_start_conversion(channel);
	while (!ADC_is_conversion_done())
     186:	f6 df       	rcall	.-20     	; 0x174 <ADC_is_conversion_done>
     188:	88 23       	and	r24, r24
     18a:	e9 f3       	breq	.-6      	; 0x186 <ADC_get_conversion+0xa>
 *
 * \return Conversion result read from the ADC ADC module
 */
adc_result_t ADC_get_conversion_result(void)
{
	return (ADC0.RES);
     18c:	e0 e0       	ldi	r30, 0x00	; 0
     18e:	f6 e0       	ldi	r31, 0x06	; 6
     190:	20 89       	ldd	r18, Z+16	; 0x10
     192:	31 89       	ldd	r19, Z+17	; 0x11

	ADC_start_conversion(channel);
	while (!ADC_is_conversion_done())
		;
	res = ADC_get_conversion_result();
	ADC0.INTFLAGS |= ADC_RESRDY_bm;
     194:	93 85       	ldd	r25, Z+11	; 0x0b
     196:	91 60       	ori	r25, 0x01	; 1
     198:	93 87       	std	Z+11, r25	; 0x0b
	return res;
}
     19a:	c9 01       	movw	r24, r18
     19c:	08 95       	ret

0000019e <BOD_init>:
	//		 | BOD_VLMCFG_ABOVE_gc; /* Interrupt when supply goes above VLM level */

	// BOD.VLMCTRLA = BOD_VLMLVL_5ABOVE_gc; /* VLM threshold 5% above BOD level */

	return 0;
}
     19e:	80 e0       	ldi	r24, 0x00	; 0
     1a0:	08 95       	ret

000001a2 <DIGGSIGG_init>:
	//		 | CCL_EDGEDET_DIS_gc /* Edge detector is disabled */
	//		 | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	//		 | 0 << CCL_ENABLE_bp /* LUT Enable: disabled */
	//		 | 0 << CCL_OUTEN_bp; /* Output Enable: disabled */

	CCL.TRUTH1 = 168; /* Truth 1: 168 */
     1a2:	e0 ec       	ldi	r30, 0xC0	; 192
     1a4:	f1 e0       	ldi	r31, 0x01	; 1
     1a6:	88 ea       	ldi	r24, 0xA8	; 168
     1a8:	84 87       	std	Z+12, r24	; 0x0c

	CCL.LUT1CTRLC = CCL_INSEL2_TCA0_gc /* TCA0 WO2 input source */;
     1aa:	88 e0       	ldi	r24, 0x08	; 8
     1ac:	83 87       	std	Z+11, r24	; 0x0b

	CCL.LUT1CTRLB = CCL_INSEL0_SPI0_gc /* SPI0 SCK source */
     1ae:	8b eb       	ldi	r24, 0xBB	; 187
     1b0:	82 87       	std	Z+10, r24	; 0x0a
	                | CCL_INSEL1_SPI0_gc /* SPI0 MOSI input source */;

	CCL.LUT1CTRLA = 0 << CCL_CLKSRC_bp       /* Clock Source Selection: disabled */
     1b2:	89 e0       	ldi	r24, 0x09	; 9
     1b4:	81 87       	std	Z+9, r24	; 0x09
	                | CCL_EDGEDET_DIS_gc     /* Edge detector is disabled */
	                | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	                | 1 << CCL_ENABLE_bp     /* LUT Enable: enabled */
	                | 1 << CCL_OUTEN_bp;     /* Output Enable: enabled */

	CCL.CTRLA = 1 << CCL_ENABLE_bp      /* Enable: enabled */
     1b6:	81 e4       	ldi	r24, 0x41	; 65
     1b8:	80 83       	st	Z, r24
	            | 1 << CCL_RUNSTDBY_bp; /* Run in Standby: enabled */

	return 0;
}
     1ba:	80 e0       	ldi	r24, 0x00	; 0
     1bc:	08 95       	ret

000001be <CLKCTRL_init>:
 *       on calling convention. The memory model is not visible to the
 *       preprocessor, so it must be defined in the Assembler preprocessor directives.
 */
static inline void ccp_write_io(void *addr, uint8_t value)
{
	protected_write_io(addr, CCP_IOREG_gc, value);
     1be:	47 e0       	ldi	r20, 0x07	; 7
     1c0:	68 ed       	ldi	r22, 0xD8	; 216
     1c2:	8c e7       	ldi	r24, 0x7C	; 124
     1c4:	90 e0       	ldi	r25, 0x00	; 0
     1c6:	ad d0       	rcall	.+346    	; 0x322 <protected_write_io>
     1c8:	41 e0       	ldi	r20, 0x01	; 1
     1ca:	68 ed       	ldi	r22, 0xD8	; 216
     1cc:	81 e6       	ldi	r24, 0x61	; 97
     1ce:	90 e0       	ldi	r25, 0x00	; 0
     1d0:	a8 d0       	rcall	.+336    	; 0x322 <protected_write_io>
	//		 | 0 << CLKCTRL_CLKOUT_bp /* System clock out: disabled */);

	// ccp_write_io((void*)&(CLKCTRL.MCLKLOCK),0 << CLKCTRL_LOCKEN_bp /* lock enable: disabled */);

	return 0;
}
     1d2:	80 e0       	ldi	r24, 0x00	; 0
     1d4:	08 95       	ret

000001d6 <CPUINT_init>:

	// CPUINT.LVL0PRI = 0x0 << CPUINT_LVL0PRI_gp; /* Interrupt Level Priority: 0x0 */

	// CPUINT.LVL1VEC = 0x0 << CPUINT_LVL1VEC_gp; /* Interrupt Vector with High Priority: 0x0 */

	ENABLE_INTERRUPTS();
     1d6:	78 94       	sei

	return 0;
}
     1d8:	80 e0       	ldi	r24, 0x00	; 0
     1da:	08 95       	ret

000001dc <DAC_init>:
 *
 * \return Nothing
 */
void DAC_disable()
{
	DAC0.CTRLA &= ~DAC_ENABLE_bm;
     1dc:	81 e4       	ldi	r24, 0x41	; 65
     1de:	80 93 80 06 	sts	0x0680, r24	; 0x800680 <__TEXT_REGION_LENGTH__+0x700680>
     1e2:	80 e0       	ldi	r24, 0x00	; 0
     1e4:	08 95       	ret

000001e6 <DAC_set_output>:
 *
 * \return Nothing
 */
void DAC_set_output(dac_resolution_t value)
{
	DAC0.DATA = value;
     1e6:	80 93 81 06 	sts	0x0681, r24	; 0x800681 <__TEXT_REGION_LENGTH__+0x700681>
     1ea:	08 95       	ret

000001ec <mcu_init>:
#ifdef __cplusplus
extern "C" {
#endif

void mcu_init(void)
{
     1ec:	e0 e1       	ldi	r30, 0x10	; 16
     1ee:	f4 e0       	ldi	r31, 0x04	; 4
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     1f0:	80 81       	ld	r24, Z
     1f2:	88 60       	ori	r24, 0x08	; 8
     1f4:	81 93       	st	Z+, r24
	 * disables all peripherals to save power. Driver shall enable
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
     1f6:	e8 31       	cpi	r30, 0x18	; 24
     1f8:	84 e0       	ldi	r24, 0x04	; 4
     1fa:	f8 07       	cpc	r31, r24
     1fc:	c9 f7       	brne	.-14     	; 0x1f0 <mcu_init+0x4>
     1fe:	e0 e3       	ldi	r30, 0x30	; 48
     200:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     202:	80 81       	ld	r24, Z
     204:	88 60       	ori	r24, 0x08	; 8
     206:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     208:	e8 33       	cpi	r30, 0x38	; 56
     20a:	84 e0       	ldi	r24, 0x04	; 4
     20c:	f8 07       	cpc	r31, r24
     20e:	c9 f7       	brne	.-14     	; 0x202 <mcu_init+0x16>
     210:	e0 e5       	ldi	r30, 0x50	; 80
     212:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     214:	80 81       	ld	r24, Z
     216:	88 60       	ori	r24, 0x08	; 8
     218:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     21a:	e8 35       	cpi	r30, 0x58	; 88
     21c:	84 e0       	ldi	r24, 0x04	; 4
     21e:	f8 07       	cpc	r31, r24
     220:	c9 f7       	brne	.-14     	; 0x214 <mcu_init+0x28>
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}
}
     222:	08 95       	ret

00000224 <ADC_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     224:	e5 e1       	ldi	r30, 0x15	; 21
     226:	f4 e0       	ldi	r31, 0x04	; 4
     228:	80 81       	ld	r24, Z
     22a:	88 7f       	andi	r24, 0xF8	; 248
     22c:	84 60       	ori	r24, 0x04	; 4
     22e:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     230:	80 81       	ld	r24, Z
     232:	87 7f       	andi	r24, 0xF7	; 247
     234:	80 83       	st	Z, r24
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     236:	e7 e1       	ldi	r30, 0x17	; 23
     238:	f4 e0       	ldi	r31, 0x04	; 4
     23a:	80 81       	ld	r24, Z
     23c:	88 7f       	andi	r24, 0xF8	; 248
     23e:	84 60       	ori	r24, 0x04	; 4
     240:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     242:	80 81       	ld	r24, Z
     244:	87 7f       	andi	r24, 0xF7	; 247
     246:	80 83       	st	Z, r24
 */
static inline void PORTB_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     248:	e4 e3       	ldi	r30, 0x34	; 52
     24a:	f4 e0       	ldi	r31, 0x04	; 4
     24c:	80 81       	ld	r24, Z
     24e:	88 7f       	andi	r24, 0xF8	; 248
     250:	84 60       	ori	r24, 0x04	; 4
     252:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     254:	80 81       	ld	r24, Z
     256:	87 7f       	andi	r24, 0xF7	; 247
     258:	80 83       	st	Z, r24
 */
static inline void PORTB_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     25a:	e1 e3       	ldi	r30, 0x31	; 49
     25c:	f4 e0       	ldi	r31, 0x04	; 4
     25e:	80 81       	ld	r24, Z
     260:	88 7f       	andi	r24, 0xF8	; 248
     262:	84 60       	ori	r24, 0x04	; 4
     264:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     266:	80 81       	ld	r24, Z
     268:	87 7f       	andi	r24, 0xF7	; 247
     26a:	80 83       	st	Z, r24
 */
static inline void PORTB_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     26c:	e0 e3       	ldi	r30, 0x30	; 48
     26e:	f4 e0       	ldi	r31, 0x04	; 4
     270:	80 81       	ld	r24, Z
     272:	88 7f       	andi	r24, 0xF8	; 248
     274:	84 60       	ori	r24, 0x04	; 4
     276:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     278:	80 81       	ld	r24, Z
     27a:	87 7f       	andi	r24, 0xF7	; 247
     27c:	80 83       	st	Z, r24
	// Disable digital input buffer
	DEN4_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	DEN4_PIN_set_pull_mode(PORT_PULL_OFF);

	ADC_init();
     27e:	75 df       	rcall	.-278    	; 0x16a <ADC_init>
     280:	08 95       	ret

00000282 <USART_0_initialization>:
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     282:	23 98       	cbi	0x04, 3	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     284:	e3 e3       	ldi	r30, 0x33	; 51
     286:	f4 e0       	ldi	r31, 0x04	; 4
     288:	80 81       	ld	r24, Z
     28a:	87 7f       	andi	r24, 0xF7	; 247
     28c:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     28e:	22 9a       	sbi	0x04, 2	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     290:	2a 98       	cbi	0x05, 2	; 5
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	USART_0_init();
     292:	7f d0       	rcall	.+254    	; 0x392 <USART_0_init>
     294:	08 95       	ret

00000296 <TIMER_0_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     296:	25 9a       	sbi	0x04, 5	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     298:	2d 98       	cbi	0x05, 5	; 5
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLC |= PORTMUX_TCA02_bm;
     29a:	e0 e0       	ldi	r30, 0x00	; 0
     29c:	f2 e0       	ldi	r31, 0x02	; 2
     29e:	82 81       	ldd	r24, Z+2	; 0x02
     2a0:	84 60       	ori	r24, 0x04	; 4
     2a2:	82 83       	std	Z+2, r24	; 0x02

	TIMER_0_init();
     2a4:	66 d0       	rcall	.+204    	; 0x372 <TIMER_0_init>
     2a6:	08 95       	ret

000002a8 <DIGGSIGG_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTC.DIR |= (1 << pin);
     2a8:	41 9a       	sbi	0x08, 1	; 8
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
	} else {
		VPORTC.OUT &= ~(1 << pin);
     2aa:	49 98       	cbi	0x09, 1	; 9
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLA |= PORTMUX_LUT1_bm;
     2ac:	e0 e0       	ldi	r30, 0x00	; 0
     2ae:	f2 e0       	ldi	r31, 0x02	; 2
     2b0:	80 81       	ld	r24, Z
     2b2:	80 62       	ori	r24, 0x20	; 32
     2b4:	80 83       	st	Z, r24

	DIGGSIGG_init();
     2b6:	75 df       	rcall	.-278    	; 0x1a2 <DIGGSIGG_init>
     2b8:	08 95       	ret

000002ba <SPI_0_initialization>:
 */
static inline void PORTA_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
     2ba:	02 98       	cbi	0x00, 2	; 0
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2bc:	e2 e1       	ldi	r30, 0x12	; 18
     2be:	f4 e0       	ldi	r31, 0x04	; 4
     2c0:	80 81       	ld	r24, Z
     2c2:	87 7f       	andi	r24, 0xF7	; 247
     2c4:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     2c6:	01 9a       	sbi	0x00, 1	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     2c8:	09 98       	cbi	0x01, 1	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     2ca:	03 9a       	sbi	0x00, 3	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     2cc:	0b 98       	cbi	0x01, 3	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     2ce:	04 9a       	sbi	0x00, 4	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     2d0:	0c 98       	cbi	0x01, 4	; 1
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	SPI_0_init();
     2d2:	47 d0       	rcall	.+142    	; 0x362 <SPI_0_init>
     2d4:	08 95       	ret

000002d6 <DAC_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     2d6:	e6 e1       	ldi	r30, 0x16	; 22
     2d8:	f4 e0       	ldi	r31, 0x04	; 4
     2da:	80 81       	ld	r24, Z
     2dc:	88 7f       	andi	r24, 0xF8	; 248
     2de:	84 60       	ori	r24, 0x04	; 4
     2e0:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2e2:	80 81       	ld	r24, Z
     2e4:	87 7f       	andi	r24, 0xF7	; 247
     2e6:	80 83       	st	Z, r24
	// Disable digital input buffer
	AXON_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	AXON_PIN_set_pull_mode(PORT_PULL_OFF);

	DAC_init();
     2e8:	79 df       	rcall	.-270    	; 0x1dc <DAC_init>
     2ea:	08 95       	ret

000002ec <system_init>:
/**
 * \brief System initialization
 */
void system_init()
{
	mcu_init();
     2ec:	7f df       	rcall	.-258    	; 0x1ec <mcu_init>
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     2ee:	27 98       	cbi	0x04, 7	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2f0:	e7 e3       	ldi	r30, 0x37	; 55
     2f2:	f4 e0       	ldi	r31, 0x04	; 4
     2f4:	80 81       	ld	r24, Z
     2f6:	87 7f       	andi	r24, 0xF7	; 247
     2f8:	80 83       	st	Z, r24
 */
static inline void PORTC_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
     2fa:	42 98       	cbi	0x08, 2	; 8
static inline void PORTC_set_pin_pull_mode(const uint8_t pin, const enum port_pull_mode pull_mode)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
     2fc:	e2 e5       	ldi	r30, 0x52	; 82
     2fe:	f4 e0       	ldi	r31, 0x04	; 4
     300:	80 81       	ld	r24, Z
     302:	88 60       	ori	r24, 0x08	; 8
     304:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTC.DIR |= (1 << pin);
     306:	45 9a       	sbi	0x08, 5	; 8
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     308:	4d 9a       	sbi	0x09, 5	; 9
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    true);

	CLKCTRL_init();
     30a:	59 df       	rcall	.-334    	; 0x1be <CLKCTRL_init>

	RTC_init();
     30c:	0e d0       	rcall	.+28     	; 0x32a <RTC_init>

	ADC_initialization();
     30e:	8a df       	rcall	.-236    	; 0x224 <ADC_initialization>

	USART_0_initialization();
     310:	b8 df       	rcall	.-144    	; 0x282 <USART_0_initialization>

	TIMER_0_initialization();
     312:	c1 df       	rcall	.-126    	; 0x296 <TIMER_0_initialization>

	DIGGSIGG_initialization();
     314:	c9 df       	rcall	.-110    	; 0x2a8 <DIGGSIGG_initialization>

	SPI_0_initialization();
     316:	d1 df       	rcall	.-94     	; 0x2ba <SPI_0_initialization>

	DAC_initialization();
     318:	de df       	rcall	.-68     	; 0x2d6 <DAC_initialization>

	CPUINT_init();
     31a:	5d df       	rcall	.-326    	; 0x1d6 <CPUINT_init>

	SLPCTRL_init();
     31c:	20 d0       	rcall	.+64     	; 0x35e <SLPCTRL_init>

	BOD_init();
     31e:	3f df       	rcall	.-386    	; 0x19e <BOD_init>
     320:	08 95       	ret

00000322 <protected_write_io>:
#if defined(__GNUC__)
  
#ifdef RAMPZ
	out     _SFR_IO_ADDR(RAMPZ), r1         // Clear bits 23:16 of Z
#endif
	movw    r30, r24                // Load addr into Z
     322:	fc 01       	movw	r30, r24
	out     CCP, r22                // Start CCP handshake
     324:	64 bf       	out	0x34, r22	; 52
	st      Z, r20                  // Write value to I/O register
     326:	40 83       	st	Z, r20
	ret                             // Return to caller
     328:	08 95       	ret

0000032a <RTC_init>:
 * \return Initialization status.
 */
int8_t RTC_init()
{

	while (RTC.STATUS > 0) { /* Wait for all register to be synchronized */
     32a:	e0 e4       	ldi	r30, 0x40	; 64
     32c:	f1 e0       	ldi	r31, 0x01	; 1
     32e:	81 81       	ldd	r24, Z+1	; 0x01
     330:	81 11       	cpse	r24, r1
     332:	fd cf       	rjmp	.-6      	; 0x32e <RTC_init+0x4>
	}

	// RTC.CMP = 0x0; /* Compare: 0x0 */

	RTC.CNT = 0x20; /* Counter: 0x20 */
     334:	e0 e4       	ldi	r30, 0x40	; 64
     336:	f1 e0       	ldi	r31, 0x01	; 1
     338:	80 e2       	ldi	r24, 0x20	; 32
     33a:	90 e0       	ldi	r25, 0x00	; 0
     33c:	80 87       	std	Z+8, r24	; 0x08
     33e:	91 87       	std	Z+9, r25	; 0x09

	RTC.CTRLA = RTC_PRESCALER_DIV1_gc   /* 1 */
     340:	21 e8       	ldi	r18, 0x81	; 129
     342:	20 83       	st	Z, r18
	            | 1 << RTC_RTCEN_bp     /* Enable: enabled */
	            | 1 << RTC_RUNSTDBY_bp; /* Run In Standby: enabled */

	RTC.PER = 0x20 / TIMESCALE; /* Period: 0x20 */
     344:	82 87       	std	Z+10, r24	; 0x0a
     346:	93 87       	std	Z+11, r25	; 0x0b

	// RTC.CLKSEL = RTC_CLKSEL_INT32K_gc; /* 32KHz Internal Ultra Low Power Oscillator (OSCULP32K) */

	RTC.DBGCTRL = 1 << RTC_DBGRUN_bp; /* Run in debug: enabled */
     348:	81 e0       	ldi	r24, 0x01	; 1
     34a:	85 83       	std	Z+5, r24	; 0x05

	RTC.INTCTRL = 0 << RTC_CMP_bp    /* Compare Match Interrupt enable: disabled */
     34c:	82 83       	std	Z+2, r24	; 0x02
	              | 1 << RTC_OVF_bp; /* Overflow Interrupt enable: enabled */

	while (RTC.PITSTATUS > 0) { /* Wait for all register to be synchronized */
     34e:	81 89       	ldd	r24, Z+17	; 0x11
     350:	81 11       	cpse	r24, r1
     352:	fd cf       	rjmp	.-6      	; 0x34e <RTC_init+0x24>
	}

	RTC.PITCTRLA = RTC_PERIOD_OFF_gc    /* Off */
     354:	81 e0       	ldi	r24, 0x01	; 1
     356:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <__TEXT_REGION_LENGTH__+0x700150>
	// RTC.PITDBGCTRL = 0 << RTC_DBGRUN_bp; /* Run in debug: disabled */

	// RTC.PITINTCTRL = 0 << RTC_PI_bp; /* Periodic Interrupt: disabled */

	return 0;
}
     35a:	80 e0       	ldi	r24, 0x00	; 0
     35c:	08 95       	ret

0000035e <SLPCTRL_init>:

	// SLPCTRL.CTRLA = 0 << SLPCTRL_SEN_bp /* Sleep enable: disabled */
	//		 | SLPCTRL_SMODE_IDLE_gc; /* Idle mode */

	return 0;
}
     35e:	80 e0       	ldi	r24, 0x00	; 0
     360:	08 95       	ret

00000362 <SPI_0_init>:
 * \return Initialization status
 */
int8_t SPI_0_init()
{

	SPI0.CTRLA = 0 << SPI_CLK2X_bp     /* Enable Double Speed: disabled */
     362:	e0 e2       	ldi	r30, 0x20	; 32
     364:	f8 e0       	ldi	r31, 0x08	; 8
     366:	83 e2       	ldi	r24, 0x23	; 35
     368:	80 83       	st	Z, r24
	             | 0 << SPI_DORD_bp    /* Data Order Setting: disabled */
	             | 1 << SPI_ENABLE_bp  /* Enable Module: enabled */
	             | 1 << SPI_MASTER_bp  /* SPI module in master mode */
	             | SPI_PRESC_DIV16_gc; /* System Clock / 16 */

	SPI0.CTRLB = 0 << SPI_BUFEN_bp   /* Buffer Mode Enable: disabled */
     36a:	84 e0       	ldi	r24, 0x04	; 4
     36c:	81 83       	std	Z+1, r24	; 0x01
	//		 | 0 << SPI_RXCIE_bp /* Receive Complete Interrupt Enable: disabled */
	//		 | 0 << SPI_SSIE_bp /* Slave Select Trigger Interrupt Enable: disabled */
	//		 | 0 << SPI_TXCIE_bp; /* Transfer Complete Interrupt Enable: disabled */

	return 0;
}
     36e:	80 e0       	ldi	r24, 0x00	; 0
     370:	08 95       	ret

00000372 <TIMER_0_init>:

	// TCA0.SINGLE.CMP0 = 0x0; /* Compare Register 0: 0x0 */

	// TCA0.SINGLE.CMP1 = 0x0; /* Compare Register 1: 0x0 */

	TCA0.SINGLE.CMP2 = 0x4; /* Compare Register 2: 0x4 */
     372:	e0 e0       	ldi	r30, 0x00	; 0
     374:	fa e0       	ldi	r31, 0x0A	; 10
     376:	84 e0       	ldi	r24, 0x04	; 4
     378:	90 e0       	ldi	r25, 0x00	; 0
     37a:	84 a7       	std	Z+44, r24	; 0x2c
     37c:	95 a7       	std	Z+45, r25	; 0x2d

	// TCA0.SINGLE.CNT = 0x0; /* Count: 0x0 */

	TCA0.SINGLE.CTRLB = 0 << TCA_SINGLE_ALUPD_bp            /* Auto Lock Update: disabled */
     37e:	83 e4       	ldi	r24, 0x43	; 67
     380:	81 83       	std	Z+1, r24	; 0x01
	                    | 0 << TCA_SINGLE_CMP0EN_bp         /* Compare 0 Enable: disabled */
	                    | 0 << TCA_SINGLE_CMP1EN_bp         /* Compare 1 Enable: disabled */
	                    | 1 << TCA_SINGLE_CMP2EN_bp         /* Compare 2 Enable: enabled */
	                    | TCA_SINGLE_WGMODE_SINGLESLOPE_gc; /*  */

	TCA0.SINGLE.CTRLC = 0 << TCA_SINGLE_CMP0OV_bp    /* Compare 0 Waveform Output Value: disabled */
     382:	84 e0       	ldi	r24, 0x04	; 4
     384:	82 83       	std	Z+2, r24	; 0x02
	// TCA0.SINGLE.INTCTRL = 0 << TCA_SINGLE_CMP0_bp /* Compare 0 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP1_bp /* Compare 1 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP2_bp /* Compare 2 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_OVF_bp; /* Overflow Interrupt: disabled */

	TCA0.SINGLE.PER = 0x7; /* Period: 0x7 */
     386:	87 e0       	ldi	r24, 0x07	; 7
     388:	90 e0       	ldi	r25, 0x00	; 0
     38a:	86 a3       	std	Z+38, r24	; 0x26
     38c:	97 a3       	std	Z+39, r25	; 0x27

	// TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV1_gc /* System Clock */
	//		 | 0 << TCA_SINGLE_ENABLE_bp; /* Module Enable: disabled */

	return 0;
}
     38e:	80 e0       	ldi	r24, 0x00	; 0
     390:	08 95       	ret

00000392 <USART_0_init>:
uint8_t USART_0_read()
{
	while (!(USART0.STATUS & USART_RXCIF_bm))
		;
	return USART0.RXDATAL;
}
     392:	e0 e0       	ldi	r30, 0x00	; 0
     394:	f8 e0       	ldi	r31, 0x08	; 8
     396:	87 e4       	ldi	r24, 0x47	; 71
     398:	90 e1       	ldi	r25, 0x10	; 16
     39a:	80 87       	std	Z+8, r24	; 0x08
     39c:	91 87       	std	Z+9, r25	; 0x09
     39e:	80 ec       	ldi	r24, 0xC0	; 192
     3a0:	86 83       	std	Z+6, r24	; 0x06
     3a2:	80 e0       	ldi	r24, 0x00	; 0
     3a4:	9e e3       	ldi	r25, 0x3E	; 62
     3a6:	80 93 65 3e 	sts	0x3E65, r24	; 0x803e65 <__iob+0x2>
     3aa:	90 93 66 3e 	sts	0x3E66, r25	; 0x803e66 <__iob+0x3>
     3ae:	80 e0       	ldi	r24, 0x00	; 0
     3b0:	08 95       	ret

000003b2 <USART_0_write>:
 *
 * \return Nothing
 */
void USART_0_write(const uint8_t data)
{
	while (!(USART0.STATUS & USART_DREIF_bm))
     3b2:	e0 e0       	ldi	r30, 0x00	; 0
     3b4:	f8 e0       	ldi	r31, 0x08	; 8
     3b6:	94 81       	ldd	r25, Z+4	; 0x04
     3b8:	95 ff       	sbrs	r25, 5
     3ba:	fd cf       	rjmp	.-6      	; 0x3b6 <USART_0_write+0x4>
		;
	USART0.TXDATAL = data;
     3bc:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <__TEXT_REGION_LENGTH__+0x700802>
     3c0:	08 95       	ret

000003c2 <USART_0_printCHAR>:

#if defined(__GNUC__)

int USART_0_printCHAR(char character, FILE *stream)
{
	USART_0_write(character);
     3c2:	f7 df       	rcall	.-18     	; 0x3b2 <USART_0_write>
	return 0;
}
     3c4:	80 e0       	ldi	r24, 0x00	; 0
     3c6:	90 e0       	ldi	r25, 0x00	; 0
     3c8:	08 95       	ret

000003ca <tinyCharge_is_charging>:

_Bool charging;

_Bool tinyCharge_is_charging(){
	return charging;
}
     3ca:	80 91 58 3e 	lds	r24, 0x3E58	; 0x803e58 <charging>
     3ce:	08 95       	ret

000003d0 <tinyCharge_set_charging>:

void tinyCharge_set_charging(_Bool charging_status){
	charging = charging_status;
     3d0:	80 93 58 3e 	sts	0x3E58, r24	; 0x803e58 <charging>
     3d4:	08 95       	ret

000003d6 <tinyCharge_set_transistors>:
}


void tinyCharge_set_transistors(){
	if(charging){
     3d6:	80 91 58 3e 	lds	r24, 0x3E58	; 0x803e58 <charging>
     3da:	88 23       	and	r24, r24
     3dc:	11 f0       	breq	.+4      	; 0x3e2 <tinyCharge_set_transistors+0xc>
	} else {
		VPORTC.OUT &= ~(1 << pin);
     3de:	4d 98       	cbi	0x09, 5	; 9
     3e0:	08 95       	ret
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     3e2:	4d 9a       	sbi	0x09, 5	; 9
     3e4:	08 95       	ret

000003e6 <tinyDebugger_send_int>:
	dtostrf(value,1,NUMBER_OF_DECIMALS, number);
	printf("%s:%s;", name, number);
}
void tinyDebugger_send_string(const char* name, char * value){
	printf("%s:%s;", name, value);
}
     3e6:	7f 93       	push	r23
     3e8:	6f 93       	push	r22
     3ea:	9f 93       	push	r25
     3ec:	8f 93       	push	r24
     3ee:	84 e5       	ldi	r24, 0x54	; 84
     3f0:	99 e9       	ldi	r25, 0x99	; 153
     3f2:	9f 93       	push	r25
     3f4:	8f 93       	push	r24
     3f6:	87 d5       	rcall	.+2830   	; 0xf06 <printf>
     3f8:	0f 90       	pop	r0
     3fa:	0f 90       	pop	r0
     3fc:	0f 90       	pop	r0
     3fe:	0f 90       	pop	r0
     400:	0f 90       	pop	r0
     402:	0f 90       	pop	r0
     404:	08 95       	ret

00000406 <tinyDebugger_send_uint8>:
     406:	1f 92       	push	r1
     408:	6f 93       	push	r22
     40a:	9f 93       	push	r25
     40c:	8f 93       	push	r24
     40e:	8b e5       	ldi	r24, 0x5B	; 91
     410:	99 e9       	ldi	r25, 0x99	; 153
     412:	9f 93       	push	r25
     414:	8f 93       	push	r24
     416:	77 d5       	rcall	.+2798   	; 0xf06 <printf>
     418:	0f 90       	pop	r0
     41a:	0f 90       	pop	r0
     41c:	0f 90       	pop	r0
     41e:	0f 90       	pop	r0
     420:	0f 90       	pop	r0
     422:	0f 90       	pop	r0
     424:	08 95       	ret

00000426 <tinyDebugger_send_double>:
     426:	cf 92       	push	r12
     428:	df 92       	push	r13
     42a:	ef 92       	push	r14
     42c:	ff 92       	push	r15
     42e:	0f 93       	push	r16
     430:	1f 93       	push	r17
     432:	cf 93       	push	r28
     434:	df 93       	push	r29
     436:	cd b7       	in	r28, 0x3d	; 61
     438:	de b7       	in	r29, 0x3e	; 62
     43a:	64 97       	sbiw	r28, 0x14	; 20
     43c:	cd bf       	out	0x3d, r28	; 61
     43e:	de bf       	out	0x3e, r29	; 62
     440:	d8 2e       	mov	r13, r24
     442:	c9 2e       	mov	r12, r25
     444:	cb 01       	movw	r24, r22
     446:	ba 01       	movw	r22, r20
     448:	9e 01       	movw	r18, r28
     44a:	2f 5f       	subi	r18, 0xFF	; 255
     44c:	3f 4f       	sbci	r19, 0xFF	; 255
     44e:	79 01       	movw	r14, r18
     450:	89 01       	movw	r16, r18
     452:	21 e0       	ldi	r18, 0x01	; 1
     454:	41 e0       	ldi	r20, 0x01	; 1
     456:	38 d5       	rcall	.+2672   	; 0xec8 <dtostrf>
     458:	ff 92       	push	r15
     45a:	ef 92       	push	r14
     45c:	cf 92       	push	r12
     45e:	df 92       	push	r13
     460:	82 e6       	ldi	r24, 0x62	; 98
     462:	99 e9       	ldi	r25, 0x99	; 153
     464:	9f 93       	push	r25
     466:	8f 93       	push	r24
     468:	4e d5       	rcall	.+2716   	; 0xf06 <printf>
     46a:	0f 90       	pop	r0
     46c:	0f 90       	pop	r0
     46e:	0f 90       	pop	r0
     470:	0f 90       	pop	r0
     472:	0f 90       	pop	r0
     474:	0f 90       	pop	r0
     476:	64 96       	adiw	r28, 0x14	; 20
     478:	cd bf       	out	0x3d, r28	; 61
     47a:	de bf       	out	0x3e, r29	; 62
     47c:	df 91       	pop	r29
     47e:	cf 91       	pop	r28
     480:	1f 91       	pop	r17
     482:	0f 91       	pop	r16
     484:	ff 90       	pop	r15
     486:	ef 90       	pop	r14
     488:	df 90       	pop	r13
     48a:	cf 90       	pop	r12
     48c:	08 95       	ret

0000048e <tinyDebugger_end_line>:
void tinyDebugger_end_line(){
	printf("\r\n");
     48e:	89 e6       	ldi	r24, 0x69	; 105
     490:	99 e9       	ldi	r25, 0x99	; 153
     492:	4c d5       	rcall	.+2712   	; 0xf2c <puts>
     494:	08 95       	ret

00000496 <tinyPulse_toggle_pulse_mode>:
uint32_t time_of_last_pulse = 0;
uint16_t time_since_last_pulse = 0;
uint16_t ideal_time_between_pulses = 1000/PULSEMODE_FREQUENCY;

void tinyPulse_toggle_pulse_mode(){
	pulse_mode = !pulse_mode;
     496:	90 91 1c 3e 	lds	r25, 0x3E1C	; 0x803e1c <pulse_mode>
     49a:	81 e0       	ldi	r24, 0x01	; 1
     49c:	89 27       	eor	r24, r25
     49e:	80 93 1c 3e 	sts	0x3E1C, r24	; 0x803e1c <pulse_mode>
     4a2:	08 95       	ret

000004a4 <tinyPulse_update_potential>:
}

double tinyPulse_update_potential(double potential){
     4a4:	cf 92       	push	r12
     4a6:	df 92       	push	r13
     4a8:	ef 92       	push	r14
     4aa:	ff 92       	push	r15
     4ac:	6b 01       	movw	r12, r22
     4ae:	7c 01       	movw	r14, r24
	if(pulse_mode){
     4b0:	80 91 1c 3e 	lds	r24, 0x3E1C	; 0x803e1c <pulse_mode>
     4b4:	88 23       	and	r24, r24
     4b6:	21 f1       	breq	.+72     	; 0x500 <tinyPulse_update_potential+0x5c>
		
		time_since_last_pulse = tinyTime_now() - time_of_last_pulse;
     4b8:	3e d0       	rcall	.+124    	; 0x536 <tinyTime_now>
     4ba:	20 91 18 3e 	lds	r18, 0x3E18	; 0x803e18 <time_of_last_pulse>
     4be:	30 91 19 3e 	lds	r19, 0x3E19	; 0x803e19 <time_of_last_pulse+0x1>
     4c2:	62 1b       	sub	r22, r18
     4c4:	73 0b       	sbc	r23, r19
     4c6:	60 93 16 3e 	sts	0x3E16, r22	; 0x803e16 <__data_end>
     4ca:	70 93 17 3e 	sts	0x3E17, r23	; 0x803e17 <__data_end+0x1>
		
		if(time_since_last_pulse >= ideal_time_between_pulses){
     4ce:	80 91 0e 3e 	lds	r24, 0x3E0E	; 0x803e0e <ideal_time_between_pulses>
     4d2:	90 91 0f 3e 	lds	r25, 0x3E0F	; 0x803e0f <ideal_time_between_pulses+0x1>
     4d6:	68 17       	cp	r22, r24
     4d8:	79 07       	cpc	r23, r25
     4da:	90 f0       	brcs	.+36     	; 0x500 <tinyPulse_update_potential+0x5c>
			potential += BUTTON_PRESS_REACTION;
     4dc:	20 e0       	ldi	r18, 0x00	; 0
     4de:	30 e0       	ldi	r19, 0x00	; 0
     4e0:	40 ed       	ldi	r20, 0xD0	; 208
     4e2:	51 e4       	ldi	r21, 0x41	; 65
     4e4:	c7 01       	movw	r24, r14
     4e6:	b6 01       	movw	r22, r12
     4e8:	5a d3       	rcall	.+1716   	; 0xb9e <__addsf3>
     4ea:	6b 01       	movw	r12, r22
     4ec:	7c 01       	movw	r14, r24
			time_of_last_pulse = tinyTime_now();			
     4ee:	23 d0       	rcall	.+70     	; 0x536 <tinyTime_now>
     4f0:	60 93 18 3e 	sts	0x3E18, r22	; 0x803e18 <time_of_last_pulse>
     4f4:	70 93 19 3e 	sts	0x3E19, r23	; 0x803e19 <time_of_last_pulse+0x1>
     4f8:	80 93 1a 3e 	sts	0x3E1A, r24	; 0x803e1a <time_of_last_pulse+0x2>
     4fc:	90 93 1b 3e 	sts	0x3E1B, r25	; 0x803e1b <time_of_last_pulse+0x3>
		}
	}
	return potential;
}
     500:	c7 01       	movw	r24, r14
     502:	b6 01       	movw	r22, r12
     504:	ff 90       	pop	r15
     506:	ef 90       	pop	r14
     508:	df 90       	pop	r13
     50a:	cf 90       	pop	r12
     50c:	08 95       	ret

0000050e <tinyTime_counter_increment>:
If the Interrupt Service Routine is clocked by a crystal oscillator
it gives a very precise timer-counter.
*/
void tinyTime_counter_increment(void)
{
	time_counter++;
     50e:	80 91 1d 3e 	lds	r24, 0x3E1D	; 0x803e1d <time_counter>
     512:	90 91 1e 3e 	lds	r25, 0x3E1E	; 0x803e1e <time_counter+0x1>
     516:	a0 91 1f 3e 	lds	r26, 0x3E1F	; 0x803e1f <time_counter+0x2>
     51a:	b0 91 20 3e 	lds	r27, 0x3E20	; 0x803e20 <time_counter+0x3>
     51e:	01 96       	adiw	r24, 0x01	; 1
     520:	a1 1d       	adc	r26, r1
     522:	b1 1d       	adc	r27, r1
     524:	80 93 1d 3e 	sts	0x3E1D, r24	; 0x803e1d <time_counter>
     528:	90 93 1e 3e 	sts	0x3E1E, r25	; 0x803e1e <time_counter+0x1>
     52c:	a0 93 1f 3e 	sts	0x3E1F, r26	; 0x803e1f <time_counter+0x2>
     530:	b0 93 20 3e 	sts	0x3E20, r27	; 0x803e20 <time_counter+0x3>
     534:	08 95       	ret

00000536 <tinyTime_now>:
/*
This function is callable by external libraries to give them the counted time so far.
*/
uint32_t tinyTime_now(void)
{
	return time_counter;
     536:	60 91 1d 3e 	lds	r22, 0x3E1D	; 0x803e1d <time_counter>
     53a:	70 91 1e 3e 	lds	r23, 0x3E1E	; 0x803e1e <time_counter+0x1>
     53e:	80 91 1f 3e 	lds	r24, 0x3E1F	; 0x803e1f <time_counter+0x2>
     542:	90 91 20 3e 	lds	r25, 0x3E20	; 0x803e20 <time_counter+0x3>
     546:	08 95       	ret

00000548 <main>:


int main(void)
{	
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
     548:	0e de       	rcall	.-996    	; 0x166 <atmel_start_init>
	Setting this value will mean that the ADC (Analog to Digital Converter) will read 4.32v as 255, and 0v as 0.
	For some reason, instead of the reference voltage being 4.32v, it is 3.3v. 
	A plausible explanation is that the microchip does not up the voltage, so that if the microchip is only ever 
	supplied with 3.3v, it will output 3.3v as the max.
	*/
	VREF.CTRLA = VREF_ADC0REFSEL_4V34_gc;
     54a:	80 e3       	ldi	r24, 0x30	; 48
     54c:	80 93 a0 00 	sts	0x00A0, r24	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
	while (1)
	{
		// We don't want to update the neuron too often because of various reasons. The tinyISR_getflag is set every ms, and so the loop is only run once every ms.  
		if(tinyISR_getflag())
     550:	b3 d2       	rcall	.+1382   	; 0xab8 <tinyISR_getflag>
     552:	88 23       	and	r24, r24
     554:	e9 f3       	breq	.-6      	; 0x550 <main+0x8>
		{			
			
			if(tinyCharge_is_charging()){
     556:	39 df       	rcall	.-398    	; 0x3ca <tinyCharge_is_charging>
     558:	88 23       	and	r24, r24
     55a:	31 f0       	breq	.+12     	; 0x568 <main+0x20>
				// Charge loop
				
				// We check the Dendrites in order to detect if we have stopped charging
				tinyDendrite_update_signals();
     55c:	8c d1       	rcall	.+792    	; 0x876 <tinyDendrite_update_signals>
				
				// Update LED
				tinyLED_set_color(NEURON_OUT_LED, CHARGING_COLOR);
     55e:	61 e0       	ldi	r22, 0x01	; 1
     560:	80 e0       	ldi	r24, 0x00	; 0
     562:	7c d0       	rcall	.+248    	; 0x65c <tinyLED_set_color>
				tinyLED_update();
     564:	84 d0       	rcall	.+264    	; 0x66e <tinyLED_update>
     566:	06 c0       	rjmp	.+12     	; 0x574 <main+0x2c>
				
			}
			else{
				// Main loop				
				tinyButton_update();
     568:	0e d0       	rcall	.+28     	; 0x586 <tinyButton_update>
				
				tinyPotential_update();
     56a:	a9 d2       	rcall	.+1362   	; 0xabe <tinyPotential_update>
				
				//LED update
				tinyLED_set_color(NEURON_OUT_LED, OFF);
     56c:	60 e0       	ldi	r22, 0x00	; 0
     56e:	80 e0       	ldi	r24, 0x00	; 0
     570:	75 d0       	rcall	.+234    	; 0x65c <tinyLED_set_color>
				tinyLED_update();
     572:	7d d0       	rcall	.+250    	; 0x66e <tinyLED_update>
			}
			
			
			// Switch transistors
			tinyCharge_set_transistors();
     574:	30 df       	rcall	.-416    	; 0x3d6 <tinyCharge_set_transistors>
			
			// Prepare for next cycle
			tinyISR_setflag(false);
     576:	80 e0       	ldi	r24, 0x00	; 0
     578:	9c d2       	rcall	.+1336   	; 0xab2 <tinyISR_setflag>
			tinyDebugger_send_int("time", tinyTime_now());
     57a:	dd df       	rcall	.-70     	; 0x536 <tinyTime_now>
     57c:	8b e6       	ldi	r24, 0x6B	; 107
     57e:	99 e9       	ldi	r25, 0x99	; 153
     580:	32 df       	rcall	.-412    	; 0x3e6 <tinyDebugger_send_int>
			tinyDebugger_end_line();
     582:	85 df       	rcall	.-246    	; 0x48e <tinyDebugger_end_line>
     584:	e5 cf       	rjmp	.-54     	; 0x550 <main+0x8>

00000586 <tinyButton_update>:
/*
If the button has been let go, we change button_press to true. This only lasts one cycle, before it is set to false again.
If the button is held down for longer than PULSEMODE_BUTTON_PRESS_TIME, we toggle the pulse mode state.
*/
void tinyButton_update(void)
{
     586:	0f 93       	push	r16
     588:	1f 93       	push	r17
     58a:	cf 93       	push	r28
     58c:	df 93       	push	r29
	button_press = false;
     58e:	10 92 25 3e 	sts	0x3E25, r1	; 0x803e25 <button_press>
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTC_get_pin_level(const uint8_t pin)
{
	return VPORTC.IN & (1 << pin);
     592:	8a b1       	in	r24, 0x0a	; 10
	_Bool button_is_pushed_down = !BUTTON_PIN_get_level(); // The digital port will be read as low if the button is pushed down.
     594:	d1 e0       	ldi	r29, 0x01	; 1
     596:	c8 2f       	mov	r28, r24
     598:	c4 70       	andi	r28, 0x04	; 4
     59a:	82 fd       	sbrc	r24, 2
     59c:	d0 e0       	ldi	r29, 0x00	; 0

	if (button_is_pushed_down && !button_was_pushed_down)
     59e:	c1 11       	cpse	r28, r1
     5a0:	2f c0       	rjmp	.+94     	; 0x600 <tinyButton_update+0x7a>
     5a2:	80 91 26 3e 	lds	r24, 0x3E26	; 0x803e26 <button_was_pushed_down>
     5a6:	81 11       	cpse	r24, r1
     5a8:	0d c0       	rjmp	.+26     	; 0x5c4 <tinyButton_update+0x3e>
	{
		tinyButton_start_time = tinyTime_now();
     5aa:	c5 df       	rcall	.-118    	; 0x536 <tinyTime_now>
     5ac:	60 93 21 3e 	sts	0x3E21, r22	; 0x803e21 <tinyButton_start_time>
     5b0:	70 93 22 3e 	sts	0x3E22, r23	; 0x803e22 <tinyButton_start_time+0x1>
     5b4:	80 93 23 3e 	sts	0x3E23, r24	; 0x803e23 <tinyButton_start_time+0x2>
     5b8:	90 93 24 3e 	sts	0x3E24, r25	; 0x803e24 <tinyButton_start_time+0x3>
	}
	if (button_is_pushed_down && button_was_pushed_down)
     5bc:	80 91 26 3e 	lds	r24, 0x3E26	; 0x803e26 <button_was_pushed_down>
     5c0:	88 23       	and	r24, r24
     5c2:	39 f1       	breq	.+78     	; 0x612 <tinyButton_update+0x8c>
	{
		if ((tinyTime_now() - tinyButton_start_time) > PULSEMODE_BUTTON_PRESS_TIME)
     5c4:	b8 df       	rcall	.-144    	; 0x536 <tinyTime_now>
     5c6:	00 91 21 3e 	lds	r16, 0x3E21	; 0x803e21 <tinyButton_start_time>
     5ca:	10 91 22 3e 	lds	r17, 0x3E22	; 0x803e22 <tinyButton_start_time+0x1>
     5ce:	20 91 23 3e 	lds	r18, 0x3E23	; 0x803e23 <tinyButton_start_time+0x2>
     5d2:	30 91 24 3e 	lds	r19, 0x3E24	; 0x803e24 <tinyButton_start_time+0x3>
     5d6:	dc 01       	movw	r26, r24
     5d8:	cb 01       	movw	r24, r22
     5da:	80 1b       	sub	r24, r16
     5dc:	91 0b       	sbc	r25, r17
     5de:	a2 0b       	sbc	r26, r18
     5e0:	b3 0b       	sbc	r27, r19
     5e2:	81 3d       	cpi	r24, 0xD1	; 209
     5e4:	97 40       	sbci	r25, 0x07	; 7
     5e6:	a1 05       	cpc	r26, r1
     5e8:	b1 05       	cpc	r27, r1
     5ea:	50 f0       	brcs	.+20     	; 0x600 <tinyButton_update+0x7a>
		{
			tinyPulse_toggle_pulse_mode();
     5ec:	54 df       	rcall	.-344    	; 0x496 <tinyPulse_toggle_pulse_mode>
			tinyButton_start_time = tinyTime_now();
     5ee:	a3 df       	rcall	.-186    	; 0x536 <tinyTime_now>
     5f0:	60 93 21 3e 	sts	0x3E21, r22	; 0x803e21 <tinyButton_start_time>
     5f4:	70 93 22 3e 	sts	0x3E22, r23	; 0x803e22 <tinyButton_start_time+0x1>
     5f8:	80 93 23 3e 	sts	0x3E23, r24	; 0x803e23 <tinyButton_start_time+0x2>
     5fc:	90 93 24 3e 	sts	0x3E24, r25	; 0x803e24 <tinyButton_start_time+0x3>
		}
	}
	if (!button_is_pushed_down && button_was_pushed_down)
     600:	cc 23       	and	r28, r28
     602:	39 f0       	breq	.+14     	; 0x612 <tinyButton_update+0x8c>
     604:	80 91 26 3e 	lds	r24, 0x3E26	; 0x803e26 <button_was_pushed_down>
     608:	88 23       	and	r24, r24
     60a:	19 f0       	breq	.+6      	; 0x612 <tinyButton_update+0x8c>
	{
		button_press = true;
     60c:	81 e0       	ldi	r24, 0x01	; 1
     60e:	80 93 25 3e 	sts	0x3E25, r24	; 0x803e25 <button_press>
	}
	button_was_pushed_down = button_is_pushed_down;
     612:	d0 93 26 3e 	sts	0x3E26, r29	; 0x803e26 <button_was_pushed_down>
}
     616:	df 91       	pop	r29
     618:	cf 91       	pop	r28
     61a:	1f 91       	pop	r17
     61c:	0f 91       	pop	r16
     61e:	08 95       	ret

00000620 <tinyButton_update_potential>:

double tinyButton_update_potential(double potential){
	if(button_press){
     620:	20 91 25 3e 	lds	r18, 0x3E25	; 0x803e25 <button_press>
     624:	22 23       	and	r18, r18
     626:	29 f0       	breq	.+10     	; 0x632 <tinyButton_update_potential+0x12>
		potential += BUTTON_PRESS_REACTION;
     628:	20 e0       	ldi	r18, 0x00	; 0
     62a:	30 e0       	ldi	r19, 0x00	; 0
     62c:	40 ed       	ldi	r20, 0xD0	; 208
     62e:	51 e4       	ldi	r21, 0x41	; 65
     630:	b6 d2       	rcall	.+1388   	; 0xb9e <__addsf3>
	}
	return potential;
}
     632:	08 95       	ret

00000634 <tinyLED_SPIWriteByte>:
*/
void tinyLED_set_RGB_color(uint8_t LED_id, uint8_t red, uint8_t green, uint8_t blue)
{
	tinyLED_RGB_colors[LED_id].red = red;
	tinyLED_RGB_colors[LED_id].green = green;
	tinyLED_RGB_colors[LED_id].blue = blue;
     634:	90 91 23 08 	lds	r25, 0x0823	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
     638:	90 93 23 08 	sts	0x0823, r25	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
     63c:	e0 e0       	ldi	r30, 0x00	; 0
     63e:	fa e0       	ldi	r31, 0x0A	; 10
     640:	10 a2       	std	Z+32, r1	; 0x20
     642:	11 a2       	std	Z+33, r1	; 0x21
     644:	91 e0       	ldi	r25, 0x01	; 1
     646:	90 83       	st	Z, r25
     648:	80 93 24 08 	sts	0x0824, r24	; 0x800824 <__TEXT_REGION_LENGTH__+0x700824>
     64c:	e0 e2       	ldi	r30, 0x20	; 32
     64e:	f8 e0       	ldi	r31, 0x08	; 8
     650:	83 81       	ldd	r24, Z+3	; 0x03
     652:	88 23       	and	r24, r24
     654:	ec f7       	brge	.-6      	; 0x650 <tinyLED_SPIWriteByte+0x1c>
     656:	10 92 00 0a 	sts	0x0A00, r1	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
     65a:	08 95       	ret

0000065c <tinyLED_set_color>:
     65c:	e8 2f       	mov	r30, r24
     65e:	f0 e0       	ldi	r31, 0x00	; 0
     660:	ee 0f       	add	r30, r30
     662:	ff 1f       	adc	r31, r31
     664:	e1 5a       	subi	r30, 0xA1	; 161
     666:	f1 4c       	sbci	r31, 0xC1	; 193
     668:	60 83       	st	Z, r22
     66a:	11 82       	std	Z+1, r1	; 0x01
     66c:	08 95       	ret

0000066e <tinyLED_update>:
/*
function to write the current LED-array on to the LEDs and
effectively update the values stored in the LEDs to the values stored in the MCU.
*/
void tinyLED_update(void)
{
     66e:	cf 93       	push	r28
     670:	df 93       	push	r29
	uint32_t now = tinyTime_now();
     672:	61 df       	rcall	.-318    	; 0x536 <tinyTime_now>
		
		
		
		//For some reason unknown to the writer the data-bus to the LEDs is serialized as GRB
		//which means the 24-bit data-bus will look like [Green[0:7], Red[0:7], Blue[0:7]]
		tinyLED_SPIWriteByte(tinyLED_RGB_colors[i].green);
     674:	c9 e5       	ldi	r28, 0x59	; 89
     676:	de e3       	ldi	r29, 0x3E	; 62
     678:	89 81       	ldd	r24, Y+1	; 0x01
     67a:	dc df       	rcall	.-72     	; 0x634 <tinyLED_SPIWriteByte>
		tinyLED_SPIWriteByte(tinyLED_RGB_colors[i].red);
     67c:	88 81       	ld	r24, Y
     67e:	da df       	rcall	.-76     	; 0x634 <tinyLED_SPIWriteByte>
		tinyLED_SPIWriteByte(tinyLED_RGB_colors[i].blue);
     680:	8a 81       	ldd	r24, Y+2	; 0x02
     682:	d8 df       	rcall	.-80     	; 0x634 <tinyLED_SPIWriteByte>
		
		
		
		//For some reason unknown to the writer the data-bus to the LEDs is serialized as GRB
		//which means the 24-bit data-bus will look like [Green[0:7], Red[0:7], Blue[0:7]]
		tinyLED_SPIWriteByte(tinyLED_RGB_colors[i].green);
     684:	8c 81       	ldd	r24, Y+4	; 0x04
     686:	d6 df       	rcall	.-84     	; 0x634 <tinyLED_SPIWriteByte>
		tinyLED_SPIWriteByte(tinyLED_RGB_colors[i].red);
     688:	8b 81       	ldd	r24, Y+3	; 0x03
     68a:	d4 df       	rcall	.-88     	; 0x634 <tinyLED_SPIWriteByte>
		tinyLED_SPIWriteByte(tinyLED_RGB_colors[i].blue);
     68c:	8d 81       	ldd	r24, Y+5	; 0x05
     68e:	d2 df       	rcall	.-92     	; 0x634 <tinyLED_SPIWriteByte>
	}
}
     690:	df 91       	pop	r29
     692:	cf 91       	pop	r28
     694:	08 95       	ret

00000696 <tinyAxon_add_pulse>:
{
	// We want to check each slot in the pulse_queue, and
	// if we find an empty slot (0), we add a pulse.
	for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
	{
		if(pulse_queue[i] == 0){
     696:	20 91 28 3e 	lds	r18, 0x3E28	; 0x803e28 <pulse_queue>
     69a:	30 91 29 3e 	lds	r19, 0x3E29	; 0x803e29 <pulse_queue+0x1>
     69e:	23 2b       	or	r18, r19
     6a0:	51 f0       	breq	.+20     	; 0x6b6 <tinyAxon_add_pulse+0x20>
     6a2:	ea e2       	ldi	r30, 0x2A	; 42
     6a4:	fe e3       	ldi	r31, 0x3E	; 62
     6a6:	21 e0       	ldi	r18, 0x01	; 1
     6a8:	30 e0       	ldi	r19, 0x00	; 0
     6aa:	b9 01       	movw	r22, r18
     6ac:	41 91       	ld	r20, Z+
     6ae:	51 91       	ld	r21, Z+
     6b0:	45 2b       	or	r20, r21
     6b2:	81 f4       	brne	.+32     	; 0x6d4 <tinyAxon_add_pulse+0x3e>
     6b4:	02 c0       	rjmp	.+4      	; 0x6ba <tinyAxon_add_pulse+0x24>
     6b6:	60 e0       	ldi	r22, 0x00	; 0
     6b8:	70 e0       	ldi	r23, 0x00	; 0
			pulse_queue[i] = new_pulse;
     6ba:	66 0f       	add	r22, r22
     6bc:	77 1f       	adc	r23, r23
     6be:	fb 01       	movw	r30, r22
     6c0:	e8 5d       	subi	r30, 0xD8	; 216
     6c2:	f1 4c       	sbci	r31, 0xC1	; 193
     6c4:	80 83       	st	Z, r24
     6c6:	91 83       	std	Z+1, r25	; 0x01
			pulses_in_queue++;
     6c8:	80 91 3c 3e 	lds	r24, 0x3E3C	; 0x803e3c <pulses_in_queue>
     6cc:	8f 5f       	subi	r24, 0xFF	; 255
     6ce:	80 93 3c 3e 	sts	0x3E3C, r24	; 0x803e3c <pulses_in_queue>
			// We return so we only ever add one
			break;
     6d2:	08 95       	ret
     6d4:	2f 5f       	subi	r18, 0xFF	; 255
     6d6:	3f 4f       	sbci	r19, 0xFF	; 255
*/
static void tinyAxon_add_pulse(uint16_t new_pulse)
{
	// We want to check each slot in the pulse_queue, and
	// if we find an empty slot (0), we add a pulse.
	for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
     6d8:	2a 30       	cpi	r18, 0x0A	; 10
     6da:	31 05       	cpc	r19, r1
     6dc:	31 f7       	brne	.-52     	; 0x6aa <tinyAxon_add_pulse+0x14>
     6de:	08 95       	ret

000006e0 <find_newest_pulse>:
uint8_t find_newest_pulse() {
	uint16_t max;
	uint8_t current_index = 0;
	uint8_t return_index = 0;
	
	max = pulse_queue[current_index];
     6e0:	40 91 28 3e 	lds	r20, 0x3E28	; 0x803e28 <pulse_queue>
     6e4:	50 91 29 3e 	lds	r21, 0x3E29	; 0x803e29 <pulse_queue+0x1>
     6e8:	ea e2       	ldi	r30, 0x2A	; 42
     6ea:	fe e3       	ldi	r31, 0x3E	; 62
	
// This function will be used with pulse_queue to find the newest pulse
uint8_t find_newest_pulse() {
	uint16_t max;
	uint8_t current_index = 0;
	uint8_t return_index = 0;
     6ec:	80 e0       	ldi	r24, 0x00	; 0
	
	max = pulse_queue[current_index];
	
	for (current_index = 1; current_index < MAX_NUMBER_OF_PULSES; current_index++) {
     6ee:	91 e0       	ldi	r25, 0x01	; 1
		if (pulse_queue[current_index] > max) {
     6f0:	21 91       	ld	r18, Z+
     6f2:	31 91       	ld	r19, Z+
     6f4:	42 17       	cp	r20, r18
     6f6:	53 07       	cpc	r21, r19
     6f8:	10 f4       	brcc	.+4      	; 0x6fe <find_newest_pulse+0x1e>
     6fa:	89 2f       	mov	r24, r25
			return_index = current_index;
			max = pulse_queue[current_index];
     6fc:	a9 01       	movw	r20, r18
	uint8_t current_index = 0;
	uint8_t return_index = 0;
	
	max = pulse_queue[current_index];
	
	for (current_index = 1; current_index < MAX_NUMBER_OF_PULSES; current_index++) {
     6fe:	9f 5f       	subi	r25, 0xFF	; 255
     700:	9a 30       	cpi	r25, 0x0A	; 10
     702:	b1 f7       	brne	.-20     	; 0x6f0 <find_newest_pulse+0x10>
			return_index = current_index;
			max = pulse_queue[current_index];
		}
	}
	return return_index;
}
     704:	08 95       	ret

00000706 <tinyAxon_remove_pulse>:

/*
If the potential is very low, we want to try to remove a pulse.
*/
bool tinyAxon_remove_pulse(void)
{
     706:	cf 93       	push	r28
	// We want to return a bool indicating whether or not a pulse actually was removed.
	if(pulses_in_queue == 0){
     708:	c0 91 3c 3e 	lds	r28, 0x3E3C	; 0x803e3c <pulses_in_queue>
     70c:	cc 23       	and	r28, r28
     70e:	81 f0       	breq	.+32     	; 0x730 <tinyAxon_remove_pulse+0x2a>
		//There was no pulse to remove.
		return false;
	}
	else{
		// If we are to remove a pulse, we want to remove the one that will fire last.
		uint16_t newest_pulse = pulse_queue[find_newest_pulse()];
     710:	e7 df       	rcall	.-50     	; 0x6e0 <find_newest_pulse>
     712:	e8 2f       	mov	r30, r24
     714:	f0 e0       	ldi	r31, 0x00	; 0
     716:	ee 0f       	add	r30, r30
     718:	ff 1f       	adc	r31, r31
     71a:	e8 5d       	subi	r30, 0xD8	; 216
     71c:	f1 4c       	sbci	r31, 0xC1	; 193
	
		// Now we want to check if the pulse is too far away to be affected by the low potential, or close enough that we decide to remove it.
		// (When we say that the pulse is too far away, it refers to the biological process of how the potential spreads from Dendrites to axon).
		if(newest_pulse > PULSE_NO_RETURN_TIME){
     71e:	80 81       	ld	r24, Z
     720:	91 81       	ldd	r25, Z+1	; 0x01
     722:	cd 97       	sbiw	r24, 0x3d	; 61
     724:	38 f0       	brcs	.+14     	; 0x734 <tinyAxon_remove_pulse+0x2e>
			// We decided to remove the pulse
			pulses_in_queue--;
     726:	c1 50       	subi	r28, 0x01	; 1
     728:	c0 93 3c 3e 	sts	0x3E3C, r28	; 0x803e3c <pulses_in_queue>
			return true;
     72c:	81 e0       	ldi	r24, 0x01	; 1
     72e:	03 c0       	rjmp	.+6      	; 0x736 <tinyAxon_remove_pulse+0x30>
bool tinyAxon_remove_pulse(void)
{
	// We want to return a bool indicating whether or not a pulse actually was removed.
	if(pulses_in_queue == 0){
		//There was no pulse to remove.
		return false;
     730:	80 e0       	ldi	r24, 0x00	; 0
     732:	01 c0       	rjmp	.+2      	; 0x736 <tinyAxon_remove_pulse+0x30>
			pulses_in_queue--;
			return true;
		}
		// Here we have found that there is a pulse queued, but it is old enough to let pass anyway, so now we need to put it back into the queue.
		else{
			return false;
     734:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     736:	cf 91       	pop	r28
     738:	08 95       	ret

0000073a <tinyAxon_update_potential>:
/*
Decides whether or not the axon should fire
If the axon does fire, the potential is reduced
*/
double tinyAxon_update_potential(double potential)
{	
     73a:	cf 92       	push	r12
     73c:	df 92       	push	r13
     73e:	ef 92       	push	r14
     740:	ff 92       	push	r15
     742:	6b 01       	movw	r12, r22
     744:	7c 01       	movw	r14, r24
	//While the neuron has enough potential to fire, we want to fire more
	while (potential > THRESHOLD_POTENTIAL)
     746:	20 e0       	ldi	r18, 0x00	; 0
     748:	30 e0       	ldi	r19, 0x00	; 0
     74a:	48 ec       	ldi	r20, 0xC8	; 200
     74c:	51 e4       	ldi	r21, 0x41	; 65
     74e:	4a d3       	rcall	.+1684   	; 0xde4 <__gesf2>
     750:	18 16       	cp	r1, r24
     752:	54 f5       	brge	.+84     	; 0x7a8 <tinyAxon_update_potential+0x6e>
	{
		// We have to check if there are already queued pulses, so that the frequency never exceeds FIRE_DELAY
		if(pulses_in_queue>0){
     754:	80 91 3c 3e 	lds	r24, 0x3E3C	; 0x803e3c <pulses_in_queue>
     758:	88 23       	and	r24, r24
     75a:	99 f0       	breq	.+38     	; 0x782 <tinyAxon_update_potential+0x48>
			uint16_t newest_pulse = pulse_queue[find_newest_pulse()];
     75c:	c1 df       	rcall	.-126    	; 0x6e0 <find_newest_pulse>
     75e:	e8 2f       	mov	r30, r24
     760:	f0 e0       	ldi	r31, 0x00	; 0
     762:	ee 0f       	add	r30, r30
     764:	ff 1f       	adc	r31, r31
     766:	e8 5d       	subi	r30, 0xD8	; 216
     768:	f1 4c       	sbci	r31, 0xC1	; 193
			
			// There is at least one pulse in the queue, and it is so close, that we need to offset the new pulse, so that we keep at least
			// one FIRE_DELAY between each pulse
			if(newest_pulse + FIRE_DELAY > TRAVLE_DELAY+FIRE_DELAY){
     76a:	80 81       	ld	r24, Z
     76c:	91 81       	ldd	r25, Z+1	; 0x01
     76e:	c2 96       	adiw	r24, 0x32	; 50
     770:	87 39       	cpi	r24, 0x97	; 151
     772:	91 05       	cpc	r25, r1
     774:	10 f0       	brcs	.+4      	; 0x77a <tinyAxon_update_potential+0x40>
				tinyAxon_add_pulse(newest_pulse + FIRE_DELAY);
     776:	8f df       	rcall	.-226    	; 0x696 <tinyAxon_add_pulse>
     778:	07 c0       	rjmp	.+14     	; 0x788 <tinyAxon_update_potential+0x4e>
			}
			// There is at least one pulse in the queue, but it's far enough away to ignore
			else{
				tinyAxon_add_pulse(TRAVLE_DELAY + FIRE_DELAY);
     77a:	86 e9       	ldi	r24, 0x96	; 150
     77c:	90 e0       	ldi	r25, 0x00	; 0
     77e:	8b df       	rcall	.-234    	; 0x696 <tinyAxon_add_pulse>
     780:	03 c0       	rjmp	.+6      	; 0x788 <tinyAxon_update_potential+0x4e>
			}
		}
		// There are no pulses in the queue, so we add a pulse as normal
		else{
			tinyAxon_add_pulse(TRAVLE_DELAY + FIRE_DELAY);		
     782:	86 e9       	ldi	r24, 0x96	; 150
     784:	90 e0       	ldi	r25, 0x00	; 0
     786:	87 df       	rcall	.-242    	; 0x696 <tinyAxon_add_pulse>
		}
		
		potential += POSTFIRE_POTENTIAL_REACTION; // This is usually defined as a negative value, don't be confused by the +=
     788:	20 e0       	ldi	r18, 0x00	; 0
     78a:	30 e0       	ldi	r19, 0x00	; 0
     78c:	40 ef       	ldi	r20, 0xF0	; 240
     78e:	51 e4       	ldi	r21, 0x41	; 65
     790:	c7 01       	movw	r24, r14
     792:	b6 01       	movw	r22, r12
     794:	03 d2       	rcall	.+1030   	; 0xb9c <__subsf3>
     796:	6b 01       	movw	r12, r22
     798:	7c 01       	movw	r14, r24
If the axon does fire, the potential is reduced
*/
double tinyAxon_update_potential(double potential)
{	
	//While the neuron has enough potential to fire, we want to fire more
	while (potential > THRESHOLD_POTENTIAL)
     79a:	20 e0       	ldi	r18, 0x00	; 0
     79c:	30 e0       	ldi	r19, 0x00	; 0
     79e:	48 ec       	ldi	r20, 0xC8	; 200
     7a0:	51 e4       	ldi	r21, 0x41	; 65
     7a2:	20 d3       	rcall	.+1600   	; 0xde4 <__gesf2>
     7a4:	18 16       	cp	r1, r24
     7a6:	b4 f2       	brlt	.-84     	; 0x754 <tinyAxon_update_potential+0x1a>
		
		potential += POSTFIRE_POTENTIAL_REACTION; // This is usually defined as a negative value, don't be confused by the +=
	}
	
	// If the neuron has a very low potential, we want to remove a pulse from the queue (if there is one)
	if(potential < -THRESHOLD_POTENTIAL && pulses_in_queue > 0) // Perhaps this should be a separate variable? For now, we will just simply use -THRESHOLD_POTENTIAL
     7a8:	20 e0       	ldi	r18, 0x00	; 0
     7aa:	30 e0       	ldi	r19, 0x00	; 0
     7ac:	48 ec       	ldi	r20, 0xC8	; 200
     7ae:	51 ec       	ldi	r21, 0xC1	; 193
     7b0:	c7 01       	movw	r24, r14
     7b2:	b6 01       	movw	r22, r12
     7b4:	60 d2       	rcall	.+1216   	; 0xc76 <__cmpsf2>
     7b6:	88 23       	and	r24, r24
     7b8:	0c f0       	brlt	.+2      	; 0x7bc <tinyAxon_update_potential+0x82>
     7ba:	41 c0       	rjmp	.+130    	; 0x83e <tinyAxon_update_potential+0x104>
     7bc:	80 91 3c 3e 	lds	r24, 0x3E3C	; 0x803e3c <pulses_in_queue>
     7c0:	88 23       	and	r24, r24
     7c2:	01 f1       	breq	.+64     	; 0x804 <tinyAxon_update_potential+0xca>
	{
		// The neurons potential is low enough to attempt to remove a queued fire (Fire less)
		if(tinyAxon_remove_pulse())
     7c4:	a0 df       	rcall	.-192    	; 0x706 <tinyAxon_remove_pulse>
     7c6:	88 23       	and	r24, r24
     7c8:	d1 f1       	breq	.+116    	; 0x83e <tinyAxon_update_potential+0x104>
		{
			// The potential has evened out a bit
			potential += THRESHOLD_POTENTIAL;
     7ca:	20 e0       	ldi	r18, 0x00	; 0
     7cc:	30 e0       	ldi	r19, 0x00	; 0
     7ce:	48 ec       	ldi	r20, 0xC8	; 200
     7d0:	51 e4       	ldi	r21, 0x41	; 65
     7d2:	c7 01       	movw	r24, r14
     7d4:	b6 01       	movw	r22, r12
     7d6:	e3 d1       	rcall	.+966    	; 0xb9e <__addsf3>
     7d8:	6b 01       	movw	r12, r22
     7da:	7c 01       	movw	r14, r24
     7dc:	30 c0       	rjmp	.+96     	; 0x83e <tinyAxon_update_potential+0x104>
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
	{
		for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
		{
			if(pulse_queue[i] != 0){
     7de:	80 81       	ld	r24, Z
     7e0:	91 81       	ldd	r25, Z+1	; 0x01
     7e2:	00 97       	sbiw	r24, 0x00	; 0
     7e4:	39 f0       	breq	.+14     	; 0x7f4 <tinyAxon_update_potential+0xba>
				pulse_queue[i]--;
     7e6:	01 97       	sbiw	r24, 0x01	; 1
     7e8:	80 83       	st	Z, r24
     7ea:	91 83       	std	Z+1, r25	; 0x01
				
				// If the time went from 1 to 0, we fire the axon
				if(pulse_queue[i] == 0){
     7ec:	89 2b       	or	r24, r25
     7ee:	11 f4       	brne	.+4      	; 0x7f4 <tinyAxon_update_potential+0xba>
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
	pulses_in_queue--;
     7f0:	41 50       	subi	r20, 0x01	; 1
Function to set firing.
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
     7f2:	51 e0       	ldi	r21, 0x01	; 1
     7f4:	32 96       	adiw	r30, 0x02	; 2
	}
	
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
	{
		for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
     7f6:	e2 17       	cp	r30, r18
     7f8:	f3 07       	cpc	r31, r19
     7fa:	89 f7       	brne	.-30     	; 0x7de <tinyAxon_update_potential+0xa4>
     7fc:	50 93 3d 3e 	sts	0x3E3D, r21	; 0x803e3d <tinyAxon_should_fire>
     800:	40 93 3c 3e 	sts	0x3E3C, r20	; 0x803e3c <pulses_in_queue>
The function should set the DAC to fire for two
update cycles once the pulse flag is set high.
*/
static void tinyAxon_update_pulse_transmitter(void)
{
	if (tinyAxon_should_fire)
     804:	80 91 3d 3e 	lds	r24, 0x3E3D	; 0x803e3d <tinyAxon_should_fire>
     808:	88 23       	and	r24, r24
     80a:	61 f0       	breq	.+24     	; 0x824 <tinyAxon_update_potential+0xea>
	{
		tinyAxon_should_fire = false;
     80c:	10 92 3d 3e 	sts	0x3E3D, r1	; 0x803e3d <tinyAxon_should_fire>
		tinyAxon_has_fired = true;
     810:	81 e0       	ldi	r24, 0x01	; 1
     812:	80 93 3e 3e 	sts	0x3E3E, r24	; 0x803e3e <tinyAxon_has_fired>
*/
static void tinyAxon_start_sending_pulse()
{
	if (NEURONTYPE == EXCITATORY_NEURON)
	{
		DAC_set_output(EXCITATORY_NEURON_OUTPUT);
     816:	87 ed       	ldi	r24, 0xD7	; 215
     818:	90 e0       	ldi	r25, 0x00	; 0
     81a:	e5 dc       	rcall	.-1590   	; 0x1e6 <DAC_set_output>
		axonOutputValue=EXCITATORY_NEURON_OUTPUT;
     81c:	87 ed       	ldi	r24, 0xD7	; 215
     81e:	80 93 27 3e 	sts	0x3E27, r24	; 0x803e27 <axonOutputValue>
     822:	18 c0       	rjmp	.+48     	; 0x854 <tinyAxon_update_potential+0x11a>
		tinyAxon_should_fire = false;
		tinyAxon_has_fired = true;
		
		tinyAxon_start_sending_pulse();
	}
	else if (tinyAxon_has_fired)
     824:	80 91 3e 3e 	lds	r24, 0x3E3E	; 0x803e3e <tinyAxon_has_fired>
     828:	88 23       	and	r24, r24
     82a:	19 f0       	breq	.+6      	; 0x832 <tinyAxon_update_potential+0xf8>
	{
		tinyAxon_has_fired = false;
     82c:	10 92 3e 3e 	sts	0x3E3E, r1	; 0x803e3e <tinyAxon_has_fired>
     830:	11 c0       	rjmp	.+34     	; 0x854 <tinyAxon_update_potential+0x11a>
}

static void tinyAxon_stop_sending_pulse()
{
	
	DAC_set_output(NO_SIGNAL_OUTPUT);
     832:	80 e0       	ldi	r24, 0x00	; 0
     834:	90 e0       	ldi	r25, 0x00	; 0
     836:	d7 dc       	rcall	.-1618   	; 0x1e6 <DAC_set_output>
	axonOutputValue=NO_SIGNAL_OUTPUT;
     838:	10 92 27 3e 	sts	0x3E27, r1	; 0x803e27 <axonOutputValue>
     83c:	0b c0       	rjmp	.+22     	; 0x854 <tinyAxon_update_potential+0x11a>
			potential += THRESHOLD_POTENTIAL;
		}
	}
	
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
     83e:	40 91 3c 3e 	lds	r20, 0x3E3C	; 0x803e3c <pulses_in_queue>
     842:	44 23       	and	r20, r20
     844:	f9 f2       	breq	.-66     	; 0x804 <tinyAxon_update_potential+0xca>
     846:	50 91 3d 3e 	lds	r21, 0x3E3D	; 0x803e3d <tinyAxon_should_fire>
     84a:	e8 e2       	ldi	r30, 0x28	; 40
     84c:	fe e3       	ldi	r31, 0x3E	; 62
     84e:	2c e3       	ldi	r18, 0x3C	; 60
     850:	3e e3       	ldi	r19, 0x3E	; 62
     852:	c5 cf       	rjmp	.-118    	; 0x7de <tinyAxon_update_potential+0xa4>
	}
	
	// Here we set the actual output of the DAC (Digital to Analog Converter)
	tinyAxon_update_pulse_transmitter();
	
	tinyDebugger_send_uint8("Axon", axonOutputValue);
     854:	60 91 27 3e 	lds	r22, 0x3E27	; 0x803e27 <axonOutputValue>
     858:	80 e7       	ldi	r24, 0x70	; 112
     85a:	99 e9       	ldi	r25, 0x99	; 153
     85c:	d4 dd       	rcall	.-1112   	; 0x406 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("Pulses", pulses_in_queue);
     85e:	60 91 3c 3e 	lds	r22, 0x3E3C	; 0x803e3c <pulses_in_queue>
     862:	85 e7       	ldi	r24, 0x75	; 117
     864:	99 e9       	ldi	r25, 0x99	; 153
     866:	cf dd       	rcall	.-1122   	; 0x406 <tinyDebugger_send_uint8>
	
	return potential;
}
     868:	c7 01       	movw	r24, r14
     86a:	b6 01       	movw	r22, r12
     86c:	ff 90       	pop	r15
     86e:	ef 90       	pop	r14
     870:	df 90       	pop	r13
     872:	cf 90       	pop	r12
     874:	08 95       	ret

00000876 <tinyDendrite_update_signals>:
/*
This function converts the 8 bit value from the ADC into one of the signal types defined in DendriteSignal
We also update the charging state
*/
void tinyDendrite_update_signals(void)
{
     876:	2f 92       	push	r2
     878:	3f 92       	push	r3
     87a:	4f 92       	push	r4
     87c:	5f 92       	push	r5
     87e:	6f 92       	push	r6
     880:	7f 92       	push	r7
     882:	8f 92       	push	r8
     884:	9f 92       	push	r9
     886:	af 92       	push	r10
     888:	bf 92       	push	r11
     88a:	cf 92       	push	r12
     88c:	df 92       	push	r13
     88e:	ef 92       	push	r14
     890:	ff 92       	push	r15
     892:	0f 93       	push	r16
     894:	1f 93       	push	r17
     896:	cf 93       	push	r28
     898:	df 93       	push	r29
     89a:	00 e1       	ldi	r16, 0x10	; 16
     89c:	1e e3       	ldi	r17, 0x3E	; 62
     89e:	0f 2e       	mov	r0, r31
     8a0:	f9 e4       	ldi	r31, 0x49	; 73
     8a2:	cf 2e       	mov	r12, r31
     8a4:	fe e3       	ldi	r31, 0x3E	; 62
     8a6:	df 2e       	mov	r13, r31
     8a8:	f0 2d       	mov	r31, r0
     8aa:	0f 2e       	mov	r0, r31
     8ac:	f3 e5       	ldi	r31, 0x53	; 83
     8ae:	ef 2e       	mov	r14, r31
     8b0:	fe e3       	ldi	r31, 0x3E	; 62
     8b2:	ff 2e       	mov	r15, r31
     8b4:	f0 2d       	mov	r31, r0
     8b6:	e6 01       	movw	r28, r12
*/
static void tinyDendrite_read_signals(void)
{
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_values[i] = ADC_get_conversion(Dendrite_ports[i]);
     8b8:	f8 01       	movw	r30, r16
     8ba:	81 91       	ld	r24, Z+
     8bc:	8f 01       	movw	r16, r30
     8be:	5e dc       	rcall	.-1860   	; 0x17c <ADC_get_conversion>
     8c0:	89 93       	st	Y+, r24
     8c2:	99 93       	st	Y+, r25
/*
This function reads the voltage at the Dendrite inputs with the ADC
*/
static void tinyDendrite_read_signals(void)
{
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
     8c4:	ce 15       	cp	r28, r14
     8c6:	df 05       	cpc	r29, r15
     8c8:	b9 f7       	brne	.-18     	; 0x8b8 <tinyDendrite_update_signals+0x42>
	{
		tinyDendrite_values[i] = ADC_get_conversion(Dendrite_ports[i]);
	}
	tinyDebugger_send_int("D1", tinyDendrite_values[0]);
     8ca:	c9 e4       	ldi	r28, 0x49	; 73
     8cc:	de e3       	ldi	r29, 0x3E	; 62
     8ce:	68 81       	ld	r22, Y
     8d0:	79 81       	ldd	r23, Y+1	; 0x01
     8d2:	8c e7       	ldi	r24, 0x7C	; 124
     8d4:	99 e9       	ldi	r25, 0x99	; 153
     8d6:	87 dd       	rcall	.-1266   	; 0x3e6 <tinyDebugger_send_int>
	tinyDebugger_send_int("D2", tinyDendrite_values[1]);
     8d8:	6a 81       	ldd	r22, Y+2	; 0x02
     8da:	7b 81       	ldd	r23, Y+3	; 0x03
     8dc:	8f e7       	ldi	r24, 0x7F	; 127
     8de:	99 e9       	ldi	r25, 0x99	; 153
     8e0:	82 dd       	rcall	.-1276   	; 0x3e6 <tinyDebugger_send_int>
	tinyDebugger_send_int("D3", tinyDendrite_values[2]);
     8e2:	6c 81       	ldd	r22, Y+4	; 0x04
     8e4:	7d 81       	ldd	r23, Y+5	; 0x05
     8e6:	82 e8       	ldi	r24, 0x82	; 130
     8e8:	99 e9       	ldi	r25, 0x99	; 153
     8ea:	7d dd       	rcall	.-1286   	; 0x3e6 <tinyDebugger_send_int>
	tinyDebugger_send_int("D4", tinyDendrite_values[3]);
     8ec:	6e 81       	ldd	r22, Y+6	; 0x06
     8ee:	7f 81       	ldd	r23, Y+7	; 0x07
     8f0:	85 e8       	ldi	r24, 0x85	; 133
     8f2:	99 e9       	ldi	r25, 0x99	; 153
     8f4:	78 dd       	rcall	.-1296   	; 0x3e6 <tinyDebugger_send_int>
	tinyDebugger_send_int("D5", tinyDendrite_values[4]);
     8f6:	68 85       	ldd	r22, Y+8	; 0x08
     8f8:	79 85       	ldd	r23, Y+9	; 0x09
     8fa:	88 e8       	ldi	r24, 0x88	; 136
     8fc:	99 e9       	ldi	r25, 0x99	; 153
     8fe:	73 dd       	rcall	.-1306   	; 0x3e6 <tinyDebugger_send_int>
{
	
	//Read the analog voltage values on each of the Dendrites
	tinyDendrite_read_signals();
	
	tinyCharge_set_charging(false);
     900:	80 e0       	ldi	r24, 0x00	; 0
     902:	66 dd       	rcall	.-1332   	; 0x3d0 <tinyCharge_set_charging>
     904:	c4 e4       	ldi	r28, 0x44	; 68
     906:	de e3       	ldi	r29, 0x3E	; 62
     908:	0f e3       	ldi	r16, 0x3F	; 63
     90a:	1e e3       	ldi	r17, 0x3E	; 62
     90c:	0f 2e       	mov	r0, r31
     90e:	f9 e4       	ldi	r31, 0x49	; 73
     910:	8f 2e       	mov	r8, r31
     912:	fe e3       	ldi	r31, 0x3E	; 62
     914:	9f 2e       	mov	r9, r31
     916:	f0 2d       	mov	r31, r0
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     918:	66 24       	eor	r6, r6
     91a:	63 94       	inc	r6
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     91c:	68 94       	set
     91e:	22 24       	eor	r2, r2
     920:	21 f8       	bld	r2, 1
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     922:	68 94       	set
     924:	33 24       	eor	r3, r3
     926:	32 f8       	bld	r3, 2
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     928:	0f 2e       	mov	r0, r31
     92a:	f6 e0       	ldi	r31, 0x06	; 6
     92c:	4f 2e       	mov	r4, r31
     92e:	f0 2d       	mov	r31, r0
			tinyDendrite_current_signals[i] = CHARGING;
			tinyCharge_set_charging(true);
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     930:	0f 2e       	mov	r0, r31
     932:	f5 e0       	ldi	r31, 0x05	; 5
     934:	7f 2e       	mov	r7, r31
     936:	f0 2d       	mov	r31, r0
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = CHARGING;
     938:	0f 2e       	mov	r0, r31
     93a:	f7 e0       	ldi	r31, 0x07	; 7
     93c:	5f 2e       	mov	r5, r31
     93e:	f0 2d       	mov	r31, r0
     940:	7e 01       	movw	r14, r28
     942:	58 01       	movw	r10, r16
	
	tinyCharge_set_charging(false);
	
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
     944:	88 81       	ld	r24, Y
     946:	f8 01       	movw	r30, r16
     948:	80 83       	st	Z, r24
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
     94a:	f6 01       	movw	r30, r12
     94c:	81 91       	ld	r24, Z+
     94e:	91 91       	ld	r25, Z+
     950:	6f 01       	movw	r12, r30
     952:	89 3e       	cpi	r24, 0xE9	; 233
     954:	91 05       	cpc	r25, r1
     956:	20 f0       	brcs	.+8      	; 0x960 <tinyDendrite_update_signals+0xea>
		{
			tinyDendrite_current_signals[i] = CHARGING;
     958:	58 82       	st	Y, r5
			tinyCharge_set_charging(true);
     95a:	86 2d       	mov	r24, r6
     95c:	39 dd       	rcall	.-1422   	; 0x3d0 <tinyCharge_set_charging>
     95e:	1f c0       	rjmp	.+62     	; 0x99e <tinyDendrite_update_signals+0x128>
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
     960:	88 3c       	cpi	r24, 0xC8	; 200
     962:	91 05       	cpc	r25, r1
     964:	10 f0       	brcs	.+4      	; 0x96a <tinyDendrite_update_signals+0xf4>
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     966:	78 82       	st	Y, r7
     968:	1a c0       	rjmp	.+52     	; 0x99e <tinyDendrite_update_signals+0x128>
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
     96a:	87 3a       	cpi	r24, 0xA7	; 167
     96c:	91 05       	cpc	r25, r1
     96e:	10 f0       	brcs	.+4      	; 0x974 <tinyDendrite_update_signals+0xfe>
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     970:	48 82       	st	Y, r4
     972:	15 c0       	rjmp	.+42     	; 0x99e <tinyDendrite_update_signals+0x128>
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
     974:	85 38       	cpi	r24, 0x85	; 133
     976:	91 05       	cpc	r25, r1
     978:	10 f0       	brcs	.+4      	; 0x97e <tinyDendrite_update_signals+0x108>
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     97a:	38 82       	st	Y, r3
     97c:	10 c0       	rjmp	.+32     	; 0x99e <tinyDendrite_update_signals+0x128>
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
     97e:	84 36       	cpi	r24, 0x64	; 100
     980:	91 05       	cpc	r25, r1
     982:	10 f0       	brcs	.+4      	; 0x988 <tinyDendrite_update_signals+0x112>
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     984:	28 82       	st	Y, r2
     986:	0b c0       	rjmp	.+22     	; 0x99e <tinyDendrite_update_signals+0x128>
		}
		else if (tinyDendrite_values[i] > HIGH_INHIB_THRESHOLD)
     988:	83 34       	cpi	r24, 0x43	; 67
     98a:	91 05       	cpc	r25, r1
     98c:	18 f0       	brcs	.+6      	; 0x994 <tinyDendrite_update_signals+0x11e>
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
     98e:	83 e0       	ldi	r24, 0x03	; 3
     990:	88 83       	st	Y, r24
     992:	05 c0       	rjmp	.+10     	; 0x99e <tinyDendrite_update_signals+0x128>
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
     994:	82 97       	sbiw	r24, 0x22	; 34
     996:	10 f0       	brcs	.+4      	; 0x99c <tinyDendrite_update_signals+0x126>
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     998:	68 82       	st	Y, r6
     99a:	01 c0       	rjmp	.+2      	; 0x99e <tinyDendrite_update_signals+0x128>
		}
		else
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     99c:	18 82       	st	Y, r1
     99e:	0f 5f       	subi	r16, 0xFF	; 255
     9a0:	1f 4f       	sbci	r17, 0xFF	; 255
		}
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
     9a2:	f7 01       	movw	r30, r14
     9a4:	90 81       	ld	r25, Z
     9a6:	f5 01       	movw	r30, r10
     9a8:	80 81       	ld	r24, Z
     9aa:	98 13       	cpse	r25, r24
     9ac:	02 c0       	rjmp	.+4      	; 0x9b2 <tinyDendrite_update_signals+0x13c>
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     9ae:	f7 01       	movw	r30, r14
     9b0:	10 82       	st	Z, r1
     9b2:	21 96       	adiw	r28, 0x01	; 1
	//Read the analog voltage values on each of the Dendrites
	tinyDendrite_read_signals();
	
	tinyCharge_set_charging(false);
	
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
     9b4:	c8 15       	cp	r28, r8
     9b6:	d9 05       	cpc	r29, r9
     9b8:	19 f6       	brne	.-122    	; 0x940 <tinyDendrite_update_signals+0xca>
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
		}
	}
}
     9ba:	df 91       	pop	r29
     9bc:	cf 91       	pop	r28
     9be:	1f 91       	pop	r17
     9c0:	0f 91       	pop	r16
     9c2:	ff 90       	pop	r15
     9c4:	ef 90       	pop	r14
     9c6:	df 90       	pop	r13
     9c8:	cf 90       	pop	r12
     9ca:	bf 90       	pop	r11
     9cc:	af 90       	pop	r10
     9ce:	9f 90       	pop	r9
     9d0:	8f 90       	pop	r8
     9d2:	7f 90       	pop	r7
     9d4:	6f 90       	pop	r6
     9d6:	5f 90       	pop	r5
     9d8:	4f 90       	pop	r4
     9da:	3f 90       	pop	r3
     9dc:	2f 90       	pop	r2
     9de:	08 95       	ret

000009e0 <tinyDendrite_get_potential>:
outside. It uses the previously declared functions to return the potential.
*/
int16_t tinyDendrite_get_potential()
{
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
     9e0:	4a df       	rcall	.-364    	; 0x876 <tinyDendrite_update_signals>
     9e2:	e4 e4       	ldi	r30, 0x44	; 68
     9e4:	fe e3       	ldi	r31, 0x3E	; 62
     9e6:	49 e4       	ldi	r20, 0x49	; 73
     9e8:	5e e3       	ldi	r21, 0x3E	; 62
	
	int16_t return_potential_val = 0;
     9ea:	20 e0       	ldi	r18, 0x00	; 0
     9ec:	30 e0       	ldi	r19, 0x00	; 0
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		switch(tinyDendrite_current_signals[i])
     9ee:	91 91       	ld	r25, Z+
     9f0:	93 30       	cpi	r25, 0x03	; 3
     9f2:	a1 f0       	breq	.+40     	; 0xa1c <tinyDendrite_get_potential+0x3c>
     9f4:	28 f4       	brcc	.+10     	; 0xa00 <tinyDendrite_get_potential+0x20>
     9f6:	91 30       	cpi	r25, 0x01	; 1
     9f8:	b9 f0       	breq	.+46     	; 0xa28 <tinyDendrite_get_potential+0x48>
     9fa:	92 30       	cpi	r25, 0x02	; 2
     9fc:	91 f0       	breq	.+36     	; 0xa22 <tinyDendrite_get_potential+0x42>
     9fe:	16 c0       	rjmp	.+44     	; 0xa2c <tinyDendrite_get_potential+0x4c>
     a00:	95 30       	cpi	r25, 0x05	; 5
     a02:	31 f0       	breq	.+12     	; 0xa10 <tinyDendrite_get_potential+0x30>
     a04:	40 f0       	brcs	.+16     	; 0xa16 <tinyDendrite_get_potential+0x36>
     a06:	96 30       	cpi	r25, 0x06	; 6
     a08:	89 f4       	brne	.+34     	; 0xa2c <tinyDendrite_get_potential+0x4c>
		{
			case NO_SIGNAL:
				return_potential_val += NO_SIGNAL_REACTION;
				break;
			case HIGH_EXCITE:
				return_potential_val += HIGH_EXCITE_REACTION;
     a0a:	2c 5c       	subi	r18, 0xCC	; 204
     a0c:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     a0e:	0e c0       	rjmp	.+28     	; 0xa2c <tinyDendrite_get_potential+0x4c>
			case NORMAL_EXCITE:
				return_potential_val += NORMAL_EXCITE_REACTION;
     a10:	26 5e       	subi	r18, 0xE6	; 230
     a12:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     a14:	0b c0       	rjmp	.+22     	; 0xa2c <tinyDendrite_get_potential+0x4c>
			case LOW_EXCITE:
				return_potential_val += LOW_EXCITE_REACTION;
     a16:	2c 5e       	subi	r18, 0xEC	; 236
     a18:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     a1a:	08 c0       	rjmp	.+16     	; 0xa2c <tinyDendrite_get_potential+0x4c>
			case HIGH_INHIB:
				return_potential_val += HIGH_INHIB_REACTION;
     a1c:	22 53       	subi	r18, 0x32	; 50
     a1e:	31 09       	sbc	r19, r1
				break;
     a20:	05 c0       	rjmp	.+10     	; 0xa2c <tinyDendrite_get_potential+0x4c>
			case NORMAL_INHIB:
				return_potential_val += NORMAL_INHIB_REACTION;
     a22:	2a 51       	subi	r18, 0x1A	; 26
     a24:	31 09       	sbc	r19, r1
				break;
     a26:	02 c0       	rjmp	.+4      	; 0xa2c <tinyDendrite_get_potential+0x4c>
			case LOW_INHIB:
				return_potential_val += LOW_INHIB_REACTION;
     a28:	24 51       	subi	r18, 0x14	; 20
     a2a:	31 09       	sbc	r19, r1
{
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
	
	int16_t return_potential_val = 0;
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
     a2c:	e4 17       	cp	r30, r20
     a2e:	f5 07       	cpc	r31, r21
     a30:	f1 f6       	brne	.-68     	; 0x9ee <tinyDendrite_get_potential+0xe>
			default:
				break;
		}
	}
	return return_potential_val;
}
     a32:	c9 01       	movw	r24, r18
     a34:	08 95       	ret

00000a36 <tinyDendrite_update_potential>:

double tinyDendrite_update_potential(double potential){
     a36:	cf 92       	push	r12
     a38:	df 92       	push	r13
     a3a:	ef 92       	push	r14
     a3c:	ff 92       	push	r15
     a3e:	6b 01       	movw	r12, r22
     a40:	7c 01       	movw	r14, r24
	
	int16_t potential_change = tinyDendrite_get_potential();
     a42:	ce df       	rcall	.-100    	; 0x9e0 <tinyDendrite_get_potential>
	potential += potential_change;
	return potential;
     a44:	bc 01       	movw	r22, r24
     a46:	99 0f       	add	r25, r25
     a48:	88 0b       	sbc	r24, r24
     a4a:	99 0b       	sbc	r25, r25
     a4c:	1b d1       	rcall	.+566    	; 0xc84 <__floatsisf>
     a4e:	a7 01       	movw	r20, r14
     a50:	96 01       	movw	r18, r12
     a52:	a5 d0       	rcall	.+330    	; 0xb9e <__addsf3>
     a54:	ff 90       	pop	r15
     a56:	ef 90       	pop	r14
     a58:	df 90       	pop	r13
     a5a:	cf 90       	pop	r12
     a5c:	08 95       	ret

00000a5e <__vector_6>:
This function is called every time the RTC (Real Time Clock) counter overflows.
With the current settings, it will be called every ms.
The RTC clock runs at 1kHz, and the number of cycles before overflow is set with RTC.PER = someHexValue (e.g. 0x20) in src/rtc.c
*/
ISR(RTC_CNT_vect)
{
     a5e:	1f 92       	push	r1
     a60:	0f 92       	push	r0
     a62:	0f b6       	in	r0, 0x3f	; 63
     a64:	0f 92       	push	r0
     a66:	11 24       	eor	r1, r1
     a68:	2f 93       	push	r18
     a6a:	3f 93       	push	r19
     a6c:	4f 93       	push	r20
     a6e:	5f 93       	push	r21
     a70:	6f 93       	push	r22
     a72:	7f 93       	push	r23
     a74:	8f 93       	push	r24
     a76:	9f 93       	push	r25
     a78:	af 93       	push	r26
     a7a:	bf 93       	push	r27
     a7c:	cf 93       	push	r28
     a7e:	ef 93       	push	r30
     a80:	ff 93       	push	r31
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     a82:	c1 e0       	ldi	r28, 0x01	; 1
     a84:	c0 93 53 3e 	sts	0x3E53, r28	; 0x803e53 <tinyISR_interrupt_flag>
{
	// Set flag to let main loop run a new cycle
	tinyISR_setflag(true);
	
	// Timer counter incrementation
	tinyTime_counter_increment();
     a88:	42 dd       	rcall	.-1404   	; 0x50e <tinyTime_counter_increment>

	/* Overflow interrupt flag has to be cleared manually */
	RTC.INTFLAGS = RTC_OVF_bm;
     a8a:	c0 93 43 01 	sts	0x0143, r28	; 0x800143 <__TEXT_REGION_LENGTH__+0x700143>
}
     a8e:	ff 91       	pop	r31
     a90:	ef 91       	pop	r30
     a92:	cf 91       	pop	r28
     a94:	bf 91       	pop	r27
     a96:	af 91       	pop	r26
     a98:	9f 91       	pop	r25
     a9a:	8f 91       	pop	r24
     a9c:	7f 91       	pop	r23
     a9e:	6f 91       	pop	r22
     aa0:	5f 91       	pop	r21
     aa2:	4f 91       	pop	r20
     aa4:	3f 91       	pop	r19
     aa6:	2f 91       	pop	r18
     aa8:	0f 90       	pop	r0
     aaa:	0f be       	out	0x3f, r0	; 63
     aac:	0f 90       	pop	r0
     aae:	1f 90       	pop	r1
     ab0:	18 95       	reti

00000ab2 <tinyISR_setflag>:
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     ab2:	80 93 53 3e 	sts	0x3E53, r24	; 0x803e53 <tinyISR_interrupt_flag>
     ab6:	08 95       	ret

00000ab8 <tinyISR_getflag>:
}

_Bool tinyISR_getflag(void)
{
	return tinyISR_interrupt_flag;
}
     ab8:	80 91 53 3e 	lds	r24, 0x3E53	; 0x803e53 <tinyISR_interrupt_flag>
     abc:	08 95       	ret

00000abe <tinyPotential_update>:
/*
The function which will run in the main loop.
This function will run on interrupts by the RTC module.
*/
void tinyPotential_update()
{
     abe:	cf 92       	push	r12
     ac0:	df 92       	push	r13
     ac2:	ef 92       	push	r14
     ac4:	ff 92       	push	r15
	// Previously, we kept track of time in case the microchip for some reason uses more than one ms on a cycle
	// but for simplification, we just assume that each cycle will take one ms. The consequences for a cycle taking longer
	// are negligible. 
	
	double time_since_last_update = 1;
	tinyPotential_potential *= (exp(-(time_since_last_update/TINYPOTENTIAL_TIME_CONST)));
     ac6:	28 ee       	ldi	r18, 0xE8	; 232
     ac8:	33 e7       	ldi	r19, 0x73	; 115
     aca:	4d e7       	ldi	r20, 0x7D	; 125
     acc:	5f e3       	ldi	r21, 0x3F	; 63
     ace:	60 91 54 3e 	lds	r22, 0x3E54	; 0x803e54 <tinyPotential_potential>
     ad2:	70 91 55 3e 	lds	r23, 0x3E55	; 0x803e55 <tinyPotential_potential+0x1>
     ad6:	80 91 56 3e 	lds	r24, 0x3E56	; 0x803e56 <tinyPotential_potential+0x2>
     ada:	90 91 57 3e 	lds	r25, 0x3E57	; 0x803e57 <tinyPotential_potential+0x3>
     ade:	87 d1       	rcall	.+782    	; 0xdee <__mulsf3>
     ae0:	6b 01       	movw	r12, r22
     ae2:	7c 01       	movw	r14, r24
	if(fabs(tinyPotential_potential)<0.1){
     ae4:	9f 77       	andi	r25, 0x7F	; 127
     ae6:	2d ec       	ldi	r18, 0xCD	; 205
     ae8:	3c ec       	ldi	r19, 0xCC	; 204
     aea:	4c ec       	ldi	r20, 0xCC	; 204
     aec:	5d e3       	ldi	r21, 0x3D	; 61
     aee:	c3 d0       	rcall	.+390    	; 0xc76 <__cmpsf2>
     af0:	88 23       	and	r24, r24
     af2:	4c f0       	brlt	.+18     	; 0xb06 <tinyPotential_update+0x48>
	// Previously, we kept track of time in case the microchip for some reason uses more than one ms on a cycle
	// but for simplification, we just assume that each cycle will take one ms. The consequences for a cycle taking longer
	// are negligible. 
	
	double time_since_last_update = 1;
	tinyPotential_potential *= (exp(-(time_since_last_update/TINYPOTENTIAL_TIME_CONST)));
     af4:	c0 92 54 3e 	sts	0x3E54, r12	; 0x803e54 <tinyPotential_potential>
     af8:	d0 92 55 3e 	sts	0x3E55, r13	; 0x803e55 <tinyPotential_potential+0x1>
     afc:	e0 92 56 3e 	sts	0x3E56, r14	; 0x803e56 <tinyPotential_potential+0x2>
     b00:	f0 92 57 3e 	sts	0x3E57, r15	; 0x803e57 <tinyPotential_potential+0x3>
     b04:	08 c0       	rjmp	.+16     	; 0xb16 <tinyPotential_update+0x58>
	if(fabs(tinyPotential_potential)<0.1){
		tinyPotential_potential=0;
     b06:	10 92 54 3e 	sts	0x3E54, r1	; 0x803e54 <tinyPotential_potential>
     b0a:	10 92 55 3e 	sts	0x3E55, r1	; 0x803e55 <tinyPotential_potential+0x1>
     b0e:	10 92 56 3e 	sts	0x3E56, r1	; 0x803e56 <tinyPotential_potential+0x2>
     b12:	10 92 57 3e 	sts	0x3E57, r1	; 0x803e57 <tinyPotential_potential+0x3>
void tinyPotential_update()
{
	//Some of the potential in the neuron has decayed away
	tinyPotential_decay();
	// Update potential with values from Dendrites
	tinyPotential_potential = tinyDendrite_update_potential(tinyPotential_potential);
     b16:	60 91 54 3e 	lds	r22, 0x3E54	; 0x803e54 <tinyPotential_potential>
     b1a:	70 91 55 3e 	lds	r23, 0x3E55	; 0x803e55 <tinyPotential_potential+0x1>
     b1e:	80 91 56 3e 	lds	r24, 0x3E56	; 0x803e56 <tinyPotential_potential+0x2>
     b22:	90 91 57 3e 	lds	r25, 0x3E57	; 0x803e57 <tinyPotential_potential+0x3>
     b26:	87 df       	rcall	.-242    	; 0xa36 <tinyDendrite_update_potential>
     b28:	ab 01       	movw	r20, r22
     b2a:	bc 01       	movw	r22, r24
     b2c:	40 93 54 3e 	sts	0x3E54, r20	; 0x803e54 <tinyPotential_potential>
     b30:	50 93 55 3e 	sts	0x3E55, r21	; 0x803e55 <tinyPotential_potential+0x1>
     b34:	60 93 56 3e 	sts	0x3E56, r22	; 0x803e56 <tinyPotential_potential+0x2>
     b38:	70 93 57 3e 	sts	0x3E57, r23	; 0x803e57 <tinyPotential_potential+0x3>
	tinyDebugger_send_double("DendP", tinyPotential_potential);
     b3c:	8b e8       	ldi	r24, 0x8B	; 139
     b3e:	99 e9       	ldi	r25, 0x99	; 153
     b40:	72 dc       	rcall	.-1820   	; 0x426 <tinyDebugger_send_double>
	
	// Update potential from button press
	tinyPotential_potential = tinyButton_update_potential(tinyPotential_potential);
     b42:	60 91 54 3e 	lds	r22, 0x3E54	; 0x803e54 <tinyPotential_potential>
     b46:	70 91 55 3e 	lds	r23, 0x3E55	; 0x803e55 <tinyPotential_potential+0x1>
     b4a:	80 91 56 3e 	lds	r24, 0x3E56	; 0x803e56 <tinyPotential_potential+0x2>
     b4e:	90 91 57 3e 	lds	r25, 0x3E57	; 0x803e57 <tinyPotential_potential+0x3>
     b52:	66 dd       	rcall	.-1332   	; 0x620 <tinyButton_update_potential>
     b54:	60 93 54 3e 	sts	0x3E54, r22	; 0x803e54 <tinyPotential_potential>
     b58:	70 93 55 3e 	sts	0x3E55, r23	; 0x803e55 <tinyPotential_potential+0x1>
     b5c:	80 93 56 3e 	sts	0x3E56, r24	; 0x803e56 <tinyPotential_potential+0x2>
     b60:	90 93 57 3e 	sts	0x3E57, r25	; 0x803e57 <tinyPotential_potential+0x3>
	
	// Update potential with values from spontaneous pulse.
	tinyPotential_potential = tinyPulse_update_potential(tinyPotential_potential);
     b64:	9f dc       	rcall	.-1730   	; 0x4a4 <tinyPulse_update_potential>
     b66:	60 93 54 3e 	sts	0x3E54, r22	; 0x803e54 <tinyPotential_potential>
     b6a:	70 93 55 3e 	sts	0x3E55, r23	; 0x803e55 <tinyPotential_potential+0x1>
     b6e:	80 93 56 3e 	sts	0x3E56, r24	; 0x803e56 <tinyPotential_potential+0x2>
     b72:	90 93 57 3e 	sts	0x3E57, r25	; 0x803e57 <tinyPotential_potential+0x3>
	
	// Let the axon affect the potential
	// This is also where we decide whether or not the axon should fire
	tinyPotential_potential = tinyAxon_update_potential(tinyPotential_potential);
     b76:	e1 dd       	rcall	.-1086   	; 0x73a <tinyAxon_update_potential>
     b78:	ab 01       	movw	r20, r22
     b7a:	bc 01       	movw	r22, r24
     b7c:	40 93 54 3e 	sts	0x3E54, r20	; 0x803e54 <tinyPotential_potential>
     b80:	50 93 55 3e 	sts	0x3E55, r21	; 0x803e55 <tinyPotential_potential+0x1>
     b84:	60 93 56 3e 	sts	0x3E56, r22	; 0x803e56 <tinyPotential_potential+0x2>
     b88:	70 93 57 3e 	sts	0x3E57, r23	; 0x803e57 <tinyPotential_potential+0x3>
	tinyDebugger_send_double("AxonP", tinyPotential_potential);
     b8c:	81 e9       	ldi	r24, 0x91	; 145
     b8e:	99 e9       	ldi	r25, 0x99	; 153
     b90:	4a dc       	rcall	.-1900   	; 0x426 <tinyDebugger_send_double>

	//Update the led
	//potential_to_RGB_update_LEDs(tinyPotential_potential);
}
     b92:	ff 90       	pop	r15
     b94:	ef 90       	pop	r14
     b96:	df 90       	pop	r13
     b98:	cf 90       	pop	r12
     b9a:	08 95       	ret

00000b9c <__subsf3>:
     b9c:	50 58       	subi	r21, 0x80	; 128

00000b9e <__addsf3>:
     b9e:	bb 27       	eor	r27, r27
     ba0:	aa 27       	eor	r26, r26
     ba2:	0e 94 e6 05 	call	0xbcc	; 0xbcc <__addsf3x>
     ba6:	0c 94 b8 06 	jmp	0xd70	; 0xd70 <__fp_round>
     baa:	0e 94 aa 06 	call	0xd54	; 0xd54 <__fp_pscA>
     bae:	38 f0       	brcs	.+14     	; 0xbbe <__addsf3+0x20>
     bb0:	0e 94 b1 06 	call	0xd62	; 0xd62 <__fp_pscB>
     bb4:	20 f0       	brcs	.+8      	; 0xbbe <__addsf3+0x20>
     bb6:	39 f4       	brne	.+14     	; 0xbc6 <__addsf3+0x28>
     bb8:	9f 3f       	cpi	r25, 0xFF	; 255
     bba:	19 f4       	brne	.+6      	; 0xbc2 <__addsf3+0x24>
     bbc:	26 f4       	brtc	.+8      	; 0xbc6 <__addsf3+0x28>
     bbe:	0c 94 a7 06 	jmp	0xd4e	; 0xd4e <__fp_nan>
     bc2:	0e f4       	brtc	.+2      	; 0xbc6 <__addsf3+0x28>
     bc4:	e0 95       	com	r30
     bc6:	e7 fb       	bst	r30, 7
     bc8:	0c 94 a1 06 	jmp	0xd42	; 0xd42 <__fp_inf>

00000bcc <__addsf3x>:
     bcc:	e9 2f       	mov	r30, r25
     bce:	0e 94 c9 06 	call	0xd92	; 0xd92 <__fp_split3>
     bd2:	58 f3       	brcs	.-42     	; 0xbaa <__addsf3+0xc>
     bd4:	ba 17       	cp	r27, r26
     bd6:	62 07       	cpc	r22, r18
     bd8:	73 07       	cpc	r23, r19
     bda:	84 07       	cpc	r24, r20
     bdc:	95 07       	cpc	r25, r21
     bde:	20 f0       	brcs	.+8      	; 0xbe8 <__addsf3x+0x1c>
     be0:	79 f4       	brne	.+30     	; 0xc00 <__addsf3x+0x34>
     be2:	a6 f5       	brtc	.+104    	; 0xc4c <__addsf3x+0x80>
     be4:	0c 94 eb 06 	jmp	0xdd6	; 0xdd6 <__fp_zero>
     be8:	0e f4       	brtc	.+2      	; 0xbec <__addsf3x+0x20>
     bea:	e0 95       	com	r30
     bec:	0b 2e       	mov	r0, r27
     bee:	ba 2f       	mov	r27, r26
     bf0:	a0 2d       	mov	r26, r0
     bf2:	0b 01       	movw	r0, r22
     bf4:	b9 01       	movw	r22, r18
     bf6:	90 01       	movw	r18, r0
     bf8:	0c 01       	movw	r0, r24
     bfa:	ca 01       	movw	r24, r20
     bfc:	a0 01       	movw	r20, r0
     bfe:	11 24       	eor	r1, r1
     c00:	ff 27       	eor	r31, r31
     c02:	59 1b       	sub	r21, r25
     c04:	99 f0       	breq	.+38     	; 0xc2c <__addsf3x+0x60>
     c06:	59 3f       	cpi	r21, 0xF9	; 249
     c08:	50 f4       	brcc	.+20     	; 0xc1e <__addsf3x+0x52>
     c0a:	50 3e       	cpi	r21, 0xE0	; 224
     c0c:	68 f1       	brcs	.+90     	; 0xc68 <__addsf3x+0x9c>
     c0e:	1a 16       	cp	r1, r26
     c10:	f0 40       	sbci	r31, 0x00	; 0
     c12:	a2 2f       	mov	r26, r18
     c14:	23 2f       	mov	r18, r19
     c16:	34 2f       	mov	r19, r20
     c18:	44 27       	eor	r20, r20
     c1a:	58 5f       	subi	r21, 0xF8	; 248
     c1c:	f3 cf       	rjmp	.-26     	; 0xc04 <__addsf3x+0x38>
     c1e:	46 95       	lsr	r20
     c20:	37 95       	ror	r19
     c22:	27 95       	ror	r18
     c24:	a7 95       	ror	r26
     c26:	f0 40       	sbci	r31, 0x00	; 0
     c28:	53 95       	inc	r21
     c2a:	c9 f7       	brne	.-14     	; 0xc1e <__addsf3x+0x52>
     c2c:	7e f4       	brtc	.+30     	; 0xc4c <__addsf3x+0x80>
     c2e:	1f 16       	cp	r1, r31
     c30:	ba 0b       	sbc	r27, r26
     c32:	62 0b       	sbc	r22, r18
     c34:	73 0b       	sbc	r23, r19
     c36:	84 0b       	sbc	r24, r20
     c38:	ba f0       	brmi	.+46     	; 0xc68 <__addsf3x+0x9c>
     c3a:	91 50       	subi	r25, 0x01	; 1
     c3c:	a1 f0       	breq	.+40     	; 0xc66 <__addsf3x+0x9a>
     c3e:	ff 0f       	add	r31, r31
     c40:	bb 1f       	adc	r27, r27
     c42:	66 1f       	adc	r22, r22
     c44:	77 1f       	adc	r23, r23
     c46:	88 1f       	adc	r24, r24
     c48:	c2 f7       	brpl	.-16     	; 0xc3a <__addsf3x+0x6e>
     c4a:	0e c0       	rjmp	.+28     	; 0xc68 <__addsf3x+0x9c>
     c4c:	ba 0f       	add	r27, r26
     c4e:	62 1f       	adc	r22, r18
     c50:	73 1f       	adc	r23, r19
     c52:	84 1f       	adc	r24, r20
     c54:	48 f4       	brcc	.+18     	; 0xc68 <__addsf3x+0x9c>
     c56:	87 95       	ror	r24
     c58:	77 95       	ror	r23
     c5a:	67 95       	ror	r22
     c5c:	b7 95       	ror	r27
     c5e:	f7 95       	ror	r31
     c60:	9e 3f       	cpi	r25, 0xFE	; 254
     c62:	08 f0       	brcs	.+2      	; 0xc66 <__addsf3x+0x9a>
     c64:	b0 cf       	rjmp	.-160    	; 0xbc6 <__addsf3+0x28>
     c66:	93 95       	inc	r25
     c68:	88 0f       	add	r24, r24
     c6a:	08 f0       	brcs	.+2      	; 0xc6e <__addsf3x+0xa2>
     c6c:	99 27       	eor	r25, r25
     c6e:	ee 0f       	add	r30, r30
     c70:	97 95       	ror	r25
     c72:	87 95       	ror	r24
     c74:	08 95       	ret

00000c76 <__cmpsf2>:
     c76:	0e 94 7d 06 	call	0xcfa	; 0xcfa <__fp_cmp>
     c7a:	08 f4       	brcc	.+2      	; 0xc7e <__cmpsf2+0x8>
     c7c:	81 e0       	ldi	r24, 0x01	; 1
     c7e:	08 95       	ret

00000c80 <__floatunsisf>:
     c80:	e8 94       	clt
     c82:	09 c0       	rjmp	.+18     	; 0xc96 <__floatsisf+0x12>

00000c84 <__floatsisf>:
     c84:	97 fb       	bst	r25, 7
     c86:	3e f4       	brtc	.+14     	; 0xc96 <__floatsisf+0x12>
     c88:	90 95       	com	r25
     c8a:	80 95       	com	r24
     c8c:	70 95       	com	r23
     c8e:	61 95       	neg	r22
     c90:	7f 4f       	sbci	r23, 0xFF	; 255
     c92:	8f 4f       	sbci	r24, 0xFF	; 255
     c94:	9f 4f       	sbci	r25, 0xFF	; 255
     c96:	99 23       	and	r25, r25
     c98:	a9 f0       	breq	.+42     	; 0xcc4 <__floatsisf+0x40>
     c9a:	f9 2f       	mov	r31, r25
     c9c:	96 e9       	ldi	r25, 0x96	; 150
     c9e:	bb 27       	eor	r27, r27
     ca0:	93 95       	inc	r25
     ca2:	f6 95       	lsr	r31
     ca4:	87 95       	ror	r24
     ca6:	77 95       	ror	r23
     ca8:	67 95       	ror	r22
     caa:	b7 95       	ror	r27
     cac:	f1 11       	cpse	r31, r1
     cae:	f8 cf       	rjmp	.-16     	; 0xca0 <__floatsisf+0x1c>
     cb0:	fa f4       	brpl	.+62     	; 0xcf0 <__floatsisf+0x6c>
     cb2:	bb 0f       	add	r27, r27
     cb4:	11 f4       	brne	.+4      	; 0xcba <__floatsisf+0x36>
     cb6:	60 ff       	sbrs	r22, 0
     cb8:	1b c0       	rjmp	.+54     	; 0xcf0 <__floatsisf+0x6c>
     cba:	6f 5f       	subi	r22, 0xFF	; 255
     cbc:	7f 4f       	sbci	r23, 0xFF	; 255
     cbe:	8f 4f       	sbci	r24, 0xFF	; 255
     cc0:	9f 4f       	sbci	r25, 0xFF	; 255
     cc2:	16 c0       	rjmp	.+44     	; 0xcf0 <__floatsisf+0x6c>
     cc4:	88 23       	and	r24, r24
     cc6:	11 f0       	breq	.+4      	; 0xccc <__floatsisf+0x48>
     cc8:	96 e9       	ldi	r25, 0x96	; 150
     cca:	11 c0       	rjmp	.+34     	; 0xcee <__floatsisf+0x6a>
     ccc:	77 23       	and	r23, r23
     cce:	21 f0       	breq	.+8      	; 0xcd8 <__floatsisf+0x54>
     cd0:	9e e8       	ldi	r25, 0x8E	; 142
     cd2:	87 2f       	mov	r24, r23
     cd4:	76 2f       	mov	r23, r22
     cd6:	05 c0       	rjmp	.+10     	; 0xce2 <__floatsisf+0x5e>
     cd8:	66 23       	and	r22, r22
     cda:	71 f0       	breq	.+28     	; 0xcf8 <__floatsisf+0x74>
     cdc:	96 e8       	ldi	r25, 0x86	; 134
     cde:	86 2f       	mov	r24, r22
     ce0:	70 e0       	ldi	r23, 0x00	; 0
     ce2:	60 e0       	ldi	r22, 0x00	; 0
     ce4:	2a f0       	brmi	.+10     	; 0xcf0 <__floatsisf+0x6c>
     ce6:	9a 95       	dec	r25
     ce8:	66 0f       	add	r22, r22
     cea:	77 1f       	adc	r23, r23
     cec:	88 1f       	adc	r24, r24
     cee:	da f7       	brpl	.-10     	; 0xce6 <__floatsisf+0x62>
     cf0:	88 0f       	add	r24, r24
     cf2:	96 95       	lsr	r25
     cf4:	87 95       	ror	r24
     cf6:	97 f9       	bld	r25, 7
     cf8:	08 95       	ret

00000cfa <__fp_cmp>:
     cfa:	99 0f       	add	r25, r25
     cfc:	00 08       	sbc	r0, r0
     cfe:	55 0f       	add	r21, r21
     d00:	aa 0b       	sbc	r26, r26
     d02:	e0 e8       	ldi	r30, 0x80	; 128
     d04:	fe ef       	ldi	r31, 0xFE	; 254
     d06:	16 16       	cp	r1, r22
     d08:	17 06       	cpc	r1, r23
     d0a:	e8 07       	cpc	r30, r24
     d0c:	f9 07       	cpc	r31, r25
     d0e:	c0 f0       	brcs	.+48     	; 0xd40 <__fp_cmp+0x46>
     d10:	12 16       	cp	r1, r18
     d12:	13 06       	cpc	r1, r19
     d14:	e4 07       	cpc	r30, r20
     d16:	f5 07       	cpc	r31, r21
     d18:	98 f0       	brcs	.+38     	; 0xd40 <__fp_cmp+0x46>
     d1a:	62 1b       	sub	r22, r18
     d1c:	73 0b       	sbc	r23, r19
     d1e:	84 0b       	sbc	r24, r20
     d20:	95 0b       	sbc	r25, r21
     d22:	39 f4       	brne	.+14     	; 0xd32 <__fp_cmp+0x38>
     d24:	0a 26       	eor	r0, r26
     d26:	61 f0       	breq	.+24     	; 0xd40 <__fp_cmp+0x46>
     d28:	23 2b       	or	r18, r19
     d2a:	24 2b       	or	r18, r20
     d2c:	25 2b       	or	r18, r21
     d2e:	21 f4       	brne	.+8      	; 0xd38 <__fp_cmp+0x3e>
     d30:	08 95       	ret
     d32:	0a 26       	eor	r0, r26
     d34:	09 f4       	brne	.+2      	; 0xd38 <__fp_cmp+0x3e>
     d36:	a1 40       	sbci	r26, 0x01	; 1
     d38:	a6 95       	lsr	r26
     d3a:	8f ef       	ldi	r24, 0xFF	; 255
     d3c:	81 1d       	adc	r24, r1
     d3e:	81 1d       	adc	r24, r1
     d40:	08 95       	ret

00000d42 <__fp_inf>:
     d42:	97 f9       	bld	r25, 7
     d44:	9f 67       	ori	r25, 0x7F	; 127
     d46:	80 e8       	ldi	r24, 0x80	; 128
     d48:	70 e0       	ldi	r23, 0x00	; 0
     d4a:	60 e0       	ldi	r22, 0x00	; 0
     d4c:	08 95       	ret

00000d4e <__fp_nan>:
     d4e:	9f ef       	ldi	r25, 0xFF	; 255
     d50:	80 ec       	ldi	r24, 0xC0	; 192
     d52:	08 95       	ret

00000d54 <__fp_pscA>:
     d54:	00 24       	eor	r0, r0
     d56:	0a 94       	dec	r0
     d58:	16 16       	cp	r1, r22
     d5a:	17 06       	cpc	r1, r23
     d5c:	18 06       	cpc	r1, r24
     d5e:	09 06       	cpc	r0, r25
     d60:	08 95       	ret

00000d62 <__fp_pscB>:
     d62:	00 24       	eor	r0, r0
     d64:	0a 94       	dec	r0
     d66:	12 16       	cp	r1, r18
     d68:	13 06       	cpc	r1, r19
     d6a:	14 06       	cpc	r1, r20
     d6c:	05 06       	cpc	r0, r21
     d6e:	08 95       	ret

00000d70 <__fp_round>:
     d70:	09 2e       	mov	r0, r25
     d72:	03 94       	inc	r0
     d74:	00 0c       	add	r0, r0
     d76:	11 f4       	brne	.+4      	; 0xd7c <__fp_round+0xc>
     d78:	88 23       	and	r24, r24
     d7a:	52 f0       	brmi	.+20     	; 0xd90 <__fp_round+0x20>
     d7c:	bb 0f       	add	r27, r27
     d7e:	40 f4       	brcc	.+16     	; 0xd90 <__fp_round+0x20>
     d80:	bf 2b       	or	r27, r31
     d82:	11 f4       	brne	.+4      	; 0xd88 <__fp_round+0x18>
     d84:	60 ff       	sbrs	r22, 0
     d86:	04 c0       	rjmp	.+8      	; 0xd90 <__fp_round+0x20>
     d88:	6f 5f       	subi	r22, 0xFF	; 255
     d8a:	7f 4f       	sbci	r23, 0xFF	; 255
     d8c:	8f 4f       	sbci	r24, 0xFF	; 255
     d8e:	9f 4f       	sbci	r25, 0xFF	; 255
     d90:	08 95       	ret

00000d92 <__fp_split3>:
     d92:	57 fd       	sbrc	r21, 7
     d94:	90 58       	subi	r25, 0x80	; 128
     d96:	44 0f       	add	r20, r20
     d98:	55 1f       	adc	r21, r21
     d9a:	59 f0       	breq	.+22     	; 0xdb2 <__fp_splitA+0x10>
     d9c:	5f 3f       	cpi	r21, 0xFF	; 255
     d9e:	71 f0       	breq	.+28     	; 0xdbc <__fp_splitA+0x1a>
     da0:	47 95       	ror	r20

00000da2 <__fp_splitA>:
     da2:	88 0f       	add	r24, r24
     da4:	97 fb       	bst	r25, 7
     da6:	99 1f       	adc	r25, r25
     da8:	61 f0       	breq	.+24     	; 0xdc2 <__fp_splitA+0x20>
     daa:	9f 3f       	cpi	r25, 0xFF	; 255
     dac:	79 f0       	breq	.+30     	; 0xdcc <__fp_splitA+0x2a>
     dae:	87 95       	ror	r24
     db0:	08 95       	ret
     db2:	12 16       	cp	r1, r18
     db4:	13 06       	cpc	r1, r19
     db6:	14 06       	cpc	r1, r20
     db8:	55 1f       	adc	r21, r21
     dba:	f2 cf       	rjmp	.-28     	; 0xda0 <__fp_split3+0xe>
     dbc:	46 95       	lsr	r20
     dbe:	f1 df       	rcall	.-30     	; 0xda2 <__fp_splitA>
     dc0:	08 c0       	rjmp	.+16     	; 0xdd2 <__fp_splitA+0x30>
     dc2:	16 16       	cp	r1, r22
     dc4:	17 06       	cpc	r1, r23
     dc6:	18 06       	cpc	r1, r24
     dc8:	99 1f       	adc	r25, r25
     dca:	f1 cf       	rjmp	.-30     	; 0xdae <__fp_splitA+0xc>
     dcc:	86 95       	lsr	r24
     dce:	71 05       	cpc	r23, r1
     dd0:	61 05       	cpc	r22, r1
     dd2:	08 94       	sec
     dd4:	08 95       	ret

00000dd6 <__fp_zero>:
     dd6:	e8 94       	clt

00000dd8 <__fp_szero>:
     dd8:	bb 27       	eor	r27, r27
     dda:	66 27       	eor	r22, r22
     ddc:	77 27       	eor	r23, r23
     dde:	cb 01       	movw	r24, r22
     de0:	97 f9       	bld	r25, 7
     de2:	08 95       	ret

00000de4 <__gesf2>:
     de4:	0e 94 7d 06 	call	0xcfa	; 0xcfa <__fp_cmp>
     de8:	08 f4       	brcc	.+2      	; 0xdec <__gesf2+0x8>
     dea:	8f ef       	ldi	r24, 0xFF	; 255
     dec:	08 95       	ret

00000dee <__mulsf3>:
     dee:	0e 94 0a 07 	call	0xe14	; 0xe14 <__mulsf3x>
     df2:	0c 94 b8 06 	jmp	0xd70	; 0xd70 <__fp_round>
     df6:	0e 94 aa 06 	call	0xd54	; 0xd54 <__fp_pscA>
     dfa:	38 f0       	brcs	.+14     	; 0xe0a <__mulsf3+0x1c>
     dfc:	0e 94 b1 06 	call	0xd62	; 0xd62 <__fp_pscB>
     e00:	20 f0       	brcs	.+8      	; 0xe0a <__mulsf3+0x1c>
     e02:	95 23       	and	r25, r21
     e04:	11 f0       	breq	.+4      	; 0xe0a <__mulsf3+0x1c>
     e06:	0c 94 a1 06 	jmp	0xd42	; 0xd42 <__fp_inf>
     e0a:	0c 94 a7 06 	jmp	0xd4e	; 0xd4e <__fp_nan>
     e0e:	11 24       	eor	r1, r1
     e10:	0c 94 ec 06 	jmp	0xdd8	; 0xdd8 <__fp_szero>

00000e14 <__mulsf3x>:
     e14:	0e 94 c9 06 	call	0xd92	; 0xd92 <__fp_split3>
     e18:	70 f3       	brcs	.-36     	; 0xdf6 <__mulsf3+0x8>

00000e1a <__mulsf3_pse>:
     e1a:	95 9f       	mul	r25, r21
     e1c:	c1 f3       	breq	.-16     	; 0xe0e <__mulsf3+0x20>
     e1e:	95 0f       	add	r25, r21
     e20:	50 e0       	ldi	r21, 0x00	; 0
     e22:	55 1f       	adc	r21, r21
     e24:	62 9f       	mul	r22, r18
     e26:	f0 01       	movw	r30, r0
     e28:	72 9f       	mul	r23, r18
     e2a:	bb 27       	eor	r27, r27
     e2c:	f0 0d       	add	r31, r0
     e2e:	b1 1d       	adc	r27, r1
     e30:	63 9f       	mul	r22, r19
     e32:	aa 27       	eor	r26, r26
     e34:	f0 0d       	add	r31, r0
     e36:	b1 1d       	adc	r27, r1
     e38:	aa 1f       	adc	r26, r26
     e3a:	64 9f       	mul	r22, r20
     e3c:	66 27       	eor	r22, r22
     e3e:	b0 0d       	add	r27, r0
     e40:	a1 1d       	adc	r26, r1
     e42:	66 1f       	adc	r22, r22
     e44:	82 9f       	mul	r24, r18
     e46:	22 27       	eor	r18, r18
     e48:	b0 0d       	add	r27, r0
     e4a:	a1 1d       	adc	r26, r1
     e4c:	62 1f       	adc	r22, r18
     e4e:	73 9f       	mul	r23, r19
     e50:	b0 0d       	add	r27, r0
     e52:	a1 1d       	adc	r26, r1
     e54:	62 1f       	adc	r22, r18
     e56:	83 9f       	mul	r24, r19
     e58:	a0 0d       	add	r26, r0
     e5a:	61 1d       	adc	r22, r1
     e5c:	22 1f       	adc	r18, r18
     e5e:	74 9f       	mul	r23, r20
     e60:	33 27       	eor	r19, r19
     e62:	a0 0d       	add	r26, r0
     e64:	61 1d       	adc	r22, r1
     e66:	23 1f       	adc	r18, r19
     e68:	84 9f       	mul	r24, r20
     e6a:	60 0d       	add	r22, r0
     e6c:	21 1d       	adc	r18, r1
     e6e:	82 2f       	mov	r24, r18
     e70:	76 2f       	mov	r23, r22
     e72:	6a 2f       	mov	r22, r26
     e74:	11 24       	eor	r1, r1
     e76:	9f 57       	subi	r25, 0x7F	; 127
     e78:	50 40       	sbci	r21, 0x00	; 0
     e7a:	9a f0       	brmi	.+38     	; 0xea2 <__mulsf3_pse+0x88>
     e7c:	f1 f0       	breq	.+60     	; 0xeba <__mulsf3_pse+0xa0>
     e7e:	88 23       	and	r24, r24
     e80:	4a f0       	brmi	.+18     	; 0xe94 <__mulsf3_pse+0x7a>
     e82:	ee 0f       	add	r30, r30
     e84:	ff 1f       	adc	r31, r31
     e86:	bb 1f       	adc	r27, r27
     e88:	66 1f       	adc	r22, r22
     e8a:	77 1f       	adc	r23, r23
     e8c:	88 1f       	adc	r24, r24
     e8e:	91 50       	subi	r25, 0x01	; 1
     e90:	50 40       	sbci	r21, 0x00	; 0
     e92:	a9 f7       	brne	.-22     	; 0xe7e <__mulsf3_pse+0x64>
     e94:	9e 3f       	cpi	r25, 0xFE	; 254
     e96:	51 05       	cpc	r21, r1
     e98:	80 f0       	brcs	.+32     	; 0xeba <__mulsf3_pse+0xa0>
     e9a:	0c 94 a1 06 	jmp	0xd42	; 0xd42 <__fp_inf>
     e9e:	0c 94 ec 06 	jmp	0xdd8	; 0xdd8 <__fp_szero>
     ea2:	5f 3f       	cpi	r21, 0xFF	; 255
     ea4:	e4 f3       	brlt	.-8      	; 0xe9e <__mulsf3_pse+0x84>
     ea6:	98 3e       	cpi	r25, 0xE8	; 232
     ea8:	d4 f3       	brlt	.-12     	; 0xe9e <__mulsf3_pse+0x84>
     eaa:	86 95       	lsr	r24
     eac:	77 95       	ror	r23
     eae:	67 95       	ror	r22
     eb0:	b7 95       	ror	r27
     eb2:	f7 95       	ror	r31
     eb4:	e7 95       	ror	r30
     eb6:	9f 5f       	subi	r25, 0xFF	; 255
     eb8:	c1 f7       	brne	.-16     	; 0xeaa <__mulsf3_pse+0x90>
     eba:	fe 2b       	or	r31, r30
     ebc:	88 0f       	add	r24, r24
     ebe:	91 1d       	adc	r25, r1
     ec0:	96 95       	lsr	r25
     ec2:	87 95       	ror	r24
     ec4:	97 f9       	bld	r25, 7
     ec6:	08 95       	ret

00000ec8 <dtostrf>:
     ec8:	ef 92       	push	r14
     eca:	0f 93       	push	r16
     ecc:	1f 93       	push	r17
     ece:	cf 93       	push	r28
     ed0:	df 93       	push	r29
     ed2:	e8 01       	movw	r28, r16
     ed4:	47 fd       	sbrc	r20, 7
     ed6:	02 c0       	rjmp	.+4      	; 0xedc <dtostrf+0x14>
     ed8:	34 e0       	ldi	r19, 0x04	; 4
     eda:	01 c0       	rjmp	.+2      	; 0xede <dtostrf+0x16>
     edc:	34 e1       	ldi	r19, 0x14	; 20
     ede:	04 2e       	mov	r0, r20
     ee0:	00 0c       	add	r0, r0
     ee2:	55 0b       	sbc	r21, r21
     ee4:	57 ff       	sbrs	r21, 7
     ee6:	03 c0       	rjmp	.+6      	; 0xeee <dtostrf+0x26>
     ee8:	51 95       	neg	r21
     eea:	41 95       	neg	r20
     eec:	51 09       	sbc	r21, r1
     eee:	e3 2e       	mov	r14, r19
     ef0:	02 2f       	mov	r16, r18
     ef2:	24 2f       	mov	r18, r20
     ef4:	ae 01       	movw	r20, r28
     ef6:	1c d2       	rcall	.+1080   	; 0x1330 <dtoa_prf>
     ef8:	ce 01       	movw	r24, r28
     efa:	df 91       	pop	r29
     efc:	cf 91       	pop	r28
     efe:	1f 91       	pop	r17
     f00:	0f 91       	pop	r16
     f02:	ef 90       	pop	r14
     f04:	08 95       	ret

00000f06 <printf>:
     f06:	a0 e0       	ldi	r26, 0x00	; 0
     f08:	b0 e0       	ldi	r27, 0x00	; 0
     f0a:	e8 e8       	ldi	r30, 0x88	; 136
     f0c:	f7 e0       	ldi	r31, 0x07	; 7
     f0e:	ff c4       	rjmp	.+2558   	; 0x190e <__prologue_saves__+0x20>
     f10:	ae 01       	movw	r20, r28
     f12:	4b 5f       	subi	r20, 0xFB	; 251
     f14:	5f 4f       	sbci	r21, 0xFF	; 255
     f16:	fa 01       	movw	r30, r20
     f18:	61 91       	ld	r22, Z+
     f1a:	71 91       	ld	r23, Z+
     f1c:	af 01       	movw	r20, r30
     f1e:	80 91 65 3e 	lds	r24, 0x3E65	; 0x803e65 <__iob+0x2>
     f22:	90 91 66 3e 	lds	r25, 0x3E66	; 0x803e66 <__iob+0x3>
     f26:	32 d0       	rcall	.+100    	; 0xf8c <vfprintf>
     f28:	e2 e0       	ldi	r30, 0x02	; 2
     f2a:	0a c5       	rjmp	.+2580   	; 0x1940 <__epilogue_restores__+0x20>

00000f2c <puts>:
     f2c:	0f 93       	push	r16
     f2e:	1f 93       	push	r17
     f30:	cf 93       	push	r28
     f32:	df 93       	push	r29
     f34:	e0 91 65 3e 	lds	r30, 0x3E65	; 0x803e65 <__iob+0x2>
     f38:	f0 91 66 3e 	lds	r31, 0x3E66	; 0x803e66 <__iob+0x3>
     f3c:	23 81       	ldd	r18, Z+3	; 0x03
     f3e:	21 ff       	sbrs	r18, 1
     f40:	1b c0       	rjmp	.+54     	; 0xf78 <puts+0x4c>
     f42:	8c 01       	movw	r16, r24
     f44:	d0 e0       	ldi	r29, 0x00	; 0
     f46:	c0 e0       	ldi	r28, 0x00	; 0
     f48:	f8 01       	movw	r30, r16
     f4a:	81 91       	ld	r24, Z+
     f4c:	8f 01       	movw	r16, r30
     f4e:	60 91 65 3e 	lds	r22, 0x3E65	; 0x803e65 <__iob+0x2>
     f52:	70 91 66 3e 	lds	r23, 0x3E66	; 0x803e66 <__iob+0x3>
     f56:	db 01       	movw	r26, r22
     f58:	18 96       	adiw	r26, 0x08	; 8
     f5a:	ed 91       	ld	r30, X+
     f5c:	fc 91       	ld	r31, X
     f5e:	19 97       	sbiw	r26, 0x09	; 9
     f60:	88 23       	and	r24, r24
     f62:	31 f0       	breq	.+12     	; 0xf70 <puts+0x44>
     f64:	09 95       	icall
     f66:	89 2b       	or	r24, r25
     f68:	79 f3       	breq	.-34     	; 0xf48 <puts+0x1c>
     f6a:	df ef       	ldi	r29, 0xFF	; 255
     f6c:	cf ef       	ldi	r28, 0xFF	; 255
     f6e:	ec cf       	rjmp	.-40     	; 0xf48 <puts+0x1c>
     f70:	8a e0       	ldi	r24, 0x0A	; 10
     f72:	09 95       	icall
     f74:	89 2b       	or	r24, r25
     f76:	19 f0       	breq	.+6      	; 0xf7e <puts+0x52>
     f78:	8f ef       	ldi	r24, 0xFF	; 255
     f7a:	9f ef       	ldi	r25, 0xFF	; 255
     f7c:	02 c0       	rjmp	.+4      	; 0xf82 <puts+0x56>
     f7e:	8d 2f       	mov	r24, r29
     f80:	9c 2f       	mov	r25, r28
     f82:	df 91       	pop	r29
     f84:	cf 91       	pop	r28
     f86:	1f 91       	pop	r17
     f88:	0f 91       	pop	r16
     f8a:	08 95       	ret

00000f8c <vfprintf>:
     f8c:	ab e0       	ldi	r26, 0x0B	; 11
     f8e:	b0 e0       	ldi	r27, 0x00	; 0
     f90:	eb ec       	ldi	r30, 0xCB	; 203
     f92:	f7 e0       	ldi	r31, 0x07	; 7
     f94:	ac c4       	rjmp	.+2392   	; 0x18ee <__prologue_saves__>
     f96:	6c 01       	movw	r12, r24
     f98:	7b 01       	movw	r14, r22
     f9a:	8a 01       	movw	r16, r20
     f9c:	fc 01       	movw	r30, r24
     f9e:	16 82       	std	Z+6, r1	; 0x06
     fa0:	17 82       	std	Z+7, r1	; 0x07
     fa2:	83 81       	ldd	r24, Z+3	; 0x03
     fa4:	81 ff       	sbrs	r24, 1
     fa6:	bf c1       	rjmp	.+894    	; 0x1326 <vfprintf+0x39a>
     fa8:	ce 01       	movw	r24, r28
     faa:	01 96       	adiw	r24, 0x01	; 1
     fac:	3c 01       	movw	r6, r24
     fae:	f6 01       	movw	r30, r12
     fb0:	93 81       	ldd	r25, Z+3	; 0x03
     fb2:	f7 01       	movw	r30, r14
     fb4:	93 fd       	sbrc	r25, 3
     fb6:	85 91       	lpm	r24, Z+
     fb8:	93 ff       	sbrs	r25, 3
     fba:	81 91       	ld	r24, Z+
     fbc:	7f 01       	movw	r14, r30
     fbe:	88 23       	and	r24, r24
     fc0:	09 f4       	brne	.+2      	; 0xfc4 <vfprintf+0x38>
     fc2:	ad c1       	rjmp	.+858    	; 0x131e <vfprintf+0x392>
     fc4:	85 32       	cpi	r24, 0x25	; 37
     fc6:	39 f4       	brne	.+14     	; 0xfd6 <vfprintf+0x4a>
     fc8:	93 fd       	sbrc	r25, 3
     fca:	85 91       	lpm	r24, Z+
     fcc:	93 ff       	sbrs	r25, 3
     fce:	81 91       	ld	r24, Z+
     fd0:	7f 01       	movw	r14, r30
     fd2:	85 32       	cpi	r24, 0x25	; 37
     fd4:	21 f4       	brne	.+8      	; 0xfde <vfprintf+0x52>
     fd6:	b6 01       	movw	r22, r12
     fd8:	90 e0       	ldi	r25, 0x00	; 0
     fda:	ef d3       	rcall	.+2014   	; 0x17ba <fputc>
     fdc:	e8 cf       	rjmp	.-48     	; 0xfae <vfprintf+0x22>
     fde:	91 2c       	mov	r9, r1
     fe0:	21 2c       	mov	r2, r1
     fe2:	31 2c       	mov	r3, r1
     fe4:	ff e1       	ldi	r31, 0x1F	; 31
     fe6:	f3 15       	cp	r31, r3
     fe8:	d8 f0       	brcs	.+54     	; 0x1020 <vfprintf+0x94>
     fea:	8b 32       	cpi	r24, 0x2B	; 43
     fec:	79 f0       	breq	.+30     	; 0x100c <vfprintf+0x80>
     fee:	38 f4       	brcc	.+14     	; 0xffe <vfprintf+0x72>
     ff0:	80 32       	cpi	r24, 0x20	; 32
     ff2:	79 f0       	breq	.+30     	; 0x1012 <vfprintf+0x86>
     ff4:	83 32       	cpi	r24, 0x23	; 35
     ff6:	a1 f4       	brne	.+40     	; 0x1020 <vfprintf+0x94>
     ff8:	23 2d       	mov	r18, r3
     ffa:	20 61       	ori	r18, 0x10	; 16
     ffc:	1d c0       	rjmp	.+58     	; 0x1038 <vfprintf+0xac>
     ffe:	8d 32       	cpi	r24, 0x2D	; 45
    1000:	61 f0       	breq	.+24     	; 0x101a <vfprintf+0x8e>
    1002:	80 33       	cpi	r24, 0x30	; 48
    1004:	69 f4       	brne	.+26     	; 0x1020 <vfprintf+0x94>
    1006:	23 2d       	mov	r18, r3
    1008:	21 60       	ori	r18, 0x01	; 1
    100a:	16 c0       	rjmp	.+44     	; 0x1038 <vfprintf+0xac>
    100c:	83 2d       	mov	r24, r3
    100e:	82 60       	ori	r24, 0x02	; 2
    1010:	38 2e       	mov	r3, r24
    1012:	e3 2d       	mov	r30, r3
    1014:	e4 60       	ori	r30, 0x04	; 4
    1016:	3e 2e       	mov	r3, r30
    1018:	2a c0       	rjmp	.+84     	; 0x106e <vfprintf+0xe2>
    101a:	f3 2d       	mov	r31, r3
    101c:	f8 60       	ori	r31, 0x08	; 8
    101e:	1d c0       	rjmp	.+58     	; 0x105a <vfprintf+0xce>
    1020:	37 fc       	sbrc	r3, 7
    1022:	2d c0       	rjmp	.+90     	; 0x107e <vfprintf+0xf2>
    1024:	20 ed       	ldi	r18, 0xD0	; 208
    1026:	28 0f       	add	r18, r24
    1028:	2a 30       	cpi	r18, 0x0A	; 10
    102a:	40 f0       	brcs	.+16     	; 0x103c <vfprintf+0xb0>
    102c:	8e 32       	cpi	r24, 0x2E	; 46
    102e:	b9 f4       	brne	.+46     	; 0x105e <vfprintf+0xd2>
    1030:	36 fc       	sbrc	r3, 6
    1032:	75 c1       	rjmp	.+746    	; 0x131e <vfprintf+0x392>
    1034:	23 2d       	mov	r18, r3
    1036:	20 64       	ori	r18, 0x40	; 64
    1038:	32 2e       	mov	r3, r18
    103a:	19 c0       	rjmp	.+50     	; 0x106e <vfprintf+0xe2>
    103c:	36 fe       	sbrs	r3, 6
    103e:	06 c0       	rjmp	.+12     	; 0x104c <vfprintf+0xc0>
    1040:	8a e0       	ldi	r24, 0x0A	; 10
    1042:	98 9e       	mul	r9, r24
    1044:	20 0d       	add	r18, r0
    1046:	11 24       	eor	r1, r1
    1048:	92 2e       	mov	r9, r18
    104a:	11 c0       	rjmp	.+34     	; 0x106e <vfprintf+0xe2>
    104c:	ea e0       	ldi	r30, 0x0A	; 10
    104e:	2e 9e       	mul	r2, r30
    1050:	20 0d       	add	r18, r0
    1052:	11 24       	eor	r1, r1
    1054:	22 2e       	mov	r2, r18
    1056:	f3 2d       	mov	r31, r3
    1058:	f0 62       	ori	r31, 0x20	; 32
    105a:	3f 2e       	mov	r3, r31
    105c:	08 c0       	rjmp	.+16     	; 0x106e <vfprintf+0xe2>
    105e:	8c 36       	cpi	r24, 0x6C	; 108
    1060:	21 f4       	brne	.+8      	; 0x106a <vfprintf+0xde>
    1062:	83 2d       	mov	r24, r3
    1064:	80 68       	ori	r24, 0x80	; 128
    1066:	38 2e       	mov	r3, r24
    1068:	02 c0       	rjmp	.+4      	; 0x106e <vfprintf+0xe2>
    106a:	88 36       	cpi	r24, 0x68	; 104
    106c:	41 f4       	brne	.+16     	; 0x107e <vfprintf+0xf2>
    106e:	f7 01       	movw	r30, r14
    1070:	93 fd       	sbrc	r25, 3
    1072:	85 91       	lpm	r24, Z+
    1074:	93 ff       	sbrs	r25, 3
    1076:	81 91       	ld	r24, Z+
    1078:	7f 01       	movw	r14, r30
    107a:	81 11       	cpse	r24, r1
    107c:	b3 cf       	rjmp	.-154    	; 0xfe4 <vfprintf+0x58>
    107e:	98 2f       	mov	r25, r24
    1080:	9f 7d       	andi	r25, 0xDF	; 223
    1082:	95 54       	subi	r25, 0x45	; 69
    1084:	93 30       	cpi	r25, 0x03	; 3
    1086:	28 f4       	brcc	.+10     	; 0x1092 <vfprintf+0x106>
    1088:	0c 5f       	subi	r16, 0xFC	; 252
    108a:	1f 4f       	sbci	r17, 0xFF	; 255
    108c:	9f e3       	ldi	r25, 0x3F	; 63
    108e:	99 83       	std	Y+1, r25	; 0x01
    1090:	0d c0       	rjmp	.+26     	; 0x10ac <vfprintf+0x120>
    1092:	83 36       	cpi	r24, 0x63	; 99
    1094:	31 f0       	breq	.+12     	; 0x10a2 <vfprintf+0x116>
    1096:	83 37       	cpi	r24, 0x73	; 115
    1098:	71 f0       	breq	.+28     	; 0x10b6 <vfprintf+0x12a>
    109a:	83 35       	cpi	r24, 0x53	; 83
    109c:	09 f0       	breq	.+2      	; 0x10a0 <vfprintf+0x114>
    109e:	55 c0       	rjmp	.+170    	; 0x114a <vfprintf+0x1be>
    10a0:	20 c0       	rjmp	.+64     	; 0x10e2 <vfprintf+0x156>
    10a2:	f8 01       	movw	r30, r16
    10a4:	80 81       	ld	r24, Z
    10a6:	89 83       	std	Y+1, r24	; 0x01
    10a8:	0e 5f       	subi	r16, 0xFE	; 254
    10aa:	1f 4f       	sbci	r17, 0xFF	; 255
    10ac:	88 24       	eor	r8, r8
    10ae:	83 94       	inc	r8
    10b0:	91 2c       	mov	r9, r1
    10b2:	53 01       	movw	r10, r6
    10b4:	12 c0       	rjmp	.+36     	; 0x10da <vfprintf+0x14e>
    10b6:	28 01       	movw	r4, r16
    10b8:	f2 e0       	ldi	r31, 0x02	; 2
    10ba:	4f 0e       	add	r4, r31
    10bc:	51 1c       	adc	r5, r1
    10be:	f8 01       	movw	r30, r16
    10c0:	a0 80       	ld	r10, Z
    10c2:	b1 80       	ldd	r11, Z+1	; 0x01
    10c4:	36 fe       	sbrs	r3, 6
    10c6:	03 c0       	rjmp	.+6      	; 0x10ce <vfprintf+0x142>
    10c8:	69 2d       	mov	r22, r9
    10ca:	70 e0       	ldi	r23, 0x00	; 0
    10cc:	02 c0       	rjmp	.+4      	; 0x10d2 <vfprintf+0x146>
    10ce:	6f ef       	ldi	r22, 0xFF	; 255
    10d0:	7f ef       	ldi	r23, 0xFF	; 255
    10d2:	c5 01       	movw	r24, r10
    10d4:	67 d3       	rcall	.+1742   	; 0x17a4 <strnlen>
    10d6:	4c 01       	movw	r8, r24
    10d8:	82 01       	movw	r16, r4
    10da:	f3 2d       	mov	r31, r3
    10dc:	ff 77       	andi	r31, 0x7F	; 127
    10de:	3f 2e       	mov	r3, r31
    10e0:	15 c0       	rjmp	.+42     	; 0x110c <vfprintf+0x180>
    10e2:	28 01       	movw	r4, r16
    10e4:	22 e0       	ldi	r18, 0x02	; 2
    10e6:	42 0e       	add	r4, r18
    10e8:	51 1c       	adc	r5, r1
    10ea:	f8 01       	movw	r30, r16
    10ec:	a0 80       	ld	r10, Z
    10ee:	b1 80       	ldd	r11, Z+1	; 0x01
    10f0:	36 fe       	sbrs	r3, 6
    10f2:	03 c0       	rjmp	.+6      	; 0x10fa <vfprintf+0x16e>
    10f4:	69 2d       	mov	r22, r9
    10f6:	70 e0       	ldi	r23, 0x00	; 0
    10f8:	02 c0       	rjmp	.+4      	; 0x10fe <vfprintf+0x172>
    10fa:	6f ef       	ldi	r22, 0xFF	; 255
    10fc:	7f ef       	ldi	r23, 0xFF	; 255
    10fe:	c5 01       	movw	r24, r10
    1100:	46 d3       	rcall	.+1676   	; 0x178e <strnlen_P>
    1102:	4c 01       	movw	r8, r24
    1104:	f3 2d       	mov	r31, r3
    1106:	f0 68       	ori	r31, 0x80	; 128
    1108:	3f 2e       	mov	r3, r31
    110a:	82 01       	movw	r16, r4
    110c:	33 fc       	sbrc	r3, 3
    110e:	19 c0       	rjmp	.+50     	; 0x1142 <vfprintf+0x1b6>
    1110:	82 2d       	mov	r24, r2
    1112:	90 e0       	ldi	r25, 0x00	; 0
    1114:	88 16       	cp	r8, r24
    1116:	99 06       	cpc	r9, r25
    1118:	a0 f4       	brcc	.+40     	; 0x1142 <vfprintf+0x1b6>
    111a:	b6 01       	movw	r22, r12
    111c:	80 e2       	ldi	r24, 0x20	; 32
    111e:	90 e0       	ldi	r25, 0x00	; 0
    1120:	4c d3       	rcall	.+1688   	; 0x17ba <fputc>
    1122:	2a 94       	dec	r2
    1124:	f5 cf       	rjmp	.-22     	; 0x1110 <vfprintf+0x184>
    1126:	f5 01       	movw	r30, r10
    1128:	37 fc       	sbrc	r3, 7
    112a:	85 91       	lpm	r24, Z+
    112c:	37 fe       	sbrs	r3, 7
    112e:	81 91       	ld	r24, Z+
    1130:	5f 01       	movw	r10, r30
    1132:	b6 01       	movw	r22, r12
    1134:	90 e0       	ldi	r25, 0x00	; 0
    1136:	41 d3       	rcall	.+1666   	; 0x17ba <fputc>
    1138:	21 10       	cpse	r2, r1
    113a:	2a 94       	dec	r2
    113c:	21 e0       	ldi	r18, 0x01	; 1
    113e:	82 1a       	sub	r8, r18
    1140:	91 08       	sbc	r9, r1
    1142:	81 14       	cp	r8, r1
    1144:	91 04       	cpc	r9, r1
    1146:	79 f7       	brne	.-34     	; 0x1126 <vfprintf+0x19a>
    1148:	e1 c0       	rjmp	.+450    	; 0x130c <vfprintf+0x380>
    114a:	84 36       	cpi	r24, 0x64	; 100
    114c:	11 f0       	breq	.+4      	; 0x1152 <vfprintf+0x1c6>
    114e:	89 36       	cpi	r24, 0x69	; 105
    1150:	39 f5       	brne	.+78     	; 0x11a0 <vfprintf+0x214>
    1152:	f8 01       	movw	r30, r16
    1154:	37 fe       	sbrs	r3, 7
    1156:	07 c0       	rjmp	.+14     	; 0x1166 <vfprintf+0x1da>
    1158:	60 81       	ld	r22, Z
    115a:	71 81       	ldd	r23, Z+1	; 0x01
    115c:	82 81       	ldd	r24, Z+2	; 0x02
    115e:	93 81       	ldd	r25, Z+3	; 0x03
    1160:	0c 5f       	subi	r16, 0xFC	; 252
    1162:	1f 4f       	sbci	r17, 0xFF	; 255
    1164:	08 c0       	rjmp	.+16     	; 0x1176 <vfprintf+0x1ea>
    1166:	60 81       	ld	r22, Z
    1168:	71 81       	ldd	r23, Z+1	; 0x01
    116a:	07 2e       	mov	r0, r23
    116c:	00 0c       	add	r0, r0
    116e:	88 0b       	sbc	r24, r24
    1170:	99 0b       	sbc	r25, r25
    1172:	0e 5f       	subi	r16, 0xFE	; 254
    1174:	1f 4f       	sbci	r17, 0xFF	; 255
    1176:	f3 2d       	mov	r31, r3
    1178:	ff 76       	andi	r31, 0x6F	; 111
    117a:	3f 2e       	mov	r3, r31
    117c:	97 ff       	sbrs	r25, 7
    117e:	09 c0       	rjmp	.+18     	; 0x1192 <vfprintf+0x206>
    1180:	90 95       	com	r25
    1182:	80 95       	com	r24
    1184:	70 95       	com	r23
    1186:	61 95       	neg	r22
    1188:	7f 4f       	sbci	r23, 0xFF	; 255
    118a:	8f 4f       	sbci	r24, 0xFF	; 255
    118c:	9f 4f       	sbci	r25, 0xFF	; 255
    118e:	f0 68       	ori	r31, 0x80	; 128
    1190:	3f 2e       	mov	r3, r31
    1192:	2a e0       	ldi	r18, 0x0A	; 10
    1194:	30 e0       	ldi	r19, 0x00	; 0
    1196:	a3 01       	movw	r20, r6
    1198:	4c d3       	rcall	.+1688   	; 0x1832 <__ultoa_invert>
    119a:	88 2e       	mov	r8, r24
    119c:	86 18       	sub	r8, r6
    119e:	44 c0       	rjmp	.+136    	; 0x1228 <vfprintf+0x29c>
    11a0:	85 37       	cpi	r24, 0x75	; 117
    11a2:	31 f4       	brne	.+12     	; 0x11b0 <vfprintf+0x224>
    11a4:	23 2d       	mov	r18, r3
    11a6:	2f 7e       	andi	r18, 0xEF	; 239
    11a8:	b2 2e       	mov	r11, r18
    11aa:	2a e0       	ldi	r18, 0x0A	; 10
    11ac:	30 e0       	ldi	r19, 0x00	; 0
    11ae:	25 c0       	rjmp	.+74     	; 0x11fa <vfprintf+0x26e>
    11b0:	93 2d       	mov	r25, r3
    11b2:	99 7f       	andi	r25, 0xF9	; 249
    11b4:	b9 2e       	mov	r11, r25
    11b6:	8f 36       	cpi	r24, 0x6F	; 111
    11b8:	c1 f0       	breq	.+48     	; 0x11ea <vfprintf+0x25e>
    11ba:	18 f4       	brcc	.+6      	; 0x11c2 <vfprintf+0x236>
    11bc:	88 35       	cpi	r24, 0x58	; 88
    11be:	79 f0       	breq	.+30     	; 0x11de <vfprintf+0x252>
    11c0:	ae c0       	rjmp	.+348    	; 0x131e <vfprintf+0x392>
    11c2:	80 37       	cpi	r24, 0x70	; 112
    11c4:	19 f0       	breq	.+6      	; 0x11cc <vfprintf+0x240>
    11c6:	88 37       	cpi	r24, 0x78	; 120
    11c8:	21 f0       	breq	.+8      	; 0x11d2 <vfprintf+0x246>
    11ca:	a9 c0       	rjmp	.+338    	; 0x131e <vfprintf+0x392>
    11cc:	e9 2f       	mov	r30, r25
    11ce:	e0 61       	ori	r30, 0x10	; 16
    11d0:	be 2e       	mov	r11, r30
    11d2:	b4 fe       	sbrs	r11, 4
    11d4:	0d c0       	rjmp	.+26     	; 0x11f0 <vfprintf+0x264>
    11d6:	fb 2d       	mov	r31, r11
    11d8:	f4 60       	ori	r31, 0x04	; 4
    11da:	bf 2e       	mov	r11, r31
    11dc:	09 c0       	rjmp	.+18     	; 0x11f0 <vfprintf+0x264>
    11de:	34 fe       	sbrs	r3, 4
    11e0:	0a c0       	rjmp	.+20     	; 0x11f6 <vfprintf+0x26a>
    11e2:	29 2f       	mov	r18, r25
    11e4:	26 60       	ori	r18, 0x06	; 6
    11e6:	b2 2e       	mov	r11, r18
    11e8:	06 c0       	rjmp	.+12     	; 0x11f6 <vfprintf+0x26a>
    11ea:	28 e0       	ldi	r18, 0x08	; 8
    11ec:	30 e0       	ldi	r19, 0x00	; 0
    11ee:	05 c0       	rjmp	.+10     	; 0x11fa <vfprintf+0x26e>
    11f0:	20 e1       	ldi	r18, 0x10	; 16
    11f2:	30 e0       	ldi	r19, 0x00	; 0
    11f4:	02 c0       	rjmp	.+4      	; 0x11fa <vfprintf+0x26e>
    11f6:	20 e1       	ldi	r18, 0x10	; 16
    11f8:	32 e0       	ldi	r19, 0x02	; 2
    11fa:	f8 01       	movw	r30, r16
    11fc:	b7 fe       	sbrs	r11, 7
    11fe:	07 c0       	rjmp	.+14     	; 0x120e <vfprintf+0x282>
    1200:	60 81       	ld	r22, Z
    1202:	71 81       	ldd	r23, Z+1	; 0x01
    1204:	82 81       	ldd	r24, Z+2	; 0x02
    1206:	93 81       	ldd	r25, Z+3	; 0x03
    1208:	0c 5f       	subi	r16, 0xFC	; 252
    120a:	1f 4f       	sbci	r17, 0xFF	; 255
    120c:	06 c0       	rjmp	.+12     	; 0x121a <vfprintf+0x28e>
    120e:	60 81       	ld	r22, Z
    1210:	71 81       	ldd	r23, Z+1	; 0x01
    1212:	80 e0       	ldi	r24, 0x00	; 0
    1214:	90 e0       	ldi	r25, 0x00	; 0
    1216:	0e 5f       	subi	r16, 0xFE	; 254
    1218:	1f 4f       	sbci	r17, 0xFF	; 255
    121a:	a3 01       	movw	r20, r6
    121c:	0a d3       	rcall	.+1556   	; 0x1832 <__ultoa_invert>
    121e:	88 2e       	mov	r8, r24
    1220:	86 18       	sub	r8, r6
    1222:	fb 2d       	mov	r31, r11
    1224:	ff 77       	andi	r31, 0x7F	; 127
    1226:	3f 2e       	mov	r3, r31
    1228:	36 fe       	sbrs	r3, 6
    122a:	0d c0       	rjmp	.+26     	; 0x1246 <vfprintf+0x2ba>
    122c:	23 2d       	mov	r18, r3
    122e:	2e 7f       	andi	r18, 0xFE	; 254
    1230:	a2 2e       	mov	r10, r18
    1232:	89 14       	cp	r8, r9
    1234:	58 f4       	brcc	.+22     	; 0x124c <vfprintf+0x2c0>
    1236:	34 fe       	sbrs	r3, 4
    1238:	0b c0       	rjmp	.+22     	; 0x1250 <vfprintf+0x2c4>
    123a:	32 fc       	sbrc	r3, 2
    123c:	09 c0       	rjmp	.+18     	; 0x1250 <vfprintf+0x2c4>
    123e:	83 2d       	mov	r24, r3
    1240:	8e 7e       	andi	r24, 0xEE	; 238
    1242:	a8 2e       	mov	r10, r24
    1244:	05 c0       	rjmp	.+10     	; 0x1250 <vfprintf+0x2c4>
    1246:	b8 2c       	mov	r11, r8
    1248:	a3 2c       	mov	r10, r3
    124a:	03 c0       	rjmp	.+6      	; 0x1252 <vfprintf+0x2c6>
    124c:	b8 2c       	mov	r11, r8
    124e:	01 c0       	rjmp	.+2      	; 0x1252 <vfprintf+0x2c6>
    1250:	b9 2c       	mov	r11, r9
    1252:	a4 fe       	sbrs	r10, 4
    1254:	0f c0       	rjmp	.+30     	; 0x1274 <vfprintf+0x2e8>
    1256:	fe 01       	movw	r30, r28
    1258:	e8 0d       	add	r30, r8
    125a:	f1 1d       	adc	r31, r1
    125c:	80 81       	ld	r24, Z
    125e:	80 33       	cpi	r24, 0x30	; 48
    1260:	21 f4       	brne	.+8      	; 0x126a <vfprintf+0x2de>
    1262:	9a 2d       	mov	r25, r10
    1264:	99 7e       	andi	r25, 0xE9	; 233
    1266:	a9 2e       	mov	r10, r25
    1268:	09 c0       	rjmp	.+18     	; 0x127c <vfprintf+0x2f0>
    126a:	a2 fe       	sbrs	r10, 2
    126c:	06 c0       	rjmp	.+12     	; 0x127a <vfprintf+0x2ee>
    126e:	b3 94       	inc	r11
    1270:	b3 94       	inc	r11
    1272:	04 c0       	rjmp	.+8      	; 0x127c <vfprintf+0x2f0>
    1274:	8a 2d       	mov	r24, r10
    1276:	86 78       	andi	r24, 0x86	; 134
    1278:	09 f0       	breq	.+2      	; 0x127c <vfprintf+0x2f0>
    127a:	b3 94       	inc	r11
    127c:	a3 fc       	sbrc	r10, 3
    127e:	10 c0       	rjmp	.+32     	; 0x12a0 <vfprintf+0x314>
    1280:	a0 fe       	sbrs	r10, 0
    1282:	06 c0       	rjmp	.+12     	; 0x1290 <vfprintf+0x304>
    1284:	b2 14       	cp	r11, r2
    1286:	80 f4       	brcc	.+32     	; 0x12a8 <vfprintf+0x31c>
    1288:	28 0c       	add	r2, r8
    128a:	92 2c       	mov	r9, r2
    128c:	9b 18       	sub	r9, r11
    128e:	0d c0       	rjmp	.+26     	; 0x12aa <vfprintf+0x31e>
    1290:	b2 14       	cp	r11, r2
    1292:	58 f4       	brcc	.+22     	; 0x12aa <vfprintf+0x31e>
    1294:	b6 01       	movw	r22, r12
    1296:	80 e2       	ldi	r24, 0x20	; 32
    1298:	90 e0       	ldi	r25, 0x00	; 0
    129a:	8f d2       	rcall	.+1310   	; 0x17ba <fputc>
    129c:	b3 94       	inc	r11
    129e:	f8 cf       	rjmp	.-16     	; 0x1290 <vfprintf+0x304>
    12a0:	b2 14       	cp	r11, r2
    12a2:	18 f4       	brcc	.+6      	; 0x12aa <vfprintf+0x31e>
    12a4:	2b 18       	sub	r2, r11
    12a6:	02 c0       	rjmp	.+4      	; 0x12ac <vfprintf+0x320>
    12a8:	98 2c       	mov	r9, r8
    12aa:	21 2c       	mov	r2, r1
    12ac:	a4 fe       	sbrs	r10, 4
    12ae:	0f c0       	rjmp	.+30     	; 0x12ce <vfprintf+0x342>
    12b0:	b6 01       	movw	r22, r12
    12b2:	80 e3       	ldi	r24, 0x30	; 48
    12b4:	90 e0       	ldi	r25, 0x00	; 0
    12b6:	81 d2       	rcall	.+1282   	; 0x17ba <fputc>
    12b8:	a2 fe       	sbrs	r10, 2
    12ba:	16 c0       	rjmp	.+44     	; 0x12e8 <vfprintf+0x35c>
    12bc:	a1 fc       	sbrc	r10, 1
    12be:	03 c0       	rjmp	.+6      	; 0x12c6 <vfprintf+0x33a>
    12c0:	88 e7       	ldi	r24, 0x78	; 120
    12c2:	90 e0       	ldi	r25, 0x00	; 0
    12c4:	02 c0       	rjmp	.+4      	; 0x12ca <vfprintf+0x33e>
    12c6:	88 e5       	ldi	r24, 0x58	; 88
    12c8:	90 e0       	ldi	r25, 0x00	; 0
    12ca:	b6 01       	movw	r22, r12
    12cc:	0c c0       	rjmp	.+24     	; 0x12e6 <vfprintf+0x35a>
    12ce:	8a 2d       	mov	r24, r10
    12d0:	86 78       	andi	r24, 0x86	; 134
    12d2:	51 f0       	breq	.+20     	; 0x12e8 <vfprintf+0x35c>
    12d4:	a1 fe       	sbrs	r10, 1
    12d6:	02 c0       	rjmp	.+4      	; 0x12dc <vfprintf+0x350>
    12d8:	8b e2       	ldi	r24, 0x2B	; 43
    12da:	01 c0       	rjmp	.+2      	; 0x12de <vfprintf+0x352>
    12dc:	80 e2       	ldi	r24, 0x20	; 32
    12de:	a7 fc       	sbrc	r10, 7
    12e0:	8d e2       	ldi	r24, 0x2D	; 45
    12e2:	b6 01       	movw	r22, r12
    12e4:	90 e0       	ldi	r25, 0x00	; 0
    12e6:	69 d2       	rcall	.+1234   	; 0x17ba <fputc>
    12e8:	89 14       	cp	r8, r9
    12ea:	30 f4       	brcc	.+12     	; 0x12f8 <vfprintf+0x36c>
    12ec:	b6 01       	movw	r22, r12
    12ee:	80 e3       	ldi	r24, 0x30	; 48
    12f0:	90 e0       	ldi	r25, 0x00	; 0
    12f2:	63 d2       	rcall	.+1222   	; 0x17ba <fputc>
    12f4:	9a 94       	dec	r9
    12f6:	f8 cf       	rjmp	.-16     	; 0x12e8 <vfprintf+0x35c>
    12f8:	8a 94       	dec	r8
    12fa:	f3 01       	movw	r30, r6
    12fc:	e8 0d       	add	r30, r8
    12fe:	f1 1d       	adc	r31, r1
    1300:	80 81       	ld	r24, Z
    1302:	b6 01       	movw	r22, r12
    1304:	90 e0       	ldi	r25, 0x00	; 0
    1306:	59 d2       	rcall	.+1202   	; 0x17ba <fputc>
    1308:	81 10       	cpse	r8, r1
    130a:	f6 cf       	rjmp	.-20     	; 0x12f8 <vfprintf+0x36c>
    130c:	22 20       	and	r2, r2
    130e:	09 f4       	brne	.+2      	; 0x1312 <vfprintf+0x386>
    1310:	4e ce       	rjmp	.-868    	; 0xfae <vfprintf+0x22>
    1312:	b6 01       	movw	r22, r12
    1314:	80 e2       	ldi	r24, 0x20	; 32
    1316:	90 e0       	ldi	r25, 0x00	; 0
    1318:	50 d2       	rcall	.+1184   	; 0x17ba <fputc>
    131a:	2a 94       	dec	r2
    131c:	f7 cf       	rjmp	.-18     	; 0x130c <vfprintf+0x380>
    131e:	f6 01       	movw	r30, r12
    1320:	86 81       	ldd	r24, Z+6	; 0x06
    1322:	97 81       	ldd	r25, Z+7	; 0x07
    1324:	02 c0       	rjmp	.+4      	; 0x132a <vfprintf+0x39e>
    1326:	8f ef       	ldi	r24, 0xFF	; 255
    1328:	9f ef       	ldi	r25, 0xFF	; 255
    132a:	2b 96       	adiw	r28, 0x0b	; 11
    132c:	e2 e1       	ldi	r30, 0x12	; 18
    132e:	f8 c2       	rjmp	.+1520   	; 0x1920 <__epilogue_restores__>

00001330 <dtoa_prf>:
    1330:	a9 e0       	ldi	r26, 0x09	; 9
    1332:	b0 e0       	ldi	r27, 0x00	; 0
    1334:	ed e9       	ldi	r30, 0x9D	; 157
    1336:	f9 e0       	ldi	r31, 0x09	; 9
    1338:	e0 c2       	rjmp	.+1472   	; 0x18fa <__prologue_saves__+0xc>
    133a:	6a 01       	movw	r12, r20
    133c:	12 2f       	mov	r17, r18
    133e:	b0 2e       	mov	r11, r16
    1340:	2b e3       	ldi	r18, 0x3B	; 59
    1342:	20 17       	cp	r18, r16
    1344:	20 f0       	brcs	.+8      	; 0x134e <dtoa_prf+0x1e>
    1346:	ff 24       	eor	r15, r15
    1348:	f3 94       	inc	r15
    134a:	f0 0e       	add	r15, r16
    134c:	02 c0       	rjmp	.+4      	; 0x1352 <dtoa_prf+0x22>
    134e:	2c e3       	ldi	r18, 0x3C	; 60
    1350:	f2 2e       	mov	r15, r18
    1352:	0f 2d       	mov	r16, r15
    1354:	27 e0       	ldi	r18, 0x07	; 7
    1356:	ae 01       	movw	r20, r28
    1358:	4f 5f       	subi	r20, 0xFF	; 255
    135a:	5f 4f       	sbci	r21, 0xFF	; 255
    135c:	40 d1       	rcall	.+640    	; 0x15de <__ftoa_engine>
    135e:	bc 01       	movw	r22, r24
    1360:	49 81       	ldd	r20, Y+1	; 0x01
    1362:	84 2f       	mov	r24, r20
    1364:	89 70       	andi	r24, 0x09	; 9
    1366:	81 30       	cpi	r24, 0x01	; 1
    1368:	31 f0       	breq	.+12     	; 0x1376 <dtoa_prf+0x46>
    136a:	e1 fc       	sbrc	r14, 1
    136c:	06 c0       	rjmp	.+12     	; 0x137a <dtoa_prf+0x4a>
    136e:	e0 fe       	sbrs	r14, 0
    1370:	06 c0       	rjmp	.+12     	; 0x137e <dtoa_prf+0x4e>
    1372:	90 e2       	ldi	r25, 0x20	; 32
    1374:	05 c0       	rjmp	.+10     	; 0x1380 <dtoa_prf+0x50>
    1376:	9d e2       	ldi	r25, 0x2D	; 45
    1378:	03 c0       	rjmp	.+6      	; 0x1380 <dtoa_prf+0x50>
    137a:	9b e2       	ldi	r25, 0x2B	; 43
    137c:	01 c0       	rjmp	.+2      	; 0x1380 <dtoa_prf+0x50>
    137e:	90 e0       	ldi	r25, 0x00	; 0
    1380:	5e 2d       	mov	r21, r14
    1382:	50 71       	andi	r21, 0x10	; 16
    1384:	43 ff       	sbrs	r20, 3
    1386:	3c c0       	rjmp	.+120    	; 0x1400 <dtoa_prf+0xd0>
    1388:	91 11       	cpse	r25, r1
    138a:	02 c0       	rjmp	.+4      	; 0x1390 <dtoa_prf+0x60>
    138c:	83 e0       	ldi	r24, 0x03	; 3
    138e:	01 c0       	rjmp	.+2      	; 0x1392 <dtoa_prf+0x62>
    1390:	84 e0       	ldi	r24, 0x04	; 4
    1392:	81 17       	cp	r24, r17
    1394:	18 f4       	brcc	.+6      	; 0x139c <dtoa_prf+0x6c>
    1396:	21 2f       	mov	r18, r17
    1398:	28 1b       	sub	r18, r24
    139a:	01 c0       	rjmp	.+2      	; 0x139e <dtoa_prf+0x6e>
    139c:	20 e0       	ldi	r18, 0x00	; 0
    139e:	51 11       	cpse	r21, r1
    13a0:	0b c0       	rjmp	.+22     	; 0x13b8 <dtoa_prf+0x88>
    13a2:	f6 01       	movw	r30, r12
    13a4:	82 2f       	mov	r24, r18
    13a6:	30 e2       	ldi	r19, 0x20	; 32
    13a8:	88 23       	and	r24, r24
    13aa:	19 f0       	breq	.+6      	; 0x13b2 <dtoa_prf+0x82>
    13ac:	31 93       	st	Z+, r19
    13ae:	81 50       	subi	r24, 0x01	; 1
    13b0:	fb cf       	rjmp	.-10     	; 0x13a8 <dtoa_prf+0x78>
    13b2:	c2 0e       	add	r12, r18
    13b4:	d1 1c       	adc	r13, r1
    13b6:	20 e0       	ldi	r18, 0x00	; 0
    13b8:	99 23       	and	r25, r25
    13ba:	29 f0       	breq	.+10     	; 0x13c6 <dtoa_prf+0x96>
    13bc:	d6 01       	movw	r26, r12
    13be:	9c 93       	st	X, r25
    13c0:	f6 01       	movw	r30, r12
    13c2:	31 96       	adiw	r30, 0x01	; 1
    13c4:	6f 01       	movw	r12, r30
    13c6:	c6 01       	movw	r24, r12
    13c8:	03 96       	adiw	r24, 0x03	; 3
    13ca:	e2 fe       	sbrs	r14, 2
    13cc:	0a c0       	rjmp	.+20     	; 0x13e2 <dtoa_prf+0xb2>
    13ce:	3e e4       	ldi	r19, 0x4E	; 78
    13d0:	d6 01       	movw	r26, r12
    13d2:	3c 93       	st	X, r19
    13d4:	41 e4       	ldi	r20, 0x41	; 65
    13d6:	11 96       	adiw	r26, 0x01	; 1
    13d8:	4c 93       	st	X, r20
    13da:	11 97       	sbiw	r26, 0x01	; 1
    13dc:	12 96       	adiw	r26, 0x02	; 2
    13de:	3c 93       	st	X, r19
    13e0:	06 c0       	rjmp	.+12     	; 0x13ee <dtoa_prf+0xbe>
    13e2:	3e e6       	ldi	r19, 0x6E	; 110
    13e4:	f6 01       	movw	r30, r12
    13e6:	30 83       	st	Z, r19
    13e8:	41 e6       	ldi	r20, 0x61	; 97
    13ea:	41 83       	std	Z+1, r20	; 0x01
    13ec:	32 83       	std	Z+2, r19	; 0x02
    13ee:	fc 01       	movw	r30, r24
    13f0:	32 2f       	mov	r19, r18
    13f2:	40 e2       	ldi	r20, 0x20	; 32
    13f4:	33 23       	and	r19, r19
    13f6:	09 f4       	brne	.+2      	; 0x13fa <dtoa_prf+0xca>
    13f8:	42 c0       	rjmp	.+132    	; 0x147e <dtoa_prf+0x14e>
    13fa:	41 93       	st	Z+, r20
    13fc:	31 50       	subi	r19, 0x01	; 1
    13fe:	fa cf       	rjmp	.-12     	; 0x13f4 <dtoa_prf+0xc4>
    1400:	42 ff       	sbrs	r20, 2
    1402:	44 c0       	rjmp	.+136    	; 0x148c <dtoa_prf+0x15c>
    1404:	91 11       	cpse	r25, r1
    1406:	02 c0       	rjmp	.+4      	; 0x140c <dtoa_prf+0xdc>
    1408:	83 e0       	ldi	r24, 0x03	; 3
    140a:	01 c0       	rjmp	.+2      	; 0x140e <dtoa_prf+0xde>
    140c:	84 e0       	ldi	r24, 0x04	; 4
    140e:	81 17       	cp	r24, r17
    1410:	18 f4       	brcc	.+6      	; 0x1418 <dtoa_prf+0xe8>
    1412:	21 2f       	mov	r18, r17
    1414:	28 1b       	sub	r18, r24
    1416:	01 c0       	rjmp	.+2      	; 0x141a <dtoa_prf+0xea>
    1418:	20 e0       	ldi	r18, 0x00	; 0
    141a:	51 11       	cpse	r21, r1
    141c:	0b c0       	rjmp	.+22     	; 0x1434 <dtoa_prf+0x104>
    141e:	f6 01       	movw	r30, r12
    1420:	82 2f       	mov	r24, r18
    1422:	30 e2       	ldi	r19, 0x20	; 32
    1424:	88 23       	and	r24, r24
    1426:	19 f0       	breq	.+6      	; 0x142e <dtoa_prf+0xfe>
    1428:	31 93       	st	Z+, r19
    142a:	81 50       	subi	r24, 0x01	; 1
    142c:	fb cf       	rjmp	.-10     	; 0x1424 <dtoa_prf+0xf4>
    142e:	c2 0e       	add	r12, r18
    1430:	d1 1c       	adc	r13, r1
    1432:	20 e0       	ldi	r18, 0x00	; 0
    1434:	99 23       	and	r25, r25
    1436:	29 f0       	breq	.+10     	; 0x1442 <dtoa_prf+0x112>
    1438:	d6 01       	movw	r26, r12
    143a:	9c 93       	st	X, r25
    143c:	f6 01       	movw	r30, r12
    143e:	31 96       	adiw	r30, 0x01	; 1
    1440:	6f 01       	movw	r12, r30
    1442:	c6 01       	movw	r24, r12
    1444:	03 96       	adiw	r24, 0x03	; 3
    1446:	e2 fe       	sbrs	r14, 2
    1448:	0b c0       	rjmp	.+22     	; 0x1460 <dtoa_prf+0x130>
    144a:	39 e4       	ldi	r19, 0x49	; 73
    144c:	d6 01       	movw	r26, r12
    144e:	3c 93       	st	X, r19
    1450:	3e e4       	ldi	r19, 0x4E	; 78
    1452:	11 96       	adiw	r26, 0x01	; 1
    1454:	3c 93       	st	X, r19
    1456:	11 97       	sbiw	r26, 0x01	; 1
    1458:	36 e4       	ldi	r19, 0x46	; 70
    145a:	12 96       	adiw	r26, 0x02	; 2
    145c:	3c 93       	st	X, r19
    145e:	07 c0       	rjmp	.+14     	; 0x146e <dtoa_prf+0x13e>
    1460:	39 e6       	ldi	r19, 0x69	; 105
    1462:	f6 01       	movw	r30, r12
    1464:	30 83       	st	Z, r19
    1466:	3e e6       	ldi	r19, 0x6E	; 110
    1468:	31 83       	std	Z+1, r19	; 0x01
    146a:	36 e6       	ldi	r19, 0x66	; 102
    146c:	32 83       	std	Z+2, r19	; 0x02
    146e:	fc 01       	movw	r30, r24
    1470:	32 2f       	mov	r19, r18
    1472:	40 e2       	ldi	r20, 0x20	; 32
    1474:	33 23       	and	r19, r19
    1476:	19 f0       	breq	.+6      	; 0x147e <dtoa_prf+0x14e>
    1478:	41 93       	st	Z+, r20
    147a:	31 50       	subi	r19, 0x01	; 1
    147c:	fb cf       	rjmp	.-10     	; 0x1474 <dtoa_prf+0x144>
    147e:	fc 01       	movw	r30, r24
    1480:	e2 0f       	add	r30, r18
    1482:	f1 1d       	adc	r31, r1
    1484:	10 82       	st	Z, r1
    1486:	8e ef       	ldi	r24, 0xFE	; 254
    1488:	9f ef       	ldi	r25, 0xFF	; 255
    148a:	a6 c0       	rjmp	.+332    	; 0x15d8 <dtoa_prf+0x2a8>
    148c:	21 e0       	ldi	r18, 0x01	; 1
    148e:	30 e0       	ldi	r19, 0x00	; 0
    1490:	91 11       	cpse	r25, r1
    1492:	02 c0       	rjmp	.+4      	; 0x1498 <dtoa_prf+0x168>
    1494:	20 e0       	ldi	r18, 0x00	; 0
    1496:	30 e0       	ldi	r19, 0x00	; 0
    1498:	16 16       	cp	r1, r22
    149a:	17 06       	cpc	r1, r23
    149c:	1c f4       	brge	.+6      	; 0x14a4 <dtoa_prf+0x174>
    149e:	fb 01       	movw	r30, r22
    14a0:	31 96       	adiw	r30, 0x01	; 1
    14a2:	02 c0       	rjmp	.+4      	; 0x14a8 <dtoa_prf+0x178>
    14a4:	e1 e0       	ldi	r30, 0x01	; 1
    14a6:	f0 e0       	ldi	r31, 0x00	; 0
    14a8:	2e 0f       	add	r18, r30
    14aa:	3f 1f       	adc	r19, r31
    14ac:	bb 20       	and	r11, r11
    14ae:	21 f0       	breq	.+8      	; 0x14b8 <dtoa_prf+0x188>
    14b0:	eb 2d       	mov	r30, r11
    14b2:	f0 e0       	ldi	r31, 0x00	; 0
    14b4:	31 96       	adiw	r30, 0x01	; 1
    14b6:	02 c0       	rjmp	.+4      	; 0x14bc <dtoa_prf+0x18c>
    14b8:	e0 e0       	ldi	r30, 0x00	; 0
    14ba:	f0 e0       	ldi	r31, 0x00	; 0
    14bc:	2e 0f       	add	r18, r30
    14be:	3f 1f       	adc	r19, r31
    14c0:	e1 2f       	mov	r30, r17
    14c2:	f0 e0       	ldi	r31, 0x00	; 0
    14c4:	2e 17       	cp	r18, r30
    14c6:	3f 07       	cpc	r19, r31
    14c8:	1c f4       	brge	.+6      	; 0x14d0 <dtoa_prf+0x1a0>
    14ca:	12 1b       	sub	r17, r18
    14cc:	21 2f       	mov	r18, r17
    14ce:	01 c0       	rjmp	.+2      	; 0x14d2 <dtoa_prf+0x1a2>
    14d0:	20 e0       	ldi	r18, 0x00	; 0
    14d2:	8e 2d       	mov	r24, r14
    14d4:	88 71       	andi	r24, 0x18	; 24
    14d6:	59 f4       	brne	.+22     	; 0x14ee <dtoa_prf+0x1be>
    14d8:	f6 01       	movw	r30, r12
    14da:	82 2f       	mov	r24, r18
    14dc:	30 e2       	ldi	r19, 0x20	; 32
    14de:	88 23       	and	r24, r24
    14e0:	19 f0       	breq	.+6      	; 0x14e8 <dtoa_prf+0x1b8>
    14e2:	31 93       	st	Z+, r19
    14e4:	81 50       	subi	r24, 0x01	; 1
    14e6:	fb cf       	rjmp	.-10     	; 0x14de <dtoa_prf+0x1ae>
    14e8:	c2 0e       	add	r12, r18
    14ea:	d1 1c       	adc	r13, r1
    14ec:	20 e0       	ldi	r18, 0x00	; 0
    14ee:	99 23       	and	r25, r25
    14f0:	29 f0       	breq	.+10     	; 0x14fc <dtoa_prf+0x1cc>
    14f2:	d6 01       	movw	r26, r12
    14f4:	9c 93       	st	X, r25
    14f6:	f6 01       	movw	r30, r12
    14f8:	31 96       	adiw	r30, 0x01	; 1
    14fa:	6f 01       	movw	r12, r30
    14fc:	51 11       	cpse	r21, r1
    14fe:	0b c0       	rjmp	.+22     	; 0x1516 <dtoa_prf+0x1e6>
    1500:	f6 01       	movw	r30, r12
    1502:	82 2f       	mov	r24, r18
    1504:	90 e3       	ldi	r25, 0x30	; 48
    1506:	88 23       	and	r24, r24
    1508:	19 f0       	breq	.+6      	; 0x1510 <dtoa_prf+0x1e0>
    150a:	91 93       	st	Z+, r25
    150c:	81 50       	subi	r24, 0x01	; 1
    150e:	fb cf       	rjmp	.-10     	; 0x1506 <dtoa_prf+0x1d6>
    1510:	c2 0e       	add	r12, r18
    1512:	d1 1c       	adc	r13, r1
    1514:	20 e0       	ldi	r18, 0x00	; 0
    1516:	0f 2d       	mov	r16, r15
    1518:	06 0f       	add	r16, r22
    151a:	9a 81       	ldd	r25, Y+2	; 0x02
    151c:	34 2f       	mov	r19, r20
    151e:	30 71       	andi	r19, 0x10	; 16
    1520:	44 ff       	sbrs	r20, 4
    1522:	03 c0       	rjmp	.+6      	; 0x152a <dtoa_prf+0x1fa>
    1524:	91 33       	cpi	r25, 0x31	; 49
    1526:	09 f4       	brne	.+2      	; 0x152a <dtoa_prf+0x1fa>
    1528:	01 50       	subi	r16, 0x01	; 1
    152a:	10 16       	cp	r1, r16
    152c:	24 f4       	brge	.+8      	; 0x1536 <dtoa_prf+0x206>
    152e:	09 30       	cpi	r16, 0x09	; 9
    1530:	18 f0       	brcs	.+6      	; 0x1538 <dtoa_prf+0x208>
    1532:	08 e0       	ldi	r16, 0x08	; 8
    1534:	01 c0       	rjmp	.+2      	; 0x1538 <dtoa_prf+0x208>
    1536:	01 e0       	ldi	r16, 0x01	; 1
    1538:	ab 01       	movw	r20, r22
    153a:	77 ff       	sbrs	r23, 7
    153c:	02 c0       	rjmp	.+4      	; 0x1542 <dtoa_prf+0x212>
    153e:	40 e0       	ldi	r20, 0x00	; 0
    1540:	50 e0       	ldi	r21, 0x00	; 0
    1542:	fb 01       	movw	r30, r22
    1544:	e4 1b       	sub	r30, r20
    1546:	f5 0b       	sbc	r31, r21
    1548:	a1 e0       	ldi	r26, 0x01	; 1
    154a:	b0 e0       	ldi	r27, 0x00	; 0
    154c:	ac 0f       	add	r26, r28
    154e:	bd 1f       	adc	r27, r29
    1550:	ea 0f       	add	r30, r26
    1552:	fb 1f       	adc	r31, r27
    1554:	8e e2       	ldi	r24, 0x2E	; 46
    1556:	a8 2e       	mov	r10, r24
    1558:	4b 01       	movw	r8, r22
    155a:	80 1a       	sub	r8, r16
    155c:	91 08       	sbc	r9, r1
    155e:	0b 2d       	mov	r16, r11
    1560:	10 e0       	ldi	r17, 0x00	; 0
    1562:	11 95       	neg	r17
    1564:	01 95       	neg	r16
    1566:	11 09       	sbc	r17, r1
    1568:	4f 3f       	cpi	r20, 0xFF	; 255
    156a:	bf ef       	ldi	r27, 0xFF	; 255
    156c:	5b 07       	cpc	r21, r27
    156e:	21 f4       	brne	.+8      	; 0x1578 <dtoa_prf+0x248>
    1570:	d6 01       	movw	r26, r12
    1572:	ac 92       	st	X, r10
    1574:	11 96       	adiw	r26, 0x01	; 1
    1576:	6d 01       	movw	r12, r26
    1578:	64 17       	cp	r22, r20
    157a:	75 07       	cpc	r23, r21
    157c:	2c f0       	brlt	.+10     	; 0x1588 <dtoa_prf+0x258>
    157e:	84 16       	cp	r8, r20
    1580:	95 06       	cpc	r9, r21
    1582:	14 f4       	brge	.+4      	; 0x1588 <dtoa_prf+0x258>
    1584:	81 81       	ldd	r24, Z+1	; 0x01
    1586:	01 c0       	rjmp	.+2      	; 0x158a <dtoa_prf+0x25a>
    1588:	80 e3       	ldi	r24, 0x30	; 48
    158a:	41 50       	subi	r20, 0x01	; 1
    158c:	51 09       	sbc	r21, r1
    158e:	31 96       	adiw	r30, 0x01	; 1
    1590:	d6 01       	movw	r26, r12
    1592:	11 96       	adiw	r26, 0x01	; 1
    1594:	7d 01       	movw	r14, r26
    1596:	40 17       	cp	r20, r16
    1598:	51 07       	cpc	r21, r17
    159a:	24 f0       	brlt	.+8      	; 0x15a4 <dtoa_prf+0x274>
    159c:	d6 01       	movw	r26, r12
    159e:	8c 93       	st	X, r24
    15a0:	67 01       	movw	r12, r14
    15a2:	e2 cf       	rjmp	.-60     	; 0x1568 <dtoa_prf+0x238>
    15a4:	64 17       	cp	r22, r20
    15a6:	75 07       	cpc	r23, r21
    15a8:	39 f4       	brne	.+14     	; 0x15b8 <dtoa_prf+0x288>
    15aa:	96 33       	cpi	r25, 0x36	; 54
    15ac:	20 f4       	brcc	.+8      	; 0x15b6 <dtoa_prf+0x286>
    15ae:	95 33       	cpi	r25, 0x35	; 53
    15b0:	19 f4       	brne	.+6      	; 0x15b8 <dtoa_prf+0x288>
    15b2:	31 11       	cpse	r19, r1
    15b4:	01 c0       	rjmp	.+2      	; 0x15b8 <dtoa_prf+0x288>
    15b6:	81 e3       	ldi	r24, 0x31	; 49
    15b8:	f6 01       	movw	r30, r12
    15ba:	80 83       	st	Z, r24
    15bc:	f7 01       	movw	r30, r14
    15be:	82 2f       	mov	r24, r18
    15c0:	90 e2       	ldi	r25, 0x20	; 32
    15c2:	88 23       	and	r24, r24
    15c4:	19 f0       	breq	.+6      	; 0x15cc <dtoa_prf+0x29c>
    15c6:	91 93       	st	Z+, r25
    15c8:	81 50       	subi	r24, 0x01	; 1
    15ca:	fb cf       	rjmp	.-10     	; 0x15c2 <dtoa_prf+0x292>
    15cc:	f7 01       	movw	r30, r14
    15ce:	e2 0f       	add	r30, r18
    15d0:	f1 1d       	adc	r31, r1
    15d2:	10 82       	st	Z, r1
    15d4:	80 e0       	ldi	r24, 0x00	; 0
    15d6:	90 e0       	ldi	r25, 0x00	; 0
    15d8:	29 96       	adiw	r28, 0x09	; 9
    15da:	ec e0       	ldi	r30, 0x0C	; 12
    15dc:	a7 c1       	rjmp	.+846    	; 0x192c <__epilogue_restores__+0xc>

000015de <__ftoa_engine>:
    15de:	28 30       	cpi	r18, 0x08	; 8
    15e0:	08 f0       	brcs	.+2      	; 0x15e4 <__ftoa_engine+0x6>
    15e2:	27 e0       	ldi	r18, 0x07	; 7
    15e4:	33 27       	eor	r19, r19
    15e6:	da 01       	movw	r26, r20
    15e8:	99 0f       	add	r25, r25
    15ea:	31 1d       	adc	r19, r1
    15ec:	87 fd       	sbrc	r24, 7
    15ee:	91 60       	ori	r25, 0x01	; 1
    15f0:	00 96       	adiw	r24, 0x00	; 0
    15f2:	61 05       	cpc	r22, r1
    15f4:	71 05       	cpc	r23, r1
    15f6:	39 f4       	brne	.+14     	; 0x1606 <__ftoa_engine+0x28>
    15f8:	32 60       	ori	r19, 0x02	; 2
    15fa:	2e 5f       	subi	r18, 0xFE	; 254
    15fc:	3d 93       	st	X+, r19
    15fe:	30 e3       	ldi	r19, 0x30	; 48
    1600:	2a 95       	dec	r18
    1602:	e1 f7       	brne	.-8      	; 0x15fc <__ftoa_engine+0x1e>
    1604:	08 95       	ret
    1606:	9f 3f       	cpi	r25, 0xFF	; 255
    1608:	30 f0       	brcs	.+12     	; 0x1616 <__ftoa_engine+0x38>
    160a:	80 38       	cpi	r24, 0x80	; 128
    160c:	71 05       	cpc	r23, r1
    160e:	61 05       	cpc	r22, r1
    1610:	09 f0       	breq	.+2      	; 0x1614 <__ftoa_engine+0x36>
    1612:	3c 5f       	subi	r19, 0xFC	; 252
    1614:	3c 5f       	subi	r19, 0xFC	; 252
    1616:	3d 93       	st	X+, r19
    1618:	91 30       	cpi	r25, 0x01	; 1
    161a:	08 f0       	brcs	.+2      	; 0x161e <__ftoa_engine+0x40>
    161c:	80 68       	ori	r24, 0x80	; 128
    161e:	91 1d       	adc	r25, r1
    1620:	df 93       	push	r29
    1622:	cf 93       	push	r28
    1624:	1f 93       	push	r17
    1626:	0f 93       	push	r16
    1628:	ff 92       	push	r15
    162a:	ef 92       	push	r14
    162c:	19 2f       	mov	r17, r25
    162e:	98 7f       	andi	r25, 0xF8	; 248
    1630:	96 95       	lsr	r25
    1632:	e9 2f       	mov	r30, r25
    1634:	96 95       	lsr	r25
    1636:	96 95       	lsr	r25
    1638:	e9 0f       	add	r30, r25
    163a:	ff 27       	eor	r31, r31
    163c:	e2 57       	subi	r30, 0x72	; 114
    163e:	ff 4f       	sbci	r31, 0xFF	; 255
    1640:	99 27       	eor	r25, r25
    1642:	33 27       	eor	r19, r19
    1644:	ee 24       	eor	r14, r14
    1646:	ff 24       	eor	r15, r15
    1648:	a7 01       	movw	r20, r14
    164a:	e7 01       	movw	r28, r14
    164c:	05 90       	lpm	r0, Z+
    164e:	08 94       	sec
    1650:	07 94       	ror	r0
    1652:	28 f4       	brcc	.+10     	; 0x165e <__ftoa_engine+0x80>
    1654:	36 0f       	add	r19, r22
    1656:	e7 1e       	adc	r14, r23
    1658:	f8 1e       	adc	r15, r24
    165a:	49 1f       	adc	r20, r25
    165c:	51 1d       	adc	r21, r1
    165e:	66 0f       	add	r22, r22
    1660:	77 1f       	adc	r23, r23
    1662:	88 1f       	adc	r24, r24
    1664:	99 1f       	adc	r25, r25
    1666:	06 94       	lsr	r0
    1668:	a1 f7       	brne	.-24     	; 0x1652 <__ftoa_engine+0x74>
    166a:	05 90       	lpm	r0, Z+
    166c:	07 94       	ror	r0
    166e:	28 f4       	brcc	.+10     	; 0x167a <__ftoa_engine+0x9c>
    1670:	e7 0e       	add	r14, r23
    1672:	f8 1e       	adc	r15, r24
    1674:	49 1f       	adc	r20, r25
    1676:	56 1f       	adc	r21, r22
    1678:	c1 1d       	adc	r28, r1
    167a:	77 0f       	add	r23, r23
    167c:	88 1f       	adc	r24, r24
    167e:	99 1f       	adc	r25, r25
    1680:	66 1f       	adc	r22, r22
    1682:	06 94       	lsr	r0
    1684:	a1 f7       	brne	.-24     	; 0x166e <__ftoa_engine+0x90>
    1686:	05 90       	lpm	r0, Z+
    1688:	07 94       	ror	r0
    168a:	28 f4       	brcc	.+10     	; 0x1696 <__ftoa_engine+0xb8>
    168c:	f8 0e       	add	r15, r24
    168e:	49 1f       	adc	r20, r25
    1690:	56 1f       	adc	r21, r22
    1692:	c7 1f       	adc	r28, r23
    1694:	d1 1d       	adc	r29, r1
    1696:	88 0f       	add	r24, r24
    1698:	99 1f       	adc	r25, r25
    169a:	66 1f       	adc	r22, r22
    169c:	77 1f       	adc	r23, r23
    169e:	06 94       	lsr	r0
    16a0:	a1 f7       	brne	.-24     	; 0x168a <__ftoa_engine+0xac>
    16a2:	05 90       	lpm	r0, Z+
    16a4:	07 94       	ror	r0
    16a6:	20 f4       	brcc	.+8      	; 0x16b0 <__ftoa_engine+0xd2>
    16a8:	49 0f       	add	r20, r25
    16aa:	56 1f       	adc	r21, r22
    16ac:	c7 1f       	adc	r28, r23
    16ae:	d8 1f       	adc	r29, r24
    16b0:	99 0f       	add	r25, r25
    16b2:	66 1f       	adc	r22, r22
    16b4:	77 1f       	adc	r23, r23
    16b6:	88 1f       	adc	r24, r24
    16b8:	06 94       	lsr	r0
    16ba:	a9 f7       	brne	.-22     	; 0x16a6 <__ftoa_engine+0xc8>
    16bc:	84 91       	lpm	r24, Z
    16be:	10 95       	com	r17
    16c0:	17 70       	andi	r17, 0x07	; 7
    16c2:	41 f0       	breq	.+16     	; 0x16d4 <__ftoa_engine+0xf6>
    16c4:	d6 95       	lsr	r29
    16c6:	c7 95       	ror	r28
    16c8:	57 95       	ror	r21
    16ca:	47 95       	ror	r20
    16cc:	f7 94       	ror	r15
    16ce:	e7 94       	ror	r14
    16d0:	1a 95       	dec	r17
    16d2:	c1 f7       	brne	.-16     	; 0x16c4 <__ftoa_engine+0xe6>
    16d4:	e4 e3       	ldi	r30, 0x34	; 52
    16d6:	f0 e0       	ldi	r31, 0x00	; 0
    16d8:	68 94       	set
    16da:	15 90       	lpm	r1, Z+
    16dc:	15 91       	lpm	r17, Z+
    16de:	35 91       	lpm	r19, Z+
    16e0:	65 91       	lpm	r22, Z+
    16e2:	95 91       	lpm	r25, Z+
    16e4:	05 90       	lpm	r0, Z+
    16e6:	7f e2       	ldi	r23, 0x2F	; 47
    16e8:	73 95       	inc	r23
    16ea:	e1 18       	sub	r14, r1
    16ec:	f1 0a       	sbc	r15, r17
    16ee:	43 0b       	sbc	r20, r19
    16f0:	56 0b       	sbc	r21, r22
    16f2:	c9 0b       	sbc	r28, r25
    16f4:	d0 09       	sbc	r29, r0
    16f6:	c0 f7       	brcc	.-16     	; 0x16e8 <__ftoa_engine+0x10a>
    16f8:	e1 0c       	add	r14, r1
    16fa:	f1 1e       	adc	r15, r17
    16fc:	43 1f       	adc	r20, r19
    16fe:	56 1f       	adc	r21, r22
    1700:	c9 1f       	adc	r28, r25
    1702:	d0 1d       	adc	r29, r0
    1704:	7e f4       	brtc	.+30     	; 0x1724 <__ftoa_engine+0x146>
    1706:	70 33       	cpi	r23, 0x30	; 48
    1708:	11 f4       	brne	.+4      	; 0x170e <__ftoa_engine+0x130>
    170a:	8a 95       	dec	r24
    170c:	e6 cf       	rjmp	.-52     	; 0x16da <__ftoa_engine+0xfc>
    170e:	e8 94       	clt
    1710:	01 50       	subi	r16, 0x01	; 1
    1712:	30 f0       	brcs	.+12     	; 0x1720 <__ftoa_engine+0x142>
    1714:	08 0f       	add	r16, r24
    1716:	0a f4       	brpl	.+2      	; 0x171a <__ftoa_engine+0x13c>
    1718:	00 27       	eor	r16, r16
    171a:	02 17       	cp	r16, r18
    171c:	08 f4       	brcc	.+2      	; 0x1720 <__ftoa_engine+0x142>
    171e:	20 2f       	mov	r18, r16
    1720:	23 95       	inc	r18
    1722:	02 2f       	mov	r16, r18
    1724:	7a 33       	cpi	r23, 0x3A	; 58
    1726:	28 f0       	brcs	.+10     	; 0x1732 <__ftoa_engine+0x154>
    1728:	79 e3       	ldi	r23, 0x39	; 57
    172a:	7d 93       	st	X+, r23
    172c:	2a 95       	dec	r18
    172e:	e9 f7       	brne	.-6      	; 0x172a <__ftoa_engine+0x14c>
    1730:	10 c0       	rjmp	.+32     	; 0x1752 <__ftoa_engine+0x174>
    1732:	7d 93       	st	X+, r23
    1734:	2a 95       	dec	r18
    1736:	89 f6       	brne	.-94     	; 0x16da <__ftoa_engine+0xfc>
    1738:	06 94       	lsr	r0
    173a:	97 95       	ror	r25
    173c:	67 95       	ror	r22
    173e:	37 95       	ror	r19
    1740:	17 95       	ror	r17
    1742:	17 94       	ror	r1
    1744:	e1 18       	sub	r14, r1
    1746:	f1 0a       	sbc	r15, r17
    1748:	43 0b       	sbc	r20, r19
    174a:	56 0b       	sbc	r21, r22
    174c:	c9 0b       	sbc	r28, r25
    174e:	d0 09       	sbc	r29, r0
    1750:	98 f0       	brcs	.+38     	; 0x1778 <__ftoa_engine+0x19a>
    1752:	23 95       	inc	r18
    1754:	7e 91       	ld	r23, -X
    1756:	73 95       	inc	r23
    1758:	7a 33       	cpi	r23, 0x3A	; 58
    175a:	08 f0       	brcs	.+2      	; 0x175e <__ftoa_engine+0x180>
    175c:	70 e3       	ldi	r23, 0x30	; 48
    175e:	7c 93       	st	X, r23
    1760:	20 13       	cpse	r18, r16
    1762:	b8 f7       	brcc	.-18     	; 0x1752 <__ftoa_engine+0x174>
    1764:	7e 91       	ld	r23, -X
    1766:	70 61       	ori	r23, 0x10	; 16
    1768:	7d 93       	st	X+, r23
    176a:	30 f0       	brcs	.+12     	; 0x1778 <__ftoa_engine+0x19a>
    176c:	83 95       	inc	r24
    176e:	71 e3       	ldi	r23, 0x31	; 49
    1770:	7d 93       	st	X+, r23
    1772:	70 e3       	ldi	r23, 0x30	; 48
    1774:	2a 95       	dec	r18
    1776:	e1 f7       	brne	.-8      	; 0x1770 <__ftoa_engine+0x192>
    1778:	11 24       	eor	r1, r1
    177a:	ef 90       	pop	r14
    177c:	ff 90       	pop	r15
    177e:	0f 91       	pop	r16
    1780:	1f 91       	pop	r17
    1782:	cf 91       	pop	r28
    1784:	df 91       	pop	r29
    1786:	99 27       	eor	r25, r25
    1788:	87 fd       	sbrc	r24, 7
    178a:	90 95       	com	r25
    178c:	08 95       	ret

0000178e <strnlen_P>:
    178e:	fc 01       	movw	r30, r24
    1790:	05 90       	lpm	r0, Z+
    1792:	61 50       	subi	r22, 0x01	; 1
    1794:	70 40       	sbci	r23, 0x00	; 0
    1796:	01 10       	cpse	r0, r1
    1798:	d8 f7       	brcc	.-10     	; 0x1790 <strnlen_P+0x2>
    179a:	80 95       	com	r24
    179c:	90 95       	com	r25
    179e:	8e 0f       	add	r24, r30
    17a0:	9f 1f       	adc	r25, r31
    17a2:	08 95       	ret

000017a4 <strnlen>:
    17a4:	fc 01       	movw	r30, r24
    17a6:	61 50       	subi	r22, 0x01	; 1
    17a8:	70 40       	sbci	r23, 0x00	; 0
    17aa:	01 90       	ld	r0, Z+
    17ac:	01 10       	cpse	r0, r1
    17ae:	d8 f7       	brcc	.-10     	; 0x17a6 <strnlen+0x2>
    17b0:	80 95       	com	r24
    17b2:	90 95       	com	r25
    17b4:	8e 0f       	add	r24, r30
    17b6:	9f 1f       	adc	r25, r31
    17b8:	08 95       	ret

000017ba <fputc>:
    17ba:	0f 93       	push	r16
    17bc:	1f 93       	push	r17
    17be:	cf 93       	push	r28
    17c0:	df 93       	push	r29
    17c2:	fb 01       	movw	r30, r22
    17c4:	23 81       	ldd	r18, Z+3	; 0x03
    17c6:	21 fd       	sbrc	r18, 1
    17c8:	03 c0       	rjmp	.+6      	; 0x17d0 <fputc+0x16>
    17ca:	8f ef       	ldi	r24, 0xFF	; 255
    17cc:	9f ef       	ldi	r25, 0xFF	; 255
    17ce:	2c c0       	rjmp	.+88     	; 0x1828 <fputc+0x6e>
    17d0:	22 ff       	sbrs	r18, 2
    17d2:	16 c0       	rjmp	.+44     	; 0x1800 <fputc+0x46>
    17d4:	46 81       	ldd	r20, Z+6	; 0x06
    17d6:	57 81       	ldd	r21, Z+7	; 0x07
    17d8:	24 81       	ldd	r18, Z+4	; 0x04
    17da:	35 81       	ldd	r19, Z+5	; 0x05
    17dc:	42 17       	cp	r20, r18
    17de:	53 07       	cpc	r21, r19
    17e0:	44 f4       	brge	.+16     	; 0x17f2 <fputc+0x38>
    17e2:	a0 81       	ld	r26, Z
    17e4:	b1 81       	ldd	r27, Z+1	; 0x01
    17e6:	9d 01       	movw	r18, r26
    17e8:	2f 5f       	subi	r18, 0xFF	; 255
    17ea:	3f 4f       	sbci	r19, 0xFF	; 255
    17ec:	20 83       	st	Z, r18
    17ee:	31 83       	std	Z+1, r19	; 0x01
    17f0:	8c 93       	st	X, r24
    17f2:	26 81       	ldd	r18, Z+6	; 0x06
    17f4:	37 81       	ldd	r19, Z+7	; 0x07
    17f6:	2f 5f       	subi	r18, 0xFF	; 255
    17f8:	3f 4f       	sbci	r19, 0xFF	; 255
    17fa:	26 83       	std	Z+6, r18	; 0x06
    17fc:	37 83       	std	Z+7, r19	; 0x07
    17fe:	14 c0       	rjmp	.+40     	; 0x1828 <fputc+0x6e>
    1800:	8b 01       	movw	r16, r22
    1802:	ec 01       	movw	r28, r24
    1804:	fb 01       	movw	r30, r22
    1806:	00 84       	ldd	r0, Z+8	; 0x08
    1808:	f1 85       	ldd	r31, Z+9	; 0x09
    180a:	e0 2d       	mov	r30, r0
    180c:	09 95       	icall
    180e:	89 2b       	or	r24, r25
    1810:	e1 f6       	brne	.-72     	; 0x17ca <fputc+0x10>
    1812:	d8 01       	movw	r26, r16
    1814:	16 96       	adiw	r26, 0x06	; 6
    1816:	8d 91       	ld	r24, X+
    1818:	9c 91       	ld	r25, X
    181a:	17 97       	sbiw	r26, 0x07	; 7
    181c:	01 96       	adiw	r24, 0x01	; 1
    181e:	16 96       	adiw	r26, 0x06	; 6
    1820:	8d 93       	st	X+, r24
    1822:	9c 93       	st	X, r25
    1824:	17 97       	sbiw	r26, 0x07	; 7
    1826:	ce 01       	movw	r24, r28
    1828:	df 91       	pop	r29
    182a:	cf 91       	pop	r28
    182c:	1f 91       	pop	r17
    182e:	0f 91       	pop	r16
    1830:	08 95       	ret

00001832 <__ultoa_invert>:
    1832:	fa 01       	movw	r30, r20
    1834:	aa 27       	eor	r26, r26
    1836:	28 30       	cpi	r18, 0x08	; 8
    1838:	51 f1       	breq	.+84     	; 0x188e <__ultoa_invert+0x5c>
    183a:	20 31       	cpi	r18, 0x10	; 16
    183c:	81 f1       	breq	.+96     	; 0x189e <__ultoa_invert+0x6c>
    183e:	e8 94       	clt
    1840:	6f 93       	push	r22
    1842:	6e 7f       	andi	r22, 0xFE	; 254
    1844:	6e 5f       	subi	r22, 0xFE	; 254
    1846:	7f 4f       	sbci	r23, 0xFF	; 255
    1848:	8f 4f       	sbci	r24, 0xFF	; 255
    184a:	9f 4f       	sbci	r25, 0xFF	; 255
    184c:	af 4f       	sbci	r26, 0xFF	; 255
    184e:	b1 e0       	ldi	r27, 0x01	; 1
    1850:	3e d0       	rcall	.+124    	; 0x18ce <__ultoa_invert+0x9c>
    1852:	b4 e0       	ldi	r27, 0x04	; 4
    1854:	3c d0       	rcall	.+120    	; 0x18ce <__ultoa_invert+0x9c>
    1856:	67 0f       	add	r22, r23
    1858:	78 1f       	adc	r23, r24
    185a:	89 1f       	adc	r24, r25
    185c:	9a 1f       	adc	r25, r26
    185e:	a1 1d       	adc	r26, r1
    1860:	68 0f       	add	r22, r24
    1862:	79 1f       	adc	r23, r25
    1864:	8a 1f       	adc	r24, r26
    1866:	91 1d       	adc	r25, r1
    1868:	a1 1d       	adc	r26, r1
    186a:	6a 0f       	add	r22, r26
    186c:	71 1d       	adc	r23, r1
    186e:	81 1d       	adc	r24, r1
    1870:	91 1d       	adc	r25, r1
    1872:	a1 1d       	adc	r26, r1
    1874:	20 d0       	rcall	.+64     	; 0x18b6 <__ultoa_invert+0x84>
    1876:	09 f4       	brne	.+2      	; 0x187a <__ultoa_invert+0x48>
    1878:	68 94       	set
    187a:	3f 91       	pop	r19
    187c:	2a e0       	ldi	r18, 0x0A	; 10
    187e:	26 9f       	mul	r18, r22
    1880:	11 24       	eor	r1, r1
    1882:	30 19       	sub	r19, r0
    1884:	30 5d       	subi	r19, 0xD0	; 208
    1886:	31 93       	st	Z+, r19
    1888:	de f6       	brtc	.-74     	; 0x1840 <__ultoa_invert+0xe>
    188a:	cf 01       	movw	r24, r30
    188c:	08 95       	ret
    188e:	46 2f       	mov	r20, r22
    1890:	47 70       	andi	r20, 0x07	; 7
    1892:	40 5d       	subi	r20, 0xD0	; 208
    1894:	41 93       	st	Z+, r20
    1896:	b3 e0       	ldi	r27, 0x03	; 3
    1898:	0f d0       	rcall	.+30     	; 0x18b8 <__ultoa_invert+0x86>
    189a:	c9 f7       	brne	.-14     	; 0x188e <__ultoa_invert+0x5c>
    189c:	f6 cf       	rjmp	.-20     	; 0x188a <__ultoa_invert+0x58>
    189e:	46 2f       	mov	r20, r22
    18a0:	4f 70       	andi	r20, 0x0F	; 15
    18a2:	40 5d       	subi	r20, 0xD0	; 208
    18a4:	4a 33       	cpi	r20, 0x3A	; 58
    18a6:	18 f0       	brcs	.+6      	; 0x18ae <__ultoa_invert+0x7c>
    18a8:	49 5d       	subi	r20, 0xD9	; 217
    18aa:	31 fd       	sbrc	r19, 1
    18ac:	40 52       	subi	r20, 0x20	; 32
    18ae:	41 93       	st	Z+, r20
    18b0:	02 d0       	rcall	.+4      	; 0x18b6 <__ultoa_invert+0x84>
    18b2:	a9 f7       	brne	.-22     	; 0x189e <__ultoa_invert+0x6c>
    18b4:	ea cf       	rjmp	.-44     	; 0x188a <__ultoa_invert+0x58>
    18b6:	b4 e0       	ldi	r27, 0x04	; 4
    18b8:	a6 95       	lsr	r26
    18ba:	97 95       	ror	r25
    18bc:	87 95       	ror	r24
    18be:	77 95       	ror	r23
    18c0:	67 95       	ror	r22
    18c2:	ba 95       	dec	r27
    18c4:	c9 f7       	brne	.-14     	; 0x18b8 <__ultoa_invert+0x86>
    18c6:	00 97       	sbiw	r24, 0x00	; 0
    18c8:	61 05       	cpc	r22, r1
    18ca:	71 05       	cpc	r23, r1
    18cc:	08 95       	ret
    18ce:	9b 01       	movw	r18, r22
    18d0:	ac 01       	movw	r20, r24
    18d2:	0a 2e       	mov	r0, r26
    18d4:	06 94       	lsr	r0
    18d6:	57 95       	ror	r21
    18d8:	47 95       	ror	r20
    18da:	37 95       	ror	r19
    18dc:	27 95       	ror	r18
    18de:	ba 95       	dec	r27
    18e0:	c9 f7       	brne	.-14     	; 0x18d4 <__ultoa_invert+0xa2>
    18e2:	62 0f       	add	r22, r18
    18e4:	73 1f       	adc	r23, r19
    18e6:	84 1f       	adc	r24, r20
    18e8:	95 1f       	adc	r25, r21
    18ea:	a0 1d       	adc	r26, r0
    18ec:	08 95       	ret

000018ee <__prologue_saves__>:
    18ee:	2f 92       	push	r2
    18f0:	3f 92       	push	r3
    18f2:	4f 92       	push	r4
    18f4:	5f 92       	push	r5
    18f6:	6f 92       	push	r6
    18f8:	7f 92       	push	r7
    18fa:	8f 92       	push	r8
    18fc:	9f 92       	push	r9
    18fe:	af 92       	push	r10
    1900:	bf 92       	push	r11
    1902:	cf 92       	push	r12
    1904:	df 92       	push	r13
    1906:	ef 92       	push	r14
    1908:	ff 92       	push	r15
    190a:	0f 93       	push	r16
    190c:	1f 93       	push	r17
    190e:	cf 93       	push	r28
    1910:	df 93       	push	r29
    1912:	cd b7       	in	r28, 0x3d	; 61
    1914:	de b7       	in	r29, 0x3e	; 62
    1916:	ca 1b       	sub	r28, r26
    1918:	db 0b       	sbc	r29, r27
    191a:	cd bf       	out	0x3d, r28	; 61
    191c:	de bf       	out	0x3e, r29	; 62
    191e:	09 94       	ijmp

00001920 <__epilogue_restores__>:
    1920:	2a 88       	ldd	r2, Y+18	; 0x12
    1922:	39 88       	ldd	r3, Y+17	; 0x11
    1924:	48 88       	ldd	r4, Y+16	; 0x10
    1926:	5f 84       	ldd	r5, Y+15	; 0x0f
    1928:	6e 84       	ldd	r6, Y+14	; 0x0e
    192a:	7d 84       	ldd	r7, Y+13	; 0x0d
    192c:	8c 84       	ldd	r8, Y+12	; 0x0c
    192e:	9b 84       	ldd	r9, Y+11	; 0x0b
    1930:	aa 84       	ldd	r10, Y+10	; 0x0a
    1932:	b9 84       	ldd	r11, Y+9	; 0x09
    1934:	c8 84       	ldd	r12, Y+8	; 0x08
    1936:	df 80       	ldd	r13, Y+7	; 0x07
    1938:	ee 80       	ldd	r14, Y+6	; 0x06
    193a:	fd 80       	ldd	r15, Y+5	; 0x05
    193c:	0c 81       	ldd	r16, Y+4	; 0x04
    193e:	1b 81       	ldd	r17, Y+3	; 0x03
    1940:	aa 81       	ldd	r26, Y+2	; 0x02
    1942:	b9 81       	ldd	r27, Y+1	; 0x01
    1944:	ce 0f       	add	r28, r30
    1946:	d1 1d       	adc	r29, r1
    1948:	cd bf       	out	0x3d, r28	; 61
    194a:	de bf       	out	0x3e, r29	; 62
    194c:	ed 01       	movw	r28, r26
    194e:	08 95       	ret

00001950 <_exit>:
    1950:	f8 94       	cli

00001952 <__stop_program>:
    1952:	ff cf       	rjmp	.-2      	; 0x1952 <__stop_program>
