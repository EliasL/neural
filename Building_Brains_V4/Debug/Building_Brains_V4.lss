
Building_Brains_V4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000016  00803e00  00001cab  00001d5f  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001c6a  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000041  00009c6a  00001c6a  00001d1e  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .bss          0000005f  00803e16  00803e16  00001d75  2**0
                  ALLOC
  4 .comment      0000005c  00000000  00000000  00001d75  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001dd4  2**2
                  CONTENTS, READONLY
  6 .debug_aranges 000004b8  00000000  00000000  00001e10  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   000076d3  00000000  00000000  000022c8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00002fdb  00000000  00000000  0000999b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000026be  00000000  00000000  0000c976  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000870  00000000  00000000  0000f034  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00002f5a  00000000  00000000  0000f8a4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00001494  00000000  00000000  000127fe  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000350  00000000  00000000  00013c92  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	96 c0       	rjmp	.+300    	; 0x12e <__ctors_end>
       2:	b0 c0       	rjmp	.+352    	; 0x164 <__bad_interrupt>
       4:	af c0       	rjmp	.+350    	; 0x164 <__bad_interrupt>
       6:	ae c0       	rjmp	.+348    	; 0x164 <__bad_interrupt>
       8:	ad c0       	rjmp	.+346    	; 0x164 <__bad_interrupt>
       a:	ac c0       	rjmp	.+344    	; 0x164 <__bad_interrupt>
       c:	c4 c5       	rjmp	.+2952   	; 0xb96 <__vector_6>
       e:	aa c0       	rjmp	.+340    	; 0x164 <__bad_interrupt>
      10:	a9 c0       	rjmp	.+338    	; 0x164 <__bad_interrupt>
      12:	a8 c0       	rjmp	.+336    	; 0x164 <__bad_interrupt>
      14:	a7 c0       	rjmp	.+334    	; 0x164 <__bad_interrupt>
      16:	a6 c0       	rjmp	.+332    	; 0x164 <__bad_interrupt>
      18:	a5 c0       	rjmp	.+330    	; 0x164 <__bad_interrupt>
      1a:	a4 c0       	rjmp	.+328    	; 0x164 <__bad_interrupt>
      1c:	a3 c0       	rjmp	.+326    	; 0x164 <__bad_interrupt>
      1e:	a2 c0       	rjmp	.+324    	; 0x164 <__bad_interrupt>
      20:	a1 c0       	rjmp	.+322    	; 0x164 <__bad_interrupt>
      22:	a0 c0       	rjmp	.+320    	; 0x164 <__bad_interrupt>
      24:	9f c0       	rjmp	.+318    	; 0x164 <__bad_interrupt>
      26:	9e c0       	rjmp	.+316    	; 0x164 <__bad_interrupt>
      28:	9d c0       	rjmp	.+314    	; 0x164 <__bad_interrupt>
      2a:	9c c0       	rjmp	.+312    	; 0x164 <__bad_interrupt>
      2c:	9b c0       	rjmp	.+310    	; 0x164 <__bad_interrupt>
      2e:	9a c0       	rjmp	.+308    	; 0x164 <__bad_interrupt>
      30:	99 c0       	rjmp	.+306    	; 0x164 <__bad_interrupt>
      32:	98 c0       	rjmp	.+304    	; 0x164 <__bad_interrupt>

00000034 <__trampolines_end>:
      34:	00 40       	sbci	r16, 0x00	; 0
      36:	7a 10       	cpse	r7, r10
      38:	f3 5a       	subi	r31, 0xA3	; 163
      3a:	00 a0       	ldd	r0, Z+32	; 0x20
      3c:	72 4e       	sbci	r23, 0xE2	; 226
      3e:	18 09       	sbc	r17, r8
      40:	00 10       	cpse	r0, r0
      42:	a5 d4       	rcall	.+2378   	; 0x98e <tinyAxon_update_potential+0x15c>
      44:	e8 00       	.word	0x00e8	; ????
      46:	00 e8       	ldi	r16, 0x80	; 128
      48:	76 48       	sbci	r23, 0x86	; 134
      4a:	17 00       	.word	0x0017	; ????
      4c:	00 e4       	ldi	r16, 0x40	; 64
      4e:	0b 54       	subi	r16, 0x4B	; 75
      50:	02 00       	.word	0x0002	; ????
      52:	00 ca       	rjmp	.-3072   	; 0xfffff454 <__eeprom_end+0xff7ef454>
      54:	9a 3b       	cpi	r25, 0xBA	; 186
      56:	00 00       	nop
      58:	00 e1       	ldi	r16, 0x10	; 16
      5a:	f5 05       	cpc	r31, r5
      5c:	00 00       	nop
      5e:	80 96       	adiw	r24, 0x20	; 32
      60:	98 00       	.word	0x0098	; ????
      62:	00 00       	nop
      64:	40 42       	sbci	r20, 0x20	; 32
      66:	0f 00       	.word	0x000f	; ????
      68:	00 00       	nop
      6a:	a0 86       	std	Z+8, r10	; 0x08
      6c:	01 00       	.word	0x0001	; ????
      6e:	00 00       	nop
      70:	10 27       	eor	r17, r16
      72:	00 00       	nop
      74:	00 00       	nop
      76:	e8 03       	fmulsu	r22, r16
      78:	00 00       	nop
      7a:	00 00       	nop
      7c:	64 00       	.word	0x0064	; ????
      7e:	00 00       	nop
      80:	00 00       	nop
      82:	0a 00       	.word	0x000a	; ????
      84:	00 00       	nop
      86:	00 00       	nop
      88:	01 00       	.word	0x0001	; ????
      8a:	00 00       	nop
      8c:	00 00       	nop
      8e:	2c 76       	andi	r18, 0x6C	; 108
      90:	d8 88       	ldd	r13, Y+16	; 0x10
      92:	dc 67       	ori	r29, 0x7C	; 124
      94:	4f 08       	sbc	r4, r15
      96:	23 df       	rcall	.-442    	; 0xfffffede <__eeprom_end+0xff7efede>
      98:	c1 df       	rcall	.-126    	; 0x1c <__FUSE_REGION_LENGTH__+0x13>
      9a:	ae 59       	subi	r26, 0x9E	; 158
      9c:	e1 b1       	in	r30, 0x01	; 1
      9e:	b7 96       	adiw	r30, 0x27	; 39
      a0:	e5 e3       	ldi	r30, 0x35	; 53
      a2:	e4 53       	subi	r30, 0x34	; 52
      a4:	c6 3a       	cpi	r28, 0xA6	; 166
      a6:	e6 51       	subi	r30, 0x16	; 22
      a8:	99 76       	andi	r25, 0x69	; 105
      aa:	96 e8       	ldi	r25, 0x86	; 134
      ac:	e6 c2       	rjmp	.+1484   	; 0x67a <potential_to_RGB_update_LEDs+0xd8>
      ae:	84 26       	eor	r8, r20
      b0:	eb 89       	ldd	r30, Y+19	; 0x13
      b2:	8c 9b       	sbis	0x11, 4	; 17
      b4:	62 ed       	ldi	r22, 0xD2	; 210
      b6:	40 7c       	andi	r20, 0xC0	; 192
      b8:	6f fc       	.word	0xfc6f	; ????
      ba:	ef bc       	out	0x2f, r14	; 47
      bc:	9c 9f       	mul	r25, r28
      be:	40 f2       	brcs	.-112    	; 0x50 <__SREG__+0x11>
      c0:	ba a5       	ldd	r27, Y+42	; 0x2a
      c2:	6f a5       	ldd	r22, Y+47	; 0x2f
      c4:	f4 90       	lpm	r15, Z
      c6:	05 5a       	subi	r16, 0xA5	; 165
      c8:	2a f7       	brpl	.-54     	; 0x94 <__SREG__+0x55>
      ca:	5c 93       	st	X, r21
      cc:	6b 6c       	ori	r22, 0xCB	; 203
      ce:	f9 67       	ori	r31, 0x79	; 121
      d0:	6d c1       	rjmp	.+730    	; 0x3ac <USART_0_init+0x16>
      d2:	1b fc       	.word	0xfc1b	; ????
      d4:	e0 e4       	ldi	r30, 0x40	; 64
      d6:	0d 47       	sbci	r16, 0x7D	; 125
      d8:	fe f5       	brtc	.+126    	; 0x158 <.do_clear_bss_loop>
      da:	20 e6       	ldi	r18, 0x60	; 96
      dc:	b5 00       	.word	0x00b5	; ????
      de:	d0 ed       	ldi	r29, 0xD0	; 208
      e0:	90 2e       	mov	r9, r16
      e2:	03 00       	.word	0x0003	; ????
      e4:	94 35       	cpi	r25, 0x54	; 84
      e6:	77 05       	cpc	r23, r7
      e8:	00 80       	ld	r0, Z
      ea:	84 1e       	adc	r8, r20
      ec:	08 00       	.word	0x0008	; ????
      ee:	00 20       	and	r0, r0
      f0:	4e 0a       	sbc	r4, r30
      f2:	00 00       	nop
      f4:	00 c8       	rjmp	.-4096   	; 0xfffff0f6 <__eeprom_end+0xff7ef0f6>
      f6:	0c 33       	cpi	r16, 0x3C	; 60
      f8:	33 33       	cpi	r19, 0x33	; 51
      fa:	33 0f       	add	r19, r19
      fc:	98 6e       	ori	r25, 0xE8	; 232
      fe:	12 83       	std	Z+2, r17	; 0x02
     100:	11 41       	sbci	r17, 0x11	; 17
     102:	ef 8d       	ldd	r30, Y+31	; 0x1f
     104:	21 14       	cp	r2, r1
     106:	89 3b       	cpi	r24, 0xB9	; 185
     108:	e6 55       	subi	r30, 0x56	; 86
     10a:	16 cf       	rjmp	.-468    	; 0xffffff38 <__eeprom_end+0xff7eff38>
     10c:	fe e6       	ldi	r31, 0x6E	; 110
     10e:	db 18       	sub	r13, r11
     110:	d1 84       	ldd	r13, Z+9	; 0x09
     112:	4b 38       	cpi	r20, 0x8B	; 139
     114:	1b f7       	brvc	.-58     	; 0xdc <__SREG__+0x9d>
     116:	7c 1d       	adc	r23, r12
     118:	90 1d       	adc	r25, r0
     11a:	a4 bb       	out	0x14, r26	; 20
     11c:	e4 24       	eor	r14, r4
     11e:	20 32       	cpi	r18, 0x20	; 32
     120:	84 72       	andi	r24, 0x24	; 36
     122:	5e 22       	and	r5, r30
     124:	81 00       	.word	0x0081	; ????
     126:	c9 f1       	breq	.+114    	; 0x19a <ADC_get_conversion+0x1e>
     128:	24 ec       	ldi	r18, 0xC4	; 196
     12a:	a1 e5       	ldi	r26, 0x51	; 81
     12c:	3d 27       	eor	r19, r29

0000012e <__ctors_end>:
     12e:	11 24       	eor	r1, r1
     130:	1f be       	out	0x3f, r1	; 63
     132:	cf ef       	ldi	r28, 0xFF	; 255
     134:	cd bf       	out	0x3d, r28	; 61
     136:	df e3       	ldi	r29, 0x3F	; 63
     138:	de bf       	out	0x3e, r29	; 62

0000013a <__do_copy_data>:
     13a:	1e e3       	ldi	r17, 0x3E	; 62
     13c:	a0 e0       	ldi	r26, 0x00	; 0
     13e:	be e3       	ldi	r27, 0x3E	; 62
     140:	eb ea       	ldi	r30, 0xAB	; 171
     142:	fc e1       	ldi	r31, 0x1C	; 28
     144:	02 c0       	rjmp	.+4      	; 0x14a <__do_copy_data+0x10>
     146:	05 90       	lpm	r0, Z+
     148:	0d 92       	st	X+, r0
     14a:	a6 31       	cpi	r26, 0x16	; 22
     14c:	b1 07       	cpc	r27, r17
     14e:	d9 f7       	brne	.-10     	; 0x146 <__do_copy_data+0xc>

00000150 <__do_clear_bss>:
     150:	2e e3       	ldi	r18, 0x3E	; 62
     152:	a6 e1       	ldi	r26, 0x16	; 22
     154:	be e3       	ldi	r27, 0x3E	; 62
     156:	01 c0       	rjmp	.+2      	; 0x15a <.do_clear_bss_start>

00000158 <.do_clear_bss_loop>:
     158:	1d 92       	st	X+, r1

0000015a <.do_clear_bss_start>:
     15a:	a5 37       	cpi	r26, 0x75	; 117
     15c:	b2 07       	cpc	r27, r18
     15e:	e1 f7       	brne	.-8      	; 0x158 <.do_clear_bss_loop>
     160:	f4 d1       	rcall	.+1000   	; 0x54a <main>
     162:	81 cd       	rjmp	.-1278   	; 0xfffffc66 <__eeprom_end+0xff7efc66>

00000164 <__bad_interrupt>:
     164:	4d cf       	rjmp	.-358    	; 0x0 <__vectors>

00000166 <atmel_start_init>:
/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
	system_init();
     166:	c2 d0       	rcall	.+388    	; 0x2ec <system_init>
     168:	08 95       	ret

0000016a <ADC_init>:
 * \return Conversion result read from the ADC ADC module
 */
adc_result_t ADC_get_conversion_result(void)
{
	return (ADC0.RES);
}
     16a:	85 e0       	ldi	r24, 0x05	; 5
     16c:	80 93 00 06 	sts	0x0600, r24	; 0x800600 <__TEXT_REGION_LENGTH__+0x700600>
     170:	80 e0       	ldi	r24, 0x00	; 0
     172:	08 95       	ret

00000174 <ADC_is_conversion_done>:
     174:	80 91 0b 06 	lds	r24, 0x060B	; 0x80060b <__TEXT_REGION_LENGTH__+0x70060b>
     178:	81 70       	andi	r24, 0x01	; 1
     17a:	08 95       	ret

0000017c <ADC_get_conversion>:
 *
 * \return Nothing
 */
void ADC_start_conversion(adc_0_channel_t channel)
{
	ADC0.MUXPOS  = channel;
     17c:	e0 e0       	ldi	r30, 0x00	; 0
     17e:	f6 e0       	ldi	r31, 0x06	; 6
     180:	86 83       	std	Z+6, r24	; 0x06
	ADC0.COMMAND = ADC_STCONV_bm;
     182:	81 e0       	ldi	r24, 0x01	; 1
     184:	80 87       	std	Z+8, r24	; 0x08
adc_result_t ADC_get_conversion(adc_0_channel_t channel)
{
	adc_result_t res;

	ADC_start_conversion(channel);
	while (!ADC_is_conversion_done())
     186:	f6 df       	rcall	.-20     	; 0x174 <ADC_is_conversion_done>
     188:	88 23       	and	r24, r24
     18a:	e9 f3       	breq	.-6      	; 0x186 <ADC_get_conversion+0xa>
 *
 * \return Conversion result read from the ADC ADC module
 */
adc_result_t ADC_get_conversion_result(void)
{
	return (ADC0.RES);
     18c:	e0 e0       	ldi	r30, 0x00	; 0
     18e:	f6 e0       	ldi	r31, 0x06	; 6
     190:	20 89       	ldd	r18, Z+16	; 0x10
     192:	31 89       	ldd	r19, Z+17	; 0x11

	ADC_start_conversion(channel);
	while (!ADC_is_conversion_done())
		;
	res = ADC_get_conversion_result();
	ADC0.INTFLAGS |= ADC_RESRDY_bm;
     194:	93 85       	ldd	r25, Z+11	; 0x0b
     196:	91 60       	ori	r25, 0x01	; 1
     198:	93 87       	std	Z+11, r25	; 0x0b
	return res;
}
     19a:	c9 01       	movw	r24, r18
     19c:	08 95       	ret

0000019e <BOD_init>:
	//		 | BOD_VLMCFG_ABOVE_gc; /* Interrupt when supply goes above VLM level */

	// BOD.VLMCTRLA = BOD_VLMLVL_5ABOVE_gc; /* VLM threshold 5% above BOD level */

	return 0;
}
     19e:	80 e0       	ldi	r24, 0x00	; 0
     1a0:	08 95       	ret

000001a2 <DIGGSIGG_init>:
	//		 | CCL_EDGEDET_DIS_gc /* Edge detector is disabled */
	//		 | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	//		 | 0 << CCL_ENABLE_bp /* LUT Enable: disabled */
	//		 | 0 << CCL_OUTEN_bp; /* Output Enable: disabled */

	CCL.TRUTH1 = 168; /* Truth 1: 168 */
     1a2:	e0 ec       	ldi	r30, 0xC0	; 192
     1a4:	f1 e0       	ldi	r31, 0x01	; 1
     1a6:	88 ea       	ldi	r24, 0xA8	; 168
     1a8:	84 87       	std	Z+12, r24	; 0x0c

	CCL.LUT1CTRLC = CCL_INSEL2_TCA0_gc /* TCA0 WO2 input source */;
     1aa:	88 e0       	ldi	r24, 0x08	; 8
     1ac:	83 87       	std	Z+11, r24	; 0x0b

	CCL.LUT1CTRLB = CCL_INSEL0_SPI0_gc /* SPI0 SCK source */
     1ae:	8b eb       	ldi	r24, 0xBB	; 187
     1b0:	82 87       	std	Z+10, r24	; 0x0a
	                | CCL_INSEL1_SPI0_gc /* SPI0 MOSI input source */;

	CCL.LUT1CTRLA = 0 << CCL_CLKSRC_bp       /* Clock Source Selection: disabled */
     1b2:	89 e0       	ldi	r24, 0x09	; 9
     1b4:	81 87       	std	Z+9, r24	; 0x09
	                | CCL_EDGEDET_DIS_gc     /* Edge detector is disabled */
	                | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	                | 1 << CCL_ENABLE_bp     /* LUT Enable: enabled */
	                | 1 << CCL_OUTEN_bp;     /* Output Enable: enabled */

	CCL.CTRLA = 1 << CCL_ENABLE_bp      /* Enable: enabled */
     1b6:	81 e4       	ldi	r24, 0x41	; 65
     1b8:	80 83       	st	Z, r24
	            | 1 << CCL_RUNSTDBY_bp; /* Run in Standby: enabled */

	return 0;
}
     1ba:	80 e0       	ldi	r24, 0x00	; 0
     1bc:	08 95       	ret

000001be <CLKCTRL_init>:
 *       on calling convention. The memory model is not visible to the
 *       preprocessor, so it must be defined in the Assembler preprocessor directives.
 */
static inline void ccp_write_io(void *addr, uint8_t value)
{
	protected_write_io(addr, CCP_IOREG_gc, value);
     1be:	47 e0       	ldi	r20, 0x07	; 7
     1c0:	68 ed       	ldi	r22, 0xD8	; 216
     1c2:	8c e7       	ldi	r24, 0x7C	; 124
     1c4:	90 e0       	ldi	r25, 0x00	; 0
     1c6:	ad d0       	rcall	.+346    	; 0x322 <protected_write_io>
     1c8:	41 e0       	ldi	r20, 0x01	; 1
     1ca:	68 ed       	ldi	r22, 0xD8	; 216
     1cc:	81 e6       	ldi	r24, 0x61	; 97
     1ce:	90 e0       	ldi	r25, 0x00	; 0
     1d0:	a8 d0       	rcall	.+336    	; 0x322 <protected_write_io>
	//		 | 0 << CLKCTRL_CLKOUT_bp /* System clock out: disabled */);

	// ccp_write_io((void*)&(CLKCTRL.MCLKLOCK),0 << CLKCTRL_LOCKEN_bp /* lock enable: disabled */);

	return 0;
}
     1d2:	80 e0       	ldi	r24, 0x00	; 0
     1d4:	08 95       	ret

000001d6 <CPUINT_init>:

	// CPUINT.LVL0PRI = 0x0 << CPUINT_LVL0PRI_gp; /* Interrupt Level Priority: 0x0 */

	// CPUINT.LVL1VEC = 0x0 << CPUINT_LVL1VEC_gp; /* Interrupt Vector with High Priority: 0x0 */

	ENABLE_INTERRUPTS();
     1d6:	78 94       	sei

	return 0;
}
     1d8:	80 e0       	ldi	r24, 0x00	; 0
     1da:	08 95       	ret

000001dc <DAC_init>:
 *
 * \return Nothing
 */
void DAC_disable()
{
	DAC0.CTRLA &= ~DAC_ENABLE_bm;
     1dc:	81 e4       	ldi	r24, 0x41	; 65
     1de:	80 93 80 06 	sts	0x0680, r24	; 0x800680 <__TEXT_REGION_LENGTH__+0x700680>
     1e2:	80 e0       	ldi	r24, 0x00	; 0
     1e4:	08 95       	ret

000001e6 <DAC_set_output>:
 *
 * \return Nothing
 */
void DAC_set_output(dac_resolution_t value)
{
	DAC0.DATA = value;
     1e6:	80 93 81 06 	sts	0x0681, r24	; 0x800681 <__TEXT_REGION_LENGTH__+0x700681>
     1ea:	08 95       	ret

000001ec <mcu_init>:
#ifdef __cplusplus
extern "C" {
#endif

void mcu_init(void)
{
     1ec:	e0 e1       	ldi	r30, 0x10	; 16
     1ee:	f4 e0       	ldi	r31, 0x04	; 4
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     1f0:	80 81       	ld	r24, Z
     1f2:	88 60       	ori	r24, 0x08	; 8
     1f4:	81 93       	st	Z+, r24
	 * disables all peripherals to save power. Driver shall enable
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
     1f6:	e8 31       	cpi	r30, 0x18	; 24
     1f8:	84 e0       	ldi	r24, 0x04	; 4
     1fa:	f8 07       	cpc	r31, r24
     1fc:	c9 f7       	brne	.-14     	; 0x1f0 <mcu_init+0x4>
     1fe:	e0 e3       	ldi	r30, 0x30	; 48
     200:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     202:	80 81       	ld	r24, Z
     204:	88 60       	ori	r24, 0x08	; 8
     206:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     208:	e8 33       	cpi	r30, 0x38	; 56
     20a:	84 e0       	ldi	r24, 0x04	; 4
     20c:	f8 07       	cpc	r31, r24
     20e:	c9 f7       	brne	.-14     	; 0x202 <mcu_init+0x16>
     210:	e0 e5       	ldi	r30, 0x50	; 80
     212:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     214:	80 81       	ld	r24, Z
     216:	88 60       	ori	r24, 0x08	; 8
     218:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     21a:	e8 35       	cpi	r30, 0x58	; 88
     21c:	84 e0       	ldi	r24, 0x04	; 4
     21e:	f8 07       	cpc	r31, r24
     220:	c9 f7       	brne	.-14     	; 0x214 <mcu_init+0x28>
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}
}
     222:	08 95       	ret

00000224 <ADC_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     224:	e5 e1       	ldi	r30, 0x15	; 21
     226:	f4 e0       	ldi	r31, 0x04	; 4
     228:	80 81       	ld	r24, Z
     22a:	88 7f       	andi	r24, 0xF8	; 248
     22c:	84 60       	ori	r24, 0x04	; 4
     22e:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     230:	80 81       	ld	r24, Z
     232:	87 7f       	andi	r24, 0xF7	; 247
     234:	80 83       	st	Z, r24
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     236:	e7 e1       	ldi	r30, 0x17	; 23
     238:	f4 e0       	ldi	r31, 0x04	; 4
     23a:	80 81       	ld	r24, Z
     23c:	88 7f       	andi	r24, 0xF8	; 248
     23e:	84 60       	ori	r24, 0x04	; 4
     240:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     242:	80 81       	ld	r24, Z
     244:	87 7f       	andi	r24, 0xF7	; 247
     246:	80 83       	st	Z, r24
 */
static inline void PORTB_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     248:	e4 e3       	ldi	r30, 0x34	; 52
     24a:	f4 e0       	ldi	r31, 0x04	; 4
     24c:	80 81       	ld	r24, Z
     24e:	88 7f       	andi	r24, 0xF8	; 248
     250:	84 60       	ori	r24, 0x04	; 4
     252:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     254:	80 81       	ld	r24, Z
     256:	87 7f       	andi	r24, 0xF7	; 247
     258:	80 83       	st	Z, r24
 */
static inline void PORTB_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     25a:	e1 e3       	ldi	r30, 0x31	; 49
     25c:	f4 e0       	ldi	r31, 0x04	; 4
     25e:	80 81       	ld	r24, Z
     260:	88 7f       	andi	r24, 0xF8	; 248
     262:	84 60       	ori	r24, 0x04	; 4
     264:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     266:	80 81       	ld	r24, Z
     268:	87 7f       	andi	r24, 0xF7	; 247
     26a:	80 83       	st	Z, r24
 */
static inline void PORTB_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     26c:	e0 e3       	ldi	r30, 0x30	; 48
     26e:	f4 e0       	ldi	r31, 0x04	; 4
     270:	80 81       	ld	r24, Z
     272:	88 7f       	andi	r24, 0xF8	; 248
     274:	84 60       	ori	r24, 0x04	; 4
     276:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     278:	80 81       	ld	r24, Z
     27a:	87 7f       	andi	r24, 0xF7	; 247
     27c:	80 83       	st	Z, r24
	// Disable digital input buffer
	DEN4_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	DEN4_PIN_set_pull_mode(PORT_PULL_OFF);

	ADC_init();
     27e:	75 df       	rcall	.-278    	; 0x16a <ADC_init>
     280:	08 95       	ret

00000282 <USART_0_initialization>:
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     282:	23 98       	cbi	0x04, 3	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     284:	e3 e3       	ldi	r30, 0x33	; 51
     286:	f4 e0       	ldi	r31, 0x04	; 4
     288:	80 81       	ld	r24, Z
     28a:	87 7f       	andi	r24, 0xF7	; 247
     28c:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     28e:	22 9a       	sbi	0x04, 2	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     290:	2a 98       	cbi	0x05, 2	; 5
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	USART_0_init();
     292:	81 d0       	rcall	.+258    	; 0x396 <USART_0_init>
     294:	08 95       	ret

00000296 <TIMER_0_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     296:	25 9a       	sbi	0x04, 5	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     298:	2d 98       	cbi	0x05, 5	; 5
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLC |= PORTMUX_TCA02_bm;
     29a:	e0 e0       	ldi	r30, 0x00	; 0
     29c:	f2 e0       	ldi	r31, 0x02	; 2
     29e:	82 81       	ldd	r24, Z+2	; 0x02
     2a0:	84 60       	ori	r24, 0x04	; 4
     2a2:	82 83       	std	Z+2, r24	; 0x02

	TIMER_0_init();
     2a4:	68 d0       	rcall	.+208    	; 0x376 <TIMER_0_init>
     2a6:	08 95       	ret

000002a8 <DIGGSIGG_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTC.DIR |= (1 << pin);
     2a8:	41 9a       	sbi	0x08, 1	; 8
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
	} else {
		VPORTC.OUT &= ~(1 << pin);
     2aa:	49 98       	cbi	0x09, 1	; 9
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLA |= PORTMUX_LUT1_bm;
     2ac:	e0 e0       	ldi	r30, 0x00	; 0
     2ae:	f2 e0       	ldi	r31, 0x02	; 2
     2b0:	80 81       	ld	r24, Z
     2b2:	80 62       	ori	r24, 0x20	; 32
     2b4:	80 83       	st	Z, r24

	DIGGSIGG_init();
     2b6:	75 df       	rcall	.-278    	; 0x1a2 <DIGGSIGG_init>
     2b8:	08 95       	ret

000002ba <SPI_0_initialization>:
 */
static inline void PORTA_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
     2ba:	02 98       	cbi	0x00, 2	; 0
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2bc:	e2 e1       	ldi	r30, 0x12	; 18
     2be:	f4 e0       	ldi	r31, 0x04	; 4
     2c0:	80 81       	ld	r24, Z
     2c2:	87 7f       	andi	r24, 0xF7	; 247
     2c4:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     2c6:	01 9a       	sbi	0x00, 1	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     2c8:	09 98       	cbi	0x01, 1	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     2ca:	03 9a       	sbi	0x00, 3	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     2cc:	0b 98       	cbi	0x01, 3	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     2ce:	04 9a       	sbi	0x00, 4	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     2d0:	0c 98       	cbi	0x01, 4	; 1
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	SPI_0_init();
     2d2:	49 d0       	rcall	.+146    	; 0x366 <SPI_0_init>
     2d4:	08 95       	ret

000002d6 <DAC_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     2d6:	e6 e1       	ldi	r30, 0x16	; 22
     2d8:	f4 e0       	ldi	r31, 0x04	; 4
     2da:	80 81       	ld	r24, Z
     2dc:	88 7f       	andi	r24, 0xF8	; 248
     2de:	84 60       	ori	r24, 0x04	; 4
     2e0:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2e2:	80 81       	ld	r24, Z
     2e4:	87 7f       	andi	r24, 0xF7	; 247
     2e6:	80 83       	st	Z, r24
	// Disable digital input buffer
	AXON_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	AXON_PIN_set_pull_mode(PORT_PULL_OFF);

	DAC_init();
     2e8:	79 df       	rcall	.-270    	; 0x1dc <DAC_init>
     2ea:	08 95       	ret

000002ec <system_init>:
/**
 * \brief System initialization
 */
void system_init()
{
	mcu_init();
     2ec:	7f df       	rcall	.-258    	; 0x1ec <mcu_init>
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     2ee:	27 98       	cbi	0x04, 7	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2f0:	e7 e3       	ldi	r30, 0x37	; 55
     2f2:	f4 e0       	ldi	r31, 0x04	; 4
     2f4:	80 81       	ld	r24, Z
     2f6:	87 7f       	andi	r24, 0xF7	; 247
     2f8:	80 83       	st	Z, r24
 */
static inline void PORTC_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
     2fa:	42 98       	cbi	0x08, 2	; 8
static inline void PORTC_set_pin_pull_mode(const uint8_t pin, const enum port_pull_mode pull_mode)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
     2fc:	e2 e5       	ldi	r30, 0x52	; 82
     2fe:	f4 e0       	ldi	r31, 0x04	; 4
     300:	80 81       	ld	r24, Z
     302:	88 60       	ori	r24, 0x08	; 8
     304:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTC.DIR |= (1 << pin);
     306:	45 9a       	sbi	0x08, 5	; 8
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     308:	4d 9a       	sbi	0x09, 5	; 9
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    true);

	CLKCTRL_init();
     30a:	59 df       	rcall	.-334    	; 0x1be <CLKCTRL_init>

	RTC_init();
     30c:	0e d0       	rcall	.+28     	; 0x32a <RTC_init>

	ADC_initialization();
     30e:	8a df       	rcall	.-236    	; 0x224 <ADC_initialization>

	USART_0_initialization();
     310:	b8 df       	rcall	.-144    	; 0x282 <USART_0_initialization>

	TIMER_0_initialization();
     312:	c1 df       	rcall	.-126    	; 0x296 <TIMER_0_initialization>

	DIGGSIGG_initialization();
     314:	c9 df       	rcall	.-110    	; 0x2a8 <DIGGSIGG_initialization>

	SPI_0_initialization();
     316:	d1 df       	rcall	.-94     	; 0x2ba <SPI_0_initialization>

	DAC_initialization();
     318:	de df       	rcall	.-68     	; 0x2d6 <DAC_initialization>

	CPUINT_init();
     31a:	5d df       	rcall	.-326    	; 0x1d6 <CPUINT_init>

	SLPCTRL_init();
     31c:	22 d0       	rcall	.+68     	; 0x362 <SLPCTRL_init>

	BOD_init();
     31e:	3f df       	rcall	.-386    	; 0x19e <BOD_init>
     320:	08 95       	ret

00000322 <protected_write_io>:
#if defined(__GNUC__)
  
#ifdef RAMPZ
	out     _SFR_IO_ADDR(RAMPZ), r1         // Clear bits 23:16 of Z
#endif
	movw    r30, r24                // Load addr into Z
     322:	fc 01       	movw	r30, r24
	out     CCP, r22                // Start CCP handshake
     324:	64 bf       	out	0x34, r22	; 52
	st      Z, r20                  // Write value to I/O register
     326:	40 83       	st	Z, r20
	ret                             // Return to caller
     328:	08 95       	ret

0000032a <RTC_init>:
 * \return Initialization status.
 */
int8_t RTC_init()
{

	while (RTC.STATUS > 0) { /* Wait for all register to be synchronized */
     32a:	e0 e4       	ldi	r30, 0x40	; 64
     32c:	f1 e0       	ldi	r31, 0x01	; 1
     32e:	81 81       	ldd	r24, Z+1	; 0x01
     330:	81 11       	cpse	r24, r1
     332:	fd cf       	rjmp	.-6      	; 0x32e <RTC_init+0x4>
	}

	// RTC.CMP = 0x0; /* Compare: 0x0 */

	RTC.CNT = 0x20; /* Counter: 0x20 */
     334:	e0 e4       	ldi	r30, 0x40	; 64
     336:	f1 e0       	ldi	r31, 0x01	; 1
     338:	80 e2       	ldi	r24, 0x20	; 32
     33a:	90 e0       	ldi	r25, 0x00	; 0
     33c:	80 87       	std	Z+8, r24	; 0x08
     33e:	91 87       	std	Z+9, r25	; 0x09

	RTC.CTRLA = RTC_PRESCALER_DIV1_gc   /* 1 */
     340:	81 e8       	ldi	r24, 0x81	; 129
     342:	80 83       	st	Z, r24
	            | 1 << RTC_RTCEN_bp     /* Enable: enabled */
	            | 1 << RTC_RUNSTDBY_bp; /* Run In Standby: enabled */

	RTC.PER = 0x20 / TIMESCALE; /* Period: 0x20 */
     344:	80 e8       	ldi	r24, 0x80	; 128
     346:	9c e0       	ldi	r25, 0x0C	; 12
     348:	82 87       	std	Z+10, r24	; 0x0a
     34a:	93 87       	std	Z+11, r25	; 0x0b

	// RTC.CLKSEL = RTC_CLKSEL_INT32K_gc; /* 32KHz Internal Ultra Low Power Oscillator (OSCULP32K) */

	RTC.DBGCTRL = 1 << RTC_DBGRUN_bp; /* Run in debug: enabled */
     34c:	81 e0       	ldi	r24, 0x01	; 1
     34e:	85 83       	std	Z+5, r24	; 0x05

	RTC.INTCTRL = 0 << RTC_CMP_bp    /* Compare Match Interrupt enable: disabled */
     350:	82 83       	std	Z+2, r24	; 0x02
	              | 1 << RTC_OVF_bp; /* Overflow Interrupt enable: enabled */

	while (RTC.PITSTATUS > 0) { /* Wait for all register to be synchronized */
     352:	81 89       	ldd	r24, Z+17	; 0x11
     354:	81 11       	cpse	r24, r1
     356:	fd cf       	rjmp	.-6      	; 0x352 <RTC_init+0x28>
	}

	RTC.PITCTRLA = RTC_PERIOD_OFF_gc    /* Off */
     358:	81 e0       	ldi	r24, 0x01	; 1
     35a:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <__TEXT_REGION_LENGTH__+0x700150>
	// RTC.PITDBGCTRL = 0 << RTC_DBGRUN_bp; /* Run in debug: disabled */

	// RTC.PITINTCTRL = 0 << RTC_PI_bp; /* Periodic Interrupt: disabled */

	return 0;
}
     35e:	80 e0       	ldi	r24, 0x00	; 0
     360:	08 95       	ret

00000362 <SLPCTRL_init>:

	// SLPCTRL.CTRLA = 0 << SLPCTRL_SEN_bp /* Sleep enable: disabled */
	//		 | SLPCTRL_SMODE_IDLE_gc; /* Idle mode */

	return 0;
}
     362:	80 e0       	ldi	r24, 0x00	; 0
     364:	08 95       	ret

00000366 <SPI_0_init>:
 * \return Initialization status
 */
int8_t SPI_0_init()
{

	SPI0.CTRLA = 0 << SPI_CLK2X_bp     /* Enable Double Speed: disabled */
     366:	e0 e2       	ldi	r30, 0x20	; 32
     368:	f8 e0       	ldi	r31, 0x08	; 8
     36a:	83 e2       	ldi	r24, 0x23	; 35
     36c:	80 83       	st	Z, r24
	             | 0 << SPI_DORD_bp    /* Data Order Setting: disabled */
	             | 1 << SPI_ENABLE_bp  /* Enable Module: enabled */
	             | 1 << SPI_MASTER_bp  /* SPI module in master mode */
	             | SPI_PRESC_DIV16_gc; /* System Clock / 16 */

	SPI0.CTRLB = 0 << SPI_BUFEN_bp   /* Buffer Mode Enable: disabled */
     36e:	84 e0       	ldi	r24, 0x04	; 4
     370:	81 83       	std	Z+1, r24	; 0x01
	//		 | 0 << SPI_RXCIE_bp /* Receive Complete Interrupt Enable: disabled */
	//		 | 0 << SPI_SSIE_bp /* Slave Select Trigger Interrupt Enable: disabled */
	//		 | 0 << SPI_TXCIE_bp; /* Transfer Complete Interrupt Enable: disabled */

	return 0;
}
     372:	80 e0       	ldi	r24, 0x00	; 0
     374:	08 95       	ret

00000376 <TIMER_0_init>:

	// TCA0.SINGLE.CMP0 = 0x0; /* Compare Register 0: 0x0 */

	// TCA0.SINGLE.CMP1 = 0x0; /* Compare Register 1: 0x0 */

	TCA0.SINGLE.CMP2 = 0x4; /* Compare Register 2: 0x4 */
     376:	e0 e0       	ldi	r30, 0x00	; 0
     378:	fa e0       	ldi	r31, 0x0A	; 10
     37a:	84 e0       	ldi	r24, 0x04	; 4
     37c:	90 e0       	ldi	r25, 0x00	; 0
     37e:	84 a7       	std	Z+44, r24	; 0x2c
     380:	95 a7       	std	Z+45, r25	; 0x2d

	// TCA0.SINGLE.CNT = 0x0; /* Count: 0x0 */

	TCA0.SINGLE.CTRLB = 0 << TCA_SINGLE_ALUPD_bp            /* Auto Lock Update: disabled */
     382:	83 e4       	ldi	r24, 0x43	; 67
     384:	81 83       	std	Z+1, r24	; 0x01
	                    | 0 << TCA_SINGLE_CMP0EN_bp         /* Compare 0 Enable: disabled */
	                    | 0 << TCA_SINGLE_CMP1EN_bp         /* Compare 1 Enable: disabled */
	                    | 1 << TCA_SINGLE_CMP2EN_bp         /* Compare 2 Enable: enabled */
	                    | TCA_SINGLE_WGMODE_SINGLESLOPE_gc; /*  */

	TCA0.SINGLE.CTRLC = 0 << TCA_SINGLE_CMP0OV_bp    /* Compare 0 Waveform Output Value: disabled */
     386:	84 e0       	ldi	r24, 0x04	; 4
     388:	82 83       	std	Z+2, r24	; 0x02
	// TCA0.SINGLE.INTCTRL = 0 << TCA_SINGLE_CMP0_bp /* Compare 0 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP1_bp /* Compare 1 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP2_bp /* Compare 2 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_OVF_bp; /* Overflow Interrupt: disabled */

	TCA0.SINGLE.PER = 0x7; /* Period: 0x7 */
     38a:	87 e0       	ldi	r24, 0x07	; 7
     38c:	90 e0       	ldi	r25, 0x00	; 0
     38e:	86 a3       	std	Z+38, r24	; 0x26
     390:	97 a3       	std	Z+39, r25	; 0x27

	// TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV1_gc /* System Clock */
	//		 | 0 << TCA_SINGLE_ENABLE_bp; /* Module Enable: disabled */

	return 0;
}
     392:	80 e0       	ldi	r24, 0x00	; 0
     394:	08 95       	ret

00000396 <USART_0_init>:
uint8_t USART_0_read()
{
	while (!(USART0.STATUS & USART_RXCIF_bm))
		;
	return USART0.RXDATAL;
}
     396:	e0 e0       	ldi	r30, 0x00	; 0
     398:	f8 e0       	ldi	r31, 0x08	; 8
     39a:	87 e4       	ldi	r24, 0x47	; 71
     39c:	90 e1       	ldi	r25, 0x10	; 16
     39e:	80 87       	std	Z+8, r24	; 0x08
     3a0:	91 87       	std	Z+9, r25	; 0x09
     3a2:	80 ec       	ldi	r24, 0xC0	; 192
     3a4:	86 83       	std	Z+6, r24	; 0x06
     3a6:	80 e0       	ldi	r24, 0x00	; 0
     3a8:	9e e3       	ldi	r25, 0x3E	; 62
     3aa:	80 93 71 3e 	sts	0x3E71, r24	; 0x803e71 <__iob+0x2>
     3ae:	90 93 72 3e 	sts	0x3E72, r25	; 0x803e72 <__iob+0x3>
     3b2:	80 e0       	ldi	r24, 0x00	; 0
     3b4:	08 95       	ret

000003b6 <USART_0_write>:
 *
 * \return Nothing
 */
void USART_0_write(const uint8_t data)
{
	while (!(USART0.STATUS & USART_DREIF_bm))
     3b6:	e0 e0       	ldi	r30, 0x00	; 0
     3b8:	f8 e0       	ldi	r31, 0x08	; 8
     3ba:	94 81       	ldd	r25, Z+4	; 0x04
     3bc:	95 ff       	sbrs	r25, 5
     3be:	fd cf       	rjmp	.-6      	; 0x3ba <USART_0_write+0x4>
		;
	USART0.TXDATAL = data;
     3c0:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <__TEXT_REGION_LENGTH__+0x700802>
     3c4:	08 95       	ret

000003c6 <USART_0_printCHAR>:

#if defined(__GNUC__)

int USART_0_printCHAR(char character, FILE *stream)
{
	USART_0_write(character);
     3c6:	f7 df       	rcall	.-18     	; 0x3b6 <USART_0_write>
	return 0;
}
     3c8:	80 e0       	ldi	r24, 0x00	; 0
     3ca:	90 e0       	ldi	r25, 0x00	; 0
     3cc:	08 95       	ret

000003ce <tinyCharge_is_charging>:
_Bool charging;

_Bool tinyCharge_is_charging(){
	return false;
	//return charging;
}
     3ce:	80 e0       	ldi	r24, 0x00	; 0
     3d0:	08 95       	ret

000003d2 <tinyCharge_set_charging>:

void tinyCharge_set_charging(_Bool charging_status){
	charging = charging_status;
     3d2:	80 93 6e 3e 	sts	0x3E6E, r24	; 0x803e6e <charging>
     3d6:	08 95       	ret

000003d8 <tinyCharge_set_transistors>:
}


void tinyCharge_set_transistors(){
	if(charging){
     3d8:	80 91 6e 3e 	lds	r24, 0x3E6E	; 0x803e6e <charging>
     3dc:	88 23       	and	r24, r24
     3de:	11 f0       	breq	.+4      	; 0x3e4 <tinyCharge_set_transistors+0xc>
	} else {
		VPORTC.OUT &= ~(1 << pin);
     3e0:	4d 98       	cbi	0x09, 5	; 9
     3e2:	08 95       	ret
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     3e4:	4d 9a       	sbi	0x09, 5	; 9
     3e6:	08 95       	ret

000003e8 <tinyDebugger_send_int>:
	dtostrf(value,1,NUMBER_OF_DECIMALS, number);
	printf("%s:%s;", name, number);
}
void tinyDebugger_send_string(const char* name, char * value){
	printf("%s:%s;", name, value);
}
     3e8:	7f 93       	push	r23
     3ea:	6f 93       	push	r22
     3ec:	9f 93       	push	r25
     3ee:	8f 93       	push	r24
     3f0:	8a e6       	ldi	r24, 0x6A	; 106
     3f2:	9c e9       	ldi	r25, 0x9C	; 156
     3f4:	9f 93       	push	r25
     3f6:	8f 93       	push	r24
     3f8:	11 d7       	rcall	.+3618   	; 0x121c <printf>
     3fa:	0f 90       	pop	r0
     3fc:	0f 90       	pop	r0
     3fe:	0f 90       	pop	r0
     400:	0f 90       	pop	r0
     402:	0f 90       	pop	r0
     404:	0f 90       	pop	r0
     406:	08 95       	ret

00000408 <tinyDebugger_send_uint8>:
     408:	1f 92       	push	r1
     40a:	6f 93       	push	r22
     40c:	9f 93       	push	r25
     40e:	8f 93       	push	r24
     410:	81 e7       	ldi	r24, 0x71	; 113
     412:	9c e9       	ldi	r25, 0x9C	; 156
     414:	9f 93       	push	r25
     416:	8f 93       	push	r24
     418:	01 d7       	rcall	.+3586   	; 0x121c <printf>
     41a:	0f 90       	pop	r0
     41c:	0f 90       	pop	r0
     41e:	0f 90       	pop	r0
     420:	0f 90       	pop	r0
     422:	0f 90       	pop	r0
     424:	0f 90       	pop	r0
     426:	08 95       	ret

00000428 <tinyDebugger_send_double>:
     428:	cf 92       	push	r12
     42a:	df 92       	push	r13
     42c:	ef 92       	push	r14
     42e:	ff 92       	push	r15
     430:	0f 93       	push	r16
     432:	1f 93       	push	r17
     434:	cf 93       	push	r28
     436:	df 93       	push	r29
     438:	cd b7       	in	r28, 0x3d	; 61
     43a:	de b7       	in	r29, 0x3e	; 62
     43c:	64 97       	sbiw	r28, 0x14	; 20
     43e:	cd bf       	out	0x3d, r28	; 61
     440:	de bf       	out	0x3e, r29	; 62
     442:	d8 2e       	mov	r13, r24
     444:	c9 2e       	mov	r12, r25
     446:	cb 01       	movw	r24, r22
     448:	ba 01       	movw	r22, r20
     44a:	9e 01       	movw	r18, r28
     44c:	2f 5f       	subi	r18, 0xFF	; 255
     44e:	3f 4f       	sbci	r19, 0xFF	; 255
     450:	79 01       	movw	r14, r18
     452:	89 01       	movw	r16, r18
     454:	21 e0       	ldi	r18, 0x01	; 1
     456:	41 e0       	ldi	r20, 0x01	; 1
     458:	c2 d6       	rcall	.+3460   	; 0x11de <dtostrf>
     45a:	ff 92       	push	r15
     45c:	ef 92       	push	r14
     45e:	cf 92       	push	r12
     460:	df 92       	push	r13
     462:	88 e7       	ldi	r24, 0x78	; 120
     464:	9c e9       	ldi	r25, 0x9C	; 156
     466:	9f 93       	push	r25
     468:	8f 93       	push	r24
     46a:	d8 d6       	rcall	.+3504   	; 0x121c <printf>
     46c:	0f 90       	pop	r0
     46e:	0f 90       	pop	r0
     470:	0f 90       	pop	r0
     472:	0f 90       	pop	r0
     474:	0f 90       	pop	r0
     476:	0f 90       	pop	r0
     478:	64 96       	adiw	r28, 0x14	; 20
     47a:	cd bf       	out	0x3d, r28	; 61
     47c:	de bf       	out	0x3e, r29	; 62
     47e:	df 91       	pop	r29
     480:	cf 91       	pop	r28
     482:	1f 91       	pop	r17
     484:	0f 91       	pop	r16
     486:	ff 90       	pop	r15
     488:	ef 90       	pop	r14
     48a:	df 90       	pop	r13
     48c:	cf 90       	pop	r12
     48e:	08 95       	ret

00000490 <tinyDebugger_end_line>:
void tinyDebugger_end_line(){
	printf("\r\n");
     490:	8f e7       	ldi	r24, 0x7F	; 127
     492:	9c e9       	ldi	r25, 0x9C	; 156
     494:	d6 d6       	rcall	.+3500   	; 0x1242 <puts>
     496:	08 95       	ret

00000498 <tinyPulse_toggle_pulse_mode>:
uint32_t time_of_last_pulse = 0;
uint16_t time_since_last_pulse = 0;
uint16_t ideal_time_between_pulses = 1000/PULSEMODE_FREQUENCY;

void tinyPulse_toggle_pulse_mode(){
	pulse_mode = !pulse_mode;
     498:	90 91 1c 3e 	lds	r25, 0x3E1C	; 0x803e1c <pulse_mode>
     49c:	81 e0       	ldi	r24, 0x01	; 1
     49e:	89 27       	eor	r24, r25
     4a0:	80 93 1c 3e 	sts	0x3E1C, r24	; 0x803e1c <pulse_mode>
     4a4:	08 95       	ret

000004a6 <tinyPulse_update_potential>:
}

double tinyPulse_update_potential(double potential){
     4a6:	cf 92       	push	r12
     4a8:	df 92       	push	r13
     4aa:	ef 92       	push	r14
     4ac:	ff 92       	push	r15
     4ae:	6b 01       	movw	r12, r22
     4b0:	7c 01       	movw	r14, r24
	if(pulse_mode){
     4b2:	80 91 1c 3e 	lds	r24, 0x3E1C	; 0x803e1c <pulse_mode>
     4b6:	88 23       	and	r24, r24
     4b8:	21 f1       	breq	.+72     	; 0x502 <tinyPulse_update_potential+0x5c>
		
		time_since_last_pulse = tinyTime_now() - time_of_last_pulse;
     4ba:	3e d0       	rcall	.+124    	; 0x538 <tinyTime_now>
     4bc:	20 91 18 3e 	lds	r18, 0x3E18	; 0x803e18 <time_of_last_pulse>
     4c0:	30 91 19 3e 	lds	r19, 0x3E19	; 0x803e19 <time_of_last_pulse+0x1>
     4c4:	62 1b       	sub	r22, r18
     4c6:	73 0b       	sbc	r23, r19
     4c8:	60 93 16 3e 	sts	0x3E16, r22	; 0x803e16 <__data_end>
     4cc:	70 93 17 3e 	sts	0x3E17, r23	; 0x803e17 <__data_end+0x1>
		
		if(time_since_last_pulse >= ideal_time_between_pulses){
     4d0:	80 91 0e 3e 	lds	r24, 0x3E0E	; 0x803e0e <ideal_time_between_pulses>
     4d4:	90 91 0f 3e 	lds	r25, 0x3E0F	; 0x803e0f <ideal_time_between_pulses+0x1>
     4d8:	68 17       	cp	r22, r24
     4da:	79 07       	cpc	r23, r25
     4dc:	90 f0       	brcs	.+36     	; 0x502 <tinyPulse_update_potential+0x5c>
			potential += BUTTON_PRESS_REACTION;
     4de:	20 e0       	ldi	r18, 0x00	; 0
     4e0:	30 e0       	ldi	r19, 0x00	; 0
     4e2:	40 ed       	ldi	r20, 0xD0	; 208
     4e4:	51 e4       	ldi	r21, 0x41	; 65
     4e6:	c7 01       	movw	r24, r14
     4e8:	b6 01       	movw	r22, r12
     4ea:	ef d3       	rcall	.+2014   	; 0xcca <__addsf3>
     4ec:	6b 01       	movw	r12, r22
     4ee:	7c 01       	movw	r14, r24
			time_of_last_pulse = tinyTime_now();			
     4f0:	23 d0       	rcall	.+70     	; 0x538 <tinyTime_now>
     4f2:	60 93 18 3e 	sts	0x3E18, r22	; 0x803e18 <time_of_last_pulse>
     4f6:	70 93 19 3e 	sts	0x3E19, r23	; 0x803e19 <time_of_last_pulse+0x1>
     4fa:	80 93 1a 3e 	sts	0x3E1A, r24	; 0x803e1a <time_of_last_pulse+0x2>
     4fe:	90 93 1b 3e 	sts	0x3E1B, r25	; 0x803e1b <time_of_last_pulse+0x3>
		}
	}
	return potential;
}
     502:	c7 01       	movw	r24, r14
     504:	b6 01       	movw	r22, r12
     506:	ff 90       	pop	r15
     508:	ef 90       	pop	r14
     50a:	df 90       	pop	r13
     50c:	cf 90       	pop	r12
     50e:	08 95       	ret

00000510 <tinyTime_counter_increment>:
If the Interrupt Service Routine is clocked by a crystal oscillator
it gives a very precise timer-counter.
*/
void tinyTime_counter_increment(void)
{
	time_counter++;
     510:	80 91 1d 3e 	lds	r24, 0x3E1D	; 0x803e1d <time_counter>
     514:	90 91 1e 3e 	lds	r25, 0x3E1E	; 0x803e1e <time_counter+0x1>
     518:	a0 91 1f 3e 	lds	r26, 0x3E1F	; 0x803e1f <time_counter+0x2>
     51c:	b0 91 20 3e 	lds	r27, 0x3E20	; 0x803e20 <time_counter+0x3>
     520:	01 96       	adiw	r24, 0x01	; 1
     522:	a1 1d       	adc	r26, r1
     524:	b1 1d       	adc	r27, r1
     526:	80 93 1d 3e 	sts	0x3E1D, r24	; 0x803e1d <time_counter>
     52a:	90 93 1e 3e 	sts	0x3E1E, r25	; 0x803e1e <time_counter+0x1>
     52e:	a0 93 1f 3e 	sts	0x3E1F, r26	; 0x803e1f <time_counter+0x2>
     532:	b0 93 20 3e 	sts	0x3E20, r27	; 0x803e20 <time_counter+0x3>
     536:	08 95       	ret

00000538 <tinyTime_now>:
/*
This function is callable by external libraries to give them the counted time so far.
*/
uint32_t tinyTime_now(void)
{
	return time_counter;
     538:	60 91 1d 3e 	lds	r22, 0x3E1D	; 0x803e1d <time_counter>
     53c:	70 91 1e 3e 	lds	r23, 0x3E1E	; 0x803e1e <time_counter+0x1>
     540:	80 91 1f 3e 	lds	r24, 0x3E1F	; 0x803e1f <time_counter+0x2>
     544:	90 91 20 3e 	lds	r25, 0x3E20	; 0x803e20 <time_counter+0x3>
     548:	08 95       	ret

0000054a <main>:


int main(void)
{	
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
     54a:	0d de       	rcall	.-998    	; 0x166 <atmel_start_init>
	Setting this value will mean that the ADC (Analog to Digital Converter) will read 4.32v as 255, and 0v as 0.
	For some reason, instead of the reference voltage being 4.32v, it is 3.3v. 
	A plausible explanation is that the microchip does not up the voltage, so that if the microchip is only ever 
	supplied with 3.3v, it will output 3.3v as the max.
	*/
	VREF.CTRLA = VREF_ADC0REFSEL_4V34_gc;
     54c:	80 e3       	ldi	r24, 0x30	; 48
     54e:	80 93 a0 00 	sts	0x00A0, r24	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
	while (1)
	{
		// We don't want to update the neuron too often because of various reasons. The tinyISR_getflag is set every ms, and so the loop is only run once every ms.  
		if(tinyISR_getflag())
     552:	4e d3       	rcall	.+1692   	; 0xbf0 <tinyISR_getflag>
     554:	88 23       	and	r24, r24
     556:	e9 f3       	breq	.-6      	; 0x552 <main+0x8>
		{			
			
			if(tinyCharge_is_charging()){
     558:	3a df       	rcall	.-396    	; 0x3ce <tinyCharge_is_charging>
     55a:	88 23       	and	r24, r24
     55c:	11 f0       	breq	.+4      	; 0x562 <main+0x18>
				// Charge loop
				
				// We check the Dendrites in order to detect if we have stopped charging
				tinyDendrite_update_signals();
     55e:	28 d2       	rcall	.+1104   	; 0x9b0 <tinyDendrite_update_signals>
     560:	02 c0       	rjmp	.+4      	; 0x566 <main+0x1c>
				// Update led
				
			}
			else{
				// Main loop				
				tinyButton_update();
     562:	aa d0       	rcall	.+340    	; 0x6b8 <tinyButton_update>
				
				tinyPotential_update();
     564:	48 d3       	rcall	.+1680   	; 0xbf6 <tinyPotential_update>
			}
			
			
			// Switch transistors
			tinyCharge_set_transistors();
     566:	38 df       	rcall	.-400    	; 0x3d8 <tinyCharge_set_transistors>
			
			// Prepare for next cycle
			tinyISR_setflag(false);
     568:	80 e0       	ldi	r24, 0x00	; 0
     56a:	3f d3       	rcall	.+1662   	; 0xbea <tinyISR_setflag>
			tinyDebugger_send_int("time", tinyTime_now());
     56c:	e5 df       	rcall	.-54     	; 0x538 <tinyTime_now>
     56e:	81 e8       	ldi	r24, 0x81	; 129
     570:	9c e9       	ldi	r25, 0x9C	; 156
     572:	3a df       	rcall	.-396    	; 0x3e8 <tinyDebugger_send_int>
			tinyDebugger_end_line();
     574:	8d df       	rcall	.-230    	; 0x490 <tinyDebugger_end_line>
     576:	ed cf       	rjmp	.-38     	; 0x552 <main+0x8>

00000578 <set_LED_fire>:



//function to be called upon when firing flag has been raised.
void set_LED_fire(void)
{
     578:	cf 93       	push	r28
	fire_flash_time_counter = tinyTime_now();
     57a:	de df       	rcall	.-68     	; 0x538 <tinyTime_now>
     57c:	60 93 21 3e 	sts	0x3E21, r22	; 0x803e21 <fire_flash_time_counter>
     580:	70 93 22 3e 	sts	0x3E22, r23	; 0x803e22 <fire_flash_time_counter+0x1>
     584:	80 93 23 3e 	sts	0x3E23, r24	; 0x803e23 <fire_flash_time_counter+0x2>
     588:	90 93 24 3e 	sts	0x3E24, r25	; 0x803e24 <fire_flash_time_counter+0x3>
     58c:	c0 e0       	ldi	r28, 0x00	; 0
	for (int i = 0; i < NUMBER_OF_LEDS; i++)
	{
		tinyCCLRGB_setColor(i, MAX_BRIGHTNESS, MAX_BRIGHTNESS, MAX_BRIGHTNESS);//As per the specs, all LEDs should be blue while firing.
     58e:	20 e3       	ldi	r18, 0x30	; 48
     590:	40 e3       	ldi	r20, 0x30	; 48
     592:	60 e3       	ldi	r22, 0x30	; 48
     594:	8c 2f       	mov	r24, r28
     596:	fc d0       	rcall	.+504    	; 0x790 <tinyCCLRGB_setColor>
     598:	cf 5f       	subi	r28, 0xFF	; 255

//function to be called upon when firing flag has been raised.
void set_LED_fire(void)
{
	fire_flash_time_counter = tinyTime_now();
	for (int i = 0; i < NUMBER_OF_LEDS; i++)
     59a:	c6 30       	cpi	r28, 0x06	; 6
     59c:	c1 f7       	brne	.-16     	; 0x58e <set_LED_fire+0x16>
	{
		tinyCCLRGB_setColor(i, MAX_BRIGHTNESS, MAX_BRIGHTNESS, MAX_BRIGHTNESS);//As per the specs, all LEDs should be blue while firing.
	}
}
     59e:	cf 91       	pop	r28
     5a0:	08 95       	ret

000005a2 <potential_to_RGB_update_LEDs>:



void potential_to_RGB_update_LEDs(double potential)
{
     5a2:	8f 92       	push	r8
     5a4:	9f 92       	push	r9
     5a6:	af 92       	push	r10
     5a8:	bf 92       	push	r11
     5aa:	cf 92       	push	r12
     5ac:	df 92       	push	r13
     5ae:	ef 92       	push	r14
     5b0:	ff 92       	push	r15
     5b2:	0f 93       	push	r16
     5b4:	1f 93       	push	r17
     5b6:	cf 93       	push	r28
     5b8:	6b 01       	movw	r12, r22
     5ba:	7c 01       	movw	r14, r24
	if ((tinyTime_now() - fire_flash_time_counter) < FIRE_FLASH_TIME)
     5bc:	bd df       	rcall	.-134    	; 0x538 <tinyTime_now>
     5be:	00 91 21 3e 	lds	r16, 0x3E21	; 0x803e21 <fire_flash_time_counter>
     5c2:	10 91 22 3e 	lds	r17, 0x3E22	; 0x803e22 <fire_flash_time_counter+0x1>
     5c6:	20 91 23 3e 	lds	r18, 0x3E23	; 0x803e23 <fire_flash_time_counter+0x2>
     5ca:	30 91 24 3e 	lds	r19, 0x3E24	; 0x803e24 <fire_flash_time_counter+0x3>
     5ce:	dc 01       	movw	r26, r24
     5d0:	cb 01       	movw	r24, r22
     5d2:	80 1b       	sub	r24, r16
     5d4:	91 0b       	sbc	r25, r17
     5d6:	a2 0b       	sbc	r26, r18
     5d8:	b3 0b       	sbc	r27, r19
     5da:	84 36       	cpi	r24, 0x64	; 100
     5dc:	91 05       	cpc	r25, r1
     5de:	a1 05       	cpc	r26, r1
     5e0:	b1 05       	cpc	r27, r1
     5e2:	50 f4       	brcc	.+20     	; 0x5f8 <potential_to_RGB_update_LEDs+0x56>
     5e4:	c0 e0       	ldi	r28, 0x00	; 0
	{
		for (int i = 0; i < NUMBER_OF_LEDS; i++)
		{
			tinyCCLRGB_setColor(i, MAX_BRIGHTNESS, MAX_BRIGHTNESS, MAX_BRIGHTNESS);
     5e6:	20 e3       	ldi	r18, 0x30	; 48
     5e8:	40 e3       	ldi	r20, 0x30	; 48
     5ea:	60 e3       	ldi	r22, 0x30	; 48
     5ec:	8c 2f       	mov	r24, r28
     5ee:	d0 d0       	rcall	.+416    	; 0x790 <tinyCCLRGB_setColor>
     5f0:	cf 5f       	subi	r28, 0xFF	; 255

void potential_to_RGB_update_LEDs(double potential)
{
	if ((tinyTime_now() - fire_flash_time_counter) < FIRE_FLASH_TIME)
	{
		for (int i = 0; i < NUMBER_OF_LEDS; i++)
     5f2:	c6 30       	cpi	r28, 0x06	; 6
     5f4:	c1 f7       	brne	.-16     	; 0x5e6 <potential_to_RGB_update_LEDs+0x44>
     5f6:	53 c0       	rjmp	.+166    	; 0x69e <potential_to_RGB_update_LEDs+0xfc>
     5f8:	c0 e0       	ldi	r28, 0x00	; 0
*/
static void potential_to_RGB_set_color(double potential)
{
	for (int i = 0; i < NUMBER_OF_LEDS; i++)
	{
		tinyCCLRGB_setColor(i, 0x0, 0x0, 0x0);//Clear all LED stored values on the MCU before writing again.
     5fa:	20 e0       	ldi	r18, 0x00	; 0
     5fc:	40 e0       	ldi	r20, 0x00	; 0
     5fe:	60 e0       	ldi	r22, 0x00	; 0
     600:	8c 2f       	mov	r24, r28
     602:	c6 d0       	rcall	.+396    	; 0x790 <tinyCCLRGB_setColor>
     604:	cf 5f       	subi	r28, 0xFF	; 255
When firing all lights turn blue for ~100ms, but this needs to be tested.
LEDs are numbered right way on top of PCB, but opposite way on bottom of PCB.
*/
static void potential_to_RGB_set_color(double potential)
{
	for (int i = 0; i < NUMBER_OF_LEDS; i++)
     606:	c6 30       	cpi	r28, 0x06	; 6
     608:	c1 f7       	brne	.-16     	; 0x5fa <potential_to_RGB_update_LEDs+0x58>
	{
		tinyCCLRGB_setColor(i, 0x0, 0x0, 0x0);//Clear all LED stored values on the MCU before writing again.
	}
	double absolute_potential = abs(potential);//setting variable for absolute potential so it won't have to be calculated more than once.
     60a:	c7 01       	movw	r24, r14
     60c:	b6 01       	movw	r22, r12
     60e:	40 d4       	rcall	.+2176   	; 0xe90 <__fixsfsi>
     610:	9b 01       	movw	r18, r22
     612:	77 23       	and	r23, r23
     614:	24 f4       	brge	.+8      	; 0x61e <potential_to_RGB_update_LEDs+0x7c>
     616:	22 27       	eor	r18, r18
     618:	33 27       	eor	r19, r19
     61a:	26 1b       	sub	r18, r22
     61c:	37 0b       	sbc	r19, r23
     61e:	b9 01       	movw	r22, r18
     620:	33 0f       	add	r19, r19
     622:	88 0b       	sbc	r24, r24
     624:	99 0b       	sbc	r25, r25
     626:	6c d4       	rcall	.+2264   	; 0xf00 <__floatsisf>
     628:	4b 01       	movw	r8, r22
     62a:	5c 01       	movw	r10, r24
	if (absolute_potential < 1)//set the middle lights as white both top side and bottom side.
     62c:	20 e0       	ldi	r18, 0x00	; 0
     62e:	30 e0       	ldi	r19, 0x00	; 0
     630:	40 e8       	ldi	r20, 0x80	; 128
     632:	5f e3       	ldi	r21, 0x3F	; 63
     634:	b6 d3       	rcall	.+1900   	; 0xda2 <__cmpsf2>
     636:	88 23       	and	r24, r24
     638:	34 f4       	brge	.+12     	; 0x646 <potential_to_RGB_update_LEDs+0xa4>
	{
		tinyCCLRGB_setColor(2, MAX_BRIGHTNESS/3, MAX_BRIGHTNESS/3, MAX_BRIGHTNESS/3);
     63a:	20 e1       	ldi	r18, 0x10	; 16
     63c:	40 e1       	ldi	r20, 0x10	; 16
     63e:	60 e1       	ldi	r22, 0x10	; 16
     640:	82 e0       	ldi	r24, 0x02	; 2
     642:	a6 d0       	rcall	.+332    	; 0x790 <tinyCCLRGB_setColor>
     644:	2c c0       	rjmp	.+88     	; 0x69e <potential_to_RGB_update_LEDs+0xfc>
		//tinyCCLRGB_setColor(4, max_brightness/3, max_brightness/3, max_brightness/3);
	}
	else
	{
		uint8_t brightness_intensity = round((absolute_potential/25)*MAX_BRIGHTNESS);//brightness intensity for the LED that shows potential.
     646:	20 e0       	ldi	r18, 0x00	; 0
     648:	30 e0       	ldi	r19, 0x00	; 0
     64a:	48 ec       	ldi	r20, 0xC8	; 200
     64c:	51 e4       	ldi	r21, 0x41	; 65
     64e:	c5 01       	movw	r24, r10
     650:	b4 01       	movw	r22, r8
     652:	ac d3       	rcall	.+1880   	; 0xdac <__divsf3>
     654:	20 e0       	ldi	r18, 0x00	; 0
     656:	30 e0       	ldi	r19, 0x00	; 0
     658:	40 e4       	ldi	r20, 0x40	; 64
     65a:	52 e4       	ldi	r21, 0x42	; 66
     65c:	06 d5       	rcall	.+2572   	; 0x106a <__mulsf3>
     65e:	72 d5       	rcall	.+2788   	; 0x1144 <round>
     660:	1e d4       	rcall	.+2108   	; 0xe9e <__fixunssfsi>
     662:	c6 2f       	mov	r28, r22
		if (potential < 0)
     664:	20 e0       	ldi	r18, 0x00	; 0
     666:	30 e0       	ldi	r19, 0x00	; 0
     668:	a9 01       	movw	r20, r18
     66a:	c7 01       	movw	r24, r14
     66c:	b6 01       	movw	r22, r12
     66e:	99 d3       	rcall	.+1842   	; 0xda2 <__cmpsf2>
     670:	88 23       	and	r24, r24
     672:	5c f4       	brge	.+22     	; 0x68a <potential_to_RGB_update_LEDs+0xe8>
		{
			tinyCCLRGB_setColor(0, brightness_intensity, 0x0, 0x0);
     674:	20 e0       	ldi	r18, 0x00	; 0
     676:	40 e0       	ldi	r20, 0x00	; 0
     678:	6c 2f       	mov	r22, r28
     67a:	80 e0       	ldi	r24, 0x00	; 0
     67c:	89 d0       	rcall	.+274    	; 0x790 <tinyCCLRGB_setColor>
			tinyCCLRGB_setColor(1, brightness_intensity, 0x0, 0x0);//sets lower LEDs red if potential is negative.
     67e:	20 e0       	ldi	r18, 0x00	; 0
     680:	40 e0       	ldi	r20, 0x00	; 0
     682:	6c 2f       	mov	r22, r28
     684:	81 e0       	ldi	r24, 0x01	; 1
     686:	84 d0       	rcall	.+264    	; 0x790 <tinyCCLRGB_setColor>
     688:	0a c0       	rjmp	.+20     	; 0x69e <potential_to_RGB_update_LEDs+0xfc>
		} 
		else
		{
			tinyCCLRGB_setColor(3, 0x0, brightness_intensity, 0x0);//sets upper LEDs green if potential is positive.
     68a:	20 e0       	ldi	r18, 0x00	; 0
     68c:	4c 2f       	mov	r20, r28
     68e:	60 e0       	ldi	r22, 0x00	; 0
     690:	83 e0       	ldi	r24, 0x03	; 3
     692:	7e d0       	rcall	.+252    	; 0x790 <tinyCCLRGB_setColor>
			tinyCCLRGB_setColor(4, 0x0, brightness_intensity, 0x0);
     694:	20 e0       	ldi	r18, 0x00	; 0
     696:	4c 2f       	mov	r20, r28
     698:	60 e0       	ldi	r22, 0x00	; 0
     69a:	84 e0       	ldi	r24, 0x04	; 4
     69c:	79 d0       	rcall	.+242    	; 0x790 <tinyCCLRGB_setColor>
	}
	else
	{
		potential_to_RGB_set_color(potential);
	}
	tinyCCLRGB_uploadColorsToLeds();
     69e:	85 d0       	rcall	.+266    	; 0x7aa <tinyCCLRGB_uploadColorsToLeds>
}
     6a0:	cf 91       	pop	r28
     6a2:	1f 91       	pop	r17
     6a4:	0f 91       	pop	r16
     6a6:	ff 90       	pop	r15
     6a8:	ef 90       	pop	r14
     6aa:	df 90       	pop	r13
     6ac:	cf 90       	pop	r12
     6ae:	bf 90       	pop	r11
     6b0:	af 90       	pop	r10
     6b2:	9f 90       	pop	r9
     6b4:	8f 90       	pop	r8
     6b6:	08 95       	ret

000006b8 <tinyButton_update>:
/*
If the button has been let go, we change button_press to true. This only lasts one cycle, before it is set to false again.
If the button is held down for longer than PULSEMODE_BUTTON_PRESS_TIME, we toggle the pulse mode state.
*/
void tinyButton_update(void)
{
     6b8:	0f 93       	push	r16
     6ba:	1f 93       	push	r17
     6bc:	cf 93       	push	r28
     6be:	df 93       	push	r29
	button_press = false;
     6c0:	10 92 29 3e 	sts	0x3E29, r1	; 0x803e29 <button_press>
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTC_get_pin_level(const uint8_t pin)
{
	return VPORTC.IN & (1 << pin);
     6c4:	8a b1       	in	r24, 0x0a	; 10
	_Bool button_is_pushed_down = !BUTTON_PIN_get_level(); // The digital port will be read as low if the button is pushed down.
     6c6:	d1 e0       	ldi	r29, 0x01	; 1
     6c8:	c8 2f       	mov	r28, r24
     6ca:	c4 70       	andi	r28, 0x04	; 4
     6cc:	82 fd       	sbrc	r24, 2
     6ce:	d0 e0       	ldi	r29, 0x00	; 0

	if (button_is_pushed_down && !button_was_pushed_down)
     6d0:	c1 11       	cpse	r28, r1
     6d2:	30 c0       	rjmp	.+96     	; 0x734 <tinyButton_update+0x7c>
     6d4:	80 91 2a 3e 	lds	r24, 0x3E2A	; 0x803e2a <button_was_pushed_down>
     6d8:	81 11       	cpse	r24, r1
     6da:	0d c0       	rjmp	.+26     	; 0x6f6 <tinyButton_update+0x3e>
	{
		tinyButton_start_time = tinyTime_now();
     6dc:	2d df       	rcall	.-422    	; 0x538 <tinyTime_now>
     6de:	60 93 25 3e 	sts	0x3E25, r22	; 0x803e25 <tinyButton_start_time>
     6e2:	70 93 26 3e 	sts	0x3E26, r23	; 0x803e26 <tinyButton_start_time+0x1>
     6e6:	80 93 27 3e 	sts	0x3E27, r24	; 0x803e27 <tinyButton_start_time+0x2>
     6ea:	90 93 28 3e 	sts	0x3E28, r25	; 0x803e28 <tinyButton_start_time+0x3>
	}
	if (button_is_pushed_down && button_was_pushed_down)
     6ee:	80 91 2a 3e 	lds	r24, 0x3E2A	; 0x803e2a <button_was_pushed_down>
     6f2:	88 23       	and	r24, r24
     6f4:	41 f1       	breq	.+80     	; 0x746 <tinyButton_update+0x8e>
	{
		if ((tinyTime_now() - tinyButton_start_time) > PULSEMODE_BUTTON_PRESS_TIME)
     6f6:	20 df       	rcall	.-448    	; 0x538 <tinyTime_now>
     6f8:	00 91 25 3e 	lds	r16, 0x3E25	; 0x803e25 <tinyButton_start_time>
     6fc:	10 91 26 3e 	lds	r17, 0x3E26	; 0x803e26 <tinyButton_start_time+0x1>
     700:	20 91 27 3e 	lds	r18, 0x3E27	; 0x803e27 <tinyButton_start_time+0x2>
     704:	30 91 28 3e 	lds	r19, 0x3E28	; 0x803e28 <tinyButton_start_time+0x3>
     708:	60 1b       	sub	r22, r16
     70a:	71 0b       	sbc	r23, r17
     70c:	82 0b       	sbc	r24, r18
     70e:	93 0b       	sbc	r25, r19
     710:	f5 d3       	rcall	.+2026   	; 0xefc <__floatunsisf>
     712:	20 e0       	ldi	r18, 0x00	; 0
     714:	30 e0       	ldi	r19, 0x00	; 0
     716:	40 ea       	ldi	r20, 0xA0	; 160
     718:	51 e4       	ldi	r21, 0x41	; 65
     71a:	a2 d4       	rcall	.+2372   	; 0x1060 <__gesf2>
     71c:	18 16       	cp	r1, r24
     71e:	54 f4       	brge	.+20     	; 0x734 <tinyButton_update+0x7c>
		{
			tinyPulse_toggle_pulse_mode();
     720:	bb de       	rcall	.-650    	; 0x498 <tinyPulse_toggle_pulse_mode>
			tinyButton_start_time = tinyTime_now();
     722:	0a df       	rcall	.-492    	; 0x538 <tinyTime_now>
     724:	60 93 25 3e 	sts	0x3E25, r22	; 0x803e25 <tinyButton_start_time>
     728:	70 93 26 3e 	sts	0x3E26, r23	; 0x803e26 <tinyButton_start_time+0x1>
     72c:	80 93 27 3e 	sts	0x3E27, r24	; 0x803e27 <tinyButton_start_time+0x2>
     730:	90 93 28 3e 	sts	0x3E28, r25	; 0x803e28 <tinyButton_start_time+0x3>
		}
	}
	if (!button_is_pushed_down && button_was_pushed_down)
     734:	cc 23       	and	r28, r28
     736:	39 f0       	breq	.+14     	; 0x746 <tinyButton_update+0x8e>
     738:	80 91 2a 3e 	lds	r24, 0x3E2A	; 0x803e2a <button_was_pushed_down>
     73c:	88 23       	and	r24, r24
     73e:	19 f0       	breq	.+6      	; 0x746 <tinyButton_update+0x8e>
	{
		button_press = true;
     740:	81 e0       	ldi	r24, 0x01	; 1
     742:	80 93 29 3e 	sts	0x3E29, r24	; 0x803e29 <button_press>
	}
	button_was_pushed_down = button_is_pushed_down;
     746:	d0 93 2a 3e 	sts	0x3E2A, r29	; 0x803e2a <button_was_pushed_down>
}
     74a:	df 91       	pop	r29
     74c:	cf 91       	pop	r28
     74e:	1f 91       	pop	r17
     750:	0f 91       	pop	r16
     752:	08 95       	ret

00000754 <tinyButton_update_potential>:

double tinyButton_update_potential(double potential){
	if(button_press){
     754:	20 91 29 3e 	lds	r18, 0x3E29	; 0x803e29 <button_press>
     758:	22 23       	and	r18, r18
     75a:	29 f0       	breq	.+10     	; 0x766 <tinyButton_update_potential+0x12>
		potential += BUTTON_PRESS_REACTION;
     75c:	20 e0       	ldi	r18, 0x00	; 0
     75e:	30 e0       	ldi	r19, 0x00	; 0
     760:	40 ed       	ldi	r20, 0xD0	; 208
     762:	51 e4       	ldi	r21, 0x41	; 65
     764:	b2 d2       	rcall	.+1380   	; 0xcca <__addsf3>
	}
	return potential;
}
     766:	08 95       	ret

00000768 <tinyCCLRGB_SPIWriteByte>:
Function used to send a byte over SPI, which in turn gets
translated to the bit-sequence required by the LEDs over the CCL.
*/
static void tinyCCLRGB_SPIWriteByte(uint8_t byte)
{
	SPI0.INTFLAGS = SPI0_INTFLAGS; // clear the write collision flag to allow writing
     768:	90 91 23 08 	lds	r25, 0x0823	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
     76c:	90 93 23 08 	sts	0x0823, r25	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
	TCA0.SINGLE.CNT = 0; // reset TCA counter register to ensure the first rising edge of the PWM is predictable
     770:	e0 e0       	ldi	r30, 0x00	; 0
     772:	fa e0       	ldi	r31, 0x0A	; 10
     774:	10 a2       	std	Z+32, r1	; 0x20
     776:	11 a2       	std	Z+33, r1	; 0x21
	
	// start TCA
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 1 << TCA_SPLIT_ENABLE_bp;
     778:	91 e0       	ldi	r25, 0x01	; 1
     77a:	90 83       	st	Z, r25
	SPI0_DATA = byte;
     77c:	80 93 24 08 	sts	0x0824, r24	; 0x800824 <__TEXT_REGION_LENGTH__+0x700824>

	while((SPI0.INTFLAGS & SPI_RXCIE_bm) == 0){} // wait for transfer to complete
     780:	e0 e2       	ldi	r30, 0x20	; 32
     782:	f8 e0       	ldi	r31, 0x08	; 8
     784:	83 81       	ldd	r24, Z+3	; 0x03
     786:	88 23       	and	r24, r24
     788:	ec f7       	brge	.-6      	; 0x784 <tinyCCLRGB_SPIWriteByte+0x1c>
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 0 << TCA_SPLIT_ENABLE_bp; //Stop TCA
     78a:	10 92 00 0a 	sts	0x0A00, r1	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
     78e:	08 95       	ret

00000790 <tinyCCLRGB_setColor>:
/*
changes the values in the variables stored in the led-array.
*/
void tinyCCLRGB_setColor(uint8_t led, uint8_t red, uint8_t green, uint8_t blue) 
{
	tinyCCLRGB_colors[led].red = red;
     790:	90 e0       	ldi	r25, 0x00	; 0
     792:	fc 01       	movw	r30, r24
     794:	ee 0f       	add	r30, r30
     796:	ff 1f       	adc	r31, r31
     798:	8e 0f       	add	r24, r30
     79a:	9f 1f       	adc	r25, r31
     79c:	fc 01       	movw	r30, r24
     79e:	e5 5d       	subi	r30, 0xD5	; 213
     7a0:	f1 4c       	sbci	r31, 0xC1	; 193
     7a2:	60 83       	st	Z, r22
	tinyCCLRGB_colors[led].green = green;
     7a4:	41 83       	std	Z+1, r20	; 0x01
	tinyCCLRGB_colors[led].blue = blue;
     7a6:	22 83       	std	Z+2, r18	; 0x02
     7a8:	08 95       	ret

000007aa <tinyCCLRGB_uploadColorsToLeds>:
/*
function to write the current LED-array on to the LEDs and
effectively update the values stored in the LEDs to the values stored in the MCU.
*/
void tinyCCLRGB_uploadColorsToLeds(void)
{
     7aa:	0f 93       	push	r16
     7ac:	1f 93       	push	r17
     7ae:	cf 93       	push	r28
     7b0:	df 93       	push	r29
     7b2:	cb e2       	ldi	r28, 0x2B	; 43
     7b4:	de e3       	ldi	r29, 0x3E	; 62
     7b6:	0d e3       	ldi	r16, 0x3D	; 61
     7b8:	1e e3       	ldi	r17, 0x3E	; 62
	for (uint8_t i = 0; i < TINYCCLRGB_LEDCOUNT; i++)
	{
		//For some reason unknown to the writer the data-bus to the LEDs is serialized as GRB
		//which means the 24-bit data-bus will look like [Green[0:7], Red[0:7], Blue[0:7]]
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].green);
     7ba:	89 81       	ldd	r24, Y+1	; 0x01
     7bc:	d5 df       	rcall	.-86     	; 0x768 <tinyCCLRGB_SPIWriteByte>
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].red);
     7be:	88 81       	ld	r24, Y
     7c0:	d3 df       	rcall	.-90     	; 0x768 <tinyCCLRGB_SPIWriteByte>
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].blue);
     7c2:	8a 81       	ldd	r24, Y+2	; 0x02
     7c4:	d1 df       	rcall	.-94     	; 0x768 <tinyCCLRGB_SPIWriteByte>
     7c6:	23 96       	adiw	r28, 0x03	; 3
function to write the current LED-array on to the LEDs and
effectively update the values stored in the LEDs to the values stored in the MCU.
*/
void tinyCCLRGB_uploadColorsToLeds(void)
{
	for (uint8_t i = 0; i < TINYCCLRGB_LEDCOUNT; i++)
     7c8:	c0 17       	cp	r28, r16
     7ca:	d1 07       	cpc	r29, r17
     7cc:	b1 f7       	brne	.-20     	; 0x7ba <tinyCCLRGB_uploadColorsToLeds+0x10>
		//which means the 24-bit data-bus will look like [Green[0:7], Red[0:7], Blue[0:7]]
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].green);
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].red);
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].blue);
	}
}
     7ce:	df 91       	pop	r29
     7d0:	cf 91       	pop	r28
     7d2:	1f 91       	pop	r17
     7d4:	0f 91       	pop	r16
     7d6:	08 95       	ret

000007d8 <find_newest_pulse>:
uint8_t find_newest_pulse() {
	uint16_t max;
	uint8_t current_index = 0;
	uint8_t return_index = 0;
	
	max = time_left_until_pulse[current_index];
     7d8:	40 91 3e 3e 	lds	r20, 0x3E3E	; 0x803e3e <time_left_until_pulse>
     7dc:	50 91 3f 3e 	lds	r21, 0x3E3F	; 0x803e3f <time_left_until_pulse+0x1>
     7e0:	e0 e4       	ldi	r30, 0x40	; 64
     7e2:	fe e3       	ldi	r31, 0x3E	; 62
	
// This function will be used with time_left_until_pulse to find the newest pulse
uint8_t find_newest_pulse() {
	uint16_t max;
	uint8_t current_index = 0;
	uint8_t return_index = 0;
     7e4:	80 e0       	ldi	r24, 0x00	; 0
	
	max = time_left_until_pulse[current_index];
	
	for (current_index = 1; current_index < MAX_NUMBER_OF_PULSES; current_index++) {
     7e6:	91 e0       	ldi	r25, 0x01	; 1
		if (time_left_until_pulse[current_index] > max) {
     7e8:	21 91       	ld	r18, Z+
     7ea:	31 91       	ld	r19, Z+
     7ec:	42 17       	cp	r20, r18
     7ee:	53 07       	cpc	r21, r19
     7f0:	10 f4       	brcc	.+4      	; 0x7f6 <find_newest_pulse+0x1e>
     7f2:	89 2f       	mov	r24, r25
			return_index = current_index;
			max = time_left_until_pulse[current_index];
     7f4:	a9 01       	movw	r20, r18
	uint8_t current_index = 0;
	uint8_t return_index = 0;
	
	max = time_left_until_pulse[current_index];
	
	for (current_index = 1; current_index < MAX_NUMBER_OF_PULSES; current_index++) {
     7f6:	9f 5f       	subi	r25, 0xFF	; 255
     7f8:	9a 30       	cpi	r25, 0x0A	; 10
     7fa:	b1 f7       	brne	.-20     	; 0x7e8 <find_newest_pulse+0x10>
			return_index = current_index;
			max = time_left_until_pulse[current_index];
		}
	}
	return return_index;
}
     7fc:	08 95       	ret

000007fe <tinyAxon_remove_pulse>:

/*
If the potential is very low, we want to try to remove a pulse.
*/
bool tinyAxon_remove_pulse(void)
{
     7fe:	cf 93       	push	r28
	// We want to return a bool indicating whether or not a pulse actually was removed.
	if(pulses_in_queue == 0){
     800:	c0 91 52 3e 	lds	r28, 0x3E52	; 0x803e52 <pulses_in_queue>
     804:	cc 23       	and	r28, r28
     806:	81 f0       	breq	.+32     	; 0x828 <tinyAxon_remove_pulse+0x2a>
		//There was no pulse to remove.
		return false;
	}
	else{
		// If we are to remove a pulse, we want to remove the one that will fire last.
		uint16_t newest_pulse = time_left_until_pulse[find_newest_pulse()];
     808:	e7 df       	rcall	.-50     	; 0x7d8 <find_newest_pulse>
     80a:	e8 2f       	mov	r30, r24
     80c:	f0 e0       	ldi	r31, 0x00	; 0
     80e:	ee 0f       	add	r30, r30
     810:	ff 1f       	adc	r31, r31
     812:	e2 5c       	subi	r30, 0xC2	; 194
     814:	f1 4c       	sbci	r31, 0xC1	; 193
	
		// Now we want to check if the pulse is too far away to be affected by the low potential, or close enough that we decide to remove it.
		// (When we say that the pulse is too far away, it refers to the biological process of how the potential spreads from Dendrites to axon).
		if(newest_pulse > PULSE_NO_RETURN_TIME){
     816:	80 81       	ld	r24, Z
     818:	91 81       	ldd	r25, Z+1	; 0x01
     81a:	cd 97       	sbiw	r24, 0x3d	; 61
     81c:	38 f0       	brcs	.+14     	; 0x82c <tinyAxon_remove_pulse+0x2e>
			// We decided to remove the pulse
			pulses_in_queue--;
     81e:	c1 50       	subi	r28, 0x01	; 1
     820:	c0 93 52 3e 	sts	0x3E52, r28	; 0x803e52 <pulses_in_queue>
			return true;
     824:	81 e0       	ldi	r24, 0x01	; 1
     826:	03 c0       	rjmp	.+6      	; 0x82e <tinyAxon_remove_pulse+0x30>
bool tinyAxon_remove_pulse(void)
{
	// We want to return a bool indicating whether or not a pulse actually was removed.
	if(pulses_in_queue == 0){
		//There was no pulse to remove.
		return false;
     828:	80 e0       	ldi	r24, 0x00	; 0
     82a:	01 c0       	rjmp	.+2      	; 0x82e <tinyAxon_remove_pulse+0x30>
			pulses_in_queue--;
			return true;
		}
		// Here we have found that there is a pulse queued, but it is old enough to let pass anyway, so now we need to put it back into the queue.
		else{
			return false;
     82c:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     82e:	cf 91       	pop	r28
     830:	08 95       	ret

00000832 <tinyAxon_update_potential>:
/*
Decides whether or not the axon should fire
If the axon does fire, the potential is reduced
*/
double tinyAxon_update_potential(double potential)
{
     832:	bf 92       	push	r11
     834:	cf 92       	push	r12
     836:	df 92       	push	r13
     838:	ef 92       	push	r14
     83a:	ff 92       	push	r15
     83c:	0f 93       	push	r16
     83e:	1f 93       	push	r17
     840:	cf 93       	push	r28
     842:	df 93       	push	r29
     844:	6b 01       	movw	r12, r22
     846:	7c 01       	movw	r14, r24
	uint8_t pulse_nr = 0;
	
	//While the neuron has enough potential to fire, we want to fire more
	while (potential > THRESHOLD_POTENTIAL)
     848:	20 e0       	ldi	r18, 0x00	; 0
     84a:	30 e0       	ldi	r19, 0x00	; 0
     84c:	48 ec       	ldi	r20, 0xC8	; 200
     84e:	51 e4       	ldi	r21, 0x41	; 65
     850:	07 d4       	rcall	.+2062   	; 0x1060 <__gesf2>
     852:	18 16       	cp	r1, r24
     854:	0c f0       	brlt	.+2      	; 0x858 <tinyAxon_update_potential+0x26>
     856:	3e c0       	rjmp	.+124    	; 0x8d4 <tinyAxon_update_potential+0xa2>
     858:	00 91 52 3e 	lds	r16, 0x3E52	; 0x803e52 <pulses_in_queue>
     85c:	10 e0       	ldi	r17, 0x00	; 0
{
	// We want to check each slot in the time_left_until_pulse, and
	// if we find an empty slot (0), we add a pulse.
	for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
	{
		if(time_left_until_pulse[i] == 0){
     85e:	ce e3       	ldi	r28, 0x3E	; 62
     860:	de e3       	ldi	r29, 0x3E	; 62
			time_left_until_pulse[i] = new_pulse;
     862:	0f 2e       	mov	r0, r31
     864:	f2 e3       	ldi	r31, 0x32	; 50
     866:	bf 2e       	mov	r11, r31
     868:	f0 2d       	mov	r31, r0
{
	// We want to check each slot in the time_left_until_pulse, and
	// if we find an empty slot (0), we add a pulse.
	for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
	{
		if(time_left_until_pulse[i] == 0){
     86a:	88 81       	ld	r24, Y
     86c:	99 81       	ldd	r25, Y+1	; 0x01
     86e:	89 2b       	or	r24, r25
     870:	51 f0       	breq	.+20     	; 0x886 <tinyAxon_update_potential+0x54>
     872:	e0 e4       	ldi	r30, 0x40	; 64
     874:	fe e3       	ldi	r31, 0x3E	; 62
     876:	81 e0       	ldi	r24, 0x01	; 1
     878:	90 e0       	ldi	r25, 0x00	; 0
     87a:	ac 01       	movw	r20, r24
     87c:	21 91       	ld	r18, Z+
     87e:	31 91       	ld	r19, Z+
     880:	23 2b       	or	r18, r19
     882:	89 f4       	brne	.+34     	; 0x8a6 <tinyAxon_update_potential+0x74>
     884:	02 c0       	rjmp	.+4      	; 0x88a <tinyAxon_update_potential+0x58>
     886:	40 e0       	ldi	r20, 0x00	; 0
     888:	50 e0       	ldi	r21, 0x00	; 0
			time_left_until_pulse[i] = new_pulse;
     88a:	44 0f       	add	r20, r20
     88c:	55 1f       	adc	r21, r21
     88e:	fa 01       	movw	r30, r20
     890:	e2 5c       	subi	r30, 0xC2	; 194
     892:	f1 4c       	sbci	r31, 0xC1	; 193
     894:	b1 9e       	mul	r11, r17
     896:	c0 01       	movw	r24, r0
     898:	11 24       	eor	r1, r1
     89a:	8c 59       	subi	r24, 0x9C	; 156
     89c:	9f 4f       	sbci	r25, 0xFF	; 255
     89e:	80 83       	st	Z, r24
     8a0:	91 83       	std	Z+1, r25	; 0x01
			pulses_in_queue++;
     8a2:	0f 5f       	subi	r16, 0xFF	; 255
     8a4:	04 c0       	rjmp	.+8      	; 0x8ae <tinyAxon_update_potential+0x7c>
     8a6:	01 96       	adiw	r24, 0x01	; 1
*/
static void tinyAxon_add_pulse(uint16_t new_pulse)
{
	// We want to check each slot in the time_left_until_pulse, and
	// if we find an empty slot (0), we add a pulse.
	for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
     8a8:	8a 30       	cpi	r24, 0x0A	; 10
     8aa:	91 05       	cpc	r25, r1
     8ac:	31 f7       	brne	.-52     	; 0x87a <tinyAxon_update_potential+0x48>
	
	//While the neuron has enough potential to fire, we want to fire more
	while (potential > THRESHOLD_POTENTIAL)
	{
		tinyAxon_add_pulse(TRAVLE_DELAY + FIRE_DELAY*pulse_nr);
		pulse_nr++;
     8ae:	1f 5f       	subi	r17, 0xFF	; 255
		
		potential += POSTFIRE_POTENTIAL_REACTION; // This is usually defined as a negative value, don't be confused by the +=
     8b0:	20 e0       	ldi	r18, 0x00	; 0
     8b2:	30 e0       	ldi	r19, 0x00	; 0
     8b4:	40 ef       	ldi	r20, 0xF0	; 240
     8b6:	51 e4       	ldi	r21, 0x41	; 65
     8b8:	c7 01       	movw	r24, r14
     8ba:	b6 01       	movw	r22, r12
     8bc:	05 d2       	rcall	.+1034   	; 0xcc8 <__subsf3>
     8be:	6b 01       	movw	r12, r22
     8c0:	7c 01       	movw	r14, r24
double tinyAxon_update_potential(double potential)
{
	uint8_t pulse_nr = 0;
	
	//While the neuron has enough potential to fire, we want to fire more
	while (potential > THRESHOLD_POTENTIAL)
     8c2:	20 e0       	ldi	r18, 0x00	; 0
     8c4:	30 e0       	ldi	r19, 0x00	; 0
     8c6:	48 ec       	ldi	r20, 0xC8	; 200
     8c8:	51 e4       	ldi	r21, 0x41	; 65
     8ca:	ca d3       	rcall	.+1940   	; 0x1060 <__gesf2>
     8cc:	18 16       	cp	r1, r24
     8ce:	6c f2       	brlt	.-102    	; 0x86a <tinyAxon_update_potential+0x38>
     8d0:	00 93 52 3e 	sts	0x3E52, r16	; 0x803e52 <pulses_in_queue>
		
		potential += POSTFIRE_POTENTIAL_REACTION; // This is usually defined as a negative value, don't be confused by the +=
	}
	
	// If the neuron has a very low potential, we want to remove a pulse from the queue (if there is one)
	if(potential < -THRESHOLD_POTENTIAL && pulses_in_queue > 0) // Perhaps this should be a separate variable? For now, we will just simply use -THRESHOLD_POTENTIAL
     8d4:	20 e0       	ldi	r18, 0x00	; 0
     8d6:	30 e0       	ldi	r19, 0x00	; 0
     8d8:	48 ec       	ldi	r20, 0xC8	; 200
     8da:	51 ec       	ldi	r21, 0xC1	; 193
     8dc:	c7 01       	movw	r24, r14
     8de:	b6 01       	movw	r22, r12
     8e0:	60 d2       	rcall	.+1216   	; 0xda2 <__cmpsf2>
     8e2:	88 23       	and	r24, r24
     8e4:	0c f0       	brlt	.+2      	; 0x8e8 <tinyAxon_update_potential+0xb6>
     8e6:	43 c0       	rjmp	.+134    	; 0x96e <tinyAxon_update_potential+0x13c>
     8e8:	80 91 52 3e 	lds	r24, 0x3E52	; 0x803e52 <pulses_in_queue>
     8ec:	88 23       	and	r24, r24
     8ee:	11 f1       	breq	.+68     	; 0x934 <tinyAxon_update_potential+0x102>
	{
		// The neurons potential is low enough to attempt to remove a queued fire (Fire less)
		if(tinyAxon_remove_pulse())
     8f0:	86 df       	rcall	.-244    	; 0x7fe <tinyAxon_remove_pulse>
     8f2:	88 23       	and	r24, r24
     8f4:	e1 f1       	breq	.+120    	; 0x96e <tinyAxon_update_potential+0x13c>
		{
			// The potential has evened out a bit
			potential += THRESHOLD_POTENTIAL;
     8f6:	20 e0       	ldi	r18, 0x00	; 0
     8f8:	30 e0       	ldi	r19, 0x00	; 0
     8fa:	48 ec       	ldi	r20, 0xC8	; 200
     8fc:	51 e4       	ldi	r21, 0x41	; 65
     8fe:	c7 01       	movw	r24, r14
     900:	b6 01       	movw	r22, r12
     902:	e3 d1       	rcall	.+966    	; 0xcca <__addsf3>
     904:	6b 01       	movw	r12, r22
     906:	7c 01       	movw	r14, r24
     908:	32 c0       	rjmp	.+100    	; 0x96e <tinyAxon_update_potential+0x13c>
	// If there are pulses in the queue, we want to reduce the time in each of the time_left_until_pulse elements
	if (pulses_in_queue > 0)
	{
		for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
		{
			if(time_left_until_pulse[i] != 0){
     90a:	88 81       	ld	r24, Y
     90c:	99 81       	ldd	r25, Y+1	; 0x01
     90e:	00 97       	sbiw	r24, 0x00	; 0
     910:	69 f0       	breq	.+26     	; 0x92c <tinyAxon_update_potential+0xfa>
				time_left_until_pulse[i]--;
     912:	01 97       	sbiw	r24, 0x01	; 1
     914:	88 83       	st	Y, r24
     916:	99 83       	std	Y+1, r25	; 0x01
				
				// If the time went from 1 to 0, we fire the axon
				if(time_left_until_pulse[i] == 0){
     918:	89 2b       	or	r24, r25
     91a:	41 f4       	brne	.+16     	; 0x92c <tinyAxon_update_potential+0xfa>
Function to set firing.
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
     91c:	b0 92 53 3e 	sts	0x3E53, r11	; 0x803e53 <tinyAxon_should_fire>
	pulses_in_queue--;
     920:	80 91 52 3e 	lds	r24, 0x3E52	; 0x803e52 <pulses_in_queue>
     924:	81 50       	subi	r24, 0x01	; 1
     926:	80 93 52 3e 	sts	0x3E52, r24	; 0x803e52 <pulses_in_queue>
				// If the time went from 1 to 0, we fire the axon
				if(time_left_until_pulse[i] == 0){
					
					// We fire the axon
					tinyAxon_fire_pulse();
					set_LED_fire();
     92a:	26 de       	rcall	.-948    	; 0x578 <set_LED_fire>
     92c:	22 96       	adiw	r28, 0x02	; 2
	}
	
	// If there are pulses in the queue, we want to reduce the time in each of the time_left_until_pulse elements
	if (pulses_in_queue > 0)
	{
		for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
     92e:	0c 17       	cp	r16, r28
     930:	1d 07       	cpc	r17, r29
     932:	59 f7       	brne	.-42     	; 0x90a <tinyAxon_update_potential+0xd8>
The function should set the DAC to fire for two
update cycles once the pulse flag is set high.
*/
static void tinyAxon_update_pulse_transmitter(void)
{
	if (tinyAxon_should_fire)
     934:	80 91 53 3e 	lds	r24, 0x3E53	; 0x803e53 <tinyAxon_should_fire>
     938:	88 23       	and	r24, r24
     93a:	61 f0       	breq	.+24     	; 0x954 <tinyAxon_update_potential+0x122>
	{
		tinyAxon_should_fire = false;
     93c:	10 92 53 3e 	sts	0x3E53, r1	; 0x803e53 <tinyAxon_should_fire>
		tinyAxon_has_fired = true;
     940:	81 e0       	ldi	r24, 0x01	; 1
     942:	80 93 54 3e 	sts	0x3E54, r24	; 0x803e54 <tinyAxon_has_fired>
*/
static void tinyAxon_start_sending_pulse()
{
	if (NEURONTYPE == EXCITATORY_NEURON)
	{
		DAC_set_output(EXCITATORY_NEURON_OUTPUT);
     946:	87 ed       	ldi	r24, 0xD7	; 215
     948:	90 e0       	ldi	r25, 0x00	; 0
     94a:	4d dc       	rcall	.-1894   	; 0x1e6 <DAC_set_output>
		axonOutputValue=EXCITATORY_NEURON_OUTPUT;
     94c:	87 ed       	ldi	r24, 0xD7	; 215
     94e:	80 93 3d 3e 	sts	0x3E3D, r24	; 0x803e3d <axonOutputValue>
     952:	18 c0       	rjmp	.+48     	; 0x984 <tinyAxon_update_potential+0x152>
		tinyAxon_should_fire = false;
		tinyAxon_has_fired = true;
		
		tinyAxon_start_sending_pulse();
	}
	else if (tinyAxon_has_fired)
     954:	80 91 54 3e 	lds	r24, 0x3E54	; 0x803e54 <tinyAxon_has_fired>
     958:	88 23       	and	r24, r24
     95a:	19 f0       	breq	.+6      	; 0x962 <tinyAxon_update_potential+0x130>
	{
		tinyAxon_has_fired = false;
     95c:	10 92 54 3e 	sts	0x3E54, r1	; 0x803e54 <tinyAxon_has_fired>
     960:	11 c0       	rjmp	.+34     	; 0x984 <tinyAxon_update_potential+0x152>
}

static void tinyAxon_stop_sending_pulse()
{
	
	DAC_set_output(NO_SIGNAL_OUTPUT);
     962:	80 e0       	ldi	r24, 0x00	; 0
     964:	90 e0       	ldi	r25, 0x00	; 0
     966:	3f dc       	rcall	.-1922   	; 0x1e6 <DAC_set_output>
	axonOutputValue=NO_SIGNAL_OUTPUT;
     968:	10 92 3d 3e 	sts	0x3E3D, r1	; 0x803e3d <axonOutputValue>
     96c:	0b c0       	rjmp	.+22     	; 0x984 <tinyAxon_update_potential+0x152>
			potential += THRESHOLD_POTENTIAL;
		}
	}
	
	// If there are pulses in the queue, we want to reduce the time in each of the time_left_until_pulse elements
	if (pulses_in_queue > 0)
     96e:	80 91 52 3e 	lds	r24, 0x3E52	; 0x803e52 <pulses_in_queue>
     972:	88 23       	and	r24, r24
     974:	f9 f2       	breq	.-66     	; 0x934 <tinyAxon_update_potential+0x102>
     976:	ce e3       	ldi	r28, 0x3E	; 62
     978:	de e3       	ldi	r29, 0x3E	; 62
     97a:	02 e5       	ldi	r16, 0x52	; 82
     97c:	1e e3       	ldi	r17, 0x3E	; 62
Function to set firing.
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
     97e:	bb 24       	eor	r11, r11
     980:	b3 94       	inc	r11
     982:	c3 cf       	rjmp	.-122    	; 0x90a <tinyAxon_update_potential+0xd8>
	}
	
	// Here we set the actual output of the DAC (Digital to Analog Converter)
	tinyAxon_update_pulse_transmitter();
	
	tinyDebugger_send_uint8("Axon", axonOutputValue);
     984:	60 91 3d 3e 	lds	r22, 0x3E3D	; 0x803e3d <axonOutputValue>
     988:	86 e8       	ldi	r24, 0x86	; 134
     98a:	9c e9       	ldi	r25, 0x9C	; 156
     98c:	3d dd       	rcall	.-1414   	; 0x408 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("Pulses", pulses_in_queue);
     98e:	60 91 52 3e 	lds	r22, 0x3E52	; 0x803e52 <pulses_in_queue>
     992:	8b e8       	ldi	r24, 0x8B	; 139
     994:	9c e9       	ldi	r25, 0x9C	; 156
     996:	38 dd       	rcall	.-1424   	; 0x408 <tinyDebugger_send_uint8>
	
	return potential;
}
     998:	c7 01       	movw	r24, r14
     99a:	b6 01       	movw	r22, r12
     99c:	df 91       	pop	r29
     99e:	cf 91       	pop	r28
     9a0:	1f 91       	pop	r17
     9a2:	0f 91       	pop	r16
     9a4:	ff 90       	pop	r15
     9a6:	ef 90       	pop	r14
     9a8:	df 90       	pop	r13
     9aa:	cf 90       	pop	r12
     9ac:	bf 90       	pop	r11
     9ae:	08 95       	ret

000009b0 <tinyDendrite_update_signals>:
/*
This function converts the 8 bit value from the ADC into one of the signal types defined in DendriteSignal
We also update the charging state
*/
void tinyDendrite_update_signals(void)
{
     9b0:	2f 92       	push	r2
     9b2:	3f 92       	push	r3
     9b4:	4f 92       	push	r4
     9b6:	5f 92       	push	r5
     9b8:	6f 92       	push	r6
     9ba:	7f 92       	push	r7
     9bc:	8f 92       	push	r8
     9be:	9f 92       	push	r9
     9c0:	af 92       	push	r10
     9c2:	bf 92       	push	r11
     9c4:	cf 92       	push	r12
     9c6:	df 92       	push	r13
     9c8:	ef 92       	push	r14
     9ca:	ff 92       	push	r15
     9cc:	0f 93       	push	r16
     9ce:	1f 93       	push	r17
     9d0:	cf 93       	push	r28
     9d2:	df 93       	push	r29
     9d4:	00 e1       	ldi	r16, 0x10	; 16
     9d6:	1e e3       	ldi	r17, 0x3E	; 62
     9d8:	0f 2e       	mov	r0, r31
     9da:	ff e5       	ldi	r31, 0x5F	; 95
     9dc:	cf 2e       	mov	r12, r31
     9de:	fe e3       	ldi	r31, 0x3E	; 62
     9e0:	df 2e       	mov	r13, r31
     9e2:	f0 2d       	mov	r31, r0
     9e4:	0f 2e       	mov	r0, r31
     9e6:	f9 e6       	ldi	r31, 0x69	; 105
     9e8:	ef 2e       	mov	r14, r31
     9ea:	fe e3       	ldi	r31, 0x3E	; 62
     9ec:	ff 2e       	mov	r15, r31
     9ee:	f0 2d       	mov	r31, r0
     9f0:	e6 01       	movw	r28, r12
*/
static void tinyDendrite_read_signals(void)
{
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_values[i] = ADC_get_conversion(Dendrite_ports[i]);
     9f2:	f8 01       	movw	r30, r16
     9f4:	81 91       	ld	r24, Z+
     9f6:	8f 01       	movw	r16, r30
     9f8:	c1 db       	rcall	.-2174   	; 0x17c <ADC_get_conversion>
     9fa:	89 93       	st	Y+, r24
     9fc:	99 93       	st	Y+, r25
/*
This function reads the voltage at the Dendrite inputs with the ADC
*/
static void tinyDendrite_read_signals(void)
{
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
     9fe:	ce 15       	cp	r28, r14
     a00:	df 05       	cpc	r29, r15
     a02:	b9 f7       	brne	.-18     	; 0x9f2 <tinyDendrite_update_signals+0x42>
	{
		tinyDendrite_values[i] = ADC_get_conversion(Dendrite_ports[i]);
	}
	tinyDebugger_send_int("D1", tinyDendrite_values[0]);
     a04:	cf e5       	ldi	r28, 0x5F	; 95
     a06:	de e3       	ldi	r29, 0x3E	; 62
     a08:	68 81       	ld	r22, Y
     a0a:	79 81       	ldd	r23, Y+1	; 0x01
     a0c:	82 e9       	ldi	r24, 0x92	; 146
     a0e:	9c e9       	ldi	r25, 0x9C	; 156
     a10:	eb dc       	rcall	.-1578   	; 0x3e8 <tinyDebugger_send_int>
	tinyDebugger_send_int("D2", tinyDendrite_values[1]);
     a12:	6a 81       	ldd	r22, Y+2	; 0x02
     a14:	7b 81       	ldd	r23, Y+3	; 0x03
     a16:	85 e9       	ldi	r24, 0x95	; 149
     a18:	9c e9       	ldi	r25, 0x9C	; 156
     a1a:	e6 dc       	rcall	.-1588   	; 0x3e8 <tinyDebugger_send_int>
	tinyDebugger_send_int("D3", tinyDendrite_values[2]);
     a1c:	6c 81       	ldd	r22, Y+4	; 0x04
     a1e:	7d 81       	ldd	r23, Y+5	; 0x05
     a20:	88 e9       	ldi	r24, 0x98	; 152
     a22:	9c e9       	ldi	r25, 0x9C	; 156
     a24:	e1 dc       	rcall	.-1598   	; 0x3e8 <tinyDebugger_send_int>
	tinyDebugger_send_int("D4", tinyDendrite_values[3]);
     a26:	6e 81       	ldd	r22, Y+6	; 0x06
     a28:	7f 81       	ldd	r23, Y+7	; 0x07
     a2a:	8b e9       	ldi	r24, 0x9B	; 155
     a2c:	9c e9       	ldi	r25, 0x9C	; 156
     a2e:	dc dc       	rcall	.-1608   	; 0x3e8 <tinyDebugger_send_int>
	tinyDebugger_send_int("D5", tinyDendrite_values[4]);
     a30:	68 85       	ldd	r22, Y+8	; 0x08
     a32:	79 85       	ldd	r23, Y+9	; 0x09
     a34:	8e e9       	ldi	r24, 0x9E	; 158
     a36:	9c e9       	ldi	r25, 0x9C	; 156
     a38:	d7 dc       	rcall	.-1618   	; 0x3e8 <tinyDebugger_send_int>
{
	
	//Read the analog voltage values on each of the Dendrites
	tinyDendrite_read_signals();
	
	tinyCharge_set_charging(false);
     a3a:	80 e0       	ldi	r24, 0x00	; 0
     a3c:	ca dc       	rcall	.-1644   	; 0x3d2 <tinyCharge_set_charging>
     a3e:	ca e5       	ldi	r28, 0x5A	; 90
     a40:	de e3       	ldi	r29, 0x3E	; 62
     a42:	05 e5       	ldi	r16, 0x55	; 85
     a44:	1e e3       	ldi	r17, 0x3E	; 62
     a46:	0f 2e       	mov	r0, r31
     a48:	ff e5       	ldi	r31, 0x5F	; 95
     a4a:	8f 2e       	mov	r8, r31
     a4c:	fe e3       	ldi	r31, 0x3E	; 62
     a4e:	9f 2e       	mov	r9, r31
     a50:	f0 2d       	mov	r31, r0
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     a52:	66 24       	eor	r6, r6
     a54:	63 94       	inc	r6
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     a56:	68 94       	set
     a58:	22 24       	eor	r2, r2
     a5a:	21 f8       	bld	r2, 1
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     a5c:	68 94       	set
     a5e:	33 24       	eor	r3, r3
     a60:	32 f8       	bld	r3, 2
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     a62:	0f 2e       	mov	r0, r31
     a64:	f6 e0       	ldi	r31, 0x06	; 6
     a66:	4f 2e       	mov	r4, r31
     a68:	f0 2d       	mov	r31, r0
			tinyDendrite_current_signals[i] = CHARGING;
			tinyCharge_set_charging(true);
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     a6a:	0f 2e       	mov	r0, r31
     a6c:	f5 e0       	ldi	r31, 0x05	; 5
     a6e:	7f 2e       	mov	r7, r31
     a70:	f0 2d       	mov	r31, r0
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = CHARGING;
     a72:	0f 2e       	mov	r0, r31
     a74:	f7 e0       	ldi	r31, 0x07	; 7
     a76:	5f 2e       	mov	r5, r31
     a78:	f0 2d       	mov	r31, r0
     a7a:	7e 01       	movw	r14, r28
     a7c:	58 01       	movw	r10, r16
	
	tinyCharge_set_charging(false);
	
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
     a7e:	88 81       	ld	r24, Y
     a80:	f8 01       	movw	r30, r16
     a82:	80 83       	st	Z, r24
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
     a84:	f6 01       	movw	r30, r12
     a86:	81 91       	ld	r24, Z+
     a88:	91 91       	ld	r25, Z+
     a8a:	6f 01       	movw	r12, r30
     a8c:	89 3e       	cpi	r24, 0xE9	; 233
     a8e:	91 05       	cpc	r25, r1
     a90:	20 f0       	brcs	.+8      	; 0xa9a <tinyDendrite_update_signals+0xea>
		{
			tinyDendrite_current_signals[i] = CHARGING;
     a92:	58 82       	st	Y, r5
			tinyCharge_set_charging(true);
     a94:	86 2d       	mov	r24, r6
     a96:	9d dc       	rcall	.-1734   	; 0x3d2 <tinyCharge_set_charging>
     a98:	1f c0       	rjmp	.+62     	; 0xad8 <tinyDendrite_update_signals+0x128>
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
     a9a:	88 3c       	cpi	r24, 0xC8	; 200
     a9c:	91 05       	cpc	r25, r1
     a9e:	10 f0       	brcs	.+4      	; 0xaa4 <tinyDendrite_update_signals+0xf4>
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     aa0:	78 82       	st	Y, r7
     aa2:	1a c0       	rjmp	.+52     	; 0xad8 <tinyDendrite_update_signals+0x128>
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
     aa4:	87 3a       	cpi	r24, 0xA7	; 167
     aa6:	91 05       	cpc	r25, r1
     aa8:	10 f0       	brcs	.+4      	; 0xaae <tinyDendrite_update_signals+0xfe>
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     aaa:	48 82       	st	Y, r4
     aac:	15 c0       	rjmp	.+42     	; 0xad8 <tinyDendrite_update_signals+0x128>
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
     aae:	85 38       	cpi	r24, 0x85	; 133
     ab0:	91 05       	cpc	r25, r1
     ab2:	10 f0       	brcs	.+4      	; 0xab8 <tinyDendrite_update_signals+0x108>
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     ab4:	38 82       	st	Y, r3
     ab6:	10 c0       	rjmp	.+32     	; 0xad8 <tinyDendrite_update_signals+0x128>
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
     ab8:	84 36       	cpi	r24, 0x64	; 100
     aba:	91 05       	cpc	r25, r1
     abc:	10 f0       	brcs	.+4      	; 0xac2 <tinyDendrite_update_signals+0x112>
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     abe:	28 82       	st	Y, r2
     ac0:	0b c0       	rjmp	.+22     	; 0xad8 <tinyDendrite_update_signals+0x128>
		}
		else if (tinyDendrite_values[i] > HIGH_INHIB_THRESHOLD)
     ac2:	83 34       	cpi	r24, 0x43	; 67
     ac4:	91 05       	cpc	r25, r1
     ac6:	18 f0       	brcs	.+6      	; 0xace <tinyDendrite_update_signals+0x11e>
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
     ac8:	83 e0       	ldi	r24, 0x03	; 3
     aca:	88 83       	st	Y, r24
     acc:	05 c0       	rjmp	.+10     	; 0xad8 <tinyDendrite_update_signals+0x128>
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
     ace:	82 97       	sbiw	r24, 0x22	; 34
     ad0:	10 f0       	brcs	.+4      	; 0xad6 <tinyDendrite_update_signals+0x126>
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     ad2:	68 82       	st	Y, r6
     ad4:	01 c0       	rjmp	.+2      	; 0xad8 <tinyDendrite_update_signals+0x128>
		}
		else
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     ad6:	18 82       	st	Y, r1
     ad8:	0f 5f       	subi	r16, 0xFF	; 255
     ada:	1f 4f       	sbci	r17, 0xFF	; 255
		}
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
     adc:	f7 01       	movw	r30, r14
     ade:	90 81       	ld	r25, Z
     ae0:	f5 01       	movw	r30, r10
     ae2:	80 81       	ld	r24, Z
     ae4:	98 13       	cpse	r25, r24
     ae6:	02 c0       	rjmp	.+4      	; 0xaec <tinyDendrite_update_signals+0x13c>
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     ae8:	f7 01       	movw	r30, r14
     aea:	10 82       	st	Z, r1
     aec:	21 96       	adiw	r28, 0x01	; 1
	//Read the analog voltage values on each of the Dendrites
	tinyDendrite_read_signals();
	
	tinyCharge_set_charging(false);
	
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
     aee:	c8 15       	cp	r28, r8
     af0:	d9 05       	cpc	r29, r9
     af2:	19 f6       	brne	.-122    	; 0xa7a <tinyDendrite_update_signals+0xca>
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
		}
	}
}
     af4:	df 91       	pop	r29
     af6:	cf 91       	pop	r28
     af8:	1f 91       	pop	r17
     afa:	0f 91       	pop	r16
     afc:	ff 90       	pop	r15
     afe:	ef 90       	pop	r14
     b00:	df 90       	pop	r13
     b02:	cf 90       	pop	r12
     b04:	bf 90       	pop	r11
     b06:	af 90       	pop	r10
     b08:	9f 90       	pop	r9
     b0a:	8f 90       	pop	r8
     b0c:	7f 90       	pop	r7
     b0e:	6f 90       	pop	r6
     b10:	5f 90       	pop	r5
     b12:	4f 90       	pop	r4
     b14:	3f 90       	pop	r3
     b16:	2f 90       	pop	r2
     b18:	08 95       	ret

00000b1a <tinyDendrite_get_potential>:
outside. It uses the previously declared functions to return the potential.
*/
int16_t tinyDendrite_get_potential()
{
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
     b1a:	4a df       	rcall	.-364    	; 0x9b0 <tinyDendrite_update_signals>
     b1c:	ea e5       	ldi	r30, 0x5A	; 90
     b1e:	fe e3       	ldi	r31, 0x3E	; 62
     b20:	4f e5       	ldi	r20, 0x5F	; 95
     b22:	5e e3       	ldi	r21, 0x3E	; 62
	
	int16_t return_potential_val = 0;
     b24:	20 e0       	ldi	r18, 0x00	; 0
     b26:	30 e0       	ldi	r19, 0x00	; 0
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		switch(tinyDendrite_current_signals[i])
     b28:	91 91       	ld	r25, Z+
     b2a:	93 30       	cpi	r25, 0x03	; 3
     b2c:	a1 f0       	breq	.+40     	; 0xb56 <tinyDendrite_get_potential+0x3c>
     b2e:	28 f4       	brcc	.+10     	; 0xb3a <tinyDendrite_get_potential+0x20>
     b30:	91 30       	cpi	r25, 0x01	; 1
     b32:	b9 f0       	breq	.+46     	; 0xb62 <tinyDendrite_get_potential+0x48>
     b34:	92 30       	cpi	r25, 0x02	; 2
     b36:	91 f0       	breq	.+36     	; 0xb5c <tinyDendrite_get_potential+0x42>
     b38:	16 c0       	rjmp	.+44     	; 0xb66 <tinyDendrite_get_potential+0x4c>
     b3a:	95 30       	cpi	r25, 0x05	; 5
     b3c:	31 f0       	breq	.+12     	; 0xb4a <tinyDendrite_get_potential+0x30>
     b3e:	40 f0       	brcs	.+16     	; 0xb50 <tinyDendrite_get_potential+0x36>
     b40:	96 30       	cpi	r25, 0x06	; 6
     b42:	89 f4       	brne	.+34     	; 0xb66 <tinyDendrite_get_potential+0x4c>
		{
			case NO_SIGNAL:
				return_potential_val += NO_SIGNAL_REACTION;
				break;
			case HIGH_EXCITE:
				return_potential_val += HIGH_EXCITE_REACTION;
     b44:	2c 5c       	subi	r18, 0xCC	; 204
     b46:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     b48:	0e c0       	rjmp	.+28     	; 0xb66 <tinyDendrite_get_potential+0x4c>
			case NORMAL_EXCITE:
				return_potential_val += NORMAL_EXCITE_REACTION;
     b4a:	26 5e       	subi	r18, 0xE6	; 230
     b4c:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     b4e:	0b c0       	rjmp	.+22     	; 0xb66 <tinyDendrite_get_potential+0x4c>
			case LOW_EXCITE:
				return_potential_val += LOW_EXCITE_REACTION;
     b50:	2c 5e       	subi	r18, 0xEC	; 236
     b52:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     b54:	08 c0       	rjmp	.+16     	; 0xb66 <tinyDendrite_get_potential+0x4c>
			case HIGH_INHIB:
				return_potential_val += HIGH_INHIB_REACTION;
     b56:	22 53       	subi	r18, 0x32	; 50
     b58:	31 09       	sbc	r19, r1
				break;
     b5a:	05 c0       	rjmp	.+10     	; 0xb66 <tinyDendrite_get_potential+0x4c>
			case NORMAL_INHIB:
				return_potential_val += NORMAL_INHIB_REACTION;
     b5c:	2a 51       	subi	r18, 0x1A	; 26
     b5e:	31 09       	sbc	r19, r1
				break;
     b60:	02 c0       	rjmp	.+4      	; 0xb66 <tinyDendrite_get_potential+0x4c>
			case LOW_INHIB:
				return_potential_val += LOW_INHIB_REACTION;
     b62:	24 51       	subi	r18, 0x14	; 20
     b64:	31 09       	sbc	r19, r1
{
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
	
	int16_t return_potential_val = 0;
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
     b66:	e4 17       	cp	r30, r20
     b68:	f5 07       	cpc	r31, r21
     b6a:	f1 f6       	brne	.-68     	; 0xb28 <tinyDendrite_get_potential+0xe>
			default:
				break;
		}
	}
	return return_potential_val;
}
     b6c:	c9 01       	movw	r24, r18
     b6e:	08 95       	ret

00000b70 <tinyDendrite_update_potential>:

double tinyDendrite_update_potential(double potential){
     b70:	cf 92       	push	r12
     b72:	df 92       	push	r13
     b74:	ef 92       	push	r14
     b76:	ff 92       	push	r15
     b78:	6b 01       	movw	r12, r22
     b7a:	7c 01       	movw	r14, r24
	
	uint16_t potential_change = tinyDendrite_get_potential();
     b7c:	ce df       	rcall	.-100    	; 0xb1a <tinyDendrite_get_potential>
	potential += potential_change;
	return potential;
     b7e:	bc 01       	movw	r22, r24
     b80:	80 e0       	ldi	r24, 0x00	; 0
     b82:	90 e0       	ldi	r25, 0x00	; 0
     b84:	bb d1       	rcall	.+886    	; 0xefc <__floatunsisf>
     b86:	a7 01       	movw	r20, r14
     b88:	96 01       	movw	r18, r12
     b8a:	9f d0       	rcall	.+318    	; 0xcca <__addsf3>
     b8c:	ff 90       	pop	r15
     b8e:	ef 90       	pop	r14
     b90:	df 90       	pop	r13
     b92:	cf 90       	pop	r12
     b94:	08 95       	ret

00000b96 <__vector_6>:
This function is called every time the RTC (Real Time Clock) counter overflows.
With the current settings, it will be called every ms.
The RTC clock runs at 1kHz, and the number of cycles before overflow is set with RTC.PER = someHexValue (e.g. 0x20) in src/rtc.c
*/
ISR(RTC_CNT_vect)
{
     b96:	1f 92       	push	r1
     b98:	0f 92       	push	r0
     b9a:	0f b6       	in	r0, 0x3f	; 63
     b9c:	0f 92       	push	r0
     b9e:	11 24       	eor	r1, r1
     ba0:	2f 93       	push	r18
     ba2:	3f 93       	push	r19
     ba4:	4f 93       	push	r20
     ba6:	5f 93       	push	r21
     ba8:	6f 93       	push	r22
     baa:	7f 93       	push	r23
     bac:	8f 93       	push	r24
     bae:	9f 93       	push	r25
     bb0:	af 93       	push	r26
     bb2:	bf 93       	push	r27
     bb4:	cf 93       	push	r28
     bb6:	ef 93       	push	r30
     bb8:	ff 93       	push	r31
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     bba:	c1 e0       	ldi	r28, 0x01	; 1
     bbc:	c0 93 69 3e 	sts	0x3E69, r28	; 0x803e69 <tinyISR_interrupt_flag>
{
	// Set flag to let main loop run a new cycle
	tinyISR_setflag(true);
	
	// Timer counter incrementation
	tinyTime_counter_increment();
     bc0:	a7 dc       	rcall	.-1714   	; 0x510 <tinyTime_counter_increment>

	/* Overflow interrupt flag has to be cleared manually */
	RTC.INTFLAGS = RTC_OVF_bm;
     bc2:	c0 93 43 01 	sts	0x0143, r28	; 0x800143 <__TEXT_REGION_LENGTH__+0x700143>
}
     bc6:	ff 91       	pop	r31
     bc8:	ef 91       	pop	r30
     bca:	cf 91       	pop	r28
     bcc:	bf 91       	pop	r27
     bce:	af 91       	pop	r26
     bd0:	9f 91       	pop	r25
     bd2:	8f 91       	pop	r24
     bd4:	7f 91       	pop	r23
     bd6:	6f 91       	pop	r22
     bd8:	5f 91       	pop	r21
     bda:	4f 91       	pop	r20
     bdc:	3f 91       	pop	r19
     bde:	2f 91       	pop	r18
     be0:	0f 90       	pop	r0
     be2:	0f be       	out	0x3f, r0	; 63
     be4:	0f 90       	pop	r0
     be6:	1f 90       	pop	r1
     be8:	18 95       	reti

00000bea <tinyISR_setflag>:
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     bea:	80 93 69 3e 	sts	0x3E69, r24	; 0x803e69 <tinyISR_interrupt_flag>
     bee:	08 95       	ret

00000bf0 <tinyISR_getflag>:
}

_Bool tinyISR_getflag(void)
{
	return tinyISR_interrupt_flag;
}
     bf0:	80 91 69 3e 	lds	r24, 0x3E69	; 0x803e69 <tinyISR_interrupt_flag>
     bf4:	08 95       	ret

00000bf6 <tinyPotential_update>:
/*
The function which will run in the main loop.
This function will run on interrupts by the RTC module.
*/
void tinyPotential_update()
{
     bf6:	cf 92       	push	r12
     bf8:	df 92       	push	r13
     bfa:	ef 92       	push	r14
     bfc:	ff 92       	push	r15
	tinyDebugger_send_double("Potential", tinyPotential_potential);
     bfe:	40 91 6a 3e 	lds	r20, 0x3E6A	; 0x803e6a <tinyPotential_potential>
     c02:	50 91 6b 3e 	lds	r21, 0x3E6B	; 0x803e6b <tinyPotential_potential+0x1>
     c06:	60 91 6c 3e 	lds	r22, 0x3E6C	; 0x803e6c <tinyPotential_potential+0x2>
     c0a:	70 91 6d 3e 	lds	r23, 0x3E6D	; 0x803e6d <tinyPotential_potential+0x3>
     c0e:	81 ea       	ldi	r24, 0xA1	; 161
     c10:	9c e9       	ldi	r25, 0x9C	; 156
     c12:	0a dc       	rcall	.-2028   	; 0x428 <tinyDebugger_send_double>
	// Previously, we kept track of time in case the microchip for some reason uses more than one ms on a cycle
	// but for simplification, we just assume that each cycle will take one ms. The consequences for a cycle taking longer
	// are negligible. 
	
	double time_since_last_update = 1;
	tinyPotential_potential *= (exp(-(time_since_last_update/TINYPOTENTIAL_TIME_CONST)));
     c14:	28 ee       	ldi	r18, 0xE8	; 232
     c16:	33 e7       	ldi	r19, 0x73	; 115
     c18:	4d e7       	ldi	r20, 0x7D	; 125
     c1a:	5f e3       	ldi	r21, 0x3F	; 63
     c1c:	60 91 6a 3e 	lds	r22, 0x3E6A	; 0x803e6a <tinyPotential_potential>
     c20:	70 91 6b 3e 	lds	r23, 0x3E6B	; 0x803e6b <tinyPotential_potential+0x1>
     c24:	80 91 6c 3e 	lds	r24, 0x3E6C	; 0x803e6c <tinyPotential_potential+0x2>
     c28:	90 91 6d 3e 	lds	r25, 0x3E6D	; 0x803e6d <tinyPotential_potential+0x3>
     c2c:	1e d2       	rcall	.+1084   	; 0x106a <__mulsf3>
     c2e:	6b 01       	movw	r12, r22
     c30:	7c 01       	movw	r14, r24
	if(fabs(tinyPotential_potential)<0.1){
     c32:	9f 77       	andi	r25, 0x7F	; 127
     c34:	2d ec       	ldi	r18, 0xCD	; 205
     c36:	3c ec       	ldi	r19, 0xCC	; 204
     c38:	4c ec       	ldi	r20, 0xCC	; 204
     c3a:	5d e3       	ldi	r21, 0x3D	; 61
     c3c:	b2 d0       	rcall	.+356    	; 0xda2 <__cmpsf2>
     c3e:	88 23       	and	r24, r24
     c40:	4c f0       	brlt	.+18     	; 0xc54 <tinyPotential_update+0x5e>
	// Previously, we kept track of time in case the microchip for some reason uses more than one ms on a cycle
	// but for simplification, we just assume that each cycle will take one ms. The consequences for a cycle taking longer
	// are negligible. 
	
	double time_since_last_update = 1;
	tinyPotential_potential *= (exp(-(time_since_last_update/TINYPOTENTIAL_TIME_CONST)));
     c42:	c0 92 6a 3e 	sts	0x3E6A, r12	; 0x803e6a <tinyPotential_potential>
     c46:	d0 92 6b 3e 	sts	0x3E6B, r13	; 0x803e6b <tinyPotential_potential+0x1>
     c4a:	e0 92 6c 3e 	sts	0x3E6C, r14	; 0x803e6c <tinyPotential_potential+0x2>
     c4e:	f0 92 6d 3e 	sts	0x3E6D, r15	; 0x803e6d <tinyPotential_potential+0x3>
     c52:	08 c0       	rjmp	.+16     	; 0xc64 <tinyPotential_update+0x6e>
	if(fabs(tinyPotential_potential)<0.1){
		tinyPotential_potential=0;
     c54:	10 92 6a 3e 	sts	0x3E6A, r1	; 0x803e6a <tinyPotential_potential>
     c58:	10 92 6b 3e 	sts	0x3E6B, r1	; 0x803e6b <tinyPotential_potential+0x1>
     c5c:	10 92 6c 3e 	sts	0x3E6C, r1	; 0x803e6c <tinyPotential_potential+0x2>
     c60:	10 92 6d 3e 	sts	0x3E6D, r1	; 0x803e6d <tinyPotential_potential+0x3>
	tinyDebugger_send_double("Potential", tinyPotential_potential);
	//Some of the potential in the neuron has decayed away
	tinyPotential_decay();
	
	// Update potential with values from Dendrites
	tinyPotential_potential = tinyDendrite_update_potential(tinyPotential_potential);
     c64:	60 91 6a 3e 	lds	r22, 0x3E6A	; 0x803e6a <tinyPotential_potential>
     c68:	70 91 6b 3e 	lds	r23, 0x3E6B	; 0x803e6b <tinyPotential_potential+0x1>
     c6c:	80 91 6c 3e 	lds	r24, 0x3E6C	; 0x803e6c <tinyPotential_potential+0x2>
     c70:	90 91 6d 3e 	lds	r25, 0x3E6D	; 0x803e6d <tinyPotential_potential+0x3>
     c74:	7d df       	rcall	.-262    	; 0xb70 <tinyDendrite_update_potential>
     c76:	60 93 6a 3e 	sts	0x3E6A, r22	; 0x803e6a <tinyPotential_potential>
     c7a:	70 93 6b 3e 	sts	0x3E6B, r23	; 0x803e6b <tinyPotential_potential+0x1>
     c7e:	80 93 6c 3e 	sts	0x3E6C, r24	; 0x803e6c <tinyPotential_potential+0x2>
     c82:	90 93 6d 3e 	sts	0x3E6D, r25	; 0x803e6d <tinyPotential_potential+0x3>
	
	// Update potential from button press
	tinyPotential_potential = tinyButton_update_potential(tinyPotential_potential);
     c86:	66 dd       	rcall	.-1332   	; 0x754 <tinyButton_update_potential>
     c88:	60 93 6a 3e 	sts	0x3E6A, r22	; 0x803e6a <tinyPotential_potential>
     c8c:	70 93 6b 3e 	sts	0x3E6B, r23	; 0x803e6b <tinyPotential_potential+0x1>
     c90:	80 93 6c 3e 	sts	0x3E6C, r24	; 0x803e6c <tinyPotential_potential+0x2>
     c94:	90 93 6d 3e 	sts	0x3E6D, r25	; 0x803e6d <tinyPotential_potential+0x3>
	
	// Update potential with values from spontaneous pulse.
	tinyPotential_potential = tinyPulse_update_potential(tinyPotential_potential);
     c98:	06 dc       	rcall	.-2036   	; 0x4a6 <tinyPulse_update_potential>
     c9a:	60 93 6a 3e 	sts	0x3E6A, r22	; 0x803e6a <tinyPotential_potential>
     c9e:	70 93 6b 3e 	sts	0x3E6B, r23	; 0x803e6b <tinyPotential_potential+0x1>
     ca2:	80 93 6c 3e 	sts	0x3E6C, r24	; 0x803e6c <tinyPotential_potential+0x2>
     ca6:	90 93 6d 3e 	sts	0x3E6D, r25	; 0x803e6d <tinyPotential_potential+0x3>
	
	// Let the axon affect the potential
	// This is also where we decide whether or not the axon should fire
	tinyPotential_potential = tinyAxon_update_potential(tinyPotential_potential);
     caa:	c3 dd       	rcall	.-1146   	; 0x832 <tinyAxon_update_potential>
     cac:	60 93 6a 3e 	sts	0x3E6A, r22	; 0x803e6a <tinyPotential_potential>
     cb0:	70 93 6b 3e 	sts	0x3E6B, r23	; 0x803e6b <tinyPotential_potential+0x1>
     cb4:	80 93 6c 3e 	sts	0x3E6C, r24	; 0x803e6c <tinyPotential_potential+0x2>
     cb8:	90 93 6d 3e 	sts	0x3E6D, r25	; 0x803e6d <tinyPotential_potential+0x3>

	//Update the led
	potential_to_RGB_update_LEDs(tinyPotential_potential);
     cbc:	72 dc       	rcall	.-1820   	; 0x5a2 <potential_to_RGB_update_LEDs>
}
     cbe:	ff 90       	pop	r15
     cc0:	ef 90       	pop	r14
     cc2:	df 90       	pop	r13
     cc4:	cf 90       	pop	r12
     cc6:	08 95       	ret

00000cc8 <__subsf3>:
     cc8:	50 58       	subi	r21, 0x80	; 128

00000cca <__addsf3>:
     cca:	bb 27       	eor	r27, r27
     ccc:	aa 27       	eor	r26, r26
     cce:	0e 94 7c 06 	call	0xcf8	; 0xcf8 <__addsf3x>
     cd2:	0c 94 f6 07 	jmp	0xfec	; 0xfec <__fp_round>
     cd6:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <__fp_pscA>
     cda:	38 f0       	brcs	.+14     	; 0xcea <__addsf3+0x20>
     cdc:	0e 94 ef 07 	call	0xfde	; 0xfde <__fp_pscB>
     ce0:	20 f0       	brcs	.+8      	; 0xcea <__addsf3+0x20>
     ce2:	39 f4       	brne	.+14     	; 0xcf2 <__addsf3+0x28>
     ce4:	9f 3f       	cpi	r25, 0xFF	; 255
     ce6:	19 f4       	brne	.+6      	; 0xcee <__addsf3+0x24>
     ce8:	26 f4       	brtc	.+8      	; 0xcf2 <__addsf3+0x28>
     cea:	0c 94 e5 07 	jmp	0xfca	; 0xfca <__fp_nan>
     cee:	0e f4       	brtc	.+2      	; 0xcf2 <__addsf3+0x28>
     cf0:	e0 95       	com	r30
     cf2:	e7 fb       	bst	r30, 7
     cf4:	0c 94 df 07 	jmp	0xfbe	; 0xfbe <__fp_inf>

00000cf8 <__addsf3x>:
     cf8:	e9 2f       	mov	r30, r25
     cfa:	0e 94 07 08 	call	0x100e	; 0x100e <__fp_split3>
     cfe:	58 f3       	brcs	.-42     	; 0xcd6 <__addsf3+0xc>
     d00:	ba 17       	cp	r27, r26
     d02:	62 07       	cpc	r22, r18
     d04:	73 07       	cpc	r23, r19
     d06:	84 07       	cpc	r24, r20
     d08:	95 07       	cpc	r25, r21
     d0a:	20 f0       	brcs	.+8      	; 0xd14 <__addsf3x+0x1c>
     d0c:	79 f4       	brne	.+30     	; 0xd2c <__addsf3x+0x34>
     d0e:	a6 f5       	brtc	.+104    	; 0xd78 <__addsf3x+0x80>
     d10:	0c 94 29 08 	jmp	0x1052	; 0x1052 <__fp_zero>
     d14:	0e f4       	brtc	.+2      	; 0xd18 <__addsf3x+0x20>
     d16:	e0 95       	com	r30
     d18:	0b 2e       	mov	r0, r27
     d1a:	ba 2f       	mov	r27, r26
     d1c:	a0 2d       	mov	r26, r0
     d1e:	0b 01       	movw	r0, r22
     d20:	b9 01       	movw	r22, r18
     d22:	90 01       	movw	r18, r0
     d24:	0c 01       	movw	r0, r24
     d26:	ca 01       	movw	r24, r20
     d28:	a0 01       	movw	r20, r0
     d2a:	11 24       	eor	r1, r1
     d2c:	ff 27       	eor	r31, r31
     d2e:	59 1b       	sub	r21, r25
     d30:	99 f0       	breq	.+38     	; 0xd58 <__addsf3x+0x60>
     d32:	59 3f       	cpi	r21, 0xF9	; 249
     d34:	50 f4       	brcc	.+20     	; 0xd4a <__addsf3x+0x52>
     d36:	50 3e       	cpi	r21, 0xE0	; 224
     d38:	68 f1       	brcs	.+90     	; 0xd94 <__addsf3x+0x9c>
     d3a:	1a 16       	cp	r1, r26
     d3c:	f0 40       	sbci	r31, 0x00	; 0
     d3e:	a2 2f       	mov	r26, r18
     d40:	23 2f       	mov	r18, r19
     d42:	34 2f       	mov	r19, r20
     d44:	44 27       	eor	r20, r20
     d46:	58 5f       	subi	r21, 0xF8	; 248
     d48:	f3 cf       	rjmp	.-26     	; 0xd30 <__addsf3x+0x38>
     d4a:	46 95       	lsr	r20
     d4c:	37 95       	ror	r19
     d4e:	27 95       	ror	r18
     d50:	a7 95       	ror	r26
     d52:	f0 40       	sbci	r31, 0x00	; 0
     d54:	53 95       	inc	r21
     d56:	c9 f7       	brne	.-14     	; 0xd4a <__addsf3x+0x52>
     d58:	7e f4       	brtc	.+30     	; 0xd78 <__addsf3x+0x80>
     d5a:	1f 16       	cp	r1, r31
     d5c:	ba 0b       	sbc	r27, r26
     d5e:	62 0b       	sbc	r22, r18
     d60:	73 0b       	sbc	r23, r19
     d62:	84 0b       	sbc	r24, r20
     d64:	ba f0       	brmi	.+46     	; 0xd94 <__addsf3x+0x9c>
     d66:	91 50       	subi	r25, 0x01	; 1
     d68:	a1 f0       	breq	.+40     	; 0xd92 <__addsf3x+0x9a>
     d6a:	ff 0f       	add	r31, r31
     d6c:	bb 1f       	adc	r27, r27
     d6e:	66 1f       	adc	r22, r22
     d70:	77 1f       	adc	r23, r23
     d72:	88 1f       	adc	r24, r24
     d74:	c2 f7       	brpl	.-16     	; 0xd66 <__addsf3x+0x6e>
     d76:	0e c0       	rjmp	.+28     	; 0xd94 <__addsf3x+0x9c>
     d78:	ba 0f       	add	r27, r26
     d7a:	62 1f       	adc	r22, r18
     d7c:	73 1f       	adc	r23, r19
     d7e:	84 1f       	adc	r24, r20
     d80:	48 f4       	brcc	.+18     	; 0xd94 <__addsf3x+0x9c>
     d82:	87 95       	ror	r24
     d84:	77 95       	ror	r23
     d86:	67 95       	ror	r22
     d88:	b7 95       	ror	r27
     d8a:	f7 95       	ror	r31
     d8c:	9e 3f       	cpi	r25, 0xFE	; 254
     d8e:	08 f0       	brcs	.+2      	; 0xd92 <__addsf3x+0x9a>
     d90:	b0 cf       	rjmp	.-160    	; 0xcf2 <__addsf3+0x28>
     d92:	93 95       	inc	r25
     d94:	88 0f       	add	r24, r24
     d96:	08 f0       	brcs	.+2      	; 0xd9a <__addsf3x+0xa2>
     d98:	99 27       	eor	r25, r25
     d9a:	ee 0f       	add	r30, r30
     d9c:	97 95       	ror	r25
     d9e:	87 95       	ror	r24
     da0:	08 95       	ret

00000da2 <__cmpsf2>:
     da2:	0e 94 bb 07 	call	0xf76	; 0xf76 <__fp_cmp>
     da6:	08 f4       	brcc	.+2      	; 0xdaa <__cmpsf2+0x8>
     da8:	81 e0       	ldi	r24, 0x01	; 1
     daa:	08 95       	ret

00000dac <__divsf3>:
     dac:	0e 94 ea 06 	call	0xdd4	; 0xdd4 <__divsf3x>
     db0:	0c 94 f6 07 	jmp	0xfec	; 0xfec <__fp_round>
     db4:	0e 94 ef 07 	call	0xfde	; 0xfde <__fp_pscB>
     db8:	58 f0       	brcs	.+22     	; 0xdd0 <__divsf3+0x24>
     dba:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <__fp_pscA>
     dbe:	40 f0       	brcs	.+16     	; 0xdd0 <__divsf3+0x24>
     dc0:	29 f4       	brne	.+10     	; 0xdcc <__divsf3+0x20>
     dc2:	5f 3f       	cpi	r21, 0xFF	; 255
     dc4:	29 f0       	breq	.+10     	; 0xdd0 <__divsf3+0x24>
     dc6:	0c 94 df 07 	jmp	0xfbe	; 0xfbe <__fp_inf>
     dca:	51 11       	cpse	r21, r1
     dcc:	0c 94 2a 08 	jmp	0x1054	; 0x1054 <__fp_szero>
     dd0:	0c 94 e5 07 	jmp	0xfca	; 0xfca <__fp_nan>

00000dd4 <__divsf3x>:
     dd4:	0e 94 07 08 	call	0x100e	; 0x100e <__fp_split3>
     dd8:	68 f3       	brcs	.-38     	; 0xdb4 <__divsf3+0x8>

00000dda <__divsf3_pse>:
     dda:	99 23       	and	r25, r25
     ddc:	b1 f3       	breq	.-20     	; 0xdca <__divsf3+0x1e>
     dde:	55 23       	and	r21, r21
     de0:	91 f3       	breq	.-28     	; 0xdc6 <__divsf3+0x1a>
     de2:	95 1b       	sub	r25, r21
     de4:	55 0b       	sbc	r21, r21
     de6:	bb 27       	eor	r27, r27
     de8:	aa 27       	eor	r26, r26
     dea:	62 17       	cp	r22, r18
     dec:	73 07       	cpc	r23, r19
     dee:	84 07       	cpc	r24, r20
     df0:	38 f0       	brcs	.+14     	; 0xe00 <__divsf3_pse+0x26>
     df2:	9f 5f       	subi	r25, 0xFF	; 255
     df4:	5f 4f       	sbci	r21, 0xFF	; 255
     df6:	22 0f       	add	r18, r18
     df8:	33 1f       	adc	r19, r19
     dfa:	44 1f       	adc	r20, r20
     dfc:	aa 1f       	adc	r26, r26
     dfe:	a9 f3       	breq	.-22     	; 0xdea <__divsf3_pse+0x10>
     e00:	35 d0       	rcall	.+106    	; 0xe6c <__divsf3_pse+0x92>
     e02:	0e 2e       	mov	r0, r30
     e04:	3a f0       	brmi	.+14     	; 0xe14 <__divsf3_pse+0x3a>
     e06:	e0 e8       	ldi	r30, 0x80	; 128
     e08:	32 d0       	rcall	.+100    	; 0xe6e <__divsf3_pse+0x94>
     e0a:	91 50       	subi	r25, 0x01	; 1
     e0c:	50 40       	sbci	r21, 0x00	; 0
     e0e:	e6 95       	lsr	r30
     e10:	00 1c       	adc	r0, r0
     e12:	ca f7       	brpl	.-14     	; 0xe06 <__divsf3_pse+0x2c>
     e14:	2b d0       	rcall	.+86     	; 0xe6c <__divsf3_pse+0x92>
     e16:	fe 2f       	mov	r31, r30
     e18:	29 d0       	rcall	.+82     	; 0xe6c <__divsf3_pse+0x92>
     e1a:	66 0f       	add	r22, r22
     e1c:	77 1f       	adc	r23, r23
     e1e:	88 1f       	adc	r24, r24
     e20:	bb 1f       	adc	r27, r27
     e22:	26 17       	cp	r18, r22
     e24:	37 07       	cpc	r19, r23
     e26:	48 07       	cpc	r20, r24
     e28:	ab 07       	cpc	r26, r27
     e2a:	b0 e8       	ldi	r27, 0x80	; 128
     e2c:	09 f0       	breq	.+2      	; 0xe30 <__divsf3_pse+0x56>
     e2e:	bb 0b       	sbc	r27, r27
     e30:	80 2d       	mov	r24, r0
     e32:	bf 01       	movw	r22, r30
     e34:	ff 27       	eor	r31, r31
     e36:	93 58       	subi	r25, 0x83	; 131
     e38:	5f 4f       	sbci	r21, 0xFF	; 255
     e3a:	3a f0       	brmi	.+14     	; 0xe4a <__divsf3_pse+0x70>
     e3c:	9e 3f       	cpi	r25, 0xFE	; 254
     e3e:	51 05       	cpc	r21, r1
     e40:	78 f0       	brcs	.+30     	; 0xe60 <__divsf3_pse+0x86>
     e42:	0c 94 df 07 	jmp	0xfbe	; 0xfbe <__fp_inf>
     e46:	0c 94 2a 08 	jmp	0x1054	; 0x1054 <__fp_szero>
     e4a:	5f 3f       	cpi	r21, 0xFF	; 255
     e4c:	e4 f3       	brlt	.-8      	; 0xe46 <__divsf3_pse+0x6c>
     e4e:	98 3e       	cpi	r25, 0xE8	; 232
     e50:	d4 f3       	brlt	.-12     	; 0xe46 <__divsf3_pse+0x6c>
     e52:	86 95       	lsr	r24
     e54:	77 95       	ror	r23
     e56:	67 95       	ror	r22
     e58:	b7 95       	ror	r27
     e5a:	f7 95       	ror	r31
     e5c:	9f 5f       	subi	r25, 0xFF	; 255
     e5e:	c9 f7       	brne	.-14     	; 0xe52 <__divsf3_pse+0x78>
     e60:	88 0f       	add	r24, r24
     e62:	91 1d       	adc	r25, r1
     e64:	96 95       	lsr	r25
     e66:	87 95       	ror	r24
     e68:	97 f9       	bld	r25, 7
     e6a:	08 95       	ret
     e6c:	e1 e0       	ldi	r30, 0x01	; 1
     e6e:	66 0f       	add	r22, r22
     e70:	77 1f       	adc	r23, r23
     e72:	88 1f       	adc	r24, r24
     e74:	bb 1f       	adc	r27, r27
     e76:	62 17       	cp	r22, r18
     e78:	73 07       	cpc	r23, r19
     e7a:	84 07       	cpc	r24, r20
     e7c:	ba 07       	cpc	r27, r26
     e7e:	20 f0       	brcs	.+8      	; 0xe88 <__divsf3_pse+0xae>
     e80:	62 1b       	sub	r22, r18
     e82:	73 0b       	sbc	r23, r19
     e84:	84 0b       	sbc	r24, r20
     e86:	ba 0b       	sbc	r27, r26
     e88:	ee 1f       	adc	r30, r30
     e8a:	88 f7       	brcc	.-30     	; 0xe6e <__divsf3_pse+0x94>
     e8c:	e0 95       	com	r30
     e8e:	08 95       	ret

00000e90 <__fixsfsi>:
     e90:	0e 94 4f 07 	call	0xe9e	; 0xe9e <__fixunssfsi>
     e94:	68 94       	set
     e96:	b1 11       	cpse	r27, r1
     e98:	0c 94 2a 08 	jmp	0x1054	; 0x1054 <__fp_szero>
     e9c:	08 95       	ret

00000e9e <__fixunssfsi>:
     e9e:	0e 94 0f 08 	call	0x101e	; 0x101e <__fp_splitA>
     ea2:	88 f0       	brcs	.+34     	; 0xec6 <__fixunssfsi+0x28>
     ea4:	9f 57       	subi	r25, 0x7F	; 127
     ea6:	98 f0       	brcs	.+38     	; 0xece <__fixunssfsi+0x30>
     ea8:	b9 2f       	mov	r27, r25
     eaa:	99 27       	eor	r25, r25
     eac:	b7 51       	subi	r27, 0x17	; 23
     eae:	b0 f0       	brcs	.+44     	; 0xedc <__fixunssfsi+0x3e>
     eb0:	e1 f0       	breq	.+56     	; 0xeea <__fixunssfsi+0x4c>
     eb2:	66 0f       	add	r22, r22
     eb4:	77 1f       	adc	r23, r23
     eb6:	88 1f       	adc	r24, r24
     eb8:	99 1f       	adc	r25, r25
     eba:	1a f0       	brmi	.+6      	; 0xec2 <__fixunssfsi+0x24>
     ebc:	ba 95       	dec	r27
     ebe:	c9 f7       	brne	.-14     	; 0xeb2 <__fixunssfsi+0x14>
     ec0:	14 c0       	rjmp	.+40     	; 0xeea <__fixunssfsi+0x4c>
     ec2:	b1 30       	cpi	r27, 0x01	; 1
     ec4:	91 f0       	breq	.+36     	; 0xeea <__fixunssfsi+0x4c>
     ec6:	0e 94 29 08 	call	0x1052	; 0x1052 <__fp_zero>
     eca:	b1 e0       	ldi	r27, 0x01	; 1
     ecc:	08 95       	ret
     ece:	0c 94 29 08 	jmp	0x1052	; 0x1052 <__fp_zero>
     ed2:	67 2f       	mov	r22, r23
     ed4:	78 2f       	mov	r23, r24
     ed6:	88 27       	eor	r24, r24
     ed8:	b8 5f       	subi	r27, 0xF8	; 248
     eda:	39 f0       	breq	.+14     	; 0xeea <__fixunssfsi+0x4c>
     edc:	b9 3f       	cpi	r27, 0xF9	; 249
     ede:	cc f3       	brlt	.-14     	; 0xed2 <__fixunssfsi+0x34>
     ee0:	86 95       	lsr	r24
     ee2:	77 95       	ror	r23
     ee4:	67 95       	ror	r22
     ee6:	b3 95       	inc	r27
     ee8:	d9 f7       	brne	.-10     	; 0xee0 <__fixunssfsi+0x42>
     eea:	3e f4       	brtc	.+14     	; 0xefa <__fixunssfsi+0x5c>
     eec:	90 95       	com	r25
     eee:	80 95       	com	r24
     ef0:	70 95       	com	r23
     ef2:	61 95       	neg	r22
     ef4:	7f 4f       	sbci	r23, 0xFF	; 255
     ef6:	8f 4f       	sbci	r24, 0xFF	; 255
     ef8:	9f 4f       	sbci	r25, 0xFF	; 255
     efa:	08 95       	ret

00000efc <__floatunsisf>:
     efc:	e8 94       	clt
     efe:	09 c0       	rjmp	.+18     	; 0xf12 <__floatsisf+0x12>

00000f00 <__floatsisf>:
     f00:	97 fb       	bst	r25, 7
     f02:	3e f4       	brtc	.+14     	; 0xf12 <__floatsisf+0x12>
     f04:	90 95       	com	r25
     f06:	80 95       	com	r24
     f08:	70 95       	com	r23
     f0a:	61 95       	neg	r22
     f0c:	7f 4f       	sbci	r23, 0xFF	; 255
     f0e:	8f 4f       	sbci	r24, 0xFF	; 255
     f10:	9f 4f       	sbci	r25, 0xFF	; 255
     f12:	99 23       	and	r25, r25
     f14:	a9 f0       	breq	.+42     	; 0xf40 <__floatsisf+0x40>
     f16:	f9 2f       	mov	r31, r25
     f18:	96 e9       	ldi	r25, 0x96	; 150
     f1a:	bb 27       	eor	r27, r27
     f1c:	93 95       	inc	r25
     f1e:	f6 95       	lsr	r31
     f20:	87 95       	ror	r24
     f22:	77 95       	ror	r23
     f24:	67 95       	ror	r22
     f26:	b7 95       	ror	r27
     f28:	f1 11       	cpse	r31, r1
     f2a:	f8 cf       	rjmp	.-16     	; 0xf1c <__floatsisf+0x1c>
     f2c:	fa f4       	brpl	.+62     	; 0xf6c <__floatsisf+0x6c>
     f2e:	bb 0f       	add	r27, r27
     f30:	11 f4       	brne	.+4      	; 0xf36 <__floatsisf+0x36>
     f32:	60 ff       	sbrs	r22, 0
     f34:	1b c0       	rjmp	.+54     	; 0xf6c <__floatsisf+0x6c>
     f36:	6f 5f       	subi	r22, 0xFF	; 255
     f38:	7f 4f       	sbci	r23, 0xFF	; 255
     f3a:	8f 4f       	sbci	r24, 0xFF	; 255
     f3c:	9f 4f       	sbci	r25, 0xFF	; 255
     f3e:	16 c0       	rjmp	.+44     	; 0xf6c <__floatsisf+0x6c>
     f40:	88 23       	and	r24, r24
     f42:	11 f0       	breq	.+4      	; 0xf48 <__floatsisf+0x48>
     f44:	96 e9       	ldi	r25, 0x96	; 150
     f46:	11 c0       	rjmp	.+34     	; 0xf6a <__floatsisf+0x6a>
     f48:	77 23       	and	r23, r23
     f4a:	21 f0       	breq	.+8      	; 0xf54 <__floatsisf+0x54>
     f4c:	9e e8       	ldi	r25, 0x8E	; 142
     f4e:	87 2f       	mov	r24, r23
     f50:	76 2f       	mov	r23, r22
     f52:	05 c0       	rjmp	.+10     	; 0xf5e <__floatsisf+0x5e>
     f54:	66 23       	and	r22, r22
     f56:	71 f0       	breq	.+28     	; 0xf74 <__floatsisf+0x74>
     f58:	96 e8       	ldi	r25, 0x86	; 134
     f5a:	86 2f       	mov	r24, r22
     f5c:	70 e0       	ldi	r23, 0x00	; 0
     f5e:	60 e0       	ldi	r22, 0x00	; 0
     f60:	2a f0       	brmi	.+10     	; 0xf6c <__floatsisf+0x6c>
     f62:	9a 95       	dec	r25
     f64:	66 0f       	add	r22, r22
     f66:	77 1f       	adc	r23, r23
     f68:	88 1f       	adc	r24, r24
     f6a:	da f7       	brpl	.-10     	; 0xf62 <__floatsisf+0x62>
     f6c:	88 0f       	add	r24, r24
     f6e:	96 95       	lsr	r25
     f70:	87 95       	ror	r24
     f72:	97 f9       	bld	r25, 7
     f74:	08 95       	ret

00000f76 <__fp_cmp>:
     f76:	99 0f       	add	r25, r25
     f78:	00 08       	sbc	r0, r0
     f7a:	55 0f       	add	r21, r21
     f7c:	aa 0b       	sbc	r26, r26
     f7e:	e0 e8       	ldi	r30, 0x80	; 128
     f80:	fe ef       	ldi	r31, 0xFE	; 254
     f82:	16 16       	cp	r1, r22
     f84:	17 06       	cpc	r1, r23
     f86:	e8 07       	cpc	r30, r24
     f88:	f9 07       	cpc	r31, r25
     f8a:	c0 f0       	brcs	.+48     	; 0xfbc <__fp_cmp+0x46>
     f8c:	12 16       	cp	r1, r18
     f8e:	13 06       	cpc	r1, r19
     f90:	e4 07       	cpc	r30, r20
     f92:	f5 07       	cpc	r31, r21
     f94:	98 f0       	brcs	.+38     	; 0xfbc <__fp_cmp+0x46>
     f96:	62 1b       	sub	r22, r18
     f98:	73 0b       	sbc	r23, r19
     f9a:	84 0b       	sbc	r24, r20
     f9c:	95 0b       	sbc	r25, r21
     f9e:	39 f4       	brne	.+14     	; 0xfae <__fp_cmp+0x38>
     fa0:	0a 26       	eor	r0, r26
     fa2:	61 f0       	breq	.+24     	; 0xfbc <__fp_cmp+0x46>
     fa4:	23 2b       	or	r18, r19
     fa6:	24 2b       	or	r18, r20
     fa8:	25 2b       	or	r18, r21
     faa:	21 f4       	brne	.+8      	; 0xfb4 <__fp_cmp+0x3e>
     fac:	08 95       	ret
     fae:	0a 26       	eor	r0, r26
     fb0:	09 f4       	brne	.+2      	; 0xfb4 <__fp_cmp+0x3e>
     fb2:	a1 40       	sbci	r26, 0x01	; 1
     fb4:	a6 95       	lsr	r26
     fb6:	8f ef       	ldi	r24, 0xFF	; 255
     fb8:	81 1d       	adc	r24, r1
     fba:	81 1d       	adc	r24, r1
     fbc:	08 95       	ret

00000fbe <__fp_inf>:
     fbe:	97 f9       	bld	r25, 7
     fc0:	9f 67       	ori	r25, 0x7F	; 127
     fc2:	80 e8       	ldi	r24, 0x80	; 128
     fc4:	70 e0       	ldi	r23, 0x00	; 0
     fc6:	60 e0       	ldi	r22, 0x00	; 0
     fc8:	08 95       	ret

00000fca <__fp_nan>:
     fca:	9f ef       	ldi	r25, 0xFF	; 255
     fcc:	80 ec       	ldi	r24, 0xC0	; 192
     fce:	08 95       	ret

00000fd0 <__fp_pscA>:
     fd0:	00 24       	eor	r0, r0
     fd2:	0a 94       	dec	r0
     fd4:	16 16       	cp	r1, r22
     fd6:	17 06       	cpc	r1, r23
     fd8:	18 06       	cpc	r1, r24
     fda:	09 06       	cpc	r0, r25
     fdc:	08 95       	ret

00000fde <__fp_pscB>:
     fde:	00 24       	eor	r0, r0
     fe0:	0a 94       	dec	r0
     fe2:	12 16       	cp	r1, r18
     fe4:	13 06       	cpc	r1, r19
     fe6:	14 06       	cpc	r1, r20
     fe8:	05 06       	cpc	r0, r21
     fea:	08 95       	ret

00000fec <__fp_round>:
     fec:	09 2e       	mov	r0, r25
     fee:	03 94       	inc	r0
     ff0:	00 0c       	add	r0, r0
     ff2:	11 f4       	brne	.+4      	; 0xff8 <__fp_round+0xc>
     ff4:	88 23       	and	r24, r24
     ff6:	52 f0       	brmi	.+20     	; 0x100c <__fp_round+0x20>
     ff8:	bb 0f       	add	r27, r27
     ffa:	40 f4       	brcc	.+16     	; 0x100c <__fp_round+0x20>
     ffc:	bf 2b       	or	r27, r31
     ffe:	11 f4       	brne	.+4      	; 0x1004 <__fp_round+0x18>
    1000:	60 ff       	sbrs	r22, 0
    1002:	04 c0       	rjmp	.+8      	; 0x100c <__fp_round+0x20>
    1004:	6f 5f       	subi	r22, 0xFF	; 255
    1006:	7f 4f       	sbci	r23, 0xFF	; 255
    1008:	8f 4f       	sbci	r24, 0xFF	; 255
    100a:	9f 4f       	sbci	r25, 0xFF	; 255
    100c:	08 95       	ret

0000100e <__fp_split3>:
    100e:	57 fd       	sbrc	r21, 7
    1010:	90 58       	subi	r25, 0x80	; 128
    1012:	44 0f       	add	r20, r20
    1014:	55 1f       	adc	r21, r21
    1016:	59 f0       	breq	.+22     	; 0x102e <__fp_splitA+0x10>
    1018:	5f 3f       	cpi	r21, 0xFF	; 255
    101a:	71 f0       	breq	.+28     	; 0x1038 <__fp_splitA+0x1a>
    101c:	47 95       	ror	r20

0000101e <__fp_splitA>:
    101e:	88 0f       	add	r24, r24
    1020:	97 fb       	bst	r25, 7
    1022:	99 1f       	adc	r25, r25
    1024:	61 f0       	breq	.+24     	; 0x103e <__fp_splitA+0x20>
    1026:	9f 3f       	cpi	r25, 0xFF	; 255
    1028:	79 f0       	breq	.+30     	; 0x1048 <__fp_splitA+0x2a>
    102a:	87 95       	ror	r24
    102c:	08 95       	ret
    102e:	12 16       	cp	r1, r18
    1030:	13 06       	cpc	r1, r19
    1032:	14 06       	cpc	r1, r20
    1034:	55 1f       	adc	r21, r21
    1036:	f2 cf       	rjmp	.-28     	; 0x101c <__fp_split3+0xe>
    1038:	46 95       	lsr	r20
    103a:	f1 df       	rcall	.-30     	; 0x101e <__fp_splitA>
    103c:	08 c0       	rjmp	.+16     	; 0x104e <__fp_splitA+0x30>
    103e:	16 16       	cp	r1, r22
    1040:	17 06       	cpc	r1, r23
    1042:	18 06       	cpc	r1, r24
    1044:	99 1f       	adc	r25, r25
    1046:	f1 cf       	rjmp	.-30     	; 0x102a <__fp_splitA+0xc>
    1048:	86 95       	lsr	r24
    104a:	71 05       	cpc	r23, r1
    104c:	61 05       	cpc	r22, r1
    104e:	08 94       	sec
    1050:	08 95       	ret

00001052 <__fp_zero>:
    1052:	e8 94       	clt

00001054 <__fp_szero>:
    1054:	bb 27       	eor	r27, r27
    1056:	66 27       	eor	r22, r22
    1058:	77 27       	eor	r23, r23
    105a:	cb 01       	movw	r24, r22
    105c:	97 f9       	bld	r25, 7
    105e:	08 95       	ret

00001060 <__gesf2>:
    1060:	0e 94 bb 07 	call	0xf76	; 0xf76 <__fp_cmp>
    1064:	08 f4       	brcc	.+2      	; 0x1068 <__gesf2+0x8>
    1066:	8f ef       	ldi	r24, 0xFF	; 255
    1068:	08 95       	ret

0000106a <__mulsf3>:
    106a:	0e 94 48 08 	call	0x1090	; 0x1090 <__mulsf3x>
    106e:	0c 94 f6 07 	jmp	0xfec	; 0xfec <__fp_round>
    1072:	0e 94 e8 07 	call	0xfd0	; 0xfd0 <__fp_pscA>
    1076:	38 f0       	brcs	.+14     	; 0x1086 <__mulsf3+0x1c>
    1078:	0e 94 ef 07 	call	0xfde	; 0xfde <__fp_pscB>
    107c:	20 f0       	brcs	.+8      	; 0x1086 <__mulsf3+0x1c>
    107e:	95 23       	and	r25, r21
    1080:	11 f0       	breq	.+4      	; 0x1086 <__mulsf3+0x1c>
    1082:	0c 94 df 07 	jmp	0xfbe	; 0xfbe <__fp_inf>
    1086:	0c 94 e5 07 	jmp	0xfca	; 0xfca <__fp_nan>
    108a:	11 24       	eor	r1, r1
    108c:	0c 94 2a 08 	jmp	0x1054	; 0x1054 <__fp_szero>

00001090 <__mulsf3x>:
    1090:	0e 94 07 08 	call	0x100e	; 0x100e <__fp_split3>
    1094:	70 f3       	brcs	.-36     	; 0x1072 <__mulsf3+0x8>

00001096 <__mulsf3_pse>:
    1096:	95 9f       	mul	r25, r21
    1098:	c1 f3       	breq	.-16     	; 0x108a <__mulsf3+0x20>
    109a:	95 0f       	add	r25, r21
    109c:	50 e0       	ldi	r21, 0x00	; 0
    109e:	55 1f       	adc	r21, r21
    10a0:	62 9f       	mul	r22, r18
    10a2:	f0 01       	movw	r30, r0
    10a4:	72 9f       	mul	r23, r18
    10a6:	bb 27       	eor	r27, r27
    10a8:	f0 0d       	add	r31, r0
    10aa:	b1 1d       	adc	r27, r1
    10ac:	63 9f       	mul	r22, r19
    10ae:	aa 27       	eor	r26, r26
    10b0:	f0 0d       	add	r31, r0
    10b2:	b1 1d       	adc	r27, r1
    10b4:	aa 1f       	adc	r26, r26
    10b6:	64 9f       	mul	r22, r20
    10b8:	66 27       	eor	r22, r22
    10ba:	b0 0d       	add	r27, r0
    10bc:	a1 1d       	adc	r26, r1
    10be:	66 1f       	adc	r22, r22
    10c0:	82 9f       	mul	r24, r18
    10c2:	22 27       	eor	r18, r18
    10c4:	b0 0d       	add	r27, r0
    10c6:	a1 1d       	adc	r26, r1
    10c8:	62 1f       	adc	r22, r18
    10ca:	73 9f       	mul	r23, r19
    10cc:	b0 0d       	add	r27, r0
    10ce:	a1 1d       	adc	r26, r1
    10d0:	62 1f       	adc	r22, r18
    10d2:	83 9f       	mul	r24, r19
    10d4:	a0 0d       	add	r26, r0
    10d6:	61 1d       	adc	r22, r1
    10d8:	22 1f       	adc	r18, r18
    10da:	74 9f       	mul	r23, r20
    10dc:	33 27       	eor	r19, r19
    10de:	a0 0d       	add	r26, r0
    10e0:	61 1d       	adc	r22, r1
    10e2:	23 1f       	adc	r18, r19
    10e4:	84 9f       	mul	r24, r20
    10e6:	60 0d       	add	r22, r0
    10e8:	21 1d       	adc	r18, r1
    10ea:	82 2f       	mov	r24, r18
    10ec:	76 2f       	mov	r23, r22
    10ee:	6a 2f       	mov	r22, r26
    10f0:	11 24       	eor	r1, r1
    10f2:	9f 57       	subi	r25, 0x7F	; 127
    10f4:	50 40       	sbci	r21, 0x00	; 0
    10f6:	9a f0       	brmi	.+38     	; 0x111e <__mulsf3_pse+0x88>
    10f8:	f1 f0       	breq	.+60     	; 0x1136 <__mulsf3_pse+0xa0>
    10fa:	88 23       	and	r24, r24
    10fc:	4a f0       	brmi	.+18     	; 0x1110 <__mulsf3_pse+0x7a>
    10fe:	ee 0f       	add	r30, r30
    1100:	ff 1f       	adc	r31, r31
    1102:	bb 1f       	adc	r27, r27
    1104:	66 1f       	adc	r22, r22
    1106:	77 1f       	adc	r23, r23
    1108:	88 1f       	adc	r24, r24
    110a:	91 50       	subi	r25, 0x01	; 1
    110c:	50 40       	sbci	r21, 0x00	; 0
    110e:	a9 f7       	brne	.-22     	; 0x10fa <__mulsf3_pse+0x64>
    1110:	9e 3f       	cpi	r25, 0xFE	; 254
    1112:	51 05       	cpc	r21, r1
    1114:	80 f0       	brcs	.+32     	; 0x1136 <__mulsf3_pse+0xa0>
    1116:	0c 94 df 07 	jmp	0xfbe	; 0xfbe <__fp_inf>
    111a:	0c 94 2a 08 	jmp	0x1054	; 0x1054 <__fp_szero>
    111e:	5f 3f       	cpi	r21, 0xFF	; 255
    1120:	e4 f3       	brlt	.-8      	; 0x111a <__mulsf3_pse+0x84>
    1122:	98 3e       	cpi	r25, 0xE8	; 232
    1124:	d4 f3       	brlt	.-12     	; 0x111a <__mulsf3_pse+0x84>
    1126:	86 95       	lsr	r24
    1128:	77 95       	ror	r23
    112a:	67 95       	ror	r22
    112c:	b7 95       	ror	r27
    112e:	f7 95       	ror	r31
    1130:	e7 95       	ror	r30
    1132:	9f 5f       	subi	r25, 0xFF	; 255
    1134:	c1 f7       	brne	.-16     	; 0x1126 <__mulsf3_pse+0x90>
    1136:	fe 2b       	or	r31, r30
    1138:	88 0f       	add	r24, r24
    113a:	91 1d       	adc	r25, r1
    113c:	96 95       	lsr	r25
    113e:	87 95       	ror	r24
    1140:	97 f9       	bld	r25, 7
    1142:	08 95       	ret

00001144 <round>:
    1144:	0e 94 0f 08 	call	0x101e	; 0x101e <__fp_splitA>
    1148:	e8 f0       	brcs	.+58     	; 0x1184 <round+0x40>
    114a:	9e 37       	cpi	r25, 0x7E	; 126
    114c:	e8 f0       	brcs	.+58     	; 0x1188 <round+0x44>
    114e:	96 39       	cpi	r25, 0x96	; 150
    1150:	b8 f4       	brcc	.+46     	; 0x1180 <round+0x3c>
    1152:	9e 38       	cpi	r25, 0x8E	; 142
    1154:	48 f4       	brcc	.+18     	; 0x1168 <round+0x24>
    1156:	67 2f       	mov	r22, r23
    1158:	78 2f       	mov	r23, r24
    115a:	88 27       	eor	r24, r24
    115c:	98 5f       	subi	r25, 0xF8	; 248
    115e:	f9 cf       	rjmp	.-14     	; 0x1152 <round+0xe>
    1160:	86 95       	lsr	r24
    1162:	77 95       	ror	r23
    1164:	67 95       	ror	r22
    1166:	93 95       	inc	r25
    1168:	95 39       	cpi	r25, 0x95	; 149
    116a:	d0 f3       	brcs	.-12     	; 0x1160 <round+0x1c>
    116c:	b6 2f       	mov	r27, r22
    116e:	b1 70       	andi	r27, 0x01	; 1
    1170:	6b 0f       	add	r22, r27
    1172:	71 1d       	adc	r23, r1
    1174:	81 1d       	adc	r24, r1
    1176:	20 f4       	brcc	.+8      	; 0x1180 <round+0x3c>
    1178:	87 95       	ror	r24
    117a:	77 95       	ror	r23
    117c:	67 95       	ror	r22
    117e:	93 95       	inc	r25
    1180:	0c 94 c6 08 	jmp	0x118c	; 0x118c <__fp_mintl>
    1184:	0c 94 e1 08 	jmp	0x11c2	; 0x11c2 <__fp_mpack>
    1188:	0c 94 2a 08 	jmp	0x1054	; 0x1054 <__fp_szero>

0000118c <__fp_mintl>:
    118c:	88 23       	and	r24, r24
    118e:	71 f4       	brne	.+28     	; 0x11ac <__fp_mintl+0x20>
    1190:	77 23       	and	r23, r23
    1192:	21 f0       	breq	.+8      	; 0x119c <__fp_mintl+0x10>
    1194:	98 50       	subi	r25, 0x08	; 8
    1196:	87 2b       	or	r24, r23
    1198:	76 2f       	mov	r23, r22
    119a:	07 c0       	rjmp	.+14     	; 0x11aa <__fp_mintl+0x1e>
    119c:	66 23       	and	r22, r22
    119e:	11 f4       	brne	.+4      	; 0x11a4 <__fp_mintl+0x18>
    11a0:	99 27       	eor	r25, r25
    11a2:	0d c0       	rjmp	.+26     	; 0x11be <__fp_mintl+0x32>
    11a4:	90 51       	subi	r25, 0x10	; 16
    11a6:	86 2b       	or	r24, r22
    11a8:	70 e0       	ldi	r23, 0x00	; 0
    11aa:	60 e0       	ldi	r22, 0x00	; 0
    11ac:	2a f0       	brmi	.+10     	; 0x11b8 <__fp_mintl+0x2c>
    11ae:	9a 95       	dec	r25
    11b0:	66 0f       	add	r22, r22
    11b2:	77 1f       	adc	r23, r23
    11b4:	88 1f       	adc	r24, r24
    11b6:	da f7       	brpl	.-10     	; 0x11ae <__fp_mintl+0x22>
    11b8:	88 0f       	add	r24, r24
    11ba:	96 95       	lsr	r25
    11bc:	87 95       	ror	r24
    11be:	97 f9       	bld	r25, 7
    11c0:	08 95       	ret

000011c2 <__fp_mpack>:
    11c2:	9f 3f       	cpi	r25, 0xFF	; 255
    11c4:	31 f0       	breq	.+12     	; 0x11d2 <__fp_mpack_finite+0xc>

000011c6 <__fp_mpack_finite>:
    11c6:	91 50       	subi	r25, 0x01	; 1
    11c8:	20 f4       	brcc	.+8      	; 0x11d2 <__fp_mpack_finite+0xc>
    11ca:	87 95       	ror	r24
    11cc:	77 95       	ror	r23
    11ce:	67 95       	ror	r22
    11d0:	b7 95       	ror	r27
    11d2:	88 0f       	add	r24, r24
    11d4:	91 1d       	adc	r25, r1
    11d6:	96 95       	lsr	r25
    11d8:	87 95       	ror	r24
    11da:	97 f9       	bld	r25, 7
    11dc:	08 95       	ret

000011de <dtostrf>:
    11de:	ef 92       	push	r14
    11e0:	0f 93       	push	r16
    11e2:	1f 93       	push	r17
    11e4:	cf 93       	push	r28
    11e6:	df 93       	push	r29
    11e8:	e8 01       	movw	r28, r16
    11ea:	47 fd       	sbrc	r20, 7
    11ec:	02 c0       	rjmp	.+4      	; 0x11f2 <dtostrf+0x14>
    11ee:	34 e0       	ldi	r19, 0x04	; 4
    11f0:	01 c0       	rjmp	.+2      	; 0x11f4 <dtostrf+0x16>
    11f2:	34 e1       	ldi	r19, 0x14	; 20
    11f4:	04 2e       	mov	r0, r20
    11f6:	00 0c       	add	r0, r0
    11f8:	55 0b       	sbc	r21, r21
    11fa:	57 ff       	sbrs	r21, 7
    11fc:	03 c0       	rjmp	.+6      	; 0x1204 <dtostrf+0x26>
    11fe:	51 95       	neg	r21
    1200:	41 95       	neg	r20
    1202:	51 09       	sbc	r21, r1
    1204:	e3 2e       	mov	r14, r19
    1206:	02 2f       	mov	r16, r18
    1208:	24 2f       	mov	r18, r20
    120a:	ae 01       	movw	r20, r28
    120c:	1c d2       	rcall	.+1080   	; 0x1646 <dtoa_prf>
    120e:	ce 01       	movw	r24, r28
    1210:	df 91       	pop	r29
    1212:	cf 91       	pop	r28
    1214:	1f 91       	pop	r17
    1216:	0f 91       	pop	r16
    1218:	ef 90       	pop	r14
    121a:	08 95       	ret

0000121c <printf>:
    121c:	a0 e0       	ldi	r26, 0x00	; 0
    121e:	b0 e0       	ldi	r27, 0x00	; 0
    1220:	e3 e1       	ldi	r30, 0x13	; 19
    1222:	f9 e0       	ldi	r31, 0x09	; 9
    1224:	ff c4       	rjmp	.+2558   	; 0x1c24 <__prologue_saves__+0x20>
    1226:	ae 01       	movw	r20, r28
    1228:	4b 5f       	subi	r20, 0xFB	; 251
    122a:	5f 4f       	sbci	r21, 0xFF	; 255
    122c:	fa 01       	movw	r30, r20
    122e:	61 91       	ld	r22, Z+
    1230:	71 91       	ld	r23, Z+
    1232:	af 01       	movw	r20, r30
    1234:	80 91 71 3e 	lds	r24, 0x3E71	; 0x803e71 <__iob+0x2>
    1238:	90 91 72 3e 	lds	r25, 0x3E72	; 0x803e72 <__iob+0x3>
    123c:	32 d0       	rcall	.+100    	; 0x12a2 <vfprintf>
    123e:	e2 e0       	ldi	r30, 0x02	; 2
    1240:	0a c5       	rjmp	.+2580   	; 0x1c56 <__epilogue_restores__+0x20>

00001242 <puts>:
    1242:	0f 93       	push	r16
    1244:	1f 93       	push	r17
    1246:	cf 93       	push	r28
    1248:	df 93       	push	r29
    124a:	e0 91 71 3e 	lds	r30, 0x3E71	; 0x803e71 <__iob+0x2>
    124e:	f0 91 72 3e 	lds	r31, 0x3E72	; 0x803e72 <__iob+0x3>
    1252:	23 81       	ldd	r18, Z+3	; 0x03
    1254:	21 ff       	sbrs	r18, 1
    1256:	1b c0       	rjmp	.+54     	; 0x128e <puts+0x4c>
    1258:	8c 01       	movw	r16, r24
    125a:	d0 e0       	ldi	r29, 0x00	; 0
    125c:	c0 e0       	ldi	r28, 0x00	; 0
    125e:	f8 01       	movw	r30, r16
    1260:	81 91       	ld	r24, Z+
    1262:	8f 01       	movw	r16, r30
    1264:	60 91 71 3e 	lds	r22, 0x3E71	; 0x803e71 <__iob+0x2>
    1268:	70 91 72 3e 	lds	r23, 0x3E72	; 0x803e72 <__iob+0x3>
    126c:	db 01       	movw	r26, r22
    126e:	18 96       	adiw	r26, 0x08	; 8
    1270:	ed 91       	ld	r30, X+
    1272:	fc 91       	ld	r31, X
    1274:	19 97       	sbiw	r26, 0x09	; 9
    1276:	88 23       	and	r24, r24
    1278:	31 f0       	breq	.+12     	; 0x1286 <puts+0x44>
    127a:	09 95       	icall
    127c:	89 2b       	or	r24, r25
    127e:	79 f3       	breq	.-34     	; 0x125e <puts+0x1c>
    1280:	df ef       	ldi	r29, 0xFF	; 255
    1282:	cf ef       	ldi	r28, 0xFF	; 255
    1284:	ec cf       	rjmp	.-40     	; 0x125e <puts+0x1c>
    1286:	8a e0       	ldi	r24, 0x0A	; 10
    1288:	09 95       	icall
    128a:	89 2b       	or	r24, r25
    128c:	19 f0       	breq	.+6      	; 0x1294 <puts+0x52>
    128e:	8f ef       	ldi	r24, 0xFF	; 255
    1290:	9f ef       	ldi	r25, 0xFF	; 255
    1292:	02 c0       	rjmp	.+4      	; 0x1298 <puts+0x56>
    1294:	8d 2f       	mov	r24, r29
    1296:	9c 2f       	mov	r25, r28
    1298:	df 91       	pop	r29
    129a:	cf 91       	pop	r28
    129c:	1f 91       	pop	r17
    129e:	0f 91       	pop	r16
    12a0:	08 95       	ret

000012a2 <vfprintf>:
    12a2:	ab e0       	ldi	r26, 0x0B	; 11
    12a4:	b0 e0       	ldi	r27, 0x00	; 0
    12a6:	e6 e5       	ldi	r30, 0x56	; 86
    12a8:	f9 e0       	ldi	r31, 0x09	; 9
    12aa:	ac c4       	rjmp	.+2392   	; 0x1c04 <__prologue_saves__>
    12ac:	6c 01       	movw	r12, r24
    12ae:	7b 01       	movw	r14, r22
    12b0:	8a 01       	movw	r16, r20
    12b2:	fc 01       	movw	r30, r24
    12b4:	16 82       	std	Z+6, r1	; 0x06
    12b6:	17 82       	std	Z+7, r1	; 0x07
    12b8:	83 81       	ldd	r24, Z+3	; 0x03
    12ba:	81 ff       	sbrs	r24, 1
    12bc:	bf c1       	rjmp	.+894    	; 0x163c <vfprintf+0x39a>
    12be:	ce 01       	movw	r24, r28
    12c0:	01 96       	adiw	r24, 0x01	; 1
    12c2:	3c 01       	movw	r6, r24
    12c4:	f6 01       	movw	r30, r12
    12c6:	93 81       	ldd	r25, Z+3	; 0x03
    12c8:	f7 01       	movw	r30, r14
    12ca:	93 fd       	sbrc	r25, 3
    12cc:	85 91       	lpm	r24, Z+
    12ce:	93 ff       	sbrs	r25, 3
    12d0:	81 91       	ld	r24, Z+
    12d2:	7f 01       	movw	r14, r30
    12d4:	88 23       	and	r24, r24
    12d6:	09 f4       	brne	.+2      	; 0x12da <vfprintf+0x38>
    12d8:	ad c1       	rjmp	.+858    	; 0x1634 <vfprintf+0x392>
    12da:	85 32       	cpi	r24, 0x25	; 37
    12dc:	39 f4       	brne	.+14     	; 0x12ec <vfprintf+0x4a>
    12de:	93 fd       	sbrc	r25, 3
    12e0:	85 91       	lpm	r24, Z+
    12e2:	93 ff       	sbrs	r25, 3
    12e4:	81 91       	ld	r24, Z+
    12e6:	7f 01       	movw	r14, r30
    12e8:	85 32       	cpi	r24, 0x25	; 37
    12ea:	21 f4       	brne	.+8      	; 0x12f4 <vfprintf+0x52>
    12ec:	b6 01       	movw	r22, r12
    12ee:	90 e0       	ldi	r25, 0x00	; 0
    12f0:	ef d3       	rcall	.+2014   	; 0x1ad0 <fputc>
    12f2:	e8 cf       	rjmp	.-48     	; 0x12c4 <vfprintf+0x22>
    12f4:	91 2c       	mov	r9, r1
    12f6:	21 2c       	mov	r2, r1
    12f8:	31 2c       	mov	r3, r1
    12fa:	ff e1       	ldi	r31, 0x1F	; 31
    12fc:	f3 15       	cp	r31, r3
    12fe:	d8 f0       	brcs	.+54     	; 0x1336 <vfprintf+0x94>
    1300:	8b 32       	cpi	r24, 0x2B	; 43
    1302:	79 f0       	breq	.+30     	; 0x1322 <vfprintf+0x80>
    1304:	38 f4       	brcc	.+14     	; 0x1314 <vfprintf+0x72>
    1306:	80 32       	cpi	r24, 0x20	; 32
    1308:	79 f0       	breq	.+30     	; 0x1328 <vfprintf+0x86>
    130a:	83 32       	cpi	r24, 0x23	; 35
    130c:	a1 f4       	brne	.+40     	; 0x1336 <vfprintf+0x94>
    130e:	23 2d       	mov	r18, r3
    1310:	20 61       	ori	r18, 0x10	; 16
    1312:	1d c0       	rjmp	.+58     	; 0x134e <vfprintf+0xac>
    1314:	8d 32       	cpi	r24, 0x2D	; 45
    1316:	61 f0       	breq	.+24     	; 0x1330 <vfprintf+0x8e>
    1318:	80 33       	cpi	r24, 0x30	; 48
    131a:	69 f4       	brne	.+26     	; 0x1336 <vfprintf+0x94>
    131c:	23 2d       	mov	r18, r3
    131e:	21 60       	ori	r18, 0x01	; 1
    1320:	16 c0       	rjmp	.+44     	; 0x134e <vfprintf+0xac>
    1322:	83 2d       	mov	r24, r3
    1324:	82 60       	ori	r24, 0x02	; 2
    1326:	38 2e       	mov	r3, r24
    1328:	e3 2d       	mov	r30, r3
    132a:	e4 60       	ori	r30, 0x04	; 4
    132c:	3e 2e       	mov	r3, r30
    132e:	2a c0       	rjmp	.+84     	; 0x1384 <vfprintf+0xe2>
    1330:	f3 2d       	mov	r31, r3
    1332:	f8 60       	ori	r31, 0x08	; 8
    1334:	1d c0       	rjmp	.+58     	; 0x1370 <vfprintf+0xce>
    1336:	37 fc       	sbrc	r3, 7
    1338:	2d c0       	rjmp	.+90     	; 0x1394 <vfprintf+0xf2>
    133a:	20 ed       	ldi	r18, 0xD0	; 208
    133c:	28 0f       	add	r18, r24
    133e:	2a 30       	cpi	r18, 0x0A	; 10
    1340:	40 f0       	brcs	.+16     	; 0x1352 <vfprintf+0xb0>
    1342:	8e 32       	cpi	r24, 0x2E	; 46
    1344:	b9 f4       	brne	.+46     	; 0x1374 <vfprintf+0xd2>
    1346:	36 fc       	sbrc	r3, 6
    1348:	75 c1       	rjmp	.+746    	; 0x1634 <vfprintf+0x392>
    134a:	23 2d       	mov	r18, r3
    134c:	20 64       	ori	r18, 0x40	; 64
    134e:	32 2e       	mov	r3, r18
    1350:	19 c0       	rjmp	.+50     	; 0x1384 <vfprintf+0xe2>
    1352:	36 fe       	sbrs	r3, 6
    1354:	06 c0       	rjmp	.+12     	; 0x1362 <vfprintf+0xc0>
    1356:	8a e0       	ldi	r24, 0x0A	; 10
    1358:	98 9e       	mul	r9, r24
    135a:	20 0d       	add	r18, r0
    135c:	11 24       	eor	r1, r1
    135e:	92 2e       	mov	r9, r18
    1360:	11 c0       	rjmp	.+34     	; 0x1384 <vfprintf+0xe2>
    1362:	ea e0       	ldi	r30, 0x0A	; 10
    1364:	2e 9e       	mul	r2, r30
    1366:	20 0d       	add	r18, r0
    1368:	11 24       	eor	r1, r1
    136a:	22 2e       	mov	r2, r18
    136c:	f3 2d       	mov	r31, r3
    136e:	f0 62       	ori	r31, 0x20	; 32
    1370:	3f 2e       	mov	r3, r31
    1372:	08 c0       	rjmp	.+16     	; 0x1384 <vfprintf+0xe2>
    1374:	8c 36       	cpi	r24, 0x6C	; 108
    1376:	21 f4       	brne	.+8      	; 0x1380 <vfprintf+0xde>
    1378:	83 2d       	mov	r24, r3
    137a:	80 68       	ori	r24, 0x80	; 128
    137c:	38 2e       	mov	r3, r24
    137e:	02 c0       	rjmp	.+4      	; 0x1384 <vfprintf+0xe2>
    1380:	88 36       	cpi	r24, 0x68	; 104
    1382:	41 f4       	brne	.+16     	; 0x1394 <vfprintf+0xf2>
    1384:	f7 01       	movw	r30, r14
    1386:	93 fd       	sbrc	r25, 3
    1388:	85 91       	lpm	r24, Z+
    138a:	93 ff       	sbrs	r25, 3
    138c:	81 91       	ld	r24, Z+
    138e:	7f 01       	movw	r14, r30
    1390:	81 11       	cpse	r24, r1
    1392:	b3 cf       	rjmp	.-154    	; 0x12fa <vfprintf+0x58>
    1394:	98 2f       	mov	r25, r24
    1396:	9f 7d       	andi	r25, 0xDF	; 223
    1398:	95 54       	subi	r25, 0x45	; 69
    139a:	93 30       	cpi	r25, 0x03	; 3
    139c:	28 f4       	brcc	.+10     	; 0x13a8 <vfprintf+0x106>
    139e:	0c 5f       	subi	r16, 0xFC	; 252
    13a0:	1f 4f       	sbci	r17, 0xFF	; 255
    13a2:	9f e3       	ldi	r25, 0x3F	; 63
    13a4:	99 83       	std	Y+1, r25	; 0x01
    13a6:	0d c0       	rjmp	.+26     	; 0x13c2 <vfprintf+0x120>
    13a8:	83 36       	cpi	r24, 0x63	; 99
    13aa:	31 f0       	breq	.+12     	; 0x13b8 <vfprintf+0x116>
    13ac:	83 37       	cpi	r24, 0x73	; 115
    13ae:	71 f0       	breq	.+28     	; 0x13cc <vfprintf+0x12a>
    13b0:	83 35       	cpi	r24, 0x53	; 83
    13b2:	09 f0       	breq	.+2      	; 0x13b6 <vfprintf+0x114>
    13b4:	55 c0       	rjmp	.+170    	; 0x1460 <vfprintf+0x1be>
    13b6:	20 c0       	rjmp	.+64     	; 0x13f8 <vfprintf+0x156>
    13b8:	f8 01       	movw	r30, r16
    13ba:	80 81       	ld	r24, Z
    13bc:	89 83       	std	Y+1, r24	; 0x01
    13be:	0e 5f       	subi	r16, 0xFE	; 254
    13c0:	1f 4f       	sbci	r17, 0xFF	; 255
    13c2:	88 24       	eor	r8, r8
    13c4:	83 94       	inc	r8
    13c6:	91 2c       	mov	r9, r1
    13c8:	53 01       	movw	r10, r6
    13ca:	12 c0       	rjmp	.+36     	; 0x13f0 <vfprintf+0x14e>
    13cc:	28 01       	movw	r4, r16
    13ce:	f2 e0       	ldi	r31, 0x02	; 2
    13d0:	4f 0e       	add	r4, r31
    13d2:	51 1c       	adc	r5, r1
    13d4:	f8 01       	movw	r30, r16
    13d6:	a0 80       	ld	r10, Z
    13d8:	b1 80       	ldd	r11, Z+1	; 0x01
    13da:	36 fe       	sbrs	r3, 6
    13dc:	03 c0       	rjmp	.+6      	; 0x13e4 <vfprintf+0x142>
    13de:	69 2d       	mov	r22, r9
    13e0:	70 e0       	ldi	r23, 0x00	; 0
    13e2:	02 c0       	rjmp	.+4      	; 0x13e8 <vfprintf+0x146>
    13e4:	6f ef       	ldi	r22, 0xFF	; 255
    13e6:	7f ef       	ldi	r23, 0xFF	; 255
    13e8:	c5 01       	movw	r24, r10
    13ea:	67 d3       	rcall	.+1742   	; 0x1aba <strnlen>
    13ec:	4c 01       	movw	r8, r24
    13ee:	82 01       	movw	r16, r4
    13f0:	f3 2d       	mov	r31, r3
    13f2:	ff 77       	andi	r31, 0x7F	; 127
    13f4:	3f 2e       	mov	r3, r31
    13f6:	15 c0       	rjmp	.+42     	; 0x1422 <vfprintf+0x180>
    13f8:	28 01       	movw	r4, r16
    13fa:	22 e0       	ldi	r18, 0x02	; 2
    13fc:	42 0e       	add	r4, r18
    13fe:	51 1c       	adc	r5, r1
    1400:	f8 01       	movw	r30, r16
    1402:	a0 80       	ld	r10, Z
    1404:	b1 80       	ldd	r11, Z+1	; 0x01
    1406:	36 fe       	sbrs	r3, 6
    1408:	03 c0       	rjmp	.+6      	; 0x1410 <vfprintf+0x16e>
    140a:	69 2d       	mov	r22, r9
    140c:	70 e0       	ldi	r23, 0x00	; 0
    140e:	02 c0       	rjmp	.+4      	; 0x1414 <vfprintf+0x172>
    1410:	6f ef       	ldi	r22, 0xFF	; 255
    1412:	7f ef       	ldi	r23, 0xFF	; 255
    1414:	c5 01       	movw	r24, r10
    1416:	46 d3       	rcall	.+1676   	; 0x1aa4 <strnlen_P>
    1418:	4c 01       	movw	r8, r24
    141a:	f3 2d       	mov	r31, r3
    141c:	f0 68       	ori	r31, 0x80	; 128
    141e:	3f 2e       	mov	r3, r31
    1420:	82 01       	movw	r16, r4
    1422:	33 fc       	sbrc	r3, 3
    1424:	19 c0       	rjmp	.+50     	; 0x1458 <vfprintf+0x1b6>
    1426:	82 2d       	mov	r24, r2
    1428:	90 e0       	ldi	r25, 0x00	; 0
    142a:	88 16       	cp	r8, r24
    142c:	99 06       	cpc	r9, r25
    142e:	a0 f4       	brcc	.+40     	; 0x1458 <vfprintf+0x1b6>
    1430:	b6 01       	movw	r22, r12
    1432:	80 e2       	ldi	r24, 0x20	; 32
    1434:	90 e0       	ldi	r25, 0x00	; 0
    1436:	4c d3       	rcall	.+1688   	; 0x1ad0 <fputc>
    1438:	2a 94       	dec	r2
    143a:	f5 cf       	rjmp	.-22     	; 0x1426 <vfprintf+0x184>
    143c:	f5 01       	movw	r30, r10
    143e:	37 fc       	sbrc	r3, 7
    1440:	85 91       	lpm	r24, Z+
    1442:	37 fe       	sbrs	r3, 7
    1444:	81 91       	ld	r24, Z+
    1446:	5f 01       	movw	r10, r30
    1448:	b6 01       	movw	r22, r12
    144a:	90 e0       	ldi	r25, 0x00	; 0
    144c:	41 d3       	rcall	.+1666   	; 0x1ad0 <fputc>
    144e:	21 10       	cpse	r2, r1
    1450:	2a 94       	dec	r2
    1452:	21 e0       	ldi	r18, 0x01	; 1
    1454:	82 1a       	sub	r8, r18
    1456:	91 08       	sbc	r9, r1
    1458:	81 14       	cp	r8, r1
    145a:	91 04       	cpc	r9, r1
    145c:	79 f7       	brne	.-34     	; 0x143c <vfprintf+0x19a>
    145e:	e1 c0       	rjmp	.+450    	; 0x1622 <vfprintf+0x380>
    1460:	84 36       	cpi	r24, 0x64	; 100
    1462:	11 f0       	breq	.+4      	; 0x1468 <vfprintf+0x1c6>
    1464:	89 36       	cpi	r24, 0x69	; 105
    1466:	39 f5       	brne	.+78     	; 0x14b6 <vfprintf+0x214>
    1468:	f8 01       	movw	r30, r16
    146a:	37 fe       	sbrs	r3, 7
    146c:	07 c0       	rjmp	.+14     	; 0x147c <vfprintf+0x1da>
    146e:	60 81       	ld	r22, Z
    1470:	71 81       	ldd	r23, Z+1	; 0x01
    1472:	82 81       	ldd	r24, Z+2	; 0x02
    1474:	93 81       	ldd	r25, Z+3	; 0x03
    1476:	0c 5f       	subi	r16, 0xFC	; 252
    1478:	1f 4f       	sbci	r17, 0xFF	; 255
    147a:	08 c0       	rjmp	.+16     	; 0x148c <vfprintf+0x1ea>
    147c:	60 81       	ld	r22, Z
    147e:	71 81       	ldd	r23, Z+1	; 0x01
    1480:	07 2e       	mov	r0, r23
    1482:	00 0c       	add	r0, r0
    1484:	88 0b       	sbc	r24, r24
    1486:	99 0b       	sbc	r25, r25
    1488:	0e 5f       	subi	r16, 0xFE	; 254
    148a:	1f 4f       	sbci	r17, 0xFF	; 255
    148c:	f3 2d       	mov	r31, r3
    148e:	ff 76       	andi	r31, 0x6F	; 111
    1490:	3f 2e       	mov	r3, r31
    1492:	97 ff       	sbrs	r25, 7
    1494:	09 c0       	rjmp	.+18     	; 0x14a8 <vfprintf+0x206>
    1496:	90 95       	com	r25
    1498:	80 95       	com	r24
    149a:	70 95       	com	r23
    149c:	61 95       	neg	r22
    149e:	7f 4f       	sbci	r23, 0xFF	; 255
    14a0:	8f 4f       	sbci	r24, 0xFF	; 255
    14a2:	9f 4f       	sbci	r25, 0xFF	; 255
    14a4:	f0 68       	ori	r31, 0x80	; 128
    14a6:	3f 2e       	mov	r3, r31
    14a8:	2a e0       	ldi	r18, 0x0A	; 10
    14aa:	30 e0       	ldi	r19, 0x00	; 0
    14ac:	a3 01       	movw	r20, r6
    14ae:	4c d3       	rcall	.+1688   	; 0x1b48 <__ultoa_invert>
    14b0:	88 2e       	mov	r8, r24
    14b2:	86 18       	sub	r8, r6
    14b4:	44 c0       	rjmp	.+136    	; 0x153e <vfprintf+0x29c>
    14b6:	85 37       	cpi	r24, 0x75	; 117
    14b8:	31 f4       	brne	.+12     	; 0x14c6 <vfprintf+0x224>
    14ba:	23 2d       	mov	r18, r3
    14bc:	2f 7e       	andi	r18, 0xEF	; 239
    14be:	b2 2e       	mov	r11, r18
    14c0:	2a e0       	ldi	r18, 0x0A	; 10
    14c2:	30 e0       	ldi	r19, 0x00	; 0
    14c4:	25 c0       	rjmp	.+74     	; 0x1510 <vfprintf+0x26e>
    14c6:	93 2d       	mov	r25, r3
    14c8:	99 7f       	andi	r25, 0xF9	; 249
    14ca:	b9 2e       	mov	r11, r25
    14cc:	8f 36       	cpi	r24, 0x6F	; 111
    14ce:	c1 f0       	breq	.+48     	; 0x1500 <vfprintf+0x25e>
    14d0:	18 f4       	brcc	.+6      	; 0x14d8 <vfprintf+0x236>
    14d2:	88 35       	cpi	r24, 0x58	; 88
    14d4:	79 f0       	breq	.+30     	; 0x14f4 <vfprintf+0x252>
    14d6:	ae c0       	rjmp	.+348    	; 0x1634 <vfprintf+0x392>
    14d8:	80 37       	cpi	r24, 0x70	; 112
    14da:	19 f0       	breq	.+6      	; 0x14e2 <vfprintf+0x240>
    14dc:	88 37       	cpi	r24, 0x78	; 120
    14de:	21 f0       	breq	.+8      	; 0x14e8 <vfprintf+0x246>
    14e0:	a9 c0       	rjmp	.+338    	; 0x1634 <vfprintf+0x392>
    14e2:	e9 2f       	mov	r30, r25
    14e4:	e0 61       	ori	r30, 0x10	; 16
    14e6:	be 2e       	mov	r11, r30
    14e8:	b4 fe       	sbrs	r11, 4
    14ea:	0d c0       	rjmp	.+26     	; 0x1506 <vfprintf+0x264>
    14ec:	fb 2d       	mov	r31, r11
    14ee:	f4 60       	ori	r31, 0x04	; 4
    14f0:	bf 2e       	mov	r11, r31
    14f2:	09 c0       	rjmp	.+18     	; 0x1506 <vfprintf+0x264>
    14f4:	34 fe       	sbrs	r3, 4
    14f6:	0a c0       	rjmp	.+20     	; 0x150c <vfprintf+0x26a>
    14f8:	29 2f       	mov	r18, r25
    14fa:	26 60       	ori	r18, 0x06	; 6
    14fc:	b2 2e       	mov	r11, r18
    14fe:	06 c0       	rjmp	.+12     	; 0x150c <vfprintf+0x26a>
    1500:	28 e0       	ldi	r18, 0x08	; 8
    1502:	30 e0       	ldi	r19, 0x00	; 0
    1504:	05 c0       	rjmp	.+10     	; 0x1510 <vfprintf+0x26e>
    1506:	20 e1       	ldi	r18, 0x10	; 16
    1508:	30 e0       	ldi	r19, 0x00	; 0
    150a:	02 c0       	rjmp	.+4      	; 0x1510 <vfprintf+0x26e>
    150c:	20 e1       	ldi	r18, 0x10	; 16
    150e:	32 e0       	ldi	r19, 0x02	; 2
    1510:	f8 01       	movw	r30, r16
    1512:	b7 fe       	sbrs	r11, 7
    1514:	07 c0       	rjmp	.+14     	; 0x1524 <vfprintf+0x282>
    1516:	60 81       	ld	r22, Z
    1518:	71 81       	ldd	r23, Z+1	; 0x01
    151a:	82 81       	ldd	r24, Z+2	; 0x02
    151c:	93 81       	ldd	r25, Z+3	; 0x03
    151e:	0c 5f       	subi	r16, 0xFC	; 252
    1520:	1f 4f       	sbci	r17, 0xFF	; 255
    1522:	06 c0       	rjmp	.+12     	; 0x1530 <vfprintf+0x28e>
    1524:	60 81       	ld	r22, Z
    1526:	71 81       	ldd	r23, Z+1	; 0x01
    1528:	80 e0       	ldi	r24, 0x00	; 0
    152a:	90 e0       	ldi	r25, 0x00	; 0
    152c:	0e 5f       	subi	r16, 0xFE	; 254
    152e:	1f 4f       	sbci	r17, 0xFF	; 255
    1530:	a3 01       	movw	r20, r6
    1532:	0a d3       	rcall	.+1556   	; 0x1b48 <__ultoa_invert>
    1534:	88 2e       	mov	r8, r24
    1536:	86 18       	sub	r8, r6
    1538:	fb 2d       	mov	r31, r11
    153a:	ff 77       	andi	r31, 0x7F	; 127
    153c:	3f 2e       	mov	r3, r31
    153e:	36 fe       	sbrs	r3, 6
    1540:	0d c0       	rjmp	.+26     	; 0x155c <vfprintf+0x2ba>
    1542:	23 2d       	mov	r18, r3
    1544:	2e 7f       	andi	r18, 0xFE	; 254
    1546:	a2 2e       	mov	r10, r18
    1548:	89 14       	cp	r8, r9
    154a:	58 f4       	brcc	.+22     	; 0x1562 <vfprintf+0x2c0>
    154c:	34 fe       	sbrs	r3, 4
    154e:	0b c0       	rjmp	.+22     	; 0x1566 <vfprintf+0x2c4>
    1550:	32 fc       	sbrc	r3, 2
    1552:	09 c0       	rjmp	.+18     	; 0x1566 <vfprintf+0x2c4>
    1554:	83 2d       	mov	r24, r3
    1556:	8e 7e       	andi	r24, 0xEE	; 238
    1558:	a8 2e       	mov	r10, r24
    155a:	05 c0       	rjmp	.+10     	; 0x1566 <vfprintf+0x2c4>
    155c:	b8 2c       	mov	r11, r8
    155e:	a3 2c       	mov	r10, r3
    1560:	03 c0       	rjmp	.+6      	; 0x1568 <vfprintf+0x2c6>
    1562:	b8 2c       	mov	r11, r8
    1564:	01 c0       	rjmp	.+2      	; 0x1568 <vfprintf+0x2c6>
    1566:	b9 2c       	mov	r11, r9
    1568:	a4 fe       	sbrs	r10, 4
    156a:	0f c0       	rjmp	.+30     	; 0x158a <vfprintf+0x2e8>
    156c:	fe 01       	movw	r30, r28
    156e:	e8 0d       	add	r30, r8
    1570:	f1 1d       	adc	r31, r1
    1572:	80 81       	ld	r24, Z
    1574:	80 33       	cpi	r24, 0x30	; 48
    1576:	21 f4       	brne	.+8      	; 0x1580 <vfprintf+0x2de>
    1578:	9a 2d       	mov	r25, r10
    157a:	99 7e       	andi	r25, 0xE9	; 233
    157c:	a9 2e       	mov	r10, r25
    157e:	09 c0       	rjmp	.+18     	; 0x1592 <vfprintf+0x2f0>
    1580:	a2 fe       	sbrs	r10, 2
    1582:	06 c0       	rjmp	.+12     	; 0x1590 <vfprintf+0x2ee>
    1584:	b3 94       	inc	r11
    1586:	b3 94       	inc	r11
    1588:	04 c0       	rjmp	.+8      	; 0x1592 <vfprintf+0x2f0>
    158a:	8a 2d       	mov	r24, r10
    158c:	86 78       	andi	r24, 0x86	; 134
    158e:	09 f0       	breq	.+2      	; 0x1592 <vfprintf+0x2f0>
    1590:	b3 94       	inc	r11
    1592:	a3 fc       	sbrc	r10, 3
    1594:	10 c0       	rjmp	.+32     	; 0x15b6 <vfprintf+0x314>
    1596:	a0 fe       	sbrs	r10, 0
    1598:	06 c0       	rjmp	.+12     	; 0x15a6 <vfprintf+0x304>
    159a:	b2 14       	cp	r11, r2
    159c:	80 f4       	brcc	.+32     	; 0x15be <vfprintf+0x31c>
    159e:	28 0c       	add	r2, r8
    15a0:	92 2c       	mov	r9, r2
    15a2:	9b 18       	sub	r9, r11
    15a4:	0d c0       	rjmp	.+26     	; 0x15c0 <vfprintf+0x31e>
    15a6:	b2 14       	cp	r11, r2
    15a8:	58 f4       	brcc	.+22     	; 0x15c0 <vfprintf+0x31e>
    15aa:	b6 01       	movw	r22, r12
    15ac:	80 e2       	ldi	r24, 0x20	; 32
    15ae:	90 e0       	ldi	r25, 0x00	; 0
    15b0:	8f d2       	rcall	.+1310   	; 0x1ad0 <fputc>
    15b2:	b3 94       	inc	r11
    15b4:	f8 cf       	rjmp	.-16     	; 0x15a6 <vfprintf+0x304>
    15b6:	b2 14       	cp	r11, r2
    15b8:	18 f4       	brcc	.+6      	; 0x15c0 <vfprintf+0x31e>
    15ba:	2b 18       	sub	r2, r11
    15bc:	02 c0       	rjmp	.+4      	; 0x15c2 <vfprintf+0x320>
    15be:	98 2c       	mov	r9, r8
    15c0:	21 2c       	mov	r2, r1
    15c2:	a4 fe       	sbrs	r10, 4
    15c4:	0f c0       	rjmp	.+30     	; 0x15e4 <vfprintf+0x342>
    15c6:	b6 01       	movw	r22, r12
    15c8:	80 e3       	ldi	r24, 0x30	; 48
    15ca:	90 e0       	ldi	r25, 0x00	; 0
    15cc:	81 d2       	rcall	.+1282   	; 0x1ad0 <fputc>
    15ce:	a2 fe       	sbrs	r10, 2
    15d0:	16 c0       	rjmp	.+44     	; 0x15fe <vfprintf+0x35c>
    15d2:	a1 fc       	sbrc	r10, 1
    15d4:	03 c0       	rjmp	.+6      	; 0x15dc <vfprintf+0x33a>
    15d6:	88 e7       	ldi	r24, 0x78	; 120
    15d8:	90 e0       	ldi	r25, 0x00	; 0
    15da:	02 c0       	rjmp	.+4      	; 0x15e0 <vfprintf+0x33e>
    15dc:	88 e5       	ldi	r24, 0x58	; 88
    15de:	90 e0       	ldi	r25, 0x00	; 0
    15e0:	b6 01       	movw	r22, r12
    15e2:	0c c0       	rjmp	.+24     	; 0x15fc <vfprintf+0x35a>
    15e4:	8a 2d       	mov	r24, r10
    15e6:	86 78       	andi	r24, 0x86	; 134
    15e8:	51 f0       	breq	.+20     	; 0x15fe <vfprintf+0x35c>
    15ea:	a1 fe       	sbrs	r10, 1
    15ec:	02 c0       	rjmp	.+4      	; 0x15f2 <vfprintf+0x350>
    15ee:	8b e2       	ldi	r24, 0x2B	; 43
    15f0:	01 c0       	rjmp	.+2      	; 0x15f4 <vfprintf+0x352>
    15f2:	80 e2       	ldi	r24, 0x20	; 32
    15f4:	a7 fc       	sbrc	r10, 7
    15f6:	8d e2       	ldi	r24, 0x2D	; 45
    15f8:	b6 01       	movw	r22, r12
    15fa:	90 e0       	ldi	r25, 0x00	; 0
    15fc:	69 d2       	rcall	.+1234   	; 0x1ad0 <fputc>
    15fe:	89 14       	cp	r8, r9
    1600:	30 f4       	brcc	.+12     	; 0x160e <vfprintf+0x36c>
    1602:	b6 01       	movw	r22, r12
    1604:	80 e3       	ldi	r24, 0x30	; 48
    1606:	90 e0       	ldi	r25, 0x00	; 0
    1608:	63 d2       	rcall	.+1222   	; 0x1ad0 <fputc>
    160a:	9a 94       	dec	r9
    160c:	f8 cf       	rjmp	.-16     	; 0x15fe <vfprintf+0x35c>
    160e:	8a 94       	dec	r8
    1610:	f3 01       	movw	r30, r6
    1612:	e8 0d       	add	r30, r8
    1614:	f1 1d       	adc	r31, r1
    1616:	80 81       	ld	r24, Z
    1618:	b6 01       	movw	r22, r12
    161a:	90 e0       	ldi	r25, 0x00	; 0
    161c:	59 d2       	rcall	.+1202   	; 0x1ad0 <fputc>
    161e:	81 10       	cpse	r8, r1
    1620:	f6 cf       	rjmp	.-20     	; 0x160e <vfprintf+0x36c>
    1622:	22 20       	and	r2, r2
    1624:	09 f4       	brne	.+2      	; 0x1628 <vfprintf+0x386>
    1626:	4e ce       	rjmp	.-868    	; 0x12c4 <vfprintf+0x22>
    1628:	b6 01       	movw	r22, r12
    162a:	80 e2       	ldi	r24, 0x20	; 32
    162c:	90 e0       	ldi	r25, 0x00	; 0
    162e:	50 d2       	rcall	.+1184   	; 0x1ad0 <fputc>
    1630:	2a 94       	dec	r2
    1632:	f7 cf       	rjmp	.-18     	; 0x1622 <vfprintf+0x380>
    1634:	f6 01       	movw	r30, r12
    1636:	86 81       	ldd	r24, Z+6	; 0x06
    1638:	97 81       	ldd	r25, Z+7	; 0x07
    163a:	02 c0       	rjmp	.+4      	; 0x1640 <vfprintf+0x39e>
    163c:	8f ef       	ldi	r24, 0xFF	; 255
    163e:	9f ef       	ldi	r25, 0xFF	; 255
    1640:	2b 96       	adiw	r28, 0x0b	; 11
    1642:	e2 e1       	ldi	r30, 0x12	; 18
    1644:	f8 c2       	rjmp	.+1520   	; 0x1c36 <__epilogue_restores__>

00001646 <dtoa_prf>:
    1646:	a9 e0       	ldi	r26, 0x09	; 9
    1648:	b0 e0       	ldi	r27, 0x00	; 0
    164a:	e8 e2       	ldi	r30, 0x28	; 40
    164c:	fb e0       	ldi	r31, 0x0B	; 11
    164e:	e0 c2       	rjmp	.+1472   	; 0x1c10 <__prologue_saves__+0xc>
    1650:	6a 01       	movw	r12, r20
    1652:	12 2f       	mov	r17, r18
    1654:	b0 2e       	mov	r11, r16
    1656:	2b e3       	ldi	r18, 0x3B	; 59
    1658:	20 17       	cp	r18, r16
    165a:	20 f0       	brcs	.+8      	; 0x1664 <dtoa_prf+0x1e>
    165c:	ff 24       	eor	r15, r15
    165e:	f3 94       	inc	r15
    1660:	f0 0e       	add	r15, r16
    1662:	02 c0       	rjmp	.+4      	; 0x1668 <dtoa_prf+0x22>
    1664:	2c e3       	ldi	r18, 0x3C	; 60
    1666:	f2 2e       	mov	r15, r18
    1668:	0f 2d       	mov	r16, r15
    166a:	27 e0       	ldi	r18, 0x07	; 7
    166c:	ae 01       	movw	r20, r28
    166e:	4f 5f       	subi	r20, 0xFF	; 255
    1670:	5f 4f       	sbci	r21, 0xFF	; 255
    1672:	40 d1       	rcall	.+640    	; 0x18f4 <__ftoa_engine>
    1674:	bc 01       	movw	r22, r24
    1676:	49 81       	ldd	r20, Y+1	; 0x01
    1678:	84 2f       	mov	r24, r20
    167a:	89 70       	andi	r24, 0x09	; 9
    167c:	81 30       	cpi	r24, 0x01	; 1
    167e:	31 f0       	breq	.+12     	; 0x168c <dtoa_prf+0x46>
    1680:	e1 fc       	sbrc	r14, 1
    1682:	06 c0       	rjmp	.+12     	; 0x1690 <dtoa_prf+0x4a>
    1684:	e0 fe       	sbrs	r14, 0
    1686:	06 c0       	rjmp	.+12     	; 0x1694 <dtoa_prf+0x4e>
    1688:	90 e2       	ldi	r25, 0x20	; 32
    168a:	05 c0       	rjmp	.+10     	; 0x1696 <dtoa_prf+0x50>
    168c:	9d e2       	ldi	r25, 0x2D	; 45
    168e:	03 c0       	rjmp	.+6      	; 0x1696 <dtoa_prf+0x50>
    1690:	9b e2       	ldi	r25, 0x2B	; 43
    1692:	01 c0       	rjmp	.+2      	; 0x1696 <dtoa_prf+0x50>
    1694:	90 e0       	ldi	r25, 0x00	; 0
    1696:	5e 2d       	mov	r21, r14
    1698:	50 71       	andi	r21, 0x10	; 16
    169a:	43 ff       	sbrs	r20, 3
    169c:	3c c0       	rjmp	.+120    	; 0x1716 <dtoa_prf+0xd0>
    169e:	91 11       	cpse	r25, r1
    16a0:	02 c0       	rjmp	.+4      	; 0x16a6 <dtoa_prf+0x60>
    16a2:	83 e0       	ldi	r24, 0x03	; 3
    16a4:	01 c0       	rjmp	.+2      	; 0x16a8 <dtoa_prf+0x62>
    16a6:	84 e0       	ldi	r24, 0x04	; 4
    16a8:	81 17       	cp	r24, r17
    16aa:	18 f4       	brcc	.+6      	; 0x16b2 <dtoa_prf+0x6c>
    16ac:	21 2f       	mov	r18, r17
    16ae:	28 1b       	sub	r18, r24
    16b0:	01 c0       	rjmp	.+2      	; 0x16b4 <dtoa_prf+0x6e>
    16b2:	20 e0       	ldi	r18, 0x00	; 0
    16b4:	51 11       	cpse	r21, r1
    16b6:	0b c0       	rjmp	.+22     	; 0x16ce <dtoa_prf+0x88>
    16b8:	f6 01       	movw	r30, r12
    16ba:	82 2f       	mov	r24, r18
    16bc:	30 e2       	ldi	r19, 0x20	; 32
    16be:	88 23       	and	r24, r24
    16c0:	19 f0       	breq	.+6      	; 0x16c8 <dtoa_prf+0x82>
    16c2:	31 93       	st	Z+, r19
    16c4:	81 50       	subi	r24, 0x01	; 1
    16c6:	fb cf       	rjmp	.-10     	; 0x16be <dtoa_prf+0x78>
    16c8:	c2 0e       	add	r12, r18
    16ca:	d1 1c       	adc	r13, r1
    16cc:	20 e0       	ldi	r18, 0x00	; 0
    16ce:	99 23       	and	r25, r25
    16d0:	29 f0       	breq	.+10     	; 0x16dc <dtoa_prf+0x96>
    16d2:	d6 01       	movw	r26, r12
    16d4:	9c 93       	st	X, r25
    16d6:	f6 01       	movw	r30, r12
    16d8:	31 96       	adiw	r30, 0x01	; 1
    16da:	6f 01       	movw	r12, r30
    16dc:	c6 01       	movw	r24, r12
    16de:	03 96       	adiw	r24, 0x03	; 3
    16e0:	e2 fe       	sbrs	r14, 2
    16e2:	0a c0       	rjmp	.+20     	; 0x16f8 <dtoa_prf+0xb2>
    16e4:	3e e4       	ldi	r19, 0x4E	; 78
    16e6:	d6 01       	movw	r26, r12
    16e8:	3c 93       	st	X, r19
    16ea:	41 e4       	ldi	r20, 0x41	; 65
    16ec:	11 96       	adiw	r26, 0x01	; 1
    16ee:	4c 93       	st	X, r20
    16f0:	11 97       	sbiw	r26, 0x01	; 1
    16f2:	12 96       	adiw	r26, 0x02	; 2
    16f4:	3c 93       	st	X, r19
    16f6:	06 c0       	rjmp	.+12     	; 0x1704 <dtoa_prf+0xbe>
    16f8:	3e e6       	ldi	r19, 0x6E	; 110
    16fa:	f6 01       	movw	r30, r12
    16fc:	30 83       	st	Z, r19
    16fe:	41 e6       	ldi	r20, 0x61	; 97
    1700:	41 83       	std	Z+1, r20	; 0x01
    1702:	32 83       	std	Z+2, r19	; 0x02
    1704:	fc 01       	movw	r30, r24
    1706:	32 2f       	mov	r19, r18
    1708:	40 e2       	ldi	r20, 0x20	; 32
    170a:	33 23       	and	r19, r19
    170c:	09 f4       	brne	.+2      	; 0x1710 <dtoa_prf+0xca>
    170e:	42 c0       	rjmp	.+132    	; 0x1794 <dtoa_prf+0x14e>
    1710:	41 93       	st	Z+, r20
    1712:	31 50       	subi	r19, 0x01	; 1
    1714:	fa cf       	rjmp	.-12     	; 0x170a <dtoa_prf+0xc4>
    1716:	42 ff       	sbrs	r20, 2
    1718:	44 c0       	rjmp	.+136    	; 0x17a2 <dtoa_prf+0x15c>
    171a:	91 11       	cpse	r25, r1
    171c:	02 c0       	rjmp	.+4      	; 0x1722 <dtoa_prf+0xdc>
    171e:	83 e0       	ldi	r24, 0x03	; 3
    1720:	01 c0       	rjmp	.+2      	; 0x1724 <dtoa_prf+0xde>
    1722:	84 e0       	ldi	r24, 0x04	; 4
    1724:	81 17       	cp	r24, r17
    1726:	18 f4       	brcc	.+6      	; 0x172e <dtoa_prf+0xe8>
    1728:	21 2f       	mov	r18, r17
    172a:	28 1b       	sub	r18, r24
    172c:	01 c0       	rjmp	.+2      	; 0x1730 <dtoa_prf+0xea>
    172e:	20 e0       	ldi	r18, 0x00	; 0
    1730:	51 11       	cpse	r21, r1
    1732:	0b c0       	rjmp	.+22     	; 0x174a <dtoa_prf+0x104>
    1734:	f6 01       	movw	r30, r12
    1736:	82 2f       	mov	r24, r18
    1738:	30 e2       	ldi	r19, 0x20	; 32
    173a:	88 23       	and	r24, r24
    173c:	19 f0       	breq	.+6      	; 0x1744 <dtoa_prf+0xfe>
    173e:	31 93       	st	Z+, r19
    1740:	81 50       	subi	r24, 0x01	; 1
    1742:	fb cf       	rjmp	.-10     	; 0x173a <dtoa_prf+0xf4>
    1744:	c2 0e       	add	r12, r18
    1746:	d1 1c       	adc	r13, r1
    1748:	20 e0       	ldi	r18, 0x00	; 0
    174a:	99 23       	and	r25, r25
    174c:	29 f0       	breq	.+10     	; 0x1758 <dtoa_prf+0x112>
    174e:	d6 01       	movw	r26, r12
    1750:	9c 93       	st	X, r25
    1752:	f6 01       	movw	r30, r12
    1754:	31 96       	adiw	r30, 0x01	; 1
    1756:	6f 01       	movw	r12, r30
    1758:	c6 01       	movw	r24, r12
    175a:	03 96       	adiw	r24, 0x03	; 3
    175c:	e2 fe       	sbrs	r14, 2
    175e:	0b c0       	rjmp	.+22     	; 0x1776 <dtoa_prf+0x130>
    1760:	39 e4       	ldi	r19, 0x49	; 73
    1762:	d6 01       	movw	r26, r12
    1764:	3c 93       	st	X, r19
    1766:	3e e4       	ldi	r19, 0x4E	; 78
    1768:	11 96       	adiw	r26, 0x01	; 1
    176a:	3c 93       	st	X, r19
    176c:	11 97       	sbiw	r26, 0x01	; 1
    176e:	36 e4       	ldi	r19, 0x46	; 70
    1770:	12 96       	adiw	r26, 0x02	; 2
    1772:	3c 93       	st	X, r19
    1774:	07 c0       	rjmp	.+14     	; 0x1784 <dtoa_prf+0x13e>
    1776:	39 e6       	ldi	r19, 0x69	; 105
    1778:	f6 01       	movw	r30, r12
    177a:	30 83       	st	Z, r19
    177c:	3e e6       	ldi	r19, 0x6E	; 110
    177e:	31 83       	std	Z+1, r19	; 0x01
    1780:	36 e6       	ldi	r19, 0x66	; 102
    1782:	32 83       	std	Z+2, r19	; 0x02
    1784:	fc 01       	movw	r30, r24
    1786:	32 2f       	mov	r19, r18
    1788:	40 e2       	ldi	r20, 0x20	; 32
    178a:	33 23       	and	r19, r19
    178c:	19 f0       	breq	.+6      	; 0x1794 <dtoa_prf+0x14e>
    178e:	41 93       	st	Z+, r20
    1790:	31 50       	subi	r19, 0x01	; 1
    1792:	fb cf       	rjmp	.-10     	; 0x178a <dtoa_prf+0x144>
    1794:	fc 01       	movw	r30, r24
    1796:	e2 0f       	add	r30, r18
    1798:	f1 1d       	adc	r31, r1
    179a:	10 82       	st	Z, r1
    179c:	8e ef       	ldi	r24, 0xFE	; 254
    179e:	9f ef       	ldi	r25, 0xFF	; 255
    17a0:	a6 c0       	rjmp	.+332    	; 0x18ee <dtoa_prf+0x2a8>
    17a2:	21 e0       	ldi	r18, 0x01	; 1
    17a4:	30 e0       	ldi	r19, 0x00	; 0
    17a6:	91 11       	cpse	r25, r1
    17a8:	02 c0       	rjmp	.+4      	; 0x17ae <dtoa_prf+0x168>
    17aa:	20 e0       	ldi	r18, 0x00	; 0
    17ac:	30 e0       	ldi	r19, 0x00	; 0
    17ae:	16 16       	cp	r1, r22
    17b0:	17 06       	cpc	r1, r23
    17b2:	1c f4       	brge	.+6      	; 0x17ba <dtoa_prf+0x174>
    17b4:	fb 01       	movw	r30, r22
    17b6:	31 96       	adiw	r30, 0x01	; 1
    17b8:	02 c0       	rjmp	.+4      	; 0x17be <dtoa_prf+0x178>
    17ba:	e1 e0       	ldi	r30, 0x01	; 1
    17bc:	f0 e0       	ldi	r31, 0x00	; 0
    17be:	2e 0f       	add	r18, r30
    17c0:	3f 1f       	adc	r19, r31
    17c2:	bb 20       	and	r11, r11
    17c4:	21 f0       	breq	.+8      	; 0x17ce <dtoa_prf+0x188>
    17c6:	eb 2d       	mov	r30, r11
    17c8:	f0 e0       	ldi	r31, 0x00	; 0
    17ca:	31 96       	adiw	r30, 0x01	; 1
    17cc:	02 c0       	rjmp	.+4      	; 0x17d2 <dtoa_prf+0x18c>
    17ce:	e0 e0       	ldi	r30, 0x00	; 0
    17d0:	f0 e0       	ldi	r31, 0x00	; 0
    17d2:	2e 0f       	add	r18, r30
    17d4:	3f 1f       	adc	r19, r31
    17d6:	e1 2f       	mov	r30, r17
    17d8:	f0 e0       	ldi	r31, 0x00	; 0
    17da:	2e 17       	cp	r18, r30
    17dc:	3f 07       	cpc	r19, r31
    17de:	1c f4       	brge	.+6      	; 0x17e6 <dtoa_prf+0x1a0>
    17e0:	12 1b       	sub	r17, r18
    17e2:	21 2f       	mov	r18, r17
    17e4:	01 c0       	rjmp	.+2      	; 0x17e8 <dtoa_prf+0x1a2>
    17e6:	20 e0       	ldi	r18, 0x00	; 0
    17e8:	8e 2d       	mov	r24, r14
    17ea:	88 71       	andi	r24, 0x18	; 24
    17ec:	59 f4       	brne	.+22     	; 0x1804 <dtoa_prf+0x1be>
    17ee:	f6 01       	movw	r30, r12
    17f0:	82 2f       	mov	r24, r18
    17f2:	30 e2       	ldi	r19, 0x20	; 32
    17f4:	88 23       	and	r24, r24
    17f6:	19 f0       	breq	.+6      	; 0x17fe <dtoa_prf+0x1b8>
    17f8:	31 93       	st	Z+, r19
    17fa:	81 50       	subi	r24, 0x01	; 1
    17fc:	fb cf       	rjmp	.-10     	; 0x17f4 <dtoa_prf+0x1ae>
    17fe:	c2 0e       	add	r12, r18
    1800:	d1 1c       	adc	r13, r1
    1802:	20 e0       	ldi	r18, 0x00	; 0
    1804:	99 23       	and	r25, r25
    1806:	29 f0       	breq	.+10     	; 0x1812 <dtoa_prf+0x1cc>
    1808:	d6 01       	movw	r26, r12
    180a:	9c 93       	st	X, r25
    180c:	f6 01       	movw	r30, r12
    180e:	31 96       	adiw	r30, 0x01	; 1
    1810:	6f 01       	movw	r12, r30
    1812:	51 11       	cpse	r21, r1
    1814:	0b c0       	rjmp	.+22     	; 0x182c <dtoa_prf+0x1e6>
    1816:	f6 01       	movw	r30, r12
    1818:	82 2f       	mov	r24, r18
    181a:	90 e3       	ldi	r25, 0x30	; 48
    181c:	88 23       	and	r24, r24
    181e:	19 f0       	breq	.+6      	; 0x1826 <dtoa_prf+0x1e0>
    1820:	91 93       	st	Z+, r25
    1822:	81 50       	subi	r24, 0x01	; 1
    1824:	fb cf       	rjmp	.-10     	; 0x181c <dtoa_prf+0x1d6>
    1826:	c2 0e       	add	r12, r18
    1828:	d1 1c       	adc	r13, r1
    182a:	20 e0       	ldi	r18, 0x00	; 0
    182c:	0f 2d       	mov	r16, r15
    182e:	06 0f       	add	r16, r22
    1830:	9a 81       	ldd	r25, Y+2	; 0x02
    1832:	34 2f       	mov	r19, r20
    1834:	30 71       	andi	r19, 0x10	; 16
    1836:	44 ff       	sbrs	r20, 4
    1838:	03 c0       	rjmp	.+6      	; 0x1840 <dtoa_prf+0x1fa>
    183a:	91 33       	cpi	r25, 0x31	; 49
    183c:	09 f4       	brne	.+2      	; 0x1840 <dtoa_prf+0x1fa>
    183e:	01 50       	subi	r16, 0x01	; 1
    1840:	10 16       	cp	r1, r16
    1842:	24 f4       	brge	.+8      	; 0x184c <dtoa_prf+0x206>
    1844:	09 30       	cpi	r16, 0x09	; 9
    1846:	18 f0       	brcs	.+6      	; 0x184e <dtoa_prf+0x208>
    1848:	08 e0       	ldi	r16, 0x08	; 8
    184a:	01 c0       	rjmp	.+2      	; 0x184e <dtoa_prf+0x208>
    184c:	01 e0       	ldi	r16, 0x01	; 1
    184e:	ab 01       	movw	r20, r22
    1850:	77 ff       	sbrs	r23, 7
    1852:	02 c0       	rjmp	.+4      	; 0x1858 <dtoa_prf+0x212>
    1854:	40 e0       	ldi	r20, 0x00	; 0
    1856:	50 e0       	ldi	r21, 0x00	; 0
    1858:	fb 01       	movw	r30, r22
    185a:	e4 1b       	sub	r30, r20
    185c:	f5 0b       	sbc	r31, r21
    185e:	a1 e0       	ldi	r26, 0x01	; 1
    1860:	b0 e0       	ldi	r27, 0x00	; 0
    1862:	ac 0f       	add	r26, r28
    1864:	bd 1f       	adc	r27, r29
    1866:	ea 0f       	add	r30, r26
    1868:	fb 1f       	adc	r31, r27
    186a:	8e e2       	ldi	r24, 0x2E	; 46
    186c:	a8 2e       	mov	r10, r24
    186e:	4b 01       	movw	r8, r22
    1870:	80 1a       	sub	r8, r16
    1872:	91 08       	sbc	r9, r1
    1874:	0b 2d       	mov	r16, r11
    1876:	10 e0       	ldi	r17, 0x00	; 0
    1878:	11 95       	neg	r17
    187a:	01 95       	neg	r16
    187c:	11 09       	sbc	r17, r1
    187e:	4f 3f       	cpi	r20, 0xFF	; 255
    1880:	bf ef       	ldi	r27, 0xFF	; 255
    1882:	5b 07       	cpc	r21, r27
    1884:	21 f4       	brne	.+8      	; 0x188e <dtoa_prf+0x248>
    1886:	d6 01       	movw	r26, r12
    1888:	ac 92       	st	X, r10
    188a:	11 96       	adiw	r26, 0x01	; 1
    188c:	6d 01       	movw	r12, r26
    188e:	64 17       	cp	r22, r20
    1890:	75 07       	cpc	r23, r21
    1892:	2c f0       	brlt	.+10     	; 0x189e <dtoa_prf+0x258>
    1894:	84 16       	cp	r8, r20
    1896:	95 06       	cpc	r9, r21
    1898:	14 f4       	brge	.+4      	; 0x189e <dtoa_prf+0x258>
    189a:	81 81       	ldd	r24, Z+1	; 0x01
    189c:	01 c0       	rjmp	.+2      	; 0x18a0 <dtoa_prf+0x25a>
    189e:	80 e3       	ldi	r24, 0x30	; 48
    18a0:	41 50       	subi	r20, 0x01	; 1
    18a2:	51 09       	sbc	r21, r1
    18a4:	31 96       	adiw	r30, 0x01	; 1
    18a6:	d6 01       	movw	r26, r12
    18a8:	11 96       	adiw	r26, 0x01	; 1
    18aa:	7d 01       	movw	r14, r26
    18ac:	40 17       	cp	r20, r16
    18ae:	51 07       	cpc	r21, r17
    18b0:	24 f0       	brlt	.+8      	; 0x18ba <dtoa_prf+0x274>
    18b2:	d6 01       	movw	r26, r12
    18b4:	8c 93       	st	X, r24
    18b6:	67 01       	movw	r12, r14
    18b8:	e2 cf       	rjmp	.-60     	; 0x187e <dtoa_prf+0x238>
    18ba:	64 17       	cp	r22, r20
    18bc:	75 07       	cpc	r23, r21
    18be:	39 f4       	brne	.+14     	; 0x18ce <dtoa_prf+0x288>
    18c0:	96 33       	cpi	r25, 0x36	; 54
    18c2:	20 f4       	brcc	.+8      	; 0x18cc <dtoa_prf+0x286>
    18c4:	95 33       	cpi	r25, 0x35	; 53
    18c6:	19 f4       	brne	.+6      	; 0x18ce <dtoa_prf+0x288>
    18c8:	31 11       	cpse	r19, r1
    18ca:	01 c0       	rjmp	.+2      	; 0x18ce <dtoa_prf+0x288>
    18cc:	81 e3       	ldi	r24, 0x31	; 49
    18ce:	f6 01       	movw	r30, r12
    18d0:	80 83       	st	Z, r24
    18d2:	f7 01       	movw	r30, r14
    18d4:	82 2f       	mov	r24, r18
    18d6:	90 e2       	ldi	r25, 0x20	; 32
    18d8:	88 23       	and	r24, r24
    18da:	19 f0       	breq	.+6      	; 0x18e2 <dtoa_prf+0x29c>
    18dc:	91 93       	st	Z+, r25
    18de:	81 50       	subi	r24, 0x01	; 1
    18e0:	fb cf       	rjmp	.-10     	; 0x18d8 <dtoa_prf+0x292>
    18e2:	f7 01       	movw	r30, r14
    18e4:	e2 0f       	add	r30, r18
    18e6:	f1 1d       	adc	r31, r1
    18e8:	10 82       	st	Z, r1
    18ea:	80 e0       	ldi	r24, 0x00	; 0
    18ec:	90 e0       	ldi	r25, 0x00	; 0
    18ee:	29 96       	adiw	r28, 0x09	; 9
    18f0:	ec e0       	ldi	r30, 0x0C	; 12
    18f2:	a7 c1       	rjmp	.+846    	; 0x1c42 <__epilogue_restores__+0xc>

000018f4 <__ftoa_engine>:
    18f4:	28 30       	cpi	r18, 0x08	; 8
    18f6:	08 f0       	brcs	.+2      	; 0x18fa <__ftoa_engine+0x6>
    18f8:	27 e0       	ldi	r18, 0x07	; 7
    18fa:	33 27       	eor	r19, r19
    18fc:	da 01       	movw	r26, r20
    18fe:	99 0f       	add	r25, r25
    1900:	31 1d       	adc	r19, r1
    1902:	87 fd       	sbrc	r24, 7
    1904:	91 60       	ori	r25, 0x01	; 1
    1906:	00 96       	adiw	r24, 0x00	; 0
    1908:	61 05       	cpc	r22, r1
    190a:	71 05       	cpc	r23, r1
    190c:	39 f4       	brne	.+14     	; 0x191c <__ftoa_engine+0x28>
    190e:	32 60       	ori	r19, 0x02	; 2
    1910:	2e 5f       	subi	r18, 0xFE	; 254
    1912:	3d 93       	st	X+, r19
    1914:	30 e3       	ldi	r19, 0x30	; 48
    1916:	2a 95       	dec	r18
    1918:	e1 f7       	brne	.-8      	; 0x1912 <__ftoa_engine+0x1e>
    191a:	08 95       	ret
    191c:	9f 3f       	cpi	r25, 0xFF	; 255
    191e:	30 f0       	brcs	.+12     	; 0x192c <__ftoa_engine+0x38>
    1920:	80 38       	cpi	r24, 0x80	; 128
    1922:	71 05       	cpc	r23, r1
    1924:	61 05       	cpc	r22, r1
    1926:	09 f0       	breq	.+2      	; 0x192a <__ftoa_engine+0x36>
    1928:	3c 5f       	subi	r19, 0xFC	; 252
    192a:	3c 5f       	subi	r19, 0xFC	; 252
    192c:	3d 93       	st	X+, r19
    192e:	91 30       	cpi	r25, 0x01	; 1
    1930:	08 f0       	brcs	.+2      	; 0x1934 <__ftoa_engine+0x40>
    1932:	80 68       	ori	r24, 0x80	; 128
    1934:	91 1d       	adc	r25, r1
    1936:	df 93       	push	r29
    1938:	cf 93       	push	r28
    193a:	1f 93       	push	r17
    193c:	0f 93       	push	r16
    193e:	ff 92       	push	r15
    1940:	ef 92       	push	r14
    1942:	19 2f       	mov	r17, r25
    1944:	98 7f       	andi	r25, 0xF8	; 248
    1946:	96 95       	lsr	r25
    1948:	e9 2f       	mov	r30, r25
    194a:	96 95       	lsr	r25
    194c:	96 95       	lsr	r25
    194e:	e9 0f       	add	r30, r25
    1950:	ff 27       	eor	r31, r31
    1952:	e2 57       	subi	r30, 0x72	; 114
    1954:	ff 4f       	sbci	r31, 0xFF	; 255
    1956:	99 27       	eor	r25, r25
    1958:	33 27       	eor	r19, r19
    195a:	ee 24       	eor	r14, r14
    195c:	ff 24       	eor	r15, r15
    195e:	a7 01       	movw	r20, r14
    1960:	e7 01       	movw	r28, r14
    1962:	05 90       	lpm	r0, Z+
    1964:	08 94       	sec
    1966:	07 94       	ror	r0
    1968:	28 f4       	brcc	.+10     	; 0x1974 <__ftoa_engine+0x80>
    196a:	36 0f       	add	r19, r22
    196c:	e7 1e       	adc	r14, r23
    196e:	f8 1e       	adc	r15, r24
    1970:	49 1f       	adc	r20, r25
    1972:	51 1d       	adc	r21, r1
    1974:	66 0f       	add	r22, r22
    1976:	77 1f       	adc	r23, r23
    1978:	88 1f       	adc	r24, r24
    197a:	99 1f       	adc	r25, r25
    197c:	06 94       	lsr	r0
    197e:	a1 f7       	brne	.-24     	; 0x1968 <__ftoa_engine+0x74>
    1980:	05 90       	lpm	r0, Z+
    1982:	07 94       	ror	r0
    1984:	28 f4       	brcc	.+10     	; 0x1990 <__ftoa_engine+0x9c>
    1986:	e7 0e       	add	r14, r23
    1988:	f8 1e       	adc	r15, r24
    198a:	49 1f       	adc	r20, r25
    198c:	56 1f       	adc	r21, r22
    198e:	c1 1d       	adc	r28, r1
    1990:	77 0f       	add	r23, r23
    1992:	88 1f       	adc	r24, r24
    1994:	99 1f       	adc	r25, r25
    1996:	66 1f       	adc	r22, r22
    1998:	06 94       	lsr	r0
    199a:	a1 f7       	brne	.-24     	; 0x1984 <__ftoa_engine+0x90>
    199c:	05 90       	lpm	r0, Z+
    199e:	07 94       	ror	r0
    19a0:	28 f4       	brcc	.+10     	; 0x19ac <__ftoa_engine+0xb8>
    19a2:	f8 0e       	add	r15, r24
    19a4:	49 1f       	adc	r20, r25
    19a6:	56 1f       	adc	r21, r22
    19a8:	c7 1f       	adc	r28, r23
    19aa:	d1 1d       	adc	r29, r1
    19ac:	88 0f       	add	r24, r24
    19ae:	99 1f       	adc	r25, r25
    19b0:	66 1f       	adc	r22, r22
    19b2:	77 1f       	adc	r23, r23
    19b4:	06 94       	lsr	r0
    19b6:	a1 f7       	brne	.-24     	; 0x19a0 <__ftoa_engine+0xac>
    19b8:	05 90       	lpm	r0, Z+
    19ba:	07 94       	ror	r0
    19bc:	20 f4       	brcc	.+8      	; 0x19c6 <__ftoa_engine+0xd2>
    19be:	49 0f       	add	r20, r25
    19c0:	56 1f       	adc	r21, r22
    19c2:	c7 1f       	adc	r28, r23
    19c4:	d8 1f       	adc	r29, r24
    19c6:	99 0f       	add	r25, r25
    19c8:	66 1f       	adc	r22, r22
    19ca:	77 1f       	adc	r23, r23
    19cc:	88 1f       	adc	r24, r24
    19ce:	06 94       	lsr	r0
    19d0:	a9 f7       	brne	.-22     	; 0x19bc <__ftoa_engine+0xc8>
    19d2:	84 91       	lpm	r24, Z
    19d4:	10 95       	com	r17
    19d6:	17 70       	andi	r17, 0x07	; 7
    19d8:	41 f0       	breq	.+16     	; 0x19ea <__ftoa_engine+0xf6>
    19da:	d6 95       	lsr	r29
    19dc:	c7 95       	ror	r28
    19de:	57 95       	ror	r21
    19e0:	47 95       	ror	r20
    19e2:	f7 94       	ror	r15
    19e4:	e7 94       	ror	r14
    19e6:	1a 95       	dec	r17
    19e8:	c1 f7       	brne	.-16     	; 0x19da <__ftoa_engine+0xe6>
    19ea:	e4 e3       	ldi	r30, 0x34	; 52
    19ec:	f0 e0       	ldi	r31, 0x00	; 0
    19ee:	68 94       	set
    19f0:	15 90       	lpm	r1, Z+
    19f2:	15 91       	lpm	r17, Z+
    19f4:	35 91       	lpm	r19, Z+
    19f6:	65 91       	lpm	r22, Z+
    19f8:	95 91       	lpm	r25, Z+
    19fa:	05 90       	lpm	r0, Z+
    19fc:	7f e2       	ldi	r23, 0x2F	; 47
    19fe:	73 95       	inc	r23
    1a00:	e1 18       	sub	r14, r1
    1a02:	f1 0a       	sbc	r15, r17
    1a04:	43 0b       	sbc	r20, r19
    1a06:	56 0b       	sbc	r21, r22
    1a08:	c9 0b       	sbc	r28, r25
    1a0a:	d0 09       	sbc	r29, r0
    1a0c:	c0 f7       	brcc	.-16     	; 0x19fe <__ftoa_engine+0x10a>
    1a0e:	e1 0c       	add	r14, r1
    1a10:	f1 1e       	adc	r15, r17
    1a12:	43 1f       	adc	r20, r19
    1a14:	56 1f       	adc	r21, r22
    1a16:	c9 1f       	adc	r28, r25
    1a18:	d0 1d       	adc	r29, r0
    1a1a:	7e f4       	brtc	.+30     	; 0x1a3a <__ftoa_engine+0x146>
    1a1c:	70 33       	cpi	r23, 0x30	; 48
    1a1e:	11 f4       	brne	.+4      	; 0x1a24 <__ftoa_engine+0x130>
    1a20:	8a 95       	dec	r24
    1a22:	e6 cf       	rjmp	.-52     	; 0x19f0 <__ftoa_engine+0xfc>
    1a24:	e8 94       	clt
    1a26:	01 50       	subi	r16, 0x01	; 1
    1a28:	30 f0       	brcs	.+12     	; 0x1a36 <__ftoa_engine+0x142>
    1a2a:	08 0f       	add	r16, r24
    1a2c:	0a f4       	brpl	.+2      	; 0x1a30 <__ftoa_engine+0x13c>
    1a2e:	00 27       	eor	r16, r16
    1a30:	02 17       	cp	r16, r18
    1a32:	08 f4       	brcc	.+2      	; 0x1a36 <__ftoa_engine+0x142>
    1a34:	20 2f       	mov	r18, r16
    1a36:	23 95       	inc	r18
    1a38:	02 2f       	mov	r16, r18
    1a3a:	7a 33       	cpi	r23, 0x3A	; 58
    1a3c:	28 f0       	brcs	.+10     	; 0x1a48 <__ftoa_engine+0x154>
    1a3e:	79 e3       	ldi	r23, 0x39	; 57
    1a40:	7d 93       	st	X+, r23
    1a42:	2a 95       	dec	r18
    1a44:	e9 f7       	brne	.-6      	; 0x1a40 <__ftoa_engine+0x14c>
    1a46:	10 c0       	rjmp	.+32     	; 0x1a68 <__ftoa_engine+0x174>
    1a48:	7d 93       	st	X+, r23
    1a4a:	2a 95       	dec	r18
    1a4c:	89 f6       	brne	.-94     	; 0x19f0 <__ftoa_engine+0xfc>
    1a4e:	06 94       	lsr	r0
    1a50:	97 95       	ror	r25
    1a52:	67 95       	ror	r22
    1a54:	37 95       	ror	r19
    1a56:	17 95       	ror	r17
    1a58:	17 94       	ror	r1
    1a5a:	e1 18       	sub	r14, r1
    1a5c:	f1 0a       	sbc	r15, r17
    1a5e:	43 0b       	sbc	r20, r19
    1a60:	56 0b       	sbc	r21, r22
    1a62:	c9 0b       	sbc	r28, r25
    1a64:	d0 09       	sbc	r29, r0
    1a66:	98 f0       	brcs	.+38     	; 0x1a8e <__ftoa_engine+0x19a>
    1a68:	23 95       	inc	r18
    1a6a:	7e 91       	ld	r23, -X
    1a6c:	73 95       	inc	r23
    1a6e:	7a 33       	cpi	r23, 0x3A	; 58
    1a70:	08 f0       	brcs	.+2      	; 0x1a74 <__ftoa_engine+0x180>
    1a72:	70 e3       	ldi	r23, 0x30	; 48
    1a74:	7c 93       	st	X, r23
    1a76:	20 13       	cpse	r18, r16
    1a78:	b8 f7       	brcc	.-18     	; 0x1a68 <__ftoa_engine+0x174>
    1a7a:	7e 91       	ld	r23, -X
    1a7c:	70 61       	ori	r23, 0x10	; 16
    1a7e:	7d 93       	st	X+, r23
    1a80:	30 f0       	brcs	.+12     	; 0x1a8e <__ftoa_engine+0x19a>
    1a82:	83 95       	inc	r24
    1a84:	71 e3       	ldi	r23, 0x31	; 49
    1a86:	7d 93       	st	X+, r23
    1a88:	70 e3       	ldi	r23, 0x30	; 48
    1a8a:	2a 95       	dec	r18
    1a8c:	e1 f7       	brne	.-8      	; 0x1a86 <__ftoa_engine+0x192>
    1a8e:	11 24       	eor	r1, r1
    1a90:	ef 90       	pop	r14
    1a92:	ff 90       	pop	r15
    1a94:	0f 91       	pop	r16
    1a96:	1f 91       	pop	r17
    1a98:	cf 91       	pop	r28
    1a9a:	df 91       	pop	r29
    1a9c:	99 27       	eor	r25, r25
    1a9e:	87 fd       	sbrc	r24, 7
    1aa0:	90 95       	com	r25
    1aa2:	08 95       	ret

00001aa4 <strnlen_P>:
    1aa4:	fc 01       	movw	r30, r24
    1aa6:	05 90       	lpm	r0, Z+
    1aa8:	61 50       	subi	r22, 0x01	; 1
    1aaa:	70 40       	sbci	r23, 0x00	; 0
    1aac:	01 10       	cpse	r0, r1
    1aae:	d8 f7       	brcc	.-10     	; 0x1aa6 <strnlen_P+0x2>
    1ab0:	80 95       	com	r24
    1ab2:	90 95       	com	r25
    1ab4:	8e 0f       	add	r24, r30
    1ab6:	9f 1f       	adc	r25, r31
    1ab8:	08 95       	ret

00001aba <strnlen>:
    1aba:	fc 01       	movw	r30, r24
    1abc:	61 50       	subi	r22, 0x01	; 1
    1abe:	70 40       	sbci	r23, 0x00	; 0
    1ac0:	01 90       	ld	r0, Z+
    1ac2:	01 10       	cpse	r0, r1
    1ac4:	d8 f7       	brcc	.-10     	; 0x1abc <strnlen+0x2>
    1ac6:	80 95       	com	r24
    1ac8:	90 95       	com	r25
    1aca:	8e 0f       	add	r24, r30
    1acc:	9f 1f       	adc	r25, r31
    1ace:	08 95       	ret

00001ad0 <fputc>:
    1ad0:	0f 93       	push	r16
    1ad2:	1f 93       	push	r17
    1ad4:	cf 93       	push	r28
    1ad6:	df 93       	push	r29
    1ad8:	fb 01       	movw	r30, r22
    1ada:	23 81       	ldd	r18, Z+3	; 0x03
    1adc:	21 fd       	sbrc	r18, 1
    1ade:	03 c0       	rjmp	.+6      	; 0x1ae6 <fputc+0x16>
    1ae0:	8f ef       	ldi	r24, 0xFF	; 255
    1ae2:	9f ef       	ldi	r25, 0xFF	; 255
    1ae4:	2c c0       	rjmp	.+88     	; 0x1b3e <fputc+0x6e>
    1ae6:	22 ff       	sbrs	r18, 2
    1ae8:	16 c0       	rjmp	.+44     	; 0x1b16 <fputc+0x46>
    1aea:	46 81       	ldd	r20, Z+6	; 0x06
    1aec:	57 81       	ldd	r21, Z+7	; 0x07
    1aee:	24 81       	ldd	r18, Z+4	; 0x04
    1af0:	35 81       	ldd	r19, Z+5	; 0x05
    1af2:	42 17       	cp	r20, r18
    1af4:	53 07       	cpc	r21, r19
    1af6:	44 f4       	brge	.+16     	; 0x1b08 <fputc+0x38>
    1af8:	a0 81       	ld	r26, Z
    1afa:	b1 81       	ldd	r27, Z+1	; 0x01
    1afc:	9d 01       	movw	r18, r26
    1afe:	2f 5f       	subi	r18, 0xFF	; 255
    1b00:	3f 4f       	sbci	r19, 0xFF	; 255
    1b02:	20 83       	st	Z, r18
    1b04:	31 83       	std	Z+1, r19	; 0x01
    1b06:	8c 93       	st	X, r24
    1b08:	26 81       	ldd	r18, Z+6	; 0x06
    1b0a:	37 81       	ldd	r19, Z+7	; 0x07
    1b0c:	2f 5f       	subi	r18, 0xFF	; 255
    1b0e:	3f 4f       	sbci	r19, 0xFF	; 255
    1b10:	26 83       	std	Z+6, r18	; 0x06
    1b12:	37 83       	std	Z+7, r19	; 0x07
    1b14:	14 c0       	rjmp	.+40     	; 0x1b3e <fputc+0x6e>
    1b16:	8b 01       	movw	r16, r22
    1b18:	ec 01       	movw	r28, r24
    1b1a:	fb 01       	movw	r30, r22
    1b1c:	00 84       	ldd	r0, Z+8	; 0x08
    1b1e:	f1 85       	ldd	r31, Z+9	; 0x09
    1b20:	e0 2d       	mov	r30, r0
    1b22:	09 95       	icall
    1b24:	89 2b       	or	r24, r25
    1b26:	e1 f6       	brne	.-72     	; 0x1ae0 <fputc+0x10>
    1b28:	d8 01       	movw	r26, r16
    1b2a:	16 96       	adiw	r26, 0x06	; 6
    1b2c:	8d 91       	ld	r24, X+
    1b2e:	9c 91       	ld	r25, X
    1b30:	17 97       	sbiw	r26, 0x07	; 7
    1b32:	01 96       	adiw	r24, 0x01	; 1
    1b34:	16 96       	adiw	r26, 0x06	; 6
    1b36:	8d 93       	st	X+, r24
    1b38:	9c 93       	st	X, r25
    1b3a:	17 97       	sbiw	r26, 0x07	; 7
    1b3c:	ce 01       	movw	r24, r28
    1b3e:	df 91       	pop	r29
    1b40:	cf 91       	pop	r28
    1b42:	1f 91       	pop	r17
    1b44:	0f 91       	pop	r16
    1b46:	08 95       	ret

00001b48 <__ultoa_invert>:
    1b48:	fa 01       	movw	r30, r20
    1b4a:	aa 27       	eor	r26, r26
    1b4c:	28 30       	cpi	r18, 0x08	; 8
    1b4e:	51 f1       	breq	.+84     	; 0x1ba4 <__ultoa_invert+0x5c>
    1b50:	20 31       	cpi	r18, 0x10	; 16
    1b52:	81 f1       	breq	.+96     	; 0x1bb4 <__ultoa_invert+0x6c>
    1b54:	e8 94       	clt
    1b56:	6f 93       	push	r22
    1b58:	6e 7f       	andi	r22, 0xFE	; 254
    1b5a:	6e 5f       	subi	r22, 0xFE	; 254
    1b5c:	7f 4f       	sbci	r23, 0xFF	; 255
    1b5e:	8f 4f       	sbci	r24, 0xFF	; 255
    1b60:	9f 4f       	sbci	r25, 0xFF	; 255
    1b62:	af 4f       	sbci	r26, 0xFF	; 255
    1b64:	b1 e0       	ldi	r27, 0x01	; 1
    1b66:	3e d0       	rcall	.+124    	; 0x1be4 <__ultoa_invert+0x9c>
    1b68:	b4 e0       	ldi	r27, 0x04	; 4
    1b6a:	3c d0       	rcall	.+120    	; 0x1be4 <__ultoa_invert+0x9c>
    1b6c:	67 0f       	add	r22, r23
    1b6e:	78 1f       	adc	r23, r24
    1b70:	89 1f       	adc	r24, r25
    1b72:	9a 1f       	adc	r25, r26
    1b74:	a1 1d       	adc	r26, r1
    1b76:	68 0f       	add	r22, r24
    1b78:	79 1f       	adc	r23, r25
    1b7a:	8a 1f       	adc	r24, r26
    1b7c:	91 1d       	adc	r25, r1
    1b7e:	a1 1d       	adc	r26, r1
    1b80:	6a 0f       	add	r22, r26
    1b82:	71 1d       	adc	r23, r1
    1b84:	81 1d       	adc	r24, r1
    1b86:	91 1d       	adc	r25, r1
    1b88:	a1 1d       	adc	r26, r1
    1b8a:	20 d0       	rcall	.+64     	; 0x1bcc <__ultoa_invert+0x84>
    1b8c:	09 f4       	brne	.+2      	; 0x1b90 <__ultoa_invert+0x48>
    1b8e:	68 94       	set
    1b90:	3f 91       	pop	r19
    1b92:	2a e0       	ldi	r18, 0x0A	; 10
    1b94:	26 9f       	mul	r18, r22
    1b96:	11 24       	eor	r1, r1
    1b98:	30 19       	sub	r19, r0
    1b9a:	30 5d       	subi	r19, 0xD0	; 208
    1b9c:	31 93       	st	Z+, r19
    1b9e:	de f6       	brtc	.-74     	; 0x1b56 <__ultoa_invert+0xe>
    1ba0:	cf 01       	movw	r24, r30
    1ba2:	08 95       	ret
    1ba4:	46 2f       	mov	r20, r22
    1ba6:	47 70       	andi	r20, 0x07	; 7
    1ba8:	40 5d       	subi	r20, 0xD0	; 208
    1baa:	41 93       	st	Z+, r20
    1bac:	b3 e0       	ldi	r27, 0x03	; 3
    1bae:	0f d0       	rcall	.+30     	; 0x1bce <__ultoa_invert+0x86>
    1bb0:	c9 f7       	brne	.-14     	; 0x1ba4 <__ultoa_invert+0x5c>
    1bb2:	f6 cf       	rjmp	.-20     	; 0x1ba0 <__ultoa_invert+0x58>
    1bb4:	46 2f       	mov	r20, r22
    1bb6:	4f 70       	andi	r20, 0x0F	; 15
    1bb8:	40 5d       	subi	r20, 0xD0	; 208
    1bba:	4a 33       	cpi	r20, 0x3A	; 58
    1bbc:	18 f0       	brcs	.+6      	; 0x1bc4 <__ultoa_invert+0x7c>
    1bbe:	49 5d       	subi	r20, 0xD9	; 217
    1bc0:	31 fd       	sbrc	r19, 1
    1bc2:	40 52       	subi	r20, 0x20	; 32
    1bc4:	41 93       	st	Z+, r20
    1bc6:	02 d0       	rcall	.+4      	; 0x1bcc <__ultoa_invert+0x84>
    1bc8:	a9 f7       	brne	.-22     	; 0x1bb4 <__ultoa_invert+0x6c>
    1bca:	ea cf       	rjmp	.-44     	; 0x1ba0 <__ultoa_invert+0x58>
    1bcc:	b4 e0       	ldi	r27, 0x04	; 4
    1bce:	a6 95       	lsr	r26
    1bd0:	97 95       	ror	r25
    1bd2:	87 95       	ror	r24
    1bd4:	77 95       	ror	r23
    1bd6:	67 95       	ror	r22
    1bd8:	ba 95       	dec	r27
    1bda:	c9 f7       	brne	.-14     	; 0x1bce <__ultoa_invert+0x86>
    1bdc:	00 97       	sbiw	r24, 0x00	; 0
    1bde:	61 05       	cpc	r22, r1
    1be0:	71 05       	cpc	r23, r1
    1be2:	08 95       	ret
    1be4:	9b 01       	movw	r18, r22
    1be6:	ac 01       	movw	r20, r24
    1be8:	0a 2e       	mov	r0, r26
    1bea:	06 94       	lsr	r0
    1bec:	57 95       	ror	r21
    1bee:	47 95       	ror	r20
    1bf0:	37 95       	ror	r19
    1bf2:	27 95       	ror	r18
    1bf4:	ba 95       	dec	r27
    1bf6:	c9 f7       	brne	.-14     	; 0x1bea <__ultoa_invert+0xa2>
    1bf8:	62 0f       	add	r22, r18
    1bfa:	73 1f       	adc	r23, r19
    1bfc:	84 1f       	adc	r24, r20
    1bfe:	95 1f       	adc	r25, r21
    1c00:	a0 1d       	adc	r26, r0
    1c02:	08 95       	ret

00001c04 <__prologue_saves__>:
    1c04:	2f 92       	push	r2
    1c06:	3f 92       	push	r3
    1c08:	4f 92       	push	r4
    1c0a:	5f 92       	push	r5
    1c0c:	6f 92       	push	r6
    1c0e:	7f 92       	push	r7
    1c10:	8f 92       	push	r8
    1c12:	9f 92       	push	r9
    1c14:	af 92       	push	r10
    1c16:	bf 92       	push	r11
    1c18:	cf 92       	push	r12
    1c1a:	df 92       	push	r13
    1c1c:	ef 92       	push	r14
    1c1e:	ff 92       	push	r15
    1c20:	0f 93       	push	r16
    1c22:	1f 93       	push	r17
    1c24:	cf 93       	push	r28
    1c26:	df 93       	push	r29
    1c28:	cd b7       	in	r28, 0x3d	; 61
    1c2a:	de b7       	in	r29, 0x3e	; 62
    1c2c:	ca 1b       	sub	r28, r26
    1c2e:	db 0b       	sbc	r29, r27
    1c30:	cd bf       	out	0x3d, r28	; 61
    1c32:	de bf       	out	0x3e, r29	; 62
    1c34:	09 94       	ijmp

00001c36 <__epilogue_restores__>:
    1c36:	2a 88       	ldd	r2, Y+18	; 0x12
    1c38:	39 88       	ldd	r3, Y+17	; 0x11
    1c3a:	48 88       	ldd	r4, Y+16	; 0x10
    1c3c:	5f 84       	ldd	r5, Y+15	; 0x0f
    1c3e:	6e 84       	ldd	r6, Y+14	; 0x0e
    1c40:	7d 84       	ldd	r7, Y+13	; 0x0d
    1c42:	8c 84       	ldd	r8, Y+12	; 0x0c
    1c44:	9b 84       	ldd	r9, Y+11	; 0x0b
    1c46:	aa 84       	ldd	r10, Y+10	; 0x0a
    1c48:	b9 84       	ldd	r11, Y+9	; 0x09
    1c4a:	c8 84       	ldd	r12, Y+8	; 0x08
    1c4c:	df 80       	ldd	r13, Y+7	; 0x07
    1c4e:	ee 80       	ldd	r14, Y+6	; 0x06
    1c50:	fd 80       	ldd	r15, Y+5	; 0x05
    1c52:	0c 81       	ldd	r16, Y+4	; 0x04
    1c54:	1b 81       	ldd	r17, Y+3	; 0x03
    1c56:	aa 81       	ldd	r26, Y+2	; 0x02
    1c58:	b9 81       	ldd	r27, Y+1	; 0x01
    1c5a:	ce 0f       	add	r28, r30
    1c5c:	d1 1d       	adc	r29, r1
    1c5e:	cd bf       	out	0x3d, r28	; 61
    1c60:	de bf       	out	0x3e, r29	; 62
    1c62:	ed 01       	movw	r28, r26
    1c64:	08 95       	ret

00001c66 <_exit>:
    1c66:	f8 94       	cli

00001c68 <__stop_program>:
    1c68:	ff cf       	rjmp	.-2      	; 0x1c68 <__stop_program>
