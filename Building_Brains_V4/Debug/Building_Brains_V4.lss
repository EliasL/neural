
Building_Brains_V4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000e  00803e00  000014bc  00001550  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000014bc  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000050  00803e0e  00803e0e  0000155e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000155e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001590  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000420  00000000  00000000  000015d0  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000700a  00000000  00000000  000019f0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002dd1  00000000  00000000  000089fa  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000023bd  00000000  00000000  0000b7cb  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000794  00000000  00000000  0000db88  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002cfb  00000000  00000000  0000e31c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000153d  00000000  00000000  00011017  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000280  00000000  00000000  00012554  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	2d c0       	rjmp	.+90     	; 0x5c <__ctors_end>
       2:	47 c0       	rjmp	.+142    	; 0x92 <__bad_interrupt>
       4:	46 c0       	rjmp	.+140    	; 0x92 <__bad_interrupt>
       6:	45 c0       	rjmp	.+138    	; 0x92 <__bad_interrupt>
       8:	44 c0       	rjmp	.+136    	; 0x92 <__bad_interrupt>
       a:	43 c0       	rjmp	.+134    	; 0x92 <__bad_interrupt>
       c:	64 c5       	rjmp	.+2760   	; 0xad6 <__vector_6>
       e:	41 c0       	rjmp	.+130    	; 0x92 <__bad_interrupt>
      10:	40 c0       	rjmp	.+128    	; 0x92 <__bad_interrupt>
      12:	3f c0       	rjmp	.+126    	; 0x92 <__bad_interrupt>
      14:	3e c0       	rjmp	.+124    	; 0x92 <__bad_interrupt>
      16:	3d c0       	rjmp	.+122    	; 0x92 <__bad_interrupt>
      18:	3c c0       	rjmp	.+120    	; 0x92 <__bad_interrupt>
      1a:	3b c0       	rjmp	.+118    	; 0x92 <__bad_interrupt>
      1c:	3a c0       	rjmp	.+116    	; 0x92 <__bad_interrupt>
      1e:	39 c0       	rjmp	.+114    	; 0x92 <__bad_interrupt>
      20:	38 c0       	rjmp	.+112    	; 0x92 <__bad_interrupt>
      22:	37 c0       	rjmp	.+110    	; 0x92 <__bad_interrupt>
      24:	36 c0       	rjmp	.+108    	; 0x92 <__bad_interrupt>
      26:	35 c0       	rjmp	.+106    	; 0x92 <__bad_interrupt>
      28:	34 c0       	rjmp	.+104    	; 0x92 <__bad_interrupt>
      2a:	33 c0       	rjmp	.+102    	; 0x92 <__bad_interrupt>
      2c:	32 c0       	rjmp	.+100    	; 0x92 <__bad_interrupt>
      2e:	31 c0       	rjmp	.+98     	; 0x92 <__bad_interrupt>
      30:	30 c0       	rjmp	.+96     	; 0x92 <__bad_interrupt>
      32:	2f c0       	rjmp	.+94     	; 0x92 <__bad_interrupt>
      34:	07 63       	ori	r16, 0x37	; 55
      36:	42 36       	cpi	r20, 0x62	; 98
      38:	b7 9b       	sbis	0x16, 7	; 22
      3a:	d8 a7       	std	Y+40, r29	; 0x28
      3c:	1a 39       	cpi	r17, 0x9A	; 154
      3e:	68 56       	subi	r22, 0x68	; 104
      40:	18 ae       	std	Y+56, r1	; 0x38
      42:	ba ab       	std	Y+50, r27	; 0x32
      44:	55 8c       	ldd	r5, Z+29	; 0x1d
      46:	1d 3c       	cpi	r17, 0xCD	; 205
      48:	b7 cc       	rjmp	.-1682   	; 0xfffff9b8 <__eeprom_end+0xff7ef9b8>
      4a:	57 63       	ori	r21, 0x37	; 55
      4c:	bd 6d       	ori	r27, 0xDD	; 221
      4e:	ed fd       	.word	0xfded	; ????
      50:	75 3e       	cpi	r23, 0xE5	; 229
      52:	f6 17       	cp	r31, r22
      54:	72 31       	cpi	r23, 0x12	; 18
      56:	bf 00       	.word	0x00bf	; ????
      58:	00 00       	nop
      5a:	80 3f       	cpi	r24, 0xF0	; 240

0000005c <__ctors_end>:
      5c:	11 24       	eor	r1, r1
      5e:	1f be       	out	0x3f, r1	; 63
      60:	cf ef       	ldi	r28, 0xFF	; 255
      62:	cd bf       	out	0x3d, r28	; 61
      64:	df e3       	ldi	r29, 0x3F	; 63
      66:	de bf       	out	0x3e, r29	; 62

00000068 <__do_copy_data>:
      68:	1e e3       	ldi	r17, 0x3E	; 62
      6a:	a0 e0       	ldi	r26, 0x00	; 0
      6c:	be e3       	ldi	r27, 0x3E	; 62
      6e:	ec eb       	ldi	r30, 0xBC	; 188
      70:	f4 e1       	ldi	r31, 0x14	; 20
      72:	02 c0       	rjmp	.+4      	; 0x78 <__do_copy_data+0x10>
      74:	05 90       	lpm	r0, Z+
      76:	0d 92       	st	X+, r0
      78:	ae 30       	cpi	r26, 0x0E	; 14
      7a:	b1 07       	cpc	r27, r17
      7c:	d9 f7       	brne	.-10     	; 0x74 <__do_copy_data+0xc>

0000007e <__do_clear_bss>:
      7e:	2e e3       	ldi	r18, 0x3E	; 62
      80:	ae e0       	ldi	r26, 0x0E	; 14
      82:	be e3       	ldi	r27, 0x3E	; 62
      84:	01 c0       	rjmp	.+2      	; 0x88 <.do_clear_bss_start>

00000086 <.do_clear_bss_loop>:
      86:	1d 92       	st	X+, r1

00000088 <.do_clear_bss_start>:
      88:	ae 35       	cpi	r26, 0x5E	; 94
      8a:	b2 07       	cpc	r27, r18
      8c:	e1 f7       	brne	.-8      	; 0x86 <.do_clear_bss_loop>
      8e:	f3 d1       	rcall	.+998    	; 0x476 <main>
      90:	13 ca       	rjmp	.-3034   	; 0xfffff4b8 <__eeprom_end+0xff7ef4b8>

00000092 <__bad_interrupt>:
      92:	b6 cf       	rjmp	.-148    	; 0x0 <__vectors>

00000094 <atmel_start_init>:
/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
	system_init();
      94:	b8 d0       	rcall	.+368    	; 0x206 <system_init>
      96:	08 95       	ret

00000098 <ADC_init>:
 * \return Conversion result read from the ADC ADC module
 */
adc_result_t ADC_get_conversion_result(void)
{
	return (ADC0.RES);
}
      98:	85 e0       	ldi	r24, 0x05	; 5
      9a:	80 93 00 06 	sts	0x0600, r24	; 0x800600 <__TEXT_REGION_LENGTH__+0x700600>
      9e:	80 e0       	ldi	r24, 0x00	; 0
      a0:	08 95       	ret

000000a2 <ADC_is_conversion_done>:
      a2:	80 91 0b 06 	lds	r24, 0x060B	; 0x80060b <__TEXT_REGION_LENGTH__+0x70060b>
      a6:	81 70       	andi	r24, 0x01	; 1
      a8:	08 95       	ret

000000aa <ADC_get_conversion>:
 *
 * \return Nothing
 */
void ADC_start_conversion(adc_0_channel_t channel)
{
	ADC0.MUXPOS  = channel;
      aa:	e0 e0       	ldi	r30, 0x00	; 0
      ac:	f6 e0       	ldi	r31, 0x06	; 6
      ae:	86 83       	std	Z+6, r24	; 0x06
	ADC0.COMMAND = ADC_STCONV_bm;
      b0:	81 e0       	ldi	r24, 0x01	; 1
      b2:	80 87       	std	Z+8, r24	; 0x08
adc_result_t ADC_get_conversion(adc_0_channel_t channel)
{
	adc_result_t res;

	ADC_start_conversion(channel);
	while (!ADC_is_conversion_done())
      b4:	f6 df       	rcall	.-20     	; 0xa2 <ADC_is_conversion_done>
      b6:	88 23       	and	r24, r24
      b8:	e9 f3       	breq	.-6      	; 0xb4 <ADC_get_conversion+0xa>
 *
 * \return Conversion result read from the ADC ADC module
 */
adc_result_t ADC_get_conversion_result(void)
{
	return (ADC0.RES);
      ba:	e0 e0       	ldi	r30, 0x00	; 0
      bc:	f6 e0       	ldi	r31, 0x06	; 6
      be:	20 89       	ldd	r18, Z+16	; 0x10
      c0:	31 89       	ldd	r19, Z+17	; 0x11

	ADC_start_conversion(channel);
	while (!ADC_is_conversion_done())
		;
	res = ADC_get_conversion_result();
	ADC0.INTFLAGS |= ADC_RESRDY_bm;
      c2:	93 85       	ldd	r25, Z+11	; 0x0b
      c4:	91 60       	ori	r25, 0x01	; 1
      c6:	93 87       	std	Z+11, r25	; 0x0b
	return res;
}
      c8:	c9 01       	movw	r24, r18
      ca:	08 95       	ret

000000cc <BOD_init>:
	//		 | BOD_VLMCFG_ABOVE_gc; /* Interrupt when supply goes above VLM level */

	// BOD.VLMCTRLA = BOD_VLMLVL_5ABOVE_gc; /* VLM threshold 5% above BOD level */

	return 0;
}
      cc:	80 e0       	ldi	r24, 0x00	; 0
      ce:	08 95       	ret

000000d0 <DIGGSIGG_init>:
	//		 | CCL_EDGEDET_DIS_gc /* Edge detector is disabled */
	//		 | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	//		 | 0 << CCL_ENABLE_bp /* LUT Enable: disabled */
	//		 | 0 << CCL_OUTEN_bp; /* Output Enable: disabled */

	CCL.TRUTH1 = 168; /* Truth 1: 168 */
      d0:	e0 ec       	ldi	r30, 0xC0	; 192
      d2:	f1 e0       	ldi	r31, 0x01	; 1
      d4:	88 ea       	ldi	r24, 0xA8	; 168
      d6:	84 87       	std	Z+12, r24	; 0x0c

	CCL.LUT1CTRLC = CCL_INSEL2_TCA0_gc /* TCA0 WO2 input source */;
      d8:	88 e0       	ldi	r24, 0x08	; 8
      da:	83 87       	std	Z+11, r24	; 0x0b

	CCL.LUT1CTRLB = CCL_INSEL0_SPI0_gc /* SPI0 SCK source */
      dc:	8b eb       	ldi	r24, 0xBB	; 187
      de:	82 87       	std	Z+10, r24	; 0x0a
	                | CCL_INSEL1_SPI0_gc /* SPI0 MOSI input source */;

	CCL.LUT1CTRLA = 0 << CCL_CLKSRC_bp       /* Clock Source Selection: disabled */
      e0:	89 e0       	ldi	r24, 0x09	; 9
      e2:	81 87       	std	Z+9, r24	; 0x09
	                | CCL_EDGEDET_DIS_gc     /* Edge detector is disabled */
	                | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	                | 1 << CCL_ENABLE_bp     /* LUT Enable: enabled */
	                | 1 << CCL_OUTEN_bp;     /* Output Enable: enabled */

	CCL.CTRLA = 1 << CCL_ENABLE_bp      /* Enable: enabled */
      e4:	81 e4       	ldi	r24, 0x41	; 65
      e6:	80 83       	st	Z, r24
	            | 1 << CCL_RUNSTDBY_bp; /* Run in Standby: enabled */

	return 0;
}
      e8:	80 e0       	ldi	r24, 0x00	; 0
      ea:	08 95       	ret

000000ec <CLKCTRL_init>:
 *       on calling convention. The memory model is not visible to the
 *       preprocessor, so it must be defined in the Assembler preprocessor directives.
 */
static inline void ccp_write_io(void *addr, uint8_t value)
{
	protected_write_io(addr, CCP_IOREG_gc, value);
      ec:	47 e0       	ldi	r20, 0x07	; 7
      ee:	68 ed       	ldi	r22, 0xD8	; 216
      f0:	8c e7       	ldi	r24, 0x7C	; 124
      f2:	90 e0       	ldi	r25, 0x00	; 0
      f4:	a2 d0       	rcall	.+324    	; 0x23a <protected_write_io>
      f6:	41 e0       	ldi	r20, 0x01	; 1
      f8:	68 ed       	ldi	r22, 0xD8	; 216
      fa:	81 e6       	ldi	r24, 0x61	; 97
      fc:	90 e0       	ldi	r25, 0x00	; 0
      fe:	9d d0       	rcall	.+314    	; 0x23a <protected_write_io>
	//		 | 0 << CLKCTRL_CLKOUT_bp /* System clock out: disabled */);

	// ccp_write_io((void*)&(CLKCTRL.MCLKLOCK),0 << CLKCTRL_LOCKEN_bp /* lock enable: disabled */);

	return 0;
}
     100:	80 e0       	ldi	r24, 0x00	; 0
     102:	08 95       	ret

00000104 <CPUINT_init>:

	// CPUINT.LVL0PRI = 0x0 << CPUINT_LVL0PRI_gp; /* Interrupt Level Priority: 0x0 */

	// CPUINT.LVL1VEC = 0x0 << CPUINT_LVL1VEC_gp; /* Interrupt Vector with High Priority: 0x0 */

	ENABLE_INTERRUPTS();
     104:	78 94       	sei

	return 0;
}
     106:	80 e0       	ldi	r24, 0x00	; 0
     108:	08 95       	ret

0000010a <DAC_init>:
 *
 * \return Nothing
 */
void DAC_disable()
{
	DAC0.CTRLA &= ~DAC_ENABLE_bm;
     10a:	81 e4       	ldi	r24, 0x41	; 65
     10c:	80 93 80 06 	sts	0x0680, r24	; 0x800680 <__TEXT_REGION_LENGTH__+0x700680>
     110:	80 e0       	ldi	r24, 0x00	; 0
     112:	08 95       	ret

00000114 <DAC_set_output>:
 *
 * \return Nothing
 */
void DAC_set_output(dac_resolution_t value)
{
	DAC0.DATA = value;
     114:	80 93 81 06 	sts	0x0681, r24	; 0x800681 <__TEXT_REGION_LENGTH__+0x700681>
     118:	08 95       	ret

0000011a <mcu_init>:
#ifdef __cplusplus
extern "C" {
#endif

void mcu_init(void)
{
     11a:	e0 e1       	ldi	r30, 0x10	; 16
     11c:	f4 e0       	ldi	r31, 0x04	; 4
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     11e:	80 81       	ld	r24, Z
     120:	88 60       	ori	r24, 0x08	; 8
     122:	81 93       	st	Z+, r24
	 * disables all peripherals to save power. Driver shall enable
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
     124:	e8 31       	cpi	r30, 0x18	; 24
     126:	84 e0       	ldi	r24, 0x04	; 4
     128:	f8 07       	cpc	r31, r24
     12a:	c9 f7       	brne	.-14     	; 0x11e <mcu_init+0x4>
     12c:	e0 e3       	ldi	r30, 0x30	; 48
     12e:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     130:	80 81       	ld	r24, Z
     132:	88 60       	ori	r24, 0x08	; 8
     134:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     136:	e8 33       	cpi	r30, 0x38	; 56
     138:	84 e0       	ldi	r24, 0x04	; 4
     13a:	f8 07       	cpc	r31, r24
     13c:	c9 f7       	brne	.-14     	; 0x130 <mcu_init+0x16>
     13e:	e0 e5       	ldi	r30, 0x50	; 80
     140:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     142:	80 81       	ld	r24, Z
     144:	88 60       	ori	r24, 0x08	; 8
     146:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     148:	e8 35       	cpi	r30, 0x58	; 88
     14a:	84 e0       	ldi	r24, 0x04	; 4
     14c:	f8 07       	cpc	r31, r24
     14e:	c9 f7       	brne	.-14     	; 0x142 <mcu_init+0x28>
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}
}
     150:	08 95       	ret

00000152 <ADC_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     152:	e5 e1       	ldi	r30, 0x15	; 21
     154:	f4 e0       	ldi	r31, 0x04	; 4
     156:	80 81       	ld	r24, Z
     158:	88 7f       	andi	r24, 0xF8	; 248
     15a:	84 60       	ori	r24, 0x04	; 4
     15c:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     15e:	80 81       	ld	r24, Z
     160:	87 7f       	andi	r24, 0xF7	; 247
     162:	80 83       	st	Z, r24
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     164:	e7 e1       	ldi	r30, 0x17	; 23
     166:	f4 e0       	ldi	r31, 0x04	; 4
     168:	80 81       	ld	r24, Z
     16a:	88 7f       	andi	r24, 0xF8	; 248
     16c:	84 60       	ori	r24, 0x04	; 4
     16e:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     170:	80 81       	ld	r24, Z
     172:	87 7f       	andi	r24, 0xF7	; 247
     174:	80 83       	st	Z, r24
 */
static inline void PORTB_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     176:	e4 e3       	ldi	r30, 0x34	; 52
     178:	f4 e0       	ldi	r31, 0x04	; 4
     17a:	80 81       	ld	r24, Z
     17c:	88 7f       	andi	r24, 0xF8	; 248
     17e:	84 60       	ori	r24, 0x04	; 4
     180:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     182:	80 81       	ld	r24, Z
     184:	87 7f       	andi	r24, 0xF7	; 247
     186:	80 83       	st	Z, r24
 */
static inline void PORTB_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     188:	e1 e3       	ldi	r30, 0x31	; 49
     18a:	f4 e0       	ldi	r31, 0x04	; 4
     18c:	80 81       	ld	r24, Z
     18e:	88 7f       	andi	r24, 0xF8	; 248
     190:	84 60       	ori	r24, 0x04	; 4
     192:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     194:	80 81       	ld	r24, Z
     196:	87 7f       	andi	r24, 0xF7	; 247
     198:	80 83       	st	Z, r24
 */
static inline void PORTB_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     19a:	e0 e3       	ldi	r30, 0x30	; 48
     19c:	f4 e0       	ldi	r31, 0x04	; 4
     19e:	80 81       	ld	r24, Z
     1a0:	88 7f       	andi	r24, 0xF8	; 248
     1a2:	84 60       	ori	r24, 0x04	; 4
     1a4:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     1a6:	80 81       	ld	r24, Z
     1a8:	87 7f       	andi	r24, 0xF7	; 247
     1aa:	80 83       	st	Z, r24
	// Disable digital input buffer
	Dendrite_4_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	Dendrite_4_set_pull_mode(PORT_PULL_OFF);

	ADC_init();
     1ac:	75 df       	rcall	.-278    	; 0x98 <ADC_init>
     1ae:	08 95       	ret

000001b0 <TIMER_0_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     1b0:	25 9a       	sbi	0x04, 5	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     1b2:	2d 98       	cbi	0x05, 5	; 5
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLC |= PORTMUX_TCA02_bm;
     1b4:	e0 e0       	ldi	r30, 0x00	; 0
     1b6:	f2 e0       	ldi	r31, 0x02	; 2
     1b8:	82 81       	ldd	r24, Z+2	; 0x02
     1ba:	84 60       	ori	r24, 0x04	; 4
     1bc:	82 83       	std	Z+2, r24	; 0x02

	TIMER_0_init();
     1be:	eb d0       	rcall	.+470    	; 0x396 <TIMER_0_init>
     1c0:	08 95       	ret

000001c2 <DIGGSIGG_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTC.DIR |= (1 << pin);
     1c2:	41 9a       	sbi	0x08, 1	; 8
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
	} else {
		VPORTC.OUT &= ~(1 << pin);
     1c4:	49 98       	cbi	0x09, 1	; 9
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLA |= PORTMUX_LUT1_bm;
     1c6:	e0 e0       	ldi	r30, 0x00	; 0
     1c8:	f2 e0       	ldi	r31, 0x02	; 2
     1ca:	80 81       	ld	r24, Z
     1cc:	80 62       	ori	r24, 0x20	; 32
     1ce:	80 83       	st	Z, r24

	DIGGSIGG_init();
     1d0:	7f df       	rcall	.-258    	; 0xd0 <DIGGSIGG_init>
     1d2:	08 95       	ret

000001d4 <SPI_0_initialization>:
 */
static inline void PORTA_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
     1d4:	02 98       	cbi	0x00, 2	; 0
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     1d6:	e2 e1       	ldi	r30, 0x12	; 18
     1d8:	f4 e0       	ldi	r31, 0x04	; 4
     1da:	80 81       	ld	r24, Z
     1dc:	87 7f       	andi	r24, 0xF7	; 247
     1de:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     1e0:	01 9a       	sbi	0x00, 1	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     1e2:	09 98       	cbi	0x01, 1	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     1e4:	03 9a       	sbi	0x00, 3	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     1e6:	0b 98       	cbi	0x01, 3	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     1e8:	04 9a       	sbi	0x00, 4	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     1ea:	0c 98       	cbi	0x01, 4	; 1
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	SPI_0_init();
     1ec:	cc d0       	rcall	.+408    	; 0x386 <SPI_0_init>
     1ee:	08 95       	ret

000001f0 <DAC_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     1f0:	e6 e1       	ldi	r30, 0x16	; 22
     1f2:	f4 e0       	ldi	r31, 0x04	; 4
     1f4:	80 81       	ld	r24, Z
     1f6:	88 7f       	andi	r24, 0xF8	; 248
     1f8:	84 60       	ori	r24, 0x04	; 4
     1fa:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     1fc:	80 81       	ld	r24, Z
     1fe:	87 7f       	andi	r24, 0xF7	; 247
     200:	80 83       	st	Z, r24
	// Disable digital input buffer
	Axon_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	Axon_set_pull_mode(PORT_PULL_OFF);

	DAC_init();
     202:	83 df       	rcall	.-250    	; 0x10a <DAC_init>
     204:	08 95       	ret

00000206 <system_init>:
/**
 * \brief System initialization
 */
void system_init()
{
	mcu_init();
     206:	89 df       	rcall	.-238    	; 0x11a <mcu_init>
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     208:	27 98       	cbi	0x04, 7	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     20a:	e7 e3       	ldi	r30, 0x37	; 55
     20c:	f4 e0       	ldi	r31, 0x04	; 4
     20e:	80 81       	ld	r24, Z
     210:	87 7f       	andi	r24, 0xF7	; 247
     212:	80 83       	st	Z, r24
 */
static inline void PORTC_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
     214:	42 98       	cbi	0x08, 2	; 8
static inline void PORTC_set_pin_pull_mode(const uint8_t pin, const enum port_pull_mode pull_mode)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
     216:	e2 e5       	ldi	r30, 0x52	; 82
     218:	f4 e0       	ldi	r31, 0x04	; 4
     21a:	80 81       	ld	r24, Z
     21c:	88 60       	ori	r24, 0x08	; 8
     21e:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTC.DIR |= (1 << pin);
     220:	45 9a       	sbi	0x08, 5	; 8
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     222:	4d 9a       	sbi	0x09, 5	; 9
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    true);

	CLKCTRL_init();
     224:	63 df       	rcall	.-314    	; 0xec <CLKCTRL_init>

	RTC_init();
     226:	93 d0       	rcall	.+294    	; 0x34e <RTC_init>

	ADC_initialization();
     228:	94 df       	rcall	.-216    	; 0x152 <ADC_initialization>

	TIMER_0_initialization();
     22a:	c2 df       	rcall	.-124    	; 0x1b0 <TIMER_0_initialization>

	DIGGSIGG_initialization();
     22c:	ca df       	rcall	.-108    	; 0x1c2 <DIGGSIGG_initialization>

	SPI_0_initialization();
     22e:	d2 df       	rcall	.-92     	; 0x1d4 <SPI_0_initialization>

	DAC_initialization();
     230:	df df       	rcall	.-66     	; 0x1f0 <DAC_initialization>

	CPUINT_init();
     232:	68 df       	rcall	.-304    	; 0x104 <CPUINT_init>

	SLPCTRL_init();
     234:	a6 d0       	rcall	.+332    	; 0x382 <SLPCTRL_init>

	BOD_init();
     236:	4a df       	rcall	.-364    	; 0xcc <BOD_init>
     238:	08 95       	ret

0000023a <protected_write_io>:
#if defined(__GNUC__)
  
#ifdef RAMPZ
	out     _SFR_IO_ADDR(RAMPZ), r1         // Clear bits 23:16 of Z
#endif
	movw    r30, r24                // Load addr into Z
     23a:	fc 01       	movw	r30, r24
	out     CCP, r22                // Start CCP handshake
     23c:	64 bf       	out	0x34, r22	; 52
	st      Z, r20                  // Write value to I/O register
     23e:	40 83       	st	Z, r20
	ret                             // Return to caller
     240:	08 95       	ret

00000242 <enqueue>:
 */ 
#include <stdio.h>
#include <stdlib.h>
#include "include/queue.h"

void enqueue(node_t **head, uint32_t val) {
     242:	cf 92       	push	r12
     244:	df 92       	push	r13
     246:	ef 92       	push	r14
     248:	ff 92       	push	r15
     24a:	cf 93       	push	r28
     24c:	df 93       	push	r29
     24e:	ec 01       	movw	r28, r24
     250:	6a 01       	movw	r12, r20
     252:	7b 01       	movw	r14, r22
	// remember, head is at the very BACK of the queue (The element that will wait the longest until dequeued)
	
	// we create a new empty node
	node_t *new_node = malloc(sizeof(node_t));
     254:	86 e0       	ldi	r24, 0x06	; 6
     256:	90 e0       	ldi	r25, 0x00	; 0
     258:	0e d8       	rcall	.-4068   	; 0xfffff276 <__eeprom_end+0xff7ef276>
	// Not quite sure what happens here, but it seems to be some sort of error handling, except you never know if there has been an error :/
	if (!new_node) return;
     25a:	00 97       	sbiw	r24, 0x00	; 0
     25c:	59 f0       	breq	.+22     	; 0x274 <enqueue+0x32>

	// we configure our node
	new_node->val = val;
     25e:	fc 01       	movw	r30, r24
     260:	c0 82       	st	Z, r12
     262:	d1 82       	std	Z+1, r13	; 0x01
     264:	e2 82       	std	Z+2, r14	; 0x02
     266:	f3 82       	std	Z+3, r15	; 0x03
	new_node->next = *head;
     268:	28 81       	ld	r18, Y
     26a:	39 81       	ldd	r19, Y+1	; 0x01
     26c:	24 83       	std	Z+4, r18	; 0x04
     26e:	35 83       	std	Z+5, r19	; 0x05

	// and lastly, we change the pointer pointing to the previous head node, to point to our new node instead
	*head = new_node;
     270:	88 83       	st	Y, r24
     272:	99 83       	std	Y+1, r25	; 0x01
}
     274:	df 91       	pop	r29
     276:	cf 91       	pop	r28
     278:	ff 90       	pop	r15
     27a:	ef 90       	pop	r14
     27c:	df 90       	pop	r13
     27e:	cf 90       	pop	r12
     280:	08 95       	ret

00000282 <dequeue>:

uint32_t dequeue(node_t **head) {
     282:	cf 92       	push	r12
     284:	df 92       	push	r13
     286:	ef 92       	push	r14
     288:	ff 92       	push	r15
     28a:	0f 93       	push	r16
     28c:	1f 93       	push	r17
     28e:	cf 93       	push	r28
     290:	df 93       	push	r29
	node_t *current, *prev = NULL;
	uint32_t retval = 0;

	// If the queue we have been given is empty, we return an error
	// (0 is usually not an error, but it is probably the best option)
	if (*head == NULL) return 0;
     292:	dc 01       	movw	r26, r24
     294:	ed 91       	ld	r30, X+
     296:	fc 91       	ld	r31, X
     298:	30 97       	sbiw	r30, 0x00	; 0
     29a:	11 f1       	breq	.+68     	; 0x2e0 <dequeue+0x5e>
     29c:	c0 e0       	ldi	r28, 0x00	; 0
     29e:	d0 e0       	ldi	r29, 0x00	; 0
     2a0:	02 c0       	rjmp	.+4      	; 0x2a6 <dequeue+0x24>
     2a2:	ef 01       	movw	r28, r30

	// Now we iterate through the queue until we reach the end
	current = *head;
	while (current->next != NULL) {
		prev = current;
		current = current->next;
     2a4:	f9 01       	movw	r30, r18
	// (0 is usually not an error, but it is probably the best option)
	if (*head == NULL) return 0;

	// Now we iterate through the queue until we reach the end
	current = *head;
	while (current->next != NULL) {
     2a6:	24 81       	ldd	r18, Z+4	; 0x04
     2a8:	35 81       	ldd	r19, Z+5	; 0x05
     2aa:	21 15       	cp	r18, r1
     2ac:	31 05       	cpc	r19, r1
     2ae:	c9 f7       	brne	.-14     	; 0x2a2 <dequeue+0x20>
     2b0:	8c 01       	movw	r16, r24
		prev = current;
		current = current->next;
	}

	// We retrieve the value we needed
	retval = current->val;
     2b2:	c0 80       	ld	r12, Z
     2b4:	d1 80       	ldd	r13, Z+1	; 0x01
     2b6:	e2 80       	ldd	r14, Z+2	; 0x02
     2b8:	f3 80       	ldd	r15, Z+3	; 0x03
	// and remove the last element of the queue from the queue
	free(current);
     2ba:	cf 01       	movw	r24, r30
     2bc:	74 d8       	rcall	.-3864   	; 0xfffff3a6 <__eeprom_end+0xff7ef3a6>
	
	// Now we update the previous node so that it becomes the front of the queue
	// In case the queue only had one element, the prev will be null (false)
	if (prev){
     2be:	20 97       	sbiw	r28, 0x00	; 0
     2c0:	39 f0       	breq	.+14     	; 0x2d0 <dequeue+0x4e>
	prev->next = NULL;}
     2c2:	1c 82       	std	Y+4, r1	; 0x04
     2c4:	1d 82       	std	Y+5, r1	; 0x05
	else{
	*head = NULL;}

	return retval;
     2c6:	6c 2d       	mov	r22, r12
     2c8:	7d 2d       	mov	r23, r13
     2ca:	8e 2d       	mov	r24, r14
     2cc:	9f 2d       	mov	r25, r15
     2ce:	0c c0       	rjmp	.+24     	; 0x2e8 <dequeue+0x66>
	// Now we update the previous node so that it becomes the front of the queue
	// In case the queue only had one element, the prev will be null (false)
	if (prev){
	prev->next = NULL;}
	else{
	*head = NULL;}
     2d0:	f8 01       	movw	r30, r16
     2d2:	10 82       	st	Z, r1
     2d4:	11 82       	std	Z+1, r1	; 0x01

	return retval;
     2d6:	6c 2d       	mov	r22, r12
     2d8:	7d 2d       	mov	r23, r13
     2da:	8e 2d       	mov	r24, r14
     2dc:	9f 2d       	mov	r25, r15
     2de:	04 c0       	rjmp	.+8      	; 0x2e8 <dequeue+0x66>
	node_t *current, *prev = NULL;
	uint32_t retval = 0;

	// If the queue we have been given is empty, we return an error
	// (0 is usually not an error, but it is probably the best option)
	if (*head == NULL) return 0;
     2e0:	60 e0       	ldi	r22, 0x00	; 0
     2e2:	70 e0       	ldi	r23, 0x00	; 0
     2e4:	80 e0       	ldi	r24, 0x00	; 0
     2e6:	90 e0       	ldi	r25, 0x00	; 0
	prev->next = NULL;}
	else{
	*head = NULL;}

	return retval;
}
     2e8:	df 91       	pop	r29
     2ea:	cf 91       	pop	r28
     2ec:	1f 91       	pop	r17
     2ee:	0f 91       	pop	r16
     2f0:	ff 90       	pop	r15
     2f2:	ef 90       	pop	r14
     2f4:	df 90       	pop	r13
     2f6:	cf 90       	pop	r12
     2f8:	08 95       	ret

000002fa <dequeue_top>:

// Here we remove the element of the queue that was added last (first in, last out)
uint32_t dequeue_top(node_t **head){
     2fa:	cf 92       	push	r12
     2fc:	df 92       	push	r13
     2fe:	ef 92       	push	r14
     300:	ff 92       	push	r15
     302:	0f 93       	push	r16
     304:	1f 93       	push	r17
     306:	cf 93       	push	r28
     308:	df 93       	push	r29
	node_t *oldHead;
	uint32_t retval = 0;
	
	// If the queue we have been given is empty, we return an error
	// (0 is usually not an error, but it is probably the best option)
	if (*head == NULL) return 0;
     30a:	dc 01       	movw	r26, r24
     30c:	ed 91       	ld	r30, X+
     30e:	fc 91       	ld	r31, X
     310:	30 97       	sbiw	r30, 0x00	; 0
     312:	81 f0       	breq	.+32     	; 0x334 <dequeue_top+0x3a>
     314:	ec 01       	movw	r28, r24
	
	oldHead = *head;
	// We then set the new head to be the second last in the queue
	newHead = oldHead->next;
     316:	c4 80       	ldd	r12, Z+4	; 0x04
     318:	d5 80       	ldd	r13, Z+5	; 0x05
	
	// We retrieve the heads value
	retval = oldHead->val;
     31a:	e0 80       	ld	r14, Z
     31c:	f1 80       	ldd	r15, Z+1	; 0x01
     31e:	02 81       	ldd	r16, Z+2	; 0x02
     320:	13 81       	ldd	r17, Z+3	; 0x03
	
	// We free the memory that was used to store the old head
	free(oldHead);
     322:	cf 01       	movw	r24, r30
     324:	40 d8       	rcall	.-3968   	; 0xfffff3a6 <__eeprom_end+0xff7ef3a6>
	
	//And then we overwrite the value of head to be the second last
	*head = newHead;
     326:	c8 82       	st	Y, r12
     328:	d9 82       	std	Y+1, r13	; 0x01
	
	return retval;
     32a:	6e 2d       	mov	r22, r14
     32c:	7f 2d       	mov	r23, r15
     32e:	80 2f       	mov	r24, r16
     330:	91 2f       	mov	r25, r17
     332:	04 c0       	rjmp	.+8      	; 0x33c <dequeue_top+0x42>
	node_t *oldHead;
	uint32_t retval = 0;
	
	// If the queue we have been given is empty, we return an error
	// (0 is usually not an error, but it is probably the best option)
	if (*head == NULL) return 0;
     334:	60 e0       	ldi	r22, 0x00	; 0
     336:	70 e0       	ldi	r23, 0x00	; 0
     338:	80 e0       	ldi	r24, 0x00	; 0
     33a:	90 e0       	ldi	r25, 0x00	; 0
	//And then we overwrite the value of head to be the second last
	*head = newHead;
	
	return retval;
	
}
     33c:	df 91       	pop	r29
     33e:	cf 91       	pop	r28
     340:	1f 91       	pop	r17
     342:	0f 91       	pop	r16
     344:	ff 90       	pop	r15
     346:	ef 90       	pop	r14
     348:	df 90       	pop	r13
     34a:	cf 90       	pop	r12
     34c:	08 95       	ret

0000034e <RTC_init>:
 * \return Initialization status.
 */
int8_t RTC_init()
{

	while (RTC.STATUS > 0) { /* Wait for all register to be synchronized */
     34e:	e0 e4       	ldi	r30, 0x40	; 64
     350:	f1 e0       	ldi	r31, 0x01	; 1
     352:	81 81       	ldd	r24, Z+1	; 0x01
     354:	81 11       	cpse	r24, r1
     356:	fd cf       	rjmp	.-6      	; 0x352 <RTC_init+0x4>
	}

	// RTC.CMP = 0x0; /* Compare: 0x0 */

	RTC.CNT = 0x20; /* Counter: 0x20 */
     358:	e0 e4       	ldi	r30, 0x40	; 64
     35a:	f1 e0       	ldi	r31, 0x01	; 1
     35c:	80 e2       	ldi	r24, 0x20	; 32
     35e:	90 e0       	ldi	r25, 0x00	; 0
     360:	80 87       	std	Z+8, r24	; 0x08
     362:	91 87       	std	Z+9, r25	; 0x09

	RTC.CTRLA = RTC_PRESCALER_DIV1_gc   /* 1 */
     364:	21 e8       	ldi	r18, 0x81	; 129
     366:	20 83       	st	Z, r18
	            | 1 << RTC_RTCEN_bp     /* Enable: enabled */
	            | 1 << RTC_RUNSTDBY_bp; /* Run In Standby: enabled */

	RTC.PER = 0x20; /* Period: 0x20 */
     368:	82 87       	std	Z+10, r24	; 0x0a
     36a:	93 87       	std	Z+11, r25	; 0x0b

	// RTC.CLKSEL = RTC_CLKSEL_INT32K_gc; /* 32KHz Internal Ultra Low Power Oscillator (OSCULP32K) */

	RTC.DBGCTRL = 1 << RTC_DBGRUN_bp; /* Run in debug: enabled */
     36c:	81 e0       	ldi	r24, 0x01	; 1
     36e:	85 83       	std	Z+5, r24	; 0x05

	RTC.INTCTRL = 0 << RTC_CMP_bp    /* Compare Match Interrupt enable: disabled */
     370:	82 83       	std	Z+2, r24	; 0x02
	              | 1 << RTC_OVF_bp; /* Overflow Interrupt enable: enabled */

	while (RTC.PITSTATUS > 0) { /* Wait for all register to be synchronized */
     372:	81 89       	ldd	r24, Z+17	; 0x11
     374:	81 11       	cpse	r24, r1
     376:	fd cf       	rjmp	.-6      	; 0x372 <RTC_init+0x24>
	}

	RTC.PITCTRLA = RTC_PERIOD_OFF_gc    /* Off */
     378:	81 e0       	ldi	r24, 0x01	; 1
     37a:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <__TEXT_REGION_LENGTH__+0x700150>
	// RTC.PITDBGCTRL = 0 << RTC_DBGRUN_bp; /* Run in debug: disabled */

	// RTC.PITINTCTRL = 0 << RTC_PI_bp; /* Periodic Interrupt: disabled */

	return 0;
}
     37e:	80 e0       	ldi	r24, 0x00	; 0
     380:	08 95       	ret

00000382 <SLPCTRL_init>:

	// SLPCTRL.CTRLA = 0 << SLPCTRL_SEN_bp /* Sleep enable: disabled */
	//		 | SLPCTRL_SMODE_IDLE_gc; /* Idle mode */

	return 0;
}
     382:	80 e0       	ldi	r24, 0x00	; 0
     384:	08 95       	ret

00000386 <SPI_0_init>:
 * \return Initialization status
 */
int8_t SPI_0_init()
{

	SPI0.CTRLA = 0 << SPI_CLK2X_bp     /* Enable Double Speed: disabled */
     386:	e0 e2       	ldi	r30, 0x20	; 32
     388:	f8 e0       	ldi	r31, 0x08	; 8
     38a:	83 e2       	ldi	r24, 0x23	; 35
     38c:	80 83       	st	Z, r24
	             | 0 << SPI_DORD_bp    /* Data Order Setting: disabled */
	             | 1 << SPI_ENABLE_bp  /* Enable Module: enabled */
	             | 1 << SPI_MASTER_bp  /* SPI module in master mode */
	             | SPI_PRESC_DIV16_gc; /* System Clock / 16 */

	SPI0.CTRLB = 0 << SPI_BUFEN_bp   /* Buffer Mode Enable: disabled */
     38e:	84 e0       	ldi	r24, 0x04	; 4
     390:	81 83       	std	Z+1, r24	; 0x01
	//		 | 0 << SPI_RXCIE_bp /* Receive Complete Interrupt Enable: disabled */
	//		 | 0 << SPI_SSIE_bp /* Slave Select Trigger Interrupt Enable: disabled */
	//		 | 0 << SPI_TXCIE_bp; /* Transfer Complete Interrupt Enable: disabled */

	return 0;
}
     392:	80 e0       	ldi	r24, 0x00	; 0
     394:	08 95       	ret

00000396 <TIMER_0_init>:

	// TCA0.SINGLE.CMP0 = 0x0; /* Compare Register 0: 0x0 */

	// TCA0.SINGLE.CMP1 = 0x0; /* Compare Register 1: 0x0 */

	TCA0.SINGLE.CMP2 = 0x4; /* Compare Register 2: 0x4 */
     396:	e0 e0       	ldi	r30, 0x00	; 0
     398:	fa e0       	ldi	r31, 0x0A	; 10
     39a:	84 e0       	ldi	r24, 0x04	; 4
     39c:	90 e0       	ldi	r25, 0x00	; 0
     39e:	84 a7       	std	Z+44, r24	; 0x2c
     3a0:	95 a7       	std	Z+45, r25	; 0x2d

	// TCA0.SINGLE.CNT = 0x0; /* Count: 0x0 */

	TCA0.SINGLE.CTRLB = 0 << TCA_SINGLE_ALUPD_bp            /* Auto Lock Update: disabled */
     3a2:	83 e4       	ldi	r24, 0x43	; 67
     3a4:	81 83       	std	Z+1, r24	; 0x01
	                    | 0 << TCA_SINGLE_CMP0EN_bp         /* Compare 0 Enable: disabled */
	                    | 0 << TCA_SINGLE_CMP1EN_bp         /* Compare 1 Enable: disabled */
	                    | 1 << TCA_SINGLE_CMP2EN_bp         /* Compare 2 Enable: enabled */
	                    | TCA_SINGLE_WGMODE_SINGLESLOPE_gc; /*  */

	TCA0.SINGLE.CTRLC = 0 << TCA_SINGLE_CMP0OV_bp    /* Compare 0 Waveform Output Value: disabled */
     3a6:	84 e0       	ldi	r24, 0x04	; 4
     3a8:	82 83       	std	Z+2, r24	; 0x02
	// TCA0.SINGLE.INTCTRL = 0 << TCA_SINGLE_CMP0_bp /* Compare 0 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP1_bp /* Compare 1 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP2_bp /* Compare 2 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_OVF_bp; /* Overflow Interrupt: disabled */

	TCA0.SINGLE.PER = 0x7; /* Period: 0x7 */
     3aa:	87 e0       	ldi	r24, 0x07	; 7
     3ac:	90 e0       	ldi	r25, 0x00	; 0
     3ae:	86 a3       	std	Z+38, r24	; 0x26
     3b0:	97 a3       	std	Z+39, r25	; 0x27

	// TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV1_gc /* System Clock */
	//		 | 0 << TCA_SINGLE_ENABLE_bp; /* Module Enable: disabled */

	return 0;
}
     3b2:	80 e0       	ldi	r24, 0x00	; 0
     3b4:	08 95       	ret

000003b6 <tinyCharge_is_charging>:

_Bool charging;

_Bool tinyCharge_is_charging(){
	return charging;
}
     3b6:	80 91 55 3e 	lds	r24, 0x3E55	; 0x803e55 <charging>
     3ba:	08 95       	ret

000003bc <tinyCharge_set_charging>:

void tinyCharge_set_charging(_Bool charging_status){
	charging = charging_status;
     3bc:	80 93 55 3e 	sts	0x3E55, r24	; 0x803e55 <charging>
	} else {
		VPORTC.OUT &= ~(1 << pin);
     3c0:	4d 98       	cbi	0x09, 5	; 9
     3c2:	08 95       	ret

000003c4 <tinyPulse_toggle_pulse_mode>:
uint32_t time_of_last_pulse = 0;
uint16_t time_since_last_pulse = 0;
uint16_t ideal_time_between_pulses = 1000/PULSEMODE_FREQUENCY;

void tinyPulse_toggle_pulse_mode(){
	pulse_mode = !pulse_mode;
     3c4:	90 91 14 3e 	lds	r25, 0x3E14	; 0x803e14 <pulse_mode>
     3c8:	81 e0       	ldi	r24, 0x01	; 1
     3ca:	89 27       	eor	r24, r25
     3cc:	80 93 14 3e 	sts	0x3E14, r24	; 0x803e14 <pulse_mode>
     3d0:	08 95       	ret

000003d2 <tinyPulse_update_potential>:
}

double tinyPulse_update_potential(double potential){
     3d2:	cf 92       	push	r12
     3d4:	df 92       	push	r13
     3d6:	ef 92       	push	r14
     3d8:	ff 92       	push	r15
     3da:	6b 01       	movw	r12, r22
     3dc:	7c 01       	movw	r14, r24
	if(pulse_mode){
     3de:	80 91 14 3e 	lds	r24, 0x3E14	; 0x803e14 <pulse_mode>
     3e2:	88 23       	and	r24, r24
     3e4:	21 f1       	breq	.+72     	; 0x42e <__LOCK_REGION_LENGTH__+0x2e>
		
		time_since_last_pulse = tinyTime_now() - time_of_last_pulse;
     3e6:	3e d0       	rcall	.+124    	; 0x464 <tinyTime_now>
     3e8:	20 91 10 3e 	lds	r18, 0x3E10	; 0x803e10 <time_of_last_pulse>
     3ec:	30 91 11 3e 	lds	r19, 0x3E11	; 0x803e11 <time_of_last_pulse+0x1>
     3f0:	62 1b       	sub	r22, r18
     3f2:	73 0b       	sbc	r23, r19
     3f4:	60 93 0e 3e 	sts	0x3E0E, r22	; 0x803e0e <__data_end>
     3f8:	70 93 0f 3e 	sts	0x3E0F, r23	; 0x803e0f <__data_end+0x1>
		
		if(time_since_last_pulse >= ideal_time_between_pulses){
     3fc:	80 91 06 3e 	lds	r24, 0x3E06	; 0x803e06 <ideal_time_between_pulses>
     400:	90 91 07 3e 	lds	r25, 0x3E07	; 0x803e07 <ideal_time_between_pulses+0x1>
     404:	68 17       	cp	r22, r24
     406:	79 07       	cpc	r23, r25
     408:	90 f0       	brcs	.+36     	; 0x42e <__LOCK_REGION_LENGTH__+0x2e>
			potential += BUTTON_PRESS_REACTION;
     40a:	20 e0       	ldi	r18, 0x00	; 0
     40c:	30 e0       	ldi	r19, 0x00	; 0
     40e:	40 ed       	ldi	r20, 0xD0	; 208
     410:	51 e4       	ldi	r21, 0x41	; 65
     412:	c7 01       	movw	r24, r14
     414:	b6 01       	movw	r22, r12
     416:	ce d3       	rcall	.+1948   	; 0xbb4 <__addsf3>
     418:	6b 01       	movw	r12, r22
     41a:	7c 01       	movw	r14, r24
			time_of_last_pulse = tinyTime_now();			
     41c:	23 d0       	rcall	.+70     	; 0x464 <tinyTime_now>
     41e:	60 93 10 3e 	sts	0x3E10, r22	; 0x803e10 <time_of_last_pulse>
     422:	70 93 11 3e 	sts	0x3E11, r23	; 0x803e11 <time_of_last_pulse+0x1>
     426:	80 93 12 3e 	sts	0x3E12, r24	; 0x803e12 <time_of_last_pulse+0x2>
     42a:	90 93 13 3e 	sts	0x3E13, r25	; 0x803e13 <time_of_last_pulse+0x3>
		}
	}
	return potential;
}
     42e:	c7 01       	movw	r24, r14
     430:	b6 01       	movw	r22, r12
     432:	ff 90       	pop	r15
     434:	ef 90       	pop	r14
     436:	df 90       	pop	r13
     438:	cf 90       	pop	r12
     43a:	08 95       	ret

0000043c <tinyTime_counter_increment>:
If the Interrupt Service Routine is clocked by a crystal oscillator
it gives a very precise timer-counter.
*/
void tinyTime_counter_increment(void)
{
	time_counter++;
     43c:	80 91 15 3e 	lds	r24, 0x3E15	; 0x803e15 <time_counter>
     440:	90 91 16 3e 	lds	r25, 0x3E16	; 0x803e16 <time_counter+0x1>
     444:	a0 91 17 3e 	lds	r26, 0x3E17	; 0x803e17 <time_counter+0x2>
     448:	b0 91 18 3e 	lds	r27, 0x3E18	; 0x803e18 <time_counter+0x3>
     44c:	01 96       	adiw	r24, 0x01	; 1
     44e:	a1 1d       	adc	r26, r1
     450:	b1 1d       	adc	r27, r1
     452:	80 93 15 3e 	sts	0x3E15, r24	; 0x803e15 <time_counter>
     456:	90 93 16 3e 	sts	0x3E16, r25	; 0x803e16 <time_counter+0x1>
     45a:	a0 93 17 3e 	sts	0x3E17, r26	; 0x803e17 <time_counter+0x2>
     45e:	b0 93 18 3e 	sts	0x3E18, r27	; 0x803e18 <time_counter+0x3>
     462:	08 95       	ret

00000464 <tinyTime_now>:
/*
This function is callable by external libraries to give them the counted time so far.
*/
uint32_t tinyTime_now(void)
{
	return time_counter;
     464:	60 91 15 3e 	lds	r22, 0x3E15	; 0x803e15 <time_counter>
     468:	70 91 16 3e 	lds	r23, 0x3E16	; 0x803e16 <time_counter+0x1>
     46c:	80 91 17 3e 	lds	r24, 0x3E17	; 0x803e17 <time_counter+0x2>
     470:	90 91 18 3e 	lds	r25, 0x3E18	; 0x803e18 <time_counter+0x3>
     474:	08 95       	ret

00000476 <main>:
you need to comment out, or remove the code in driver_isr.c in order to avoid creating multiple definitions of __vector_6
*/


int main(void)
{	
     476:	cf 93       	push	r28
     478:	df 93       	push	r29
     47a:	00 d0       	rcall	.+0      	; 0x47c <main+0x6>
     47c:	cd b7       	in	r28, 0x3d	; 61
     47e:	de b7       	in	r29, 0x3e	; 62
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
     480:	09 de       	rcall	.-1006   	; 0x94 <atmel_start_init>
	Setting this value will mean that the ADC (Analog to Digital Converter) will read 4.32v as 255, and 0v as 0.
	For some reason, instead of the reference voltage being 4.32v, it is 3.3v. 
	A plausible explanation is that the microchip does not up the voltage, so that if the microchip is only ever 
	supplied with 3.3v, it will output 3.3v as the max.
	*/
	VREF.CTRLB = VREF_ADC0REFSEL_4V34_gc;
     482:	80 e3       	ldi	r24, 0x30	; 48
     484:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
	
	
	uint32_t current_cycle_time = 1;
	uint32_t previous_cycle_time = 0;
	uint16_t time_passed = 0;
	uint16_t volatile cycles=0;
     488:	19 82       	std	Y+1, r1	; 0x01
     48a:	1a 82       	std	Y+2, r1	; 0x02
	
	tinyDendriteite_set_neuron_type(NEURONTYPE);
     48c:	80 e0       	ldi	r24, 0x00	; 0
     48e:	4f d1       	rcall	.+670    	; 0x72e <tinyDendriteite_set_neuron_type>
	*/
	VREF.CTRLB = VREF_ADC0REFSEL_4V34_gc;
	
	
	uint32_t current_cycle_time = 1;
	uint32_t previous_cycle_time = 0;
     490:	81 2c       	mov	r8, r1
     492:	91 2c       	mov	r9, r1
     494:	54 01       	movw	r10, r8
	
	tinyDendriteite_set_neuron_type(NEURONTYPE);
	
	while (1)
	{
		if(tinyISR_getflag())
     496:	4c d3       	rcall	.+1688   	; 0xb30 <tinyISR_getflag>
     498:	88 23       	and	r24, r24
     49a:	e9 f3       	breq	.-6      	; 0x496 <main+0x20>
		{
			// update cycle time
			current_cycle_time = tinyTime_now();
     49c:	e3 df       	rcall	.-58     	; 0x464 <tinyTime_now>
     49e:	6b 01       	movw	r12, r22
     4a0:	7c 01       	movw	r14, r24
			
			
			if(tinyCharge_is_charging()){
     4a2:	89 df       	rcall	.-238    	; 0x3b6 <tinyCharge_is_charging>
     4a4:	88 23       	and	r24, r24
     4a6:	11 f0       	breq	.+4      	; 0x4ac <main+0x36>
				// Charge loop
				
				// We check the Dendriteites in order to detect if we have stopped charging
				tinyDendriteite_update_signals();
     4a8:	31 d2       	rcall	.+1122   	; 0x90c <tinyDendriteite_update_signals>
     4aa:	08 c0       	rjmp	.+16     	; 0x4bc <main+0x46>
				
			}
			else{
				// Main loop
				
				tinyButton_update();
     4ac:	b1 d0       	rcall	.+354    	; 0x610 <tinyButton_update>
				
				time_passed = current_cycle_time - previous_cycle_time;
				tinyPotential_update(time_passed);
     4ae:	b6 01       	movw	r22, r12
     4b0:	68 19       	sub	r22, r8
     4b2:	79 09       	sbc	r23, r9
     4b4:	80 e0       	ldi	r24, 0x00	; 0
     4b6:	90 e0       	ldi	r25, 0x00	; 0
     4b8:	d0 d4       	rcall	.+2464   	; 0xe5a <__floatunsisf>
     4ba:	3d d3       	rcall	.+1658   	; 0xb36 <tinyPotential_update>
			}
			
			
			
			previous_cycle_time = current_cycle_time;
			cycles++;
     4bc:	89 81       	ldd	r24, Y+1	; 0x01
     4be:	9a 81       	ldd	r25, Y+2	; 0x02
     4c0:	01 96       	adiw	r24, 0x01	; 1
     4c2:	89 83       	std	Y+1, r24	; 0x01
     4c4:	9a 83       	std	Y+2, r25	; 0x02
			tinyISR_setflag(false);
     4c6:	80 e0       	ldi	r24, 0x00	; 0
     4c8:	30 d3       	rcall	.+1632   	; 0xb2a <tinyISR_setflag>
				tinyPotential_update(time_passed);
			}
			
			
			
			previous_cycle_time = current_cycle_time;
     4ca:	46 01       	movw	r8, r12
     4cc:	57 01       	movw	r10, r14
     4ce:	e3 cf       	rjmp	.-58     	; 0x496 <main+0x20>

000004d0 <set_LED_fire>:



//function to be called upon when firing flag has been raised.
void set_LED_fire(void)
{
     4d0:	cf 93       	push	r28
	fire_flash_time_counter = tinyTime_now();
     4d2:	c8 df       	rcall	.-112    	; 0x464 <tinyTime_now>
     4d4:	60 93 19 3e 	sts	0x3E19, r22	; 0x803e19 <fire_flash_time_counter>
     4d8:	70 93 1a 3e 	sts	0x3E1A, r23	; 0x803e1a <fire_flash_time_counter+0x1>
     4dc:	80 93 1b 3e 	sts	0x3E1B, r24	; 0x803e1b <fire_flash_time_counter+0x2>
     4e0:	90 93 1c 3e 	sts	0x3E1C, r25	; 0x803e1c <fire_flash_time_counter+0x3>
     4e4:	c0 e0       	ldi	r28, 0x00	; 0
	for (int i = 0; i < NUMBER_OF_LEDS; i++)
	{
		tinyCCLRGB_setColor(i, MAX_BRIGHTNESS, MAX_BRIGHTNESS, MAX_BRIGHTNESS);//As per the specs, all LEDs should be blue while firing.
     4e6:	20 e3       	ldi	r18, 0x30	; 48
     4e8:	40 e3       	ldi	r20, 0x30	; 48
     4ea:	60 e3       	ldi	r22, 0x30	; 48
     4ec:	8c 2f       	mov	r24, r28
     4ee:	fb d0       	rcall	.+502    	; 0x6e6 <tinyCCLRGB_setColor>
     4f0:	cf 5f       	subi	r28, 0xFF	; 255

//function to be called upon when firing flag has been raised.
void set_LED_fire(void)
{
	fire_flash_time_counter = tinyTime_now();
	for (int i = 0; i < NUMBER_OF_LEDS; i++)
     4f2:	c6 30       	cpi	r28, 0x06	; 6
     4f4:	c1 f7       	brne	.-16     	; 0x4e6 <set_LED_fire+0x16>
	{
		tinyCCLRGB_setColor(i, MAX_BRIGHTNESS, MAX_BRIGHTNESS, MAX_BRIGHTNESS);//As per the specs, all LEDs should be blue while firing.
	}
}
     4f6:	cf 91       	pop	r28
     4f8:	08 95       	ret

000004fa <potential_to_RGB_update_LEDs>:



void potential_to_RGB_update_LEDs(double potential)
{
     4fa:	8f 92       	push	r8
     4fc:	9f 92       	push	r9
     4fe:	af 92       	push	r10
     500:	bf 92       	push	r11
     502:	cf 92       	push	r12
     504:	df 92       	push	r13
     506:	ef 92       	push	r14
     508:	ff 92       	push	r15
     50a:	0f 93       	push	r16
     50c:	1f 93       	push	r17
     50e:	cf 93       	push	r28
     510:	6b 01       	movw	r12, r22
     512:	7c 01       	movw	r14, r24
	if ((tinyTime_now() - fire_flash_time_counter) < FIRE_FLASH_TIME)
     514:	a7 df       	rcall	.-178    	; 0x464 <tinyTime_now>
     516:	00 91 19 3e 	lds	r16, 0x3E19	; 0x803e19 <fire_flash_time_counter>
     51a:	10 91 1a 3e 	lds	r17, 0x3E1A	; 0x803e1a <fire_flash_time_counter+0x1>
     51e:	20 91 1b 3e 	lds	r18, 0x3E1B	; 0x803e1b <fire_flash_time_counter+0x2>
     522:	30 91 1c 3e 	lds	r19, 0x3E1C	; 0x803e1c <fire_flash_time_counter+0x3>
     526:	dc 01       	movw	r26, r24
     528:	cb 01       	movw	r24, r22
     52a:	80 1b       	sub	r24, r16
     52c:	91 0b       	sbc	r25, r17
     52e:	a2 0b       	sbc	r26, r18
     530:	b3 0b       	sbc	r27, r19
     532:	84 36       	cpi	r24, 0x64	; 100
     534:	91 05       	cpc	r25, r1
     536:	a1 05       	cpc	r26, r1
     538:	b1 05       	cpc	r27, r1
     53a:	50 f4       	brcc	.+20     	; 0x550 <potential_to_RGB_update_LEDs+0x56>
     53c:	c0 e0       	ldi	r28, 0x00	; 0
	{
		for (int i = 0; i < NUMBER_OF_LEDS; i++)
		{
			tinyCCLRGB_setColor(i, MAX_BRIGHTNESS, MAX_BRIGHTNESS, MAX_BRIGHTNESS);
     53e:	20 e3       	ldi	r18, 0x30	; 48
     540:	40 e3       	ldi	r20, 0x30	; 48
     542:	60 e3       	ldi	r22, 0x30	; 48
     544:	8c 2f       	mov	r24, r28
     546:	cf d0       	rcall	.+414    	; 0x6e6 <tinyCCLRGB_setColor>
     548:	cf 5f       	subi	r28, 0xFF	; 255

void potential_to_RGB_update_LEDs(double potential)
{
	if ((tinyTime_now() - fire_flash_time_counter) < FIRE_FLASH_TIME)
	{
		for (int i = 0; i < NUMBER_OF_LEDS; i++)
     54a:	c6 30       	cpi	r28, 0x06	; 6
     54c:	c1 f7       	brne	.-16     	; 0x53e <potential_to_RGB_update_LEDs+0x44>
     54e:	53 c0       	rjmp	.+166    	; 0x5f6 <potential_to_RGB_update_LEDs+0xfc>
     550:	c0 e0       	ldi	r28, 0x00	; 0
*/
static void potential_to_RGB_set_color(double potential)
{
	for (int i = 0; i < NUMBER_OF_LEDS; i++)
	{
		tinyCCLRGB_setColor(i, 0x0, 0x0, 0x0);//Clear all LED stored values on the MCU before writing again.
     552:	20 e0       	ldi	r18, 0x00	; 0
     554:	40 e0       	ldi	r20, 0x00	; 0
     556:	60 e0       	ldi	r22, 0x00	; 0
     558:	8c 2f       	mov	r24, r28
     55a:	c5 d0       	rcall	.+394    	; 0x6e6 <tinyCCLRGB_setColor>
     55c:	cf 5f       	subi	r28, 0xFF	; 255
When firing all lights turn blue for ~100ms, but this needs to be tested.
LEDs are numbered right way on top of PCB, but opposite way on bottom of PCB.
*/
static void potential_to_RGB_set_color(double potential)
{
	for (int i = 0; i < NUMBER_OF_LEDS; i++)
     55e:	c6 30       	cpi	r28, 0x06	; 6
     560:	c1 f7       	brne	.-16     	; 0x552 <potential_to_RGB_update_LEDs+0x58>
	{
		tinyCCLRGB_setColor(i, 0x0, 0x0, 0x0);//Clear all LED stored values on the MCU before writing again.
	}
	double absolute_potential = abs(potential);//setting variable for absolute potential so it won't have to be calculated more than once.
     562:	c7 01       	movw	r24, r14
     564:	b6 01       	movw	r22, r12
     566:	43 d4       	rcall	.+2182   	; 0xdee <__fixsfsi>
     568:	9b 01       	movw	r18, r22
     56a:	77 23       	and	r23, r23
     56c:	24 f4       	brge	.+8      	; 0x576 <potential_to_RGB_update_LEDs+0x7c>
     56e:	22 27       	eor	r18, r18
     570:	33 27       	eor	r19, r19
     572:	26 1b       	sub	r18, r22
     574:	37 0b       	sbc	r19, r23
     576:	b9 01       	movw	r22, r18
     578:	33 0f       	add	r19, r19
     57a:	88 0b       	sbc	r24, r24
     57c:	99 0b       	sbc	r25, r25
     57e:	6f d4       	rcall	.+2270   	; 0xe5e <__floatsisf>
     580:	4b 01       	movw	r8, r22
     582:	5c 01       	movw	r10, r24
	if (absolute_potential < 1)//set the middle lights as white both top side and bottom side.
     584:	20 e0       	ldi	r18, 0x00	; 0
     586:	30 e0       	ldi	r19, 0x00	; 0
     588:	40 e8       	ldi	r20, 0x80	; 128
     58a:	5f e3       	ldi	r21, 0x3F	; 63
     58c:	7f d3       	rcall	.+1790   	; 0xc8c <__cmpsf2>
     58e:	88 23       	and	r24, r24
     590:	34 f4       	brge	.+12     	; 0x59e <potential_to_RGB_update_LEDs+0xa4>
	{
		tinyCCLRGB_setColor(2, MAX_BRIGHTNESS/3, MAX_BRIGHTNESS/3, MAX_BRIGHTNESS/3);
     592:	20 e1       	ldi	r18, 0x10	; 16
     594:	40 e1       	ldi	r20, 0x10	; 16
     596:	60 e1       	ldi	r22, 0x10	; 16
     598:	82 e0       	ldi	r24, 0x02	; 2
     59a:	a5 d0       	rcall	.+330    	; 0x6e6 <tinyCCLRGB_setColor>
     59c:	2c c0       	rjmp	.+88     	; 0x5f6 <potential_to_RGB_update_LEDs+0xfc>
		//tinyCCLRGB_setColor(4, max_brightness/3, max_brightness/3, max_brightness/3);
	}
	else
	{
		uint8_t brightness_intensity = round((absolute_potential/25)*MAX_BRIGHTNESS);//brightness intensity for the LED that shows potential.
     59e:	20 e0       	ldi	r18, 0x00	; 0
     5a0:	30 e0       	ldi	r19, 0x00	; 0
     5a2:	48 ec       	ldi	r20, 0xC8	; 200
     5a4:	51 e4       	ldi	r21, 0x41	; 65
     5a6:	c5 01       	movw	r24, r10
     5a8:	b4 01       	movw	r22, r8
     5aa:	75 d3       	rcall	.+1770   	; 0xc96 <__divsf3>
     5ac:	20 e0       	ldi	r18, 0x00	; 0
     5ae:	30 e0       	ldi	r19, 0x00	; 0
     5b0:	40 e4       	ldi	r20, 0x40	; 64
     5b2:	52 e4       	ldi	r21, 0x42	; 66
     5b4:	a6 d5       	rcall	.+2892   	; 0x1102 <__mulsf3>
     5b6:	12 d6       	rcall	.+3108   	; 0x11dc <round>
     5b8:	21 d4       	rcall	.+2114   	; 0xdfc <__fixunssfsi>
     5ba:	c6 2f       	mov	r28, r22
		if (potential < 0)
     5bc:	20 e0       	ldi	r18, 0x00	; 0
     5be:	30 e0       	ldi	r19, 0x00	; 0
     5c0:	a9 01       	movw	r20, r18
     5c2:	c7 01       	movw	r24, r14
     5c4:	b6 01       	movw	r22, r12
     5c6:	62 d3       	rcall	.+1732   	; 0xc8c <__cmpsf2>
     5c8:	88 23       	and	r24, r24
     5ca:	5c f4       	brge	.+22     	; 0x5e2 <potential_to_RGB_update_LEDs+0xe8>
		{
			tinyCCLRGB_setColor(0, brightness_intensity, 0x0, 0x0);
     5cc:	20 e0       	ldi	r18, 0x00	; 0
     5ce:	40 e0       	ldi	r20, 0x00	; 0
     5d0:	6c 2f       	mov	r22, r28
     5d2:	80 e0       	ldi	r24, 0x00	; 0
     5d4:	88 d0       	rcall	.+272    	; 0x6e6 <tinyCCLRGB_setColor>
			tinyCCLRGB_setColor(1, brightness_intensity, 0x0, 0x0);//sets lower LEDs red if potential is negative.
     5d6:	20 e0       	ldi	r18, 0x00	; 0
     5d8:	40 e0       	ldi	r20, 0x00	; 0
     5da:	6c 2f       	mov	r22, r28
     5dc:	81 e0       	ldi	r24, 0x01	; 1
     5de:	83 d0       	rcall	.+262    	; 0x6e6 <tinyCCLRGB_setColor>
     5e0:	0a c0       	rjmp	.+20     	; 0x5f6 <potential_to_RGB_update_LEDs+0xfc>
		} 
		else
		{
			tinyCCLRGB_setColor(3, 0x0, brightness_intensity, 0x0);//sets upper LEDs green if potential is positive.
     5e2:	20 e0       	ldi	r18, 0x00	; 0
     5e4:	4c 2f       	mov	r20, r28
     5e6:	60 e0       	ldi	r22, 0x00	; 0
     5e8:	83 e0       	ldi	r24, 0x03	; 3
     5ea:	7d d0       	rcall	.+250    	; 0x6e6 <tinyCCLRGB_setColor>
			tinyCCLRGB_setColor(4, 0x0, brightness_intensity, 0x0);
     5ec:	20 e0       	ldi	r18, 0x00	; 0
     5ee:	4c 2f       	mov	r20, r28
     5f0:	60 e0       	ldi	r22, 0x00	; 0
     5f2:	84 e0       	ldi	r24, 0x04	; 4
     5f4:	78 d0       	rcall	.+240    	; 0x6e6 <tinyCCLRGB_setColor>
	}
	else
	{
		potential_to_RGB_set_color(potential);
	}
	tinyCCLRGB_uploadColorsToLeds();
     5f6:	84 d0       	rcall	.+264    	; 0x700 <tinyCCLRGB_uploadColorsToLeds>
}
     5f8:	cf 91       	pop	r28
     5fa:	1f 91       	pop	r17
     5fc:	0f 91       	pop	r16
     5fe:	ff 90       	pop	r15
     600:	ef 90       	pop	r14
     602:	df 90       	pop	r13
     604:	cf 90       	pop	r12
     606:	bf 90       	pop	r11
     608:	af 90       	pop	r10
     60a:	9f 90       	pop	r9
     60c:	8f 90       	pop	r8
     60e:	08 95       	ret

00000610 <tinyButton_update>:
/*
If the button has been let go, we change button_press to true. This only lasts one cycle, before it is set to false again.
If the button is held down for longer than PULSEMODE_BUTTON_PRESS_TIME, we toggle the pulse mode state.
*/
void tinyButton_update(void)
{
     610:	0f 93       	push	r16
     612:	1f 93       	push	r17
     614:	cf 93       	push	r28
     616:	df 93       	push	r29
	button_press = false;
     618:	10 92 21 3e 	sts	0x3E21, r1	; 0x803e21 <button_press>
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTC_get_pin_level(const uint8_t pin)
{
	return VPORTC.IN & (1 << pin);
     61c:	8a b1       	in	r24, 0x0a	; 10
	_Bool button_is_pushed_down = !Button_get_level(); // The digital port will be read as low if the button is pushed down.
     61e:	d1 e0       	ldi	r29, 0x01	; 1
     620:	c8 2f       	mov	r28, r24
     622:	c4 70       	andi	r28, 0x04	; 4
     624:	82 fd       	sbrc	r24, 2
     626:	d0 e0       	ldi	r29, 0x00	; 0

	if (button_is_pushed_down && !button_was_pushed_down)
     628:	c1 11       	cpse	r28, r1
     62a:	2f c0       	rjmp	.+94     	; 0x68a <tinyButton_update+0x7a>
     62c:	80 91 22 3e 	lds	r24, 0x3E22	; 0x803e22 <button_was_pushed_down>
     630:	81 11       	cpse	r24, r1
     632:	0d c0       	rjmp	.+26     	; 0x64e <tinyButton_update+0x3e>
	{
		tinyButton_start_time = tinyTime_now();
     634:	17 df       	rcall	.-466    	; 0x464 <tinyTime_now>
     636:	60 93 1d 3e 	sts	0x3E1D, r22	; 0x803e1d <tinyButton_start_time>
     63a:	70 93 1e 3e 	sts	0x3E1E, r23	; 0x803e1e <tinyButton_start_time+0x1>
     63e:	80 93 1f 3e 	sts	0x3E1F, r24	; 0x803e1f <tinyButton_start_time+0x2>
     642:	90 93 20 3e 	sts	0x3E20, r25	; 0x803e20 <tinyButton_start_time+0x3>
	}
	if (button_is_pushed_down && button_was_pushed_down)
     646:	80 91 22 3e 	lds	r24, 0x3E22	; 0x803e22 <button_was_pushed_down>
     64a:	88 23       	and	r24, r24
     64c:	39 f1       	breq	.+78     	; 0x69c <tinyButton_update+0x8c>
	{
		if ((tinyTime_now() - tinyButton_start_time) > PULSEMODE_BUTTON_PRESS_TIME)
     64e:	0a df       	rcall	.-492    	; 0x464 <tinyTime_now>
     650:	00 91 1d 3e 	lds	r16, 0x3E1D	; 0x803e1d <tinyButton_start_time>
     654:	10 91 1e 3e 	lds	r17, 0x3E1E	; 0x803e1e <tinyButton_start_time+0x1>
     658:	20 91 1f 3e 	lds	r18, 0x3E1F	; 0x803e1f <tinyButton_start_time+0x2>
     65c:	30 91 20 3e 	lds	r19, 0x3E20	; 0x803e20 <tinyButton_start_time+0x3>
     660:	dc 01       	movw	r26, r24
     662:	cb 01       	movw	r24, r22
     664:	80 1b       	sub	r24, r16
     666:	91 0b       	sbc	r25, r17
     668:	a2 0b       	sbc	r26, r18
     66a:	b3 0b       	sbc	r27, r19
     66c:	81 3d       	cpi	r24, 0xD1	; 209
     66e:	97 40       	sbci	r25, 0x07	; 7
     670:	a1 05       	cpc	r26, r1
     672:	b1 05       	cpc	r27, r1
     674:	50 f0       	brcs	.+20     	; 0x68a <tinyButton_update+0x7a>
		{
			tinyPulse_toggle_pulse_mode();
     676:	a6 de       	rcall	.-692    	; 0x3c4 <tinyPulse_toggle_pulse_mode>
			tinyButton_start_time = tinyTime_now();
     678:	f5 de       	rcall	.-534    	; 0x464 <tinyTime_now>
     67a:	60 93 1d 3e 	sts	0x3E1D, r22	; 0x803e1d <tinyButton_start_time>
     67e:	70 93 1e 3e 	sts	0x3E1E, r23	; 0x803e1e <tinyButton_start_time+0x1>
     682:	80 93 1f 3e 	sts	0x3E1F, r24	; 0x803e1f <tinyButton_start_time+0x2>
     686:	90 93 20 3e 	sts	0x3E20, r25	; 0x803e20 <tinyButton_start_time+0x3>
		}
	}
	if (!button_is_pushed_down && button_was_pushed_down)
     68a:	cc 23       	and	r28, r28
     68c:	39 f0       	breq	.+14     	; 0x69c <tinyButton_update+0x8c>
     68e:	80 91 22 3e 	lds	r24, 0x3E22	; 0x803e22 <button_was_pushed_down>
     692:	88 23       	and	r24, r24
     694:	19 f0       	breq	.+6      	; 0x69c <tinyButton_update+0x8c>
	{
		button_press = true;
     696:	81 e0       	ldi	r24, 0x01	; 1
     698:	80 93 21 3e 	sts	0x3E21, r24	; 0x803e21 <button_press>
	}
	button_was_pushed_down = button_is_pushed_down;
     69c:	d0 93 22 3e 	sts	0x3E22, r29	; 0x803e22 <button_was_pushed_down>
}
     6a0:	df 91       	pop	r29
     6a2:	cf 91       	pop	r28
     6a4:	1f 91       	pop	r17
     6a6:	0f 91       	pop	r16
     6a8:	08 95       	ret

000006aa <tinyButton_update_potential>:

double tinyButton_update_potential(double potential){
	if(button_press){
     6aa:	20 91 21 3e 	lds	r18, 0x3E21	; 0x803e21 <button_press>
     6ae:	22 23       	and	r18, r18
     6b0:	29 f0       	breq	.+10     	; 0x6bc <tinyButton_update_potential+0x12>
		potential += BUTTON_PRESS_REACTION;
     6b2:	20 e0       	ldi	r18, 0x00	; 0
     6b4:	30 e0       	ldi	r19, 0x00	; 0
     6b6:	40 ed       	ldi	r20, 0xD0	; 208
     6b8:	51 e4       	ldi	r21, 0x41	; 65
     6ba:	7c d2       	rcall	.+1272   	; 0xbb4 <__addsf3>
	}
	return potential;
}
     6bc:	08 95       	ret

000006be <tinyCCLRGB_SPIWriteByte>:
Function used to send a byte over SPI, which in turn gets
translated to the bit-sequence required by the LEDs over the CCL.
*/
static void tinyCCLRGB_SPIWriteByte(uint8_t byte)
{
	SPI0.INTFLAGS = SPI0_INTFLAGS; // clear the write collision flag to allow writing
     6be:	90 91 23 08 	lds	r25, 0x0823	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
     6c2:	90 93 23 08 	sts	0x0823, r25	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
	TCA0.SINGLE.CNT = 0; // reset TCA counter register to ensure the first rising edge of the PWM is predictable
     6c6:	e0 e0       	ldi	r30, 0x00	; 0
     6c8:	fa e0       	ldi	r31, 0x0A	; 10
     6ca:	10 a2       	std	Z+32, r1	; 0x20
     6cc:	11 a2       	std	Z+33, r1	; 0x21
	
	// start TCA
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 1 << TCA_SPLIT_ENABLE_bp;
     6ce:	91 e0       	ldi	r25, 0x01	; 1
     6d0:	90 83       	st	Z, r25
	SPI0_DATA = byte;
     6d2:	80 93 24 08 	sts	0x0824, r24	; 0x800824 <__TEXT_REGION_LENGTH__+0x700824>

	while((SPI0.INTFLAGS & SPI_RXCIE_bm) == 0){} // wait for transfer to complete
     6d6:	e0 e2       	ldi	r30, 0x20	; 32
     6d8:	f8 e0       	ldi	r31, 0x08	; 8
     6da:	83 81       	ldd	r24, Z+3	; 0x03
     6dc:	88 23       	and	r24, r24
     6de:	ec f7       	brge	.-6      	; 0x6da <tinyCCLRGB_SPIWriteByte+0x1c>
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 0 << TCA_SPLIT_ENABLE_bp; //Stop TCA
     6e0:	10 92 00 0a 	sts	0x0A00, r1	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
     6e4:	08 95       	ret

000006e6 <tinyCCLRGB_setColor>:
/*
changes the values in the variables stored in the led-array.
*/
void tinyCCLRGB_setColor(uint8_t led, uint8_t red, uint8_t green, uint8_t blue) 
{
	tinyCCLRGB_colors[led].red = red;
     6e6:	90 e0       	ldi	r25, 0x00	; 0
     6e8:	fc 01       	movw	r30, r24
     6ea:	ee 0f       	add	r30, r30
     6ec:	ff 1f       	adc	r31, r31
     6ee:	8e 0f       	add	r24, r30
     6f0:	9f 1f       	adc	r25, r31
     6f2:	fc 01       	movw	r30, r24
     6f4:	ed 5d       	subi	r30, 0xDD	; 221
     6f6:	f1 4c       	sbci	r31, 0xC1	; 193
     6f8:	60 83       	st	Z, r22
	tinyCCLRGB_colors[led].green = green;
     6fa:	41 83       	std	Z+1, r20	; 0x01
	tinyCCLRGB_colors[led].blue = blue;
     6fc:	22 83       	std	Z+2, r18	; 0x02
     6fe:	08 95       	ret

00000700 <tinyCCLRGB_uploadColorsToLeds>:
/*
function to write the current LED-array on to the LEDs and
effectively update the values stored in the LEDs to the values stored in the MCU.
*/
void tinyCCLRGB_uploadColorsToLeds(void)
{
     700:	0f 93       	push	r16
     702:	1f 93       	push	r17
     704:	cf 93       	push	r28
     706:	df 93       	push	r29
     708:	c3 e2       	ldi	r28, 0x23	; 35
     70a:	de e3       	ldi	r29, 0x3E	; 62
     70c:	05 e3       	ldi	r16, 0x35	; 53
     70e:	1e e3       	ldi	r17, 0x3E	; 62
	for (uint8_t i = 0; i < TINYCCLRGB_LEDCOUNT; i++)
	{
		//For some reason unknown to the writer the data-bus to the LEDs is serialized as GRB
		//which means the 24-bit data-bus will look like [Green[0:7], Red[0:7], Blue[0:7]]
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].green);
     710:	89 81       	ldd	r24, Y+1	; 0x01
     712:	d5 df       	rcall	.-86     	; 0x6be <tinyCCLRGB_SPIWriteByte>
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].red);
     714:	88 81       	ld	r24, Y
     716:	d3 df       	rcall	.-90     	; 0x6be <tinyCCLRGB_SPIWriteByte>
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].blue);
     718:	8a 81       	ldd	r24, Y+2	; 0x02
     71a:	d1 df       	rcall	.-94     	; 0x6be <tinyCCLRGB_SPIWriteByte>
     71c:	23 96       	adiw	r28, 0x03	; 3
function to write the current LED-array on to the LEDs and
effectively update the values stored in the LEDs to the values stored in the MCU.
*/
void tinyCCLRGB_uploadColorsToLeds(void)
{
	for (uint8_t i = 0; i < TINYCCLRGB_LEDCOUNT; i++)
     71e:	c0 17       	cp	r28, r16
     720:	d1 07       	cpc	r29, r17
     722:	b1 f7       	brne	.-20     	; 0x710 <tinyCCLRGB_uploadColorsToLeds+0x10>
		//which means the 24-bit data-bus will look like [Green[0:7], Red[0:7], Blue[0:7]]
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].green);
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].red);
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].blue);
	}
}
     724:	df 91       	pop	r29
     726:	cf 91       	pop	r28
     728:	1f 91       	pop	r17
     72a:	0f 91       	pop	r16
     72c:	08 95       	ret

0000072e <tinyDendriteite_set_neuron_type>:


//sets neuron type
void tinyDendriteite_set_neuron_type(enum NeuronType neuron_type)
{
	this_neurons_type = neuron_type;
     72e:	91 e0       	ldi	r25, 0x01	; 1
     730:	81 11       	cpse	r24, r1
     732:	01 c0       	rjmp	.+2      	; 0x736 <tinyDendriteite_set_neuron_type+0x8>
     734:	90 e0       	ldi	r25, 0x00	; 0
     736:	90 93 39 3e 	sts	0x3E39, r25	; 0x803e39 <this_neurons_type>
     73a:	08 95       	ret

0000073c <tinyAxon_remove_pulse>:
/*
solution to remove future firing if a inhibitory signal is received
shortly after a excitatory signal.
*/
bool tinyAxon_remove_pulse(void)
{
     73c:	cf 92       	push	r12
     73e:	df 92       	push	r13
     740:	ef 92       	push	r14
     742:	ff 92       	push	r15
	// We want to remove the pulse last added to the queue
	// We also want to return a bool indicating whether or not a pulse actually was removed
	uint32_t now = tinyTime_now();
     744:	8f de       	rcall	.-738    	; 0x464 <tinyTime_now>
     746:	6b 01       	movw	r12, r22
     748:	7c 01       	movw	r14, r24
	uint32_t pulse_time = dequeue_top(&pulse_queue);
     74a:	86 e3       	ldi	r24, 0x36	; 54
     74c:	9e e3       	ldi	r25, 0x3E	; 62
     74e:	d5 dd       	rcall	.-1110   	; 0x2fa <dequeue_top>
	if(pulse_time == 0){ // Here, 0 is regarded as an error
     750:	61 15       	cp	r22, r1
     752:	71 05       	cpc	r23, r1
     754:	81 05       	cpc	r24, r1
     756:	91 05       	cpc	r25, r1
     758:	c1 f0       	breq	.+48     	; 0x78a <tinyAxon_remove_pulse+0x4e>
		return false;
	}
	
	// Now we want to check if the pulse is too far away to be affected by the low potential, or close enough that we decide to remove it
	// (When we say that the pulse is too far away, it refers to the biological process of how the potential spreads from Dendriteites to axon)
	else if((now + UNDO_PERIOD) < pulse_time){
     75a:	2c e3       	ldi	r18, 0x3C	; 60
     75c:	c2 0e       	add	r12, r18
     75e:	d1 1c       	adc	r13, r1
     760:	e1 1c       	adc	r14, r1
     762:	f1 1c       	adc	r15, r1
     764:	c6 16       	cp	r12, r22
     766:	d7 06       	cpc	r13, r23
     768:	e8 06       	cpc	r14, r24
     76a:	f9 06       	cpc	r15, r25
     76c:	38 f4       	brcc	.+14     	; 0x77c <tinyAxon_remove_pulse+0x40>
		// We decided to remove the pulse
		pulses_in_queue--;
     76e:	80 91 38 3e 	lds	r24, 0x3E38	; 0x803e38 <pulses_in_queue>
     772:	81 50       	subi	r24, 0x01	; 1
     774:	80 93 38 3e 	sts	0x3E38, r24	; 0x803e38 <pulses_in_queue>
		return true;
     778:	81 e0       	ldi	r24, 0x01	; 1
     77a:	08 c0       	rjmp	.+16     	; 0x78c <tinyAxon_remove_pulse+0x50>
	}
	// Here we have found that there is a pulse queued, but it is old enough to let pass anyway, so now we need to put it back into the queue
	else{
		enqueue(&pulse_queue, pulse_time);
     77c:	ab 01       	movw	r20, r22
     77e:	bc 01       	movw	r22, r24
     780:	86 e3       	ldi	r24, 0x36	; 54
     782:	9e e3       	ldi	r25, 0x3E	; 62
     784:	5e dd       	rcall	.-1348   	; 0x242 <enqueue>
		return false;
     786:	80 e0       	ldi	r24, 0x00	; 0
     788:	01 c0       	rjmp	.+2      	; 0x78c <tinyAxon_remove_pulse+0x50>
	// We also want to return a bool indicating whether or not a pulse actually was removed
	uint32_t now = tinyTime_now();
	uint32_t pulse_time = dequeue_top(&pulse_queue);
	if(pulse_time == 0){ // Here, 0 is regarded as an error
		//There was no pulse to remove
		return false;
     78a:	80 e0       	ldi	r24, 0x00	; 0
	// Here we have found that there is a pulse queued, but it is old enough to let pass anyway, so now we need to put it back into the queue
	else{
		enqueue(&pulse_queue, pulse_time);
		return false;
	}
}
     78c:	ff 90       	pop	r15
     78e:	ef 90       	pop	r14
     790:	df 90       	pop	r13
     792:	cf 90       	pop	r12
     794:	08 95       	ret

00000796 <tinyAxon_update_potential>:
/*
Decides whether or not the axon should fire
If the axon does fire, the potential is reduced
*/
double tinyAxon_update_potential(double potential)
{
     796:	4f 92       	push	r4
     798:	5f 92       	push	r5
     79a:	6f 92       	push	r6
     79c:	7f 92       	push	r7
     79e:	8f 92       	push	r8
     7a0:	9f 92       	push	r9
     7a2:	af 92       	push	r10
     7a4:	bf 92       	push	r11
     7a6:	cf 92       	push	r12
     7a8:	df 92       	push	r13
     7aa:	ef 92       	push	r14
     7ac:	ff 92       	push	r15
     7ae:	cf 93       	push	r28
     7b0:	df 93       	push	r29
     7b2:	6b 01       	movw	r12, r22
     7b4:	7c 01       	movw	r14, r24
	int pulse_nr = 0;
	uint32_t now = tinyTime_now();
     7b6:	56 de       	rcall	.-852    	; 0x464 <tinyTime_now>
     7b8:	2b 01       	movw	r4, r22
     7ba:	3c 01       	movw	r6, r24
	
	//While the neuron has enough potential to fire, we want to fire more
	while (potential > THRESHOLD_POTENTIAL)
     7bc:	20 e0       	ldi	r18, 0x00	; 0
     7be:	30 e0       	ldi	r19, 0x00	; 0
     7c0:	48 ec       	ldi	r20, 0xC8	; 200
     7c2:	51 e4       	ldi	r21, 0x41	; 65
     7c4:	c7 01       	movw	r24, r14
     7c6:	b6 01       	movw	r22, r12
     7c8:	21 d4       	rcall	.+2114   	; 0x100c <__gesf2>
     7ca:	18 16       	cp	r1, r24
     7cc:	5c f5       	brge	.+86     	; 0x824 <tinyAxon_update_potential+0x8e>
     7ce:	c0 e0       	ldi	r28, 0x00	; 0
     7d0:	d0 e0       	ldi	r29, 0x00	; 0
/*
Adds an element to the queue
*/
static void tinyAxon_enqueue_pulse(uint32_t new_pulse)
{
	enqueue(&pulse_queue, new_pulse);
     7d2:	53 01       	movw	r10, r6
     7d4:	42 01       	movw	r8, r4
     7d6:	84 e6       	ldi	r24, 0x64	; 100
     7d8:	88 0e       	add	r8, r24
     7da:	91 1c       	adc	r9, r1
     7dc:	a1 1c       	adc	r10, r1
     7de:	b1 1c       	adc	r11, r1
     7e0:	ae 01       	movw	r20, r28
     7e2:	0d 2e       	mov	r0, r29
     7e4:	00 0c       	add	r0, r0
     7e6:	66 0b       	sbc	r22, r22
     7e8:	77 0b       	sbc	r23, r23
     7ea:	48 0d       	add	r20, r8
     7ec:	59 1d       	adc	r21, r9
     7ee:	6a 1d       	adc	r22, r10
     7f0:	7b 1d       	adc	r23, r11
     7f2:	86 e3       	ldi	r24, 0x36	; 54
     7f4:	9e e3       	ldi	r25, 0x3E	; 62
     7f6:	25 dd       	rcall	.-1462   	; 0x242 <enqueue>
	pulses_in_queue++;
     7f8:	80 91 38 3e 	lds	r24, 0x3E38	; 0x803e38 <pulses_in_queue>
     7fc:	8f 5f       	subi	r24, 0xFF	; 255
     7fe:	80 93 38 3e 	sts	0x3E38, r24	; 0x803e38 <pulses_in_queue>
	{
		tinyAxon_enqueue_pulse(now + TRAVLE_DELAY + FIRE_DELAY*pulse_nr);
		pulse_nr++;
		
		// I want to test reducing the potential by -30 instead of -25 to simulate the hyperpolarization
		potential += POSTFIRE_POTENTIAL_REACTION; // This is usually defined as a negative value, don't be confused by the +=
     802:	20 e0       	ldi	r18, 0x00	; 0
     804:	30 e0       	ldi	r19, 0x00	; 0
     806:	40 ef       	ldi	r20, 0xF0	; 240
     808:	51 e4       	ldi	r21, 0x41	; 65
     80a:	c7 01       	movw	r24, r14
     80c:	b6 01       	movw	r22, r12
     80e:	d1 d1       	rcall	.+930    	; 0xbb2 <__subsf3>
     810:	6b 01       	movw	r12, r22
     812:	7c 01       	movw	r14, r24
     814:	e2 96       	adiw	r28, 0x32	; 50
{
	int pulse_nr = 0;
	uint32_t now = tinyTime_now();
	
	//While the neuron has enough potential to fire, we want to fire more
	while (potential > THRESHOLD_POTENTIAL)
     816:	20 e0       	ldi	r18, 0x00	; 0
     818:	30 e0       	ldi	r19, 0x00	; 0
     81a:	48 ec       	ldi	r20, 0xC8	; 200
     81c:	51 e4       	ldi	r21, 0x41	; 65
     81e:	f6 d3       	rcall	.+2028   	; 0x100c <__gesf2>
     820:	18 16       	cp	r1, r24
     822:	f4 f2       	brlt	.-68     	; 0x7e0 <tinyAxon_update_potential+0x4a>
		// I want to test reducing the potential by -30 instead of -25 to simulate the hyperpolarization
		potential += POSTFIRE_POTENTIAL_REACTION; // This is usually defined as a negative value, don't be confused by the +=
	}
	
	// If the neuron has a very low potential, we want to remove a pulse from the queue (if there is one)
	if(potential < -THRESHOLD_POTENTIAL && pulses_in_queue > 0) // Perhaps this should be a separate variable? For now, we will just simply use -THRESHOLD_POTENTIAL
     824:	20 e0       	ldi	r18, 0x00	; 0
     826:	30 e0       	ldi	r19, 0x00	; 0
     828:	48 ec       	ldi	r20, 0xC8	; 200
     82a:	51 ec       	ldi	r21, 0xC1	; 193
     82c:	c7 01       	movw	r24, r14
     82e:	b6 01       	movw	r22, r12
     830:	2d d2       	rcall	.+1114   	; 0xc8c <__cmpsf2>
     832:	88 23       	and	r24, r24
     834:	84 f4       	brge	.+32     	; 0x856 <tinyAxon_update_potential+0xc0>
     836:	80 91 38 3e 	lds	r24, 0x3E38	; 0x803e38 <pulses_in_queue>
     83a:	88 23       	and	r24, r24
     83c:	79 f1       	breq	.+94     	; 0x89c <tinyAxon_update_potential+0x106>
	{
		// The neurons potential is low enough to attempt to remove a queued fire (Fire less)
		if(tinyAxon_remove_pulse())
     83e:	7e df       	rcall	.-260    	; 0x73c <tinyAxon_remove_pulse>
     840:	88 23       	and	r24, r24
     842:	49 f0       	breq	.+18     	; 0x856 <tinyAxon_update_potential+0xc0>
		{
			// The potential has evened out a bit
			potential += THRESHOLD_POTENTIAL;
     844:	20 e0       	ldi	r18, 0x00	; 0
     846:	30 e0       	ldi	r19, 0x00	; 0
     848:	48 ec       	ldi	r20, 0xC8	; 200
     84a:	51 e4       	ldi	r21, 0x41	; 65
     84c:	c7 01       	movw	r24, r14
     84e:	b6 01       	movw	r22, r12
     850:	b1 d1       	rcall	.+866    	; 0xbb4 <__addsf3>
     852:	6b 01       	movw	r12, r22
     854:	7c 01       	movw	r14, r24
		}
	}
	
	// If there are pulses in the queue, and the pulse has been scheduled to fire
	if ((pulses_in_queue > 0) && (next_pulse <= now))
     856:	80 91 38 3e 	lds	r24, 0x3E38	; 0x803e38 <pulses_in_queue>
     85a:	88 23       	and	r24, r24
     85c:	f9 f0       	breq	.+62     	; 0x89c <tinyAxon_update_potential+0x106>
     85e:	40 91 56 3e 	lds	r20, 0x3E56	; 0x803e56 <next_pulse>
     862:	50 91 57 3e 	lds	r21, 0x3E57	; 0x803e57 <next_pulse+0x1>
     866:	60 91 58 3e 	lds	r22, 0x3E58	; 0x803e58 <next_pulse+0x2>
     86a:	70 91 59 3e 	lds	r23, 0x3E59	; 0x803e59 <next_pulse+0x3>
     86e:	44 16       	cp	r4, r20
     870:	55 06       	cpc	r5, r21
     872:	66 06       	cpc	r6, r22
     874:	77 06       	cpc	r7, r23
     876:	90 f0       	brcs	.+36     	; 0x89c <tinyAxon_update_potential+0x106>
Function to set firing.
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
     878:	91 e0       	ldi	r25, 0x01	; 1
     87a:	90 93 3a 3e 	sts	0x3E3A, r25	; 0x803e3a <tinyAxon_should_fire>
	pulses_in_queue--;
     87e:	81 50       	subi	r24, 0x01	; 1
     880:	80 93 38 3e 	sts	0x3E38, r24	; 0x803e38 <pulses_in_queue>
	next_pulse = dequeue(&pulse_queue);
     884:	86 e3       	ldi	r24, 0x36	; 54
     886:	9e e3       	ldi	r25, 0x3E	; 62
     888:	fc dc       	rcall	.-1544   	; 0x282 <dequeue>
     88a:	60 93 56 3e 	sts	0x3E56, r22	; 0x803e56 <next_pulse>
     88e:	70 93 57 3e 	sts	0x3E57, r23	; 0x803e57 <next_pulse+0x1>
     892:	80 93 58 3e 	sts	0x3E58, r24	; 0x803e58 <next_pulse+0x2>
     896:	90 93 59 3e 	sts	0x3E59, r25	; 0x803e59 <next_pulse+0x3>
	// If there are pulses in the queue, and the pulse has been scheduled to fire
	if ((pulses_in_queue > 0) && (next_pulse <= now))
	{
		// We fire the axon
		tinyAxon_fire_pulse();
		set_LED_fire();
     89a:	1a de       	rcall	.-972    	; 0x4d0 <set_LED_fire>
The function should set the DAC to fire for two
update cycles once the pulse flag is set high.
*/
static void tinyAxon_update_pulse_transmitter(void)
{
	if (tinyAxon_should_fire)
     89c:	80 91 3a 3e 	lds	r24, 0x3E3A	; 0x803e3a <tinyAxon_should_fire>
     8a0:	88 23       	and	r24, r24
     8a2:	b9 f0       	breq	.+46     	; 0x8d2 <tinyAxon_update_potential+0x13c>
	{
		tinyAxon_should_fire = false;
     8a4:	10 92 3a 3e 	sts	0x3E3A, r1	; 0x803e3a <tinyAxon_should_fire>
		tinyAxon_has_fired = true;
     8a8:	81 e0       	ldi	r24, 0x01	; 1
     8aa:	80 93 3b 3e 	sts	0x3E3B, r24	; 0x803e3b <tinyAxon_has_fired>
Pulse send function.
sends a pulse dependent on the neurons type.
*/
static void tinyAxon_start_sending_pulse()
{
	if (this_neurons_type == EXCITATORY_NEURON)
     8ae:	80 91 39 3e 	lds	r24, 0x3E39	; 0x803e39 <this_neurons_type>
     8b2:	81 11       	cpse	r24, r1
     8b4:	07 c0       	rjmp	.+14     	; 0x8c4 <tinyAxon_update_potential+0x12e>
	{
		DAC_set_output(EXCITATORY_NEURON_OUTPUT);
     8b6:	87 ed       	ldi	r24, 0xD7	; 215
     8b8:	90 e0       	ldi	r25, 0x00	; 0
     8ba:	2c dc       	rcall	.-1960   	; 0x114 <DAC_set_output>
		axonOutputValue=EXCITATORY_NEURON_OUTPUT;
     8bc:	87 ed       	ldi	r24, 0xD7	; 215
     8be:	80 93 35 3e 	sts	0x3E35, r24	; 0x803e35 <axonOutputValue>
     8c2:	13 c0       	rjmp	.+38     	; 0x8ea <tinyAxon_update_potential+0x154>
	}
	else if(this_neurons_type == INHIBITORY_NEURON)
	{
		DAC_set_output(INHIBITORY_NEURON_OUTPUT);
     8c4:	84 e7       	ldi	r24, 0x74	; 116
     8c6:	90 e0       	ldi	r25, 0x00	; 0
     8c8:	25 dc       	rcall	.-1974   	; 0x114 <DAC_set_output>
		axonOutputValue=INHIBITORY_NEURON_OUTPUT;
     8ca:	84 e7       	ldi	r24, 0x74	; 116
     8cc:	80 93 35 3e 	sts	0x3E35, r24	; 0x803e35 <axonOutputValue>
     8d0:	0c c0       	rjmp	.+24     	; 0x8ea <tinyAxon_update_potential+0x154>
		tinyAxon_should_fire = false;
		tinyAxon_has_fired = true;
		
		tinyAxon_start_sending_pulse();
	}
	else if (tinyAxon_has_fired)
     8d2:	80 91 3b 3e 	lds	r24, 0x3E3B	; 0x803e3b <tinyAxon_has_fired>
     8d6:	88 23       	and	r24, r24
     8d8:	19 f0       	breq	.+6      	; 0x8e0 <tinyAxon_update_potential+0x14a>
	{
		tinyAxon_has_fired = false;
     8da:	10 92 3b 3e 	sts	0x3E3B, r1	; 0x803e3b <tinyAxon_has_fired>
     8de:	05 c0       	rjmp	.+10     	; 0x8ea <tinyAxon_update_potential+0x154>
}

static void tinyAxon_stop_sending_pulse()
{
	
	DAC_set_output(NO_SIGNAL_OUTPUT);
     8e0:	80 e0       	ldi	r24, 0x00	; 0
     8e2:	90 e0       	ldi	r25, 0x00	; 0
     8e4:	17 dc       	rcall	.-2002   	; 0x114 <DAC_set_output>
	axonOutputValue=NO_SIGNAL_OUTPUT;
     8e6:	10 92 35 3e 	sts	0x3E35, r1	; 0x803e35 <axonOutputValue>
	}
	
	// Here we set the actual output of the DAC (Digital to Analog Converter)
	tinyAxon_update_pulse_transmitter();
	return potential;
}
     8ea:	c7 01       	movw	r24, r14
     8ec:	b6 01       	movw	r22, r12
     8ee:	df 91       	pop	r29
     8f0:	cf 91       	pop	r28
     8f2:	ff 90       	pop	r15
     8f4:	ef 90       	pop	r14
     8f6:	df 90       	pop	r13
     8f8:	cf 90       	pop	r12
     8fa:	bf 90       	pop	r11
     8fc:	af 90       	pop	r10
     8fe:	9f 90       	pop	r9
     900:	8f 90       	pop	r8
     902:	7f 90       	pop	r7
     904:	6f 90       	pop	r6
     906:	5f 90       	pop	r5
     908:	4f 90       	pop	r4
     90a:	08 95       	ret

0000090c <tinyDendriteite_update_signals>:
/*
This function converts the 8 bit value from the ADC into one of the signal types defined in DendriteiteSignal
We also update the charging state
*/
void tinyDendriteite_update_signals(void)
{
     90c:	2f 92       	push	r2
     90e:	3f 92       	push	r3
     910:	4f 92       	push	r4
     912:	5f 92       	push	r5
     914:	6f 92       	push	r6
     916:	7f 92       	push	r7
     918:	8f 92       	push	r8
     91a:	9f 92       	push	r9
     91c:	af 92       	push	r10
     91e:	bf 92       	push	r11
     920:	cf 92       	push	r12
     922:	df 92       	push	r13
     924:	ef 92       	push	r14
     926:	ff 92       	push	r15
     928:	0f 93       	push	r16
     92a:	1f 93       	push	r17
     92c:	cf 93       	push	r28
     92e:	df 93       	push	r29
	tinyCharge_set_charging(false);
     930:	80 e0       	ldi	r24, 0x00	; 0
     932:	44 dd       	rcall	.-1400   	; 0x3bc <tinyCharge_set_charging>
     934:	c1 e4       	ldi	r28, 0x41	; 65
     936:	de e3       	ldi	r29, 0x3E	; 62
     938:	0f 2e       	mov	r0, r31
     93a:	f6 e4       	ldi	r31, 0x46	; 70
     93c:	cf 2e       	mov	r12, r31
     93e:	fe e3       	ldi	r31, 0x3E	; 62
     940:	df 2e       	mov	r13, r31
     942:	f0 2d       	mov	r31, r0
     944:	0c e3       	ldi	r16, 0x3C	; 60
     946:	1e e3       	ldi	r17, 0x3E	; 62
     948:	0f 2e       	mov	r0, r31
     94a:	f6 e4       	ldi	r31, 0x46	; 70
     94c:	8f 2e       	mov	r8, r31
     94e:	fe e3       	ldi	r31, 0x3E	; 62
     950:	9f 2e       	mov	r9, r31
     952:	f0 2d       	mov	r31, r0
		{
			tinyDendriteite_current_signals[i] = HIGH_INHIB;
		}
		else if (tinyDendriteite_values[i] > LOW_INHIB_THRESHOLD)
		{
			tinyDendriteite_current_signals[i] = LOW_INHIB;
     954:	66 24       	eor	r6, r6
     956:	63 94       	inc	r6
		{
			tinyDendriteite_current_signals[i] = LOW_EXCITE;
		}
		else if (tinyDendriteite_values[i] > NORMAL_INHIB_THRESHOLD)
		{
			tinyDendriteite_current_signals[i] = NORMAL_INHIB;
     958:	68 94       	set
     95a:	22 24       	eor	r2, r2
     95c:	21 f8       	bld	r2, 1
		{
			tinyDendriteite_current_signals[i] = HIGH_EXCITE;
		}
		else if (tinyDendriteite_values[i] > LOW_EXCITE_THRESHOLD)
		{
			tinyDendriteite_current_signals[i] = LOW_EXCITE;
     95e:	68 94       	set
     960:	33 24       	eor	r3, r3
     962:	32 f8       	bld	r3, 2
		{
			tinyDendriteite_current_signals[i] = NORMAL_EXCITE;
		}
		else if (tinyDendriteite_values[i] > HIGH_EXCITE_THRESHOLD)
		{
			tinyDendriteite_current_signals[i] = HIGH_EXCITE;
     964:	0f 2e       	mov	r0, r31
     966:	f6 e0       	ldi	r31, 0x06	; 6
     968:	4f 2e       	mov	r4, r31
     96a:	f0 2d       	mov	r31, r0
			tinyDendriteite_current_signals[i] = CHARGING;
			tinyCharge_set_charging(true);
		}
		else if (tinyDendriteite_values[i] > NORMAL_EXCITE_THRESHOLD)
		{
			tinyDendriteite_current_signals[i] = NORMAL_EXCITE;
     96c:	0f 2e       	mov	r0, r31
     96e:	f5 e0       	ldi	r31, 0x05	; 5
     970:	7f 2e       	mov	r7, r31
     972:	f0 2d       	mov	r31, r0
	for (uint8_t i = 0; i < TINYDendriteITE_COUNT; i++)
	{
		tinyDendriteite_previous_signals[i] = tinyDendriteite_current_signals[i];
		if (tinyDendriteite_values[i] > CHARGING_THRESHOLD)
		{
			tinyDendriteite_current_signals[i] = CHARGING;
     974:	0f 2e       	mov	r0, r31
     976:	f7 e0       	ldi	r31, 0x07	; 7
     978:	5f 2e       	mov	r5, r31
     97a:	f0 2d       	mov	r31, r0
     97c:	7e 01       	movw	r14, r28
     97e:	58 01       	movw	r10, r16
{
	tinyCharge_set_charging(false);
	
	for (uint8_t i = 0; i < TINYDendriteITE_COUNT; i++)
	{
		tinyDendriteite_previous_signals[i] = tinyDendriteite_current_signals[i];
     980:	88 81       	ld	r24, Y
     982:	f8 01       	movw	r30, r16
     984:	80 83       	st	Z, r24
		if (tinyDendriteite_values[i] > CHARGING_THRESHOLD)
     986:	f6 01       	movw	r30, r12
     988:	81 91       	ld	r24, Z+
     98a:	91 91       	ld	r25, Z+
     98c:	6f 01       	movw	r12, r30
     98e:	89 3e       	cpi	r24, 0xE9	; 233
     990:	91 05       	cpc	r25, r1
     992:	20 f0       	brcs	.+8      	; 0x99c <tinyDendriteite_update_signals+0x90>
		{
			tinyDendriteite_current_signals[i] = CHARGING;
     994:	58 82       	st	Y, r5
			tinyCharge_set_charging(true);
     996:	86 2d       	mov	r24, r6
     998:	11 dd       	rcall	.-1502   	; 0x3bc <tinyCharge_set_charging>
     99a:	1f c0       	rjmp	.+62     	; 0x9da <tinyDendriteite_update_signals+0xce>
		}
		else if (tinyDendriteite_values[i] > NORMAL_EXCITE_THRESHOLD)
     99c:	88 3c       	cpi	r24, 0xC8	; 200
     99e:	91 05       	cpc	r25, r1
     9a0:	10 f0       	brcs	.+4      	; 0x9a6 <tinyDendriteite_update_signals+0x9a>
		{
			tinyDendriteite_current_signals[i] = NORMAL_EXCITE;
     9a2:	78 82       	st	Y, r7
     9a4:	1a c0       	rjmp	.+52     	; 0x9da <tinyDendriteite_update_signals+0xce>
		}
		else if (tinyDendriteite_values[i] > HIGH_EXCITE_THRESHOLD)
     9a6:	87 3a       	cpi	r24, 0xA7	; 167
     9a8:	91 05       	cpc	r25, r1
     9aa:	10 f0       	brcs	.+4      	; 0x9b0 <tinyDendriteite_update_signals+0xa4>
		{
			tinyDendriteite_current_signals[i] = HIGH_EXCITE;
     9ac:	48 82       	st	Y, r4
     9ae:	15 c0       	rjmp	.+42     	; 0x9da <tinyDendriteite_update_signals+0xce>
		}
		else if (tinyDendriteite_values[i] > LOW_EXCITE_THRESHOLD)
     9b0:	85 38       	cpi	r24, 0x85	; 133
     9b2:	91 05       	cpc	r25, r1
     9b4:	10 f0       	brcs	.+4      	; 0x9ba <tinyDendriteite_update_signals+0xae>
		{
			tinyDendriteite_current_signals[i] = LOW_EXCITE;
     9b6:	38 82       	st	Y, r3
     9b8:	10 c0       	rjmp	.+32     	; 0x9da <tinyDendriteite_update_signals+0xce>
		}
		else if (tinyDendriteite_values[i] > NORMAL_INHIB_THRESHOLD)
     9ba:	84 36       	cpi	r24, 0x64	; 100
     9bc:	91 05       	cpc	r25, r1
     9be:	10 f0       	brcs	.+4      	; 0x9c4 <tinyDendriteite_update_signals+0xb8>
		{
			tinyDendriteite_current_signals[i] = NORMAL_INHIB;
     9c0:	28 82       	st	Y, r2
     9c2:	0b c0       	rjmp	.+22     	; 0x9da <tinyDendriteite_update_signals+0xce>
		}
		else if (tinyDendriteite_values[i] > HIGH_INHIB_THRESHOLD)
     9c4:	83 34       	cpi	r24, 0x43	; 67
     9c6:	91 05       	cpc	r25, r1
     9c8:	18 f0       	brcs	.+6      	; 0x9d0 <tinyDendriteite_update_signals+0xc4>
		{
			tinyDendriteite_current_signals[i] = HIGH_INHIB;
     9ca:	83 e0       	ldi	r24, 0x03	; 3
     9cc:	88 83       	st	Y, r24
     9ce:	05 c0       	rjmp	.+10     	; 0x9da <tinyDendriteite_update_signals+0xce>
		}
		else if (tinyDendriteite_values[i] > LOW_INHIB_THRESHOLD)
     9d0:	82 97       	sbiw	r24, 0x22	; 34
     9d2:	10 f0       	brcs	.+4      	; 0x9d8 <tinyDendriteite_update_signals+0xcc>
		{
			tinyDendriteite_current_signals[i] = LOW_INHIB;
     9d4:	68 82       	st	Y, r6
     9d6:	01 c0       	rjmp	.+2      	; 0x9da <tinyDendriteite_update_signals+0xce>
		}
		else
		{
			tinyDendriteite_current_signals[i] = NO_SIGNAL;
     9d8:	18 82       	st	Y, r1
     9da:	0f 5f       	subi	r16, 0xFF	; 255
     9dc:	1f 4f       	sbci	r17, 0xFF	; 255
		}
		if (tinyDendriteite_current_signals[i] == tinyDendriteite_previous_signals[i])
     9de:	f7 01       	movw	r30, r14
     9e0:	90 81       	ld	r25, Z
     9e2:	f5 01       	movw	r30, r10
     9e4:	80 81       	ld	r24, Z
     9e6:	98 13       	cpse	r25, r24
     9e8:	02 c0       	rjmp	.+4      	; 0x9ee <tinyDendriteite_update_signals+0xe2>
		{
			tinyDendriteite_current_signals[i] = NO_SIGNAL;
     9ea:	f7 01       	movw	r30, r14
     9ec:	10 82       	st	Z, r1
     9ee:	21 96       	adiw	r28, 0x01	; 1
*/
void tinyDendriteite_update_signals(void)
{
	tinyCharge_set_charging(false);
	
	for (uint8_t i = 0; i < TINYDendriteITE_COUNT; i++)
     9f0:	c8 15       	cp	r28, r8
     9f2:	d9 05       	cpc	r29, r9
     9f4:	19 f6       	brne	.-122    	; 0x97c <tinyDendriteite_update_signals+0x70>
		if (tinyDendriteite_current_signals[i] == tinyDendriteite_previous_signals[i])
		{
			tinyDendriteite_current_signals[i] = NO_SIGNAL;
		}
	}
}
     9f6:	df 91       	pop	r29
     9f8:	cf 91       	pop	r28
     9fa:	1f 91       	pop	r17
     9fc:	0f 91       	pop	r16
     9fe:	ff 90       	pop	r15
     a00:	ef 90       	pop	r14
     a02:	df 90       	pop	r13
     a04:	cf 90       	pop	r12
     a06:	bf 90       	pop	r11
     a08:	af 90       	pop	r10
     a0a:	9f 90       	pop	r9
     a0c:	8f 90       	pop	r8
     a0e:	7f 90       	pop	r7
     a10:	6f 90       	pop	r6
     a12:	5f 90       	pop	r5
     a14:	4f 90       	pop	r4
     a16:	3f 90       	pop	r3
     a18:	2f 90       	pop	r2
     a1a:	08 95       	ret

00000a1c <tinyDendriteite_get_potential>:
/*
This is the master function of the module that is callable from
outside. It uses the previously declared functions to return the potential.
*/
int16_t tinyDendriteite_get_potential()
{
     a1c:	ef 92       	push	r14
     a1e:	ff 92       	push	r15
     a20:	0f 93       	push	r16
     a22:	1f 93       	push	r17
     a24:	cf 93       	push	r28
     a26:	df 93       	push	r29
     a28:	08 e0       	ldi	r16, 0x08	; 8
     a2a:	1e e3       	ldi	r17, 0x3E	; 62
     a2c:	c6 e4       	ldi	r28, 0x46	; 70
     a2e:	de e3       	ldi	r29, 0x3E	; 62
     a30:	0f 2e       	mov	r0, r31
     a32:	f0 e5       	ldi	r31, 0x50	; 80
     a34:	ef 2e       	mov	r14, r31
     a36:	fe e3       	ldi	r31, 0x3E	; 62
     a38:	ff 2e       	mov	r15, r31
     a3a:	f0 2d       	mov	r31, r0
*/
static void tinyDendriteite_read_signals(void)
{
	for (int i = 0; i < TINYDendriteITE_COUNT; i++)
	{
		tinyDendriteite_values[i] = ADC_get_conversion(Dendriteite_ports[i]);
     a3c:	f8 01       	movw	r30, r16
     a3e:	81 91       	ld	r24, Z+
     a40:	8f 01       	movw	r16, r30
     a42:	33 db       	rcall	.-2458   	; 0xaa <ADC_get_conversion>
     a44:	89 93       	st	Y+, r24
     a46:	99 93       	st	Y+, r25
/*
This function reads the voltage at the Dendriteite inputs with the ADC
*/
static void tinyDendriteite_read_signals(void)
{
	for (int i = 0; i < TINYDendriteITE_COUNT; i++)
     a48:	ce 15       	cp	r28, r14
     a4a:	df 05       	cpc	r29, r15
     a4c:	b9 f7       	brne	.-18     	; 0xa3c <tinyDendriteite_get_potential+0x20>
int16_t tinyDendriteite_get_potential()
{
	//Read the analog voltage values on each of the Dendriteites
	tinyDendriteite_read_signals();
	//Convert the digital value to the various signals defined in DendriteiteSignalType
	tinyDendriteite_update_signals();
     a4e:	5e df       	rcall	.-324    	; 0x90c <tinyDendriteite_update_signals>
     a50:	e1 e4       	ldi	r30, 0x41	; 65
     a52:	fe e3       	ldi	r31, 0x3E	; 62
     a54:	46 e4       	ldi	r20, 0x46	; 70
     a56:	5e e3       	ldi	r21, 0x3E	; 62
	
	int16_t return_potential_val = 0;
     a58:	20 e0       	ldi	r18, 0x00	; 0
     a5a:	30 e0       	ldi	r19, 0x00	; 0
	for (int i = 0; i < TINYDendriteITE_COUNT; i++)
	{
		switch(tinyDendriteite_current_signals[i])
     a5c:	91 91       	ld	r25, Z+
     a5e:	93 30       	cpi	r25, 0x03	; 3
     a60:	a1 f0       	breq	.+40     	; 0xa8a <tinyDendriteite_get_potential+0x6e>
     a62:	28 f4       	brcc	.+10     	; 0xa6e <tinyDendriteite_get_potential+0x52>
     a64:	91 30       	cpi	r25, 0x01	; 1
     a66:	b9 f0       	breq	.+46     	; 0xa96 <tinyDendriteite_get_potential+0x7a>
     a68:	92 30       	cpi	r25, 0x02	; 2
     a6a:	91 f0       	breq	.+36     	; 0xa90 <tinyDendriteite_get_potential+0x74>
     a6c:	16 c0       	rjmp	.+44     	; 0xa9a <tinyDendriteite_get_potential+0x7e>
     a6e:	95 30       	cpi	r25, 0x05	; 5
     a70:	31 f0       	breq	.+12     	; 0xa7e <tinyDendriteite_get_potential+0x62>
     a72:	40 f0       	brcs	.+16     	; 0xa84 <tinyDendriteite_get_potential+0x68>
     a74:	96 30       	cpi	r25, 0x06	; 6
     a76:	89 f4       	brne	.+34     	; 0xa9a <tinyDendriteite_get_potential+0x7e>
		{
			case NO_SIGNAL:
				return_potential_val += NO_SIGNAL_REACTION;
				break;
			case HIGH_EXCITE:
				return_potential_val += HIGH_EXCITE_REACTION;
     a78:	2c 5c       	subi	r18, 0xCC	; 204
     a7a:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     a7c:	0e c0       	rjmp	.+28     	; 0xa9a <tinyDendriteite_get_potential+0x7e>
			case NORMAL_EXCITE:
				return_potential_val += NORMAL_EXCITE_REACTION;
     a7e:	26 5e       	subi	r18, 0xE6	; 230
     a80:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     a82:	0b c0       	rjmp	.+22     	; 0xa9a <tinyDendriteite_get_potential+0x7e>
			case LOW_EXCITE:
				return_potential_val += LOW_EXCITE_REACTION;
     a84:	2c 5e       	subi	r18, 0xEC	; 236
     a86:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     a88:	08 c0       	rjmp	.+16     	; 0xa9a <tinyDendriteite_get_potential+0x7e>
			case HIGH_INHIB:
				return_potential_val += HIGH_INHIB_REACTION;
     a8a:	22 53       	subi	r18, 0x32	; 50
     a8c:	31 09       	sbc	r19, r1
				break;
     a8e:	05 c0       	rjmp	.+10     	; 0xa9a <tinyDendriteite_get_potential+0x7e>
			case NORMAL_INHIB:
				return_potential_val += NORMAL_INHIB_REACTION;
     a90:	2a 51       	subi	r18, 0x1A	; 26
     a92:	31 09       	sbc	r19, r1
				break;
     a94:	02 c0       	rjmp	.+4      	; 0xa9a <tinyDendriteite_get_potential+0x7e>
			case LOW_INHIB:
				return_potential_val += LOW_INHIB_REACTION;
     a96:	24 51       	subi	r18, 0x14	; 20
     a98:	31 09       	sbc	r19, r1
	tinyDendriteite_read_signals();
	//Convert the digital value to the various signals defined in DendriteiteSignalType
	tinyDendriteite_update_signals();
	
	int16_t return_potential_val = 0;
	for (int i = 0; i < TINYDendriteITE_COUNT; i++)
     a9a:	e4 17       	cp	r30, r20
     a9c:	f5 07       	cpc	r31, r21
     a9e:	f1 f6       	brne	.-68     	; 0xa5c <tinyDendriteite_get_potential+0x40>
			default:
				break;
		}
	}
	return return_potential_val;
}
     aa0:	c9 01       	movw	r24, r18
     aa2:	df 91       	pop	r29
     aa4:	cf 91       	pop	r28
     aa6:	1f 91       	pop	r17
     aa8:	0f 91       	pop	r16
     aaa:	ff 90       	pop	r15
     aac:	ef 90       	pop	r14
     aae:	08 95       	ret

00000ab0 <tinyDendriteite_update_potential>:

double tinyDendriteite_update_potential(double potential){
     ab0:	cf 92       	push	r12
     ab2:	df 92       	push	r13
     ab4:	ef 92       	push	r14
     ab6:	ff 92       	push	r15
     ab8:	6b 01       	movw	r12, r22
     aba:	7c 01       	movw	r14, r24
	
	uint16_t potential_change = tinyDendriteite_get_potential();
     abc:	af df       	rcall	.-162    	; 0xa1c <tinyDendriteite_get_potential>
	potential += potential_change;
	return potential;
     abe:	bc 01       	movw	r22, r24
     ac0:	80 e0       	ldi	r24, 0x00	; 0
     ac2:	90 e0       	ldi	r25, 0x00	; 0
     ac4:	ca d1       	rcall	.+916    	; 0xe5a <__floatunsisf>
     ac6:	a7 01       	movw	r20, r14
     ac8:	96 01       	movw	r18, r12
     aca:	74 d0       	rcall	.+232    	; 0xbb4 <__addsf3>
     acc:	ff 90       	pop	r15
     ace:	ef 90       	pop	r14
     ad0:	df 90       	pop	r13
     ad2:	cf 90       	pop	r12
     ad4:	08 95       	ret

00000ad6 <__vector_6>:
This function is called every time the RTC (Real Time Clock) counter overflows.
With the current settings, it will be called every ms.
The RTC clock runs at 1kHz, and the number of cycles before overflow is set with RTC.PER = someHexValue (e.g. 0x20) in src/rtc.c
*/
ISR(RTC_CNT_vect)
{
     ad6:	1f 92       	push	r1
     ad8:	0f 92       	push	r0
     ada:	0f b6       	in	r0, 0x3f	; 63
     adc:	0f 92       	push	r0
     ade:	11 24       	eor	r1, r1
     ae0:	2f 93       	push	r18
     ae2:	3f 93       	push	r19
     ae4:	4f 93       	push	r20
     ae6:	5f 93       	push	r21
     ae8:	6f 93       	push	r22
     aea:	7f 93       	push	r23
     aec:	8f 93       	push	r24
     aee:	9f 93       	push	r25
     af0:	af 93       	push	r26
     af2:	bf 93       	push	r27
     af4:	cf 93       	push	r28
     af6:	ef 93       	push	r30
     af8:	ff 93       	push	r31
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     afa:	c1 e0       	ldi	r28, 0x01	; 1
     afc:	c0 93 50 3e 	sts	0x3E50, r28	; 0x803e50 <tinyISR_interrupt_flag>
{
	// Set flag to let main loop run a new cycle
	tinyISR_setflag(true);
	
	// Timer counter incrementation
	tinyTime_counter_increment();
     b00:	9d dc       	rcall	.-1734   	; 0x43c <tinyTime_counter_increment>

	/* Overflow interrupt flag has to be cleared manually */
	RTC.INTFLAGS = RTC_OVF_bm;
     b02:	c0 93 43 01 	sts	0x0143, r28	; 0x800143 <__TEXT_REGION_LENGTH__+0x700143>
}
     b06:	ff 91       	pop	r31
     b08:	ef 91       	pop	r30
     b0a:	cf 91       	pop	r28
     b0c:	bf 91       	pop	r27
     b0e:	af 91       	pop	r26
     b10:	9f 91       	pop	r25
     b12:	8f 91       	pop	r24
     b14:	7f 91       	pop	r23
     b16:	6f 91       	pop	r22
     b18:	5f 91       	pop	r21
     b1a:	4f 91       	pop	r20
     b1c:	3f 91       	pop	r19
     b1e:	2f 91       	pop	r18
     b20:	0f 90       	pop	r0
     b22:	0f be       	out	0x3f, r0	; 63
     b24:	0f 90       	pop	r0
     b26:	1f 90       	pop	r1
     b28:	18 95       	reti

00000b2a <tinyISR_setflag>:
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     b2a:	80 93 50 3e 	sts	0x3E50, r24	; 0x803e50 <tinyISR_interrupt_flag>
     b2e:	08 95       	ret

00000b30 <tinyISR_getflag>:
}

_Bool tinyISR_getflag(void)
{
	return tinyISR_interrupt_flag;
}
     b30:	80 91 50 3e 	lds	r24, 0x3E50	; 0x803e50 <tinyISR_interrupt_flag>
     b34:	08 95       	ret

00000b36 <tinyPotential_update>:
/*
Function to decay the potential towards 0
*/
static void tinyPotential_decay(double time_since_last_update)
{
	tinyPotential_potential *= (exp(-(time_since_last_update/TINYPOTENTIAL_TIME_CONST)));
     b36:	20 e0       	ldi	r18, 0x00	; 0
     b38:	30 e0       	ldi	r19, 0x00	; 0
     b3a:	48 ec       	ldi	r20, 0xC8	; 200
     b3c:	52 e4       	ldi	r21, 0x42	; 66
     b3e:	ab d0       	rcall	.+342    	; 0xc96 <__divsf3>
     b40:	90 58       	subi	r25, 0x80	; 128
     b42:	23 d1       	rcall	.+582    	; 0xd8a <exp>
     b44:	20 91 51 3e 	lds	r18, 0x3E51	; 0x803e51 <tinyPotential_potential>
     b48:	30 91 52 3e 	lds	r19, 0x3E52	; 0x803e52 <tinyPotential_potential+0x1>
     b4c:	40 91 53 3e 	lds	r20, 0x3E53	; 0x803e53 <tinyPotential_potential+0x2>
     b50:	50 91 54 3e 	lds	r21, 0x3E54	; 0x803e54 <tinyPotential_potential+0x3>
     b54:	d6 d2       	rcall	.+1452   	; 0x1102 <__mulsf3>
     b56:	60 93 51 3e 	sts	0x3E51, r22	; 0x803e51 <tinyPotential_potential>
     b5a:	70 93 52 3e 	sts	0x3E52, r23	; 0x803e52 <tinyPotential_potential+0x1>
     b5e:	80 93 53 3e 	sts	0x3E53, r24	; 0x803e53 <tinyPotential_potential+0x2>
     b62:	90 93 54 3e 	sts	0x3E54, r25	; 0x803e54 <tinyPotential_potential+0x3>
{
	//Some of the potential in the neuron has decayed away
	tinyPotential_decay(time_since_last_update);
	
	// Update potential with values from Dendriteites
	tinyPotential_potential = tinyDendriteite_update_potential(tinyPotential_potential);
     b66:	a4 df       	rcall	.-184    	; 0xab0 <tinyDendriteite_update_potential>
     b68:	60 93 51 3e 	sts	0x3E51, r22	; 0x803e51 <tinyPotential_potential>
     b6c:	70 93 52 3e 	sts	0x3E52, r23	; 0x803e52 <tinyPotential_potential+0x1>
     b70:	80 93 53 3e 	sts	0x3E53, r24	; 0x803e53 <tinyPotential_potential+0x2>
     b74:	90 93 54 3e 	sts	0x3E54, r25	; 0x803e54 <tinyPotential_potential+0x3>
	
	// Update potential from button press
	tinyPotential_potential = tinyButton_update_potential(tinyPotential_potential);
     b78:	98 dd       	rcall	.-1232   	; 0x6aa <tinyButton_update_potential>
     b7a:	60 93 51 3e 	sts	0x3E51, r22	; 0x803e51 <tinyPotential_potential>
     b7e:	70 93 52 3e 	sts	0x3E52, r23	; 0x803e52 <tinyPotential_potential+0x1>
     b82:	80 93 53 3e 	sts	0x3E53, r24	; 0x803e53 <tinyPotential_potential+0x2>
     b86:	90 93 54 3e 	sts	0x3E54, r25	; 0x803e54 <tinyPotential_potential+0x3>
	
	// Update potential with values from spontaneous pulse.
	tinyPotential_potential = tinyPulse_update_potential(tinyPotential_potential);
     b8a:	23 dc       	rcall	.-1978   	; 0x3d2 <tinyPulse_update_potential>
     b8c:	60 93 51 3e 	sts	0x3E51, r22	; 0x803e51 <tinyPotential_potential>
     b90:	70 93 52 3e 	sts	0x3E52, r23	; 0x803e52 <tinyPotential_potential+0x1>
     b94:	80 93 53 3e 	sts	0x3E53, r24	; 0x803e53 <tinyPotential_potential+0x2>
     b98:	90 93 54 3e 	sts	0x3E54, r25	; 0x803e54 <tinyPotential_potential+0x3>
	
	// Let the axon affect the potential
	// This is also where we decide whether or not the axon should fire
	tinyPotential_potential = tinyAxon_update_potential(tinyPotential_potential);
     b9c:	fc dd       	rcall	.-1032   	; 0x796 <tinyAxon_update_potential>
     b9e:	60 93 51 3e 	sts	0x3E51, r22	; 0x803e51 <tinyPotential_potential>
     ba2:	70 93 52 3e 	sts	0x3E52, r23	; 0x803e52 <tinyPotential_potential+0x1>
     ba6:	80 93 53 3e 	sts	0x3E53, r24	; 0x803e53 <tinyPotential_potential+0x2>
     baa:	90 93 54 3e 	sts	0x3E54, r25	; 0x803e54 <tinyPotential_potential+0x3>

	//Update the led
	potential_to_RGB_update_LEDs(tinyPotential_potential);
     bae:	a5 dc       	rcall	.-1718   	; 0x4fa <potential_to_RGB_update_LEDs>
     bb0:	08 95       	ret

00000bb2 <__subsf3>:
     bb2:	50 58       	subi	r21, 0x80	; 128

00000bb4 <__addsf3>:
     bb4:	bb 27       	eor	r27, r27
     bb6:	aa 27       	eor	r26, r26
     bb8:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <__addsf3x>
     bbc:	0c 94 cc 07 	jmp	0xf98	; 0xf98 <__fp_round>
     bc0:	0e 94 be 07 	call	0xf7c	; 0xf7c <__fp_pscA>
     bc4:	38 f0       	brcs	.+14     	; 0xbd4 <__addsf3+0x20>
     bc6:	0e 94 c5 07 	call	0xf8a	; 0xf8a <__fp_pscB>
     bca:	20 f0       	brcs	.+8      	; 0xbd4 <__addsf3+0x20>
     bcc:	39 f4       	brne	.+14     	; 0xbdc <__addsf3+0x28>
     bce:	9f 3f       	cpi	r25, 0xFF	; 255
     bd0:	19 f4       	brne	.+6      	; 0xbd8 <__addsf3+0x24>
     bd2:	26 f4       	brtc	.+8      	; 0xbdc <__addsf3+0x28>
     bd4:	0c 94 94 07 	jmp	0xf28	; 0xf28 <__fp_nan>
     bd8:	0e f4       	brtc	.+2      	; 0xbdc <__addsf3+0x28>
     bda:	e0 95       	com	r30
     bdc:	e7 fb       	bst	r30, 7
     bde:	0c 94 8e 07 	jmp	0xf1c	; 0xf1c <__fp_inf>

00000be2 <__addsf3x>:
     be2:	e9 2f       	mov	r30, r25
     be4:	0e 94 dd 07 	call	0xfba	; 0xfba <__fp_split3>
     be8:	58 f3       	brcs	.-42     	; 0xbc0 <__addsf3+0xc>
     bea:	ba 17       	cp	r27, r26
     bec:	62 07       	cpc	r22, r18
     bee:	73 07       	cpc	r23, r19
     bf0:	84 07       	cpc	r24, r20
     bf2:	95 07       	cpc	r25, r21
     bf4:	20 f0       	brcs	.+8      	; 0xbfe <__addsf3x+0x1c>
     bf6:	79 f4       	brne	.+30     	; 0xc16 <__addsf3x+0x34>
     bf8:	a6 f5       	brtc	.+104    	; 0xc62 <__addsf3x+0x80>
     bfa:	0c 94 ff 07 	jmp	0xffe	; 0xffe <__fp_zero>
     bfe:	0e f4       	brtc	.+2      	; 0xc02 <__addsf3x+0x20>
     c00:	e0 95       	com	r30
     c02:	0b 2e       	mov	r0, r27
     c04:	ba 2f       	mov	r27, r26
     c06:	a0 2d       	mov	r26, r0
     c08:	0b 01       	movw	r0, r22
     c0a:	b9 01       	movw	r22, r18
     c0c:	90 01       	movw	r18, r0
     c0e:	0c 01       	movw	r0, r24
     c10:	ca 01       	movw	r24, r20
     c12:	a0 01       	movw	r20, r0
     c14:	11 24       	eor	r1, r1
     c16:	ff 27       	eor	r31, r31
     c18:	59 1b       	sub	r21, r25
     c1a:	99 f0       	breq	.+38     	; 0xc42 <__addsf3x+0x60>
     c1c:	59 3f       	cpi	r21, 0xF9	; 249
     c1e:	50 f4       	brcc	.+20     	; 0xc34 <__addsf3x+0x52>
     c20:	50 3e       	cpi	r21, 0xE0	; 224
     c22:	68 f1       	brcs	.+90     	; 0xc7e <__addsf3x+0x9c>
     c24:	1a 16       	cp	r1, r26
     c26:	f0 40       	sbci	r31, 0x00	; 0
     c28:	a2 2f       	mov	r26, r18
     c2a:	23 2f       	mov	r18, r19
     c2c:	34 2f       	mov	r19, r20
     c2e:	44 27       	eor	r20, r20
     c30:	58 5f       	subi	r21, 0xF8	; 248
     c32:	f3 cf       	rjmp	.-26     	; 0xc1a <__addsf3x+0x38>
     c34:	46 95       	lsr	r20
     c36:	37 95       	ror	r19
     c38:	27 95       	ror	r18
     c3a:	a7 95       	ror	r26
     c3c:	f0 40       	sbci	r31, 0x00	; 0
     c3e:	53 95       	inc	r21
     c40:	c9 f7       	brne	.-14     	; 0xc34 <__addsf3x+0x52>
     c42:	7e f4       	brtc	.+30     	; 0xc62 <__addsf3x+0x80>
     c44:	1f 16       	cp	r1, r31
     c46:	ba 0b       	sbc	r27, r26
     c48:	62 0b       	sbc	r22, r18
     c4a:	73 0b       	sbc	r23, r19
     c4c:	84 0b       	sbc	r24, r20
     c4e:	ba f0       	brmi	.+46     	; 0xc7e <__addsf3x+0x9c>
     c50:	91 50       	subi	r25, 0x01	; 1
     c52:	a1 f0       	breq	.+40     	; 0xc7c <__addsf3x+0x9a>
     c54:	ff 0f       	add	r31, r31
     c56:	bb 1f       	adc	r27, r27
     c58:	66 1f       	adc	r22, r22
     c5a:	77 1f       	adc	r23, r23
     c5c:	88 1f       	adc	r24, r24
     c5e:	c2 f7       	brpl	.-16     	; 0xc50 <__addsf3x+0x6e>
     c60:	0e c0       	rjmp	.+28     	; 0xc7e <__addsf3x+0x9c>
     c62:	ba 0f       	add	r27, r26
     c64:	62 1f       	adc	r22, r18
     c66:	73 1f       	adc	r23, r19
     c68:	84 1f       	adc	r24, r20
     c6a:	48 f4       	brcc	.+18     	; 0xc7e <__addsf3x+0x9c>
     c6c:	87 95       	ror	r24
     c6e:	77 95       	ror	r23
     c70:	67 95       	ror	r22
     c72:	b7 95       	ror	r27
     c74:	f7 95       	ror	r31
     c76:	9e 3f       	cpi	r25, 0xFE	; 254
     c78:	08 f0       	brcs	.+2      	; 0xc7c <__addsf3x+0x9a>
     c7a:	b0 cf       	rjmp	.-160    	; 0xbdc <__addsf3+0x28>
     c7c:	93 95       	inc	r25
     c7e:	88 0f       	add	r24, r24
     c80:	08 f0       	brcs	.+2      	; 0xc84 <__addsf3x+0xa2>
     c82:	99 27       	eor	r25, r25
     c84:	ee 0f       	add	r30, r30
     c86:	97 95       	ror	r25
     c88:	87 95       	ror	r24
     c8a:	08 95       	ret

00000c8c <__cmpsf2>:
     c8c:	0e 94 6a 07 	call	0xed4	; 0xed4 <__fp_cmp>
     c90:	08 f4       	brcc	.+2      	; 0xc94 <__cmpsf2+0x8>
     c92:	81 e0       	ldi	r24, 0x01	; 1
     c94:	08 95       	ret

00000c96 <__divsf3>:
     c96:	0e 94 5f 06 	call	0xcbe	; 0xcbe <__divsf3x>
     c9a:	0c 94 cc 07 	jmp	0xf98	; 0xf98 <__fp_round>
     c9e:	0e 94 c5 07 	call	0xf8a	; 0xf8a <__fp_pscB>
     ca2:	58 f0       	brcs	.+22     	; 0xcba <__divsf3+0x24>
     ca4:	0e 94 be 07 	call	0xf7c	; 0xf7c <__fp_pscA>
     ca8:	40 f0       	brcs	.+16     	; 0xcba <__divsf3+0x24>
     caa:	29 f4       	brne	.+10     	; 0xcb6 <__divsf3+0x20>
     cac:	5f 3f       	cpi	r21, 0xFF	; 255
     cae:	29 f0       	breq	.+10     	; 0xcba <__divsf3+0x24>
     cb0:	0c 94 8e 07 	jmp	0xf1c	; 0xf1c <__fp_inf>
     cb4:	51 11       	cpse	r21, r1
     cb6:	0c 94 00 08 	jmp	0x1000	; 0x1000 <__fp_szero>
     cba:	0c 94 94 07 	jmp	0xf28	; 0xf28 <__fp_nan>

00000cbe <__divsf3x>:
     cbe:	0e 94 dd 07 	call	0xfba	; 0xfba <__fp_split3>
     cc2:	68 f3       	brcs	.-38     	; 0xc9e <__divsf3+0x8>

00000cc4 <__divsf3_pse>:
     cc4:	99 23       	and	r25, r25
     cc6:	b1 f3       	breq	.-20     	; 0xcb4 <__divsf3+0x1e>
     cc8:	55 23       	and	r21, r21
     cca:	91 f3       	breq	.-28     	; 0xcb0 <__divsf3+0x1a>
     ccc:	95 1b       	sub	r25, r21
     cce:	55 0b       	sbc	r21, r21
     cd0:	bb 27       	eor	r27, r27
     cd2:	aa 27       	eor	r26, r26
     cd4:	62 17       	cp	r22, r18
     cd6:	73 07       	cpc	r23, r19
     cd8:	84 07       	cpc	r24, r20
     cda:	38 f0       	brcs	.+14     	; 0xcea <__divsf3_pse+0x26>
     cdc:	9f 5f       	subi	r25, 0xFF	; 255
     cde:	5f 4f       	sbci	r21, 0xFF	; 255
     ce0:	22 0f       	add	r18, r18
     ce2:	33 1f       	adc	r19, r19
     ce4:	44 1f       	adc	r20, r20
     ce6:	aa 1f       	adc	r26, r26
     ce8:	a9 f3       	breq	.-22     	; 0xcd4 <__divsf3_pse+0x10>
     cea:	35 d0       	rcall	.+106    	; 0xd56 <__divsf3_pse+0x92>
     cec:	0e 2e       	mov	r0, r30
     cee:	3a f0       	brmi	.+14     	; 0xcfe <__divsf3_pse+0x3a>
     cf0:	e0 e8       	ldi	r30, 0x80	; 128
     cf2:	32 d0       	rcall	.+100    	; 0xd58 <__divsf3_pse+0x94>
     cf4:	91 50       	subi	r25, 0x01	; 1
     cf6:	50 40       	sbci	r21, 0x00	; 0
     cf8:	e6 95       	lsr	r30
     cfa:	00 1c       	adc	r0, r0
     cfc:	ca f7       	brpl	.-14     	; 0xcf0 <__divsf3_pse+0x2c>
     cfe:	2b d0       	rcall	.+86     	; 0xd56 <__divsf3_pse+0x92>
     d00:	fe 2f       	mov	r31, r30
     d02:	29 d0       	rcall	.+82     	; 0xd56 <__divsf3_pse+0x92>
     d04:	66 0f       	add	r22, r22
     d06:	77 1f       	adc	r23, r23
     d08:	88 1f       	adc	r24, r24
     d0a:	bb 1f       	adc	r27, r27
     d0c:	26 17       	cp	r18, r22
     d0e:	37 07       	cpc	r19, r23
     d10:	48 07       	cpc	r20, r24
     d12:	ab 07       	cpc	r26, r27
     d14:	b0 e8       	ldi	r27, 0x80	; 128
     d16:	09 f0       	breq	.+2      	; 0xd1a <__divsf3_pse+0x56>
     d18:	bb 0b       	sbc	r27, r27
     d1a:	80 2d       	mov	r24, r0
     d1c:	bf 01       	movw	r22, r30
     d1e:	ff 27       	eor	r31, r31
     d20:	93 58       	subi	r25, 0x83	; 131
     d22:	5f 4f       	sbci	r21, 0xFF	; 255
     d24:	3a f0       	brmi	.+14     	; 0xd34 <__divsf3_pse+0x70>
     d26:	9e 3f       	cpi	r25, 0xFE	; 254
     d28:	51 05       	cpc	r21, r1
     d2a:	78 f0       	brcs	.+30     	; 0xd4a <__divsf3_pse+0x86>
     d2c:	0c 94 8e 07 	jmp	0xf1c	; 0xf1c <__fp_inf>
     d30:	0c 94 00 08 	jmp	0x1000	; 0x1000 <__fp_szero>
     d34:	5f 3f       	cpi	r21, 0xFF	; 255
     d36:	e4 f3       	brlt	.-8      	; 0xd30 <__divsf3_pse+0x6c>
     d38:	98 3e       	cpi	r25, 0xE8	; 232
     d3a:	d4 f3       	brlt	.-12     	; 0xd30 <__divsf3_pse+0x6c>
     d3c:	86 95       	lsr	r24
     d3e:	77 95       	ror	r23
     d40:	67 95       	ror	r22
     d42:	b7 95       	ror	r27
     d44:	f7 95       	ror	r31
     d46:	9f 5f       	subi	r25, 0xFF	; 255
     d48:	c9 f7       	brne	.-14     	; 0xd3c <__divsf3_pse+0x78>
     d4a:	88 0f       	add	r24, r24
     d4c:	91 1d       	adc	r25, r1
     d4e:	96 95       	lsr	r25
     d50:	87 95       	ror	r24
     d52:	97 f9       	bld	r25, 7
     d54:	08 95       	ret
     d56:	e1 e0       	ldi	r30, 0x01	; 1
     d58:	66 0f       	add	r22, r22
     d5a:	77 1f       	adc	r23, r23
     d5c:	88 1f       	adc	r24, r24
     d5e:	bb 1f       	adc	r27, r27
     d60:	62 17       	cp	r22, r18
     d62:	73 07       	cpc	r23, r19
     d64:	84 07       	cpc	r24, r20
     d66:	ba 07       	cpc	r27, r26
     d68:	20 f0       	brcs	.+8      	; 0xd72 <__divsf3_pse+0xae>
     d6a:	62 1b       	sub	r22, r18
     d6c:	73 0b       	sbc	r23, r19
     d6e:	84 0b       	sbc	r24, r20
     d70:	ba 0b       	sbc	r27, r26
     d72:	ee 1f       	adc	r30, r30
     d74:	88 f7       	brcc	.-30     	; 0xd58 <__divsf3_pse+0x94>
     d76:	e0 95       	com	r30
     d78:	08 95       	ret
     d7a:	29 f4       	brne	.+10     	; 0xd86 <__divsf3_pse+0xc2>
     d7c:	16 f0       	brts	.+4      	; 0xd82 <__divsf3_pse+0xbe>
     d7e:	0c 94 8e 07 	jmp	0xf1c	; 0xf1c <__fp_inf>
     d82:	0c 94 ff 07 	jmp	0xffe	; 0xffe <__fp_zero>
     d86:	0c 94 94 07 	jmp	0xf28	; 0xf28 <__fp_nan>

00000d8a <exp>:
     d8a:	0e 94 e5 07 	call	0xfca	; 0xfca <__fp_splitA>
     d8e:	a8 f3       	brcs	.-22     	; 0xd7a <__divsf3_pse+0xb6>
     d90:	96 38       	cpi	r25, 0x86	; 134
     d92:	a0 f7       	brcc	.-24     	; 0xd7c <__divsf3_pse+0xb8>
     d94:	07 f8       	bld	r0, 7
     d96:	0f 92       	push	r0
     d98:	e8 94       	clt
     d9a:	2b e3       	ldi	r18, 0x3B	; 59
     d9c:	3a ea       	ldi	r19, 0xAA	; 170
     d9e:	48 eb       	ldi	r20, 0xB8	; 184
     da0:	5f e7       	ldi	r21, 0x7F	; 127
     da2:	0e 94 97 08 	call	0x112e	; 0x112e <__mulsf3_pse>
     da6:	0f 92       	push	r0
     da8:	0f 92       	push	r0
     daa:	0f 92       	push	r0
     dac:	4d b7       	in	r20, 0x3d	; 61
     dae:	5e b7       	in	r21, 0x3e	; 62
     db0:	0f 92       	push	r0
     db2:	0e 94 4d 08 	call	0x109a	; 0x109a <modf>
     db6:	e4 e3       	ldi	r30, 0x34	; 52
     db8:	f0 e0       	ldi	r31, 0x00	; 0
     dba:	0e 94 97 07 	call	0xf2e	; 0xf2e <__fp_powser>
     dbe:	4f 91       	pop	r20
     dc0:	5f 91       	pop	r21
     dc2:	ef 91       	pop	r30
     dc4:	ff 91       	pop	r31
     dc6:	e5 95       	asr	r30
     dc8:	ee 1f       	adc	r30, r30
     dca:	ff 1f       	adc	r31, r31
     dcc:	49 f0       	breq	.+18     	; 0xde0 <exp+0x56>
     dce:	fe 57       	subi	r31, 0x7E	; 126
     dd0:	e0 68       	ori	r30, 0x80	; 128
     dd2:	44 27       	eor	r20, r20
     dd4:	ee 0f       	add	r30, r30
     dd6:	44 1f       	adc	r20, r20
     dd8:	fa 95       	dec	r31
     dda:	e1 f7       	brne	.-8      	; 0xdd4 <exp+0x4a>
     ddc:	41 95       	neg	r20
     dde:	55 0b       	sbc	r21, r21
     de0:	0e 94 17 08 	call	0x102e	; 0x102e <ldexp>
     de4:	0f 90       	pop	r0
     de6:	07 fe       	sbrs	r0, 7
     de8:	0c 94 0b 08 	jmp	0x1016	; 0x1016 <inverse>
     dec:	08 95       	ret

00000dee <__fixsfsi>:
     dee:	0e 94 fe 06 	call	0xdfc	; 0xdfc <__fixunssfsi>
     df2:	68 94       	set
     df4:	b1 11       	cpse	r27, r1
     df6:	0c 94 00 08 	jmp	0x1000	; 0x1000 <__fp_szero>
     dfa:	08 95       	ret

00000dfc <__fixunssfsi>:
     dfc:	0e 94 e5 07 	call	0xfca	; 0xfca <__fp_splitA>
     e00:	88 f0       	brcs	.+34     	; 0xe24 <__fixunssfsi+0x28>
     e02:	9f 57       	subi	r25, 0x7F	; 127
     e04:	98 f0       	brcs	.+38     	; 0xe2c <__fixunssfsi+0x30>
     e06:	b9 2f       	mov	r27, r25
     e08:	99 27       	eor	r25, r25
     e0a:	b7 51       	subi	r27, 0x17	; 23
     e0c:	b0 f0       	brcs	.+44     	; 0xe3a <__fixunssfsi+0x3e>
     e0e:	e1 f0       	breq	.+56     	; 0xe48 <__fixunssfsi+0x4c>
     e10:	66 0f       	add	r22, r22
     e12:	77 1f       	adc	r23, r23
     e14:	88 1f       	adc	r24, r24
     e16:	99 1f       	adc	r25, r25
     e18:	1a f0       	brmi	.+6      	; 0xe20 <__fixunssfsi+0x24>
     e1a:	ba 95       	dec	r27
     e1c:	c9 f7       	brne	.-14     	; 0xe10 <__fixunssfsi+0x14>
     e1e:	14 c0       	rjmp	.+40     	; 0xe48 <__fixunssfsi+0x4c>
     e20:	b1 30       	cpi	r27, 0x01	; 1
     e22:	91 f0       	breq	.+36     	; 0xe48 <__fixunssfsi+0x4c>
     e24:	0e 94 ff 07 	call	0xffe	; 0xffe <__fp_zero>
     e28:	b1 e0       	ldi	r27, 0x01	; 1
     e2a:	08 95       	ret
     e2c:	0c 94 ff 07 	jmp	0xffe	; 0xffe <__fp_zero>
     e30:	67 2f       	mov	r22, r23
     e32:	78 2f       	mov	r23, r24
     e34:	88 27       	eor	r24, r24
     e36:	b8 5f       	subi	r27, 0xF8	; 248
     e38:	39 f0       	breq	.+14     	; 0xe48 <__fixunssfsi+0x4c>
     e3a:	b9 3f       	cpi	r27, 0xF9	; 249
     e3c:	cc f3       	brlt	.-14     	; 0xe30 <__fixunssfsi+0x34>
     e3e:	86 95       	lsr	r24
     e40:	77 95       	ror	r23
     e42:	67 95       	ror	r22
     e44:	b3 95       	inc	r27
     e46:	d9 f7       	brne	.-10     	; 0xe3e <__fixunssfsi+0x42>
     e48:	3e f4       	brtc	.+14     	; 0xe58 <__fixunssfsi+0x5c>
     e4a:	90 95       	com	r25
     e4c:	80 95       	com	r24
     e4e:	70 95       	com	r23
     e50:	61 95       	neg	r22
     e52:	7f 4f       	sbci	r23, 0xFF	; 255
     e54:	8f 4f       	sbci	r24, 0xFF	; 255
     e56:	9f 4f       	sbci	r25, 0xFF	; 255
     e58:	08 95       	ret

00000e5a <__floatunsisf>:
     e5a:	e8 94       	clt
     e5c:	09 c0       	rjmp	.+18     	; 0xe70 <__floatsisf+0x12>

00000e5e <__floatsisf>:
     e5e:	97 fb       	bst	r25, 7
     e60:	3e f4       	brtc	.+14     	; 0xe70 <__floatsisf+0x12>
     e62:	90 95       	com	r25
     e64:	80 95       	com	r24
     e66:	70 95       	com	r23
     e68:	61 95       	neg	r22
     e6a:	7f 4f       	sbci	r23, 0xFF	; 255
     e6c:	8f 4f       	sbci	r24, 0xFF	; 255
     e6e:	9f 4f       	sbci	r25, 0xFF	; 255
     e70:	99 23       	and	r25, r25
     e72:	a9 f0       	breq	.+42     	; 0xe9e <__floatsisf+0x40>
     e74:	f9 2f       	mov	r31, r25
     e76:	96 e9       	ldi	r25, 0x96	; 150
     e78:	bb 27       	eor	r27, r27
     e7a:	93 95       	inc	r25
     e7c:	f6 95       	lsr	r31
     e7e:	87 95       	ror	r24
     e80:	77 95       	ror	r23
     e82:	67 95       	ror	r22
     e84:	b7 95       	ror	r27
     e86:	f1 11       	cpse	r31, r1
     e88:	f8 cf       	rjmp	.-16     	; 0xe7a <__floatsisf+0x1c>
     e8a:	fa f4       	brpl	.+62     	; 0xeca <__floatsisf+0x6c>
     e8c:	bb 0f       	add	r27, r27
     e8e:	11 f4       	brne	.+4      	; 0xe94 <__floatsisf+0x36>
     e90:	60 ff       	sbrs	r22, 0
     e92:	1b c0       	rjmp	.+54     	; 0xeca <__floatsisf+0x6c>
     e94:	6f 5f       	subi	r22, 0xFF	; 255
     e96:	7f 4f       	sbci	r23, 0xFF	; 255
     e98:	8f 4f       	sbci	r24, 0xFF	; 255
     e9a:	9f 4f       	sbci	r25, 0xFF	; 255
     e9c:	16 c0       	rjmp	.+44     	; 0xeca <__floatsisf+0x6c>
     e9e:	88 23       	and	r24, r24
     ea0:	11 f0       	breq	.+4      	; 0xea6 <__floatsisf+0x48>
     ea2:	96 e9       	ldi	r25, 0x96	; 150
     ea4:	11 c0       	rjmp	.+34     	; 0xec8 <__floatsisf+0x6a>
     ea6:	77 23       	and	r23, r23
     ea8:	21 f0       	breq	.+8      	; 0xeb2 <__floatsisf+0x54>
     eaa:	9e e8       	ldi	r25, 0x8E	; 142
     eac:	87 2f       	mov	r24, r23
     eae:	76 2f       	mov	r23, r22
     eb0:	05 c0       	rjmp	.+10     	; 0xebc <__floatsisf+0x5e>
     eb2:	66 23       	and	r22, r22
     eb4:	71 f0       	breq	.+28     	; 0xed2 <__floatsisf+0x74>
     eb6:	96 e8       	ldi	r25, 0x86	; 134
     eb8:	86 2f       	mov	r24, r22
     eba:	70 e0       	ldi	r23, 0x00	; 0
     ebc:	60 e0       	ldi	r22, 0x00	; 0
     ebe:	2a f0       	brmi	.+10     	; 0xeca <__floatsisf+0x6c>
     ec0:	9a 95       	dec	r25
     ec2:	66 0f       	add	r22, r22
     ec4:	77 1f       	adc	r23, r23
     ec6:	88 1f       	adc	r24, r24
     ec8:	da f7       	brpl	.-10     	; 0xec0 <__floatsisf+0x62>
     eca:	88 0f       	add	r24, r24
     ecc:	96 95       	lsr	r25
     ece:	87 95       	ror	r24
     ed0:	97 f9       	bld	r25, 7
     ed2:	08 95       	ret

00000ed4 <__fp_cmp>:
     ed4:	99 0f       	add	r25, r25
     ed6:	00 08       	sbc	r0, r0
     ed8:	55 0f       	add	r21, r21
     eda:	aa 0b       	sbc	r26, r26
     edc:	e0 e8       	ldi	r30, 0x80	; 128
     ede:	fe ef       	ldi	r31, 0xFE	; 254
     ee0:	16 16       	cp	r1, r22
     ee2:	17 06       	cpc	r1, r23
     ee4:	e8 07       	cpc	r30, r24
     ee6:	f9 07       	cpc	r31, r25
     ee8:	c0 f0       	brcs	.+48     	; 0xf1a <__fp_cmp+0x46>
     eea:	12 16       	cp	r1, r18
     eec:	13 06       	cpc	r1, r19
     eee:	e4 07       	cpc	r30, r20
     ef0:	f5 07       	cpc	r31, r21
     ef2:	98 f0       	brcs	.+38     	; 0xf1a <__fp_cmp+0x46>
     ef4:	62 1b       	sub	r22, r18
     ef6:	73 0b       	sbc	r23, r19
     ef8:	84 0b       	sbc	r24, r20
     efa:	95 0b       	sbc	r25, r21
     efc:	39 f4       	brne	.+14     	; 0xf0c <__fp_cmp+0x38>
     efe:	0a 26       	eor	r0, r26
     f00:	61 f0       	breq	.+24     	; 0xf1a <__fp_cmp+0x46>
     f02:	23 2b       	or	r18, r19
     f04:	24 2b       	or	r18, r20
     f06:	25 2b       	or	r18, r21
     f08:	21 f4       	brne	.+8      	; 0xf12 <__fp_cmp+0x3e>
     f0a:	08 95       	ret
     f0c:	0a 26       	eor	r0, r26
     f0e:	09 f4       	brne	.+2      	; 0xf12 <__fp_cmp+0x3e>
     f10:	a1 40       	sbci	r26, 0x01	; 1
     f12:	a6 95       	lsr	r26
     f14:	8f ef       	ldi	r24, 0xFF	; 255
     f16:	81 1d       	adc	r24, r1
     f18:	81 1d       	adc	r24, r1
     f1a:	08 95       	ret

00000f1c <__fp_inf>:
     f1c:	97 f9       	bld	r25, 7
     f1e:	9f 67       	ori	r25, 0x7F	; 127
     f20:	80 e8       	ldi	r24, 0x80	; 128
     f22:	70 e0       	ldi	r23, 0x00	; 0
     f24:	60 e0       	ldi	r22, 0x00	; 0
     f26:	08 95       	ret

00000f28 <__fp_nan>:
     f28:	9f ef       	ldi	r25, 0xFF	; 255
     f2a:	80 ec       	ldi	r24, 0xC0	; 192
     f2c:	08 95       	ret

00000f2e <__fp_powser>:
     f2e:	df 93       	push	r29
     f30:	cf 93       	push	r28
     f32:	1f 93       	push	r17
     f34:	0f 93       	push	r16
     f36:	ff 92       	push	r15
     f38:	ef 92       	push	r14
     f3a:	df 92       	push	r13
     f3c:	7b 01       	movw	r14, r22
     f3e:	8c 01       	movw	r16, r24
     f40:	68 94       	set
     f42:	06 c0       	rjmp	.+12     	; 0xf50 <__fp_powser+0x22>
     f44:	da 2e       	mov	r13, r26
     f46:	ef 01       	movw	r28, r30
     f48:	0e 94 94 08 	call	0x1128	; 0x1128 <__mulsf3x>
     f4c:	fe 01       	movw	r30, r28
     f4e:	e8 94       	clt
     f50:	a5 91       	lpm	r26, Z+
     f52:	25 91       	lpm	r18, Z+
     f54:	35 91       	lpm	r19, Z+
     f56:	45 91       	lpm	r20, Z+
     f58:	55 91       	lpm	r21, Z+
     f5a:	a6 f3       	brts	.-24     	; 0xf44 <__fp_powser+0x16>
     f5c:	ef 01       	movw	r28, r30
     f5e:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <__addsf3x>
     f62:	fe 01       	movw	r30, r28
     f64:	97 01       	movw	r18, r14
     f66:	a8 01       	movw	r20, r16
     f68:	da 94       	dec	r13
     f6a:	69 f7       	brne	.-38     	; 0xf46 <__fp_powser+0x18>
     f6c:	df 90       	pop	r13
     f6e:	ef 90       	pop	r14
     f70:	ff 90       	pop	r15
     f72:	0f 91       	pop	r16
     f74:	1f 91       	pop	r17
     f76:	cf 91       	pop	r28
     f78:	df 91       	pop	r29
     f7a:	08 95       	ret

00000f7c <__fp_pscA>:
     f7c:	00 24       	eor	r0, r0
     f7e:	0a 94       	dec	r0
     f80:	16 16       	cp	r1, r22
     f82:	17 06       	cpc	r1, r23
     f84:	18 06       	cpc	r1, r24
     f86:	09 06       	cpc	r0, r25
     f88:	08 95       	ret

00000f8a <__fp_pscB>:
     f8a:	00 24       	eor	r0, r0
     f8c:	0a 94       	dec	r0
     f8e:	12 16       	cp	r1, r18
     f90:	13 06       	cpc	r1, r19
     f92:	14 06       	cpc	r1, r20
     f94:	05 06       	cpc	r0, r21
     f96:	08 95       	ret

00000f98 <__fp_round>:
     f98:	09 2e       	mov	r0, r25
     f9a:	03 94       	inc	r0
     f9c:	00 0c       	add	r0, r0
     f9e:	11 f4       	brne	.+4      	; 0xfa4 <__fp_round+0xc>
     fa0:	88 23       	and	r24, r24
     fa2:	52 f0       	brmi	.+20     	; 0xfb8 <__fp_round+0x20>
     fa4:	bb 0f       	add	r27, r27
     fa6:	40 f4       	brcc	.+16     	; 0xfb8 <__fp_round+0x20>
     fa8:	bf 2b       	or	r27, r31
     faa:	11 f4       	brne	.+4      	; 0xfb0 <__fp_round+0x18>
     fac:	60 ff       	sbrs	r22, 0
     fae:	04 c0       	rjmp	.+8      	; 0xfb8 <__fp_round+0x20>
     fb0:	6f 5f       	subi	r22, 0xFF	; 255
     fb2:	7f 4f       	sbci	r23, 0xFF	; 255
     fb4:	8f 4f       	sbci	r24, 0xFF	; 255
     fb6:	9f 4f       	sbci	r25, 0xFF	; 255
     fb8:	08 95       	ret

00000fba <__fp_split3>:
     fba:	57 fd       	sbrc	r21, 7
     fbc:	90 58       	subi	r25, 0x80	; 128
     fbe:	44 0f       	add	r20, r20
     fc0:	55 1f       	adc	r21, r21
     fc2:	59 f0       	breq	.+22     	; 0xfda <__fp_splitA+0x10>
     fc4:	5f 3f       	cpi	r21, 0xFF	; 255
     fc6:	71 f0       	breq	.+28     	; 0xfe4 <__fp_splitA+0x1a>
     fc8:	47 95       	ror	r20

00000fca <__fp_splitA>:
     fca:	88 0f       	add	r24, r24
     fcc:	97 fb       	bst	r25, 7
     fce:	99 1f       	adc	r25, r25
     fd0:	61 f0       	breq	.+24     	; 0xfea <__fp_splitA+0x20>
     fd2:	9f 3f       	cpi	r25, 0xFF	; 255
     fd4:	79 f0       	breq	.+30     	; 0xff4 <__fp_splitA+0x2a>
     fd6:	87 95       	ror	r24
     fd8:	08 95       	ret
     fda:	12 16       	cp	r1, r18
     fdc:	13 06       	cpc	r1, r19
     fde:	14 06       	cpc	r1, r20
     fe0:	55 1f       	adc	r21, r21
     fe2:	f2 cf       	rjmp	.-28     	; 0xfc8 <__fp_split3+0xe>
     fe4:	46 95       	lsr	r20
     fe6:	f1 df       	rcall	.-30     	; 0xfca <__fp_splitA>
     fe8:	08 c0       	rjmp	.+16     	; 0xffa <__fp_splitA+0x30>
     fea:	16 16       	cp	r1, r22
     fec:	17 06       	cpc	r1, r23
     fee:	18 06       	cpc	r1, r24
     ff0:	99 1f       	adc	r25, r25
     ff2:	f1 cf       	rjmp	.-30     	; 0xfd6 <__fp_splitA+0xc>
     ff4:	86 95       	lsr	r24
     ff6:	71 05       	cpc	r23, r1
     ff8:	61 05       	cpc	r22, r1
     ffa:	08 94       	sec
     ffc:	08 95       	ret

00000ffe <__fp_zero>:
     ffe:	e8 94       	clt

00001000 <__fp_szero>:
    1000:	bb 27       	eor	r27, r27
    1002:	66 27       	eor	r22, r22
    1004:	77 27       	eor	r23, r23
    1006:	cb 01       	movw	r24, r22
    1008:	97 f9       	bld	r25, 7
    100a:	08 95       	ret

0000100c <__gesf2>:
    100c:	0e 94 6a 07 	call	0xed4	; 0xed4 <__fp_cmp>
    1010:	08 f4       	brcc	.+2      	; 0x1014 <__gesf2+0x8>
    1012:	8f ef       	ldi	r24, 0xFF	; 255
    1014:	08 95       	ret

00001016 <inverse>:
    1016:	9b 01       	movw	r18, r22
    1018:	ac 01       	movw	r20, r24
    101a:	60 e0       	ldi	r22, 0x00	; 0
    101c:	70 e0       	ldi	r23, 0x00	; 0
    101e:	80 e8       	ldi	r24, 0x80	; 128
    1020:	9f e3       	ldi	r25, 0x3F	; 63
    1022:	0c 94 4b 06 	jmp	0xc96	; 0xc96 <__divsf3>
    1026:	0c 94 8e 07 	jmp	0xf1c	; 0xf1c <__fp_inf>
    102a:	0c 94 2d 09 	jmp	0x125a	; 0x125a <__fp_mpack>

0000102e <ldexp>:
    102e:	0e 94 e5 07 	call	0xfca	; 0xfca <__fp_splitA>
    1032:	d8 f3       	brcs	.-10     	; 0x102a <inverse+0x14>
    1034:	99 23       	and	r25, r25
    1036:	c9 f3       	breq	.-14     	; 0x102a <inverse+0x14>
    1038:	94 0f       	add	r25, r20
    103a:	51 1d       	adc	r21, r1
    103c:	a3 f3       	brvs	.-24     	; 0x1026 <inverse+0x10>
    103e:	91 50       	subi	r25, 0x01	; 1
    1040:	50 40       	sbci	r21, 0x00	; 0
    1042:	94 f0       	brlt	.+36     	; 0x1068 <ldexp+0x3a>
    1044:	59 f0       	breq	.+22     	; 0x105c <ldexp+0x2e>
    1046:	88 23       	and	r24, r24
    1048:	32 f0       	brmi	.+12     	; 0x1056 <ldexp+0x28>
    104a:	66 0f       	add	r22, r22
    104c:	77 1f       	adc	r23, r23
    104e:	88 1f       	adc	r24, r24
    1050:	91 50       	subi	r25, 0x01	; 1
    1052:	50 40       	sbci	r21, 0x00	; 0
    1054:	c1 f7       	brne	.-16     	; 0x1046 <ldexp+0x18>
    1056:	9e 3f       	cpi	r25, 0xFE	; 254
    1058:	51 05       	cpc	r21, r1
    105a:	2c f7       	brge	.-54     	; 0x1026 <inverse+0x10>
    105c:	88 0f       	add	r24, r24
    105e:	91 1d       	adc	r25, r1
    1060:	96 95       	lsr	r25
    1062:	87 95       	ror	r24
    1064:	97 f9       	bld	r25, 7
    1066:	08 95       	ret
    1068:	5f 3f       	cpi	r21, 0xFF	; 255
    106a:	ac f0       	brlt	.+42     	; 0x1096 <ldexp+0x68>
    106c:	98 3e       	cpi	r25, 0xE8	; 232
    106e:	9c f0       	brlt	.+38     	; 0x1096 <ldexp+0x68>
    1070:	bb 27       	eor	r27, r27
    1072:	86 95       	lsr	r24
    1074:	77 95       	ror	r23
    1076:	67 95       	ror	r22
    1078:	b7 95       	ror	r27
    107a:	08 f4       	brcc	.+2      	; 0x107e <ldexp+0x50>
    107c:	b1 60       	ori	r27, 0x01	; 1
    107e:	93 95       	inc	r25
    1080:	c1 f7       	brne	.-16     	; 0x1072 <ldexp+0x44>
    1082:	bb 0f       	add	r27, r27
    1084:	58 f7       	brcc	.-42     	; 0x105c <ldexp+0x2e>
    1086:	11 f4       	brne	.+4      	; 0x108c <ldexp+0x5e>
    1088:	60 ff       	sbrs	r22, 0
    108a:	e8 cf       	rjmp	.-48     	; 0x105c <ldexp+0x2e>
    108c:	6f 5f       	subi	r22, 0xFF	; 255
    108e:	7f 4f       	sbci	r23, 0xFF	; 255
    1090:	8f 4f       	sbci	r24, 0xFF	; 255
    1092:	9f 4f       	sbci	r25, 0xFF	; 255
    1094:	e3 cf       	rjmp	.-58     	; 0x105c <ldexp+0x2e>
    1096:	0c 94 00 08 	jmp	0x1000	; 0x1000 <__fp_szero>

0000109a <modf>:
    109a:	fa 01       	movw	r30, r20
    109c:	dc 01       	movw	r26, r24
    109e:	aa 0f       	add	r26, r26
    10a0:	bb 1f       	adc	r27, r27
    10a2:	9b 01       	movw	r18, r22
    10a4:	ac 01       	movw	r20, r24
    10a6:	bf 57       	subi	r27, 0x7F	; 127
    10a8:	28 f4       	brcc	.+10     	; 0x10b4 <modf+0x1a>
    10aa:	22 27       	eor	r18, r18
    10ac:	33 27       	eor	r19, r19
    10ae:	44 27       	eor	r20, r20
    10b0:	50 78       	andi	r21, 0x80	; 128
    10b2:	20 c0       	rjmp	.+64     	; 0x10f4 <modf+0x5a>
    10b4:	b7 51       	subi	r27, 0x17	; 23
    10b6:	90 f4       	brcc	.+36     	; 0x10dc <modf+0x42>
    10b8:	ab 2f       	mov	r26, r27
    10ba:	00 24       	eor	r0, r0
    10bc:	46 95       	lsr	r20
    10be:	37 95       	ror	r19
    10c0:	27 95       	ror	r18
    10c2:	01 1c       	adc	r0, r1
    10c4:	a3 95       	inc	r26
    10c6:	d2 f3       	brmi	.-12     	; 0x10bc <modf+0x22>
    10c8:	00 20       	and	r0, r0
    10ca:	71 f0       	breq	.+28     	; 0x10e8 <modf+0x4e>
    10cc:	22 0f       	add	r18, r18
    10ce:	33 1f       	adc	r19, r19
    10d0:	44 1f       	adc	r20, r20
    10d2:	b3 95       	inc	r27
    10d4:	da f3       	brmi	.-10     	; 0x10cc <modf+0x32>
    10d6:	0e d0       	rcall	.+28     	; 0x10f4 <modf+0x5a>
    10d8:	0c 94 d9 05 	jmp	0xbb2	; 0xbb2 <__subsf3>
    10dc:	61 30       	cpi	r22, 0x01	; 1
    10de:	71 05       	cpc	r23, r1
    10e0:	a0 e8       	ldi	r26, 0x80	; 128
    10e2:	8a 07       	cpc	r24, r26
    10e4:	b9 46       	sbci	r27, 0x69	; 105
    10e6:	30 f4       	brcc	.+12     	; 0x10f4 <modf+0x5a>
    10e8:	9b 01       	movw	r18, r22
    10ea:	ac 01       	movw	r20, r24
    10ec:	66 27       	eor	r22, r22
    10ee:	77 27       	eor	r23, r23
    10f0:	88 27       	eor	r24, r24
    10f2:	90 78       	andi	r25, 0x80	; 128
    10f4:	30 96       	adiw	r30, 0x00	; 0
    10f6:	21 f0       	breq	.+8      	; 0x1100 <modf+0x66>
    10f8:	20 83       	st	Z, r18
    10fa:	31 83       	std	Z+1, r19	; 0x01
    10fc:	42 83       	std	Z+2, r20	; 0x02
    10fe:	53 83       	std	Z+3, r21	; 0x03
    1100:	08 95       	ret

00001102 <__mulsf3>:
    1102:	0e 94 94 08 	call	0x1128	; 0x1128 <__mulsf3x>
    1106:	0c 94 cc 07 	jmp	0xf98	; 0xf98 <__fp_round>
    110a:	0e 94 be 07 	call	0xf7c	; 0xf7c <__fp_pscA>
    110e:	38 f0       	brcs	.+14     	; 0x111e <__mulsf3+0x1c>
    1110:	0e 94 c5 07 	call	0xf8a	; 0xf8a <__fp_pscB>
    1114:	20 f0       	brcs	.+8      	; 0x111e <__mulsf3+0x1c>
    1116:	95 23       	and	r25, r21
    1118:	11 f0       	breq	.+4      	; 0x111e <__mulsf3+0x1c>
    111a:	0c 94 8e 07 	jmp	0xf1c	; 0xf1c <__fp_inf>
    111e:	0c 94 94 07 	jmp	0xf28	; 0xf28 <__fp_nan>
    1122:	11 24       	eor	r1, r1
    1124:	0c 94 00 08 	jmp	0x1000	; 0x1000 <__fp_szero>

00001128 <__mulsf3x>:
    1128:	0e 94 dd 07 	call	0xfba	; 0xfba <__fp_split3>
    112c:	70 f3       	brcs	.-36     	; 0x110a <__mulsf3+0x8>

0000112e <__mulsf3_pse>:
    112e:	95 9f       	mul	r25, r21
    1130:	c1 f3       	breq	.-16     	; 0x1122 <__mulsf3+0x20>
    1132:	95 0f       	add	r25, r21
    1134:	50 e0       	ldi	r21, 0x00	; 0
    1136:	55 1f       	adc	r21, r21
    1138:	62 9f       	mul	r22, r18
    113a:	f0 01       	movw	r30, r0
    113c:	72 9f       	mul	r23, r18
    113e:	bb 27       	eor	r27, r27
    1140:	f0 0d       	add	r31, r0
    1142:	b1 1d       	adc	r27, r1
    1144:	63 9f       	mul	r22, r19
    1146:	aa 27       	eor	r26, r26
    1148:	f0 0d       	add	r31, r0
    114a:	b1 1d       	adc	r27, r1
    114c:	aa 1f       	adc	r26, r26
    114e:	64 9f       	mul	r22, r20
    1150:	66 27       	eor	r22, r22
    1152:	b0 0d       	add	r27, r0
    1154:	a1 1d       	adc	r26, r1
    1156:	66 1f       	adc	r22, r22
    1158:	82 9f       	mul	r24, r18
    115a:	22 27       	eor	r18, r18
    115c:	b0 0d       	add	r27, r0
    115e:	a1 1d       	adc	r26, r1
    1160:	62 1f       	adc	r22, r18
    1162:	73 9f       	mul	r23, r19
    1164:	b0 0d       	add	r27, r0
    1166:	a1 1d       	adc	r26, r1
    1168:	62 1f       	adc	r22, r18
    116a:	83 9f       	mul	r24, r19
    116c:	a0 0d       	add	r26, r0
    116e:	61 1d       	adc	r22, r1
    1170:	22 1f       	adc	r18, r18
    1172:	74 9f       	mul	r23, r20
    1174:	33 27       	eor	r19, r19
    1176:	a0 0d       	add	r26, r0
    1178:	61 1d       	adc	r22, r1
    117a:	23 1f       	adc	r18, r19
    117c:	84 9f       	mul	r24, r20
    117e:	60 0d       	add	r22, r0
    1180:	21 1d       	adc	r18, r1
    1182:	82 2f       	mov	r24, r18
    1184:	76 2f       	mov	r23, r22
    1186:	6a 2f       	mov	r22, r26
    1188:	11 24       	eor	r1, r1
    118a:	9f 57       	subi	r25, 0x7F	; 127
    118c:	50 40       	sbci	r21, 0x00	; 0
    118e:	9a f0       	brmi	.+38     	; 0x11b6 <__mulsf3_pse+0x88>
    1190:	f1 f0       	breq	.+60     	; 0x11ce <__mulsf3_pse+0xa0>
    1192:	88 23       	and	r24, r24
    1194:	4a f0       	brmi	.+18     	; 0x11a8 <__mulsf3_pse+0x7a>
    1196:	ee 0f       	add	r30, r30
    1198:	ff 1f       	adc	r31, r31
    119a:	bb 1f       	adc	r27, r27
    119c:	66 1f       	adc	r22, r22
    119e:	77 1f       	adc	r23, r23
    11a0:	88 1f       	adc	r24, r24
    11a2:	91 50       	subi	r25, 0x01	; 1
    11a4:	50 40       	sbci	r21, 0x00	; 0
    11a6:	a9 f7       	brne	.-22     	; 0x1192 <__mulsf3_pse+0x64>
    11a8:	9e 3f       	cpi	r25, 0xFE	; 254
    11aa:	51 05       	cpc	r21, r1
    11ac:	80 f0       	brcs	.+32     	; 0x11ce <__mulsf3_pse+0xa0>
    11ae:	0c 94 8e 07 	jmp	0xf1c	; 0xf1c <__fp_inf>
    11b2:	0c 94 00 08 	jmp	0x1000	; 0x1000 <__fp_szero>
    11b6:	5f 3f       	cpi	r21, 0xFF	; 255
    11b8:	e4 f3       	brlt	.-8      	; 0x11b2 <__mulsf3_pse+0x84>
    11ba:	98 3e       	cpi	r25, 0xE8	; 232
    11bc:	d4 f3       	brlt	.-12     	; 0x11b2 <__mulsf3_pse+0x84>
    11be:	86 95       	lsr	r24
    11c0:	77 95       	ror	r23
    11c2:	67 95       	ror	r22
    11c4:	b7 95       	ror	r27
    11c6:	f7 95       	ror	r31
    11c8:	e7 95       	ror	r30
    11ca:	9f 5f       	subi	r25, 0xFF	; 255
    11cc:	c1 f7       	brne	.-16     	; 0x11be <__mulsf3_pse+0x90>
    11ce:	fe 2b       	or	r31, r30
    11d0:	88 0f       	add	r24, r24
    11d2:	91 1d       	adc	r25, r1
    11d4:	96 95       	lsr	r25
    11d6:	87 95       	ror	r24
    11d8:	97 f9       	bld	r25, 7
    11da:	08 95       	ret

000011dc <round>:
    11dc:	0e 94 e5 07 	call	0xfca	; 0xfca <__fp_splitA>
    11e0:	e8 f0       	brcs	.+58     	; 0x121c <round+0x40>
    11e2:	9e 37       	cpi	r25, 0x7E	; 126
    11e4:	e8 f0       	brcs	.+58     	; 0x1220 <round+0x44>
    11e6:	96 39       	cpi	r25, 0x96	; 150
    11e8:	b8 f4       	brcc	.+46     	; 0x1218 <round+0x3c>
    11ea:	9e 38       	cpi	r25, 0x8E	; 142
    11ec:	48 f4       	brcc	.+18     	; 0x1200 <round+0x24>
    11ee:	67 2f       	mov	r22, r23
    11f0:	78 2f       	mov	r23, r24
    11f2:	88 27       	eor	r24, r24
    11f4:	98 5f       	subi	r25, 0xF8	; 248
    11f6:	f9 cf       	rjmp	.-14     	; 0x11ea <round+0xe>
    11f8:	86 95       	lsr	r24
    11fa:	77 95       	ror	r23
    11fc:	67 95       	ror	r22
    11fe:	93 95       	inc	r25
    1200:	95 39       	cpi	r25, 0x95	; 149
    1202:	d0 f3       	brcs	.-12     	; 0x11f8 <round+0x1c>
    1204:	b6 2f       	mov	r27, r22
    1206:	b1 70       	andi	r27, 0x01	; 1
    1208:	6b 0f       	add	r22, r27
    120a:	71 1d       	adc	r23, r1
    120c:	81 1d       	adc	r24, r1
    120e:	20 f4       	brcc	.+8      	; 0x1218 <round+0x3c>
    1210:	87 95       	ror	r24
    1212:	77 95       	ror	r23
    1214:	67 95       	ror	r22
    1216:	93 95       	inc	r25
    1218:	0c 94 12 09 	jmp	0x1224	; 0x1224 <__fp_mintl>
    121c:	0c 94 2d 09 	jmp	0x125a	; 0x125a <__fp_mpack>
    1220:	0c 94 00 08 	jmp	0x1000	; 0x1000 <__fp_szero>

00001224 <__fp_mintl>:
    1224:	88 23       	and	r24, r24
    1226:	71 f4       	brne	.+28     	; 0x1244 <__fp_mintl+0x20>
    1228:	77 23       	and	r23, r23
    122a:	21 f0       	breq	.+8      	; 0x1234 <__fp_mintl+0x10>
    122c:	98 50       	subi	r25, 0x08	; 8
    122e:	87 2b       	or	r24, r23
    1230:	76 2f       	mov	r23, r22
    1232:	07 c0       	rjmp	.+14     	; 0x1242 <__fp_mintl+0x1e>
    1234:	66 23       	and	r22, r22
    1236:	11 f4       	brne	.+4      	; 0x123c <__fp_mintl+0x18>
    1238:	99 27       	eor	r25, r25
    123a:	0d c0       	rjmp	.+26     	; 0x1256 <__fp_mintl+0x32>
    123c:	90 51       	subi	r25, 0x10	; 16
    123e:	86 2b       	or	r24, r22
    1240:	70 e0       	ldi	r23, 0x00	; 0
    1242:	60 e0       	ldi	r22, 0x00	; 0
    1244:	2a f0       	brmi	.+10     	; 0x1250 <__fp_mintl+0x2c>
    1246:	9a 95       	dec	r25
    1248:	66 0f       	add	r22, r22
    124a:	77 1f       	adc	r23, r23
    124c:	88 1f       	adc	r24, r24
    124e:	da f7       	brpl	.-10     	; 0x1246 <__fp_mintl+0x22>
    1250:	88 0f       	add	r24, r24
    1252:	96 95       	lsr	r25
    1254:	87 95       	ror	r24
    1256:	97 f9       	bld	r25, 7
    1258:	08 95       	ret

0000125a <__fp_mpack>:
    125a:	9f 3f       	cpi	r25, 0xFF	; 255
    125c:	31 f0       	breq	.+12     	; 0x126a <__fp_mpack_finite+0xc>

0000125e <__fp_mpack_finite>:
    125e:	91 50       	subi	r25, 0x01	; 1
    1260:	20 f4       	brcc	.+8      	; 0x126a <__fp_mpack_finite+0xc>
    1262:	87 95       	ror	r24
    1264:	77 95       	ror	r23
    1266:	67 95       	ror	r22
    1268:	b7 95       	ror	r27
    126a:	88 0f       	add	r24, r24
    126c:	91 1d       	adc	r25, r1
    126e:	96 95       	lsr	r25
    1270:	87 95       	ror	r24
    1272:	97 f9       	bld	r25, 7
    1274:	08 95       	ret

00001276 <malloc>:
    1276:	0f 93       	push	r16
    1278:	1f 93       	push	r17
    127a:	cf 93       	push	r28
    127c:	df 93       	push	r29
    127e:	82 30       	cpi	r24, 0x02	; 2
    1280:	91 05       	cpc	r25, r1
    1282:	10 f4       	brcc	.+4      	; 0x1288 <malloc+0x12>
    1284:	82 e0       	ldi	r24, 0x02	; 2
    1286:	90 e0       	ldi	r25, 0x00	; 0
    1288:	e0 91 5c 3e 	lds	r30, 0x3E5C	; 0x803e5c <__flp>
    128c:	f0 91 5d 3e 	lds	r31, 0x3E5D	; 0x803e5d <__flp+0x1>
    1290:	20 e0       	ldi	r18, 0x00	; 0
    1292:	30 e0       	ldi	r19, 0x00	; 0
    1294:	a0 e0       	ldi	r26, 0x00	; 0
    1296:	b0 e0       	ldi	r27, 0x00	; 0
    1298:	30 97       	sbiw	r30, 0x00	; 0
    129a:	19 f1       	breq	.+70     	; 0x12e2 <malloc+0x6c>
    129c:	40 81       	ld	r20, Z
    129e:	51 81       	ldd	r21, Z+1	; 0x01
    12a0:	02 81       	ldd	r16, Z+2	; 0x02
    12a2:	13 81       	ldd	r17, Z+3	; 0x03
    12a4:	48 17       	cp	r20, r24
    12a6:	59 07       	cpc	r21, r25
    12a8:	c8 f0       	brcs	.+50     	; 0x12dc <malloc+0x66>
    12aa:	84 17       	cp	r24, r20
    12ac:	95 07       	cpc	r25, r21
    12ae:	69 f4       	brne	.+26     	; 0x12ca <malloc+0x54>
    12b0:	10 97       	sbiw	r26, 0x00	; 0
    12b2:	31 f0       	breq	.+12     	; 0x12c0 <malloc+0x4a>
    12b4:	12 96       	adiw	r26, 0x02	; 2
    12b6:	0c 93       	st	X, r16
    12b8:	12 97       	sbiw	r26, 0x02	; 2
    12ba:	13 96       	adiw	r26, 0x03	; 3
    12bc:	1c 93       	st	X, r17
    12be:	27 c0       	rjmp	.+78     	; 0x130e <malloc+0x98>
    12c0:	00 93 5c 3e 	sts	0x3E5C, r16	; 0x803e5c <__flp>
    12c4:	10 93 5d 3e 	sts	0x3E5D, r17	; 0x803e5d <__flp+0x1>
    12c8:	22 c0       	rjmp	.+68     	; 0x130e <malloc+0x98>
    12ca:	21 15       	cp	r18, r1
    12cc:	31 05       	cpc	r19, r1
    12ce:	19 f0       	breq	.+6      	; 0x12d6 <malloc+0x60>
    12d0:	42 17       	cp	r20, r18
    12d2:	53 07       	cpc	r21, r19
    12d4:	18 f4       	brcc	.+6      	; 0x12dc <malloc+0x66>
    12d6:	9a 01       	movw	r18, r20
    12d8:	bd 01       	movw	r22, r26
    12da:	ef 01       	movw	r28, r30
    12dc:	df 01       	movw	r26, r30
    12de:	f8 01       	movw	r30, r16
    12e0:	db cf       	rjmp	.-74     	; 0x1298 <malloc+0x22>
    12e2:	21 15       	cp	r18, r1
    12e4:	31 05       	cpc	r19, r1
    12e6:	f9 f0       	breq	.+62     	; 0x1326 <malloc+0xb0>
    12e8:	28 1b       	sub	r18, r24
    12ea:	39 0b       	sbc	r19, r25
    12ec:	24 30       	cpi	r18, 0x04	; 4
    12ee:	31 05       	cpc	r19, r1
    12f0:	80 f4       	brcc	.+32     	; 0x1312 <malloc+0x9c>
    12f2:	8a 81       	ldd	r24, Y+2	; 0x02
    12f4:	9b 81       	ldd	r25, Y+3	; 0x03
    12f6:	61 15       	cp	r22, r1
    12f8:	71 05       	cpc	r23, r1
    12fa:	21 f0       	breq	.+8      	; 0x1304 <malloc+0x8e>
    12fc:	fb 01       	movw	r30, r22
    12fe:	82 83       	std	Z+2, r24	; 0x02
    1300:	93 83       	std	Z+3, r25	; 0x03
    1302:	04 c0       	rjmp	.+8      	; 0x130c <malloc+0x96>
    1304:	80 93 5c 3e 	sts	0x3E5C, r24	; 0x803e5c <__flp>
    1308:	90 93 5d 3e 	sts	0x3E5D, r25	; 0x803e5d <__flp+0x1>
    130c:	fe 01       	movw	r30, r28
    130e:	32 96       	adiw	r30, 0x02	; 2
    1310:	44 c0       	rjmp	.+136    	; 0x139a <malloc+0x124>
    1312:	fe 01       	movw	r30, r28
    1314:	e2 0f       	add	r30, r18
    1316:	f3 1f       	adc	r31, r19
    1318:	81 93       	st	Z+, r24
    131a:	91 93       	st	Z+, r25
    131c:	22 50       	subi	r18, 0x02	; 2
    131e:	31 09       	sbc	r19, r1
    1320:	28 83       	st	Y, r18
    1322:	39 83       	std	Y+1, r19	; 0x01
    1324:	3a c0       	rjmp	.+116    	; 0x139a <malloc+0x124>
    1326:	20 91 5a 3e 	lds	r18, 0x3E5A	; 0x803e5a <__brkval>
    132a:	30 91 5b 3e 	lds	r19, 0x3E5B	; 0x803e5b <__brkval+0x1>
    132e:	23 2b       	or	r18, r19
    1330:	41 f4       	brne	.+16     	; 0x1342 <malloc+0xcc>
    1332:	20 91 02 3e 	lds	r18, 0x3E02	; 0x803e02 <__malloc_heap_start>
    1336:	30 91 03 3e 	lds	r19, 0x3E03	; 0x803e03 <__malloc_heap_start+0x1>
    133a:	20 93 5a 3e 	sts	0x3E5A, r18	; 0x803e5a <__brkval>
    133e:	30 93 5b 3e 	sts	0x3E5B, r19	; 0x803e5b <__brkval+0x1>
    1342:	20 91 00 3e 	lds	r18, 0x3E00	; 0x803e00 <__data_start>
    1346:	30 91 01 3e 	lds	r19, 0x3E01	; 0x803e01 <__data_start+0x1>
    134a:	21 15       	cp	r18, r1
    134c:	31 05       	cpc	r19, r1
    134e:	41 f4       	brne	.+16     	; 0x1360 <malloc+0xea>
    1350:	2d b7       	in	r18, 0x3d	; 61
    1352:	3e b7       	in	r19, 0x3e	; 62
    1354:	40 91 04 3e 	lds	r20, 0x3E04	; 0x803e04 <__malloc_margin>
    1358:	50 91 05 3e 	lds	r21, 0x3E05	; 0x803e05 <__malloc_margin+0x1>
    135c:	24 1b       	sub	r18, r20
    135e:	35 0b       	sbc	r19, r21
    1360:	e0 91 5a 3e 	lds	r30, 0x3E5A	; 0x803e5a <__brkval>
    1364:	f0 91 5b 3e 	lds	r31, 0x3E5B	; 0x803e5b <__brkval+0x1>
    1368:	e2 17       	cp	r30, r18
    136a:	f3 07       	cpc	r31, r19
    136c:	a0 f4       	brcc	.+40     	; 0x1396 <malloc+0x120>
    136e:	2e 1b       	sub	r18, r30
    1370:	3f 0b       	sbc	r19, r31
    1372:	28 17       	cp	r18, r24
    1374:	39 07       	cpc	r19, r25
    1376:	78 f0       	brcs	.+30     	; 0x1396 <malloc+0x120>
    1378:	ac 01       	movw	r20, r24
    137a:	4e 5f       	subi	r20, 0xFE	; 254
    137c:	5f 4f       	sbci	r21, 0xFF	; 255
    137e:	24 17       	cp	r18, r20
    1380:	35 07       	cpc	r19, r21
    1382:	48 f0       	brcs	.+18     	; 0x1396 <malloc+0x120>
    1384:	4e 0f       	add	r20, r30
    1386:	5f 1f       	adc	r21, r31
    1388:	40 93 5a 3e 	sts	0x3E5A, r20	; 0x803e5a <__brkval>
    138c:	50 93 5b 3e 	sts	0x3E5B, r21	; 0x803e5b <__brkval+0x1>
    1390:	81 93       	st	Z+, r24
    1392:	91 93       	st	Z+, r25
    1394:	02 c0       	rjmp	.+4      	; 0x139a <malloc+0x124>
    1396:	e0 e0       	ldi	r30, 0x00	; 0
    1398:	f0 e0       	ldi	r31, 0x00	; 0
    139a:	cf 01       	movw	r24, r30
    139c:	df 91       	pop	r29
    139e:	cf 91       	pop	r28
    13a0:	1f 91       	pop	r17
    13a2:	0f 91       	pop	r16
    13a4:	08 95       	ret

000013a6 <free>:
    13a6:	cf 93       	push	r28
    13a8:	df 93       	push	r29
    13aa:	00 97       	sbiw	r24, 0x00	; 0
    13ac:	09 f4       	brne	.+2      	; 0x13b0 <free+0xa>
    13ae:	81 c0       	rjmp	.+258    	; 0x14b2 <free+0x10c>
    13b0:	fc 01       	movw	r30, r24
    13b2:	32 97       	sbiw	r30, 0x02	; 2
    13b4:	12 82       	std	Z+2, r1	; 0x02
    13b6:	13 82       	std	Z+3, r1	; 0x03
    13b8:	a0 91 5c 3e 	lds	r26, 0x3E5C	; 0x803e5c <__flp>
    13bc:	b0 91 5d 3e 	lds	r27, 0x3E5D	; 0x803e5d <__flp+0x1>
    13c0:	10 97       	sbiw	r26, 0x00	; 0
    13c2:	81 f4       	brne	.+32     	; 0x13e4 <free+0x3e>
    13c4:	20 81       	ld	r18, Z
    13c6:	31 81       	ldd	r19, Z+1	; 0x01
    13c8:	82 0f       	add	r24, r18
    13ca:	93 1f       	adc	r25, r19
    13cc:	20 91 5a 3e 	lds	r18, 0x3E5A	; 0x803e5a <__brkval>
    13d0:	30 91 5b 3e 	lds	r19, 0x3E5B	; 0x803e5b <__brkval+0x1>
    13d4:	28 17       	cp	r18, r24
    13d6:	39 07       	cpc	r19, r25
    13d8:	51 f5       	brne	.+84     	; 0x142e <free+0x88>
    13da:	e0 93 5a 3e 	sts	0x3E5A, r30	; 0x803e5a <__brkval>
    13de:	f0 93 5b 3e 	sts	0x3E5B, r31	; 0x803e5b <__brkval+0x1>
    13e2:	67 c0       	rjmp	.+206    	; 0x14b2 <free+0x10c>
    13e4:	ed 01       	movw	r28, r26
    13e6:	20 e0       	ldi	r18, 0x00	; 0
    13e8:	30 e0       	ldi	r19, 0x00	; 0
    13ea:	ce 17       	cp	r28, r30
    13ec:	df 07       	cpc	r29, r31
    13ee:	40 f4       	brcc	.+16     	; 0x1400 <free+0x5a>
    13f0:	4a 81       	ldd	r20, Y+2	; 0x02
    13f2:	5b 81       	ldd	r21, Y+3	; 0x03
    13f4:	9e 01       	movw	r18, r28
    13f6:	41 15       	cp	r20, r1
    13f8:	51 05       	cpc	r21, r1
    13fa:	f1 f0       	breq	.+60     	; 0x1438 <free+0x92>
    13fc:	ea 01       	movw	r28, r20
    13fe:	f5 cf       	rjmp	.-22     	; 0x13ea <free+0x44>
    1400:	c2 83       	std	Z+2, r28	; 0x02
    1402:	d3 83       	std	Z+3, r29	; 0x03
    1404:	40 81       	ld	r20, Z
    1406:	51 81       	ldd	r21, Z+1	; 0x01
    1408:	84 0f       	add	r24, r20
    140a:	95 1f       	adc	r25, r21
    140c:	c8 17       	cp	r28, r24
    140e:	d9 07       	cpc	r29, r25
    1410:	59 f4       	brne	.+22     	; 0x1428 <free+0x82>
    1412:	88 81       	ld	r24, Y
    1414:	99 81       	ldd	r25, Y+1	; 0x01
    1416:	84 0f       	add	r24, r20
    1418:	95 1f       	adc	r25, r21
    141a:	02 96       	adiw	r24, 0x02	; 2
    141c:	80 83       	st	Z, r24
    141e:	91 83       	std	Z+1, r25	; 0x01
    1420:	8a 81       	ldd	r24, Y+2	; 0x02
    1422:	9b 81       	ldd	r25, Y+3	; 0x03
    1424:	82 83       	std	Z+2, r24	; 0x02
    1426:	93 83       	std	Z+3, r25	; 0x03
    1428:	21 15       	cp	r18, r1
    142a:	31 05       	cpc	r19, r1
    142c:	29 f4       	brne	.+10     	; 0x1438 <free+0x92>
    142e:	e0 93 5c 3e 	sts	0x3E5C, r30	; 0x803e5c <__flp>
    1432:	f0 93 5d 3e 	sts	0x3E5D, r31	; 0x803e5d <__flp+0x1>
    1436:	3d c0       	rjmp	.+122    	; 0x14b2 <free+0x10c>
    1438:	e9 01       	movw	r28, r18
    143a:	ea 83       	std	Y+2, r30	; 0x02
    143c:	fb 83       	std	Y+3, r31	; 0x03
    143e:	49 91       	ld	r20, Y+
    1440:	59 91       	ld	r21, Y+
    1442:	c4 0f       	add	r28, r20
    1444:	d5 1f       	adc	r29, r21
    1446:	ec 17       	cp	r30, r28
    1448:	fd 07       	cpc	r31, r29
    144a:	61 f4       	brne	.+24     	; 0x1464 <free+0xbe>
    144c:	80 81       	ld	r24, Z
    144e:	91 81       	ldd	r25, Z+1	; 0x01
    1450:	84 0f       	add	r24, r20
    1452:	95 1f       	adc	r25, r21
    1454:	02 96       	adiw	r24, 0x02	; 2
    1456:	e9 01       	movw	r28, r18
    1458:	88 83       	st	Y, r24
    145a:	99 83       	std	Y+1, r25	; 0x01
    145c:	82 81       	ldd	r24, Z+2	; 0x02
    145e:	93 81       	ldd	r25, Z+3	; 0x03
    1460:	8a 83       	std	Y+2, r24	; 0x02
    1462:	9b 83       	std	Y+3, r25	; 0x03
    1464:	e0 e0       	ldi	r30, 0x00	; 0
    1466:	f0 e0       	ldi	r31, 0x00	; 0
    1468:	12 96       	adiw	r26, 0x02	; 2
    146a:	8d 91       	ld	r24, X+
    146c:	9c 91       	ld	r25, X
    146e:	13 97       	sbiw	r26, 0x03	; 3
    1470:	00 97       	sbiw	r24, 0x00	; 0
    1472:	19 f0       	breq	.+6      	; 0x147a <free+0xd4>
    1474:	fd 01       	movw	r30, r26
    1476:	dc 01       	movw	r26, r24
    1478:	f7 cf       	rjmp	.-18     	; 0x1468 <free+0xc2>
    147a:	8d 91       	ld	r24, X+
    147c:	9c 91       	ld	r25, X
    147e:	11 97       	sbiw	r26, 0x01	; 1
    1480:	9d 01       	movw	r18, r26
    1482:	2e 5f       	subi	r18, 0xFE	; 254
    1484:	3f 4f       	sbci	r19, 0xFF	; 255
    1486:	82 0f       	add	r24, r18
    1488:	93 1f       	adc	r25, r19
    148a:	20 91 5a 3e 	lds	r18, 0x3E5A	; 0x803e5a <__brkval>
    148e:	30 91 5b 3e 	lds	r19, 0x3E5B	; 0x803e5b <__brkval+0x1>
    1492:	28 17       	cp	r18, r24
    1494:	39 07       	cpc	r19, r25
    1496:	69 f4       	brne	.+26     	; 0x14b2 <free+0x10c>
    1498:	30 97       	sbiw	r30, 0x00	; 0
    149a:	29 f4       	brne	.+10     	; 0x14a6 <free+0x100>
    149c:	10 92 5c 3e 	sts	0x3E5C, r1	; 0x803e5c <__flp>
    14a0:	10 92 5d 3e 	sts	0x3E5D, r1	; 0x803e5d <__flp+0x1>
    14a4:	02 c0       	rjmp	.+4      	; 0x14aa <free+0x104>
    14a6:	12 82       	std	Z+2, r1	; 0x02
    14a8:	13 82       	std	Z+3, r1	; 0x03
    14aa:	a0 93 5a 3e 	sts	0x3E5A, r26	; 0x803e5a <__brkval>
    14ae:	b0 93 5b 3e 	sts	0x3E5B, r27	; 0x803e5b <__brkval+0x1>
    14b2:	df 91       	pop	r29
    14b4:	cf 91       	pop	r28
    14b6:	08 95       	ret

000014b8 <_exit>:
    14b8:	f8 94       	cli

000014ba <__stop_program>:
    14ba:	ff cf       	rjmp	.-2      	; 0x14ba <__stop_program>
