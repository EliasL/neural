
Building_Brains_V4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000001c  00803e00  00002000  000020b4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001f88  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000078  00009f88  00001f88  0000203c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .bss          00000051  00803e1c  00803e1c  000020d0  2**0
                  ALLOC
  4 .comment      0000005c  00000000  00000000  000020d0  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  0000212c  2**2
                  CONTENTS, READONLY
  6 .debug_aranges 000004e0  00000000  00000000  00002168  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   000079fa  00000000  00000000  00002648  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00003107  00000000  00000000  0000a042  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00002850  00000000  00000000  0000d149  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  0000090c  00000000  00000000  0000f99c  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00002fa6  00000000  00000000  000102a8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000017de  00000000  00000000  0001324e  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000320  00000000  00000000  00014a2c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	96 c0       	rjmp	.+300    	; 0x12e <__ctors_end>
       2:	b0 c0       	rjmp	.+352    	; 0x164 <__bad_interrupt>
       4:	af c0       	rjmp	.+350    	; 0x164 <__bad_interrupt>
       6:	ae c0       	rjmp	.+348    	; 0x164 <__bad_interrupt>
       8:	ad c0       	rjmp	.+346    	; 0x164 <__bad_interrupt>
       a:	ac c0       	rjmp	.+344    	; 0x164 <__bad_interrupt>
       c:	48 c6       	rjmp	.+3216   	; 0xc9e <__vector_6>
       e:	aa c0       	rjmp	.+340    	; 0x164 <__bad_interrupt>
      10:	a9 c0       	rjmp	.+338    	; 0x164 <__bad_interrupt>
      12:	a8 c0       	rjmp	.+336    	; 0x164 <__bad_interrupt>
      14:	a7 c0       	rjmp	.+334    	; 0x164 <__bad_interrupt>
      16:	a6 c0       	rjmp	.+332    	; 0x164 <__bad_interrupt>
      18:	a5 c0       	rjmp	.+330    	; 0x164 <__bad_interrupt>
      1a:	a4 c0       	rjmp	.+328    	; 0x164 <__bad_interrupt>
      1c:	a3 c0       	rjmp	.+326    	; 0x164 <__bad_interrupt>
      1e:	a2 c0       	rjmp	.+324    	; 0x164 <__bad_interrupt>
      20:	a1 c0       	rjmp	.+322    	; 0x164 <__bad_interrupt>
      22:	a0 c0       	rjmp	.+320    	; 0x164 <__bad_interrupt>
      24:	9f c0       	rjmp	.+318    	; 0x164 <__bad_interrupt>
      26:	9e c0       	rjmp	.+316    	; 0x164 <__bad_interrupt>
      28:	9d c0       	rjmp	.+314    	; 0x164 <__bad_interrupt>
      2a:	9c c0       	rjmp	.+312    	; 0x164 <__bad_interrupt>
      2c:	9b c0       	rjmp	.+310    	; 0x164 <__bad_interrupt>
      2e:	9a c0       	rjmp	.+308    	; 0x164 <__bad_interrupt>
      30:	99 c0       	rjmp	.+306    	; 0x164 <__bad_interrupt>
      32:	98 c0       	rjmp	.+304    	; 0x164 <__bad_interrupt>

00000034 <__trampolines_end>:
      34:	00 40       	sbci	r16, 0x00	; 0
      36:	7a 10       	cpse	r7, r10
      38:	f3 5a       	subi	r31, 0xA3	; 163
      3a:	00 a0       	ldd	r0, Z+32	; 0x20
      3c:	72 4e       	sbci	r23, 0xE2	; 226
      3e:	18 09       	sbc	r17, r8
      40:	00 10       	cpse	r0, r0
      42:	a5 d4       	rcall	.+2378   	; 0x98e <tinyAxon_update_potential+0x48>
      44:	e8 00       	.word	0x00e8	; ????
      46:	00 e8       	ldi	r16, 0x80	; 128
      48:	76 48       	sbci	r23, 0x86	; 134
      4a:	17 00       	.word	0x0017	; ????
      4c:	00 e4       	ldi	r16, 0x40	; 64
      4e:	0b 54       	subi	r16, 0x4B	; 75
      50:	02 00       	.word	0x0002	; ????
      52:	00 ca       	rjmp	.-3072   	; 0xfffff454 <__eeprom_end+0xff7ef454>
      54:	9a 3b       	cpi	r25, 0xBA	; 186
      56:	00 00       	nop
      58:	00 e1       	ldi	r16, 0x10	; 16
      5a:	f5 05       	cpc	r31, r5
      5c:	00 00       	nop
      5e:	80 96       	adiw	r24, 0x20	; 32
      60:	98 00       	.word	0x0098	; ????
      62:	00 00       	nop
      64:	40 42       	sbci	r20, 0x20	; 32
      66:	0f 00       	.word	0x000f	; ????
      68:	00 00       	nop
      6a:	a0 86       	std	Z+8, r10	; 0x08
      6c:	01 00       	.word	0x0001	; ????
      6e:	00 00       	nop
      70:	10 27       	eor	r17, r16
      72:	00 00       	nop
      74:	00 00       	nop
      76:	e8 03       	fmulsu	r22, r16
      78:	00 00       	nop
      7a:	00 00       	nop
      7c:	64 00       	.word	0x0064	; ????
      7e:	00 00       	nop
      80:	00 00       	nop
      82:	0a 00       	.word	0x000a	; ????
      84:	00 00       	nop
      86:	00 00       	nop
      88:	01 00       	.word	0x0001	; ????
      8a:	00 00       	nop
      8c:	00 00       	nop
      8e:	2c 76       	andi	r18, 0x6C	; 108
      90:	d8 88       	ldd	r13, Y+16	; 0x10
      92:	dc 67       	ori	r29, 0x7C	; 124
      94:	4f 08       	sbc	r4, r15
      96:	23 df       	rcall	.-442    	; 0xfffffede <__eeprom_end+0xff7efede>
      98:	c1 df       	rcall	.-126    	; 0x1c <__FUSE_REGION_LENGTH__+0x13>
      9a:	ae 59       	subi	r26, 0x9E	; 158
      9c:	e1 b1       	in	r30, 0x01	; 1
      9e:	b7 96       	adiw	r30, 0x27	; 39
      a0:	e5 e3       	ldi	r30, 0x35	; 53
      a2:	e4 53       	subi	r30, 0x34	; 52
      a4:	c6 3a       	cpi	r28, 0xA6	; 166
      a6:	e6 51       	subi	r30, 0x16	; 22
      a8:	99 76       	andi	r25, 0x69	; 105
      aa:	96 e8       	ldi	r25, 0x86	; 134
      ac:	e6 c2       	rjmp	.+1484   	; 0x67a <main+0x1c>
      ae:	84 26       	eor	r8, r20
      b0:	eb 89       	ldd	r30, Y+19	; 0x13
      b2:	8c 9b       	sbis	0x11, 4	; 17
      b4:	62 ed       	ldi	r22, 0xD2	; 210
      b6:	40 7c       	andi	r20, 0xC0	; 192
      b8:	6f fc       	.word	0xfc6f	; ????
      ba:	ef bc       	out	0x2f, r14	; 47
      bc:	9c 9f       	mul	r25, r28
      be:	40 f2       	brcs	.-112    	; 0x50 <__SREG__+0x11>
      c0:	ba a5       	ldd	r27, Y+42	; 0x2a
      c2:	6f a5       	ldd	r22, Y+47	; 0x2f
      c4:	f4 90       	lpm	r15, Z
      c6:	05 5a       	subi	r16, 0xA5	; 165
      c8:	2a f7       	brpl	.-54     	; 0x94 <__SREG__+0x55>
      ca:	5c 93       	st	X, r21
      cc:	6b 6c       	ori	r22, 0xCB	; 203
      ce:	f9 67       	ori	r31, 0x79	; 121
      d0:	6d c1       	rjmp	.+730    	; 0x3ac <dequeue+0x42>
      d2:	1b fc       	.word	0xfc1b	; ????
      d4:	e0 e4       	ldi	r30, 0x40	; 64
      d6:	0d 47       	sbci	r16, 0x7D	; 125
      d8:	fe f5       	brtc	.+126    	; 0x158 <.do_clear_bss_loop>
      da:	20 e6       	ldi	r18, 0x60	; 96
      dc:	b5 00       	.word	0x00b5	; ????
      de:	d0 ed       	ldi	r29, 0xD0	; 208
      e0:	90 2e       	mov	r9, r16
      e2:	03 00       	.word	0x0003	; ????
      e4:	94 35       	cpi	r25, 0x54	; 84
      e6:	77 05       	cpc	r23, r7
      e8:	00 80       	ld	r0, Z
      ea:	84 1e       	adc	r8, r20
      ec:	08 00       	.word	0x0008	; ????
      ee:	00 20       	and	r0, r0
      f0:	4e 0a       	sbc	r4, r30
      f2:	00 00       	nop
      f4:	00 c8       	rjmp	.-4096   	; 0xfffff0f6 <__eeprom_end+0xff7ef0f6>
      f6:	0c 33       	cpi	r16, 0x3C	; 60
      f8:	33 33       	cpi	r19, 0x33	; 51
      fa:	33 0f       	add	r19, r19
      fc:	98 6e       	ori	r25, 0xE8	; 232
      fe:	12 83       	std	Z+2, r17	; 0x02
     100:	11 41       	sbci	r17, 0x11	; 17
     102:	ef 8d       	ldd	r30, Y+31	; 0x1f
     104:	21 14       	cp	r2, r1
     106:	89 3b       	cpi	r24, 0xB9	; 185
     108:	e6 55       	subi	r30, 0x56	; 86
     10a:	16 cf       	rjmp	.-468    	; 0xffffff38 <__eeprom_end+0xff7eff38>
     10c:	fe e6       	ldi	r31, 0x6E	; 110
     10e:	db 18       	sub	r13, r11
     110:	d1 84       	ldd	r13, Z+9	; 0x09
     112:	4b 38       	cpi	r20, 0x8B	; 139
     114:	1b f7       	brvc	.-58     	; 0xdc <__SREG__+0x9d>
     116:	7c 1d       	adc	r23, r12
     118:	90 1d       	adc	r25, r0
     11a:	a4 bb       	out	0x14, r26	; 20
     11c:	e4 24       	eor	r14, r4
     11e:	20 32       	cpi	r18, 0x20	; 32
     120:	84 72       	andi	r24, 0x24	; 36
     122:	5e 22       	and	r5, r30
     124:	81 00       	.word	0x0081	; ????
     126:	c9 f1       	breq	.+114    	; 0x19a <ADC_get_conversion+0x1e>
     128:	24 ec       	ldi	r18, 0xC4	; 196
     12a:	a1 e5       	ldi	r26, 0x51	; 81
     12c:	3d 27       	eor	r19, r29

0000012e <__ctors_end>:
     12e:	11 24       	eor	r1, r1
     130:	1f be       	out	0x3f, r1	; 63
     132:	cf ef       	ldi	r28, 0xFF	; 255
     134:	cd bf       	out	0x3d, r28	; 61
     136:	df e3       	ldi	r29, 0x3F	; 63
     138:	de bf       	out	0x3e, r29	; 62

0000013a <__do_copy_data>:
     13a:	1e e3       	ldi	r17, 0x3E	; 62
     13c:	a0 e0       	ldi	r26, 0x00	; 0
     13e:	be e3       	ldi	r27, 0x3E	; 62
     140:	e0 e0       	ldi	r30, 0x00	; 0
     142:	f0 e2       	ldi	r31, 0x20	; 32
     144:	02 c0       	rjmp	.+4      	; 0x14a <__do_copy_data+0x10>
     146:	05 90       	lpm	r0, Z+
     148:	0d 92       	st	X+, r0
     14a:	ac 31       	cpi	r26, 0x1C	; 28
     14c:	b1 07       	cpc	r27, r17
     14e:	d9 f7       	brne	.-10     	; 0x146 <__do_copy_data+0xc>

00000150 <__do_clear_bss>:
     150:	2e e3       	ldi	r18, 0x3E	; 62
     152:	ac e1       	ldi	r26, 0x1C	; 28
     154:	be e3       	ldi	r27, 0x3E	; 62
     156:	01 c0       	rjmp	.+2      	; 0x15a <.do_clear_bss_start>

00000158 <.do_clear_bss_loop>:
     158:	1d 92       	st	X+, r1

0000015a <.do_clear_bss_start>:
     15a:	ad 36       	cpi	r26, 0x6D	; 109
     15c:	b2 07       	cpc	r27, r18
     15e:	e1 f7       	brne	.-8      	; 0x158 <.do_clear_bss_loop>
     160:	7e d2       	rcall	.+1276   	; 0x65e <main>
     162:	10 cf       	rjmp	.-480    	; 0xffffff84 <__eeprom_end+0xff7eff84>

00000164 <__bad_interrupt>:
     164:	4d cf       	rjmp	.-358    	; 0x0 <__vectors>

00000166 <atmel_start_init>:
/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
	system_init();
     166:	c2 d0       	rcall	.+388    	; 0x2ec <system_init>
     168:	08 95       	ret

0000016a <ADC_init>:
 * \return Conversion result read from the ADC ADC module
 */
adc_result_t ADC_get_conversion_result(void)
{
	return (ADC0.RES);
}
     16a:	85 e0       	ldi	r24, 0x05	; 5
     16c:	80 93 00 06 	sts	0x0600, r24	; 0x800600 <__TEXT_REGION_LENGTH__+0x700600>
     170:	80 e0       	ldi	r24, 0x00	; 0
     172:	08 95       	ret

00000174 <ADC_is_conversion_done>:
     174:	80 91 0b 06 	lds	r24, 0x060B	; 0x80060b <__TEXT_REGION_LENGTH__+0x70060b>
     178:	81 70       	andi	r24, 0x01	; 1
     17a:	08 95       	ret

0000017c <ADC_get_conversion>:
 *
 * \return Nothing
 */
void ADC_start_conversion(adc_0_channel_t channel)
{
	ADC0.MUXPOS  = channel;
     17c:	e0 e0       	ldi	r30, 0x00	; 0
     17e:	f6 e0       	ldi	r31, 0x06	; 6
     180:	86 83       	std	Z+6, r24	; 0x06
	ADC0.COMMAND = ADC_STCONV_bm;
     182:	81 e0       	ldi	r24, 0x01	; 1
     184:	80 87       	std	Z+8, r24	; 0x08
adc_result_t ADC_get_conversion(adc_0_channel_t channel)
{
	adc_result_t res;

	ADC_start_conversion(channel);
	while (!ADC_is_conversion_done())
     186:	f6 df       	rcall	.-20     	; 0x174 <ADC_is_conversion_done>
     188:	88 23       	and	r24, r24
     18a:	e9 f3       	breq	.-6      	; 0x186 <ADC_get_conversion+0xa>
 *
 * \return Conversion result read from the ADC ADC module
 */
adc_result_t ADC_get_conversion_result(void)
{
	return (ADC0.RES);
     18c:	e0 e0       	ldi	r30, 0x00	; 0
     18e:	f6 e0       	ldi	r31, 0x06	; 6
     190:	20 89       	ldd	r18, Z+16	; 0x10
     192:	31 89       	ldd	r19, Z+17	; 0x11

	ADC_start_conversion(channel);
	while (!ADC_is_conversion_done())
		;
	res = ADC_get_conversion_result();
	ADC0.INTFLAGS |= ADC_RESRDY_bm;
     194:	93 85       	ldd	r25, Z+11	; 0x0b
     196:	91 60       	ori	r25, 0x01	; 1
     198:	93 87       	std	Z+11, r25	; 0x0b
	return res;
}
     19a:	c9 01       	movw	r24, r18
     19c:	08 95       	ret

0000019e <BOD_init>:
	//		 | BOD_VLMCFG_ABOVE_gc; /* Interrupt when supply goes above VLM level */

	// BOD.VLMCTRLA = BOD_VLMLVL_5ABOVE_gc; /* VLM threshold 5% above BOD level */

	return 0;
}
     19e:	80 e0       	ldi	r24, 0x00	; 0
     1a0:	08 95       	ret

000001a2 <DIGGSIGG_init>:
	//		 | CCL_EDGEDET_DIS_gc /* Edge detector is disabled */
	//		 | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	//		 | 0 << CCL_ENABLE_bp /* LUT Enable: disabled */
	//		 | 0 << CCL_OUTEN_bp; /* Output Enable: disabled */

	CCL.TRUTH1 = 168; /* Truth 1: 168 */
     1a2:	e0 ec       	ldi	r30, 0xC0	; 192
     1a4:	f1 e0       	ldi	r31, 0x01	; 1
     1a6:	88 ea       	ldi	r24, 0xA8	; 168
     1a8:	84 87       	std	Z+12, r24	; 0x0c

	CCL.LUT1CTRLC = CCL_INSEL2_TCA0_gc /* TCA0 WO2 input source */;
     1aa:	88 e0       	ldi	r24, 0x08	; 8
     1ac:	83 87       	std	Z+11, r24	; 0x0b

	CCL.LUT1CTRLB = CCL_INSEL0_SPI0_gc /* SPI0 SCK source */
     1ae:	8b eb       	ldi	r24, 0xBB	; 187
     1b0:	82 87       	std	Z+10, r24	; 0x0a
	                | CCL_INSEL1_SPI0_gc /* SPI0 MOSI input source */;

	CCL.LUT1CTRLA = 0 << CCL_CLKSRC_bp       /* Clock Source Selection: disabled */
     1b2:	89 e0       	ldi	r24, 0x09	; 9
     1b4:	81 87       	std	Z+9, r24	; 0x09
	                | CCL_EDGEDET_DIS_gc     /* Edge detector is disabled */
	                | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	                | 1 << CCL_ENABLE_bp     /* LUT Enable: enabled */
	                | 1 << CCL_OUTEN_bp;     /* Output Enable: enabled */

	CCL.CTRLA = 1 << CCL_ENABLE_bp      /* Enable: enabled */
     1b6:	81 e4       	ldi	r24, 0x41	; 65
     1b8:	80 83       	st	Z, r24
	            | 1 << CCL_RUNSTDBY_bp; /* Run in Standby: enabled */

	return 0;
}
     1ba:	80 e0       	ldi	r24, 0x00	; 0
     1bc:	08 95       	ret

000001be <CLKCTRL_init>:
 *       on calling convention. The memory model is not visible to the
 *       preprocessor, so it must be defined in the Assembler preprocessor directives.
 */
static inline void ccp_write_io(void *addr, uint8_t value)
{
	protected_write_io(addr, CCP_IOREG_gc, value);
     1be:	47 e0       	ldi	r20, 0x07	; 7
     1c0:	68 ed       	ldi	r22, 0xD8	; 216
     1c2:	8c e7       	ldi	r24, 0x7C	; 124
     1c4:	90 e0       	ldi	r25, 0x00	; 0
     1c6:	ad d0       	rcall	.+346    	; 0x322 <protected_write_io>
     1c8:	41 e0       	ldi	r20, 0x01	; 1
     1ca:	68 ed       	ldi	r22, 0xD8	; 216
     1cc:	81 e6       	ldi	r24, 0x61	; 97
     1ce:	90 e0       	ldi	r25, 0x00	; 0
     1d0:	a8 d0       	rcall	.+336    	; 0x322 <protected_write_io>
	//		 | 0 << CLKCTRL_CLKOUT_bp /* System clock out: disabled */);

	// ccp_write_io((void*)&(CLKCTRL.MCLKLOCK),0 << CLKCTRL_LOCKEN_bp /* lock enable: disabled */);

	return 0;
}
     1d2:	80 e0       	ldi	r24, 0x00	; 0
     1d4:	08 95       	ret

000001d6 <CPUINT_init>:

	// CPUINT.LVL0PRI = 0x0 << CPUINT_LVL0PRI_gp; /* Interrupt Level Priority: 0x0 */

	// CPUINT.LVL1VEC = 0x0 << CPUINT_LVL1VEC_gp; /* Interrupt Vector with High Priority: 0x0 */

	ENABLE_INTERRUPTS();
     1d6:	78 94       	sei

	return 0;
}
     1d8:	80 e0       	ldi	r24, 0x00	; 0
     1da:	08 95       	ret

000001dc <DAC_init>:
 *
 * \return Nothing
 */
void DAC_disable()
{
	DAC0.CTRLA &= ~DAC_ENABLE_bm;
     1dc:	81 e4       	ldi	r24, 0x41	; 65
     1de:	80 93 80 06 	sts	0x0680, r24	; 0x800680 <__TEXT_REGION_LENGTH__+0x700680>
     1e2:	80 e0       	ldi	r24, 0x00	; 0
     1e4:	08 95       	ret

000001e6 <DAC_set_output>:
 *
 * \return Nothing
 */
void DAC_set_output(dac_resolution_t value)
{
	DAC0.DATA = value;
     1e6:	80 93 81 06 	sts	0x0681, r24	; 0x800681 <__TEXT_REGION_LENGTH__+0x700681>
     1ea:	08 95       	ret

000001ec <mcu_init>:
#ifdef __cplusplus
extern "C" {
#endif

void mcu_init(void)
{
     1ec:	e0 e1       	ldi	r30, 0x10	; 16
     1ee:	f4 e0       	ldi	r31, 0x04	; 4
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     1f0:	80 81       	ld	r24, Z
     1f2:	88 60       	ori	r24, 0x08	; 8
     1f4:	81 93       	st	Z+, r24
	 * disables all peripherals to save power. Driver shall enable
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
     1f6:	e8 31       	cpi	r30, 0x18	; 24
     1f8:	84 e0       	ldi	r24, 0x04	; 4
     1fa:	f8 07       	cpc	r31, r24
     1fc:	c9 f7       	brne	.-14     	; 0x1f0 <mcu_init+0x4>
     1fe:	e0 e3       	ldi	r30, 0x30	; 48
     200:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     202:	80 81       	ld	r24, Z
     204:	88 60       	ori	r24, 0x08	; 8
     206:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     208:	e8 33       	cpi	r30, 0x38	; 56
     20a:	84 e0       	ldi	r24, 0x04	; 4
     20c:	f8 07       	cpc	r31, r24
     20e:	c9 f7       	brne	.-14     	; 0x202 <mcu_init+0x16>
     210:	e0 e5       	ldi	r30, 0x50	; 80
     212:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     214:	80 81       	ld	r24, Z
     216:	88 60       	ori	r24, 0x08	; 8
     218:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     21a:	e8 35       	cpi	r30, 0x58	; 88
     21c:	84 e0       	ldi	r24, 0x04	; 4
     21e:	f8 07       	cpc	r31, r24
     220:	c9 f7       	brne	.-14     	; 0x214 <mcu_init+0x28>
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}
}
     222:	08 95       	ret

00000224 <ADC_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     224:	e5 e1       	ldi	r30, 0x15	; 21
     226:	f4 e0       	ldi	r31, 0x04	; 4
     228:	80 81       	ld	r24, Z
     22a:	88 7f       	andi	r24, 0xF8	; 248
     22c:	84 60       	ori	r24, 0x04	; 4
     22e:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     230:	80 81       	ld	r24, Z
     232:	87 7f       	andi	r24, 0xF7	; 247
     234:	80 83       	st	Z, r24
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     236:	e7 e1       	ldi	r30, 0x17	; 23
     238:	f4 e0       	ldi	r31, 0x04	; 4
     23a:	80 81       	ld	r24, Z
     23c:	88 7f       	andi	r24, 0xF8	; 248
     23e:	84 60       	ori	r24, 0x04	; 4
     240:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     242:	80 81       	ld	r24, Z
     244:	87 7f       	andi	r24, 0xF7	; 247
     246:	80 83       	st	Z, r24
 */
static inline void PORTB_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     248:	e4 e3       	ldi	r30, 0x34	; 52
     24a:	f4 e0       	ldi	r31, 0x04	; 4
     24c:	80 81       	ld	r24, Z
     24e:	88 7f       	andi	r24, 0xF8	; 248
     250:	84 60       	ori	r24, 0x04	; 4
     252:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     254:	80 81       	ld	r24, Z
     256:	87 7f       	andi	r24, 0xF7	; 247
     258:	80 83       	st	Z, r24
 */
static inline void PORTB_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     25a:	e1 e3       	ldi	r30, 0x31	; 49
     25c:	f4 e0       	ldi	r31, 0x04	; 4
     25e:	80 81       	ld	r24, Z
     260:	88 7f       	andi	r24, 0xF8	; 248
     262:	84 60       	ori	r24, 0x04	; 4
     264:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     266:	80 81       	ld	r24, Z
     268:	87 7f       	andi	r24, 0xF7	; 247
     26a:	80 83       	st	Z, r24
 */
static inline void PORTB_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     26c:	e0 e3       	ldi	r30, 0x30	; 48
     26e:	f4 e0       	ldi	r31, 0x04	; 4
     270:	80 81       	ld	r24, Z
     272:	88 7f       	andi	r24, 0xF8	; 248
     274:	84 60       	ori	r24, 0x04	; 4
     276:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     278:	80 81       	ld	r24, Z
     27a:	87 7f       	andi	r24, 0xF7	; 247
     27c:	80 83       	st	Z, r24
	// Disable digital input buffer
	DEN4_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	DEN4_PIN_set_pull_mode(PORT_PULL_OFF);

	ADC_init();
     27e:	75 df       	rcall	.-278    	; 0x16a <ADC_init>
     280:	08 95       	ret

00000282 <USART_0_initialization>:
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     282:	23 98       	cbi	0x04, 3	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     284:	e3 e3       	ldi	r30, 0x33	; 51
     286:	f4 e0       	ldi	r31, 0x04	; 4
     288:	80 81       	ld	r24, Z
     28a:	87 7f       	andi	r24, 0xF7	; 247
     28c:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     28e:	22 9a       	sbi	0x04, 2	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     290:	2a 98       	cbi	0x05, 2	; 5
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	USART_0_init();
     292:	1b d1       	rcall	.+566    	; 0x4ca <USART_0_init>
     294:	08 95       	ret

00000296 <TIMER_0_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     296:	25 9a       	sbi	0x04, 5	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     298:	2d 98       	cbi	0x05, 5	; 5
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLC |= PORTMUX_TCA02_bm;
     29a:	e0 e0       	ldi	r30, 0x00	; 0
     29c:	f2 e0       	ldi	r31, 0x02	; 2
     29e:	82 81       	ldd	r24, Z+2	; 0x02
     2a0:	84 60       	ori	r24, 0x04	; 4
     2a2:	82 83       	std	Z+2, r24	; 0x02

	TIMER_0_init();
     2a4:	02 d1       	rcall	.+516    	; 0x4aa <TIMER_0_init>
     2a6:	08 95       	ret

000002a8 <DIGGSIGG_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTC.DIR |= (1 << pin);
     2a8:	41 9a       	sbi	0x08, 1	; 8
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
	} else {
		VPORTC.OUT &= ~(1 << pin);
     2aa:	49 98       	cbi	0x09, 1	; 9
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLA |= PORTMUX_LUT1_bm;
     2ac:	e0 e0       	ldi	r30, 0x00	; 0
     2ae:	f2 e0       	ldi	r31, 0x02	; 2
     2b0:	80 81       	ld	r24, Z
     2b2:	80 62       	ori	r24, 0x20	; 32
     2b4:	80 83       	st	Z, r24

	DIGGSIGG_init();
     2b6:	75 df       	rcall	.-278    	; 0x1a2 <DIGGSIGG_init>
     2b8:	08 95       	ret

000002ba <SPI_0_initialization>:
 */
static inline void PORTA_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
     2ba:	02 98       	cbi	0x00, 2	; 0
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2bc:	e2 e1       	ldi	r30, 0x12	; 18
     2be:	f4 e0       	ldi	r31, 0x04	; 4
     2c0:	80 81       	ld	r24, Z
     2c2:	87 7f       	andi	r24, 0xF7	; 247
     2c4:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     2c6:	01 9a       	sbi	0x00, 1	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     2c8:	09 98       	cbi	0x01, 1	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     2ca:	03 9a       	sbi	0x00, 3	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     2cc:	0b 98       	cbi	0x01, 3	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     2ce:	04 9a       	sbi	0x00, 4	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     2d0:	0c 98       	cbi	0x01, 4	; 1
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	SPI_0_init();
     2d2:	e3 d0       	rcall	.+454    	; 0x49a <SPI_0_init>
     2d4:	08 95       	ret

000002d6 <DAC_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     2d6:	e6 e1       	ldi	r30, 0x16	; 22
     2d8:	f4 e0       	ldi	r31, 0x04	; 4
     2da:	80 81       	ld	r24, Z
     2dc:	88 7f       	andi	r24, 0xF8	; 248
     2de:	84 60       	ori	r24, 0x04	; 4
     2e0:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2e2:	80 81       	ld	r24, Z
     2e4:	87 7f       	andi	r24, 0xF7	; 247
     2e6:	80 83       	st	Z, r24
	// Disable digital input buffer
	AXON_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	AXON_PIN_set_pull_mode(PORT_PULL_OFF);

	DAC_init();
     2e8:	79 df       	rcall	.-270    	; 0x1dc <DAC_init>
     2ea:	08 95       	ret

000002ec <system_init>:
/**
 * \brief System initialization
 */
void system_init()
{
	mcu_init();
     2ec:	7f df       	rcall	.-258    	; 0x1ec <mcu_init>
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     2ee:	27 98       	cbi	0x04, 7	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2f0:	e7 e3       	ldi	r30, 0x37	; 55
     2f2:	f4 e0       	ldi	r31, 0x04	; 4
     2f4:	80 81       	ld	r24, Z
     2f6:	87 7f       	andi	r24, 0xF7	; 247
     2f8:	80 83       	st	Z, r24
 */
static inline void PORTC_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
     2fa:	42 98       	cbi	0x08, 2	; 8
static inline void PORTC_set_pin_pull_mode(const uint8_t pin, const enum port_pull_mode pull_mode)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
     2fc:	e2 e5       	ldi	r30, 0x52	; 82
     2fe:	f4 e0       	ldi	r31, 0x04	; 4
     300:	80 81       	ld	r24, Z
     302:	88 60       	ori	r24, 0x08	; 8
     304:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTC.DIR |= (1 << pin);
     306:	45 9a       	sbi	0x08, 5	; 8
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     308:	4d 9a       	sbi	0x09, 5	; 9
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    true);

	CLKCTRL_init();
     30a:	59 df       	rcall	.-334    	; 0x1be <CLKCTRL_init>

	RTC_init();
     30c:	a8 d0       	rcall	.+336    	; 0x45e <RTC_init>

	ADC_initialization();
     30e:	8a df       	rcall	.-236    	; 0x224 <ADC_initialization>

	USART_0_initialization();
     310:	b8 df       	rcall	.-144    	; 0x282 <USART_0_initialization>

	TIMER_0_initialization();
     312:	c1 df       	rcall	.-126    	; 0x296 <TIMER_0_initialization>

	DIGGSIGG_initialization();
     314:	c9 df       	rcall	.-110    	; 0x2a8 <DIGGSIGG_initialization>

	SPI_0_initialization();
     316:	d1 df       	rcall	.-94     	; 0x2ba <SPI_0_initialization>

	DAC_initialization();
     318:	de df       	rcall	.-68     	; 0x2d6 <DAC_initialization>

	CPUINT_init();
     31a:	5d df       	rcall	.-326    	; 0x1d6 <CPUINT_init>

	SLPCTRL_init();
     31c:	bc d0       	rcall	.+376    	; 0x496 <SLPCTRL_init>

	BOD_init();
     31e:	3f df       	rcall	.-386    	; 0x19e <BOD_init>
     320:	08 95       	ret

00000322 <protected_write_io>:
#if defined(__GNUC__)
  
#ifdef RAMPZ
	out     _SFR_IO_ADDR(RAMPZ), r1         // Clear bits 23:16 of Z
#endif
	movw    r30, r24                // Load addr into Z
     322:	fc 01       	movw	r30, r24
	out     CCP, r22                // Start CCP handshake
     324:	64 bf       	out	0x34, r22	; 52
	st      Z, r20                  // Write value to I/O register
     326:	40 83       	st	Z, r20
	ret                             // Return to caller
     328:	08 95       	ret

0000032a <enqueue>:
 */ 
#include <stdio.h>
#include <stdlib.h>
#include "include/queue.h"

void enqueue(node_t **head, uint32_t val) {
     32a:	cf 92       	push	r12
     32c:	df 92       	push	r13
     32e:	ef 92       	push	r14
     330:	ff 92       	push	r15
     332:	cf 93       	push	r28
     334:	df 93       	push	r29
     336:	ec 01       	movw	r28, r24
     338:	6a 01       	movw	r12, r20
     33a:	7b 01       	movw	r14, r22
	// remember, head is at the very BACK of the queue (The element that will wait the longest until dequeued)
	
	// we create a new empty node
	node_t *new_node = malloc(sizeof(node_t));
     33c:	86 e0       	ldi	r24, 0x06	; 6
     33e:	90 e0       	ldi	r25, 0x00	; 0
     340:	db d7       	rcall	.+4022   	; 0x12f8 <malloc>
	// Not quite sure what happens here, but it seems to be some sort of error handling, except you never know if there has been an error :/
	if (!new_node) return;
     342:	00 97       	sbiw	r24, 0x00	; 0
     344:	59 f0       	breq	.+22     	; 0x35c <enqueue+0x32>

	// we configure our node
	new_node->val = val;
     346:	fc 01       	movw	r30, r24
     348:	c0 82       	st	Z, r12
     34a:	d1 82       	std	Z+1, r13	; 0x01
     34c:	e2 82       	std	Z+2, r14	; 0x02
     34e:	f3 82       	std	Z+3, r15	; 0x03
	new_node->next = *head;
     350:	28 81       	ld	r18, Y
     352:	39 81       	ldd	r19, Y+1	; 0x01
     354:	24 83       	std	Z+4, r18	; 0x04
     356:	35 83       	std	Z+5, r19	; 0x05

	// and lastly, we change the pointer pointing to the previous head node, to point to our new node instead
	*head = new_node;
     358:	88 83       	st	Y, r24
     35a:	99 83       	std	Y+1, r25	; 0x01
}
     35c:	df 91       	pop	r29
     35e:	cf 91       	pop	r28
     360:	ff 90       	pop	r15
     362:	ef 90       	pop	r14
     364:	df 90       	pop	r13
     366:	cf 90       	pop	r12
     368:	08 95       	ret

0000036a <dequeue>:

uint32_t dequeue(node_t **head) {
     36a:	cf 92       	push	r12
     36c:	df 92       	push	r13
     36e:	ef 92       	push	r14
     370:	ff 92       	push	r15
     372:	0f 93       	push	r16
     374:	1f 93       	push	r17
     376:	cf 93       	push	r28
     378:	df 93       	push	r29
	node_t *current, *prev = NULL;
	uint32_t retval = 0;

	// If the queue we have been given is empty, we return an error
	// (0 is usually not an error, but it is probably the best option)
	if (*head == NULL) return 0;
     37a:	dc 01       	movw	r26, r24
     37c:	ed 91       	ld	r30, X+
     37e:	fc 91       	ld	r31, X
     380:	30 97       	sbiw	r30, 0x00	; 0
     382:	11 f1       	breq	.+68     	; 0x3c8 <dequeue+0x5e>
     384:	c0 e0       	ldi	r28, 0x00	; 0
     386:	d0 e0       	ldi	r29, 0x00	; 0
     388:	02 c0       	rjmp	.+4      	; 0x38e <dequeue+0x24>
     38a:	ef 01       	movw	r28, r30

	// Now we iterate through the queue until we reach the end
	current = *head;
	while (current->next != NULL) {
		prev = current;
		current = current->next;
     38c:	f9 01       	movw	r30, r18
	// (0 is usually not an error, but it is probably the best option)
	if (*head == NULL) return 0;

	// Now we iterate through the queue until we reach the end
	current = *head;
	while (current->next != NULL) {
     38e:	24 81       	ldd	r18, Z+4	; 0x04
     390:	35 81       	ldd	r19, Z+5	; 0x05
     392:	21 15       	cp	r18, r1
     394:	31 05       	cpc	r19, r1
     396:	c9 f7       	brne	.-14     	; 0x38a <dequeue+0x20>
     398:	8c 01       	movw	r16, r24
		prev = current;
		current = current->next;
	}

	// We retrieve the value we needed
	retval = current->val;
     39a:	c0 80       	ld	r12, Z
     39c:	d1 80       	ldd	r13, Z+1	; 0x01
     39e:	e2 80       	ldd	r14, Z+2	; 0x02
     3a0:	f3 80       	ldd	r15, Z+3	; 0x03
	// and remove the last element of the queue from the queue
	free(current);
     3a2:	cf 01       	movw	r24, r30
     3a4:	41 d8       	rcall	.-3966   	; 0xfffff428 <__eeprom_end+0xff7ef428>
	
	// Now we update the previous node so that it becomes the front of the queue
	// In case the queue only had one element, the prev will be null (false)
	if (prev){
     3a6:	20 97       	sbiw	r28, 0x00	; 0
     3a8:	39 f0       	breq	.+14     	; 0x3b8 <dequeue+0x4e>
	prev->next = NULL;}
     3aa:	1c 82       	std	Y+4, r1	; 0x04
     3ac:	1d 82       	std	Y+5, r1	; 0x05
	else{
	*head = NULL;}

	return retval;
     3ae:	6c 2d       	mov	r22, r12
     3b0:	7d 2d       	mov	r23, r13
     3b2:	8e 2d       	mov	r24, r14
     3b4:	9f 2d       	mov	r25, r15
     3b6:	0c c0       	rjmp	.+24     	; 0x3d0 <dequeue+0x66>
	// Now we update the previous node so that it becomes the front of the queue
	// In case the queue only had one element, the prev will be null (false)
	if (prev){
	prev->next = NULL;}
	else{
	*head = NULL;}
     3b8:	f8 01       	movw	r30, r16
     3ba:	10 82       	st	Z, r1
     3bc:	11 82       	std	Z+1, r1	; 0x01

	return retval;
     3be:	6c 2d       	mov	r22, r12
     3c0:	7d 2d       	mov	r23, r13
     3c2:	8e 2d       	mov	r24, r14
     3c4:	9f 2d       	mov	r25, r15
     3c6:	04 c0       	rjmp	.+8      	; 0x3d0 <dequeue+0x66>
	node_t *current, *prev = NULL;
	uint32_t retval = 0;

	// If the queue we have been given is empty, we return an error
	// (0 is usually not an error, but it is probably the best option)
	if (*head == NULL) return 0;
     3c8:	60 e0       	ldi	r22, 0x00	; 0
     3ca:	70 e0       	ldi	r23, 0x00	; 0
     3cc:	80 e0       	ldi	r24, 0x00	; 0
     3ce:	90 e0       	ldi	r25, 0x00	; 0
	prev->next = NULL;}
	else{
	*head = NULL;}

	return retval;
}
     3d0:	df 91       	pop	r29
     3d2:	cf 91       	pop	r28
     3d4:	1f 91       	pop	r17
     3d6:	0f 91       	pop	r16
     3d8:	ff 90       	pop	r15
     3da:	ef 90       	pop	r14
     3dc:	df 90       	pop	r13
     3de:	cf 90       	pop	r12
     3e0:	08 95       	ret

000003e2 <dequeue_top>:

// Here we remove the element of the queue that was added last (first in, last out)
uint32_t dequeue_top(node_t **head){
     3e2:	cf 92       	push	r12
     3e4:	df 92       	push	r13
     3e6:	ef 92       	push	r14
     3e8:	ff 92       	push	r15
     3ea:	0f 93       	push	r16
     3ec:	1f 93       	push	r17
     3ee:	cf 93       	push	r28
     3f0:	df 93       	push	r29
	node_t *oldHead;
	uint32_t retval = 0;
	
	// If the queue we have been given is empty, we return an error
	// (0 is usually not an error, but it is probably the best option)
	if (*head == NULL) return 0;
     3f2:	dc 01       	movw	r26, r24
     3f4:	ed 91       	ld	r30, X+
     3f6:	fc 91       	ld	r31, X
     3f8:	30 97       	sbiw	r30, 0x00	; 0
     3fa:	81 f0       	breq	.+32     	; 0x41c <__LOCK_REGION_LENGTH__+0x1c>
     3fc:	ec 01       	movw	r28, r24
	
	oldHead = *head;
	// We then set the new head to be the second last in the queue
	newHead = oldHead->next;
     3fe:	c4 80       	ldd	r12, Z+4	; 0x04
     400:	d5 80       	ldd	r13, Z+5	; 0x05
	
	// We retrieve the heads value
	retval = oldHead->val;
     402:	e0 80       	ld	r14, Z
     404:	f1 80       	ldd	r15, Z+1	; 0x01
     406:	02 81       	ldd	r16, Z+2	; 0x02
     408:	13 81       	ldd	r17, Z+3	; 0x03
	
	// We free the memory that was used to store the old head
	free(oldHead);
     40a:	cf 01       	movw	r24, r30
     40c:	0d d8       	rcall	.-4070   	; 0xfffff428 <__eeprom_end+0xff7ef428>
	
	//And then we overwrite the value of head to be the second last
	*head = newHead;
     40e:	c8 82       	st	Y, r12
     410:	d9 82       	std	Y+1, r13	; 0x01
	
	return retval;
     412:	6e 2d       	mov	r22, r14
     414:	7f 2d       	mov	r23, r15
     416:	80 2f       	mov	r24, r16
     418:	91 2f       	mov	r25, r17
     41a:	04 c0       	rjmp	.+8      	; 0x424 <__LOCK_REGION_LENGTH__+0x24>
	node_t *oldHead;
	uint32_t retval = 0;
	
	// If the queue we have been given is empty, we return an error
	// (0 is usually not an error, but it is probably the best option)
	if (*head == NULL) return 0;
     41c:	60 e0       	ldi	r22, 0x00	; 0
     41e:	70 e0       	ldi	r23, 0x00	; 0
     420:	80 e0       	ldi	r24, 0x00	; 0
     422:	90 e0       	ldi	r25, 0x00	; 0
	//And then we overwrite the value of head to be the second last
	*head = newHead;
	
	return retval;
	
}
     424:	df 91       	pop	r29
     426:	cf 91       	pop	r28
     428:	1f 91       	pop	r17
     42a:	0f 91       	pop	r16
     42c:	ff 90       	pop	r15
     42e:	ef 90       	pop	r14
     430:	df 90       	pop	r13
     432:	cf 90       	pop	r12
     434:	08 95       	ret

00000436 <read_end>:
	node_t *current, *prev = NULL;
	uint32_t retval = 0;

	// If the queue we have been given is empty, we return an error
	// (0 is usually not an error, but it is probably the best option)
	if (*head == NULL) return 0;
     436:	dc 01       	movw	r26, r24
     438:	ed 91       	ld	r30, X+
     43a:	fc 91       	ld	r31, X
     43c:	30 97       	sbiw	r30, 0x00	; 0
     43e:	11 f4       	brne	.+4      	; 0x444 <read_end+0xe>
     440:	0a c0       	rjmp	.+20     	; 0x456 <read_end+0x20>

	// Now we iterate through the queue until we reach the end
	current = *head;
	while (current->next != NULL) {
		prev = current;
		current = current->next;
     442:	fc 01       	movw	r30, r24
	// (0 is usually not an error, but it is probably the best option)
	if (*head == NULL) return 0;

	// Now we iterate through the queue until we reach the end
	current = *head;
	while (current->next != NULL) {
     444:	84 81       	ldd	r24, Z+4	; 0x04
     446:	95 81       	ldd	r25, Z+5	; 0x05
     448:	00 97       	sbiw	r24, 0x00	; 0
     44a:	d9 f7       	brne	.-10     	; 0x442 <read_end+0xc>
		prev = current;
		current = current->next;
	}

	// We retrieve the value we needed
	retval = current->val;
     44c:	60 81       	ld	r22, Z
     44e:	71 81       	ldd	r23, Z+1	; 0x01
     450:	82 81       	ldd	r24, Z+2	; 0x02
     452:	93 81       	ldd	r25, Z+3	; 0x03
	
	return retval;
     454:	08 95       	ret
	node_t *current, *prev = NULL;
	uint32_t retval = 0;

	// If the queue we have been given is empty, we return an error
	// (0 is usually not an error, but it is probably the best option)
	if (*head == NULL) return 0;
     456:	60 e0       	ldi	r22, 0x00	; 0
     458:	70 e0       	ldi	r23, 0x00	; 0
     45a:	cb 01       	movw	r24, r22
	// We retrieve the value we needed
	retval = current->val;
	
	return retval;
	
     45c:	08 95       	ret

0000045e <RTC_init>:
 * \return Initialization status.
 */
int8_t RTC_init()
{

	while (RTC.STATUS > 0) { /* Wait for all register to be synchronized */
     45e:	e0 e4       	ldi	r30, 0x40	; 64
     460:	f1 e0       	ldi	r31, 0x01	; 1
     462:	81 81       	ldd	r24, Z+1	; 0x01
     464:	81 11       	cpse	r24, r1
     466:	fd cf       	rjmp	.-6      	; 0x462 <RTC_init+0x4>
	}

	// RTC.CMP = 0x0; /* Compare: 0x0 */

	RTC.CNT = 0x20; /* Counter: 0x20 */
     468:	e0 e4       	ldi	r30, 0x40	; 64
     46a:	f1 e0       	ldi	r31, 0x01	; 1
     46c:	80 e2       	ldi	r24, 0x20	; 32
     46e:	90 e0       	ldi	r25, 0x00	; 0
     470:	80 87       	std	Z+8, r24	; 0x08
     472:	91 87       	std	Z+9, r25	; 0x09

	RTC.CTRLA = RTC_PRESCALER_DIV1_gc   /* 1 */
     474:	81 e8       	ldi	r24, 0x81	; 129
     476:	80 83       	st	Z, r24
	            | 1 << RTC_RTCEN_bp     /* Enable: enabled */
	            | 1 << RTC_RUNSTDBY_bp; /* Run In Standby: enabled */

	RTC.PER = 0x20 / TIMESCALE; /* Period: 0x20 */
     478:	80 e8       	ldi	r24, 0x80	; 128
     47a:	9c e0       	ldi	r25, 0x0C	; 12
     47c:	82 87       	std	Z+10, r24	; 0x0a
     47e:	93 87       	std	Z+11, r25	; 0x0b

	// RTC.CLKSEL = RTC_CLKSEL_INT32K_gc; /* 32KHz Internal Ultra Low Power Oscillator (OSCULP32K) */

	RTC.DBGCTRL = 1 << RTC_DBGRUN_bp; /* Run in debug: enabled */
     480:	81 e0       	ldi	r24, 0x01	; 1
     482:	85 83       	std	Z+5, r24	; 0x05

	RTC.INTCTRL = 0 << RTC_CMP_bp    /* Compare Match Interrupt enable: disabled */
     484:	82 83       	std	Z+2, r24	; 0x02
	              | 1 << RTC_OVF_bp; /* Overflow Interrupt enable: enabled */

	while (RTC.PITSTATUS > 0) { /* Wait for all register to be synchronized */
     486:	81 89       	ldd	r24, Z+17	; 0x11
     488:	81 11       	cpse	r24, r1
     48a:	fd cf       	rjmp	.-6      	; 0x486 <RTC_init+0x28>
	}

	RTC.PITCTRLA = RTC_PERIOD_OFF_gc    /* Off */
     48c:	81 e0       	ldi	r24, 0x01	; 1
     48e:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <__TEXT_REGION_LENGTH__+0x700150>
	// RTC.PITDBGCTRL = 0 << RTC_DBGRUN_bp; /* Run in debug: disabled */

	// RTC.PITINTCTRL = 0 << RTC_PI_bp; /* Periodic Interrupt: disabled */

	return 0;
}
     492:	80 e0       	ldi	r24, 0x00	; 0
     494:	08 95       	ret

00000496 <SLPCTRL_init>:

	// SLPCTRL.CTRLA = 0 << SLPCTRL_SEN_bp /* Sleep enable: disabled */
	//		 | SLPCTRL_SMODE_IDLE_gc; /* Idle mode */

	return 0;
}
     496:	80 e0       	ldi	r24, 0x00	; 0
     498:	08 95       	ret

0000049a <SPI_0_init>:
 * \return Initialization status
 */
int8_t SPI_0_init()
{

	SPI0.CTRLA = 0 << SPI_CLK2X_bp     /* Enable Double Speed: disabled */
     49a:	e0 e2       	ldi	r30, 0x20	; 32
     49c:	f8 e0       	ldi	r31, 0x08	; 8
     49e:	83 e2       	ldi	r24, 0x23	; 35
     4a0:	80 83       	st	Z, r24
	             | 0 << SPI_DORD_bp    /* Data Order Setting: disabled */
	             | 1 << SPI_ENABLE_bp  /* Enable Module: enabled */
	             | 1 << SPI_MASTER_bp  /* SPI module in master mode */
	             | SPI_PRESC_DIV16_gc; /* System Clock / 16 */

	SPI0.CTRLB = 0 << SPI_BUFEN_bp   /* Buffer Mode Enable: disabled */
     4a2:	84 e0       	ldi	r24, 0x04	; 4
     4a4:	81 83       	std	Z+1, r24	; 0x01
	//		 | 0 << SPI_RXCIE_bp /* Receive Complete Interrupt Enable: disabled */
	//		 | 0 << SPI_SSIE_bp /* Slave Select Trigger Interrupt Enable: disabled */
	//		 | 0 << SPI_TXCIE_bp; /* Transfer Complete Interrupt Enable: disabled */

	return 0;
}
     4a6:	80 e0       	ldi	r24, 0x00	; 0
     4a8:	08 95       	ret

000004aa <TIMER_0_init>:

	// TCA0.SINGLE.CMP0 = 0x0; /* Compare Register 0: 0x0 */

	// TCA0.SINGLE.CMP1 = 0x0; /* Compare Register 1: 0x0 */

	TCA0.SINGLE.CMP2 = 0x4; /* Compare Register 2: 0x4 */
     4aa:	e0 e0       	ldi	r30, 0x00	; 0
     4ac:	fa e0       	ldi	r31, 0x0A	; 10
     4ae:	84 e0       	ldi	r24, 0x04	; 4
     4b0:	90 e0       	ldi	r25, 0x00	; 0
     4b2:	84 a7       	std	Z+44, r24	; 0x2c
     4b4:	95 a7       	std	Z+45, r25	; 0x2d

	// TCA0.SINGLE.CNT = 0x0; /* Count: 0x0 */

	TCA0.SINGLE.CTRLB = 0 << TCA_SINGLE_ALUPD_bp            /* Auto Lock Update: disabled */
     4b6:	83 e4       	ldi	r24, 0x43	; 67
     4b8:	81 83       	std	Z+1, r24	; 0x01
	                    | 0 << TCA_SINGLE_CMP0EN_bp         /* Compare 0 Enable: disabled */
	                    | 0 << TCA_SINGLE_CMP1EN_bp         /* Compare 1 Enable: disabled */
	                    | 1 << TCA_SINGLE_CMP2EN_bp         /* Compare 2 Enable: enabled */
	                    | TCA_SINGLE_WGMODE_SINGLESLOPE_gc; /*  */

	TCA0.SINGLE.CTRLC = 0 << TCA_SINGLE_CMP0OV_bp    /* Compare 0 Waveform Output Value: disabled */
     4ba:	84 e0       	ldi	r24, 0x04	; 4
     4bc:	82 83       	std	Z+2, r24	; 0x02
	// TCA0.SINGLE.INTCTRL = 0 << TCA_SINGLE_CMP0_bp /* Compare 0 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP1_bp /* Compare 1 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP2_bp /* Compare 2 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_OVF_bp; /* Overflow Interrupt: disabled */

	TCA0.SINGLE.PER = 0x7; /* Period: 0x7 */
     4be:	87 e0       	ldi	r24, 0x07	; 7
     4c0:	90 e0       	ldi	r25, 0x00	; 0
     4c2:	86 a3       	std	Z+38, r24	; 0x26
     4c4:	97 a3       	std	Z+39, r25	; 0x27

	// TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV1_gc /* System Clock */
	//		 | 0 << TCA_SINGLE_ENABLE_bp; /* Module Enable: disabled */

	return 0;
}
     4c6:	80 e0       	ldi	r24, 0x00	; 0
     4c8:	08 95       	ret

000004ca <USART_0_init>:
uint8_t USART_0_read()
{
	while (!(USART0.STATUS & USART_RXCIF_bm))
		;
	return USART0.RXDATAL;
}
     4ca:	e0 e0       	ldi	r30, 0x00	; 0
     4cc:	f8 e0       	ldi	r31, 0x08	; 8
     4ce:	87 e4       	ldi	r24, 0x47	; 71
     4d0:	90 e1       	ldi	r25, 0x10	; 16
     4d2:	80 87       	std	Z+8, r24	; 0x08
     4d4:	91 87       	std	Z+9, r25	; 0x09
     4d6:	80 ec       	ldi	r24, 0xC0	; 192
     4d8:	86 83       	std	Z+6, r24	; 0x06
     4da:	86 e0       	ldi	r24, 0x06	; 6
     4dc:	9e e3       	ldi	r25, 0x3E	; 62
     4de:	80 93 69 3e 	sts	0x3E69, r24	; 0x803e69 <__iob+0x2>
     4e2:	90 93 6a 3e 	sts	0x3E6A, r25	; 0x803e6a <__iob+0x3>
     4e6:	80 e0       	ldi	r24, 0x00	; 0
     4e8:	08 95       	ret

000004ea <USART_0_write>:
 *
 * \return Nothing
 */
void USART_0_write(const uint8_t data)
{
	while (!(USART0.STATUS & USART_DREIF_bm))
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f8 e0       	ldi	r31, 0x08	; 8
     4ee:	94 81       	ldd	r25, Z+4	; 0x04
     4f0:	95 ff       	sbrs	r25, 5
     4f2:	fd cf       	rjmp	.-6      	; 0x4ee <USART_0_write+0x4>
		;
	USART0.TXDATAL = data;
     4f4:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <__TEXT_REGION_LENGTH__+0x700802>
     4f8:	08 95       	ret

000004fa <USART_0_printCHAR>:

#if defined(__GNUC__)

int USART_0_printCHAR(char character, FILE *stream)
{
	USART_0_write(character);
     4fa:	f7 df       	rcall	.-18     	; 0x4ea <USART_0_write>
	return 0;
}
     4fc:	80 e0       	ldi	r24, 0x00	; 0
     4fe:	90 e0       	ldi	r25, 0x00	; 0
     500:	08 95       	ret

00000502 <tinyCharge_is_charging>:
_Bool charging;

_Bool tinyCharge_is_charging(){
	return false;
	//return charging;
}
     502:	80 e0       	ldi	r24, 0x00	; 0
     504:	08 95       	ret

00000506 <tinyCharge_set_charging>:

void tinyCharge_set_charging(_Bool charging_status){
	charging = charging_status;
     506:	80 93 62 3e 	sts	0x3E62, r24	; 0x803e62 <charging>
     50a:	08 95       	ret

0000050c <tinyCharge_set_transistors>:
}


void tinyCharge_set_transistors(){
	if(charging){
     50c:	80 91 62 3e 	lds	r24, 0x3E62	; 0x803e62 <charging>
     510:	88 23       	and	r24, r24
     512:	11 f0       	breq	.+4      	; 0x518 <tinyCharge_set_transistors+0xc>
	} else {
		VPORTC.OUT &= ~(1 << pin);
     514:	4d 98       	cbi	0x09, 5	; 9
     516:	08 95       	ret
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     518:	4d 9a       	sbi	0x09, 5	; 9
     51a:	08 95       	ret

0000051c <tinyDebugger_send_int>:
	dtostrf(value,1,NUMBER_OF_DECIMALS, number);
	printf("%s:%s;", name, number);
}
void tinyDebugger_send_string(const char* name, char * value){
	printf("%s:%s;", name, value);
}
     51c:	7f 93       	push	r23
     51e:	6f 93       	push	r22
     520:	9f 93       	push	r25
     522:	8f 93       	push	r24
     524:	88 e8       	ldi	r24, 0x88	; 136
     526:	9f e9       	ldi	r25, 0x9F	; 159
     528:	9f 93       	push	r25
     52a:	8f 93       	push	r24
     52c:	06 d8       	rcall	.-4084   	; 0xfffff53a <__eeprom_end+0xff7ef53a>
     52e:	0f 90       	pop	r0
     530:	0f 90       	pop	r0
     532:	0f 90       	pop	r0
     534:	0f 90       	pop	r0
     536:	0f 90       	pop	r0
     538:	0f 90       	pop	r0
     53a:	08 95       	ret

0000053c <tinyDebugger_send_float>:
     53c:	cf 92       	push	r12
     53e:	df 92       	push	r13
     540:	ef 92       	push	r14
     542:	ff 92       	push	r15
     544:	0f 93       	push	r16
     546:	1f 93       	push	r17
     548:	cf 93       	push	r28
     54a:	df 93       	push	r29
     54c:	cd b7       	in	r28, 0x3d	; 61
     54e:	de b7       	in	r29, 0x3e	; 62
     550:	64 97       	sbiw	r28, 0x14	; 20
     552:	cd bf       	out	0x3d, r28	; 61
     554:	de bf       	out	0x3e, r29	; 62
     556:	d8 2e       	mov	r13, r24
     558:	c9 2e       	mov	r12, r25
     55a:	cb 01       	movw	r24, r22
     55c:	ba 01       	movw	r22, r20
     55e:	9e 01       	movw	r18, r28
     560:	2f 5f       	subi	r18, 0xFF	; 255
     562:	3f 4f       	sbci	r19, 0xFF	; 255
     564:	79 01       	movw	r14, r18
     566:	89 01       	movw	r16, r18
     568:	21 e0       	ldi	r18, 0x01	; 1
     56a:	41 e0       	ldi	r20, 0x01	; 1
     56c:	a6 d6       	rcall	.+3404   	; 0x12ba <dtostrf>
     56e:	ff 92       	push	r15
     570:	ef 92       	push	r14
     572:	cf 92       	push	r12
     574:	df 92       	push	r13
     576:	8f e8       	ldi	r24, 0x8F	; 143
     578:	9f e9       	ldi	r25, 0x9F	; 159
     57a:	9f 93       	push	r25
     57c:	8f 93       	push	r24
     57e:	dd d7       	rcall	.+4026   	; 0x153a <printf>
     580:	0f 90       	pop	r0
     582:	0f 90       	pop	r0
     584:	0f 90       	pop	r0
     586:	0f 90       	pop	r0
     588:	0f 90       	pop	r0
     58a:	0f 90       	pop	r0
     58c:	64 96       	adiw	r28, 0x14	; 20
     58e:	cd bf       	out	0x3d, r28	; 61
     590:	de bf       	out	0x3e, r29	; 62
     592:	df 91       	pop	r29
     594:	cf 91       	pop	r28
     596:	1f 91       	pop	r17
     598:	0f 91       	pop	r16
     59a:	ff 90       	pop	r15
     59c:	ef 90       	pop	r14
     59e:	df 90       	pop	r13
     5a0:	cf 90       	pop	r12
     5a2:	08 95       	ret

000005a4 <tinyDebugger_end_line>:
void tinyDebugger_end_line(){
	printf("\r\n");
     5a4:	86 e9       	ldi	r24, 0x96	; 150
     5a6:	9f e9       	ldi	r25, 0x9F	; 159
     5a8:	db d7       	rcall	.+4022   	; 0x1560 <puts>
     5aa:	08 95       	ret

000005ac <tinyPulse_toggle_pulse_mode>:
uint32_t time_of_last_pulse = 0;
uint16_t time_since_last_pulse = 0;
uint16_t ideal_time_between_pulses = 1000/PULSEMODE_FREQUENCY;

void tinyPulse_toggle_pulse_mode(){
	pulse_mode = !pulse_mode;
     5ac:	90 91 22 3e 	lds	r25, 0x3E22	; 0x803e22 <pulse_mode>
     5b0:	81 e0       	ldi	r24, 0x01	; 1
     5b2:	89 27       	eor	r24, r25
     5b4:	80 93 22 3e 	sts	0x3E22, r24	; 0x803e22 <pulse_mode>
     5b8:	08 95       	ret

000005ba <tinyPulse_update_potential>:
}

double tinyPulse_update_potential(double potential){
     5ba:	cf 92       	push	r12
     5bc:	df 92       	push	r13
     5be:	ef 92       	push	r14
     5c0:	ff 92       	push	r15
     5c2:	6b 01       	movw	r12, r22
     5c4:	7c 01       	movw	r14, r24
	if(pulse_mode){
     5c6:	80 91 22 3e 	lds	r24, 0x3E22	; 0x803e22 <pulse_mode>
     5ca:	88 23       	and	r24, r24
     5cc:	21 f1       	breq	.+72     	; 0x616 <tinyPulse_update_potential+0x5c>
		
		time_since_last_pulse = tinyTime_now() - time_of_last_pulse;
     5ce:	3e d0       	rcall	.+124    	; 0x64c <tinyTime_now>
     5d0:	20 91 1e 3e 	lds	r18, 0x3E1E	; 0x803e1e <time_of_last_pulse>
     5d4:	30 91 1f 3e 	lds	r19, 0x3E1F	; 0x803e1f <time_of_last_pulse+0x1>
     5d8:	62 1b       	sub	r22, r18
     5da:	73 0b       	sbc	r23, r19
     5dc:	60 93 1c 3e 	sts	0x3E1C, r22	; 0x803e1c <__data_end>
     5e0:	70 93 1d 3e 	sts	0x3E1D, r23	; 0x803e1d <__data_end+0x1>
		
		if(time_since_last_pulse >= ideal_time_between_pulses){
     5e4:	80 91 14 3e 	lds	r24, 0x3E14	; 0x803e14 <ideal_time_between_pulses>
     5e8:	90 91 15 3e 	lds	r25, 0x3E15	; 0x803e15 <ideal_time_between_pulses+0x1>
     5ec:	68 17       	cp	r22, r24
     5ee:	79 07       	cpc	r23, r25
     5f0:	90 f0       	brcs	.+36     	; 0x616 <tinyPulse_update_potential+0x5c>
			potential += BUTTON_PRESS_REACTION;
     5f2:	20 e0       	ldi	r18, 0x00	; 0
     5f4:	30 e0       	ldi	r19, 0x00	; 0
     5f6:	40 ed       	ldi	r20, 0xD0	; 208
     5f8:	51 e4       	ldi	r21, 0x41	; 65
     5fa:	c7 01       	movw	r24, r14
     5fc:	b6 01       	movw	r22, r12
     5fe:	d3 d3       	rcall	.+1958   	; 0xda6 <__addsf3>
     600:	6b 01       	movw	r12, r22
     602:	7c 01       	movw	r14, r24
			time_of_last_pulse = tinyTime_now();			
     604:	23 d0       	rcall	.+70     	; 0x64c <tinyTime_now>
     606:	60 93 1e 3e 	sts	0x3E1E, r22	; 0x803e1e <time_of_last_pulse>
     60a:	70 93 1f 3e 	sts	0x3E1F, r23	; 0x803e1f <time_of_last_pulse+0x1>
     60e:	80 93 20 3e 	sts	0x3E20, r24	; 0x803e20 <time_of_last_pulse+0x2>
     612:	90 93 21 3e 	sts	0x3E21, r25	; 0x803e21 <time_of_last_pulse+0x3>
		}
	}
	return potential;
}
     616:	c7 01       	movw	r24, r14
     618:	b6 01       	movw	r22, r12
     61a:	ff 90       	pop	r15
     61c:	ef 90       	pop	r14
     61e:	df 90       	pop	r13
     620:	cf 90       	pop	r12
     622:	08 95       	ret

00000624 <tinyTime_counter_increment>:
If the Interrupt Service Routine is clocked by a crystal oscillator
it gives a very precise timer-counter.
*/
void tinyTime_counter_increment(void)
{
	time_counter++;
     624:	80 91 23 3e 	lds	r24, 0x3E23	; 0x803e23 <time_counter>
     628:	90 91 24 3e 	lds	r25, 0x3E24	; 0x803e24 <time_counter+0x1>
     62c:	a0 91 25 3e 	lds	r26, 0x3E25	; 0x803e25 <time_counter+0x2>
     630:	b0 91 26 3e 	lds	r27, 0x3E26	; 0x803e26 <time_counter+0x3>
     634:	01 96       	adiw	r24, 0x01	; 1
     636:	a1 1d       	adc	r26, r1
     638:	b1 1d       	adc	r27, r1
     63a:	80 93 23 3e 	sts	0x3E23, r24	; 0x803e23 <time_counter>
     63e:	90 93 24 3e 	sts	0x3E24, r25	; 0x803e24 <time_counter+0x1>
     642:	a0 93 25 3e 	sts	0x3E25, r26	; 0x803e25 <time_counter+0x2>
     646:	b0 93 26 3e 	sts	0x3E26, r27	; 0x803e26 <time_counter+0x3>
     64a:	08 95       	ret

0000064c <tinyTime_now>:
/*
This function is callable by external libraries to give them the counted time so far.
*/
uint32_t tinyTime_now(void)
{
	return time_counter;
     64c:	60 91 23 3e 	lds	r22, 0x3E23	; 0x803e23 <time_counter>
     650:	70 91 24 3e 	lds	r23, 0x3E24	; 0x803e24 <time_counter+0x1>
     654:	80 91 25 3e 	lds	r24, 0x3E25	; 0x803e25 <time_counter+0x2>
     658:	90 91 26 3e 	lds	r25, 0x3E26	; 0x803e26 <time_counter+0x3>
     65c:	08 95       	ret

0000065e <main>:


int main(void)
{	
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
     65e:	83 dd       	rcall	.-1274   	; 0x166 <atmel_start_init>
	Setting this value will mean that the ADC (Analog to Digital Converter) will read 4.32v as 255, and 0v as 0.
	For some reason, instead of the reference voltage being 4.32v, it is 3.3v. 
	A plausible explanation is that the microchip does not up the voltage, so that if the microchip is only ever 
	supplied with 3.3v, it will output 3.3v as the max.
	*/
	VREF.CTRLA = VREF_ADC0REFSEL_4V34_gc;
     660:	80 e3       	ldi	r24, 0x30	; 48
     662:	80 93 a0 00 	sts	0x00A0, r24	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
	while (1)
	{
		// We don't want to update the neuron too often because of various reasons. The tinyISR_getflag is set every ms, and so the loop is only run once every ms.  
		if(tinyISR_getflag())
     666:	48 d3       	rcall	.+1680   	; 0xcf8 <tinyISR_getflag>
     668:	88 23       	and	r24, r24
     66a:	e9 f3       	breq	.-6      	; 0x666 <main+0x8>
		{			
			
			if(tinyCharge_is_charging()){
     66c:	4a df       	rcall	.-364    	; 0x502 <tinyCharge_is_charging>
     66e:	88 23       	and	r24, r24
     670:	11 f0       	breq	.+4      	; 0x676 <main+0x18>
				// Charge loop
				
				// We check the Dendrites in order to detect if we have stopped charging
				tinyDendrite_update_signals();
     672:	22 d2       	rcall	.+1092   	; 0xab8 <tinyDendrite_update_signals>
     674:	02 c0       	rjmp	.+4      	; 0x67a <main+0x1c>
				// Update led
				
			}
			else{
				// Main loop				
				tinyButton_update();
     676:	aa d0       	rcall	.+340    	; 0x7cc <tinyButton_update>
				
				tinyPotential_update();
     678:	42 d3       	rcall	.+1668   	; 0xcfe <tinyPotential_update>
			}
			
			
			// Switch transistors
			tinyCharge_set_transistors();
     67a:	48 df       	rcall	.-368    	; 0x50c <tinyCharge_set_transistors>
			
			// Prepare for next cycle
			tinyISR_setflag(false);
     67c:	80 e0       	ldi	r24, 0x00	; 0
     67e:	39 d3       	rcall	.+1650   	; 0xcf2 <tinyISR_setflag>
			tinyDebugger_send_int("time", tinyTime_now());
     680:	e5 df       	rcall	.-54     	; 0x64c <tinyTime_now>
     682:	88 e9       	ldi	r24, 0x98	; 152
     684:	9f e9       	ldi	r25, 0x9F	; 159
     686:	4a df       	rcall	.-364    	; 0x51c <tinyDebugger_send_int>
			tinyDebugger_end_line();
     688:	8d df       	rcall	.-230    	; 0x5a4 <tinyDebugger_end_line>
     68a:	ed cf       	rjmp	.-38     	; 0x666 <main+0x8>

0000068c <set_LED_fire>:



//function to be called upon when firing flag has been raised.
void set_LED_fire(void)
{
     68c:	cf 93       	push	r28
	fire_flash_time_counter = tinyTime_now();
     68e:	de df       	rcall	.-68     	; 0x64c <tinyTime_now>
     690:	60 93 27 3e 	sts	0x3E27, r22	; 0x803e27 <fire_flash_time_counter>
     694:	70 93 28 3e 	sts	0x3E28, r23	; 0x803e28 <fire_flash_time_counter+0x1>
     698:	80 93 29 3e 	sts	0x3E29, r24	; 0x803e29 <fire_flash_time_counter+0x2>
     69c:	90 93 2a 3e 	sts	0x3E2A, r25	; 0x803e2a <fire_flash_time_counter+0x3>
     6a0:	c0 e0       	ldi	r28, 0x00	; 0
	for (int i = 0; i < NUMBER_OF_LEDS; i++)
	{
		tinyCCLRGB_setColor(i, MAX_BRIGHTNESS, MAX_BRIGHTNESS, MAX_BRIGHTNESS);//As per the specs, all LEDs should be blue while firing.
     6a2:	20 e3       	ldi	r18, 0x30	; 48
     6a4:	40 e3       	ldi	r20, 0x30	; 48
     6a6:	60 e3       	ldi	r22, 0x30	; 48
     6a8:	8c 2f       	mov	r24, r28
     6aa:	fc d0       	rcall	.+504    	; 0x8a4 <tinyCCLRGB_setColor>
     6ac:	cf 5f       	subi	r28, 0xFF	; 255

//function to be called upon when firing flag has been raised.
void set_LED_fire(void)
{
	fire_flash_time_counter = tinyTime_now();
	for (int i = 0; i < NUMBER_OF_LEDS; i++)
     6ae:	c6 30       	cpi	r28, 0x06	; 6
     6b0:	c1 f7       	brne	.-16     	; 0x6a2 <set_LED_fire+0x16>
	{
		tinyCCLRGB_setColor(i, MAX_BRIGHTNESS, MAX_BRIGHTNESS, MAX_BRIGHTNESS);//As per the specs, all LEDs should be blue while firing.
	}
}
     6b2:	cf 91       	pop	r28
     6b4:	08 95       	ret

000006b6 <potential_to_RGB_update_LEDs>:



void potential_to_RGB_update_LEDs(double potential)
{
     6b6:	8f 92       	push	r8
     6b8:	9f 92       	push	r9
     6ba:	af 92       	push	r10
     6bc:	bf 92       	push	r11
     6be:	cf 92       	push	r12
     6c0:	df 92       	push	r13
     6c2:	ef 92       	push	r14
     6c4:	ff 92       	push	r15
     6c6:	0f 93       	push	r16
     6c8:	1f 93       	push	r17
     6ca:	cf 93       	push	r28
     6cc:	6b 01       	movw	r12, r22
     6ce:	7c 01       	movw	r14, r24
	if ((tinyTime_now() - fire_flash_time_counter) < FIRE_FLASH_TIME)
     6d0:	bd df       	rcall	.-134    	; 0x64c <tinyTime_now>
     6d2:	00 91 27 3e 	lds	r16, 0x3E27	; 0x803e27 <fire_flash_time_counter>
     6d6:	10 91 28 3e 	lds	r17, 0x3E28	; 0x803e28 <fire_flash_time_counter+0x1>
     6da:	20 91 29 3e 	lds	r18, 0x3E29	; 0x803e29 <fire_flash_time_counter+0x2>
     6de:	30 91 2a 3e 	lds	r19, 0x3E2A	; 0x803e2a <fire_flash_time_counter+0x3>
     6e2:	dc 01       	movw	r26, r24
     6e4:	cb 01       	movw	r24, r22
     6e6:	80 1b       	sub	r24, r16
     6e8:	91 0b       	sbc	r25, r17
     6ea:	a2 0b       	sbc	r26, r18
     6ec:	b3 0b       	sbc	r27, r19
     6ee:	84 36       	cpi	r24, 0x64	; 100
     6f0:	91 05       	cpc	r25, r1
     6f2:	a1 05       	cpc	r26, r1
     6f4:	b1 05       	cpc	r27, r1
     6f6:	50 f4       	brcc	.+20     	; 0x70c <potential_to_RGB_update_LEDs+0x56>
     6f8:	c0 e0       	ldi	r28, 0x00	; 0
	{
		for (int i = 0; i < NUMBER_OF_LEDS; i++)
		{
			tinyCCLRGB_setColor(i, MAX_BRIGHTNESS, MAX_BRIGHTNESS, MAX_BRIGHTNESS);
     6fa:	20 e3       	ldi	r18, 0x30	; 48
     6fc:	40 e3       	ldi	r20, 0x30	; 48
     6fe:	60 e3       	ldi	r22, 0x30	; 48
     700:	8c 2f       	mov	r24, r28
     702:	d0 d0       	rcall	.+416    	; 0x8a4 <tinyCCLRGB_setColor>
     704:	cf 5f       	subi	r28, 0xFF	; 255

void potential_to_RGB_update_LEDs(double potential)
{
	if ((tinyTime_now() - fire_flash_time_counter) < FIRE_FLASH_TIME)
	{
		for (int i = 0; i < NUMBER_OF_LEDS; i++)
     706:	c6 30       	cpi	r28, 0x06	; 6
     708:	c1 f7       	brne	.-16     	; 0x6fa <potential_to_RGB_update_LEDs+0x44>
     70a:	53 c0       	rjmp	.+166    	; 0x7b2 <potential_to_RGB_update_LEDs+0xfc>
     70c:	c0 e0       	ldi	r28, 0x00	; 0
*/
static void potential_to_RGB_set_color(double potential)
{
	for (int i = 0; i < NUMBER_OF_LEDS; i++)
	{
		tinyCCLRGB_setColor(i, 0x0, 0x0, 0x0);//Clear all LED stored values on the MCU before writing again.
     70e:	20 e0       	ldi	r18, 0x00	; 0
     710:	40 e0       	ldi	r20, 0x00	; 0
     712:	60 e0       	ldi	r22, 0x00	; 0
     714:	8c 2f       	mov	r24, r28
     716:	c6 d0       	rcall	.+396    	; 0x8a4 <tinyCCLRGB_setColor>
     718:	cf 5f       	subi	r28, 0xFF	; 255
When firing all lights turn blue for ~100ms, but this needs to be tested.
LEDs are numbered right way on top of PCB, but opposite way on bottom of PCB.
*/
static void potential_to_RGB_set_color(double potential)
{
	for (int i = 0; i < NUMBER_OF_LEDS; i++)
     71a:	c6 30       	cpi	r28, 0x06	; 6
     71c:	c1 f7       	brne	.-16     	; 0x70e <potential_to_RGB_update_LEDs+0x58>
	{
		tinyCCLRGB_setColor(i, 0x0, 0x0, 0x0);//Clear all LED stored values on the MCU before writing again.
	}
	double absolute_potential = abs(potential);//setting variable for absolute potential so it won't have to be calculated more than once.
     71e:	c7 01       	movw	r24, r14
     720:	b6 01       	movw	r22, r12
     722:	24 d4       	rcall	.+2120   	; 0xf6c <__fixsfsi>
     724:	9b 01       	movw	r18, r22
     726:	77 23       	and	r23, r23
     728:	24 f4       	brge	.+8      	; 0x732 <potential_to_RGB_update_LEDs+0x7c>
     72a:	22 27       	eor	r18, r18
     72c:	33 27       	eor	r19, r19
     72e:	26 1b       	sub	r18, r22
     730:	37 0b       	sbc	r19, r23
     732:	b9 01       	movw	r22, r18
     734:	33 0f       	add	r19, r19
     736:	88 0b       	sbc	r24, r24
     738:	99 0b       	sbc	r25, r25
     73a:	50 d4       	rcall	.+2208   	; 0xfdc <__floatsisf>
     73c:	4b 01       	movw	r8, r22
     73e:	5c 01       	movw	r10, r24
	if (absolute_potential < 1)//set the middle lights as white both top side and bottom side.
     740:	20 e0       	ldi	r18, 0x00	; 0
     742:	30 e0       	ldi	r19, 0x00	; 0
     744:	40 e8       	ldi	r20, 0x80	; 128
     746:	5f e3       	ldi	r21, 0x3F	; 63
     748:	9a d3       	rcall	.+1844   	; 0xe7e <__cmpsf2>
     74a:	88 23       	and	r24, r24
     74c:	34 f4       	brge	.+12     	; 0x75a <potential_to_RGB_update_LEDs+0xa4>
	{
		tinyCCLRGB_setColor(2, MAX_BRIGHTNESS/3, MAX_BRIGHTNESS/3, MAX_BRIGHTNESS/3);
     74e:	20 e1       	ldi	r18, 0x10	; 16
     750:	40 e1       	ldi	r20, 0x10	; 16
     752:	60 e1       	ldi	r22, 0x10	; 16
     754:	82 e0       	ldi	r24, 0x02	; 2
     756:	a6 d0       	rcall	.+332    	; 0x8a4 <tinyCCLRGB_setColor>
     758:	2c c0       	rjmp	.+88     	; 0x7b2 <potential_to_RGB_update_LEDs+0xfc>
		//tinyCCLRGB_setColor(4, max_brightness/3, max_brightness/3, max_brightness/3);
	}
	else
	{
		uint8_t brightness_intensity = round((absolute_potential/25)*MAX_BRIGHTNESS);//brightness intensity for the LED that shows potential.
     75a:	20 e0       	ldi	r18, 0x00	; 0
     75c:	30 e0       	ldi	r19, 0x00	; 0
     75e:	48 ec       	ldi	r20, 0xC8	; 200
     760:	51 e4       	ldi	r21, 0x41	; 65
     762:	c5 01       	movw	r24, r10
     764:	b4 01       	movw	r22, r8
     766:	90 d3       	rcall	.+1824   	; 0xe88 <__divsf3>
     768:	20 e0       	ldi	r18, 0x00	; 0
     76a:	30 e0       	ldi	r19, 0x00	; 0
     76c:	40 e4       	ldi	r20, 0x40	; 64
     76e:	52 e4       	ldi	r21, 0x42	; 66
     770:	ea d4       	rcall	.+2516   	; 0x1146 <__mulsf3>
     772:	56 d5       	rcall	.+2732   	; 0x1220 <round>
     774:	02 d4       	rcall	.+2052   	; 0xf7a <__fixunssfsi>
     776:	c6 2f       	mov	r28, r22
		if (potential < 0)
     778:	20 e0       	ldi	r18, 0x00	; 0
     77a:	30 e0       	ldi	r19, 0x00	; 0
     77c:	a9 01       	movw	r20, r18
     77e:	c7 01       	movw	r24, r14
     780:	b6 01       	movw	r22, r12
     782:	7d d3       	rcall	.+1786   	; 0xe7e <__cmpsf2>
     784:	88 23       	and	r24, r24
     786:	5c f4       	brge	.+22     	; 0x79e <potential_to_RGB_update_LEDs+0xe8>
		{
			tinyCCLRGB_setColor(0, brightness_intensity, 0x0, 0x0);
     788:	20 e0       	ldi	r18, 0x00	; 0
     78a:	40 e0       	ldi	r20, 0x00	; 0
     78c:	6c 2f       	mov	r22, r28
     78e:	80 e0       	ldi	r24, 0x00	; 0
     790:	89 d0       	rcall	.+274    	; 0x8a4 <tinyCCLRGB_setColor>
			tinyCCLRGB_setColor(1, brightness_intensity, 0x0, 0x0);//sets lower LEDs red if potential is negative.
     792:	20 e0       	ldi	r18, 0x00	; 0
     794:	40 e0       	ldi	r20, 0x00	; 0
     796:	6c 2f       	mov	r22, r28
     798:	81 e0       	ldi	r24, 0x01	; 1
     79a:	84 d0       	rcall	.+264    	; 0x8a4 <tinyCCLRGB_setColor>
     79c:	0a c0       	rjmp	.+20     	; 0x7b2 <potential_to_RGB_update_LEDs+0xfc>
		} 
		else
		{
			tinyCCLRGB_setColor(3, 0x0, brightness_intensity, 0x0);//sets upper LEDs green if potential is positive.
     79e:	20 e0       	ldi	r18, 0x00	; 0
     7a0:	4c 2f       	mov	r20, r28
     7a2:	60 e0       	ldi	r22, 0x00	; 0
     7a4:	83 e0       	ldi	r24, 0x03	; 3
     7a6:	7e d0       	rcall	.+252    	; 0x8a4 <tinyCCLRGB_setColor>
			tinyCCLRGB_setColor(4, 0x0, brightness_intensity, 0x0);
     7a8:	20 e0       	ldi	r18, 0x00	; 0
     7aa:	4c 2f       	mov	r20, r28
     7ac:	60 e0       	ldi	r22, 0x00	; 0
     7ae:	84 e0       	ldi	r24, 0x04	; 4
     7b0:	79 d0       	rcall	.+242    	; 0x8a4 <tinyCCLRGB_setColor>
	}
	else
	{
		potential_to_RGB_set_color(potential);
	}
	tinyCCLRGB_uploadColorsToLeds();
     7b2:	85 d0       	rcall	.+266    	; 0x8be <tinyCCLRGB_uploadColorsToLeds>
}
     7b4:	cf 91       	pop	r28
     7b6:	1f 91       	pop	r17
     7b8:	0f 91       	pop	r16
     7ba:	ff 90       	pop	r15
     7bc:	ef 90       	pop	r14
     7be:	df 90       	pop	r13
     7c0:	cf 90       	pop	r12
     7c2:	bf 90       	pop	r11
     7c4:	af 90       	pop	r10
     7c6:	9f 90       	pop	r9
     7c8:	8f 90       	pop	r8
     7ca:	08 95       	ret

000007cc <tinyButton_update>:
/*
If the button has been let go, we change button_press to true. This only lasts one cycle, before it is set to false again.
If the button is held down for longer than PULSEMODE_BUTTON_PRESS_TIME, we toggle the pulse mode state.
*/
void tinyButton_update(void)
{
     7cc:	0f 93       	push	r16
     7ce:	1f 93       	push	r17
     7d0:	cf 93       	push	r28
     7d2:	df 93       	push	r29
	button_press = false;
     7d4:	10 92 2f 3e 	sts	0x3E2F, r1	; 0x803e2f <button_press>
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTC_get_pin_level(const uint8_t pin)
{
	return VPORTC.IN & (1 << pin);
     7d8:	8a b1       	in	r24, 0x0a	; 10
	_Bool button_is_pushed_down = !BUTTON_PIN_get_level(); // The digital port will be read as low if the button is pushed down.
     7da:	d1 e0       	ldi	r29, 0x01	; 1
     7dc:	c8 2f       	mov	r28, r24
     7de:	c4 70       	andi	r28, 0x04	; 4
     7e0:	82 fd       	sbrc	r24, 2
     7e2:	d0 e0       	ldi	r29, 0x00	; 0

	if (button_is_pushed_down && !button_was_pushed_down)
     7e4:	c1 11       	cpse	r28, r1
     7e6:	30 c0       	rjmp	.+96     	; 0x848 <tinyButton_update+0x7c>
     7e8:	80 91 30 3e 	lds	r24, 0x3E30	; 0x803e30 <button_was_pushed_down>
     7ec:	81 11       	cpse	r24, r1
     7ee:	0d c0       	rjmp	.+26     	; 0x80a <tinyButton_update+0x3e>
	{
		tinyButton_start_time = tinyTime_now();
     7f0:	2d df       	rcall	.-422    	; 0x64c <tinyTime_now>
     7f2:	60 93 2b 3e 	sts	0x3E2B, r22	; 0x803e2b <tinyButton_start_time>
     7f6:	70 93 2c 3e 	sts	0x3E2C, r23	; 0x803e2c <tinyButton_start_time+0x1>
     7fa:	80 93 2d 3e 	sts	0x3E2D, r24	; 0x803e2d <tinyButton_start_time+0x2>
     7fe:	90 93 2e 3e 	sts	0x3E2E, r25	; 0x803e2e <tinyButton_start_time+0x3>
	}
	if (button_is_pushed_down && button_was_pushed_down)
     802:	80 91 30 3e 	lds	r24, 0x3E30	; 0x803e30 <button_was_pushed_down>
     806:	88 23       	and	r24, r24
     808:	41 f1       	breq	.+80     	; 0x85a <tinyButton_update+0x8e>
	{
		if ((tinyTime_now() - tinyButton_start_time) > PULSEMODE_BUTTON_PRESS_TIME)
     80a:	20 df       	rcall	.-448    	; 0x64c <tinyTime_now>
     80c:	00 91 2b 3e 	lds	r16, 0x3E2B	; 0x803e2b <tinyButton_start_time>
     810:	10 91 2c 3e 	lds	r17, 0x3E2C	; 0x803e2c <tinyButton_start_time+0x1>
     814:	20 91 2d 3e 	lds	r18, 0x3E2D	; 0x803e2d <tinyButton_start_time+0x2>
     818:	30 91 2e 3e 	lds	r19, 0x3E2E	; 0x803e2e <tinyButton_start_time+0x3>
     81c:	60 1b       	sub	r22, r16
     81e:	71 0b       	sbc	r23, r17
     820:	82 0b       	sbc	r24, r18
     822:	93 0b       	sbc	r25, r19
     824:	d9 d3       	rcall	.+1970   	; 0xfd8 <__floatunsisf>
     826:	20 e0       	ldi	r18, 0x00	; 0
     828:	30 e0       	ldi	r19, 0x00	; 0
     82a:	40 ea       	ldi	r20, 0xA0	; 160
     82c:	51 e4       	ldi	r21, 0x41	; 65
     82e:	86 d4       	rcall	.+2316   	; 0x113c <__gesf2>
     830:	18 16       	cp	r1, r24
     832:	54 f4       	brge	.+20     	; 0x848 <tinyButton_update+0x7c>
		{
			tinyPulse_toggle_pulse_mode();
     834:	bb de       	rcall	.-650    	; 0x5ac <tinyPulse_toggle_pulse_mode>
			tinyButton_start_time = tinyTime_now();
     836:	0a df       	rcall	.-492    	; 0x64c <tinyTime_now>
     838:	60 93 2b 3e 	sts	0x3E2B, r22	; 0x803e2b <tinyButton_start_time>
     83c:	70 93 2c 3e 	sts	0x3E2C, r23	; 0x803e2c <tinyButton_start_time+0x1>
     840:	80 93 2d 3e 	sts	0x3E2D, r24	; 0x803e2d <tinyButton_start_time+0x2>
     844:	90 93 2e 3e 	sts	0x3E2E, r25	; 0x803e2e <tinyButton_start_time+0x3>
		}
	}
	if (!button_is_pushed_down && button_was_pushed_down)
     848:	cc 23       	and	r28, r28
     84a:	39 f0       	breq	.+14     	; 0x85a <tinyButton_update+0x8e>
     84c:	80 91 30 3e 	lds	r24, 0x3E30	; 0x803e30 <button_was_pushed_down>
     850:	88 23       	and	r24, r24
     852:	19 f0       	breq	.+6      	; 0x85a <tinyButton_update+0x8e>
	{
		button_press = true;
     854:	81 e0       	ldi	r24, 0x01	; 1
     856:	80 93 2f 3e 	sts	0x3E2F, r24	; 0x803e2f <button_press>
	}
	button_was_pushed_down = button_is_pushed_down;
     85a:	d0 93 30 3e 	sts	0x3E30, r29	; 0x803e30 <button_was_pushed_down>
}
     85e:	df 91       	pop	r29
     860:	cf 91       	pop	r28
     862:	1f 91       	pop	r17
     864:	0f 91       	pop	r16
     866:	08 95       	ret

00000868 <tinyButton_update_potential>:

double tinyButton_update_potential(double potential){
	if(button_press){
     868:	20 91 2f 3e 	lds	r18, 0x3E2F	; 0x803e2f <button_press>
     86c:	22 23       	and	r18, r18
     86e:	29 f0       	breq	.+10     	; 0x87a <tinyButton_update_potential+0x12>
		potential += BUTTON_PRESS_REACTION;
     870:	20 e0       	ldi	r18, 0x00	; 0
     872:	30 e0       	ldi	r19, 0x00	; 0
     874:	40 ed       	ldi	r20, 0xD0	; 208
     876:	51 e4       	ldi	r21, 0x41	; 65
     878:	96 d2       	rcall	.+1324   	; 0xda6 <__addsf3>
	}
	return potential;
}
     87a:	08 95       	ret

0000087c <tinyCCLRGB_SPIWriteByte>:
Function used to send a byte over SPI, which in turn gets
translated to the bit-sequence required by the LEDs over the CCL.
*/
static void tinyCCLRGB_SPIWriteByte(uint8_t byte)
{
	SPI0.INTFLAGS = SPI0_INTFLAGS; // clear the write collision flag to allow writing
     87c:	90 91 23 08 	lds	r25, 0x0823	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
     880:	90 93 23 08 	sts	0x0823, r25	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
	TCA0.SINGLE.CNT = 0; // reset TCA counter register to ensure the first rising edge of the PWM is predictable
     884:	e0 e0       	ldi	r30, 0x00	; 0
     886:	fa e0       	ldi	r31, 0x0A	; 10
     888:	10 a2       	std	Z+32, r1	; 0x20
     88a:	11 a2       	std	Z+33, r1	; 0x21
	
	// start TCA
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 1 << TCA_SPLIT_ENABLE_bp;
     88c:	91 e0       	ldi	r25, 0x01	; 1
     88e:	90 83       	st	Z, r25
	SPI0_DATA = byte;
     890:	80 93 24 08 	sts	0x0824, r24	; 0x800824 <__TEXT_REGION_LENGTH__+0x700824>

	while((SPI0.INTFLAGS & SPI_RXCIE_bm) == 0){} // wait for transfer to complete
     894:	e0 e2       	ldi	r30, 0x20	; 32
     896:	f8 e0       	ldi	r31, 0x08	; 8
     898:	83 81       	ldd	r24, Z+3	; 0x03
     89a:	88 23       	and	r24, r24
     89c:	ec f7       	brge	.-6      	; 0x898 <tinyCCLRGB_SPIWriteByte+0x1c>
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 0 << TCA_SPLIT_ENABLE_bp; //Stop TCA
     89e:	10 92 00 0a 	sts	0x0A00, r1	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
     8a2:	08 95       	ret

000008a4 <tinyCCLRGB_setColor>:
/*
changes the values in the variables stored in the led-array.
*/
void tinyCCLRGB_setColor(uint8_t led, uint8_t red, uint8_t green, uint8_t blue) 
{
	tinyCCLRGB_colors[led].red = red;
     8a4:	90 e0       	ldi	r25, 0x00	; 0
     8a6:	fc 01       	movw	r30, r24
     8a8:	ee 0f       	add	r30, r30
     8aa:	ff 1f       	adc	r31, r31
     8ac:	8e 0f       	add	r24, r30
     8ae:	9f 1f       	adc	r25, r31
     8b0:	fc 01       	movw	r30, r24
     8b2:	ef 5c       	subi	r30, 0xCF	; 207
     8b4:	f1 4c       	sbci	r31, 0xC1	; 193
     8b6:	60 83       	st	Z, r22
	tinyCCLRGB_colors[led].green = green;
     8b8:	41 83       	std	Z+1, r20	; 0x01
	tinyCCLRGB_colors[led].blue = blue;
     8ba:	22 83       	std	Z+2, r18	; 0x02
     8bc:	08 95       	ret

000008be <tinyCCLRGB_uploadColorsToLeds>:
/*
function to write the current LED-array on to the LEDs and
effectively update the values stored in the LEDs to the values stored in the MCU.
*/
void tinyCCLRGB_uploadColorsToLeds(void)
{
     8be:	0f 93       	push	r16
     8c0:	1f 93       	push	r17
     8c2:	cf 93       	push	r28
     8c4:	df 93       	push	r29
     8c6:	c1 e3       	ldi	r28, 0x31	; 49
     8c8:	de e3       	ldi	r29, 0x3E	; 62
     8ca:	03 e4       	ldi	r16, 0x43	; 67
     8cc:	1e e3       	ldi	r17, 0x3E	; 62
	for (uint8_t i = 0; i < TINYCCLRGB_LEDCOUNT; i++)
	{
		//For some reason unknown to the writer the data-bus to the LEDs is serialized as GRB
		//which means the 24-bit data-bus will look like [Green[0:7], Red[0:7], Blue[0:7]]
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].green);
     8ce:	89 81       	ldd	r24, Y+1	; 0x01
     8d0:	d5 df       	rcall	.-86     	; 0x87c <tinyCCLRGB_SPIWriteByte>
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].red);
     8d2:	88 81       	ld	r24, Y
     8d4:	d3 df       	rcall	.-90     	; 0x87c <tinyCCLRGB_SPIWriteByte>
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].blue);
     8d6:	8a 81       	ldd	r24, Y+2	; 0x02
     8d8:	d1 df       	rcall	.-94     	; 0x87c <tinyCCLRGB_SPIWriteByte>
     8da:	23 96       	adiw	r28, 0x03	; 3
function to write the current LED-array on to the LEDs and
effectively update the values stored in the LEDs to the values stored in the MCU.
*/
void tinyCCLRGB_uploadColorsToLeds(void)
{
	for (uint8_t i = 0; i < TINYCCLRGB_LEDCOUNT; i++)
     8dc:	c0 17       	cp	r28, r16
     8de:	d1 07       	cpc	r29, r17
     8e0:	b1 f7       	brne	.-20     	; 0x8ce <tinyCCLRGB_uploadColorsToLeds+0x10>
		//which means the 24-bit data-bus will look like [Green[0:7], Red[0:7], Blue[0:7]]
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].green);
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].red);
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].blue);
	}
}
     8e2:	df 91       	pop	r29
     8e4:	cf 91       	pop	r28
     8e6:	1f 91       	pop	r17
     8e8:	0f 91       	pop	r16
     8ea:	08 95       	ret

000008ec <tinyAxon_remove_pulse>:
/*
solution to remove future firing if a inhibitory signal is received
shortly after a excitatory signal.
*/
bool tinyAxon_remove_pulse(void)
{
     8ec:	cf 92       	push	r12
     8ee:	df 92       	push	r13
     8f0:	ef 92       	push	r14
     8f2:	ff 92       	push	r15
	// We want to remove the pulse last added to the queue
	// We also want to return a bool indicating whether or not a pulse actually was removed
	uint32_t now = tinyTime_now();
     8f4:	ab de       	rcall	.-682    	; 0x64c <tinyTime_now>
     8f6:	6b 01       	movw	r12, r22
     8f8:	7c 01       	movw	r14, r24
	uint32_t pulse_time = dequeue_top(&pulse_queue);
     8fa:	84 e4       	ldi	r24, 0x44	; 68
     8fc:	9e e3       	ldi	r25, 0x3E	; 62
     8fe:	71 dd       	rcall	.-1310   	; 0x3e2 <dequeue_top>
	if(pulse_time == 0){ // Here, 0 is regarded as an error
     900:	61 15       	cp	r22, r1
     902:	71 05       	cpc	r23, r1
     904:	81 05       	cpc	r24, r1
     906:	91 05       	cpc	r25, r1
     908:	c1 f0       	breq	.+48     	; 0x93a <tinyAxon_remove_pulse+0x4e>
		return false;
	}
	
	// Now we want to check if the pulse is too far away to be affected by the low potential, or close enough that we decide to remove it
	// (When we say that the pulse is too far away, it refers to the biological process of how the potential spreads from Dendrites to axon)
	else if((now + UNDO_PERIOD) < pulse_time){
     90a:	2c e3       	ldi	r18, 0x3C	; 60
     90c:	c2 0e       	add	r12, r18
     90e:	d1 1c       	adc	r13, r1
     910:	e1 1c       	adc	r14, r1
     912:	f1 1c       	adc	r15, r1
     914:	c6 16       	cp	r12, r22
     916:	d7 06       	cpc	r13, r23
     918:	e8 06       	cpc	r14, r24
     91a:	f9 06       	cpc	r15, r25
     91c:	38 f4       	brcc	.+14     	; 0x92c <tinyAxon_remove_pulse+0x40>
		// We decided to remove the pulse
		pulses_in_queue--;
     91e:	80 91 46 3e 	lds	r24, 0x3E46	; 0x803e46 <pulses_in_queue>
     922:	81 50       	subi	r24, 0x01	; 1
     924:	80 93 46 3e 	sts	0x3E46, r24	; 0x803e46 <pulses_in_queue>
		return true;
     928:	81 e0       	ldi	r24, 0x01	; 1
     92a:	08 c0       	rjmp	.+16     	; 0x93c <tinyAxon_remove_pulse+0x50>
	}
	// Here we have found that there is a pulse queued, but it is old enough to let pass anyway, so now we need to put it back into the queue
	else{
		enqueue(&pulse_queue, pulse_time);
     92c:	ab 01       	movw	r20, r22
     92e:	bc 01       	movw	r22, r24
     930:	84 e4       	ldi	r24, 0x44	; 68
     932:	9e e3       	ldi	r25, 0x3E	; 62
     934:	fa dc       	rcall	.-1548   	; 0x32a <enqueue>
		return false;
     936:	80 e0       	ldi	r24, 0x00	; 0
     938:	01 c0       	rjmp	.+2      	; 0x93c <tinyAxon_remove_pulse+0x50>
	// We also want to return a bool indicating whether or not a pulse actually was removed
	uint32_t now = tinyTime_now();
	uint32_t pulse_time = dequeue_top(&pulse_queue);
	if(pulse_time == 0){ // Here, 0 is regarded as an error
		//There was no pulse to remove
		return false;
     93a:	80 e0       	ldi	r24, 0x00	; 0
	// Here we have found that there is a pulse queued, but it is old enough to let pass anyway, so now we need to put it back into the queue
	else{
		enqueue(&pulse_queue, pulse_time);
		return false;
	}
}
     93c:	ff 90       	pop	r15
     93e:	ef 90       	pop	r14
     940:	df 90       	pop	r13
     942:	cf 90       	pop	r12
     944:	08 95       	ret

00000946 <tinyAxon_update_potential>:
/*
Decides whether or not the axon should fire
If the axon does fire, the potential is reduced
*/
double tinyAxon_update_potential(double potential)
{
     946:	4f 92       	push	r4
     948:	5f 92       	push	r5
     94a:	6f 92       	push	r6
     94c:	7f 92       	push	r7
     94e:	8f 92       	push	r8
     950:	9f 92       	push	r9
     952:	af 92       	push	r10
     954:	bf 92       	push	r11
     956:	cf 92       	push	r12
     958:	df 92       	push	r13
     95a:	ef 92       	push	r14
     95c:	ff 92       	push	r15
     95e:	cf 93       	push	r28
     960:	df 93       	push	r29
     962:	6b 01       	movw	r12, r22
     964:	7c 01       	movw	r14, r24
	int pulse_nr = 0;
	uint32_t now = tinyTime_now();
     966:	72 de       	rcall	.-796    	; 0x64c <tinyTime_now>
     968:	2b 01       	movw	r4, r22
     96a:	3c 01       	movw	r6, r24
	
	//While the neuron has enough potential to fire, we want to fire more
	while (potential > THRESHOLD_POTENTIAL)
     96c:	20 e0       	ldi	r18, 0x00	; 0
     96e:	30 e0       	ldi	r19, 0x00	; 0
     970:	48 ec       	ldi	r20, 0xC8	; 200
     972:	51 e4       	ldi	r21, 0x41	; 65
     974:	c7 01       	movw	r24, r14
     976:	b6 01       	movw	r22, r12
     978:	e1 d3       	rcall	.+1986   	; 0x113c <__gesf2>
     97a:	18 16       	cp	r1, r24
     97c:	5c f5       	brge	.+86     	; 0x9d4 <tinyAxon_update_potential+0x8e>
     97e:	c0 e0       	ldi	r28, 0x00	; 0
     980:	d0 e0       	ldi	r29, 0x00	; 0
/*
Adds an element to the queue
*/
static void tinyAxon_enqueue_pulse(uint32_t new_pulse)
{
	enqueue(&pulse_queue, new_pulse);
     982:	53 01       	movw	r10, r6
     984:	42 01       	movw	r8, r4
     986:	84 e6       	ldi	r24, 0x64	; 100
     988:	88 0e       	add	r8, r24
     98a:	91 1c       	adc	r9, r1
     98c:	a1 1c       	adc	r10, r1
     98e:	b1 1c       	adc	r11, r1
     990:	ae 01       	movw	r20, r28
     992:	0d 2e       	mov	r0, r29
     994:	00 0c       	add	r0, r0
     996:	66 0b       	sbc	r22, r22
     998:	77 0b       	sbc	r23, r23
     99a:	48 0d       	add	r20, r8
     99c:	59 1d       	adc	r21, r9
     99e:	6a 1d       	adc	r22, r10
     9a0:	7b 1d       	adc	r23, r11
     9a2:	84 e4       	ldi	r24, 0x44	; 68
     9a4:	9e e3       	ldi	r25, 0x3E	; 62
     9a6:	c1 dc       	rcall	.-1662   	; 0x32a <enqueue>
	pulses_in_queue++;
     9a8:	80 91 46 3e 	lds	r24, 0x3E46	; 0x803e46 <pulses_in_queue>
     9ac:	8f 5f       	subi	r24, 0xFF	; 255
     9ae:	80 93 46 3e 	sts	0x3E46, r24	; 0x803e46 <pulses_in_queue>
	while (potential > THRESHOLD_POTENTIAL)
	{
		tinyAxon_enqueue_pulse(now + TRAVLE_DELAY + FIRE_DELAY*pulse_nr);
		pulse_nr++;
		
		potential += POSTFIRE_POTENTIAL_REACTION; // This is usually defined as a negative value, don't be confused by the +=
     9b2:	20 e0       	ldi	r18, 0x00	; 0
     9b4:	30 e0       	ldi	r19, 0x00	; 0
     9b6:	40 ef       	ldi	r20, 0xF0	; 240
     9b8:	51 e4       	ldi	r21, 0x41	; 65
     9ba:	c7 01       	movw	r24, r14
     9bc:	b6 01       	movw	r22, r12
     9be:	f2 d1       	rcall	.+996    	; 0xda4 <__subsf3>
     9c0:	6b 01       	movw	r12, r22
     9c2:	7c 01       	movw	r14, r24
     9c4:	e2 96       	adiw	r28, 0x32	; 50
{
	int pulse_nr = 0;
	uint32_t now = tinyTime_now();
	
	//While the neuron has enough potential to fire, we want to fire more
	while (potential > THRESHOLD_POTENTIAL)
     9c6:	20 e0       	ldi	r18, 0x00	; 0
     9c8:	30 e0       	ldi	r19, 0x00	; 0
     9ca:	48 ec       	ldi	r20, 0xC8	; 200
     9cc:	51 e4       	ldi	r21, 0x41	; 65
     9ce:	b6 d3       	rcall	.+1900   	; 0x113c <__gesf2>
     9d0:	18 16       	cp	r1, r24
     9d2:	f4 f2       	brlt	.-68     	; 0x990 <tinyAxon_update_potential+0x4a>
		
		potential += POSTFIRE_POTENTIAL_REACTION; // This is usually defined as a negative value, don't be confused by the +=
	}
	
	// If the neuron has a very low potential, we want to remove a pulse from the queue (if there is one)
	if(potential < -THRESHOLD_POTENTIAL && pulses_in_queue > 0) // Perhaps this should be a separate variable? For now, we will just simply use -THRESHOLD_POTENTIAL
     9d4:	20 e0       	ldi	r18, 0x00	; 0
     9d6:	30 e0       	ldi	r19, 0x00	; 0
     9d8:	48 ec       	ldi	r20, 0xC8	; 200
     9da:	51 ec       	ldi	r21, 0xC1	; 193
     9dc:	c7 01       	movw	r24, r14
     9de:	b6 01       	movw	r22, r12
     9e0:	4e d2       	rcall	.+1180   	; 0xe7e <__cmpsf2>
     9e2:	88 23       	and	r24, r24
     9e4:	84 f4       	brge	.+32     	; 0xa06 <tinyAxon_update_potential+0xc0>
     9e6:	80 91 46 3e 	lds	r24, 0x3E46	; 0x803e46 <pulses_in_queue>
     9ea:	88 23       	and	r24, r24
     9ec:	21 f1       	breq	.+72     	; 0xa36 <tinyAxon_update_potential+0xf0>
	{
		// The neurons potential is low enough to attempt to remove a queued fire (Fire less)
		if(tinyAxon_remove_pulse())
     9ee:	7e df       	rcall	.-260    	; 0x8ec <tinyAxon_remove_pulse>
     9f0:	88 23       	and	r24, r24
     9f2:	49 f0       	breq	.+18     	; 0xa06 <tinyAxon_update_potential+0xc0>
		{
			// The potential has evened out a bit
			potential += THRESHOLD_POTENTIAL;
     9f4:	20 e0       	ldi	r18, 0x00	; 0
     9f6:	30 e0       	ldi	r19, 0x00	; 0
     9f8:	48 ec       	ldi	r20, 0xC8	; 200
     9fa:	51 e4       	ldi	r21, 0x41	; 65
     9fc:	c7 01       	movw	r24, r14
     9fe:	b6 01       	movw	r22, r12
     a00:	d2 d1       	rcall	.+932    	; 0xda6 <__addsf3>
     a02:	6b 01       	movw	r12, r22
     a04:	7c 01       	movw	r14, r24
		}
	}
	
	// If there are pulses in the queue, and the pulse has been scheduled to fire
	if ((pulses_in_queue > 0) && (read_end(&pulse_queue) <= now))
     a06:	80 91 46 3e 	lds	r24, 0x3E46	; 0x803e46 <pulses_in_queue>
     a0a:	88 23       	and	r24, r24
     a0c:	a1 f0       	breq	.+40     	; 0xa36 <tinyAxon_update_potential+0xf0>
     a0e:	84 e4       	ldi	r24, 0x44	; 68
     a10:	9e e3       	ldi	r25, 0x3E	; 62
     a12:	11 dd       	rcall	.-1502   	; 0x436 <read_end>
     a14:	46 16       	cp	r4, r22
     a16:	57 06       	cpc	r5, r23
     a18:	68 06       	cpc	r6, r24
     a1a:	79 06       	cpc	r7, r25
     a1c:	60 f0       	brcs	.+24     	; 0xa36 <tinyAxon_update_potential+0xf0>
Function to set firing.
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
     a1e:	81 e0       	ldi	r24, 0x01	; 1
     a20:	80 93 47 3e 	sts	0x3E47, r24	; 0x803e47 <tinyAxon_should_fire>
	pulses_in_queue--;
     a24:	80 91 46 3e 	lds	r24, 0x3E46	; 0x803e46 <pulses_in_queue>
     a28:	81 50       	subi	r24, 0x01	; 1
     a2a:	80 93 46 3e 	sts	0x3E46, r24	; 0x803e46 <pulses_in_queue>
	dequeue(&pulse_queue);
     a2e:	84 e4       	ldi	r24, 0x44	; 68
     a30:	9e e3       	ldi	r25, 0x3E	; 62
     a32:	9b dc       	rcall	.-1738   	; 0x36a <dequeue>
	// If there are pulses in the queue, and the pulse has been scheduled to fire
	if ((pulses_in_queue > 0) && (read_end(&pulse_queue) <= now))
	{
		// We fire the axon
		tinyAxon_fire_pulse();
		set_LED_fire();
     a34:	2b de       	rcall	.-938    	; 0x68c <set_LED_fire>
The function should set the DAC to fire for two
update cycles once the pulse flag is set high.
*/
static void tinyAxon_update_pulse_transmitter(void)
{
	if (tinyAxon_should_fire)
     a36:	80 91 47 3e 	lds	r24, 0x3E47	; 0x803e47 <tinyAxon_should_fire>
     a3a:	88 23       	and	r24, r24
     a3c:	61 f0       	breq	.+24     	; 0xa56 <tinyAxon_update_potential+0x110>
	{
		tinyAxon_should_fire = false;
     a3e:	10 92 47 3e 	sts	0x3E47, r1	; 0x803e47 <tinyAxon_should_fire>
		tinyAxon_has_fired = true;
     a42:	81 e0       	ldi	r24, 0x01	; 1
     a44:	80 93 48 3e 	sts	0x3E48, r24	; 0x803e48 <tinyAxon_has_fired>
*/
static void tinyAxon_start_sending_pulse()
{
	if (NEURONTYPE == EXCITATORY_NEURON)
	{
		DAC_set_output(EXCITATORY_NEURON_OUTPUT);
     a48:	87 ed       	ldi	r24, 0xD7	; 215
     a4a:	90 e0       	ldi	r25, 0x00	; 0
     a4c:	cc db       	rcall	.-2152   	; 0x1e6 <DAC_set_output>
		axonOutputValue=EXCITATORY_NEURON_OUTPUT;
     a4e:	87 ed       	ldi	r24, 0xD7	; 215
     a50:	80 93 43 3e 	sts	0x3E43, r24	; 0x803e43 <axonOutputValue>
     a54:	0c c0       	rjmp	.+24     	; 0xa6e <tinyAxon_update_potential+0x128>
		tinyAxon_should_fire = false;
		tinyAxon_has_fired = true;
		
		tinyAxon_start_sending_pulse();
	}
	else if (tinyAxon_has_fired)
     a56:	80 91 48 3e 	lds	r24, 0x3E48	; 0x803e48 <tinyAxon_has_fired>
     a5a:	88 23       	and	r24, r24
     a5c:	19 f0       	breq	.+6      	; 0xa64 <tinyAxon_update_potential+0x11e>
	{
		tinyAxon_has_fired = false;
     a5e:	10 92 48 3e 	sts	0x3E48, r1	; 0x803e48 <tinyAxon_has_fired>
     a62:	05 c0       	rjmp	.+10     	; 0xa6e <tinyAxon_update_potential+0x128>
}

static void tinyAxon_stop_sending_pulse()
{
	
	DAC_set_output(NO_SIGNAL_OUTPUT);
     a64:	80 e0       	ldi	r24, 0x00	; 0
     a66:	90 e0       	ldi	r25, 0x00	; 0
     a68:	be db       	rcall	.-2180   	; 0x1e6 <DAC_set_output>
	axonOutputValue=NO_SIGNAL_OUTPUT;
     a6a:	10 92 43 3e 	sts	0x3E43, r1	; 0x803e43 <axonOutputValue>
	}
	
	// Here we set the actual output of the DAC (Digital to Analog Converter)
	tinyAxon_update_pulse_transmitter();
	
	tinyDebugger_send_int("Axon output", axonOutputValue);
     a6e:	60 91 43 3e 	lds	r22, 0x3E43	; 0x803e43 <axonOutputValue>
     a72:	70 e0       	ldi	r23, 0x00	; 0
     a74:	8d e9       	ldi	r24, 0x9D	; 157
     a76:	9f e9       	ldi	r25, 0x9F	; 159
     a78:	51 dd       	rcall	.-1374   	; 0x51c <tinyDebugger_send_int>
	tinyDebugger_send_int("Pulses in queue", pulses_in_queue);
     a7a:	60 91 46 3e 	lds	r22, 0x3E46	; 0x803e46 <pulses_in_queue>
     a7e:	70 e0       	ldi	r23, 0x00	; 0
     a80:	89 ea       	ldi	r24, 0xA9	; 169
     a82:	9f e9       	ldi	r25, 0x9F	; 159
     a84:	4b dd       	rcall	.-1386   	; 0x51c <tinyDebugger_send_int>
	tinyDebugger_send_int("Next pulse", read_end(&pulse_queue));
     a86:	84 e4       	ldi	r24, 0x44	; 68
     a88:	9e e3       	ldi	r25, 0x3E	; 62
     a8a:	d5 dc       	rcall	.-1622   	; 0x436 <read_end>
     a8c:	ab 01       	movw	r20, r22
     a8e:	bc 01       	movw	r22, r24
     a90:	89 eb       	ldi	r24, 0xB9	; 185
     a92:	9f e9       	ldi	r25, 0x9F	; 159
     a94:	43 dd       	rcall	.-1402   	; 0x51c <tinyDebugger_send_int>
	
	return potential;
}
     a96:	c7 01       	movw	r24, r14
     a98:	b6 01       	movw	r22, r12
     a9a:	df 91       	pop	r29
     a9c:	cf 91       	pop	r28
     a9e:	ff 90       	pop	r15
     aa0:	ef 90       	pop	r14
     aa2:	df 90       	pop	r13
     aa4:	cf 90       	pop	r12
     aa6:	bf 90       	pop	r11
     aa8:	af 90       	pop	r10
     aaa:	9f 90       	pop	r9
     aac:	8f 90       	pop	r8
     aae:	7f 90       	pop	r7
     ab0:	6f 90       	pop	r6
     ab2:	5f 90       	pop	r5
     ab4:	4f 90       	pop	r4
     ab6:	08 95       	ret

00000ab8 <tinyDendrite_update_signals>:
/*
This function converts the 8 bit value from the ADC into one of the signal types defined in DendriteSignal
We also update the charging state
*/
void tinyDendrite_update_signals(void)
{
     ab8:	2f 92       	push	r2
     aba:	3f 92       	push	r3
     abc:	4f 92       	push	r4
     abe:	5f 92       	push	r5
     ac0:	6f 92       	push	r6
     ac2:	7f 92       	push	r7
     ac4:	8f 92       	push	r8
     ac6:	9f 92       	push	r9
     ac8:	af 92       	push	r10
     aca:	bf 92       	push	r11
     acc:	cf 92       	push	r12
     ace:	df 92       	push	r13
     ad0:	ef 92       	push	r14
     ad2:	ff 92       	push	r15
     ad4:	0f 93       	push	r16
     ad6:	1f 93       	push	r17
     ad8:	cf 93       	push	r28
     ada:	df 93       	push	r29
     adc:	06 e1       	ldi	r16, 0x16	; 22
     ade:	1e e3       	ldi	r17, 0x3E	; 62
     ae0:	0f 2e       	mov	r0, r31
     ae2:	f3 e5       	ldi	r31, 0x53	; 83
     ae4:	cf 2e       	mov	r12, r31
     ae6:	fe e3       	ldi	r31, 0x3E	; 62
     ae8:	df 2e       	mov	r13, r31
     aea:	f0 2d       	mov	r31, r0
     aec:	0f 2e       	mov	r0, r31
     aee:	fd e5       	ldi	r31, 0x5D	; 93
     af0:	ef 2e       	mov	r14, r31
     af2:	fe e3       	ldi	r31, 0x3E	; 62
     af4:	ff 2e       	mov	r15, r31
     af6:	f0 2d       	mov	r31, r0
     af8:	e6 01       	movw	r28, r12
*/
static void tinyDendrite_read_signals(void)
{
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_values[i] = ADC_get_conversion(Dendrite_ports[i]);
     afa:	f8 01       	movw	r30, r16
     afc:	81 91       	ld	r24, Z+
     afe:	8f 01       	movw	r16, r30
     b00:	3d db       	rcall	.-2438   	; 0x17c <ADC_get_conversion>
     b02:	89 93       	st	Y+, r24
     b04:	99 93       	st	Y+, r25
/*
This function reads the voltage at the Dendrite inputs with the ADC
*/
static void tinyDendrite_read_signals(void)
{
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
     b06:	ce 15       	cp	r28, r14
     b08:	df 05       	cpc	r29, r15
     b0a:	b9 f7       	brne	.-18     	; 0xafa <tinyDendrite_update_signals+0x42>
	{
		tinyDendrite_values[i] = ADC_get_conversion(Dendrite_ports[i]);
	}
	tinyDebugger_send_int("Dendrite1", tinyDendrite_values[0]);
     b0c:	c3 e5       	ldi	r28, 0x53	; 83
     b0e:	de e3       	ldi	r29, 0x3E	; 62
     b10:	68 81       	ld	r22, Y
     b12:	79 81       	ldd	r23, Y+1	; 0x01
     b14:	84 ec       	ldi	r24, 0xC4	; 196
     b16:	9f e9       	ldi	r25, 0x9F	; 159
     b18:	01 dd       	rcall	.-1534   	; 0x51c <tinyDebugger_send_int>
	tinyDebugger_send_int("Dendrite2", tinyDendrite_values[1]);
     b1a:	6a 81       	ldd	r22, Y+2	; 0x02
     b1c:	7b 81       	ldd	r23, Y+3	; 0x03
     b1e:	8e ec       	ldi	r24, 0xCE	; 206
     b20:	9f e9       	ldi	r25, 0x9F	; 159
     b22:	fc dc       	rcall	.-1544   	; 0x51c <tinyDebugger_send_int>
	tinyDebugger_send_int("Dendrite3", tinyDendrite_values[2]);
     b24:	6c 81       	ldd	r22, Y+4	; 0x04
     b26:	7d 81       	ldd	r23, Y+5	; 0x05
     b28:	88 ed       	ldi	r24, 0xD8	; 216
     b2a:	9f e9       	ldi	r25, 0x9F	; 159
     b2c:	f7 dc       	rcall	.-1554   	; 0x51c <tinyDebugger_send_int>
	tinyDebugger_send_int("Dendrite4", tinyDendrite_values[3]);
     b2e:	6e 81       	ldd	r22, Y+6	; 0x06
     b30:	7f 81       	ldd	r23, Y+7	; 0x07
     b32:	82 ee       	ldi	r24, 0xE2	; 226
     b34:	9f e9       	ldi	r25, 0x9F	; 159
     b36:	f2 dc       	rcall	.-1564   	; 0x51c <tinyDebugger_send_int>
	tinyDebugger_send_int("Dendrite5", tinyDendrite_values[4]);
     b38:	68 85       	ldd	r22, Y+8	; 0x08
     b3a:	79 85       	ldd	r23, Y+9	; 0x09
     b3c:	8c ee       	ldi	r24, 0xEC	; 236
     b3e:	9f e9       	ldi	r25, 0x9F	; 159
     b40:	ed dc       	rcall	.-1574   	; 0x51c <tinyDebugger_send_int>
{
	
	//Read the analog voltage values on each of the Dendrites
	tinyDendrite_read_signals();
	
	tinyCharge_set_charging(false);
     b42:	80 e0       	ldi	r24, 0x00	; 0
     b44:	e0 dc       	rcall	.-1600   	; 0x506 <tinyCharge_set_charging>
     b46:	ce e4       	ldi	r28, 0x4E	; 78
     b48:	de e3       	ldi	r29, 0x3E	; 62
     b4a:	09 e4       	ldi	r16, 0x49	; 73
     b4c:	1e e3       	ldi	r17, 0x3E	; 62
     b4e:	0f 2e       	mov	r0, r31
     b50:	f3 e5       	ldi	r31, 0x53	; 83
     b52:	8f 2e       	mov	r8, r31
     b54:	fe e3       	ldi	r31, 0x3E	; 62
     b56:	9f 2e       	mov	r9, r31
     b58:	f0 2d       	mov	r31, r0
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     b5a:	66 24       	eor	r6, r6
     b5c:	63 94       	inc	r6
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     b5e:	68 94       	set
     b60:	22 24       	eor	r2, r2
     b62:	21 f8       	bld	r2, 1
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     b64:	68 94       	set
     b66:	33 24       	eor	r3, r3
     b68:	32 f8       	bld	r3, 2
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     b6a:	0f 2e       	mov	r0, r31
     b6c:	f6 e0       	ldi	r31, 0x06	; 6
     b6e:	4f 2e       	mov	r4, r31
     b70:	f0 2d       	mov	r31, r0
			tinyDendrite_current_signals[i] = CHARGING;
			tinyCharge_set_charging(true);
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     b72:	0f 2e       	mov	r0, r31
     b74:	f5 e0       	ldi	r31, 0x05	; 5
     b76:	7f 2e       	mov	r7, r31
     b78:	f0 2d       	mov	r31, r0
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = CHARGING;
     b7a:	0f 2e       	mov	r0, r31
     b7c:	f7 e0       	ldi	r31, 0x07	; 7
     b7e:	5f 2e       	mov	r5, r31
     b80:	f0 2d       	mov	r31, r0
     b82:	7e 01       	movw	r14, r28
     b84:	58 01       	movw	r10, r16
	
	tinyCharge_set_charging(false);
	
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
     b86:	88 81       	ld	r24, Y
     b88:	f8 01       	movw	r30, r16
     b8a:	80 83       	st	Z, r24
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
     b8c:	f6 01       	movw	r30, r12
     b8e:	81 91       	ld	r24, Z+
     b90:	91 91       	ld	r25, Z+
     b92:	6f 01       	movw	r12, r30
     b94:	89 3e       	cpi	r24, 0xE9	; 233
     b96:	91 05       	cpc	r25, r1
     b98:	20 f0       	brcs	.+8      	; 0xba2 <tinyDendrite_update_signals+0xea>
		{
			tinyDendrite_current_signals[i] = CHARGING;
     b9a:	58 82       	st	Y, r5
			tinyCharge_set_charging(true);
     b9c:	86 2d       	mov	r24, r6
     b9e:	b3 dc       	rcall	.-1690   	; 0x506 <tinyCharge_set_charging>
     ba0:	1f c0       	rjmp	.+62     	; 0xbe0 <tinyDendrite_update_signals+0x128>
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
     ba2:	88 3c       	cpi	r24, 0xC8	; 200
     ba4:	91 05       	cpc	r25, r1
     ba6:	10 f0       	brcs	.+4      	; 0xbac <tinyDendrite_update_signals+0xf4>
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     ba8:	78 82       	st	Y, r7
     baa:	1a c0       	rjmp	.+52     	; 0xbe0 <tinyDendrite_update_signals+0x128>
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
     bac:	87 3a       	cpi	r24, 0xA7	; 167
     bae:	91 05       	cpc	r25, r1
     bb0:	10 f0       	brcs	.+4      	; 0xbb6 <tinyDendrite_update_signals+0xfe>
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     bb2:	48 82       	st	Y, r4
     bb4:	15 c0       	rjmp	.+42     	; 0xbe0 <tinyDendrite_update_signals+0x128>
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
     bb6:	85 38       	cpi	r24, 0x85	; 133
     bb8:	91 05       	cpc	r25, r1
     bba:	10 f0       	brcs	.+4      	; 0xbc0 <tinyDendrite_update_signals+0x108>
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     bbc:	38 82       	st	Y, r3
     bbe:	10 c0       	rjmp	.+32     	; 0xbe0 <tinyDendrite_update_signals+0x128>
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
     bc0:	84 36       	cpi	r24, 0x64	; 100
     bc2:	91 05       	cpc	r25, r1
     bc4:	10 f0       	brcs	.+4      	; 0xbca <tinyDendrite_update_signals+0x112>
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     bc6:	28 82       	st	Y, r2
     bc8:	0b c0       	rjmp	.+22     	; 0xbe0 <tinyDendrite_update_signals+0x128>
		}
		else if (tinyDendrite_values[i] > HIGH_INHIB_THRESHOLD)
     bca:	83 34       	cpi	r24, 0x43	; 67
     bcc:	91 05       	cpc	r25, r1
     bce:	18 f0       	brcs	.+6      	; 0xbd6 <tinyDendrite_update_signals+0x11e>
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
     bd0:	83 e0       	ldi	r24, 0x03	; 3
     bd2:	88 83       	st	Y, r24
     bd4:	05 c0       	rjmp	.+10     	; 0xbe0 <tinyDendrite_update_signals+0x128>
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
     bd6:	82 97       	sbiw	r24, 0x22	; 34
     bd8:	10 f0       	brcs	.+4      	; 0xbde <tinyDendrite_update_signals+0x126>
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     bda:	68 82       	st	Y, r6
     bdc:	01 c0       	rjmp	.+2      	; 0xbe0 <tinyDendrite_update_signals+0x128>
		}
		else
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     bde:	18 82       	st	Y, r1
     be0:	0f 5f       	subi	r16, 0xFF	; 255
     be2:	1f 4f       	sbci	r17, 0xFF	; 255
		}
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
     be4:	f7 01       	movw	r30, r14
     be6:	90 81       	ld	r25, Z
     be8:	f5 01       	movw	r30, r10
     bea:	80 81       	ld	r24, Z
     bec:	98 13       	cpse	r25, r24
     bee:	02 c0       	rjmp	.+4      	; 0xbf4 <tinyDendrite_update_signals+0x13c>
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     bf0:	f7 01       	movw	r30, r14
     bf2:	10 82       	st	Z, r1
     bf4:	21 96       	adiw	r28, 0x01	; 1
	//Read the analog voltage values on each of the Dendrites
	tinyDendrite_read_signals();
	
	tinyCharge_set_charging(false);
	
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
     bf6:	c8 15       	cp	r28, r8
     bf8:	d9 05       	cpc	r29, r9
     bfa:	19 f6       	brne	.-122    	; 0xb82 <tinyDendrite_update_signals+0xca>
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
		}
	}
}
     bfc:	df 91       	pop	r29
     bfe:	cf 91       	pop	r28
     c00:	1f 91       	pop	r17
     c02:	0f 91       	pop	r16
     c04:	ff 90       	pop	r15
     c06:	ef 90       	pop	r14
     c08:	df 90       	pop	r13
     c0a:	cf 90       	pop	r12
     c0c:	bf 90       	pop	r11
     c0e:	af 90       	pop	r10
     c10:	9f 90       	pop	r9
     c12:	8f 90       	pop	r8
     c14:	7f 90       	pop	r7
     c16:	6f 90       	pop	r6
     c18:	5f 90       	pop	r5
     c1a:	4f 90       	pop	r4
     c1c:	3f 90       	pop	r3
     c1e:	2f 90       	pop	r2
     c20:	08 95       	ret

00000c22 <tinyDendrite_get_potential>:
outside. It uses the previously declared functions to return the potential.
*/
int16_t tinyDendrite_get_potential()
{
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
     c22:	4a df       	rcall	.-364    	; 0xab8 <tinyDendrite_update_signals>
     c24:	ee e4       	ldi	r30, 0x4E	; 78
     c26:	fe e3       	ldi	r31, 0x3E	; 62
     c28:	43 e5       	ldi	r20, 0x53	; 83
     c2a:	5e e3       	ldi	r21, 0x3E	; 62
	
	int16_t return_potential_val = 0;
     c2c:	20 e0       	ldi	r18, 0x00	; 0
     c2e:	30 e0       	ldi	r19, 0x00	; 0
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		switch(tinyDendrite_current_signals[i])
     c30:	91 91       	ld	r25, Z+
     c32:	93 30       	cpi	r25, 0x03	; 3
     c34:	a1 f0       	breq	.+40     	; 0xc5e <tinyDendrite_get_potential+0x3c>
     c36:	28 f4       	brcc	.+10     	; 0xc42 <tinyDendrite_get_potential+0x20>
     c38:	91 30       	cpi	r25, 0x01	; 1
     c3a:	b9 f0       	breq	.+46     	; 0xc6a <tinyDendrite_get_potential+0x48>
     c3c:	92 30       	cpi	r25, 0x02	; 2
     c3e:	91 f0       	breq	.+36     	; 0xc64 <tinyDendrite_get_potential+0x42>
     c40:	16 c0       	rjmp	.+44     	; 0xc6e <tinyDendrite_get_potential+0x4c>
     c42:	95 30       	cpi	r25, 0x05	; 5
     c44:	31 f0       	breq	.+12     	; 0xc52 <tinyDendrite_get_potential+0x30>
     c46:	40 f0       	brcs	.+16     	; 0xc58 <tinyDendrite_get_potential+0x36>
     c48:	96 30       	cpi	r25, 0x06	; 6
     c4a:	89 f4       	brne	.+34     	; 0xc6e <tinyDendrite_get_potential+0x4c>
		{
			case NO_SIGNAL:
				return_potential_val += NO_SIGNAL_REACTION;
				break;
			case HIGH_EXCITE:
				return_potential_val += HIGH_EXCITE_REACTION;
     c4c:	2c 5c       	subi	r18, 0xCC	; 204
     c4e:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     c50:	0e c0       	rjmp	.+28     	; 0xc6e <tinyDendrite_get_potential+0x4c>
			case NORMAL_EXCITE:
				return_potential_val += NORMAL_EXCITE_REACTION;
     c52:	26 5e       	subi	r18, 0xE6	; 230
     c54:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     c56:	0b c0       	rjmp	.+22     	; 0xc6e <tinyDendrite_get_potential+0x4c>
			case LOW_EXCITE:
				return_potential_val += LOW_EXCITE_REACTION;
     c58:	2c 5e       	subi	r18, 0xEC	; 236
     c5a:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     c5c:	08 c0       	rjmp	.+16     	; 0xc6e <tinyDendrite_get_potential+0x4c>
			case HIGH_INHIB:
				return_potential_val += HIGH_INHIB_REACTION;
     c5e:	22 53       	subi	r18, 0x32	; 50
     c60:	31 09       	sbc	r19, r1
				break;
     c62:	05 c0       	rjmp	.+10     	; 0xc6e <tinyDendrite_get_potential+0x4c>
			case NORMAL_INHIB:
				return_potential_val += NORMAL_INHIB_REACTION;
     c64:	2a 51       	subi	r18, 0x1A	; 26
     c66:	31 09       	sbc	r19, r1
				break;
     c68:	02 c0       	rjmp	.+4      	; 0xc6e <tinyDendrite_get_potential+0x4c>
			case LOW_INHIB:
				return_potential_val += LOW_INHIB_REACTION;
     c6a:	24 51       	subi	r18, 0x14	; 20
     c6c:	31 09       	sbc	r19, r1
{
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
	
	int16_t return_potential_val = 0;
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
     c6e:	e4 17       	cp	r30, r20
     c70:	f5 07       	cpc	r31, r21
     c72:	f1 f6       	brne	.-68     	; 0xc30 <tinyDendrite_get_potential+0xe>
			default:
				break;
		}
	}
	return return_potential_val;
}
     c74:	c9 01       	movw	r24, r18
     c76:	08 95       	ret

00000c78 <tinyDendrite_update_potential>:

double tinyDendrite_update_potential(double potential){
     c78:	cf 92       	push	r12
     c7a:	df 92       	push	r13
     c7c:	ef 92       	push	r14
     c7e:	ff 92       	push	r15
     c80:	6b 01       	movw	r12, r22
     c82:	7c 01       	movw	r14, r24
	
	uint16_t potential_change = tinyDendrite_get_potential();
     c84:	ce df       	rcall	.-100    	; 0xc22 <tinyDendrite_get_potential>
	potential += potential_change;
	return potential;
     c86:	bc 01       	movw	r22, r24
     c88:	80 e0       	ldi	r24, 0x00	; 0
     c8a:	90 e0       	ldi	r25, 0x00	; 0
     c8c:	a5 d1       	rcall	.+842    	; 0xfd8 <__floatunsisf>
     c8e:	a7 01       	movw	r20, r14
     c90:	96 01       	movw	r18, r12
     c92:	89 d0       	rcall	.+274    	; 0xda6 <__addsf3>
     c94:	ff 90       	pop	r15
     c96:	ef 90       	pop	r14
     c98:	df 90       	pop	r13
     c9a:	cf 90       	pop	r12
     c9c:	08 95       	ret

00000c9e <__vector_6>:
This function is called every time the RTC (Real Time Clock) counter overflows.
With the current settings, it will be called every ms.
The RTC clock runs at 1kHz, and the number of cycles before overflow is set with RTC.PER = someHexValue (e.g. 0x20) in src/rtc.c
*/
ISR(RTC_CNT_vect)
{
     c9e:	1f 92       	push	r1
     ca0:	0f 92       	push	r0
     ca2:	0f b6       	in	r0, 0x3f	; 63
     ca4:	0f 92       	push	r0
     ca6:	11 24       	eor	r1, r1
     ca8:	2f 93       	push	r18
     caa:	3f 93       	push	r19
     cac:	4f 93       	push	r20
     cae:	5f 93       	push	r21
     cb0:	6f 93       	push	r22
     cb2:	7f 93       	push	r23
     cb4:	8f 93       	push	r24
     cb6:	9f 93       	push	r25
     cb8:	af 93       	push	r26
     cba:	bf 93       	push	r27
     cbc:	cf 93       	push	r28
     cbe:	ef 93       	push	r30
     cc0:	ff 93       	push	r31
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     cc2:	c1 e0       	ldi	r28, 0x01	; 1
     cc4:	c0 93 5d 3e 	sts	0x3E5D, r28	; 0x803e5d <tinyISR_interrupt_flag>
{
	// Set flag to let main loop run a new cycle
	tinyISR_setflag(true);
	
	// Timer counter incrementation
	tinyTime_counter_increment();
     cc8:	ad dc       	rcall	.-1702   	; 0x624 <tinyTime_counter_increment>

	/* Overflow interrupt flag has to be cleared manually */
	RTC.INTFLAGS = RTC_OVF_bm;
     cca:	c0 93 43 01 	sts	0x0143, r28	; 0x800143 <__TEXT_REGION_LENGTH__+0x700143>
}
     cce:	ff 91       	pop	r31
     cd0:	ef 91       	pop	r30
     cd2:	cf 91       	pop	r28
     cd4:	bf 91       	pop	r27
     cd6:	af 91       	pop	r26
     cd8:	9f 91       	pop	r25
     cda:	8f 91       	pop	r24
     cdc:	7f 91       	pop	r23
     cde:	6f 91       	pop	r22
     ce0:	5f 91       	pop	r21
     ce2:	4f 91       	pop	r20
     ce4:	3f 91       	pop	r19
     ce6:	2f 91       	pop	r18
     ce8:	0f 90       	pop	r0
     cea:	0f be       	out	0x3f, r0	; 63
     cec:	0f 90       	pop	r0
     cee:	1f 90       	pop	r1
     cf0:	18 95       	reti

00000cf2 <tinyISR_setflag>:
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     cf2:	80 93 5d 3e 	sts	0x3E5D, r24	; 0x803e5d <tinyISR_interrupt_flag>
     cf6:	08 95       	ret

00000cf8 <tinyISR_getflag>:
}

_Bool tinyISR_getflag(void)
{
	return tinyISR_interrupt_flag;
}
     cf8:	80 91 5d 3e 	lds	r24, 0x3E5D	; 0x803e5d <tinyISR_interrupt_flag>
     cfc:	08 95       	ret

00000cfe <tinyPotential_update>:
The function which will run in the main loop.
This function will run on interrupts by the RTC module.
*/
void tinyPotential_update()
{
	tinyDebugger_send_float("Potential", tinyPotential_potential);
     cfe:	40 91 5e 3e 	lds	r20, 0x3E5E	; 0x803e5e <tinyPotential_potential>
     d02:	50 91 5f 3e 	lds	r21, 0x3E5F	; 0x803e5f <tinyPotential_potential+0x1>
     d06:	60 91 60 3e 	lds	r22, 0x3E60	; 0x803e60 <tinyPotential_potential+0x2>
     d0a:	70 91 61 3e 	lds	r23, 0x3E61	; 0x803e61 <tinyPotential_potential+0x3>
     d0e:	86 ef       	ldi	r24, 0xF6	; 246
     d10:	9f e9       	ldi	r25, 0x9F	; 159
     d12:	14 dc       	rcall	.-2008   	; 0x53c <tinyDebugger_send_float>
	// but for simplification, we just assume that each cycle will take one ms. The consequences for a cycle taking longer
	// are negligible. 
	
	uint8_t time_since_last_update = 1;
	tinyPotential_potential *= (exp(-(time_since_last_update/TINYPOTENTIAL_TIME_CONST)));
	if(fabs(tinyPotential_potential)<0.01){
     d14:	80 91 5e 3e 	lds	r24, 0x3E5E	; 0x803e5e <tinyPotential_potential>
     d18:	90 91 5f 3e 	lds	r25, 0x3E5F	; 0x803e5f <tinyPotential_potential+0x1>
     d1c:	a0 91 60 3e 	lds	r26, 0x3E60	; 0x803e60 <tinyPotential_potential+0x2>
     d20:	b0 91 61 3e 	lds	r27, 0x3E61	; 0x803e61 <tinyPotential_potential+0x3>
     d24:	bc 01       	movw	r22, r24
     d26:	cd 01       	movw	r24, r26
     d28:	9f 77       	andi	r25, 0x7F	; 127
     d2a:	2a e0       	ldi	r18, 0x0A	; 10
     d2c:	37 ed       	ldi	r19, 0xD7	; 215
     d2e:	43 e2       	ldi	r20, 0x23	; 35
     d30:	5c e3       	ldi	r21, 0x3C	; 60
     d32:	a5 d0       	rcall	.+330    	; 0xe7e <__cmpsf2>
     d34:	88 23       	and	r24, r24
     d36:	44 f4       	brge	.+16     	; 0xd48 <tinyPotential_update+0x4a>
		tinyPotential_potential=0;
     d38:	10 92 5e 3e 	sts	0x3E5E, r1	; 0x803e5e <tinyPotential_potential>
     d3c:	10 92 5f 3e 	sts	0x3E5F, r1	; 0x803e5f <tinyPotential_potential+0x1>
     d40:	10 92 60 3e 	sts	0x3E60, r1	; 0x803e60 <tinyPotential_potential+0x2>
     d44:	10 92 61 3e 	sts	0x3E61, r1	; 0x803e61 <tinyPotential_potential+0x3>
	tinyDebugger_send_float("Potential", tinyPotential_potential);
	//Some of the potential in the neuron has decayed away
	tinyPotential_decay();
	
	// Update potential with values from Dendrites
	tinyPotential_potential = tinyDendrite_update_potential(tinyPotential_potential);
     d48:	60 91 5e 3e 	lds	r22, 0x3E5E	; 0x803e5e <tinyPotential_potential>
     d4c:	70 91 5f 3e 	lds	r23, 0x3E5F	; 0x803e5f <tinyPotential_potential+0x1>
     d50:	80 91 60 3e 	lds	r24, 0x3E60	; 0x803e60 <tinyPotential_potential+0x2>
     d54:	90 91 61 3e 	lds	r25, 0x3E61	; 0x803e61 <tinyPotential_potential+0x3>
     d58:	8f df       	rcall	.-226    	; 0xc78 <tinyDendrite_update_potential>
     d5a:	60 93 5e 3e 	sts	0x3E5E, r22	; 0x803e5e <tinyPotential_potential>
     d5e:	70 93 5f 3e 	sts	0x3E5F, r23	; 0x803e5f <tinyPotential_potential+0x1>
     d62:	80 93 60 3e 	sts	0x3E60, r24	; 0x803e60 <tinyPotential_potential+0x2>
     d66:	90 93 61 3e 	sts	0x3E61, r25	; 0x803e61 <tinyPotential_potential+0x3>
	
	// Update potential from button press
	tinyPotential_potential = tinyButton_update_potential(tinyPotential_potential);
     d6a:	7e dd       	rcall	.-1284   	; 0x868 <tinyButton_update_potential>
     d6c:	60 93 5e 3e 	sts	0x3E5E, r22	; 0x803e5e <tinyPotential_potential>
     d70:	70 93 5f 3e 	sts	0x3E5F, r23	; 0x803e5f <tinyPotential_potential+0x1>
     d74:	80 93 60 3e 	sts	0x3E60, r24	; 0x803e60 <tinyPotential_potential+0x2>
     d78:	90 93 61 3e 	sts	0x3E61, r25	; 0x803e61 <tinyPotential_potential+0x3>
	
	// Update potential with values from spontaneous pulse.
	tinyPotential_potential = tinyPulse_update_potential(tinyPotential_potential);
     d7c:	1e dc       	rcall	.-1988   	; 0x5ba <tinyPulse_update_potential>
     d7e:	60 93 5e 3e 	sts	0x3E5E, r22	; 0x803e5e <tinyPotential_potential>
     d82:	70 93 5f 3e 	sts	0x3E5F, r23	; 0x803e5f <tinyPotential_potential+0x1>
     d86:	80 93 60 3e 	sts	0x3E60, r24	; 0x803e60 <tinyPotential_potential+0x2>
     d8a:	90 93 61 3e 	sts	0x3E61, r25	; 0x803e61 <tinyPotential_potential+0x3>
	
	// Let the axon affect the potential
	// This is also where we decide whether or not the axon should fire
	tinyPotential_potential = tinyAxon_update_potential(tinyPotential_potential);
     d8e:	db dd       	rcall	.-1098   	; 0x946 <tinyAxon_update_potential>
     d90:	60 93 5e 3e 	sts	0x3E5E, r22	; 0x803e5e <tinyPotential_potential>
     d94:	70 93 5f 3e 	sts	0x3E5F, r23	; 0x803e5f <tinyPotential_potential+0x1>
     d98:	80 93 60 3e 	sts	0x3E60, r24	; 0x803e60 <tinyPotential_potential+0x2>
     d9c:	90 93 61 3e 	sts	0x3E61, r25	; 0x803e61 <tinyPotential_potential+0x3>

	//Update the led
	potential_to_RGB_update_LEDs(tinyPotential_potential);
     da0:	8a dc       	rcall	.-1772   	; 0x6b6 <potential_to_RGB_update_LEDs>
     da2:	08 95       	ret

00000da4 <__subsf3>:
     da4:	50 58       	subi	r21, 0x80	; 128

00000da6 <__addsf3>:
     da6:	bb 27       	eor	r27, r27
     da8:	aa 27       	eor	r26, r26
     daa:	0e 94 ea 06 	call	0xdd4	; 0xdd4 <__addsf3x>
     dae:	0c 94 64 08 	jmp	0x10c8	; 0x10c8 <__fp_round>
     db2:	0e 94 56 08 	call	0x10ac	; 0x10ac <__fp_pscA>
     db6:	38 f0       	brcs	.+14     	; 0xdc6 <__addsf3+0x20>
     db8:	0e 94 5d 08 	call	0x10ba	; 0x10ba <__fp_pscB>
     dbc:	20 f0       	brcs	.+8      	; 0xdc6 <__addsf3+0x20>
     dbe:	39 f4       	brne	.+14     	; 0xdce <__addsf3+0x28>
     dc0:	9f 3f       	cpi	r25, 0xFF	; 255
     dc2:	19 f4       	brne	.+6      	; 0xdca <__addsf3+0x24>
     dc4:	26 f4       	brtc	.+8      	; 0xdce <__addsf3+0x28>
     dc6:	0c 94 53 08 	jmp	0x10a6	; 0x10a6 <__fp_nan>
     dca:	0e f4       	brtc	.+2      	; 0xdce <__addsf3+0x28>
     dcc:	e0 95       	com	r30
     dce:	e7 fb       	bst	r30, 7
     dd0:	0c 94 4d 08 	jmp	0x109a	; 0x109a <__fp_inf>

00000dd4 <__addsf3x>:
     dd4:	e9 2f       	mov	r30, r25
     dd6:	0e 94 75 08 	call	0x10ea	; 0x10ea <__fp_split3>
     dda:	58 f3       	brcs	.-42     	; 0xdb2 <__addsf3+0xc>
     ddc:	ba 17       	cp	r27, r26
     dde:	62 07       	cpc	r22, r18
     de0:	73 07       	cpc	r23, r19
     de2:	84 07       	cpc	r24, r20
     de4:	95 07       	cpc	r25, r21
     de6:	20 f0       	brcs	.+8      	; 0xdf0 <__addsf3x+0x1c>
     de8:	79 f4       	brne	.+30     	; 0xe08 <__addsf3x+0x34>
     dea:	a6 f5       	brtc	.+104    	; 0xe54 <__addsf3x+0x80>
     dec:	0c 94 97 08 	jmp	0x112e	; 0x112e <__fp_zero>
     df0:	0e f4       	brtc	.+2      	; 0xdf4 <__addsf3x+0x20>
     df2:	e0 95       	com	r30
     df4:	0b 2e       	mov	r0, r27
     df6:	ba 2f       	mov	r27, r26
     df8:	a0 2d       	mov	r26, r0
     dfa:	0b 01       	movw	r0, r22
     dfc:	b9 01       	movw	r22, r18
     dfe:	90 01       	movw	r18, r0
     e00:	0c 01       	movw	r0, r24
     e02:	ca 01       	movw	r24, r20
     e04:	a0 01       	movw	r20, r0
     e06:	11 24       	eor	r1, r1
     e08:	ff 27       	eor	r31, r31
     e0a:	59 1b       	sub	r21, r25
     e0c:	99 f0       	breq	.+38     	; 0xe34 <__addsf3x+0x60>
     e0e:	59 3f       	cpi	r21, 0xF9	; 249
     e10:	50 f4       	brcc	.+20     	; 0xe26 <__addsf3x+0x52>
     e12:	50 3e       	cpi	r21, 0xE0	; 224
     e14:	68 f1       	brcs	.+90     	; 0xe70 <__addsf3x+0x9c>
     e16:	1a 16       	cp	r1, r26
     e18:	f0 40       	sbci	r31, 0x00	; 0
     e1a:	a2 2f       	mov	r26, r18
     e1c:	23 2f       	mov	r18, r19
     e1e:	34 2f       	mov	r19, r20
     e20:	44 27       	eor	r20, r20
     e22:	58 5f       	subi	r21, 0xF8	; 248
     e24:	f3 cf       	rjmp	.-26     	; 0xe0c <__addsf3x+0x38>
     e26:	46 95       	lsr	r20
     e28:	37 95       	ror	r19
     e2a:	27 95       	ror	r18
     e2c:	a7 95       	ror	r26
     e2e:	f0 40       	sbci	r31, 0x00	; 0
     e30:	53 95       	inc	r21
     e32:	c9 f7       	brne	.-14     	; 0xe26 <__addsf3x+0x52>
     e34:	7e f4       	brtc	.+30     	; 0xe54 <__addsf3x+0x80>
     e36:	1f 16       	cp	r1, r31
     e38:	ba 0b       	sbc	r27, r26
     e3a:	62 0b       	sbc	r22, r18
     e3c:	73 0b       	sbc	r23, r19
     e3e:	84 0b       	sbc	r24, r20
     e40:	ba f0       	brmi	.+46     	; 0xe70 <__addsf3x+0x9c>
     e42:	91 50       	subi	r25, 0x01	; 1
     e44:	a1 f0       	breq	.+40     	; 0xe6e <__addsf3x+0x9a>
     e46:	ff 0f       	add	r31, r31
     e48:	bb 1f       	adc	r27, r27
     e4a:	66 1f       	adc	r22, r22
     e4c:	77 1f       	adc	r23, r23
     e4e:	88 1f       	adc	r24, r24
     e50:	c2 f7       	brpl	.-16     	; 0xe42 <__addsf3x+0x6e>
     e52:	0e c0       	rjmp	.+28     	; 0xe70 <__addsf3x+0x9c>
     e54:	ba 0f       	add	r27, r26
     e56:	62 1f       	adc	r22, r18
     e58:	73 1f       	adc	r23, r19
     e5a:	84 1f       	adc	r24, r20
     e5c:	48 f4       	brcc	.+18     	; 0xe70 <__addsf3x+0x9c>
     e5e:	87 95       	ror	r24
     e60:	77 95       	ror	r23
     e62:	67 95       	ror	r22
     e64:	b7 95       	ror	r27
     e66:	f7 95       	ror	r31
     e68:	9e 3f       	cpi	r25, 0xFE	; 254
     e6a:	08 f0       	brcs	.+2      	; 0xe6e <__addsf3x+0x9a>
     e6c:	b0 cf       	rjmp	.-160    	; 0xdce <__addsf3+0x28>
     e6e:	93 95       	inc	r25
     e70:	88 0f       	add	r24, r24
     e72:	08 f0       	brcs	.+2      	; 0xe76 <__addsf3x+0xa2>
     e74:	99 27       	eor	r25, r25
     e76:	ee 0f       	add	r30, r30
     e78:	97 95       	ror	r25
     e7a:	87 95       	ror	r24
     e7c:	08 95       	ret

00000e7e <__cmpsf2>:
     e7e:	0e 94 29 08 	call	0x1052	; 0x1052 <__fp_cmp>
     e82:	08 f4       	brcc	.+2      	; 0xe86 <__cmpsf2+0x8>
     e84:	81 e0       	ldi	r24, 0x01	; 1
     e86:	08 95       	ret

00000e88 <__divsf3>:
     e88:	0e 94 58 07 	call	0xeb0	; 0xeb0 <__divsf3x>
     e8c:	0c 94 64 08 	jmp	0x10c8	; 0x10c8 <__fp_round>
     e90:	0e 94 5d 08 	call	0x10ba	; 0x10ba <__fp_pscB>
     e94:	58 f0       	brcs	.+22     	; 0xeac <__divsf3+0x24>
     e96:	0e 94 56 08 	call	0x10ac	; 0x10ac <__fp_pscA>
     e9a:	40 f0       	brcs	.+16     	; 0xeac <__divsf3+0x24>
     e9c:	29 f4       	brne	.+10     	; 0xea8 <__divsf3+0x20>
     e9e:	5f 3f       	cpi	r21, 0xFF	; 255
     ea0:	29 f0       	breq	.+10     	; 0xeac <__divsf3+0x24>
     ea2:	0c 94 4d 08 	jmp	0x109a	; 0x109a <__fp_inf>
     ea6:	51 11       	cpse	r21, r1
     ea8:	0c 94 98 08 	jmp	0x1130	; 0x1130 <__fp_szero>
     eac:	0c 94 53 08 	jmp	0x10a6	; 0x10a6 <__fp_nan>

00000eb0 <__divsf3x>:
     eb0:	0e 94 75 08 	call	0x10ea	; 0x10ea <__fp_split3>
     eb4:	68 f3       	brcs	.-38     	; 0xe90 <__divsf3+0x8>

00000eb6 <__divsf3_pse>:
     eb6:	99 23       	and	r25, r25
     eb8:	b1 f3       	breq	.-20     	; 0xea6 <__divsf3+0x1e>
     eba:	55 23       	and	r21, r21
     ebc:	91 f3       	breq	.-28     	; 0xea2 <__divsf3+0x1a>
     ebe:	95 1b       	sub	r25, r21
     ec0:	55 0b       	sbc	r21, r21
     ec2:	bb 27       	eor	r27, r27
     ec4:	aa 27       	eor	r26, r26
     ec6:	62 17       	cp	r22, r18
     ec8:	73 07       	cpc	r23, r19
     eca:	84 07       	cpc	r24, r20
     ecc:	38 f0       	brcs	.+14     	; 0xedc <__divsf3_pse+0x26>
     ece:	9f 5f       	subi	r25, 0xFF	; 255
     ed0:	5f 4f       	sbci	r21, 0xFF	; 255
     ed2:	22 0f       	add	r18, r18
     ed4:	33 1f       	adc	r19, r19
     ed6:	44 1f       	adc	r20, r20
     ed8:	aa 1f       	adc	r26, r26
     eda:	a9 f3       	breq	.-22     	; 0xec6 <__divsf3_pse+0x10>
     edc:	35 d0       	rcall	.+106    	; 0xf48 <__divsf3_pse+0x92>
     ede:	0e 2e       	mov	r0, r30
     ee0:	3a f0       	brmi	.+14     	; 0xef0 <__divsf3_pse+0x3a>
     ee2:	e0 e8       	ldi	r30, 0x80	; 128
     ee4:	32 d0       	rcall	.+100    	; 0xf4a <__divsf3_pse+0x94>
     ee6:	91 50       	subi	r25, 0x01	; 1
     ee8:	50 40       	sbci	r21, 0x00	; 0
     eea:	e6 95       	lsr	r30
     eec:	00 1c       	adc	r0, r0
     eee:	ca f7       	brpl	.-14     	; 0xee2 <__divsf3_pse+0x2c>
     ef0:	2b d0       	rcall	.+86     	; 0xf48 <__divsf3_pse+0x92>
     ef2:	fe 2f       	mov	r31, r30
     ef4:	29 d0       	rcall	.+82     	; 0xf48 <__divsf3_pse+0x92>
     ef6:	66 0f       	add	r22, r22
     ef8:	77 1f       	adc	r23, r23
     efa:	88 1f       	adc	r24, r24
     efc:	bb 1f       	adc	r27, r27
     efe:	26 17       	cp	r18, r22
     f00:	37 07       	cpc	r19, r23
     f02:	48 07       	cpc	r20, r24
     f04:	ab 07       	cpc	r26, r27
     f06:	b0 e8       	ldi	r27, 0x80	; 128
     f08:	09 f0       	breq	.+2      	; 0xf0c <__divsf3_pse+0x56>
     f0a:	bb 0b       	sbc	r27, r27
     f0c:	80 2d       	mov	r24, r0
     f0e:	bf 01       	movw	r22, r30
     f10:	ff 27       	eor	r31, r31
     f12:	93 58       	subi	r25, 0x83	; 131
     f14:	5f 4f       	sbci	r21, 0xFF	; 255
     f16:	3a f0       	brmi	.+14     	; 0xf26 <__divsf3_pse+0x70>
     f18:	9e 3f       	cpi	r25, 0xFE	; 254
     f1a:	51 05       	cpc	r21, r1
     f1c:	78 f0       	brcs	.+30     	; 0xf3c <__divsf3_pse+0x86>
     f1e:	0c 94 4d 08 	jmp	0x109a	; 0x109a <__fp_inf>
     f22:	0c 94 98 08 	jmp	0x1130	; 0x1130 <__fp_szero>
     f26:	5f 3f       	cpi	r21, 0xFF	; 255
     f28:	e4 f3       	brlt	.-8      	; 0xf22 <__divsf3_pse+0x6c>
     f2a:	98 3e       	cpi	r25, 0xE8	; 232
     f2c:	d4 f3       	brlt	.-12     	; 0xf22 <__divsf3_pse+0x6c>
     f2e:	86 95       	lsr	r24
     f30:	77 95       	ror	r23
     f32:	67 95       	ror	r22
     f34:	b7 95       	ror	r27
     f36:	f7 95       	ror	r31
     f38:	9f 5f       	subi	r25, 0xFF	; 255
     f3a:	c9 f7       	brne	.-14     	; 0xf2e <__divsf3_pse+0x78>
     f3c:	88 0f       	add	r24, r24
     f3e:	91 1d       	adc	r25, r1
     f40:	96 95       	lsr	r25
     f42:	87 95       	ror	r24
     f44:	97 f9       	bld	r25, 7
     f46:	08 95       	ret
     f48:	e1 e0       	ldi	r30, 0x01	; 1
     f4a:	66 0f       	add	r22, r22
     f4c:	77 1f       	adc	r23, r23
     f4e:	88 1f       	adc	r24, r24
     f50:	bb 1f       	adc	r27, r27
     f52:	62 17       	cp	r22, r18
     f54:	73 07       	cpc	r23, r19
     f56:	84 07       	cpc	r24, r20
     f58:	ba 07       	cpc	r27, r26
     f5a:	20 f0       	brcs	.+8      	; 0xf64 <__divsf3_pse+0xae>
     f5c:	62 1b       	sub	r22, r18
     f5e:	73 0b       	sbc	r23, r19
     f60:	84 0b       	sbc	r24, r20
     f62:	ba 0b       	sbc	r27, r26
     f64:	ee 1f       	adc	r30, r30
     f66:	88 f7       	brcc	.-30     	; 0xf4a <__divsf3_pse+0x94>
     f68:	e0 95       	com	r30
     f6a:	08 95       	ret

00000f6c <__fixsfsi>:
     f6c:	0e 94 bd 07 	call	0xf7a	; 0xf7a <__fixunssfsi>
     f70:	68 94       	set
     f72:	b1 11       	cpse	r27, r1
     f74:	0c 94 98 08 	jmp	0x1130	; 0x1130 <__fp_szero>
     f78:	08 95       	ret

00000f7a <__fixunssfsi>:
     f7a:	0e 94 7d 08 	call	0x10fa	; 0x10fa <__fp_splitA>
     f7e:	88 f0       	brcs	.+34     	; 0xfa2 <__fixunssfsi+0x28>
     f80:	9f 57       	subi	r25, 0x7F	; 127
     f82:	98 f0       	brcs	.+38     	; 0xfaa <__fixunssfsi+0x30>
     f84:	b9 2f       	mov	r27, r25
     f86:	99 27       	eor	r25, r25
     f88:	b7 51       	subi	r27, 0x17	; 23
     f8a:	b0 f0       	brcs	.+44     	; 0xfb8 <__fixunssfsi+0x3e>
     f8c:	e1 f0       	breq	.+56     	; 0xfc6 <__fixunssfsi+0x4c>
     f8e:	66 0f       	add	r22, r22
     f90:	77 1f       	adc	r23, r23
     f92:	88 1f       	adc	r24, r24
     f94:	99 1f       	adc	r25, r25
     f96:	1a f0       	brmi	.+6      	; 0xf9e <__fixunssfsi+0x24>
     f98:	ba 95       	dec	r27
     f9a:	c9 f7       	brne	.-14     	; 0xf8e <__fixunssfsi+0x14>
     f9c:	14 c0       	rjmp	.+40     	; 0xfc6 <__fixunssfsi+0x4c>
     f9e:	b1 30       	cpi	r27, 0x01	; 1
     fa0:	91 f0       	breq	.+36     	; 0xfc6 <__fixunssfsi+0x4c>
     fa2:	0e 94 97 08 	call	0x112e	; 0x112e <__fp_zero>
     fa6:	b1 e0       	ldi	r27, 0x01	; 1
     fa8:	08 95       	ret
     faa:	0c 94 97 08 	jmp	0x112e	; 0x112e <__fp_zero>
     fae:	67 2f       	mov	r22, r23
     fb0:	78 2f       	mov	r23, r24
     fb2:	88 27       	eor	r24, r24
     fb4:	b8 5f       	subi	r27, 0xF8	; 248
     fb6:	39 f0       	breq	.+14     	; 0xfc6 <__fixunssfsi+0x4c>
     fb8:	b9 3f       	cpi	r27, 0xF9	; 249
     fba:	cc f3       	brlt	.-14     	; 0xfae <__fixunssfsi+0x34>
     fbc:	86 95       	lsr	r24
     fbe:	77 95       	ror	r23
     fc0:	67 95       	ror	r22
     fc2:	b3 95       	inc	r27
     fc4:	d9 f7       	brne	.-10     	; 0xfbc <__fixunssfsi+0x42>
     fc6:	3e f4       	brtc	.+14     	; 0xfd6 <__fixunssfsi+0x5c>
     fc8:	90 95       	com	r25
     fca:	80 95       	com	r24
     fcc:	70 95       	com	r23
     fce:	61 95       	neg	r22
     fd0:	7f 4f       	sbci	r23, 0xFF	; 255
     fd2:	8f 4f       	sbci	r24, 0xFF	; 255
     fd4:	9f 4f       	sbci	r25, 0xFF	; 255
     fd6:	08 95       	ret

00000fd8 <__floatunsisf>:
     fd8:	e8 94       	clt
     fda:	09 c0       	rjmp	.+18     	; 0xfee <__floatsisf+0x12>

00000fdc <__floatsisf>:
     fdc:	97 fb       	bst	r25, 7
     fde:	3e f4       	brtc	.+14     	; 0xfee <__floatsisf+0x12>
     fe0:	90 95       	com	r25
     fe2:	80 95       	com	r24
     fe4:	70 95       	com	r23
     fe6:	61 95       	neg	r22
     fe8:	7f 4f       	sbci	r23, 0xFF	; 255
     fea:	8f 4f       	sbci	r24, 0xFF	; 255
     fec:	9f 4f       	sbci	r25, 0xFF	; 255
     fee:	99 23       	and	r25, r25
     ff0:	a9 f0       	breq	.+42     	; 0x101c <__floatsisf+0x40>
     ff2:	f9 2f       	mov	r31, r25
     ff4:	96 e9       	ldi	r25, 0x96	; 150
     ff6:	bb 27       	eor	r27, r27
     ff8:	93 95       	inc	r25
     ffa:	f6 95       	lsr	r31
     ffc:	87 95       	ror	r24
     ffe:	77 95       	ror	r23
    1000:	67 95       	ror	r22
    1002:	b7 95       	ror	r27
    1004:	f1 11       	cpse	r31, r1
    1006:	f8 cf       	rjmp	.-16     	; 0xff8 <__floatsisf+0x1c>
    1008:	fa f4       	brpl	.+62     	; 0x1048 <__floatsisf+0x6c>
    100a:	bb 0f       	add	r27, r27
    100c:	11 f4       	brne	.+4      	; 0x1012 <__floatsisf+0x36>
    100e:	60 ff       	sbrs	r22, 0
    1010:	1b c0       	rjmp	.+54     	; 0x1048 <__floatsisf+0x6c>
    1012:	6f 5f       	subi	r22, 0xFF	; 255
    1014:	7f 4f       	sbci	r23, 0xFF	; 255
    1016:	8f 4f       	sbci	r24, 0xFF	; 255
    1018:	9f 4f       	sbci	r25, 0xFF	; 255
    101a:	16 c0       	rjmp	.+44     	; 0x1048 <__floatsisf+0x6c>
    101c:	88 23       	and	r24, r24
    101e:	11 f0       	breq	.+4      	; 0x1024 <__floatsisf+0x48>
    1020:	96 e9       	ldi	r25, 0x96	; 150
    1022:	11 c0       	rjmp	.+34     	; 0x1046 <__floatsisf+0x6a>
    1024:	77 23       	and	r23, r23
    1026:	21 f0       	breq	.+8      	; 0x1030 <__floatsisf+0x54>
    1028:	9e e8       	ldi	r25, 0x8E	; 142
    102a:	87 2f       	mov	r24, r23
    102c:	76 2f       	mov	r23, r22
    102e:	05 c0       	rjmp	.+10     	; 0x103a <__floatsisf+0x5e>
    1030:	66 23       	and	r22, r22
    1032:	71 f0       	breq	.+28     	; 0x1050 <__floatsisf+0x74>
    1034:	96 e8       	ldi	r25, 0x86	; 134
    1036:	86 2f       	mov	r24, r22
    1038:	70 e0       	ldi	r23, 0x00	; 0
    103a:	60 e0       	ldi	r22, 0x00	; 0
    103c:	2a f0       	brmi	.+10     	; 0x1048 <__floatsisf+0x6c>
    103e:	9a 95       	dec	r25
    1040:	66 0f       	add	r22, r22
    1042:	77 1f       	adc	r23, r23
    1044:	88 1f       	adc	r24, r24
    1046:	da f7       	brpl	.-10     	; 0x103e <__floatsisf+0x62>
    1048:	88 0f       	add	r24, r24
    104a:	96 95       	lsr	r25
    104c:	87 95       	ror	r24
    104e:	97 f9       	bld	r25, 7
    1050:	08 95       	ret

00001052 <__fp_cmp>:
    1052:	99 0f       	add	r25, r25
    1054:	00 08       	sbc	r0, r0
    1056:	55 0f       	add	r21, r21
    1058:	aa 0b       	sbc	r26, r26
    105a:	e0 e8       	ldi	r30, 0x80	; 128
    105c:	fe ef       	ldi	r31, 0xFE	; 254
    105e:	16 16       	cp	r1, r22
    1060:	17 06       	cpc	r1, r23
    1062:	e8 07       	cpc	r30, r24
    1064:	f9 07       	cpc	r31, r25
    1066:	c0 f0       	brcs	.+48     	; 0x1098 <__fp_cmp+0x46>
    1068:	12 16       	cp	r1, r18
    106a:	13 06       	cpc	r1, r19
    106c:	e4 07       	cpc	r30, r20
    106e:	f5 07       	cpc	r31, r21
    1070:	98 f0       	brcs	.+38     	; 0x1098 <__fp_cmp+0x46>
    1072:	62 1b       	sub	r22, r18
    1074:	73 0b       	sbc	r23, r19
    1076:	84 0b       	sbc	r24, r20
    1078:	95 0b       	sbc	r25, r21
    107a:	39 f4       	brne	.+14     	; 0x108a <__fp_cmp+0x38>
    107c:	0a 26       	eor	r0, r26
    107e:	61 f0       	breq	.+24     	; 0x1098 <__fp_cmp+0x46>
    1080:	23 2b       	or	r18, r19
    1082:	24 2b       	or	r18, r20
    1084:	25 2b       	or	r18, r21
    1086:	21 f4       	brne	.+8      	; 0x1090 <__fp_cmp+0x3e>
    1088:	08 95       	ret
    108a:	0a 26       	eor	r0, r26
    108c:	09 f4       	brne	.+2      	; 0x1090 <__fp_cmp+0x3e>
    108e:	a1 40       	sbci	r26, 0x01	; 1
    1090:	a6 95       	lsr	r26
    1092:	8f ef       	ldi	r24, 0xFF	; 255
    1094:	81 1d       	adc	r24, r1
    1096:	81 1d       	adc	r24, r1
    1098:	08 95       	ret

0000109a <__fp_inf>:
    109a:	97 f9       	bld	r25, 7
    109c:	9f 67       	ori	r25, 0x7F	; 127
    109e:	80 e8       	ldi	r24, 0x80	; 128
    10a0:	70 e0       	ldi	r23, 0x00	; 0
    10a2:	60 e0       	ldi	r22, 0x00	; 0
    10a4:	08 95       	ret

000010a6 <__fp_nan>:
    10a6:	9f ef       	ldi	r25, 0xFF	; 255
    10a8:	80 ec       	ldi	r24, 0xC0	; 192
    10aa:	08 95       	ret

000010ac <__fp_pscA>:
    10ac:	00 24       	eor	r0, r0
    10ae:	0a 94       	dec	r0
    10b0:	16 16       	cp	r1, r22
    10b2:	17 06       	cpc	r1, r23
    10b4:	18 06       	cpc	r1, r24
    10b6:	09 06       	cpc	r0, r25
    10b8:	08 95       	ret

000010ba <__fp_pscB>:
    10ba:	00 24       	eor	r0, r0
    10bc:	0a 94       	dec	r0
    10be:	12 16       	cp	r1, r18
    10c0:	13 06       	cpc	r1, r19
    10c2:	14 06       	cpc	r1, r20
    10c4:	05 06       	cpc	r0, r21
    10c6:	08 95       	ret

000010c8 <__fp_round>:
    10c8:	09 2e       	mov	r0, r25
    10ca:	03 94       	inc	r0
    10cc:	00 0c       	add	r0, r0
    10ce:	11 f4       	brne	.+4      	; 0x10d4 <__fp_round+0xc>
    10d0:	88 23       	and	r24, r24
    10d2:	52 f0       	brmi	.+20     	; 0x10e8 <__fp_round+0x20>
    10d4:	bb 0f       	add	r27, r27
    10d6:	40 f4       	brcc	.+16     	; 0x10e8 <__fp_round+0x20>
    10d8:	bf 2b       	or	r27, r31
    10da:	11 f4       	brne	.+4      	; 0x10e0 <__fp_round+0x18>
    10dc:	60 ff       	sbrs	r22, 0
    10de:	04 c0       	rjmp	.+8      	; 0x10e8 <__fp_round+0x20>
    10e0:	6f 5f       	subi	r22, 0xFF	; 255
    10e2:	7f 4f       	sbci	r23, 0xFF	; 255
    10e4:	8f 4f       	sbci	r24, 0xFF	; 255
    10e6:	9f 4f       	sbci	r25, 0xFF	; 255
    10e8:	08 95       	ret

000010ea <__fp_split3>:
    10ea:	57 fd       	sbrc	r21, 7
    10ec:	90 58       	subi	r25, 0x80	; 128
    10ee:	44 0f       	add	r20, r20
    10f0:	55 1f       	adc	r21, r21
    10f2:	59 f0       	breq	.+22     	; 0x110a <__fp_splitA+0x10>
    10f4:	5f 3f       	cpi	r21, 0xFF	; 255
    10f6:	71 f0       	breq	.+28     	; 0x1114 <__fp_splitA+0x1a>
    10f8:	47 95       	ror	r20

000010fa <__fp_splitA>:
    10fa:	88 0f       	add	r24, r24
    10fc:	97 fb       	bst	r25, 7
    10fe:	99 1f       	adc	r25, r25
    1100:	61 f0       	breq	.+24     	; 0x111a <__fp_splitA+0x20>
    1102:	9f 3f       	cpi	r25, 0xFF	; 255
    1104:	79 f0       	breq	.+30     	; 0x1124 <__fp_splitA+0x2a>
    1106:	87 95       	ror	r24
    1108:	08 95       	ret
    110a:	12 16       	cp	r1, r18
    110c:	13 06       	cpc	r1, r19
    110e:	14 06       	cpc	r1, r20
    1110:	55 1f       	adc	r21, r21
    1112:	f2 cf       	rjmp	.-28     	; 0x10f8 <__fp_split3+0xe>
    1114:	46 95       	lsr	r20
    1116:	f1 df       	rcall	.-30     	; 0x10fa <__fp_splitA>
    1118:	08 c0       	rjmp	.+16     	; 0x112a <__fp_splitA+0x30>
    111a:	16 16       	cp	r1, r22
    111c:	17 06       	cpc	r1, r23
    111e:	18 06       	cpc	r1, r24
    1120:	99 1f       	adc	r25, r25
    1122:	f1 cf       	rjmp	.-30     	; 0x1106 <__fp_splitA+0xc>
    1124:	86 95       	lsr	r24
    1126:	71 05       	cpc	r23, r1
    1128:	61 05       	cpc	r22, r1
    112a:	08 94       	sec
    112c:	08 95       	ret

0000112e <__fp_zero>:
    112e:	e8 94       	clt

00001130 <__fp_szero>:
    1130:	bb 27       	eor	r27, r27
    1132:	66 27       	eor	r22, r22
    1134:	77 27       	eor	r23, r23
    1136:	cb 01       	movw	r24, r22
    1138:	97 f9       	bld	r25, 7
    113a:	08 95       	ret

0000113c <__gesf2>:
    113c:	0e 94 29 08 	call	0x1052	; 0x1052 <__fp_cmp>
    1140:	08 f4       	brcc	.+2      	; 0x1144 <__gesf2+0x8>
    1142:	8f ef       	ldi	r24, 0xFF	; 255
    1144:	08 95       	ret

00001146 <__mulsf3>:
    1146:	0e 94 b6 08 	call	0x116c	; 0x116c <__mulsf3x>
    114a:	0c 94 64 08 	jmp	0x10c8	; 0x10c8 <__fp_round>
    114e:	0e 94 56 08 	call	0x10ac	; 0x10ac <__fp_pscA>
    1152:	38 f0       	brcs	.+14     	; 0x1162 <__mulsf3+0x1c>
    1154:	0e 94 5d 08 	call	0x10ba	; 0x10ba <__fp_pscB>
    1158:	20 f0       	brcs	.+8      	; 0x1162 <__mulsf3+0x1c>
    115a:	95 23       	and	r25, r21
    115c:	11 f0       	breq	.+4      	; 0x1162 <__mulsf3+0x1c>
    115e:	0c 94 4d 08 	jmp	0x109a	; 0x109a <__fp_inf>
    1162:	0c 94 53 08 	jmp	0x10a6	; 0x10a6 <__fp_nan>
    1166:	11 24       	eor	r1, r1
    1168:	0c 94 98 08 	jmp	0x1130	; 0x1130 <__fp_szero>

0000116c <__mulsf3x>:
    116c:	0e 94 75 08 	call	0x10ea	; 0x10ea <__fp_split3>
    1170:	70 f3       	brcs	.-36     	; 0x114e <__mulsf3+0x8>

00001172 <__mulsf3_pse>:
    1172:	95 9f       	mul	r25, r21
    1174:	c1 f3       	breq	.-16     	; 0x1166 <__mulsf3+0x20>
    1176:	95 0f       	add	r25, r21
    1178:	50 e0       	ldi	r21, 0x00	; 0
    117a:	55 1f       	adc	r21, r21
    117c:	62 9f       	mul	r22, r18
    117e:	f0 01       	movw	r30, r0
    1180:	72 9f       	mul	r23, r18
    1182:	bb 27       	eor	r27, r27
    1184:	f0 0d       	add	r31, r0
    1186:	b1 1d       	adc	r27, r1
    1188:	63 9f       	mul	r22, r19
    118a:	aa 27       	eor	r26, r26
    118c:	f0 0d       	add	r31, r0
    118e:	b1 1d       	adc	r27, r1
    1190:	aa 1f       	adc	r26, r26
    1192:	64 9f       	mul	r22, r20
    1194:	66 27       	eor	r22, r22
    1196:	b0 0d       	add	r27, r0
    1198:	a1 1d       	adc	r26, r1
    119a:	66 1f       	adc	r22, r22
    119c:	82 9f       	mul	r24, r18
    119e:	22 27       	eor	r18, r18
    11a0:	b0 0d       	add	r27, r0
    11a2:	a1 1d       	adc	r26, r1
    11a4:	62 1f       	adc	r22, r18
    11a6:	73 9f       	mul	r23, r19
    11a8:	b0 0d       	add	r27, r0
    11aa:	a1 1d       	adc	r26, r1
    11ac:	62 1f       	adc	r22, r18
    11ae:	83 9f       	mul	r24, r19
    11b0:	a0 0d       	add	r26, r0
    11b2:	61 1d       	adc	r22, r1
    11b4:	22 1f       	adc	r18, r18
    11b6:	74 9f       	mul	r23, r20
    11b8:	33 27       	eor	r19, r19
    11ba:	a0 0d       	add	r26, r0
    11bc:	61 1d       	adc	r22, r1
    11be:	23 1f       	adc	r18, r19
    11c0:	84 9f       	mul	r24, r20
    11c2:	60 0d       	add	r22, r0
    11c4:	21 1d       	adc	r18, r1
    11c6:	82 2f       	mov	r24, r18
    11c8:	76 2f       	mov	r23, r22
    11ca:	6a 2f       	mov	r22, r26
    11cc:	11 24       	eor	r1, r1
    11ce:	9f 57       	subi	r25, 0x7F	; 127
    11d0:	50 40       	sbci	r21, 0x00	; 0
    11d2:	9a f0       	brmi	.+38     	; 0x11fa <__mulsf3_pse+0x88>
    11d4:	f1 f0       	breq	.+60     	; 0x1212 <__mulsf3_pse+0xa0>
    11d6:	88 23       	and	r24, r24
    11d8:	4a f0       	brmi	.+18     	; 0x11ec <__mulsf3_pse+0x7a>
    11da:	ee 0f       	add	r30, r30
    11dc:	ff 1f       	adc	r31, r31
    11de:	bb 1f       	adc	r27, r27
    11e0:	66 1f       	adc	r22, r22
    11e2:	77 1f       	adc	r23, r23
    11e4:	88 1f       	adc	r24, r24
    11e6:	91 50       	subi	r25, 0x01	; 1
    11e8:	50 40       	sbci	r21, 0x00	; 0
    11ea:	a9 f7       	brne	.-22     	; 0x11d6 <__mulsf3_pse+0x64>
    11ec:	9e 3f       	cpi	r25, 0xFE	; 254
    11ee:	51 05       	cpc	r21, r1
    11f0:	80 f0       	brcs	.+32     	; 0x1212 <__mulsf3_pse+0xa0>
    11f2:	0c 94 4d 08 	jmp	0x109a	; 0x109a <__fp_inf>
    11f6:	0c 94 98 08 	jmp	0x1130	; 0x1130 <__fp_szero>
    11fa:	5f 3f       	cpi	r21, 0xFF	; 255
    11fc:	e4 f3       	brlt	.-8      	; 0x11f6 <__mulsf3_pse+0x84>
    11fe:	98 3e       	cpi	r25, 0xE8	; 232
    1200:	d4 f3       	brlt	.-12     	; 0x11f6 <__mulsf3_pse+0x84>
    1202:	86 95       	lsr	r24
    1204:	77 95       	ror	r23
    1206:	67 95       	ror	r22
    1208:	b7 95       	ror	r27
    120a:	f7 95       	ror	r31
    120c:	e7 95       	ror	r30
    120e:	9f 5f       	subi	r25, 0xFF	; 255
    1210:	c1 f7       	brne	.-16     	; 0x1202 <__mulsf3_pse+0x90>
    1212:	fe 2b       	or	r31, r30
    1214:	88 0f       	add	r24, r24
    1216:	91 1d       	adc	r25, r1
    1218:	96 95       	lsr	r25
    121a:	87 95       	ror	r24
    121c:	97 f9       	bld	r25, 7
    121e:	08 95       	ret

00001220 <round>:
    1220:	0e 94 7d 08 	call	0x10fa	; 0x10fa <__fp_splitA>
    1224:	e8 f0       	brcs	.+58     	; 0x1260 <round+0x40>
    1226:	9e 37       	cpi	r25, 0x7E	; 126
    1228:	e8 f0       	brcs	.+58     	; 0x1264 <round+0x44>
    122a:	96 39       	cpi	r25, 0x96	; 150
    122c:	b8 f4       	brcc	.+46     	; 0x125c <round+0x3c>
    122e:	9e 38       	cpi	r25, 0x8E	; 142
    1230:	48 f4       	brcc	.+18     	; 0x1244 <round+0x24>
    1232:	67 2f       	mov	r22, r23
    1234:	78 2f       	mov	r23, r24
    1236:	88 27       	eor	r24, r24
    1238:	98 5f       	subi	r25, 0xF8	; 248
    123a:	f9 cf       	rjmp	.-14     	; 0x122e <round+0xe>
    123c:	86 95       	lsr	r24
    123e:	77 95       	ror	r23
    1240:	67 95       	ror	r22
    1242:	93 95       	inc	r25
    1244:	95 39       	cpi	r25, 0x95	; 149
    1246:	d0 f3       	brcs	.-12     	; 0x123c <round+0x1c>
    1248:	b6 2f       	mov	r27, r22
    124a:	b1 70       	andi	r27, 0x01	; 1
    124c:	6b 0f       	add	r22, r27
    124e:	71 1d       	adc	r23, r1
    1250:	81 1d       	adc	r24, r1
    1252:	20 f4       	brcc	.+8      	; 0x125c <round+0x3c>
    1254:	87 95       	ror	r24
    1256:	77 95       	ror	r23
    1258:	67 95       	ror	r22
    125a:	93 95       	inc	r25
    125c:	0c 94 34 09 	jmp	0x1268	; 0x1268 <__fp_mintl>
    1260:	0c 94 4f 09 	jmp	0x129e	; 0x129e <__fp_mpack>
    1264:	0c 94 98 08 	jmp	0x1130	; 0x1130 <__fp_szero>

00001268 <__fp_mintl>:
    1268:	88 23       	and	r24, r24
    126a:	71 f4       	brne	.+28     	; 0x1288 <__fp_mintl+0x20>
    126c:	77 23       	and	r23, r23
    126e:	21 f0       	breq	.+8      	; 0x1278 <__fp_mintl+0x10>
    1270:	98 50       	subi	r25, 0x08	; 8
    1272:	87 2b       	or	r24, r23
    1274:	76 2f       	mov	r23, r22
    1276:	07 c0       	rjmp	.+14     	; 0x1286 <__fp_mintl+0x1e>
    1278:	66 23       	and	r22, r22
    127a:	11 f4       	brne	.+4      	; 0x1280 <__fp_mintl+0x18>
    127c:	99 27       	eor	r25, r25
    127e:	0d c0       	rjmp	.+26     	; 0x129a <__fp_mintl+0x32>
    1280:	90 51       	subi	r25, 0x10	; 16
    1282:	86 2b       	or	r24, r22
    1284:	70 e0       	ldi	r23, 0x00	; 0
    1286:	60 e0       	ldi	r22, 0x00	; 0
    1288:	2a f0       	brmi	.+10     	; 0x1294 <__fp_mintl+0x2c>
    128a:	9a 95       	dec	r25
    128c:	66 0f       	add	r22, r22
    128e:	77 1f       	adc	r23, r23
    1290:	88 1f       	adc	r24, r24
    1292:	da f7       	brpl	.-10     	; 0x128a <__fp_mintl+0x22>
    1294:	88 0f       	add	r24, r24
    1296:	96 95       	lsr	r25
    1298:	87 95       	ror	r24
    129a:	97 f9       	bld	r25, 7
    129c:	08 95       	ret

0000129e <__fp_mpack>:
    129e:	9f 3f       	cpi	r25, 0xFF	; 255
    12a0:	31 f0       	breq	.+12     	; 0x12ae <__fp_mpack_finite+0xc>

000012a2 <__fp_mpack_finite>:
    12a2:	91 50       	subi	r25, 0x01	; 1
    12a4:	20 f4       	brcc	.+8      	; 0x12ae <__fp_mpack_finite+0xc>
    12a6:	87 95       	ror	r24
    12a8:	77 95       	ror	r23
    12aa:	67 95       	ror	r22
    12ac:	b7 95       	ror	r27
    12ae:	88 0f       	add	r24, r24
    12b0:	91 1d       	adc	r25, r1
    12b2:	96 95       	lsr	r25
    12b4:	87 95       	ror	r24
    12b6:	97 f9       	bld	r25, 7
    12b8:	08 95       	ret

000012ba <dtostrf>:
    12ba:	ef 92       	push	r14
    12bc:	0f 93       	push	r16
    12be:	1f 93       	push	r17
    12c0:	cf 93       	push	r28
    12c2:	df 93       	push	r29
    12c4:	e8 01       	movw	r28, r16
    12c6:	47 fd       	sbrc	r20, 7
    12c8:	02 c0       	rjmp	.+4      	; 0x12ce <dtostrf+0x14>
    12ca:	34 e0       	ldi	r19, 0x04	; 4
    12cc:	01 c0       	rjmp	.+2      	; 0x12d0 <dtostrf+0x16>
    12ce:	34 e1       	ldi	r19, 0x14	; 20
    12d0:	04 2e       	mov	r0, r20
    12d2:	00 0c       	add	r0, r0
    12d4:	55 0b       	sbc	r21, r21
    12d6:	57 ff       	sbrs	r21, 7
    12d8:	03 c0       	rjmp	.+6      	; 0x12e0 <dtostrf+0x26>
    12da:	51 95       	neg	r21
    12dc:	41 95       	neg	r20
    12de:	51 09       	sbc	r21, r1
    12e0:	e3 2e       	mov	r14, r19
    12e2:	02 2f       	mov	r16, r18
    12e4:	24 2f       	mov	r18, r20
    12e6:	ae 01       	movw	r20, r28
    12e8:	3d d3       	rcall	.+1658   	; 0x1964 <dtoa_prf>
    12ea:	ce 01       	movw	r24, r28
    12ec:	df 91       	pop	r29
    12ee:	cf 91       	pop	r28
    12f0:	1f 91       	pop	r17
    12f2:	0f 91       	pop	r16
    12f4:	ef 90       	pop	r14
    12f6:	08 95       	ret

000012f8 <malloc>:
    12f8:	0f 93       	push	r16
    12fa:	1f 93       	push	r17
    12fc:	cf 93       	push	r28
    12fe:	df 93       	push	r29
    1300:	82 30       	cpi	r24, 0x02	; 2
    1302:	91 05       	cpc	r25, r1
    1304:	10 f4       	brcc	.+4      	; 0x130a <malloc+0x12>
    1306:	82 e0       	ldi	r24, 0x02	; 2
    1308:	90 e0       	ldi	r25, 0x00	; 0
    130a:	e0 91 65 3e 	lds	r30, 0x3E65	; 0x803e65 <__flp>
    130e:	f0 91 66 3e 	lds	r31, 0x3E66	; 0x803e66 <__flp+0x1>
    1312:	20 e0       	ldi	r18, 0x00	; 0
    1314:	30 e0       	ldi	r19, 0x00	; 0
    1316:	a0 e0       	ldi	r26, 0x00	; 0
    1318:	b0 e0       	ldi	r27, 0x00	; 0
    131a:	30 97       	sbiw	r30, 0x00	; 0
    131c:	19 f1       	breq	.+70     	; 0x1364 <malloc+0x6c>
    131e:	40 81       	ld	r20, Z
    1320:	51 81       	ldd	r21, Z+1	; 0x01
    1322:	02 81       	ldd	r16, Z+2	; 0x02
    1324:	13 81       	ldd	r17, Z+3	; 0x03
    1326:	48 17       	cp	r20, r24
    1328:	59 07       	cpc	r21, r25
    132a:	c8 f0       	brcs	.+50     	; 0x135e <malloc+0x66>
    132c:	84 17       	cp	r24, r20
    132e:	95 07       	cpc	r25, r21
    1330:	69 f4       	brne	.+26     	; 0x134c <malloc+0x54>
    1332:	10 97       	sbiw	r26, 0x00	; 0
    1334:	31 f0       	breq	.+12     	; 0x1342 <malloc+0x4a>
    1336:	12 96       	adiw	r26, 0x02	; 2
    1338:	0c 93       	st	X, r16
    133a:	12 97       	sbiw	r26, 0x02	; 2
    133c:	13 96       	adiw	r26, 0x03	; 3
    133e:	1c 93       	st	X, r17
    1340:	27 c0       	rjmp	.+78     	; 0x1390 <malloc+0x98>
    1342:	00 93 65 3e 	sts	0x3E65, r16	; 0x803e65 <__flp>
    1346:	10 93 66 3e 	sts	0x3E66, r17	; 0x803e66 <__flp+0x1>
    134a:	22 c0       	rjmp	.+68     	; 0x1390 <malloc+0x98>
    134c:	21 15       	cp	r18, r1
    134e:	31 05       	cpc	r19, r1
    1350:	19 f0       	breq	.+6      	; 0x1358 <malloc+0x60>
    1352:	42 17       	cp	r20, r18
    1354:	53 07       	cpc	r21, r19
    1356:	18 f4       	brcc	.+6      	; 0x135e <malloc+0x66>
    1358:	9a 01       	movw	r18, r20
    135a:	bd 01       	movw	r22, r26
    135c:	ef 01       	movw	r28, r30
    135e:	df 01       	movw	r26, r30
    1360:	f8 01       	movw	r30, r16
    1362:	db cf       	rjmp	.-74     	; 0x131a <malloc+0x22>
    1364:	21 15       	cp	r18, r1
    1366:	31 05       	cpc	r19, r1
    1368:	f9 f0       	breq	.+62     	; 0x13a8 <malloc+0xb0>
    136a:	28 1b       	sub	r18, r24
    136c:	39 0b       	sbc	r19, r25
    136e:	24 30       	cpi	r18, 0x04	; 4
    1370:	31 05       	cpc	r19, r1
    1372:	80 f4       	brcc	.+32     	; 0x1394 <malloc+0x9c>
    1374:	8a 81       	ldd	r24, Y+2	; 0x02
    1376:	9b 81       	ldd	r25, Y+3	; 0x03
    1378:	61 15       	cp	r22, r1
    137a:	71 05       	cpc	r23, r1
    137c:	21 f0       	breq	.+8      	; 0x1386 <malloc+0x8e>
    137e:	fb 01       	movw	r30, r22
    1380:	82 83       	std	Z+2, r24	; 0x02
    1382:	93 83       	std	Z+3, r25	; 0x03
    1384:	04 c0       	rjmp	.+8      	; 0x138e <malloc+0x96>
    1386:	80 93 65 3e 	sts	0x3E65, r24	; 0x803e65 <__flp>
    138a:	90 93 66 3e 	sts	0x3E66, r25	; 0x803e66 <__flp+0x1>
    138e:	fe 01       	movw	r30, r28
    1390:	32 96       	adiw	r30, 0x02	; 2
    1392:	44 c0       	rjmp	.+136    	; 0x141c <malloc+0x124>
    1394:	fe 01       	movw	r30, r28
    1396:	e2 0f       	add	r30, r18
    1398:	f3 1f       	adc	r31, r19
    139a:	81 93       	st	Z+, r24
    139c:	91 93       	st	Z+, r25
    139e:	22 50       	subi	r18, 0x02	; 2
    13a0:	31 09       	sbc	r19, r1
    13a2:	28 83       	st	Y, r18
    13a4:	39 83       	std	Y+1, r19	; 0x01
    13a6:	3a c0       	rjmp	.+116    	; 0x141c <malloc+0x124>
    13a8:	20 91 63 3e 	lds	r18, 0x3E63	; 0x803e63 <__brkval>
    13ac:	30 91 64 3e 	lds	r19, 0x3E64	; 0x803e64 <__brkval+0x1>
    13b0:	23 2b       	or	r18, r19
    13b2:	41 f4       	brne	.+16     	; 0x13c4 <malloc+0xcc>
    13b4:	20 91 02 3e 	lds	r18, 0x3E02	; 0x803e02 <__malloc_heap_start>
    13b8:	30 91 03 3e 	lds	r19, 0x3E03	; 0x803e03 <__malloc_heap_start+0x1>
    13bc:	20 93 63 3e 	sts	0x3E63, r18	; 0x803e63 <__brkval>
    13c0:	30 93 64 3e 	sts	0x3E64, r19	; 0x803e64 <__brkval+0x1>
    13c4:	20 91 00 3e 	lds	r18, 0x3E00	; 0x803e00 <__data_start>
    13c8:	30 91 01 3e 	lds	r19, 0x3E01	; 0x803e01 <__data_start+0x1>
    13cc:	21 15       	cp	r18, r1
    13ce:	31 05       	cpc	r19, r1
    13d0:	41 f4       	brne	.+16     	; 0x13e2 <malloc+0xea>
    13d2:	2d b7       	in	r18, 0x3d	; 61
    13d4:	3e b7       	in	r19, 0x3e	; 62
    13d6:	40 91 04 3e 	lds	r20, 0x3E04	; 0x803e04 <__malloc_margin>
    13da:	50 91 05 3e 	lds	r21, 0x3E05	; 0x803e05 <__malloc_margin+0x1>
    13de:	24 1b       	sub	r18, r20
    13e0:	35 0b       	sbc	r19, r21
    13e2:	e0 91 63 3e 	lds	r30, 0x3E63	; 0x803e63 <__brkval>
    13e6:	f0 91 64 3e 	lds	r31, 0x3E64	; 0x803e64 <__brkval+0x1>
    13ea:	e2 17       	cp	r30, r18
    13ec:	f3 07       	cpc	r31, r19
    13ee:	a0 f4       	brcc	.+40     	; 0x1418 <malloc+0x120>
    13f0:	2e 1b       	sub	r18, r30
    13f2:	3f 0b       	sbc	r19, r31
    13f4:	28 17       	cp	r18, r24
    13f6:	39 07       	cpc	r19, r25
    13f8:	78 f0       	brcs	.+30     	; 0x1418 <malloc+0x120>
    13fa:	ac 01       	movw	r20, r24
    13fc:	4e 5f       	subi	r20, 0xFE	; 254
    13fe:	5f 4f       	sbci	r21, 0xFF	; 255
    1400:	24 17       	cp	r18, r20
    1402:	35 07       	cpc	r19, r21
    1404:	48 f0       	brcs	.+18     	; 0x1418 <malloc+0x120>
    1406:	4e 0f       	add	r20, r30
    1408:	5f 1f       	adc	r21, r31
    140a:	40 93 63 3e 	sts	0x3E63, r20	; 0x803e63 <__brkval>
    140e:	50 93 64 3e 	sts	0x3E64, r21	; 0x803e64 <__brkval+0x1>
    1412:	81 93       	st	Z+, r24
    1414:	91 93       	st	Z+, r25
    1416:	02 c0       	rjmp	.+4      	; 0x141c <malloc+0x124>
    1418:	e0 e0       	ldi	r30, 0x00	; 0
    141a:	f0 e0       	ldi	r31, 0x00	; 0
    141c:	cf 01       	movw	r24, r30
    141e:	df 91       	pop	r29
    1420:	cf 91       	pop	r28
    1422:	1f 91       	pop	r17
    1424:	0f 91       	pop	r16
    1426:	08 95       	ret

00001428 <free>:
    1428:	cf 93       	push	r28
    142a:	df 93       	push	r29
    142c:	00 97       	sbiw	r24, 0x00	; 0
    142e:	09 f4       	brne	.+2      	; 0x1432 <free+0xa>
    1430:	81 c0       	rjmp	.+258    	; 0x1534 <free+0x10c>
    1432:	fc 01       	movw	r30, r24
    1434:	32 97       	sbiw	r30, 0x02	; 2
    1436:	12 82       	std	Z+2, r1	; 0x02
    1438:	13 82       	std	Z+3, r1	; 0x03
    143a:	a0 91 65 3e 	lds	r26, 0x3E65	; 0x803e65 <__flp>
    143e:	b0 91 66 3e 	lds	r27, 0x3E66	; 0x803e66 <__flp+0x1>
    1442:	10 97       	sbiw	r26, 0x00	; 0
    1444:	81 f4       	brne	.+32     	; 0x1466 <free+0x3e>
    1446:	20 81       	ld	r18, Z
    1448:	31 81       	ldd	r19, Z+1	; 0x01
    144a:	82 0f       	add	r24, r18
    144c:	93 1f       	adc	r25, r19
    144e:	20 91 63 3e 	lds	r18, 0x3E63	; 0x803e63 <__brkval>
    1452:	30 91 64 3e 	lds	r19, 0x3E64	; 0x803e64 <__brkval+0x1>
    1456:	28 17       	cp	r18, r24
    1458:	39 07       	cpc	r19, r25
    145a:	51 f5       	brne	.+84     	; 0x14b0 <free+0x88>
    145c:	e0 93 63 3e 	sts	0x3E63, r30	; 0x803e63 <__brkval>
    1460:	f0 93 64 3e 	sts	0x3E64, r31	; 0x803e64 <__brkval+0x1>
    1464:	67 c0       	rjmp	.+206    	; 0x1534 <free+0x10c>
    1466:	ed 01       	movw	r28, r26
    1468:	20 e0       	ldi	r18, 0x00	; 0
    146a:	30 e0       	ldi	r19, 0x00	; 0
    146c:	ce 17       	cp	r28, r30
    146e:	df 07       	cpc	r29, r31
    1470:	40 f4       	brcc	.+16     	; 0x1482 <free+0x5a>
    1472:	4a 81       	ldd	r20, Y+2	; 0x02
    1474:	5b 81       	ldd	r21, Y+3	; 0x03
    1476:	9e 01       	movw	r18, r28
    1478:	41 15       	cp	r20, r1
    147a:	51 05       	cpc	r21, r1
    147c:	f1 f0       	breq	.+60     	; 0x14ba <free+0x92>
    147e:	ea 01       	movw	r28, r20
    1480:	f5 cf       	rjmp	.-22     	; 0x146c <free+0x44>
    1482:	c2 83       	std	Z+2, r28	; 0x02
    1484:	d3 83       	std	Z+3, r29	; 0x03
    1486:	40 81       	ld	r20, Z
    1488:	51 81       	ldd	r21, Z+1	; 0x01
    148a:	84 0f       	add	r24, r20
    148c:	95 1f       	adc	r25, r21
    148e:	c8 17       	cp	r28, r24
    1490:	d9 07       	cpc	r29, r25
    1492:	59 f4       	brne	.+22     	; 0x14aa <free+0x82>
    1494:	88 81       	ld	r24, Y
    1496:	99 81       	ldd	r25, Y+1	; 0x01
    1498:	84 0f       	add	r24, r20
    149a:	95 1f       	adc	r25, r21
    149c:	02 96       	adiw	r24, 0x02	; 2
    149e:	80 83       	st	Z, r24
    14a0:	91 83       	std	Z+1, r25	; 0x01
    14a2:	8a 81       	ldd	r24, Y+2	; 0x02
    14a4:	9b 81       	ldd	r25, Y+3	; 0x03
    14a6:	82 83       	std	Z+2, r24	; 0x02
    14a8:	93 83       	std	Z+3, r25	; 0x03
    14aa:	21 15       	cp	r18, r1
    14ac:	31 05       	cpc	r19, r1
    14ae:	29 f4       	brne	.+10     	; 0x14ba <free+0x92>
    14b0:	e0 93 65 3e 	sts	0x3E65, r30	; 0x803e65 <__flp>
    14b4:	f0 93 66 3e 	sts	0x3E66, r31	; 0x803e66 <__flp+0x1>
    14b8:	3d c0       	rjmp	.+122    	; 0x1534 <free+0x10c>
    14ba:	e9 01       	movw	r28, r18
    14bc:	ea 83       	std	Y+2, r30	; 0x02
    14be:	fb 83       	std	Y+3, r31	; 0x03
    14c0:	49 91       	ld	r20, Y+
    14c2:	59 91       	ld	r21, Y+
    14c4:	c4 0f       	add	r28, r20
    14c6:	d5 1f       	adc	r29, r21
    14c8:	ec 17       	cp	r30, r28
    14ca:	fd 07       	cpc	r31, r29
    14cc:	61 f4       	brne	.+24     	; 0x14e6 <free+0xbe>
    14ce:	80 81       	ld	r24, Z
    14d0:	91 81       	ldd	r25, Z+1	; 0x01
    14d2:	84 0f       	add	r24, r20
    14d4:	95 1f       	adc	r25, r21
    14d6:	02 96       	adiw	r24, 0x02	; 2
    14d8:	e9 01       	movw	r28, r18
    14da:	88 83       	st	Y, r24
    14dc:	99 83       	std	Y+1, r25	; 0x01
    14de:	82 81       	ldd	r24, Z+2	; 0x02
    14e0:	93 81       	ldd	r25, Z+3	; 0x03
    14e2:	8a 83       	std	Y+2, r24	; 0x02
    14e4:	9b 83       	std	Y+3, r25	; 0x03
    14e6:	e0 e0       	ldi	r30, 0x00	; 0
    14e8:	f0 e0       	ldi	r31, 0x00	; 0
    14ea:	12 96       	adiw	r26, 0x02	; 2
    14ec:	8d 91       	ld	r24, X+
    14ee:	9c 91       	ld	r25, X
    14f0:	13 97       	sbiw	r26, 0x03	; 3
    14f2:	00 97       	sbiw	r24, 0x00	; 0
    14f4:	19 f0       	breq	.+6      	; 0x14fc <free+0xd4>
    14f6:	fd 01       	movw	r30, r26
    14f8:	dc 01       	movw	r26, r24
    14fa:	f7 cf       	rjmp	.-18     	; 0x14ea <free+0xc2>
    14fc:	8d 91       	ld	r24, X+
    14fe:	9c 91       	ld	r25, X
    1500:	11 97       	sbiw	r26, 0x01	; 1
    1502:	9d 01       	movw	r18, r26
    1504:	2e 5f       	subi	r18, 0xFE	; 254
    1506:	3f 4f       	sbci	r19, 0xFF	; 255
    1508:	82 0f       	add	r24, r18
    150a:	93 1f       	adc	r25, r19
    150c:	20 91 63 3e 	lds	r18, 0x3E63	; 0x803e63 <__brkval>
    1510:	30 91 64 3e 	lds	r19, 0x3E64	; 0x803e64 <__brkval+0x1>
    1514:	28 17       	cp	r18, r24
    1516:	39 07       	cpc	r19, r25
    1518:	69 f4       	brne	.+26     	; 0x1534 <free+0x10c>
    151a:	30 97       	sbiw	r30, 0x00	; 0
    151c:	29 f4       	brne	.+10     	; 0x1528 <free+0x100>
    151e:	10 92 65 3e 	sts	0x3E65, r1	; 0x803e65 <__flp>
    1522:	10 92 66 3e 	sts	0x3E66, r1	; 0x803e66 <__flp+0x1>
    1526:	02 c0       	rjmp	.+4      	; 0x152c <free+0x104>
    1528:	12 82       	std	Z+2, r1	; 0x02
    152a:	13 82       	std	Z+3, r1	; 0x03
    152c:	a0 93 63 3e 	sts	0x3E63, r26	; 0x803e63 <__brkval>
    1530:	b0 93 64 3e 	sts	0x3E64, r27	; 0x803e64 <__brkval+0x1>
    1534:	df 91       	pop	r29
    1536:	cf 91       	pop	r28
    1538:	08 95       	ret

0000153a <printf>:
    153a:	a0 e0       	ldi	r26, 0x00	; 0
    153c:	b0 e0       	ldi	r27, 0x00	; 0
    153e:	e2 ea       	ldi	r30, 0xA2	; 162
    1540:	fa e0       	ldi	r31, 0x0A	; 10
    1542:	ff c4       	rjmp	.+2558   	; 0x1f42 <__prologue_saves__+0x20>
    1544:	ae 01       	movw	r20, r28
    1546:	4b 5f       	subi	r20, 0xFB	; 251
    1548:	5f 4f       	sbci	r21, 0xFF	; 255
    154a:	fa 01       	movw	r30, r20
    154c:	61 91       	ld	r22, Z+
    154e:	71 91       	ld	r23, Z+
    1550:	af 01       	movw	r20, r30
    1552:	80 91 69 3e 	lds	r24, 0x3E69	; 0x803e69 <__iob+0x2>
    1556:	90 91 6a 3e 	lds	r25, 0x3E6A	; 0x803e6a <__iob+0x3>
    155a:	32 d0       	rcall	.+100    	; 0x15c0 <vfprintf>
    155c:	e2 e0       	ldi	r30, 0x02	; 2
    155e:	0a c5       	rjmp	.+2580   	; 0x1f74 <__epilogue_restores__+0x20>

00001560 <puts>:
    1560:	0f 93       	push	r16
    1562:	1f 93       	push	r17
    1564:	cf 93       	push	r28
    1566:	df 93       	push	r29
    1568:	e0 91 69 3e 	lds	r30, 0x3E69	; 0x803e69 <__iob+0x2>
    156c:	f0 91 6a 3e 	lds	r31, 0x3E6A	; 0x803e6a <__iob+0x3>
    1570:	23 81       	ldd	r18, Z+3	; 0x03
    1572:	21 ff       	sbrs	r18, 1
    1574:	1b c0       	rjmp	.+54     	; 0x15ac <puts+0x4c>
    1576:	8c 01       	movw	r16, r24
    1578:	d0 e0       	ldi	r29, 0x00	; 0
    157a:	c0 e0       	ldi	r28, 0x00	; 0
    157c:	f8 01       	movw	r30, r16
    157e:	81 91       	ld	r24, Z+
    1580:	8f 01       	movw	r16, r30
    1582:	60 91 69 3e 	lds	r22, 0x3E69	; 0x803e69 <__iob+0x2>
    1586:	70 91 6a 3e 	lds	r23, 0x3E6A	; 0x803e6a <__iob+0x3>
    158a:	db 01       	movw	r26, r22
    158c:	18 96       	adiw	r26, 0x08	; 8
    158e:	ed 91       	ld	r30, X+
    1590:	fc 91       	ld	r31, X
    1592:	19 97       	sbiw	r26, 0x09	; 9
    1594:	88 23       	and	r24, r24
    1596:	31 f0       	breq	.+12     	; 0x15a4 <puts+0x44>
    1598:	09 95       	icall
    159a:	89 2b       	or	r24, r25
    159c:	79 f3       	breq	.-34     	; 0x157c <puts+0x1c>
    159e:	df ef       	ldi	r29, 0xFF	; 255
    15a0:	cf ef       	ldi	r28, 0xFF	; 255
    15a2:	ec cf       	rjmp	.-40     	; 0x157c <puts+0x1c>
    15a4:	8a e0       	ldi	r24, 0x0A	; 10
    15a6:	09 95       	icall
    15a8:	89 2b       	or	r24, r25
    15aa:	19 f0       	breq	.+6      	; 0x15b2 <puts+0x52>
    15ac:	8f ef       	ldi	r24, 0xFF	; 255
    15ae:	9f ef       	ldi	r25, 0xFF	; 255
    15b0:	02 c0       	rjmp	.+4      	; 0x15b6 <puts+0x56>
    15b2:	8d 2f       	mov	r24, r29
    15b4:	9c 2f       	mov	r25, r28
    15b6:	df 91       	pop	r29
    15b8:	cf 91       	pop	r28
    15ba:	1f 91       	pop	r17
    15bc:	0f 91       	pop	r16
    15be:	08 95       	ret

000015c0 <vfprintf>:
    15c0:	ab e0       	ldi	r26, 0x0B	; 11
    15c2:	b0 e0       	ldi	r27, 0x00	; 0
    15c4:	e5 ee       	ldi	r30, 0xE5	; 229
    15c6:	fa e0       	ldi	r31, 0x0A	; 10
    15c8:	ac c4       	rjmp	.+2392   	; 0x1f22 <__prologue_saves__>
    15ca:	6c 01       	movw	r12, r24
    15cc:	7b 01       	movw	r14, r22
    15ce:	8a 01       	movw	r16, r20
    15d0:	fc 01       	movw	r30, r24
    15d2:	16 82       	std	Z+6, r1	; 0x06
    15d4:	17 82       	std	Z+7, r1	; 0x07
    15d6:	83 81       	ldd	r24, Z+3	; 0x03
    15d8:	81 ff       	sbrs	r24, 1
    15da:	bf c1       	rjmp	.+894    	; 0x195a <vfprintf+0x39a>
    15dc:	ce 01       	movw	r24, r28
    15de:	01 96       	adiw	r24, 0x01	; 1
    15e0:	3c 01       	movw	r6, r24
    15e2:	f6 01       	movw	r30, r12
    15e4:	93 81       	ldd	r25, Z+3	; 0x03
    15e6:	f7 01       	movw	r30, r14
    15e8:	93 fd       	sbrc	r25, 3
    15ea:	85 91       	lpm	r24, Z+
    15ec:	93 ff       	sbrs	r25, 3
    15ee:	81 91       	ld	r24, Z+
    15f0:	7f 01       	movw	r14, r30
    15f2:	88 23       	and	r24, r24
    15f4:	09 f4       	brne	.+2      	; 0x15f8 <vfprintf+0x38>
    15f6:	ad c1       	rjmp	.+858    	; 0x1952 <vfprintf+0x392>
    15f8:	85 32       	cpi	r24, 0x25	; 37
    15fa:	39 f4       	brne	.+14     	; 0x160a <vfprintf+0x4a>
    15fc:	93 fd       	sbrc	r25, 3
    15fe:	85 91       	lpm	r24, Z+
    1600:	93 ff       	sbrs	r25, 3
    1602:	81 91       	ld	r24, Z+
    1604:	7f 01       	movw	r14, r30
    1606:	85 32       	cpi	r24, 0x25	; 37
    1608:	21 f4       	brne	.+8      	; 0x1612 <vfprintf+0x52>
    160a:	b6 01       	movw	r22, r12
    160c:	90 e0       	ldi	r25, 0x00	; 0
    160e:	ef d3       	rcall	.+2014   	; 0x1dee <fputc>
    1610:	e8 cf       	rjmp	.-48     	; 0x15e2 <vfprintf+0x22>
    1612:	91 2c       	mov	r9, r1
    1614:	21 2c       	mov	r2, r1
    1616:	31 2c       	mov	r3, r1
    1618:	ff e1       	ldi	r31, 0x1F	; 31
    161a:	f3 15       	cp	r31, r3
    161c:	d8 f0       	brcs	.+54     	; 0x1654 <vfprintf+0x94>
    161e:	8b 32       	cpi	r24, 0x2B	; 43
    1620:	79 f0       	breq	.+30     	; 0x1640 <vfprintf+0x80>
    1622:	38 f4       	brcc	.+14     	; 0x1632 <vfprintf+0x72>
    1624:	80 32       	cpi	r24, 0x20	; 32
    1626:	79 f0       	breq	.+30     	; 0x1646 <vfprintf+0x86>
    1628:	83 32       	cpi	r24, 0x23	; 35
    162a:	a1 f4       	brne	.+40     	; 0x1654 <vfprintf+0x94>
    162c:	23 2d       	mov	r18, r3
    162e:	20 61       	ori	r18, 0x10	; 16
    1630:	1d c0       	rjmp	.+58     	; 0x166c <vfprintf+0xac>
    1632:	8d 32       	cpi	r24, 0x2D	; 45
    1634:	61 f0       	breq	.+24     	; 0x164e <vfprintf+0x8e>
    1636:	80 33       	cpi	r24, 0x30	; 48
    1638:	69 f4       	brne	.+26     	; 0x1654 <vfprintf+0x94>
    163a:	23 2d       	mov	r18, r3
    163c:	21 60       	ori	r18, 0x01	; 1
    163e:	16 c0       	rjmp	.+44     	; 0x166c <vfprintf+0xac>
    1640:	83 2d       	mov	r24, r3
    1642:	82 60       	ori	r24, 0x02	; 2
    1644:	38 2e       	mov	r3, r24
    1646:	e3 2d       	mov	r30, r3
    1648:	e4 60       	ori	r30, 0x04	; 4
    164a:	3e 2e       	mov	r3, r30
    164c:	2a c0       	rjmp	.+84     	; 0x16a2 <vfprintf+0xe2>
    164e:	f3 2d       	mov	r31, r3
    1650:	f8 60       	ori	r31, 0x08	; 8
    1652:	1d c0       	rjmp	.+58     	; 0x168e <vfprintf+0xce>
    1654:	37 fc       	sbrc	r3, 7
    1656:	2d c0       	rjmp	.+90     	; 0x16b2 <vfprintf+0xf2>
    1658:	20 ed       	ldi	r18, 0xD0	; 208
    165a:	28 0f       	add	r18, r24
    165c:	2a 30       	cpi	r18, 0x0A	; 10
    165e:	40 f0       	brcs	.+16     	; 0x1670 <vfprintf+0xb0>
    1660:	8e 32       	cpi	r24, 0x2E	; 46
    1662:	b9 f4       	brne	.+46     	; 0x1692 <vfprintf+0xd2>
    1664:	36 fc       	sbrc	r3, 6
    1666:	75 c1       	rjmp	.+746    	; 0x1952 <vfprintf+0x392>
    1668:	23 2d       	mov	r18, r3
    166a:	20 64       	ori	r18, 0x40	; 64
    166c:	32 2e       	mov	r3, r18
    166e:	19 c0       	rjmp	.+50     	; 0x16a2 <vfprintf+0xe2>
    1670:	36 fe       	sbrs	r3, 6
    1672:	06 c0       	rjmp	.+12     	; 0x1680 <vfprintf+0xc0>
    1674:	8a e0       	ldi	r24, 0x0A	; 10
    1676:	98 9e       	mul	r9, r24
    1678:	20 0d       	add	r18, r0
    167a:	11 24       	eor	r1, r1
    167c:	92 2e       	mov	r9, r18
    167e:	11 c0       	rjmp	.+34     	; 0x16a2 <vfprintf+0xe2>
    1680:	ea e0       	ldi	r30, 0x0A	; 10
    1682:	2e 9e       	mul	r2, r30
    1684:	20 0d       	add	r18, r0
    1686:	11 24       	eor	r1, r1
    1688:	22 2e       	mov	r2, r18
    168a:	f3 2d       	mov	r31, r3
    168c:	f0 62       	ori	r31, 0x20	; 32
    168e:	3f 2e       	mov	r3, r31
    1690:	08 c0       	rjmp	.+16     	; 0x16a2 <vfprintf+0xe2>
    1692:	8c 36       	cpi	r24, 0x6C	; 108
    1694:	21 f4       	brne	.+8      	; 0x169e <vfprintf+0xde>
    1696:	83 2d       	mov	r24, r3
    1698:	80 68       	ori	r24, 0x80	; 128
    169a:	38 2e       	mov	r3, r24
    169c:	02 c0       	rjmp	.+4      	; 0x16a2 <vfprintf+0xe2>
    169e:	88 36       	cpi	r24, 0x68	; 104
    16a0:	41 f4       	brne	.+16     	; 0x16b2 <vfprintf+0xf2>
    16a2:	f7 01       	movw	r30, r14
    16a4:	93 fd       	sbrc	r25, 3
    16a6:	85 91       	lpm	r24, Z+
    16a8:	93 ff       	sbrs	r25, 3
    16aa:	81 91       	ld	r24, Z+
    16ac:	7f 01       	movw	r14, r30
    16ae:	81 11       	cpse	r24, r1
    16b0:	b3 cf       	rjmp	.-154    	; 0x1618 <vfprintf+0x58>
    16b2:	98 2f       	mov	r25, r24
    16b4:	9f 7d       	andi	r25, 0xDF	; 223
    16b6:	95 54       	subi	r25, 0x45	; 69
    16b8:	93 30       	cpi	r25, 0x03	; 3
    16ba:	28 f4       	brcc	.+10     	; 0x16c6 <vfprintf+0x106>
    16bc:	0c 5f       	subi	r16, 0xFC	; 252
    16be:	1f 4f       	sbci	r17, 0xFF	; 255
    16c0:	9f e3       	ldi	r25, 0x3F	; 63
    16c2:	99 83       	std	Y+1, r25	; 0x01
    16c4:	0d c0       	rjmp	.+26     	; 0x16e0 <vfprintf+0x120>
    16c6:	83 36       	cpi	r24, 0x63	; 99
    16c8:	31 f0       	breq	.+12     	; 0x16d6 <vfprintf+0x116>
    16ca:	83 37       	cpi	r24, 0x73	; 115
    16cc:	71 f0       	breq	.+28     	; 0x16ea <vfprintf+0x12a>
    16ce:	83 35       	cpi	r24, 0x53	; 83
    16d0:	09 f0       	breq	.+2      	; 0x16d4 <vfprintf+0x114>
    16d2:	55 c0       	rjmp	.+170    	; 0x177e <vfprintf+0x1be>
    16d4:	20 c0       	rjmp	.+64     	; 0x1716 <vfprintf+0x156>
    16d6:	f8 01       	movw	r30, r16
    16d8:	80 81       	ld	r24, Z
    16da:	89 83       	std	Y+1, r24	; 0x01
    16dc:	0e 5f       	subi	r16, 0xFE	; 254
    16de:	1f 4f       	sbci	r17, 0xFF	; 255
    16e0:	88 24       	eor	r8, r8
    16e2:	83 94       	inc	r8
    16e4:	91 2c       	mov	r9, r1
    16e6:	53 01       	movw	r10, r6
    16e8:	12 c0       	rjmp	.+36     	; 0x170e <vfprintf+0x14e>
    16ea:	28 01       	movw	r4, r16
    16ec:	f2 e0       	ldi	r31, 0x02	; 2
    16ee:	4f 0e       	add	r4, r31
    16f0:	51 1c       	adc	r5, r1
    16f2:	f8 01       	movw	r30, r16
    16f4:	a0 80       	ld	r10, Z
    16f6:	b1 80       	ldd	r11, Z+1	; 0x01
    16f8:	36 fe       	sbrs	r3, 6
    16fa:	03 c0       	rjmp	.+6      	; 0x1702 <vfprintf+0x142>
    16fc:	69 2d       	mov	r22, r9
    16fe:	70 e0       	ldi	r23, 0x00	; 0
    1700:	02 c0       	rjmp	.+4      	; 0x1706 <vfprintf+0x146>
    1702:	6f ef       	ldi	r22, 0xFF	; 255
    1704:	7f ef       	ldi	r23, 0xFF	; 255
    1706:	c5 01       	movw	r24, r10
    1708:	67 d3       	rcall	.+1742   	; 0x1dd8 <strnlen>
    170a:	4c 01       	movw	r8, r24
    170c:	82 01       	movw	r16, r4
    170e:	f3 2d       	mov	r31, r3
    1710:	ff 77       	andi	r31, 0x7F	; 127
    1712:	3f 2e       	mov	r3, r31
    1714:	15 c0       	rjmp	.+42     	; 0x1740 <vfprintf+0x180>
    1716:	28 01       	movw	r4, r16
    1718:	22 e0       	ldi	r18, 0x02	; 2
    171a:	42 0e       	add	r4, r18
    171c:	51 1c       	adc	r5, r1
    171e:	f8 01       	movw	r30, r16
    1720:	a0 80       	ld	r10, Z
    1722:	b1 80       	ldd	r11, Z+1	; 0x01
    1724:	36 fe       	sbrs	r3, 6
    1726:	03 c0       	rjmp	.+6      	; 0x172e <vfprintf+0x16e>
    1728:	69 2d       	mov	r22, r9
    172a:	70 e0       	ldi	r23, 0x00	; 0
    172c:	02 c0       	rjmp	.+4      	; 0x1732 <vfprintf+0x172>
    172e:	6f ef       	ldi	r22, 0xFF	; 255
    1730:	7f ef       	ldi	r23, 0xFF	; 255
    1732:	c5 01       	movw	r24, r10
    1734:	46 d3       	rcall	.+1676   	; 0x1dc2 <strnlen_P>
    1736:	4c 01       	movw	r8, r24
    1738:	f3 2d       	mov	r31, r3
    173a:	f0 68       	ori	r31, 0x80	; 128
    173c:	3f 2e       	mov	r3, r31
    173e:	82 01       	movw	r16, r4
    1740:	33 fc       	sbrc	r3, 3
    1742:	19 c0       	rjmp	.+50     	; 0x1776 <vfprintf+0x1b6>
    1744:	82 2d       	mov	r24, r2
    1746:	90 e0       	ldi	r25, 0x00	; 0
    1748:	88 16       	cp	r8, r24
    174a:	99 06       	cpc	r9, r25
    174c:	a0 f4       	brcc	.+40     	; 0x1776 <vfprintf+0x1b6>
    174e:	b6 01       	movw	r22, r12
    1750:	80 e2       	ldi	r24, 0x20	; 32
    1752:	90 e0       	ldi	r25, 0x00	; 0
    1754:	4c d3       	rcall	.+1688   	; 0x1dee <fputc>
    1756:	2a 94       	dec	r2
    1758:	f5 cf       	rjmp	.-22     	; 0x1744 <vfprintf+0x184>
    175a:	f5 01       	movw	r30, r10
    175c:	37 fc       	sbrc	r3, 7
    175e:	85 91       	lpm	r24, Z+
    1760:	37 fe       	sbrs	r3, 7
    1762:	81 91       	ld	r24, Z+
    1764:	5f 01       	movw	r10, r30
    1766:	b6 01       	movw	r22, r12
    1768:	90 e0       	ldi	r25, 0x00	; 0
    176a:	41 d3       	rcall	.+1666   	; 0x1dee <fputc>
    176c:	21 10       	cpse	r2, r1
    176e:	2a 94       	dec	r2
    1770:	21 e0       	ldi	r18, 0x01	; 1
    1772:	82 1a       	sub	r8, r18
    1774:	91 08       	sbc	r9, r1
    1776:	81 14       	cp	r8, r1
    1778:	91 04       	cpc	r9, r1
    177a:	79 f7       	brne	.-34     	; 0x175a <vfprintf+0x19a>
    177c:	e1 c0       	rjmp	.+450    	; 0x1940 <vfprintf+0x380>
    177e:	84 36       	cpi	r24, 0x64	; 100
    1780:	11 f0       	breq	.+4      	; 0x1786 <vfprintf+0x1c6>
    1782:	89 36       	cpi	r24, 0x69	; 105
    1784:	39 f5       	brne	.+78     	; 0x17d4 <vfprintf+0x214>
    1786:	f8 01       	movw	r30, r16
    1788:	37 fe       	sbrs	r3, 7
    178a:	07 c0       	rjmp	.+14     	; 0x179a <vfprintf+0x1da>
    178c:	60 81       	ld	r22, Z
    178e:	71 81       	ldd	r23, Z+1	; 0x01
    1790:	82 81       	ldd	r24, Z+2	; 0x02
    1792:	93 81       	ldd	r25, Z+3	; 0x03
    1794:	0c 5f       	subi	r16, 0xFC	; 252
    1796:	1f 4f       	sbci	r17, 0xFF	; 255
    1798:	08 c0       	rjmp	.+16     	; 0x17aa <vfprintf+0x1ea>
    179a:	60 81       	ld	r22, Z
    179c:	71 81       	ldd	r23, Z+1	; 0x01
    179e:	07 2e       	mov	r0, r23
    17a0:	00 0c       	add	r0, r0
    17a2:	88 0b       	sbc	r24, r24
    17a4:	99 0b       	sbc	r25, r25
    17a6:	0e 5f       	subi	r16, 0xFE	; 254
    17a8:	1f 4f       	sbci	r17, 0xFF	; 255
    17aa:	f3 2d       	mov	r31, r3
    17ac:	ff 76       	andi	r31, 0x6F	; 111
    17ae:	3f 2e       	mov	r3, r31
    17b0:	97 ff       	sbrs	r25, 7
    17b2:	09 c0       	rjmp	.+18     	; 0x17c6 <vfprintf+0x206>
    17b4:	90 95       	com	r25
    17b6:	80 95       	com	r24
    17b8:	70 95       	com	r23
    17ba:	61 95       	neg	r22
    17bc:	7f 4f       	sbci	r23, 0xFF	; 255
    17be:	8f 4f       	sbci	r24, 0xFF	; 255
    17c0:	9f 4f       	sbci	r25, 0xFF	; 255
    17c2:	f0 68       	ori	r31, 0x80	; 128
    17c4:	3f 2e       	mov	r3, r31
    17c6:	2a e0       	ldi	r18, 0x0A	; 10
    17c8:	30 e0       	ldi	r19, 0x00	; 0
    17ca:	a3 01       	movw	r20, r6
    17cc:	4c d3       	rcall	.+1688   	; 0x1e66 <__ultoa_invert>
    17ce:	88 2e       	mov	r8, r24
    17d0:	86 18       	sub	r8, r6
    17d2:	44 c0       	rjmp	.+136    	; 0x185c <vfprintf+0x29c>
    17d4:	85 37       	cpi	r24, 0x75	; 117
    17d6:	31 f4       	brne	.+12     	; 0x17e4 <vfprintf+0x224>
    17d8:	23 2d       	mov	r18, r3
    17da:	2f 7e       	andi	r18, 0xEF	; 239
    17dc:	b2 2e       	mov	r11, r18
    17de:	2a e0       	ldi	r18, 0x0A	; 10
    17e0:	30 e0       	ldi	r19, 0x00	; 0
    17e2:	25 c0       	rjmp	.+74     	; 0x182e <vfprintf+0x26e>
    17e4:	93 2d       	mov	r25, r3
    17e6:	99 7f       	andi	r25, 0xF9	; 249
    17e8:	b9 2e       	mov	r11, r25
    17ea:	8f 36       	cpi	r24, 0x6F	; 111
    17ec:	c1 f0       	breq	.+48     	; 0x181e <vfprintf+0x25e>
    17ee:	18 f4       	brcc	.+6      	; 0x17f6 <vfprintf+0x236>
    17f0:	88 35       	cpi	r24, 0x58	; 88
    17f2:	79 f0       	breq	.+30     	; 0x1812 <vfprintf+0x252>
    17f4:	ae c0       	rjmp	.+348    	; 0x1952 <vfprintf+0x392>
    17f6:	80 37       	cpi	r24, 0x70	; 112
    17f8:	19 f0       	breq	.+6      	; 0x1800 <vfprintf+0x240>
    17fa:	88 37       	cpi	r24, 0x78	; 120
    17fc:	21 f0       	breq	.+8      	; 0x1806 <vfprintf+0x246>
    17fe:	a9 c0       	rjmp	.+338    	; 0x1952 <vfprintf+0x392>
    1800:	e9 2f       	mov	r30, r25
    1802:	e0 61       	ori	r30, 0x10	; 16
    1804:	be 2e       	mov	r11, r30
    1806:	b4 fe       	sbrs	r11, 4
    1808:	0d c0       	rjmp	.+26     	; 0x1824 <vfprintf+0x264>
    180a:	fb 2d       	mov	r31, r11
    180c:	f4 60       	ori	r31, 0x04	; 4
    180e:	bf 2e       	mov	r11, r31
    1810:	09 c0       	rjmp	.+18     	; 0x1824 <vfprintf+0x264>
    1812:	34 fe       	sbrs	r3, 4
    1814:	0a c0       	rjmp	.+20     	; 0x182a <vfprintf+0x26a>
    1816:	29 2f       	mov	r18, r25
    1818:	26 60       	ori	r18, 0x06	; 6
    181a:	b2 2e       	mov	r11, r18
    181c:	06 c0       	rjmp	.+12     	; 0x182a <vfprintf+0x26a>
    181e:	28 e0       	ldi	r18, 0x08	; 8
    1820:	30 e0       	ldi	r19, 0x00	; 0
    1822:	05 c0       	rjmp	.+10     	; 0x182e <vfprintf+0x26e>
    1824:	20 e1       	ldi	r18, 0x10	; 16
    1826:	30 e0       	ldi	r19, 0x00	; 0
    1828:	02 c0       	rjmp	.+4      	; 0x182e <vfprintf+0x26e>
    182a:	20 e1       	ldi	r18, 0x10	; 16
    182c:	32 e0       	ldi	r19, 0x02	; 2
    182e:	f8 01       	movw	r30, r16
    1830:	b7 fe       	sbrs	r11, 7
    1832:	07 c0       	rjmp	.+14     	; 0x1842 <vfprintf+0x282>
    1834:	60 81       	ld	r22, Z
    1836:	71 81       	ldd	r23, Z+1	; 0x01
    1838:	82 81       	ldd	r24, Z+2	; 0x02
    183a:	93 81       	ldd	r25, Z+3	; 0x03
    183c:	0c 5f       	subi	r16, 0xFC	; 252
    183e:	1f 4f       	sbci	r17, 0xFF	; 255
    1840:	06 c0       	rjmp	.+12     	; 0x184e <vfprintf+0x28e>
    1842:	60 81       	ld	r22, Z
    1844:	71 81       	ldd	r23, Z+1	; 0x01
    1846:	80 e0       	ldi	r24, 0x00	; 0
    1848:	90 e0       	ldi	r25, 0x00	; 0
    184a:	0e 5f       	subi	r16, 0xFE	; 254
    184c:	1f 4f       	sbci	r17, 0xFF	; 255
    184e:	a3 01       	movw	r20, r6
    1850:	0a d3       	rcall	.+1556   	; 0x1e66 <__ultoa_invert>
    1852:	88 2e       	mov	r8, r24
    1854:	86 18       	sub	r8, r6
    1856:	fb 2d       	mov	r31, r11
    1858:	ff 77       	andi	r31, 0x7F	; 127
    185a:	3f 2e       	mov	r3, r31
    185c:	36 fe       	sbrs	r3, 6
    185e:	0d c0       	rjmp	.+26     	; 0x187a <vfprintf+0x2ba>
    1860:	23 2d       	mov	r18, r3
    1862:	2e 7f       	andi	r18, 0xFE	; 254
    1864:	a2 2e       	mov	r10, r18
    1866:	89 14       	cp	r8, r9
    1868:	58 f4       	brcc	.+22     	; 0x1880 <vfprintf+0x2c0>
    186a:	34 fe       	sbrs	r3, 4
    186c:	0b c0       	rjmp	.+22     	; 0x1884 <vfprintf+0x2c4>
    186e:	32 fc       	sbrc	r3, 2
    1870:	09 c0       	rjmp	.+18     	; 0x1884 <vfprintf+0x2c4>
    1872:	83 2d       	mov	r24, r3
    1874:	8e 7e       	andi	r24, 0xEE	; 238
    1876:	a8 2e       	mov	r10, r24
    1878:	05 c0       	rjmp	.+10     	; 0x1884 <vfprintf+0x2c4>
    187a:	b8 2c       	mov	r11, r8
    187c:	a3 2c       	mov	r10, r3
    187e:	03 c0       	rjmp	.+6      	; 0x1886 <vfprintf+0x2c6>
    1880:	b8 2c       	mov	r11, r8
    1882:	01 c0       	rjmp	.+2      	; 0x1886 <vfprintf+0x2c6>
    1884:	b9 2c       	mov	r11, r9
    1886:	a4 fe       	sbrs	r10, 4
    1888:	0f c0       	rjmp	.+30     	; 0x18a8 <vfprintf+0x2e8>
    188a:	fe 01       	movw	r30, r28
    188c:	e8 0d       	add	r30, r8
    188e:	f1 1d       	adc	r31, r1
    1890:	80 81       	ld	r24, Z
    1892:	80 33       	cpi	r24, 0x30	; 48
    1894:	21 f4       	brne	.+8      	; 0x189e <vfprintf+0x2de>
    1896:	9a 2d       	mov	r25, r10
    1898:	99 7e       	andi	r25, 0xE9	; 233
    189a:	a9 2e       	mov	r10, r25
    189c:	09 c0       	rjmp	.+18     	; 0x18b0 <vfprintf+0x2f0>
    189e:	a2 fe       	sbrs	r10, 2
    18a0:	06 c0       	rjmp	.+12     	; 0x18ae <vfprintf+0x2ee>
    18a2:	b3 94       	inc	r11
    18a4:	b3 94       	inc	r11
    18a6:	04 c0       	rjmp	.+8      	; 0x18b0 <vfprintf+0x2f0>
    18a8:	8a 2d       	mov	r24, r10
    18aa:	86 78       	andi	r24, 0x86	; 134
    18ac:	09 f0       	breq	.+2      	; 0x18b0 <vfprintf+0x2f0>
    18ae:	b3 94       	inc	r11
    18b0:	a3 fc       	sbrc	r10, 3
    18b2:	10 c0       	rjmp	.+32     	; 0x18d4 <vfprintf+0x314>
    18b4:	a0 fe       	sbrs	r10, 0
    18b6:	06 c0       	rjmp	.+12     	; 0x18c4 <vfprintf+0x304>
    18b8:	b2 14       	cp	r11, r2
    18ba:	80 f4       	brcc	.+32     	; 0x18dc <vfprintf+0x31c>
    18bc:	28 0c       	add	r2, r8
    18be:	92 2c       	mov	r9, r2
    18c0:	9b 18       	sub	r9, r11
    18c2:	0d c0       	rjmp	.+26     	; 0x18de <vfprintf+0x31e>
    18c4:	b2 14       	cp	r11, r2
    18c6:	58 f4       	brcc	.+22     	; 0x18de <vfprintf+0x31e>
    18c8:	b6 01       	movw	r22, r12
    18ca:	80 e2       	ldi	r24, 0x20	; 32
    18cc:	90 e0       	ldi	r25, 0x00	; 0
    18ce:	8f d2       	rcall	.+1310   	; 0x1dee <fputc>
    18d0:	b3 94       	inc	r11
    18d2:	f8 cf       	rjmp	.-16     	; 0x18c4 <vfprintf+0x304>
    18d4:	b2 14       	cp	r11, r2
    18d6:	18 f4       	brcc	.+6      	; 0x18de <vfprintf+0x31e>
    18d8:	2b 18       	sub	r2, r11
    18da:	02 c0       	rjmp	.+4      	; 0x18e0 <vfprintf+0x320>
    18dc:	98 2c       	mov	r9, r8
    18de:	21 2c       	mov	r2, r1
    18e0:	a4 fe       	sbrs	r10, 4
    18e2:	0f c0       	rjmp	.+30     	; 0x1902 <vfprintf+0x342>
    18e4:	b6 01       	movw	r22, r12
    18e6:	80 e3       	ldi	r24, 0x30	; 48
    18e8:	90 e0       	ldi	r25, 0x00	; 0
    18ea:	81 d2       	rcall	.+1282   	; 0x1dee <fputc>
    18ec:	a2 fe       	sbrs	r10, 2
    18ee:	16 c0       	rjmp	.+44     	; 0x191c <vfprintf+0x35c>
    18f0:	a1 fc       	sbrc	r10, 1
    18f2:	03 c0       	rjmp	.+6      	; 0x18fa <vfprintf+0x33a>
    18f4:	88 e7       	ldi	r24, 0x78	; 120
    18f6:	90 e0       	ldi	r25, 0x00	; 0
    18f8:	02 c0       	rjmp	.+4      	; 0x18fe <vfprintf+0x33e>
    18fa:	88 e5       	ldi	r24, 0x58	; 88
    18fc:	90 e0       	ldi	r25, 0x00	; 0
    18fe:	b6 01       	movw	r22, r12
    1900:	0c c0       	rjmp	.+24     	; 0x191a <vfprintf+0x35a>
    1902:	8a 2d       	mov	r24, r10
    1904:	86 78       	andi	r24, 0x86	; 134
    1906:	51 f0       	breq	.+20     	; 0x191c <vfprintf+0x35c>
    1908:	a1 fe       	sbrs	r10, 1
    190a:	02 c0       	rjmp	.+4      	; 0x1910 <vfprintf+0x350>
    190c:	8b e2       	ldi	r24, 0x2B	; 43
    190e:	01 c0       	rjmp	.+2      	; 0x1912 <vfprintf+0x352>
    1910:	80 e2       	ldi	r24, 0x20	; 32
    1912:	a7 fc       	sbrc	r10, 7
    1914:	8d e2       	ldi	r24, 0x2D	; 45
    1916:	b6 01       	movw	r22, r12
    1918:	90 e0       	ldi	r25, 0x00	; 0
    191a:	69 d2       	rcall	.+1234   	; 0x1dee <fputc>
    191c:	89 14       	cp	r8, r9
    191e:	30 f4       	brcc	.+12     	; 0x192c <vfprintf+0x36c>
    1920:	b6 01       	movw	r22, r12
    1922:	80 e3       	ldi	r24, 0x30	; 48
    1924:	90 e0       	ldi	r25, 0x00	; 0
    1926:	63 d2       	rcall	.+1222   	; 0x1dee <fputc>
    1928:	9a 94       	dec	r9
    192a:	f8 cf       	rjmp	.-16     	; 0x191c <vfprintf+0x35c>
    192c:	8a 94       	dec	r8
    192e:	f3 01       	movw	r30, r6
    1930:	e8 0d       	add	r30, r8
    1932:	f1 1d       	adc	r31, r1
    1934:	80 81       	ld	r24, Z
    1936:	b6 01       	movw	r22, r12
    1938:	90 e0       	ldi	r25, 0x00	; 0
    193a:	59 d2       	rcall	.+1202   	; 0x1dee <fputc>
    193c:	81 10       	cpse	r8, r1
    193e:	f6 cf       	rjmp	.-20     	; 0x192c <vfprintf+0x36c>
    1940:	22 20       	and	r2, r2
    1942:	09 f4       	brne	.+2      	; 0x1946 <vfprintf+0x386>
    1944:	4e ce       	rjmp	.-868    	; 0x15e2 <vfprintf+0x22>
    1946:	b6 01       	movw	r22, r12
    1948:	80 e2       	ldi	r24, 0x20	; 32
    194a:	90 e0       	ldi	r25, 0x00	; 0
    194c:	50 d2       	rcall	.+1184   	; 0x1dee <fputc>
    194e:	2a 94       	dec	r2
    1950:	f7 cf       	rjmp	.-18     	; 0x1940 <vfprintf+0x380>
    1952:	f6 01       	movw	r30, r12
    1954:	86 81       	ldd	r24, Z+6	; 0x06
    1956:	97 81       	ldd	r25, Z+7	; 0x07
    1958:	02 c0       	rjmp	.+4      	; 0x195e <vfprintf+0x39e>
    195a:	8f ef       	ldi	r24, 0xFF	; 255
    195c:	9f ef       	ldi	r25, 0xFF	; 255
    195e:	2b 96       	adiw	r28, 0x0b	; 11
    1960:	e2 e1       	ldi	r30, 0x12	; 18
    1962:	f8 c2       	rjmp	.+1520   	; 0x1f54 <__epilogue_restores__>

00001964 <dtoa_prf>:
    1964:	a9 e0       	ldi	r26, 0x09	; 9
    1966:	b0 e0       	ldi	r27, 0x00	; 0
    1968:	e7 eb       	ldi	r30, 0xB7	; 183
    196a:	fc e0       	ldi	r31, 0x0C	; 12
    196c:	e0 c2       	rjmp	.+1472   	; 0x1f2e <__prologue_saves__+0xc>
    196e:	6a 01       	movw	r12, r20
    1970:	12 2f       	mov	r17, r18
    1972:	b0 2e       	mov	r11, r16
    1974:	2b e3       	ldi	r18, 0x3B	; 59
    1976:	20 17       	cp	r18, r16
    1978:	20 f0       	brcs	.+8      	; 0x1982 <dtoa_prf+0x1e>
    197a:	ff 24       	eor	r15, r15
    197c:	f3 94       	inc	r15
    197e:	f0 0e       	add	r15, r16
    1980:	02 c0       	rjmp	.+4      	; 0x1986 <dtoa_prf+0x22>
    1982:	2c e3       	ldi	r18, 0x3C	; 60
    1984:	f2 2e       	mov	r15, r18
    1986:	0f 2d       	mov	r16, r15
    1988:	27 e0       	ldi	r18, 0x07	; 7
    198a:	ae 01       	movw	r20, r28
    198c:	4f 5f       	subi	r20, 0xFF	; 255
    198e:	5f 4f       	sbci	r21, 0xFF	; 255
    1990:	40 d1       	rcall	.+640    	; 0x1c12 <__ftoa_engine>
    1992:	bc 01       	movw	r22, r24
    1994:	49 81       	ldd	r20, Y+1	; 0x01
    1996:	84 2f       	mov	r24, r20
    1998:	89 70       	andi	r24, 0x09	; 9
    199a:	81 30       	cpi	r24, 0x01	; 1
    199c:	31 f0       	breq	.+12     	; 0x19aa <dtoa_prf+0x46>
    199e:	e1 fc       	sbrc	r14, 1
    19a0:	06 c0       	rjmp	.+12     	; 0x19ae <dtoa_prf+0x4a>
    19a2:	e0 fe       	sbrs	r14, 0
    19a4:	06 c0       	rjmp	.+12     	; 0x19b2 <dtoa_prf+0x4e>
    19a6:	90 e2       	ldi	r25, 0x20	; 32
    19a8:	05 c0       	rjmp	.+10     	; 0x19b4 <dtoa_prf+0x50>
    19aa:	9d e2       	ldi	r25, 0x2D	; 45
    19ac:	03 c0       	rjmp	.+6      	; 0x19b4 <dtoa_prf+0x50>
    19ae:	9b e2       	ldi	r25, 0x2B	; 43
    19b0:	01 c0       	rjmp	.+2      	; 0x19b4 <dtoa_prf+0x50>
    19b2:	90 e0       	ldi	r25, 0x00	; 0
    19b4:	5e 2d       	mov	r21, r14
    19b6:	50 71       	andi	r21, 0x10	; 16
    19b8:	43 ff       	sbrs	r20, 3
    19ba:	3c c0       	rjmp	.+120    	; 0x1a34 <dtoa_prf+0xd0>
    19bc:	91 11       	cpse	r25, r1
    19be:	02 c0       	rjmp	.+4      	; 0x19c4 <dtoa_prf+0x60>
    19c0:	83 e0       	ldi	r24, 0x03	; 3
    19c2:	01 c0       	rjmp	.+2      	; 0x19c6 <dtoa_prf+0x62>
    19c4:	84 e0       	ldi	r24, 0x04	; 4
    19c6:	81 17       	cp	r24, r17
    19c8:	18 f4       	brcc	.+6      	; 0x19d0 <dtoa_prf+0x6c>
    19ca:	21 2f       	mov	r18, r17
    19cc:	28 1b       	sub	r18, r24
    19ce:	01 c0       	rjmp	.+2      	; 0x19d2 <dtoa_prf+0x6e>
    19d0:	20 e0       	ldi	r18, 0x00	; 0
    19d2:	51 11       	cpse	r21, r1
    19d4:	0b c0       	rjmp	.+22     	; 0x19ec <dtoa_prf+0x88>
    19d6:	f6 01       	movw	r30, r12
    19d8:	82 2f       	mov	r24, r18
    19da:	30 e2       	ldi	r19, 0x20	; 32
    19dc:	88 23       	and	r24, r24
    19de:	19 f0       	breq	.+6      	; 0x19e6 <dtoa_prf+0x82>
    19e0:	31 93       	st	Z+, r19
    19e2:	81 50       	subi	r24, 0x01	; 1
    19e4:	fb cf       	rjmp	.-10     	; 0x19dc <dtoa_prf+0x78>
    19e6:	c2 0e       	add	r12, r18
    19e8:	d1 1c       	adc	r13, r1
    19ea:	20 e0       	ldi	r18, 0x00	; 0
    19ec:	99 23       	and	r25, r25
    19ee:	29 f0       	breq	.+10     	; 0x19fa <dtoa_prf+0x96>
    19f0:	d6 01       	movw	r26, r12
    19f2:	9c 93       	st	X, r25
    19f4:	f6 01       	movw	r30, r12
    19f6:	31 96       	adiw	r30, 0x01	; 1
    19f8:	6f 01       	movw	r12, r30
    19fa:	c6 01       	movw	r24, r12
    19fc:	03 96       	adiw	r24, 0x03	; 3
    19fe:	e2 fe       	sbrs	r14, 2
    1a00:	0a c0       	rjmp	.+20     	; 0x1a16 <dtoa_prf+0xb2>
    1a02:	3e e4       	ldi	r19, 0x4E	; 78
    1a04:	d6 01       	movw	r26, r12
    1a06:	3c 93       	st	X, r19
    1a08:	41 e4       	ldi	r20, 0x41	; 65
    1a0a:	11 96       	adiw	r26, 0x01	; 1
    1a0c:	4c 93       	st	X, r20
    1a0e:	11 97       	sbiw	r26, 0x01	; 1
    1a10:	12 96       	adiw	r26, 0x02	; 2
    1a12:	3c 93       	st	X, r19
    1a14:	06 c0       	rjmp	.+12     	; 0x1a22 <dtoa_prf+0xbe>
    1a16:	3e e6       	ldi	r19, 0x6E	; 110
    1a18:	f6 01       	movw	r30, r12
    1a1a:	30 83       	st	Z, r19
    1a1c:	41 e6       	ldi	r20, 0x61	; 97
    1a1e:	41 83       	std	Z+1, r20	; 0x01
    1a20:	32 83       	std	Z+2, r19	; 0x02
    1a22:	fc 01       	movw	r30, r24
    1a24:	32 2f       	mov	r19, r18
    1a26:	40 e2       	ldi	r20, 0x20	; 32
    1a28:	33 23       	and	r19, r19
    1a2a:	09 f4       	brne	.+2      	; 0x1a2e <dtoa_prf+0xca>
    1a2c:	42 c0       	rjmp	.+132    	; 0x1ab2 <dtoa_prf+0x14e>
    1a2e:	41 93       	st	Z+, r20
    1a30:	31 50       	subi	r19, 0x01	; 1
    1a32:	fa cf       	rjmp	.-12     	; 0x1a28 <dtoa_prf+0xc4>
    1a34:	42 ff       	sbrs	r20, 2
    1a36:	44 c0       	rjmp	.+136    	; 0x1ac0 <dtoa_prf+0x15c>
    1a38:	91 11       	cpse	r25, r1
    1a3a:	02 c0       	rjmp	.+4      	; 0x1a40 <dtoa_prf+0xdc>
    1a3c:	83 e0       	ldi	r24, 0x03	; 3
    1a3e:	01 c0       	rjmp	.+2      	; 0x1a42 <dtoa_prf+0xde>
    1a40:	84 e0       	ldi	r24, 0x04	; 4
    1a42:	81 17       	cp	r24, r17
    1a44:	18 f4       	brcc	.+6      	; 0x1a4c <dtoa_prf+0xe8>
    1a46:	21 2f       	mov	r18, r17
    1a48:	28 1b       	sub	r18, r24
    1a4a:	01 c0       	rjmp	.+2      	; 0x1a4e <dtoa_prf+0xea>
    1a4c:	20 e0       	ldi	r18, 0x00	; 0
    1a4e:	51 11       	cpse	r21, r1
    1a50:	0b c0       	rjmp	.+22     	; 0x1a68 <dtoa_prf+0x104>
    1a52:	f6 01       	movw	r30, r12
    1a54:	82 2f       	mov	r24, r18
    1a56:	30 e2       	ldi	r19, 0x20	; 32
    1a58:	88 23       	and	r24, r24
    1a5a:	19 f0       	breq	.+6      	; 0x1a62 <dtoa_prf+0xfe>
    1a5c:	31 93       	st	Z+, r19
    1a5e:	81 50       	subi	r24, 0x01	; 1
    1a60:	fb cf       	rjmp	.-10     	; 0x1a58 <dtoa_prf+0xf4>
    1a62:	c2 0e       	add	r12, r18
    1a64:	d1 1c       	adc	r13, r1
    1a66:	20 e0       	ldi	r18, 0x00	; 0
    1a68:	99 23       	and	r25, r25
    1a6a:	29 f0       	breq	.+10     	; 0x1a76 <dtoa_prf+0x112>
    1a6c:	d6 01       	movw	r26, r12
    1a6e:	9c 93       	st	X, r25
    1a70:	f6 01       	movw	r30, r12
    1a72:	31 96       	adiw	r30, 0x01	; 1
    1a74:	6f 01       	movw	r12, r30
    1a76:	c6 01       	movw	r24, r12
    1a78:	03 96       	adiw	r24, 0x03	; 3
    1a7a:	e2 fe       	sbrs	r14, 2
    1a7c:	0b c0       	rjmp	.+22     	; 0x1a94 <dtoa_prf+0x130>
    1a7e:	39 e4       	ldi	r19, 0x49	; 73
    1a80:	d6 01       	movw	r26, r12
    1a82:	3c 93       	st	X, r19
    1a84:	3e e4       	ldi	r19, 0x4E	; 78
    1a86:	11 96       	adiw	r26, 0x01	; 1
    1a88:	3c 93       	st	X, r19
    1a8a:	11 97       	sbiw	r26, 0x01	; 1
    1a8c:	36 e4       	ldi	r19, 0x46	; 70
    1a8e:	12 96       	adiw	r26, 0x02	; 2
    1a90:	3c 93       	st	X, r19
    1a92:	07 c0       	rjmp	.+14     	; 0x1aa2 <dtoa_prf+0x13e>
    1a94:	39 e6       	ldi	r19, 0x69	; 105
    1a96:	f6 01       	movw	r30, r12
    1a98:	30 83       	st	Z, r19
    1a9a:	3e e6       	ldi	r19, 0x6E	; 110
    1a9c:	31 83       	std	Z+1, r19	; 0x01
    1a9e:	36 e6       	ldi	r19, 0x66	; 102
    1aa0:	32 83       	std	Z+2, r19	; 0x02
    1aa2:	fc 01       	movw	r30, r24
    1aa4:	32 2f       	mov	r19, r18
    1aa6:	40 e2       	ldi	r20, 0x20	; 32
    1aa8:	33 23       	and	r19, r19
    1aaa:	19 f0       	breq	.+6      	; 0x1ab2 <dtoa_prf+0x14e>
    1aac:	41 93       	st	Z+, r20
    1aae:	31 50       	subi	r19, 0x01	; 1
    1ab0:	fb cf       	rjmp	.-10     	; 0x1aa8 <dtoa_prf+0x144>
    1ab2:	fc 01       	movw	r30, r24
    1ab4:	e2 0f       	add	r30, r18
    1ab6:	f1 1d       	adc	r31, r1
    1ab8:	10 82       	st	Z, r1
    1aba:	8e ef       	ldi	r24, 0xFE	; 254
    1abc:	9f ef       	ldi	r25, 0xFF	; 255
    1abe:	a6 c0       	rjmp	.+332    	; 0x1c0c <dtoa_prf+0x2a8>
    1ac0:	21 e0       	ldi	r18, 0x01	; 1
    1ac2:	30 e0       	ldi	r19, 0x00	; 0
    1ac4:	91 11       	cpse	r25, r1
    1ac6:	02 c0       	rjmp	.+4      	; 0x1acc <dtoa_prf+0x168>
    1ac8:	20 e0       	ldi	r18, 0x00	; 0
    1aca:	30 e0       	ldi	r19, 0x00	; 0
    1acc:	16 16       	cp	r1, r22
    1ace:	17 06       	cpc	r1, r23
    1ad0:	1c f4       	brge	.+6      	; 0x1ad8 <dtoa_prf+0x174>
    1ad2:	fb 01       	movw	r30, r22
    1ad4:	31 96       	adiw	r30, 0x01	; 1
    1ad6:	02 c0       	rjmp	.+4      	; 0x1adc <dtoa_prf+0x178>
    1ad8:	e1 e0       	ldi	r30, 0x01	; 1
    1ada:	f0 e0       	ldi	r31, 0x00	; 0
    1adc:	2e 0f       	add	r18, r30
    1ade:	3f 1f       	adc	r19, r31
    1ae0:	bb 20       	and	r11, r11
    1ae2:	21 f0       	breq	.+8      	; 0x1aec <dtoa_prf+0x188>
    1ae4:	eb 2d       	mov	r30, r11
    1ae6:	f0 e0       	ldi	r31, 0x00	; 0
    1ae8:	31 96       	adiw	r30, 0x01	; 1
    1aea:	02 c0       	rjmp	.+4      	; 0x1af0 <dtoa_prf+0x18c>
    1aec:	e0 e0       	ldi	r30, 0x00	; 0
    1aee:	f0 e0       	ldi	r31, 0x00	; 0
    1af0:	2e 0f       	add	r18, r30
    1af2:	3f 1f       	adc	r19, r31
    1af4:	e1 2f       	mov	r30, r17
    1af6:	f0 e0       	ldi	r31, 0x00	; 0
    1af8:	2e 17       	cp	r18, r30
    1afa:	3f 07       	cpc	r19, r31
    1afc:	1c f4       	brge	.+6      	; 0x1b04 <dtoa_prf+0x1a0>
    1afe:	12 1b       	sub	r17, r18
    1b00:	21 2f       	mov	r18, r17
    1b02:	01 c0       	rjmp	.+2      	; 0x1b06 <dtoa_prf+0x1a2>
    1b04:	20 e0       	ldi	r18, 0x00	; 0
    1b06:	8e 2d       	mov	r24, r14
    1b08:	88 71       	andi	r24, 0x18	; 24
    1b0a:	59 f4       	brne	.+22     	; 0x1b22 <dtoa_prf+0x1be>
    1b0c:	f6 01       	movw	r30, r12
    1b0e:	82 2f       	mov	r24, r18
    1b10:	30 e2       	ldi	r19, 0x20	; 32
    1b12:	88 23       	and	r24, r24
    1b14:	19 f0       	breq	.+6      	; 0x1b1c <dtoa_prf+0x1b8>
    1b16:	31 93       	st	Z+, r19
    1b18:	81 50       	subi	r24, 0x01	; 1
    1b1a:	fb cf       	rjmp	.-10     	; 0x1b12 <dtoa_prf+0x1ae>
    1b1c:	c2 0e       	add	r12, r18
    1b1e:	d1 1c       	adc	r13, r1
    1b20:	20 e0       	ldi	r18, 0x00	; 0
    1b22:	99 23       	and	r25, r25
    1b24:	29 f0       	breq	.+10     	; 0x1b30 <dtoa_prf+0x1cc>
    1b26:	d6 01       	movw	r26, r12
    1b28:	9c 93       	st	X, r25
    1b2a:	f6 01       	movw	r30, r12
    1b2c:	31 96       	adiw	r30, 0x01	; 1
    1b2e:	6f 01       	movw	r12, r30
    1b30:	51 11       	cpse	r21, r1
    1b32:	0b c0       	rjmp	.+22     	; 0x1b4a <dtoa_prf+0x1e6>
    1b34:	f6 01       	movw	r30, r12
    1b36:	82 2f       	mov	r24, r18
    1b38:	90 e3       	ldi	r25, 0x30	; 48
    1b3a:	88 23       	and	r24, r24
    1b3c:	19 f0       	breq	.+6      	; 0x1b44 <dtoa_prf+0x1e0>
    1b3e:	91 93       	st	Z+, r25
    1b40:	81 50       	subi	r24, 0x01	; 1
    1b42:	fb cf       	rjmp	.-10     	; 0x1b3a <dtoa_prf+0x1d6>
    1b44:	c2 0e       	add	r12, r18
    1b46:	d1 1c       	adc	r13, r1
    1b48:	20 e0       	ldi	r18, 0x00	; 0
    1b4a:	0f 2d       	mov	r16, r15
    1b4c:	06 0f       	add	r16, r22
    1b4e:	9a 81       	ldd	r25, Y+2	; 0x02
    1b50:	34 2f       	mov	r19, r20
    1b52:	30 71       	andi	r19, 0x10	; 16
    1b54:	44 ff       	sbrs	r20, 4
    1b56:	03 c0       	rjmp	.+6      	; 0x1b5e <dtoa_prf+0x1fa>
    1b58:	91 33       	cpi	r25, 0x31	; 49
    1b5a:	09 f4       	brne	.+2      	; 0x1b5e <dtoa_prf+0x1fa>
    1b5c:	01 50       	subi	r16, 0x01	; 1
    1b5e:	10 16       	cp	r1, r16
    1b60:	24 f4       	brge	.+8      	; 0x1b6a <dtoa_prf+0x206>
    1b62:	09 30       	cpi	r16, 0x09	; 9
    1b64:	18 f0       	brcs	.+6      	; 0x1b6c <dtoa_prf+0x208>
    1b66:	08 e0       	ldi	r16, 0x08	; 8
    1b68:	01 c0       	rjmp	.+2      	; 0x1b6c <dtoa_prf+0x208>
    1b6a:	01 e0       	ldi	r16, 0x01	; 1
    1b6c:	ab 01       	movw	r20, r22
    1b6e:	77 ff       	sbrs	r23, 7
    1b70:	02 c0       	rjmp	.+4      	; 0x1b76 <dtoa_prf+0x212>
    1b72:	40 e0       	ldi	r20, 0x00	; 0
    1b74:	50 e0       	ldi	r21, 0x00	; 0
    1b76:	fb 01       	movw	r30, r22
    1b78:	e4 1b       	sub	r30, r20
    1b7a:	f5 0b       	sbc	r31, r21
    1b7c:	a1 e0       	ldi	r26, 0x01	; 1
    1b7e:	b0 e0       	ldi	r27, 0x00	; 0
    1b80:	ac 0f       	add	r26, r28
    1b82:	bd 1f       	adc	r27, r29
    1b84:	ea 0f       	add	r30, r26
    1b86:	fb 1f       	adc	r31, r27
    1b88:	8e e2       	ldi	r24, 0x2E	; 46
    1b8a:	a8 2e       	mov	r10, r24
    1b8c:	4b 01       	movw	r8, r22
    1b8e:	80 1a       	sub	r8, r16
    1b90:	91 08       	sbc	r9, r1
    1b92:	0b 2d       	mov	r16, r11
    1b94:	10 e0       	ldi	r17, 0x00	; 0
    1b96:	11 95       	neg	r17
    1b98:	01 95       	neg	r16
    1b9a:	11 09       	sbc	r17, r1
    1b9c:	4f 3f       	cpi	r20, 0xFF	; 255
    1b9e:	bf ef       	ldi	r27, 0xFF	; 255
    1ba0:	5b 07       	cpc	r21, r27
    1ba2:	21 f4       	brne	.+8      	; 0x1bac <dtoa_prf+0x248>
    1ba4:	d6 01       	movw	r26, r12
    1ba6:	ac 92       	st	X, r10
    1ba8:	11 96       	adiw	r26, 0x01	; 1
    1baa:	6d 01       	movw	r12, r26
    1bac:	64 17       	cp	r22, r20
    1bae:	75 07       	cpc	r23, r21
    1bb0:	2c f0       	brlt	.+10     	; 0x1bbc <dtoa_prf+0x258>
    1bb2:	84 16       	cp	r8, r20
    1bb4:	95 06       	cpc	r9, r21
    1bb6:	14 f4       	brge	.+4      	; 0x1bbc <dtoa_prf+0x258>
    1bb8:	81 81       	ldd	r24, Z+1	; 0x01
    1bba:	01 c0       	rjmp	.+2      	; 0x1bbe <dtoa_prf+0x25a>
    1bbc:	80 e3       	ldi	r24, 0x30	; 48
    1bbe:	41 50       	subi	r20, 0x01	; 1
    1bc0:	51 09       	sbc	r21, r1
    1bc2:	31 96       	adiw	r30, 0x01	; 1
    1bc4:	d6 01       	movw	r26, r12
    1bc6:	11 96       	adiw	r26, 0x01	; 1
    1bc8:	7d 01       	movw	r14, r26
    1bca:	40 17       	cp	r20, r16
    1bcc:	51 07       	cpc	r21, r17
    1bce:	24 f0       	brlt	.+8      	; 0x1bd8 <dtoa_prf+0x274>
    1bd0:	d6 01       	movw	r26, r12
    1bd2:	8c 93       	st	X, r24
    1bd4:	67 01       	movw	r12, r14
    1bd6:	e2 cf       	rjmp	.-60     	; 0x1b9c <dtoa_prf+0x238>
    1bd8:	64 17       	cp	r22, r20
    1bda:	75 07       	cpc	r23, r21
    1bdc:	39 f4       	brne	.+14     	; 0x1bec <dtoa_prf+0x288>
    1bde:	96 33       	cpi	r25, 0x36	; 54
    1be0:	20 f4       	brcc	.+8      	; 0x1bea <dtoa_prf+0x286>
    1be2:	95 33       	cpi	r25, 0x35	; 53
    1be4:	19 f4       	brne	.+6      	; 0x1bec <dtoa_prf+0x288>
    1be6:	31 11       	cpse	r19, r1
    1be8:	01 c0       	rjmp	.+2      	; 0x1bec <dtoa_prf+0x288>
    1bea:	81 e3       	ldi	r24, 0x31	; 49
    1bec:	f6 01       	movw	r30, r12
    1bee:	80 83       	st	Z, r24
    1bf0:	f7 01       	movw	r30, r14
    1bf2:	82 2f       	mov	r24, r18
    1bf4:	90 e2       	ldi	r25, 0x20	; 32
    1bf6:	88 23       	and	r24, r24
    1bf8:	19 f0       	breq	.+6      	; 0x1c00 <dtoa_prf+0x29c>
    1bfa:	91 93       	st	Z+, r25
    1bfc:	81 50       	subi	r24, 0x01	; 1
    1bfe:	fb cf       	rjmp	.-10     	; 0x1bf6 <dtoa_prf+0x292>
    1c00:	f7 01       	movw	r30, r14
    1c02:	e2 0f       	add	r30, r18
    1c04:	f1 1d       	adc	r31, r1
    1c06:	10 82       	st	Z, r1
    1c08:	80 e0       	ldi	r24, 0x00	; 0
    1c0a:	90 e0       	ldi	r25, 0x00	; 0
    1c0c:	29 96       	adiw	r28, 0x09	; 9
    1c0e:	ec e0       	ldi	r30, 0x0C	; 12
    1c10:	a7 c1       	rjmp	.+846    	; 0x1f60 <__epilogue_restores__+0xc>

00001c12 <__ftoa_engine>:
    1c12:	28 30       	cpi	r18, 0x08	; 8
    1c14:	08 f0       	brcs	.+2      	; 0x1c18 <__ftoa_engine+0x6>
    1c16:	27 e0       	ldi	r18, 0x07	; 7
    1c18:	33 27       	eor	r19, r19
    1c1a:	da 01       	movw	r26, r20
    1c1c:	99 0f       	add	r25, r25
    1c1e:	31 1d       	adc	r19, r1
    1c20:	87 fd       	sbrc	r24, 7
    1c22:	91 60       	ori	r25, 0x01	; 1
    1c24:	00 96       	adiw	r24, 0x00	; 0
    1c26:	61 05       	cpc	r22, r1
    1c28:	71 05       	cpc	r23, r1
    1c2a:	39 f4       	brne	.+14     	; 0x1c3a <__ftoa_engine+0x28>
    1c2c:	32 60       	ori	r19, 0x02	; 2
    1c2e:	2e 5f       	subi	r18, 0xFE	; 254
    1c30:	3d 93       	st	X+, r19
    1c32:	30 e3       	ldi	r19, 0x30	; 48
    1c34:	2a 95       	dec	r18
    1c36:	e1 f7       	brne	.-8      	; 0x1c30 <__ftoa_engine+0x1e>
    1c38:	08 95       	ret
    1c3a:	9f 3f       	cpi	r25, 0xFF	; 255
    1c3c:	30 f0       	brcs	.+12     	; 0x1c4a <__ftoa_engine+0x38>
    1c3e:	80 38       	cpi	r24, 0x80	; 128
    1c40:	71 05       	cpc	r23, r1
    1c42:	61 05       	cpc	r22, r1
    1c44:	09 f0       	breq	.+2      	; 0x1c48 <__ftoa_engine+0x36>
    1c46:	3c 5f       	subi	r19, 0xFC	; 252
    1c48:	3c 5f       	subi	r19, 0xFC	; 252
    1c4a:	3d 93       	st	X+, r19
    1c4c:	91 30       	cpi	r25, 0x01	; 1
    1c4e:	08 f0       	brcs	.+2      	; 0x1c52 <__ftoa_engine+0x40>
    1c50:	80 68       	ori	r24, 0x80	; 128
    1c52:	91 1d       	adc	r25, r1
    1c54:	df 93       	push	r29
    1c56:	cf 93       	push	r28
    1c58:	1f 93       	push	r17
    1c5a:	0f 93       	push	r16
    1c5c:	ff 92       	push	r15
    1c5e:	ef 92       	push	r14
    1c60:	19 2f       	mov	r17, r25
    1c62:	98 7f       	andi	r25, 0xF8	; 248
    1c64:	96 95       	lsr	r25
    1c66:	e9 2f       	mov	r30, r25
    1c68:	96 95       	lsr	r25
    1c6a:	96 95       	lsr	r25
    1c6c:	e9 0f       	add	r30, r25
    1c6e:	ff 27       	eor	r31, r31
    1c70:	e2 57       	subi	r30, 0x72	; 114
    1c72:	ff 4f       	sbci	r31, 0xFF	; 255
    1c74:	99 27       	eor	r25, r25
    1c76:	33 27       	eor	r19, r19
    1c78:	ee 24       	eor	r14, r14
    1c7a:	ff 24       	eor	r15, r15
    1c7c:	a7 01       	movw	r20, r14
    1c7e:	e7 01       	movw	r28, r14
    1c80:	05 90       	lpm	r0, Z+
    1c82:	08 94       	sec
    1c84:	07 94       	ror	r0
    1c86:	28 f4       	brcc	.+10     	; 0x1c92 <__ftoa_engine+0x80>
    1c88:	36 0f       	add	r19, r22
    1c8a:	e7 1e       	adc	r14, r23
    1c8c:	f8 1e       	adc	r15, r24
    1c8e:	49 1f       	adc	r20, r25
    1c90:	51 1d       	adc	r21, r1
    1c92:	66 0f       	add	r22, r22
    1c94:	77 1f       	adc	r23, r23
    1c96:	88 1f       	adc	r24, r24
    1c98:	99 1f       	adc	r25, r25
    1c9a:	06 94       	lsr	r0
    1c9c:	a1 f7       	brne	.-24     	; 0x1c86 <__ftoa_engine+0x74>
    1c9e:	05 90       	lpm	r0, Z+
    1ca0:	07 94       	ror	r0
    1ca2:	28 f4       	brcc	.+10     	; 0x1cae <__ftoa_engine+0x9c>
    1ca4:	e7 0e       	add	r14, r23
    1ca6:	f8 1e       	adc	r15, r24
    1ca8:	49 1f       	adc	r20, r25
    1caa:	56 1f       	adc	r21, r22
    1cac:	c1 1d       	adc	r28, r1
    1cae:	77 0f       	add	r23, r23
    1cb0:	88 1f       	adc	r24, r24
    1cb2:	99 1f       	adc	r25, r25
    1cb4:	66 1f       	adc	r22, r22
    1cb6:	06 94       	lsr	r0
    1cb8:	a1 f7       	brne	.-24     	; 0x1ca2 <__ftoa_engine+0x90>
    1cba:	05 90       	lpm	r0, Z+
    1cbc:	07 94       	ror	r0
    1cbe:	28 f4       	brcc	.+10     	; 0x1cca <__ftoa_engine+0xb8>
    1cc0:	f8 0e       	add	r15, r24
    1cc2:	49 1f       	adc	r20, r25
    1cc4:	56 1f       	adc	r21, r22
    1cc6:	c7 1f       	adc	r28, r23
    1cc8:	d1 1d       	adc	r29, r1
    1cca:	88 0f       	add	r24, r24
    1ccc:	99 1f       	adc	r25, r25
    1cce:	66 1f       	adc	r22, r22
    1cd0:	77 1f       	adc	r23, r23
    1cd2:	06 94       	lsr	r0
    1cd4:	a1 f7       	brne	.-24     	; 0x1cbe <__ftoa_engine+0xac>
    1cd6:	05 90       	lpm	r0, Z+
    1cd8:	07 94       	ror	r0
    1cda:	20 f4       	brcc	.+8      	; 0x1ce4 <__ftoa_engine+0xd2>
    1cdc:	49 0f       	add	r20, r25
    1cde:	56 1f       	adc	r21, r22
    1ce0:	c7 1f       	adc	r28, r23
    1ce2:	d8 1f       	adc	r29, r24
    1ce4:	99 0f       	add	r25, r25
    1ce6:	66 1f       	adc	r22, r22
    1ce8:	77 1f       	adc	r23, r23
    1cea:	88 1f       	adc	r24, r24
    1cec:	06 94       	lsr	r0
    1cee:	a9 f7       	brne	.-22     	; 0x1cda <__ftoa_engine+0xc8>
    1cf0:	84 91       	lpm	r24, Z
    1cf2:	10 95       	com	r17
    1cf4:	17 70       	andi	r17, 0x07	; 7
    1cf6:	41 f0       	breq	.+16     	; 0x1d08 <__ftoa_engine+0xf6>
    1cf8:	d6 95       	lsr	r29
    1cfa:	c7 95       	ror	r28
    1cfc:	57 95       	ror	r21
    1cfe:	47 95       	ror	r20
    1d00:	f7 94       	ror	r15
    1d02:	e7 94       	ror	r14
    1d04:	1a 95       	dec	r17
    1d06:	c1 f7       	brne	.-16     	; 0x1cf8 <__ftoa_engine+0xe6>
    1d08:	e4 e3       	ldi	r30, 0x34	; 52
    1d0a:	f0 e0       	ldi	r31, 0x00	; 0
    1d0c:	68 94       	set
    1d0e:	15 90       	lpm	r1, Z+
    1d10:	15 91       	lpm	r17, Z+
    1d12:	35 91       	lpm	r19, Z+
    1d14:	65 91       	lpm	r22, Z+
    1d16:	95 91       	lpm	r25, Z+
    1d18:	05 90       	lpm	r0, Z+
    1d1a:	7f e2       	ldi	r23, 0x2F	; 47
    1d1c:	73 95       	inc	r23
    1d1e:	e1 18       	sub	r14, r1
    1d20:	f1 0a       	sbc	r15, r17
    1d22:	43 0b       	sbc	r20, r19
    1d24:	56 0b       	sbc	r21, r22
    1d26:	c9 0b       	sbc	r28, r25
    1d28:	d0 09       	sbc	r29, r0
    1d2a:	c0 f7       	brcc	.-16     	; 0x1d1c <__ftoa_engine+0x10a>
    1d2c:	e1 0c       	add	r14, r1
    1d2e:	f1 1e       	adc	r15, r17
    1d30:	43 1f       	adc	r20, r19
    1d32:	56 1f       	adc	r21, r22
    1d34:	c9 1f       	adc	r28, r25
    1d36:	d0 1d       	adc	r29, r0
    1d38:	7e f4       	brtc	.+30     	; 0x1d58 <__ftoa_engine+0x146>
    1d3a:	70 33       	cpi	r23, 0x30	; 48
    1d3c:	11 f4       	brne	.+4      	; 0x1d42 <__ftoa_engine+0x130>
    1d3e:	8a 95       	dec	r24
    1d40:	e6 cf       	rjmp	.-52     	; 0x1d0e <__ftoa_engine+0xfc>
    1d42:	e8 94       	clt
    1d44:	01 50       	subi	r16, 0x01	; 1
    1d46:	30 f0       	brcs	.+12     	; 0x1d54 <__ftoa_engine+0x142>
    1d48:	08 0f       	add	r16, r24
    1d4a:	0a f4       	brpl	.+2      	; 0x1d4e <__ftoa_engine+0x13c>
    1d4c:	00 27       	eor	r16, r16
    1d4e:	02 17       	cp	r16, r18
    1d50:	08 f4       	brcc	.+2      	; 0x1d54 <__ftoa_engine+0x142>
    1d52:	20 2f       	mov	r18, r16
    1d54:	23 95       	inc	r18
    1d56:	02 2f       	mov	r16, r18
    1d58:	7a 33       	cpi	r23, 0x3A	; 58
    1d5a:	28 f0       	brcs	.+10     	; 0x1d66 <__ftoa_engine+0x154>
    1d5c:	79 e3       	ldi	r23, 0x39	; 57
    1d5e:	7d 93       	st	X+, r23
    1d60:	2a 95       	dec	r18
    1d62:	e9 f7       	brne	.-6      	; 0x1d5e <__ftoa_engine+0x14c>
    1d64:	10 c0       	rjmp	.+32     	; 0x1d86 <__ftoa_engine+0x174>
    1d66:	7d 93       	st	X+, r23
    1d68:	2a 95       	dec	r18
    1d6a:	89 f6       	brne	.-94     	; 0x1d0e <__ftoa_engine+0xfc>
    1d6c:	06 94       	lsr	r0
    1d6e:	97 95       	ror	r25
    1d70:	67 95       	ror	r22
    1d72:	37 95       	ror	r19
    1d74:	17 95       	ror	r17
    1d76:	17 94       	ror	r1
    1d78:	e1 18       	sub	r14, r1
    1d7a:	f1 0a       	sbc	r15, r17
    1d7c:	43 0b       	sbc	r20, r19
    1d7e:	56 0b       	sbc	r21, r22
    1d80:	c9 0b       	sbc	r28, r25
    1d82:	d0 09       	sbc	r29, r0
    1d84:	98 f0       	brcs	.+38     	; 0x1dac <__ftoa_engine+0x19a>
    1d86:	23 95       	inc	r18
    1d88:	7e 91       	ld	r23, -X
    1d8a:	73 95       	inc	r23
    1d8c:	7a 33       	cpi	r23, 0x3A	; 58
    1d8e:	08 f0       	brcs	.+2      	; 0x1d92 <__ftoa_engine+0x180>
    1d90:	70 e3       	ldi	r23, 0x30	; 48
    1d92:	7c 93       	st	X, r23
    1d94:	20 13       	cpse	r18, r16
    1d96:	b8 f7       	brcc	.-18     	; 0x1d86 <__ftoa_engine+0x174>
    1d98:	7e 91       	ld	r23, -X
    1d9a:	70 61       	ori	r23, 0x10	; 16
    1d9c:	7d 93       	st	X+, r23
    1d9e:	30 f0       	brcs	.+12     	; 0x1dac <__ftoa_engine+0x19a>
    1da0:	83 95       	inc	r24
    1da2:	71 e3       	ldi	r23, 0x31	; 49
    1da4:	7d 93       	st	X+, r23
    1da6:	70 e3       	ldi	r23, 0x30	; 48
    1da8:	2a 95       	dec	r18
    1daa:	e1 f7       	brne	.-8      	; 0x1da4 <__ftoa_engine+0x192>
    1dac:	11 24       	eor	r1, r1
    1dae:	ef 90       	pop	r14
    1db0:	ff 90       	pop	r15
    1db2:	0f 91       	pop	r16
    1db4:	1f 91       	pop	r17
    1db6:	cf 91       	pop	r28
    1db8:	df 91       	pop	r29
    1dba:	99 27       	eor	r25, r25
    1dbc:	87 fd       	sbrc	r24, 7
    1dbe:	90 95       	com	r25
    1dc0:	08 95       	ret

00001dc2 <strnlen_P>:
    1dc2:	fc 01       	movw	r30, r24
    1dc4:	05 90       	lpm	r0, Z+
    1dc6:	61 50       	subi	r22, 0x01	; 1
    1dc8:	70 40       	sbci	r23, 0x00	; 0
    1dca:	01 10       	cpse	r0, r1
    1dcc:	d8 f7       	brcc	.-10     	; 0x1dc4 <strnlen_P+0x2>
    1dce:	80 95       	com	r24
    1dd0:	90 95       	com	r25
    1dd2:	8e 0f       	add	r24, r30
    1dd4:	9f 1f       	adc	r25, r31
    1dd6:	08 95       	ret

00001dd8 <strnlen>:
    1dd8:	fc 01       	movw	r30, r24
    1dda:	61 50       	subi	r22, 0x01	; 1
    1ddc:	70 40       	sbci	r23, 0x00	; 0
    1dde:	01 90       	ld	r0, Z+
    1de0:	01 10       	cpse	r0, r1
    1de2:	d8 f7       	brcc	.-10     	; 0x1dda <strnlen+0x2>
    1de4:	80 95       	com	r24
    1de6:	90 95       	com	r25
    1de8:	8e 0f       	add	r24, r30
    1dea:	9f 1f       	adc	r25, r31
    1dec:	08 95       	ret

00001dee <fputc>:
    1dee:	0f 93       	push	r16
    1df0:	1f 93       	push	r17
    1df2:	cf 93       	push	r28
    1df4:	df 93       	push	r29
    1df6:	fb 01       	movw	r30, r22
    1df8:	23 81       	ldd	r18, Z+3	; 0x03
    1dfa:	21 fd       	sbrc	r18, 1
    1dfc:	03 c0       	rjmp	.+6      	; 0x1e04 <fputc+0x16>
    1dfe:	8f ef       	ldi	r24, 0xFF	; 255
    1e00:	9f ef       	ldi	r25, 0xFF	; 255
    1e02:	2c c0       	rjmp	.+88     	; 0x1e5c <fputc+0x6e>
    1e04:	22 ff       	sbrs	r18, 2
    1e06:	16 c0       	rjmp	.+44     	; 0x1e34 <fputc+0x46>
    1e08:	46 81       	ldd	r20, Z+6	; 0x06
    1e0a:	57 81       	ldd	r21, Z+7	; 0x07
    1e0c:	24 81       	ldd	r18, Z+4	; 0x04
    1e0e:	35 81       	ldd	r19, Z+5	; 0x05
    1e10:	42 17       	cp	r20, r18
    1e12:	53 07       	cpc	r21, r19
    1e14:	44 f4       	brge	.+16     	; 0x1e26 <fputc+0x38>
    1e16:	a0 81       	ld	r26, Z
    1e18:	b1 81       	ldd	r27, Z+1	; 0x01
    1e1a:	9d 01       	movw	r18, r26
    1e1c:	2f 5f       	subi	r18, 0xFF	; 255
    1e1e:	3f 4f       	sbci	r19, 0xFF	; 255
    1e20:	20 83       	st	Z, r18
    1e22:	31 83       	std	Z+1, r19	; 0x01
    1e24:	8c 93       	st	X, r24
    1e26:	26 81       	ldd	r18, Z+6	; 0x06
    1e28:	37 81       	ldd	r19, Z+7	; 0x07
    1e2a:	2f 5f       	subi	r18, 0xFF	; 255
    1e2c:	3f 4f       	sbci	r19, 0xFF	; 255
    1e2e:	26 83       	std	Z+6, r18	; 0x06
    1e30:	37 83       	std	Z+7, r19	; 0x07
    1e32:	14 c0       	rjmp	.+40     	; 0x1e5c <fputc+0x6e>
    1e34:	8b 01       	movw	r16, r22
    1e36:	ec 01       	movw	r28, r24
    1e38:	fb 01       	movw	r30, r22
    1e3a:	00 84       	ldd	r0, Z+8	; 0x08
    1e3c:	f1 85       	ldd	r31, Z+9	; 0x09
    1e3e:	e0 2d       	mov	r30, r0
    1e40:	09 95       	icall
    1e42:	89 2b       	or	r24, r25
    1e44:	e1 f6       	brne	.-72     	; 0x1dfe <fputc+0x10>
    1e46:	d8 01       	movw	r26, r16
    1e48:	16 96       	adiw	r26, 0x06	; 6
    1e4a:	8d 91       	ld	r24, X+
    1e4c:	9c 91       	ld	r25, X
    1e4e:	17 97       	sbiw	r26, 0x07	; 7
    1e50:	01 96       	adiw	r24, 0x01	; 1
    1e52:	16 96       	adiw	r26, 0x06	; 6
    1e54:	8d 93       	st	X+, r24
    1e56:	9c 93       	st	X, r25
    1e58:	17 97       	sbiw	r26, 0x07	; 7
    1e5a:	ce 01       	movw	r24, r28
    1e5c:	df 91       	pop	r29
    1e5e:	cf 91       	pop	r28
    1e60:	1f 91       	pop	r17
    1e62:	0f 91       	pop	r16
    1e64:	08 95       	ret

00001e66 <__ultoa_invert>:
    1e66:	fa 01       	movw	r30, r20
    1e68:	aa 27       	eor	r26, r26
    1e6a:	28 30       	cpi	r18, 0x08	; 8
    1e6c:	51 f1       	breq	.+84     	; 0x1ec2 <__ultoa_invert+0x5c>
    1e6e:	20 31       	cpi	r18, 0x10	; 16
    1e70:	81 f1       	breq	.+96     	; 0x1ed2 <__ultoa_invert+0x6c>
    1e72:	e8 94       	clt
    1e74:	6f 93       	push	r22
    1e76:	6e 7f       	andi	r22, 0xFE	; 254
    1e78:	6e 5f       	subi	r22, 0xFE	; 254
    1e7a:	7f 4f       	sbci	r23, 0xFF	; 255
    1e7c:	8f 4f       	sbci	r24, 0xFF	; 255
    1e7e:	9f 4f       	sbci	r25, 0xFF	; 255
    1e80:	af 4f       	sbci	r26, 0xFF	; 255
    1e82:	b1 e0       	ldi	r27, 0x01	; 1
    1e84:	3e d0       	rcall	.+124    	; 0x1f02 <__ultoa_invert+0x9c>
    1e86:	b4 e0       	ldi	r27, 0x04	; 4
    1e88:	3c d0       	rcall	.+120    	; 0x1f02 <__ultoa_invert+0x9c>
    1e8a:	67 0f       	add	r22, r23
    1e8c:	78 1f       	adc	r23, r24
    1e8e:	89 1f       	adc	r24, r25
    1e90:	9a 1f       	adc	r25, r26
    1e92:	a1 1d       	adc	r26, r1
    1e94:	68 0f       	add	r22, r24
    1e96:	79 1f       	adc	r23, r25
    1e98:	8a 1f       	adc	r24, r26
    1e9a:	91 1d       	adc	r25, r1
    1e9c:	a1 1d       	adc	r26, r1
    1e9e:	6a 0f       	add	r22, r26
    1ea0:	71 1d       	adc	r23, r1
    1ea2:	81 1d       	adc	r24, r1
    1ea4:	91 1d       	adc	r25, r1
    1ea6:	a1 1d       	adc	r26, r1
    1ea8:	20 d0       	rcall	.+64     	; 0x1eea <__ultoa_invert+0x84>
    1eaa:	09 f4       	brne	.+2      	; 0x1eae <__ultoa_invert+0x48>
    1eac:	68 94       	set
    1eae:	3f 91       	pop	r19
    1eb0:	2a e0       	ldi	r18, 0x0A	; 10
    1eb2:	26 9f       	mul	r18, r22
    1eb4:	11 24       	eor	r1, r1
    1eb6:	30 19       	sub	r19, r0
    1eb8:	30 5d       	subi	r19, 0xD0	; 208
    1eba:	31 93       	st	Z+, r19
    1ebc:	de f6       	brtc	.-74     	; 0x1e74 <__ultoa_invert+0xe>
    1ebe:	cf 01       	movw	r24, r30
    1ec0:	08 95       	ret
    1ec2:	46 2f       	mov	r20, r22
    1ec4:	47 70       	andi	r20, 0x07	; 7
    1ec6:	40 5d       	subi	r20, 0xD0	; 208
    1ec8:	41 93       	st	Z+, r20
    1eca:	b3 e0       	ldi	r27, 0x03	; 3
    1ecc:	0f d0       	rcall	.+30     	; 0x1eec <__ultoa_invert+0x86>
    1ece:	c9 f7       	brne	.-14     	; 0x1ec2 <__ultoa_invert+0x5c>
    1ed0:	f6 cf       	rjmp	.-20     	; 0x1ebe <__ultoa_invert+0x58>
    1ed2:	46 2f       	mov	r20, r22
    1ed4:	4f 70       	andi	r20, 0x0F	; 15
    1ed6:	40 5d       	subi	r20, 0xD0	; 208
    1ed8:	4a 33       	cpi	r20, 0x3A	; 58
    1eda:	18 f0       	brcs	.+6      	; 0x1ee2 <__ultoa_invert+0x7c>
    1edc:	49 5d       	subi	r20, 0xD9	; 217
    1ede:	31 fd       	sbrc	r19, 1
    1ee0:	40 52       	subi	r20, 0x20	; 32
    1ee2:	41 93       	st	Z+, r20
    1ee4:	02 d0       	rcall	.+4      	; 0x1eea <__ultoa_invert+0x84>
    1ee6:	a9 f7       	brne	.-22     	; 0x1ed2 <__ultoa_invert+0x6c>
    1ee8:	ea cf       	rjmp	.-44     	; 0x1ebe <__ultoa_invert+0x58>
    1eea:	b4 e0       	ldi	r27, 0x04	; 4
    1eec:	a6 95       	lsr	r26
    1eee:	97 95       	ror	r25
    1ef0:	87 95       	ror	r24
    1ef2:	77 95       	ror	r23
    1ef4:	67 95       	ror	r22
    1ef6:	ba 95       	dec	r27
    1ef8:	c9 f7       	brne	.-14     	; 0x1eec <__ultoa_invert+0x86>
    1efa:	00 97       	sbiw	r24, 0x00	; 0
    1efc:	61 05       	cpc	r22, r1
    1efe:	71 05       	cpc	r23, r1
    1f00:	08 95       	ret
    1f02:	9b 01       	movw	r18, r22
    1f04:	ac 01       	movw	r20, r24
    1f06:	0a 2e       	mov	r0, r26
    1f08:	06 94       	lsr	r0
    1f0a:	57 95       	ror	r21
    1f0c:	47 95       	ror	r20
    1f0e:	37 95       	ror	r19
    1f10:	27 95       	ror	r18
    1f12:	ba 95       	dec	r27
    1f14:	c9 f7       	brne	.-14     	; 0x1f08 <__ultoa_invert+0xa2>
    1f16:	62 0f       	add	r22, r18
    1f18:	73 1f       	adc	r23, r19
    1f1a:	84 1f       	adc	r24, r20
    1f1c:	95 1f       	adc	r25, r21
    1f1e:	a0 1d       	adc	r26, r0
    1f20:	08 95       	ret

00001f22 <__prologue_saves__>:
    1f22:	2f 92       	push	r2
    1f24:	3f 92       	push	r3
    1f26:	4f 92       	push	r4
    1f28:	5f 92       	push	r5
    1f2a:	6f 92       	push	r6
    1f2c:	7f 92       	push	r7
    1f2e:	8f 92       	push	r8
    1f30:	9f 92       	push	r9
    1f32:	af 92       	push	r10
    1f34:	bf 92       	push	r11
    1f36:	cf 92       	push	r12
    1f38:	df 92       	push	r13
    1f3a:	ef 92       	push	r14
    1f3c:	ff 92       	push	r15
    1f3e:	0f 93       	push	r16
    1f40:	1f 93       	push	r17
    1f42:	cf 93       	push	r28
    1f44:	df 93       	push	r29
    1f46:	cd b7       	in	r28, 0x3d	; 61
    1f48:	de b7       	in	r29, 0x3e	; 62
    1f4a:	ca 1b       	sub	r28, r26
    1f4c:	db 0b       	sbc	r29, r27
    1f4e:	cd bf       	out	0x3d, r28	; 61
    1f50:	de bf       	out	0x3e, r29	; 62
    1f52:	09 94       	ijmp

00001f54 <__epilogue_restores__>:
    1f54:	2a 88       	ldd	r2, Y+18	; 0x12
    1f56:	39 88       	ldd	r3, Y+17	; 0x11
    1f58:	48 88       	ldd	r4, Y+16	; 0x10
    1f5a:	5f 84       	ldd	r5, Y+15	; 0x0f
    1f5c:	6e 84       	ldd	r6, Y+14	; 0x0e
    1f5e:	7d 84       	ldd	r7, Y+13	; 0x0d
    1f60:	8c 84       	ldd	r8, Y+12	; 0x0c
    1f62:	9b 84       	ldd	r9, Y+11	; 0x0b
    1f64:	aa 84       	ldd	r10, Y+10	; 0x0a
    1f66:	b9 84       	ldd	r11, Y+9	; 0x09
    1f68:	c8 84       	ldd	r12, Y+8	; 0x08
    1f6a:	df 80       	ldd	r13, Y+7	; 0x07
    1f6c:	ee 80       	ldd	r14, Y+6	; 0x06
    1f6e:	fd 80       	ldd	r15, Y+5	; 0x05
    1f70:	0c 81       	ldd	r16, Y+4	; 0x04
    1f72:	1b 81       	ldd	r17, Y+3	; 0x03
    1f74:	aa 81       	ldd	r26, Y+2	; 0x02
    1f76:	b9 81       	ldd	r27, Y+1	; 0x01
    1f78:	ce 0f       	add	r28, r30
    1f7a:	d1 1d       	adc	r29, r1
    1f7c:	cd bf       	out	0x3d, r28	; 61
    1f7e:	de bf       	out	0x3e, r29	; 62
    1f80:	ed 01       	movw	r28, r26
    1f82:	08 95       	ret

00001f84 <_exit>:
    1f84:	f8 94       	cli

00001f86 <__stop_program>:
    1f86:	ff cf       	rjmp	.-2      	; 0x1f86 <__stop_program>
