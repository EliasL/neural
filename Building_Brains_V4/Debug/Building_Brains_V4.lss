
Building_Brains_V4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000c  00803e00  00001468  000014fc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001468  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000052  00803e0c  00803e0c  00001508  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001508  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001538  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000003e8  00000000  00000000  00001578  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00006d03  00000000  00000000  00001960  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002d1e  00000000  00000000  00008663  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002167  00000000  00000000  0000b381  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000006f0  00000000  00000000  0000d4e8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002c6c  00000000  00000000  0000dbd8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001251  00000000  00000000  00010844  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000290  00000000  00000000  00011a95  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	2d c0       	rjmp	.+90     	; 0x5c <__ctors_end>
       2:	47 c0       	rjmp	.+142    	; 0x92 <__bad_interrupt>
       4:	46 c0       	rjmp	.+140    	; 0x92 <__bad_interrupt>
       6:	45 c0       	rjmp	.+138    	; 0x92 <__bad_interrupt>
       8:	44 c0       	rjmp	.+136    	; 0x92 <__bad_interrupt>
       a:	43 c0       	rjmp	.+134    	; 0x92 <__bad_interrupt>
       c:	10 c5       	rjmp	.+2592   	; 0xa2e <__vector_6>
       e:	41 c0       	rjmp	.+130    	; 0x92 <__bad_interrupt>
      10:	40 c0       	rjmp	.+128    	; 0x92 <__bad_interrupt>
      12:	3f c0       	rjmp	.+126    	; 0x92 <__bad_interrupt>
      14:	3e c0       	rjmp	.+124    	; 0x92 <__bad_interrupt>
      16:	3d c0       	rjmp	.+122    	; 0x92 <__bad_interrupt>
      18:	3c c0       	rjmp	.+120    	; 0x92 <__bad_interrupt>
      1a:	3b c0       	rjmp	.+118    	; 0x92 <__bad_interrupt>
      1c:	3a c0       	rjmp	.+116    	; 0x92 <__bad_interrupt>
      1e:	39 c0       	rjmp	.+114    	; 0x92 <__bad_interrupt>
      20:	38 c0       	rjmp	.+112    	; 0x92 <__bad_interrupt>
      22:	37 c0       	rjmp	.+110    	; 0x92 <__bad_interrupt>
      24:	36 c0       	rjmp	.+108    	; 0x92 <__bad_interrupt>
      26:	35 c0       	rjmp	.+106    	; 0x92 <__bad_interrupt>
      28:	34 c0       	rjmp	.+104    	; 0x92 <__bad_interrupt>
      2a:	33 c0       	rjmp	.+102    	; 0x92 <__bad_interrupt>
      2c:	32 c0       	rjmp	.+100    	; 0x92 <__bad_interrupt>
      2e:	31 c0       	rjmp	.+98     	; 0x92 <__bad_interrupt>
      30:	30 c0       	rjmp	.+96     	; 0x92 <__bad_interrupt>
      32:	2f c0       	rjmp	.+94     	; 0x92 <__bad_interrupt>
      34:	07 63       	ori	r16, 0x37	; 55
      36:	42 36       	cpi	r20, 0x62	; 98
      38:	b7 9b       	sbis	0x16, 7	; 22
      3a:	d8 a7       	std	Y+40, r29	; 0x28
      3c:	1a 39       	cpi	r17, 0x9A	; 154
      3e:	68 56       	subi	r22, 0x68	; 104
      40:	18 ae       	std	Y+56, r1	; 0x38
      42:	ba ab       	std	Y+50, r27	; 0x32
      44:	55 8c       	ldd	r5, Z+29	; 0x1d
      46:	1d 3c       	cpi	r17, 0xCD	; 205
      48:	b7 cc       	rjmp	.-1682   	; 0xfffff9b8 <__eeprom_end+0xff7ef9b8>
      4a:	57 63       	ori	r21, 0x37	; 55
      4c:	bd 6d       	ori	r27, 0xDD	; 221
      4e:	ed fd       	.word	0xfded	; ????
      50:	75 3e       	cpi	r23, 0xE5	; 229
      52:	f6 17       	cp	r31, r22
      54:	72 31       	cpi	r23, 0x12	; 18
      56:	bf 00       	.word	0x00bf	; ????
      58:	00 00       	nop
      5a:	80 3f       	cpi	r24, 0xF0	; 240

0000005c <__ctors_end>:
      5c:	11 24       	eor	r1, r1
      5e:	1f be       	out	0x3f, r1	; 63
      60:	cf ef       	ldi	r28, 0xFF	; 255
      62:	cd bf       	out	0x3d, r28	; 61
      64:	df e3       	ldi	r29, 0x3F	; 63
      66:	de bf       	out	0x3e, r29	; 62

00000068 <__do_copy_data>:
      68:	1e e3       	ldi	r17, 0x3E	; 62
      6a:	a0 e0       	ldi	r26, 0x00	; 0
      6c:	be e3       	ldi	r27, 0x3E	; 62
      6e:	e8 e6       	ldi	r30, 0x68	; 104
      70:	f4 e1       	ldi	r31, 0x14	; 20
      72:	02 c0       	rjmp	.+4      	; 0x78 <__do_copy_data+0x10>
      74:	05 90       	lpm	r0, Z+
      76:	0d 92       	st	X+, r0
      78:	ac 30       	cpi	r26, 0x0C	; 12
      7a:	b1 07       	cpc	r27, r17
      7c:	d9 f7       	brne	.-10     	; 0x74 <__do_copy_data+0xc>

0000007e <__do_clear_bss>:
      7e:	2e e3       	ldi	r18, 0x3E	; 62
      80:	ac e0       	ldi	r26, 0x0C	; 12
      82:	be e3       	ldi	r27, 0x3E	; 62
      84:	01 c0       	rjmp	.+2      	; 0x88 <.do_clear_bss_start>

00000086 <.do_clear_bss_loop>:
      86:	1d 92       	st	X+, r1

00000088 <.do_clear_bss_start>:
      88:	ae 35       	cpi	r26, 0x5E	; 94
      8a:	b2 07       	cpc	r27, r18
      8c:	e1 f7       	brne	.-8      	; 0x86 <.do_clear_bss_loop>
      8e:	9f d1       	rcall	.+830    	; 0x3ce <main>
      90:	e9 c9       	rjmp	.-3118   	; 0xfffff464 <__eeprom_end+0xff7ef464>

00000092 <__bad_interrupt>:
      92:	b6 cf       	rjmp	.-148    	; 0x0 <__vectors>

00000094 <atmel_start_init>:
/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
	system_init();
      94:	ad d0       	rcall	.+346    	; 0x1f0 <system_init>
      96:	08 95       	ret

00000098 <ADC_init>:
 * \return Conversion result read from the ADC ADC module
 */
adc_result_t ADC_get_conversion_result(void)
{
	return (ADC0.RES);
}
      98:	85 e0       	ldi	r24, 0x05	; 5
      9a:	80 93 00 06 	sts	0x0600, r24	; 0x800600 <__TEXT_REGION_LENGTH__+0x700600>
      9e:	80 e0       	ldi	r24, 0x00	; 0
      a0:	08 95       	ret

000000a2 <ADC_is_conversion_done>:
      a2:	80 91 0b 06 	lds	r24, 0x060B	; 0x80060b <__TEXT_REGION_LENGTH__+0x70060b>
      a6:	81 70       	andi	r24, 0x01	; 1
      a8:	08 95       	ret

000000aa <ADC_get_conversion>:
 *
 * \return Nothing
 */
void ADC_start_conversion(adc_0_channel_t channel)
{
	ADC0.MUXPOS  = channel;
      aa:	e0 e0       	ldi	r30, 0x00	; 0
      ac:	f6 e0       	ldi	r31, 0x06	; 6
      ae:	86 83       	std	Z+6, r24	; 0x06
	ADC0.COMMAND = ADC_STCONV_bm;
      b0:	81 e0       	ldi	r24, 0x01	; 1
      b2:	80 87       	std	Z+8, r24	; 0x08
adc_result_t ADC_get_conversion(adc_0_channel_t channel)
{
	adc_result_t res;

	ADC_start_conversion(channel);
	while (!ADC_is_conversion_done())
      b4:	f6 df       	rcall	.-20     	; 0xa2 <ADC_is_conversion_done>
      b6:	88 23       	and	r24, r24
      b8:	e9 f3       	breq	.-6      	; 0xb4 <ADC_get_conversion+0xa>
 *
 * \return Conversion result read from the ADC ADC module
 */
adc_result_t ADC_get_conversion_result(void)
{
	return (ADC0.RES);
      ba:	e0 e0       	ldi	r30, 0x00	; 0
      bc:	f6 e0       	ldi	r31, 0x06	; 6
      be:	20 89       	ldd	r18, Z+16	; 0x10
      c0:	31 89       	ldd	r19, Z+17	; 0x11

	ADC_start_conversion(channel);
	while (!ADC_is_conversion_done())
		;
	res = ADC_get_conversion_result();
	ADC0.INTFLAGS |= ADC_RESRDY_bm;
      c2:	93 85       	ldd	r25, Z+11	; 0x0b
      c4:	91 60       	ori	r25, 0x01	; 1
      c6:	93 87       	std	Z+11, r25	; 0x0b
	return res;
}
      c8:	c9 01       	movw	r24, r18
      ca:	08 95       	ret

000000cc <BOD_init>:
	//		 | BOD_VLMCFG_ABOVE_gc; /* Interrupt when supply goes above VLM level */

	// BOD.VLMCTRLA = BOD_VLMLVL_5ABOVE_gc; /* VLM threshold 5% above BOD level */

	return 0;
}
      cc:	80 e0       	ldi	r24, 0x00	; 0
      ce:	08 95       	ret

000000d0 <DIGGSIGG_init>:
	//		 | CCL_EDGEDET_DIS_gc /* Edge detector is disabled */
	//		 | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	//		 | 0 << CCL_ENABLE_bp /* LUT Enable: disabled */
	//		 | 0 << CCL_OUTEN_bp; /* Output Enable: disabled */

	CCL.TRUTH1 = 168; /* Truth 1: 168 */
      d0:	e0 ec       	ldi	r30, 0xC0	; 192
      d2:	f1 e0       	ldi	r31, 0x01	; 1
      d4:	88 ea       	ldi	r24, 0xA8	; 168
      d6:	84 87       	std	Z+12, r24	; 0x0c

	CCL.LUT1CTRLC = CCL_INSEL2_TCA0_gc /* TCA0 WO2 input source */;
      d8:	88 e0       	ldi	r24, 0x08	; 8
      da:	83 87       	std	Z+11, r24	; 0x0b

	CCL.LUT1CTRLB = CCL_INSEL0_SPI0_gc /* SPI0 SCK source */
      dc:	8b eb       	ldi	r24, 0xBB	; 187
      de:	82 87       	std	Z+10, r24	; 0x0a
	                | CCL_INSEL1_SPI0_gc /* SPI0 MOSI input source */;

	CCL.LUT1CTRLA = 0 << CCL_CLKSRC_bp       /* Clock Source Selection: disabled */
      e0:	89 e0       	ldi	r24, 0x09	; 9
      e2:	81 87       	std	Z+9, r24	; 0x09
	                | CCL_EDGEDET_DIS_gc     /* Edge detector is disabled */
	                | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	                | 1 << CCL_ENABLE_bp     /* LUT Enable: enabled */
	                | 1 << CCL_OUTEN_bp;     /* Output Enable: enabled */

	CCL.CTRLA = 1 << CCL_ENABLE_bp      /* Enable: enabled */
      e4:	81 e4       	ldi	r24, 0x41	; 65
      e6:	80 83       	st	Z, r24
	            | 1 << CCL_RUNSTDBY_bp; /* Run in Standby: enabled */

	return 0;
}
      e8:	80 e0       	ldi	r24, 0x00	; 0
      ea:	08 95       	ret

000000ec <CLKCTRL_init>:
 *       on calling convention. The memory model is not visible to the
 *       preprocessor, so it must be defined in the Assembler preprocessor directives.
 */
static inline void ccp_write_io(void *addr, uint8_t value)
{
	protected_write_io(addr, CCP_IOREG_gc, value);
      ec:	47 e0       	ldi	r20, 0x07	; 7
      ee:	68 ed       	ldi	r22, 0xD8	; 216
      f0:	8c e7       	ldi	r24, 0x7C	; 124
      f2:	90 e0       	ldi	r25, 0x00	; 0
      f4:	91 d0       	rcall	.+290    	; 0x218 <protected_write_io>
      f6:	41 e0       	ldi	r20, 0x01	; 1
      f8:	68 ed       	ldi	r22, 0xD8	; 216
      fa:	81 e6       	ldi	r24, 0x61	; 97
      fc:	90 e0       	ldi	r25, 0x00	; 0
      fe:	8c d0       	rcall	.+280    	; 0x218 <protected_write_io>
	//		 | 0 << CLKCTRL_CLKOUT_bp /* System clock out: disabled */);

	// ccp_write_io((void*)&(CLKCTRL.MCLKLOCK),0 << CLKCTRL_LOCKEN_bp /* lock enable: disabled */);

	return 0;
}
     100:	80 e0       	ldi	r24, 0x00	; 0
     102:	08 95       	ret

00000104 <CPUINT_init>:

	// CPUINT.LVL0PRI = 0x0 << CPUINT_LVL0PRI_gp; /* Interrupt Level Priority: 0x0 */

	// CPUINT.LVL1VEC = 0x0 << CPUINT_LVL1VEC_gp; /* Interrupt Vector with High Priority: 0x0 */

	ENABLE_INTERRUPTS();
     104:	78 94       	sei

	return 0;
}
     106:	80 e0       	ldi	r24, 0x00	; 0
     108:	08 95       	ret

0000010a <DAC_init>:
 *
 * \return Nothing
 */
void DAC_disable()
{
	DAC0.CTRLA &= ~DAC_ENABLE_bm;
     10a:	81 e4       	ldi	r24, 0x41	; 65
     10c:	80 93 80 06 	sts	0x0680, r24	; 0x800680 <__TEXT_REGION_LENGTH__+0x700680>
     110:	80 e0       	ldi	r24, 0x00	; 0
     112:	08 95       	ret

00000114 <DAC_set_output>:
 *
 * \return Nothing
 */
void DAC_set_output(dac_resolution_t value)
{
	DAC0.DATA = value;
     114:	80 93 81 06 	sts	0x0681, r24	; 0x800681 <__TEXT_REGION_LENGTH__+0x700681>
     118:	08 95       	ret

0000011a <mcu_init>:

/* configure pins and initialize registers */
void DAC_initialization(void)
{

	DAC_init();
     11a:	e0 e1       	ldi	r30, 0x10	; 16
     11c:	f4 e0       	ldi	r31, 0x04	; 4
     11e:	80 81       	ld	r24, Z
     120:	88 60       	ori	r24, 0x08	; 8
     122:	81 93       	st	Z+, r24
     124:	e8 31       	cpi	r30, 0x18	; 24
     126:	84 e0       	ldi	r24, 0x04	; 4
     128:	f8 07       	cpc	r31, r24
     12a:	c9 f7       	brne	.-14     	; 0x11e <mcu_init+0x4>
     12c:	e0 e3       	ldi	r30, 0x30	; 48
     12e:	f4 e0       	ldi	r31, 0x04	; 4
     130:	80 81       	ld	r24, Z
     132:	88 60       	ori	r24, 0x08	; 8
     134:	81 93       	st	Z+, r24
     136:	e8 33       	cpi	r30, 0x38	; 56
     138:	84 e0       	ldi	r24, 0x04	; 4
     13a:	f8 07       	cpc	r31, r24
     13c:	c9 f7       	brne	.-14     	; 0x130 <mcu_init+0x16>
     13e:	e0 e5       	ldi	r30, 0x50	; 80
     140:	f4 e0       	ldi	r31, 0x04	; 4
     142:	80 81       	ld	r24, Z
     144:	88 60       	ori	r24, 0x08	; 8
     146:	81 93       	st	Z+, r24
     148:	e8 35       	cpi	r30, 0x58	; 88
     14a:	84 e0       	ldi	r24, 0x04	; 4
     14c:	f8 07       	cpc	r31, r24
     14e:	c9 f7       	brne	.-14     	; 0x142 <mcu_init+0x28>
     150:	08 95       	ret

00000152 <ADC_initialization>:
     152:	e5 e1       	ldi	r30, 0x15	; 21
     154:	f4 e0       	ldi	r31, 0x04	; 4
     156:	80 81       	ld	r24, Z
     158:	88 7f       	andi	r24, 0xF8	; 248
     15a:	84 60       	ori	r24, 0x04	; 4
     15c:	80 83       	st	Z, r24
     15e:	80 81       	ld	r24, Z
     160:	87 7f       	andi	r24, 0xF7	; 247
     162:	80 83       	st	Z, r24
     164:	e7 e1       	ldi	r30, 0x17	; 23
     166:	f4 e0       	ldi	r31, 0x04	; 4
     168:	80 81       	ld	r24, Z
     16a:	88 7f       	andi	r24, 0xF8	; 248
     16c:	84 60       	ori	r24, 0x04	; 4
     16e:	80 83       	st	Z, r24
     170:	80 81       	ld	r24, Z
     172:	87 7f       	andi	r24, 0xF7	; 247
     174:	80 83       	st	Z, r24
     176:	e4 e3       	ldi	r30, 0x34	; 52
     178:	f4 e0       	ldi	r31, 0x04	; 4
     17a:	80 81       	ld	r24, Z
     17c:	88 7f       	andi	r24, 0xF8	; 248
     17e:	84 60       	ori	r24, 0x04	; 4
     180:	80 83       	st	Z, r24
     182:	80 81       	ld	r24, Z
     184:	87 7f       	andi	r24, 0xF7	; 247
     186:	80 83       	st	Z, r24
     188:	e1 e3       	ldi	r30, 0x31	; 49
     18a:	f4 e0       	ldi	r31, 0x04	; 4
     18c:	80 81       	ld	r24, Z
     18e:	88 7f       	andi	r24, 0xF8	; 248
     190:	84 60       	ori	r24, 0x04	; 4
     192:	80 83       	st	Z, r24
     194:	80 81       	ld	r24, Z
     196:	87 7f       	andi	r24, 0xF7	; 247
     198:	80 83       	st	Z, r24
     19a:	e0 e3       	ldi	r30, 0x30	; 48
     19c:	f4 e0       	ldi	r31, 0x04	; 4
     19e:	80 81       	ld	r24, Z
     1a0:	88 7f       	andi	r24, 0xF8	; 248
     1a2:	84 60       	ori	r24, 0x04	; 4
     1a4:	80 83       	st	Z, r24
     1a6:	80 81       	ld	r24, Z
     1a8:	87 7f       	andi	r24, 0xF7	; 247
     1aa:	80 83       	st	Z, r24
     1ac:	75 df       	rcall	.-278    	; 0x98 <ADC_init>
     1ae:	08 95       	ret

000001b0 <TIMER_0_initialization>:
     1b0:	25 9a       	sbi	0x04, 5	; 4
     1b2:	2d 98       	cbi	0x05, 5	; 5
     1b4:	e0 e0       	ldi	r30, 0x00	; 0
     1b6:	f2 e0       	ldi	r31, 0x02	; 2
     1b8:	82 81       	ldd	r24, Z+2	; 0x02
     1ba:	84 60       	ori	r24, 0x04	; 4
     1bc:	82 83       	std	Z+2, r24	; 0x02
     1be:	da d0       	rcall	.+436    	; 0x374 <TIMER_0_init>
     1c0:	08 95       	ret

000001c2 <DIGGSIGG_initialization>:
     1c2:	41 9a       	sbi	0x08, 1	; 8
     1c4:	49 98       	cbi	0x09, 1	; 9
     1c6:	e0 e0       	ldi	r30, 0x00	; 0
     1c8:	f2 e0       	ldi	r31, 0x02	; 2
     1ca:	80 81       	ld	r24, Z
     1cc:	80 62       	ori	r24, 0x20	; 32
     1ce:	80 83       	st	Z, r24
     1d0:	7f df       	rcall	.-258    	; 0xd0 <DIGGSIGG_init>
     1d2:	08 95       	ret

000001d4 <SPI_0_initialization>:
     1d4:	02 98       	cbi	0x00, 2	; 0
     1d6:	e2 e1       	ldi	r30, 0x12	; 18
     1d8:	f4 e0       	ldi	r31, 0x04	; 4
     1da:	80 81       	ld	r24, Z
     1dc:	87 7f       	andi	r24, 0xF7	; 247
     1de:	80 83       	st	Z, r24
     1e0:	01 9a       	sbi	0x00, 1	; 0
     1e2:	09 98       	cbi	0x01, 1	; 1
     1e4:	03 9a       	sbi	0x00, 3	; 0
     1e6:	0b 98       	cbi	0x01, 3	; 1
     1e8:	04 9a       	sbi	0x00, 4	; 0
     1ea:	0c 98       	cbi	0x01, 4	; 1
     1ec:	bb d0       	rcall	.+374    	; 0x364 <SPI_0_init>
     1ee:	08 95       	ret

000001f0 <system_init>:
/**
 * \brief System initialization
 */
void system_init()
{
	mcu_init();
     1f0:	94 df       	rcall	.-216    	; 0x11a <mcu_init>
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     1f2:	27 9a       	sbi	0x04, 7	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     1f4:	2f 98       	cbi	0x05, 7	; 5
 */
static inline void PORTC_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
     1f6:	42 98       	cbi	0x08, 2	; 8
static inline void PORTC_set_pin_pull_mode(const uint8_t pin, const enum port_pull_mode pull_mode)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
     1f8:	e2 e5       	ldi	r30, 0x52	; 82
     1fa:	f4 e0       	ldi	r31, 0x04	; 4
     1fc:	80 81       	ld	r24, Z
     1fe:	88 60       	ori	r24, 0x08	; 8
     200:	80 83       	st	Z, r24
	    // <id> pad_pull_config
	    // <PORT_PULL_OFF"> Off
	    // <PORT_PULL_UP"> Pull-up
	    PORT_PULL_UP);

	CLKCTRL_init();
     202:	74 df       	rcall	.-280    	; 0xec <CLKCTRL_init>

	RTC_init();
     204:	93 d0       	rcall	.+294    	; 0x32c <RTC_init>

	ADC_initialization();
     206:	a5 df       	rcall	.-182    	; 0x152 <ADC_initialization>

	TIMER_0_initialization();
     208:	d3 df       	rcall	.-90     	; 0x1b0 <TIMER_0_initialization>

	DIGGSIGG_initialization();
     20a:	db df       	rcall	.-74     	; 0x1c2 <DIGGSIGG_initialization>

	SPI_0_initialization();
     20c:	e3 df       	rcall	.-58     	; 0x1d4 <SPI_0_initialization>

/* configure pins and initialize registers */
void DAC_initialization(void)
{

	DAC_init();
     20e:	7d df       	rcall	.-262    	; 0x10a <DAC_init>

	SPI_0_initialization();

	DAC_initialization();

	CPUINT_init();
     210:	79 df       	rcall	.-270    	; 0x104 <CPUINT_init>

	SLPCTRL_init();
     212:	a6 d0       	rcall	.+332    	; 0x360 <SLPCTRL_init>

	BOD_init();
     214:	5b df       	rcall	.-330    	; 0xcc <BOD_init>
     216:	08 95       	ret

00000218 <protected_write_io>:
#if defined(__GNUC__)
  
#ifdef RAMPZ
	out     _SFR_IO_ADDR(RAMPZ), r1         // Clear bits 23:16 of Z
#endif
	movw    r30, r24                // Load addr into Z
     218:	fc 01       	movw	r30, r24
	out     CCP, r22                // Start CCP handshake
     21a:	64 bf       	out	0x34, r22	; 52
	st      Z, r20                  // Write value to I/O register
     21c:	40 83       	st	Z, r20
	ret                             // Return to caller
     21e:	08 95       	ret

00000220 <enqueue>:
 */ 
#include <stdio.h>
#include <stdlib.h>
#include "include/queue.h"

void enqueue(node_t **head, uint32_t val) {
     220:	cf 92       	push	r12
     222:	df 92       	push	r13
     224:	ef 92       	push	r14
     226:	ff 92       	push	r15
     228:	cf 93       	push	r28
     22a:	df 93       	push	r29
     22c:	ec 01       	movw	r28, r24
     22e:	6a 01       	movw	r12, r20
     230:	7b 01       	movw	r14, r22
	// remember, head is at the very BACK of the queue (The element that will wait the longest until dequeued)
	
	// we create a new empty node
	node_t *new_node = malloc(sizeof(node_t));
     232:	86 e0       	ldi	r24, 0x06	; 6
     234:	90 e0       	ldi	r25, 0x00	; 0
     236:	f5 d7       	rcall	.+4074   	; 0x1222 <malloc>
	// Not quite sure what happens here, but it seems to be some sort of error handling, except you never know if there has been an error :/
	if (!new_node) return;
     238:	00 97       	sbiw	r24, 0x00	; 0
     23a:	59 f0       	breq	.+22     	; 0x252 <enqueue+0x32>

	// we configure our node
	new_node->val = val;
     23c:	fc 01       	movw	r30, r24
     23e:	c0 82       	st	Z, r12
     240:	d1 82       	std	Z+1, r13	; 0x01
     242:	e2 82       	std	Z+2, r14	; 0x02
     244:	f3 82       	std	Z+3, r15	; 0x03
	new_node->next = *head;
     246:	28 81       	ld	r18, Y
     248:	39 81       	ldd	r19, Y+1	; 0x01
     24a:	24 83       	std	Z+4, r18	; 0x04
     24c:	35 83       	std	Z+5, r19	; 0x05

	// and lastly, we change the pointer pointing to the previous head node, to point to our new node instead
	*head = new_node;
     24e:	88 83       	st	Y, r24
     250:	99 83       	std	Y+1, r25	; 0x01
}
     252:	df 91       	pop	r29
     254:	cf 91       	pop	r28
     256:	ff 90       	pop	r15
     258:	ef 90       	pop	r14
     25a:	df 90       	pop	r13
     25c:	cf 90       	pop	r12
     25e:	08 95       	ret

00000260 <dequeue>:

uint32_t dequeue(node_t **head) {
     260:	cf 92       	push	r12
     262:	df 92       	push	r13
     264:	ef 92       	push	r14
     266:	ff 92       	push	r15
     268:	0f 93       	push	r16
     26a:	1f 93       	push	r17
     26c:	cf 93       	push	r28
     26e:	df 93       	push	r29
	node_t *current, *prev = NULL;
	uint32_t retval = 0;

	// If the queue we have been given is empty, we return an error
	// (0 is usually not an error, but it is probably the best option)
	if (*head == NULL) return 0;
     270:	dc 01       	movw	r26, r24
     272:	ed 91       	ld	r30, X+
     274:	fc 91       	ld	r31, X
     276:	30 97       	sbiw	r30, 0x00	; 0
     278:	11 f1       	breq	.+68     	; 0x2be <dequeue+0x5e>
     27a:	c0 e0       	ldi	r28, 0x00	; 0
     27c:	d0 e0       	ldi	r29, 0x00	; 0
     27e:	02 c0       	rjmp	.+4      	; 0x284 <dequeue+0x24>
     280:	ef 01       	movw	r28, r30

	// Now we iterate through the queue until we reach the end
	current = *head;
	while (current->next != NULL) {
		prev = current;
		current = current->next;
     282:	f9 01       	movw	r30, r18
	// (0 is usually not an error, but it is probably the best option)
	if (*head == NULL) return 0;

	// Now we iterate through the queue until we reach the end
	current = *head;
	while (current->next != NULL) {
     284:	24 81       	ldd	r18, Z+4	; 0x04
     286:	35 81       	ldd	r19, Z+5	; 0x05
     288:	21 15       	cp	r18, r1
     28a:	31 05       	cpc	r19, r1
     28c:	c9 f7       	brne	.-14     	; 0x280 <dequeue+0x20>
     28e:	8c 01       	movw	r16, r24
		prev = current;
		current = current->next;
	}

	// We retrieve the value we needed
	retval = current->val;
     290:	c0 80       	ld	r12, Z
     292:	d1 80       	ldd	r13, Z+1	; 0x01
     294:	e2 80       	ldd	r14, Z+2	; 0x02
     296:	f3 80       	ldd	r15, Z+3	; 0x03
	// and remove the last element of the queue from the queue
	free(current);
     298:	cf 01       	movw	r24, r30
     29a:	5b d8       	rcall	.-3914   	; 0xfffff352 <__eeprom_end+0xff7ef352>
	
	// Now we update the previous node so that it becomes the front of the queue
	// In case the queue only had one element, the prev will be null (false)
	if (prev){
     29c:	20 97       	sbiw	r28, 0x00	; 0
     29e:	39 f0       	breq	.+14     	; 0x2ae <dequeue+0x4e>
	prev->next = NULL;}
     2a0:	1c 82       	std	Y+4, r1	; 0x04
     2a2:	1d 82       	std	Y+5, r1	; 0x05
	else{
	*head = NULL;}

	return retval;
     2a4:	6c 2d       	mov	r22, r12
     2a6:	7d 2d       	mov	r23, r13
     2a8:	8e 2d       	mov	r24, r14
     2aa:	9f 2d       	mov	r25, r15
     2ac:	0c c0       	rjmp	.+24     	; 0x2c6 <dequeue+0x66>
	// Now we update the previous node so that it becomes the front of the queue
	// In case the queue only had one element, the prev will be null (false)
	if (prev){
	prev->next = NULL;}
	else{
	*head = NULL;}
     2ae:	f8 01       	movw	r30, r16
     2b0:	10 82       	st	Z, r1
     2b2:	11 82       	std	Z+1, r1	; 0x01

	return retval;
     2b4:	6c 2d       	mov	r22, r12
     2b6:	7d 2d       	mov	r23, r13
     2b8:	8e 2d       	mov	r24, r14
     2ba:	9f 2d       	mov	r25, r15
     2bc:	04 c0       	rjmp	.+8      	; 0x2c6 <dequeue+0x66>
	node_t *current, *prev = NULL;
	uint32_t retval = 0;

	// If the queue we have been given is empty, we return an error
	// (0 is usually not an error, but it is probably the best option)
	if (*head == NULL) return 0;
     2be:	60 e0       	ldi	r22, 0x00	; 0
     2c0:	70 e0       	ldi	r23, 0x00	; 0
     2c2:	80 e0       	ldi	r24, 0x00	; 0
     2c4:	90 e0       	ldi	r25, 0x00	; 0
	prev->next = NULL;}
	else{
	*head = NULL;}

	return retval;
}
     2c6:	df 91       	pop	r29
     2c8:	cf 91       	pop	r28
     2ca:	1f 91       	pop	r17
     2cc:	0f 91       	pop	r16
     2ce:	ff 90       	pop	r15
     2d0:	ef 90       	pop	r14
     2d2:	df 90       	pop	r13
     2d4:	cf 90       	pop	r12
     2d6:	08 95       	ret

000002d8 <dequeue_top>:

// Here we remove the element of the queue that was added last (first in, last out)
uint32_t dequeue_top(node_t **head){
     2d8:	cf 92       	push	r12
     2da:	df 92       	push	r13
     2dc:	ef 92       	push	r14
     2de:	ff 92       	push	r15
     2e0:	0f 93       	push	r16
     2e2:	1f 93       	push	r17
     2e4:	cf 93       	push	r28
     2e6:	df 93       	push	r29
	node_t *oldHead;
	uint32_t retval = 0;
	
	// If the queue we have been given is empty, we return an error
	// (0 is usually not an error, but it is probably the best option)
	if (*head == NULL) return 0;
     2e8:	dc 01       	movw	r26, r24
     2ea:	ed 91       	ld	r30, X+
     2ec:	fc 91       	ld	r31, X
     2ee:	30 97       	sbiw	r30, 0x00	; 0
     2f0:	81 f0       	breq	.+32     	; 0x312 <dequeue_top+0x3a>
     2f2:	ec 01       	movw	r28, r24
	
	oldHead = *head;
	// We then set the new head to be the second last in the queue
	newHead = oldHead->next;
     2f4:	c4 80       	ldd	r12, Z+4	; 0x04
     2f6:	d5 80       	ldd	r13, Z+5	; 0x05
	
	// We retrieve the heads value
	retval = oldHead->val;
     2f8:	e0 80       	ld	r14, Z
     2fa:	f1 80       	ldd	r15, Z+1	; 0x01
     2fc:	02 81       	ldd	r16, Z+2	; 0x02
     2fe:	13 81       	ldd	r17, Z+3	; 0x03
	
	// We free the memory that was used to store the old head
	free(oldHead);
     300:	cf 01       	movw	r24, r30
     302:	27 d8       	rcall	.-4018   	; 0xfffff352 <__eeprom_end+0xff7ef352>
	
	//And then we overwrite the value of head to be the second last
	*head = newHead;
     304:	c8 82       	st	Y, r12
     306:	d9 82       	std	Y+1, r13	; 0x01
	
	return retval;
     308:	6e 2d       	mov	r22, r14
     30a:	7f 2d       	mov	r23, r15
     30c:	80 2f       	mov	r24, r16
     30e:	91 2f       	mov	r25, r17
     310:	04 c0       	rjmp	.+8      	; 0x31a <dequeue_top+0x42>
	node_t *oldHead;
	uint32_t retval = 0;
	
	// If the queue we have been given is empty, we return an error
	// (0 is usually not an error, but it is probably the best option)
	if (*head == NULL) return 0;
     312:	60 e0       	ldi	r22, 0x00	; 0
     314:	70 e0       	ldi	r23, 0x00	; 0
     316:	80 e0       	ldi	r24, 0x00	; 0
     318:	90 e0       	ldi	r25, 0x00	; 0
	//And then we overwrite the value of head to be the second last
	*head = newHead;
	
	return retval;
	
}
     31a:	df 91       	pop	r29
     31c:	cf 91       	pop	r28
     31e:	1f 91       	pop	r17
     320:	0f 91       	pop	r16
     322:	ff 90       	pop	r15
     324:	ef 90       	pop	r14
     326:	df 90       	pop	r13
     328:	cf 90       	pop	r12
     32a:	08 95       	ret

0000032c <RTC_init>:
 * \return Initialization status.
 */
int8_t RTC_init()
{

	while (RTC.STATUS > 0) { /* Wait for all register to be synchronized */
     32c:	e0 e4       	ldi	r30, 0x40	; 64
     32e:	f1 e0       	ldi	r31, 0x01	; 1
     330:	81 81       	ldd	r24, Z+1	; 0x01
     332:	81 11       	cpse	r24, r1
     334:	fd cf       	rjmp	.-6      	; 0x330 <RTC_init+0x4>
	}

	// RTC.CMP = 0x0; /* Compare: 0x0 */

	RTC.CNT = 0x20; /* Counter: 0x20 */
     336:	e0 e4       	ldi	r30, 0x40	; 64
     338:	f1 e0       	ldi	r31, 0x01	; 1
     33a:	80 e2       	ldi	r24, 0x20	; 32
     33c:	90 e0       	ldi	r25, 0x00	; 0
     33e:	80 87       	std	Z+8, r24	; 0x08
     340:	91 87       	std	Z+9, r25	; 0x09

	RTC.CTRLA = RTC_PRESCALER_DIV1_gc   /* 1 */
     342:	21 e8       	ldi	r18, 0x81	; 129
     344:	20 83       	st	Z, r18
	            | 1 << RTC_RTCEN_bp     /* Enable: enabled */
	            | 1 << RTC_RUNSTDBY_bp; /* Run In Standby: enabled */

	RTC.PER = 0x20; /* Period: 0x20 */
     346:	82 87       	std	Z+10, r24	; 0x0a
     348:	93 87       	std	Z+11, r25	; 0x0b

	// RTC.CLKSEL = RTC_CLKSEL_INT32K_gc; /* 32KHz Internal Ultra Low Power Oscillator (OSCULP32K) */

	RTC.DBGCTRL = 1 << RTC_DBGRUN_bp; /* Run in debug: enabled */
     34a:	81 e0       	ldi	r24, 0x01	; 1
     34c:	85 83       	std	Z+5, r24	; 0x05

	RTC.INTCTRL = 0 << RTC_CMP_bp    /* Compare Match Interrupt enable: disabled */
     34e:	82 83       	std	Z+2, r24	; 0x02
	              | 1 << RTC_OVF_bp; /* Overflow Interrupt enable: enabled */

	while (RTC.PITSTATUS > 0) { /* Wait for all register to be synchronized */
     350:	81 89       	ldd	r24, Z+17	; 0x11
     352:	81 11       	cpse	r24, r1
     354:	fd cf       	rjmp	.-6      	; 0x350 <RTC_init+0x24>
	}

	RTC.PITCTRLA = RTC_PERIOD_OFF_gc    /* Off */
     356:	81 e0       	ldi	r24, 0x01	; 1
     358:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <__TEXT_REGION_LENGTH__+0x700150>
	// RTC.PITDBGCTRL = 0 << RTC_DBGRUN_bp; /* Run in debug: disabled */

	// RTC.PITINTCTRL = 0 << RTC_PI_bp; /* Periodic Interrupt: disabled */

	return 0;
}
     35c:	80 e0       	ldi	r24, 0x00	; 0
     35e:	08 95       	ret

00000360 <SLPCTRL_init>:

	// SLPCTRL.CTRLA = 0 << SLPCTRL_SEN_bp /* Sleep enable: disabled */
	//		 | SLPCTRL_SMODE_IDLE_gc; /* Idle mode */

	return 0;
}
     360:	80 e0       	ldi	r24, 0x00	; 0
     362:	08 95       	ret

00000364 <SPI_0_init>:
 * \return Initialization status
 */
int8_t SPI_0_init()
{

	SPI0.CTRLA = 0 << SPI_CLK2X_bp     /* Enable Double Speed: disabled */
     364:	e0 e2       	ldi	r30, 0x20	; 32
     366:	f8 e0       	ldi	r31, 0x08	; 8
     368:	83 e2       	ldi	r24, 0x23	; 35
     36a:	80 83       	st	Z, r24
	             | 0 << SPI_DORD_bp    /* Data Order Setting: disabled */
	             | 1 << SPI_ENABLE_bp  /* Enable Module: enabled */
	             | 1 << SPI_MASTER_bp  /* SPI module in master mode */
	             | SPI_PRESC_DIV16_gc; /* System Clock / 16 */

	SPI0.CTRLB = 0 << SPI_BUFEN_bp   /* Buffer Mode Enable: disabled */
     36c:	84 e0       	ldi	r24, 0x04	; 4
     36e:	81 83       	std	Z+1, r24	; 0x01
	//		 | 0 << SPI_RXCIE_bp /* Receive Complete Interrupt Enable: disabled */
	//		 | 0 << SPI_SSIE_bp /* Slave Select Trigger Interrupt Enable: disabled */
	//		 | 0 << SPI_TXCIE_bp; /* Transfer Complete Interrupt Enable: disabled */

	return 0;
}
     370:	80 e0       	ldi	r24, 0x00	; 0
     372:	08 95       	ret

00000374 <TIMER_0_init>:

	// TCA0.SINGLE.CMP0 = 0x0; /* Compare Register 0: 0x0 */

	// TCA0.SINGLE.CMP1 = 0x0; /* Compare Register 1: 0x0 */

	TCA0.SINGLE.CMP2 = 0x4; /* Compare Register 2: 0x4 */
     374:	e0 e0       	ldi	r30, 0x00	; 0
     376:	fa e0       	ldi	r31, 0x0A	; 10
     378:	84 e0       	ldi	r24, 0x04	; 4
     37a:	90 e0       	ldi	r25, 0x00	; 0
     37c:	84 a7       	std	Z+44, r24	; 0x2c
     37e:	95 a7       	std	Z+45, r25	; 0x2d

	// TCA0.SINGLE.CNT = 0x0; /* Count: 0x0 */

	TCA0.SINGLE.CTRLB = 0 << TCA_SINGLE_ALUPD_bp            /* Auto Lock Update: disabled */
     380:	83 e4       	ldi	r24, 0x43	; 67
     382:	81 83       	std	Z+1, r24	; 0x01
	                    | 0 << TCA_SINGLE_CMP0EN_bp         /* Compare 0 Enable: disabled */
	                    | 0 << TCA_SINGLE_CMP1EN_bp         /* Compare 1 Enable: disabled */
	                    | 1 << TCA_SINGLE_CMP2EN_bp         /* Compare 2 Enable: enabled */
	                    | TCA_SINGLE_WGMODE_SINGLESLOPE_gc; /*  */

	TCA0.SINGLE.CTRLC = 0 << TCA_SINGLE_CMP0OV_bp    /* Compare 0 Waveform Output Value: disabled */
     384:	84 e0       	ldi	r24, 0x04	; 4
     386:	82 83       	std	Z+2, r24	; 0x02
	// TCA0.SINGLE.INTCTRL = 0 << TCA_SINGLE_CMP0_bp /* Compare 0 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP1_bp /* Compare 1 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP2_bp /* Compare 2 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_OVF_bp; /* Overflow Interrupt: disabled */

	TCA0.SINGLE.PER = 0x7; /* Period: 0x7 */
     388:	87 e0       	ldi	r24, 0x07	; 7
     38a:	90 e0       	ldi	r25, 0x00	; 0
     38c:	86 a3       	std	Z+38, r24	; 0x26
     38e:	97 a3       	std	Z+39, r25	; 0x27

	// TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV1_gc /* System Clock */
	//		 | 0 << TCA_SINGLE_ENABLE_bp; /* Module Enable: disabled */

	return 0;
}
     390:	80 e0       	ldi	r24, 0x00	; 0
     392:	08 95       	ret

00000394 <tinyTime_counter_increment>:
If the Interrupt Service Routine is clocked by a crystal oscillator
it gives a very precise timer-counter.
*/
void tinyTime_counter_increment(void)
{
	time_counter++;
     394:	80 91 0c 3e 	lds	r24, 0x3E0C	; 0x803e0c <__data_end>
     398:	90 91 0d 3e 	lds	r25, 0x3E0D	; 0x803e0d <__data_end+0x1>
     39c:	a0 91 0e 3e 	lds	r26, 0x3E0E	; 0x803e0e <__data_end+0x2>
     3a0:	b0 91 0f 3e 	lds	r27, 0x3E0F	; 0x803e0f <__data_end+0x3>
     3a4:	01 96       	adiw	r24, 0x01	; 1
     3a6:	a1 1d       	adc	r26, r1
     3a8:	b1 1d       	adc	r27, r1
     3aa:	80 93 0c 3e 	sts	0x3E0C, r24	; 0x803e0c <__data_end>
     3ae:	90 93 0d 3e 	sts	0x3E0D, r25	; 0x803e0d <__data_end+0x1>
     3b2:	a0 93 0e 3e 	sts	0x3E0E, r26	; 0x803e0e <__data_end+0x2>
     3b6:	b0 93 0f 3e 	sts	0x3E0F, r27	; 0x803e0f <__data_end+0x3>
     3ba:	08 95       	ret

000003bc <tinyTime_now>:
/*
This function is callable by external libraries to give them the counted time so far.
*/
uint32_t tinyTime_now(void)
{
	return time_counter;
     3bc:	60 91 0c 3e 	lds	r22, 0x3E0C	; 0x803e0c <__data_end>
     3c0:	70 91 0d 3e 	lds	r23, 0x3E0D	; 0x803e0d <__data_end+0x1>
     3c4:	80 91 0e 3e 	lds	r24, 0x3E0E	; 0x803e0e <__data_end+0x2>
     3c8:	90 91 0f 3e 	lds	r25, 0x3E0F	; 0x803e0f <__data_end+0x3>
     3cc:	08 95       	ret

000003ce <main>:
#include "tinyTime/tinyTime.h"
#include "settings.h"


int main(void)
{
     3ce:	cf 93       	push	r28
     3d0:	df 93       	push	r29
     3d2:	00 d0       	rcall	.+0      	; 0x3d4 <main+0x6>
     3d4:	cd b7       	in	r28, 0x3d	; 61
     3d6:	de b7       	in	r29, 0x3e	; 62
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
     3d8:	5d de       	rcall	.-838    	; 0x94 <atmel_start_init>
	Setting this value will mean that the ADC (Analog to Digital Converter) will read 4.32v as 255, and 0v as 0.
	For some reason, instead of the reference voltage being 4.32v, it is 3.3v. 
	A plausible explanation is that the microchip does not up the voltage, so that if the microchip is only ever 
	supplied with 3.3v, it will output 3.3v as the max.
	*/
	VREF.CTRLB = VREF_ADC0REFSEL_4V34_gc;
     3da:	80 e3       	ldi	r24, 0x30	; 48
     3dc:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
	
	
	uint32_t current_cycle_time = 1;
	uint32_t previous_cycle_time = 0;
	uint16_t time_passed = 0;
	uint16_t volatile cycles=0;
     3e0:	19 82       	std	Y+1, r1	; 0x01
     3e2:	1a 82       	std	Y+2, r1	; 0x02
	
	tinyDendrite_set_neuron_type(NEURONTYPE);
     3e4:	80 e0       	ldi	r24, 0x00	; 0
     3e6:	92 d1       	rcall	.+804    	; 0x70c <tinyDendrite_set_neuron_type>
	*/
	VREF.CTRLB = VREF_ADC0REFSEL_4V34_gc;
	
	
	uint32_t current_cycle_time = 1;
	uint32_t previous_cycle_time = 0;
     3e8:	81 2c       	mov	r8, r1
     3ea:	91 2c       	mov	r9, r1
     3ec:	54 01       	movw	r10, r8
	
	tinyDendrite_set_neuron_type(NEURONTYPE);
	
	while (1)
	{
		if(tinyISR_getflag())
     3ee:	4c d3       	rcall	.+1688   	; 0xa88 <tinyISR_getflag>
     3f0:	88 23       	and	r24, r24
     3f2:	e9 f3       	breq	.-6      	; 0x3ee <main+0x20>
		{
			current_cycle_time = tinyTime_now();
     3f4:	e3 df       	rcall	.-58     	; 0x3bc <tinyTime_now>
     3f6:	6b 01       	movw	r12, r22
     3f8:	7c 01       	movw	r14, r24
			
			time_passed = current_cycle_time - previous_cycle_time;
			tinyPotential_update(time_passed);
     3fa:	68 19       	sub	r22, r8
     3fc:	79 09       	sbc	r23, r9
     3fe:	80 e0       	ldi	r24, 0x00	; 0
     400:	90 e0       	ldi	r25, 0x00	; 0
     402:	01 d5       	rcall	.+2562   	; 0xe06 <__floatunsisf>
     404:	5e d3       	rcall	.+1724   	; 0xac2 <tinyPotential_update>
			
			previous_cycle_time = current_cycle_time;
			cycles++;
     406:	89 81       	ldd	r24, Y+1	; 0x01
     408:	9a 81       	ldd	r25, Y+2	; 0x02
     40a:	01 96       	adiw	r24, 0x01	; 1
     40c:	89 83       	std	Y+1, r24	; 0x01
     40e:	9a 83       	std	Y+2, r25	; 0x02
			tinyISR_setflag(false);
     410:	80 e0       	ldi	r24, 0x00	; 0
     412:	37 d3       	rcall	.+1646   	; 0xa82 <tinyISR_setflag>
			current_cycle_time = tinyTime_now();
			
			time_passed = current_cycle_time - previous_cycle_time;
			tinyPotential_update(time_passed);
			
			previous_cycle_time = current_cycle_time;
     414:	46 01       	movw	r8, r12
     416:	57 01       	movw	r10, r14
     418:	ea cf       	rjmp	.-44     	; 0x3ee <main+0x20>

0000041a <set_LED_fire>:



//function to be called upon when firing flag has been raised.
void set_LED_fire(void)
{
     41a:	cf 93       	push	r28
	fire_flash_time_counter = tinyTime_now();
     41c:	cf df       	rcall	.-98     	; 0x3bc <tinyTime_now>
     41e:	60 93 10 3e 	sts	0x3E10, r22	; 0x803e10 <fire_flash_time_counter>
     422:	70 93 11 3e 	sts	0x3E11, r23	; 0x803e11 <fire_flash_time_counter+0x1>
     426:	80 93 12 3e 	sts	0x3E12, r24	; 0x803e12 <fire_flash_time_counter+0x2>
     42a:	90 93 13 3e 	sts	0x3E13, r25	; 0x803e13 <fire_flash_time_counter+0x3>
     42e:	c0 e0       	ldi	r28, 0x00	; 0
	for (int i = 0; i < NUMBER_OF_LEDS; i++)
	{
		tinyCCLRGB_setColor(i, MAX_BRIGHTNESS, MAX_BRIGHTNESS, MAX_BRIGHTNESS);//As per the specs, all LEDs should be blue while firing.
     430:	20 e3       	ldi	r18, 0x30	; 48
     432:	40 e3       	ldi	r20, 0x30	; 48
     434:	60 e3       	ldi	r22, 0x30	; 48
     436:	8c 2f       	mov	r24, r28
     438:	45 d1       	rcall	.+650    	; 0x6c4 <tinyCCLRGB_setColor>
     43a:	cf 5f       	subi	r28, 0xFF	; 255

//function to be called upon when firing flag has been raised.
void set_LED_fire(void)
{
	fire_flash_time_counter = tinyTime_now();
	for (int i = 0; i < NUMBER_OF_LEDS; i++)
     43c:	c6 30       	cpi	r28, 0x06	; 6
     43e:	c1 f7       	brne	.-16     	; 0x430 <set_LED_fire+0x16>
	{
		tinyCCLRGB_setColor(i, MAX_BRIGHTNESS, MAX_BRIGHTNESS, MAX_BRIGHTNESS);//As per the specs, all LEDs should be blue while firing.
	}
}
     440:	cf 91       	pop	r28
     442:	08 95       	ret

00000444 <potential_to_RGB_update_LEDs>:



void potential_to_RGB_update_LEDs(double potential)
{
     444:	8f 92       	push	r8
     446:	9f 92       	push	r9
     448:	af 92       	push	r10
     44a:	bf 92       	push	r11
     44c:	cf 92       	push	r12
     44e:	df 92       	push	r13
     450:	ef 92       	push	r14
     452:	ff 92       	push	r15
     454:	0f 93       	push	r16
     456:	1f 93       	push	r17
     458:	cf 93       	push	r28
     45a:	6b 01       	movw	r12, r22
     45c:	7c 01       	movw	r14, r24
	if ((tinyTime_now() - fire_flash_time_counter) < FIRE_FLASH_TIME)
     45e:	ae df       	rcall	.-164    	; 0x3bc <tinyTime_now>
     460:	00 91 10 3e 	lds	r16, 0x3E10	; 0x803e10 <fire_flash_time_counter>
     464:	10 91 11 3e 	lds	r17, 0x3E11	; 0x803e11 <fire_flash_time_counter+0x1>
     468:	20 91 12 3e 	lds	r18, 0x3E12	; 0x803e12 <fire_flash_time_counter+0x2>
     46c:	30 91 13 3e 	lds	r19, 0x3E13	; 0x803e13 <fire_flash_time_counter+0x3>
     470:	dc 01       	movw	r26, r24
     472:	cb 01       	movw	r24, r22
     474:	80 1b       	sub	r24, r16
     476:	91 0b       	sbc	r25, r17
     478:	a2 0b       	sbc	r26, r18
     47a:	b3 0b       	sbc	r27, r19
     47c:	84 36       	cpi	r24, 0x64	; 100
     47e:	91 05       	cpc	r25, r1
     480:	a1 05       	cpc	r26, r1
     482:	b1 05       	cpc	r27, r1
     484:	50 f4       	brcc	.+20     	; 0x49a <potential_to_RGB_update_LEDs+0x56>
     486:	c0 e0       	ldi	r28, 0x00	; 0
	{
		for (int i = 0; i < NUMBER_OF_LEDS; i++)
		{
			tinyCCLRGB_setColor(i, MAX_BRIGHTNESS, MAX_BRIGHTNESS, MAX_BRIGHTNESS);
     488:	20 e3       	ldi	r18, 0x30	; 48
     48a:	40 e3       	ldi	r20, 0x30	; 48
     48c:	60 e3       	ldi	r22, 0x30	; 48
     48e:	8c 2f       	mov	r24, r28
     490:	19 d1       	rcall	.+562    	; 0x6c4 <tinyCCLRGB_setColor>
     492:	cf 5f       	subi	r28, 0xFF	; 255

void potential_to_RGB_update_LEDs(double potential)
{
	if ((tinyTime_now() - fire_flash_time_counter) < FIRE_FLASH_TIME)
	{
		for (int i = 0; i < NUMBER_OF_LEDS; i++)
     494:	c6 30       	cpi	r28, 0x06	; 6
     496:	c1 f7       	brne	.-16     	; 0x488 <potential_to_RGB_update_LEDs+0x44>
     498:	53 c0       	rjmp	.+166    	; 0x540 <potential_to_RGB_update_LEDs+0xfc>
     49a:	c0 e0       	ldi	r28, 0x00	; 0
*/
static void potential_to_RGB_set_color(double potential)
{
	for (int i = 0; i < NUMBER_OF_LEDS; i++)
	{
		tinyCCLRGB_setColor(i, 0x0, 0x0, 0x0);//Clear all LED stored values on the MCU before writing again.
     49c:	20 e0       	ldi	r18, 0x00	; 0
     49e:	40 e0       	ldi	r20, 0x00	; 0
     4a0:	60 e0       	ldi	r22, 0x00	; 0
     4a2:	8c 2f       	mov	r24, r28
     4a4:	0f d1       	rcall	.+542    	; 0x6c4 <tinyCCLRGB_setColor>
     4a6:	cf 5f       	subi	r28, 0xFF	; 255
When firing all lights turn blue for ~100ms, but this needs to be tested.
LEDs are numbered right way on top of PCB, but opposite way on bottom of PCB.
*/
static void potential_to_RGB_set_color(double potential)
{
	for (int i = 0; i < NUMBER_OF_LEDS; i++)
     4a8:	c6 30       	cpi	r28, 0x06	; 6
     4aa:	c1 f7       	brne	.-16     	; 0x49c <potential_to_RGB_update_LEDs+0x58>
	{
		tinyCCLRGB_setColor(i, 0x0, 0x0, 0x0);//Clear all LED stored values on the MCU before writing again.
	}
	double absolute_potential = abs(potential);//setting variable for absolute potential so it won't have to be calculated more than once.
     4ac:	c7 01       	movw	r24, r14
     4ae:	b6 01       	movw	r22, r12
     4b0:	74 d4       	rcall	.+2280   	; 0xd9a <__fixsfsi>
     4b2:	9b 01       	movw	r18, r22
     4b4:	77 23       	and	r23, r23
     4b6:	24 f4       	brge	.+8      	; 0x4c0 <potential_to_RGB_update_LEDs+0x7c>
     4b8:	22 27       	eor	r18, r18
     4ba:	33 27       	eor	r19, r19
     4bc:	26 1b       	sub	r18, r22
     4be:	37 0b       	sbc	r19, r23
     4c0:	b9 01       	movw	r22, r18
     4c2:	33 0f       	add	r19, r19
     4c4:	88 0b       	sbc	r24, r24
     4c6:	99 0b       	sbc	r25, r25
     4c8:	a0 d4       	rcall	.+2368   	; 0xe0a <__floatsisf>
     4ca:	4b 01       	movw	r8, r22
     4cc:	5c 01       	movw	r10, r24
	if (absolute_potential < 1)//set the middle lights as white both top side and bottom side.
     4ce:	20 e0       	ldi	r18, 0x00	; 0
     4d0:	30 e0       	ldi	r19, 0x00	; 0
     4d2:	40 e8       	ldi	r20, 0x80	; 128
     4d4:	5f e3       	ldi	r21, 0x3F	; 63
     4d6:	b0 d3       	rcall	.+1888   	; 0xc38 <__cmpsf2>
     4d8:	88 23       	and	r24, r24
     4da:	34 f4       	brge	.+12     	; 0x4e8 <potential_to_RGB_update_LEDs+0xa4>
	{
		tinyCCLRGB_setColor(2, MAX_BRIGHTNESS/3, MAX_BRIGHTNESS/3, MAX_BRIGHTNESS/3);
     4dc:	20 e1       	ldi	r18, 0x10	; 16
     4de:	40 e1       	ldi	r20, 0x10	; 16
     4e0:	60 e1       	ldi	r22, 0x10	; 16
     4e2:	82 e0       	ldi	r24, 0x02	; 2
     4e4:	ef d0       	rcall	.+478    	; 0x6c4 <tinyCCLRGB_setColor>
     4e6:	2c c0       	rjmp	.+88     	; 0x540 <potential_to_RGB_update_LEDs+0xfc>
		//tinyCCLRGB_setColor(4, max_brightness/3, max_brightness/3, max_brightness/3);
	}
	else
	{
		uint8_t brightness_intensity = round((absolute_potential/25)*MAX_BRIGHTNESS);//brightness intensity for the LED that shows potential.
     4e8:	20 e0       	ldi	r18, 0x00	; 0
     4ea:	30 e0       	ldi	r19, 0x00	; 0
     4ec:	48 ec       	ldi	r20, 0xC8	; 200
     4ee:	51 e4       	ldi	r21, 0x41	; 65
     4f0:	c5 01       	movw	r24, r10
     4f2:	b4 01       	movw	r22, r8
     4f4:	a6 d3       	rcall	.+1868   	; 0xc42 <__divsf3>
     4f6:	20 e0       	ldi	r18, 0x00	; 0
     4f8:	30 e0       	ldi	r19, 0x00	; 0
     4fa:	40 e4       	ldi	r20, 0x40	; 64
     4fc:	52 e4       	ldi	r21, 0x42	; 66
     4fe:	d7 d5       	rcall	.+2990   	; 0x10ae <__mulsf3>
     500:	43 d6       	rcall	.+3206   	; 0x1188 <round>
     502:	52 d4       	rcall	.+2212   	; 0xda8 <__fixunssfsi>
     504:	c6 2f       	mov	r28, r22
		if (potential < 0)
     506:	20 e0       	ldi	r18, 0x00	; 0
     508:	30 e0       	ldi	r19, 0x00	; 0
     50a:	a9 01       	movw	r20, r18
     50c:	c7 01       	movw	r24, r14
     50e:	b6 01       	movw	r22, r12
     510:	93 d3       	rcall	.+1830   	; 0xc38 <__cmpsf2>
     512:	88 23       	and	r24, r24
     514:	5c f4       	brge	.+22     	; 0x52c <potential_to_RGB_update_LEDs+0xe8>
		{
			tinyCCLRGB_setColor(0, brightness_intensity, 0x0, 0x0);
     516:	20 e0       	ldi	r18, 0x00	; 0
     518:	40 e0       	ldi	r20, 0x00	; 0
     51a:	6c 2f       	mov	r22, r28
     51c:	80 e0       	ldi	r24, 0x00	; 0
     51e:	d2 d0       	rcall	.+420    	; 0x6c4 <tinyCCLRGB_setColor>
			tinyCCLRGB_setColor(1, brightness_intensity, 0x0, 0x0);//sets lower LEDs red if potential is negative.
     520:	20 e0       	ldi	r18, 0x00	; 0
     522:	40 e0       	ldi	r20, 0x00	; 0
     524:	6c 2f       	mov	r22, r28
     526:	81 e0       	ldi	r24, 0x01	; 1
     528:	cd d0       	rcall	.+410    	; 0x6c4 <tinyCCLRGB_setColor>
     52a:	0a c0       	rjmp	.+20     	; 0x540 <potential_to_RGB_update_LEDs+0xfc>
		} 
		else
		{
			tinyCCLRGB_setColor(3, 0x0, brightness_intensity, 0x0);//sets upper LEDs green if potential is positive.
     52c:	20 e0       	ldi	r18, 0x00	; 0
     52e:	4c 2f       	mov	r20, r28
     530:	60 e0       	ldi	r22, 0x00	; 0
     532:	83 e0       	ldi	r24, 0x03	; 3
     534:	c7 d0       	rcall	.+398    	; 0x6c4 <tinyCCLRGB_setColor>
			tinyCCLRGB_setColor(4, 0x0, brightness_intensity, 0x0);
     536:	20 e0       	ldi	r18, 0x00	; 0
     538:	4c 2f       	mov	r20, r28
     53a:	60 e0       	ldi	r22, 0x00	; 0
     53c:	84 e0       	ldi	r24, 0x04	; 4
     53e:	c2 d0       	rcall	.+388    	; 0x6c4 <tinyCCLRGB_setColor>
	}
	else
	{
		potential_to_RGB_set_color(potential);
	}
	tinyCCLRGB_uploadColorsToLeds();
     540:	ce d0       	rcall	.+412    	; 0x6de <tinyCCLRGB_uploadColorsToLeds>
}
     542:	cf 91       	pop	r28
     544:	1f 91       	pop	r17
     546:	0f 91       	pop	r16
     548:	ff 90       	pop	r15
     54a:	ef 90       	pop	r14
     54c:	df 90       	pop	r13
     54e:	cf 90       	pop	r12
     550:	bf 90       	pop	r11
     552:	af 90       	pop	r10
     554:	9f 90       	pop	r9
     556:	8f 90       	pop	r8
     558:	08 95       	ret

0000055a <tinyButton_get_state>:
Master-function for button-checking, returns 2 if the neuron should spontaneously fire.
Returns 1 if the system has received a button push shorter than two seconds.
Returns 0 if the button is still pushed in, or it has not yet received a button push.
*/
_Bool tinyButton_get_state(void)
{
     55a:	0f 93       	push	r16
     55c:	1f 93       	push	r17
     55e:	cf 93       	push	r28
     560:	df 93       	push	r29
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTC_get_pin_level(const uint8_t pin)
{
	return VPORTC.IN & (1 << pin);
     562:	8a b1       	in	r24, 0x0a	; 10
function changes state of button_spont_pulse, if button has been held down for 2 secs.
*/
static _Bool tinyButton_check(void)
{
	_Bool re_var = false;
	_Bool button_is_pushed_down = !Button_get_level();//the digital port will be read as low if the button is pushed down.
     564:	d1 e0       	ldi	r29, 0x01	; 1
     566:	c8 2f       	mov	r28, r24
     568:	c4 70       	andi	r28, 0x04	; 4
     56a:	82 fd       	sbrc	r24, 2
     56c:	d0 e0       	ldi	r29, 0x00	; 0
	if (!button_is_pushed_down && !button_was_pushed_down)//button is not pushed down, and was not pushed down
	{
		re_var = false;
	}
	if (button_is_pushed_down && !button_was_pushed_down)
     56e:	c1 11       	cpse	r28, r1
     570:	34 c0       	rjmp	.+104    	; 0x5da <tinyButton_get_state+0x80>
     572:	80 91 19 3e 	lds	r24, 0x3E19	; 0x803e19 <button_was_pushed_down>
     576:	81 11       	cpse	r24, r1
     578:	0d c0       	rjmp	.+26     	; 0x594 <tinyButton_get_state+0x3a>
	{
		tinyButton_start_time = tinyTime_now();
     57a:	20 df       	rcall	.-448    	; 0x3bc <tinyTime_now>
     57c:	60 93 15 3e 	sts	0x3E15, r22	; 0x803e15 <tinyButton_start_time>
     580:	70 93 16 3e 	sts	0x3E16, r23	; 0x803e16 <tinyButton_start_time+0x1>
     584:	80 93 17 3e 	sts	0x3E17, r24	; 0x803e17 <tinyButton_start_time+0x2>
     588:	90 93 18 3e 	sts	0x3E18, r25	; 0x803e18 <tinyButton_start_time+0x3>
		re_var = false;
	}
	if (button_is_pushed_down && button_was_pushed_down)
     58c:	80 91 19 3e 	lds	r24, 0x3E19	; 0x803e19 <button_was_pushed_down>
     590:	88 23       	and	r24, r24
     592:	19 f1       	breq	.+70     	; 0x5da <tinyButton_get_state+0x80>
	{
		if ((tinyTime_now() - tinyButton_start_time) > 2000)
     594:	13 df       	rcall	.-474    	; 0x3bc <tinyTime_now>
     596:	00 91 15 3e 	lds	r16, 0x3E15	; 0x803e15 <tinyButton_start_time>
     59a:	10 91 16 3e 	lds	r17, 0x3E16	; 0x803e16 <tinyButton_start_time+0x1>
     59e:	20 91 17 3e 	lds	r18, 0x3E17	; 0x803e17 <tinyButton_start_time+0x2>
     5a2:	30 91 18 3e 	lds	r19, 0x3E18	; 0x803e18 <tinyButton_start_time+0x3>
     5a6:	dc 01       	movw	r26, r24
     5a8:	cb 01       	movw	r24, r22
     5aa:	80 1b       	sub	r24, r16
     5ac:	91 0b       	sbc	r25, r17
     5ae:	a2 0b       	sbc	r26, r18
     5b0:	b3 0b       	sbc	r27, r19
     5b2:	81 3d       	cpi	r24, 0xD1	; 209
     5b4:	97 40       	sbci	r25, 0x07	; 7
     5b6:	a1 05       	cpc	r26, r1
     5b8:	b1 05       	cpc	r27, r1
     5ba:	78 f0       	brcs	.+30     	; 0x5da <tinyButton_get_state+0x80>
tinyButton_toggle_spont_pulse changes the state of the boolean value determining
if the neuron is in spontaneous fire-mode or not.
*/
static void tinyButton_toggle_spont_pulse(void)
{
	tinyButton_spont_pulse = !tinyButton_spont_pulse;
     5bc:	90 91 14 3e 	lds	r25, 0x3E14	; 0x803e14 <tinyButton_spont_pulse>
     5c0:	81 e0       	ldi	r24, 0x01	; 1
     5c2:	89 27       	eor	r24, r25
     5c4:	80 93 14 3e 	sts	0x3E14, r24	; 0x803e14 <tinyButton_spont_pulse>
	if (button_is_pushed_down && button_was_pushed_down)
	{
		if ((tinyTime_now() - tinyButton_start_time) > 2000)
		{
			tinyButton_toggle_spont_pulse();
			tinyButton_start_time = tinyTime_now();
     5c8:	f9 de       	rcall	.-526    	; 0x3bc <tinyTime_now>
     5ca:	60 93 15 3e 	sts	0x3E15, r22	; 0x803e15 <tinyButton_start_time>
     5ce:	70 93 16 3e 	sts	0x3E16, r23	; 0x803e16 <tinyButton_start_time+0x1>
     5d2:	80 93 17 3e 	sts	0x3E17, r24	; 0x803e17 <tinyButton_start_time+0x2>
     5d6:	90 93 18 3e 	sts	0x3E18, r25	; 0x803e18 <tinyButton_start_time+0x3>
		}
		re_var = false;
	}
	if (!button_is_pushed_down && button_was_pushed_down)
     5da:	cc 23       	and	r28, r28
     5dc:	19 f0       	breq	.+6      	; 0x5e4 <tinyButton_get_state+0x8a>
     5de:	80 91 19 3e 	lds	r24, 0x3E19	; 0x803e19 <button_was_pushed_down>
     5e2:	01 c0       	rjmp	.+2      	; 0x5e6 <tinyButton_get_state+0x8c>
     5e4:	80 e0       	ldi	r24, 0x00	; 0
	{
		re_var = true;
	}
	button_was_pushed_down = button_is_pushed_down;
     5e6:	d0 93 19 3e 	sts	0x3E19, r29	; 0x803e19 <button_was_pushed_down>
Returns 0 if the button is still pushed in, or it has not yet received a button push.
*/
_Bool tinyButton_get_state(void)
{
	return tinyButton_check();
}
     5ea:	df 91       	pop	r29
     5ec:	cf 91       	pop	r28
     5ee:	1f 91       	pop	r17
     5f0:	0f 91       	pop	r16
     5f2:	08 95       	ret

000005f4 <tinyButton_is_spont_pulse_on>:

_Bool tinyButton_is_spont_pulse_on(void)
{
	return tinyButton_spont_pulse;
}
     5f4:	80 91 14 3e 	lds	r24, 0x3E14	; 0x803e14 <tinyButton_spont_pulse>
     5f8:	08 95       	ret

000005fa <spont_pulse_delta_potential>:
/*
Callable function from outside the module, should be called every main loop cycle
while spontaneous pulse mode is active and will then return the change in potential.
*/
uint8_t spont_pulse_delta_potential(void)
{
     5fa:	0f 93       	push	r16
     5fc:	1f 93       	push	r17
Function to determine whether a spontaneous pulse
should increase the membrane potential or not.
*/
static _Bool spont_pulse(void)
{
	if ((tinyTime_now() - spont_pulse_timer_counter) > SPONT_PULSE_PERIOD*2)
     5fe:	de de       	rcall	.-580    	; 0x3bc <tinyTime_now>
     600:	00 91 1b 3e 	lds	r16, 0x3E1B	; 0x803e1b <spont_pulse_timer_counter>
     604:	10 91 1c 3e 	lds	r17, 0x3E1C	; 0x803e1c <spont_pulse_timer_counter+0x1>
     608:	20 91 1d 3e 	lds	r18, 0x3E1D	; 0x803e1d <spont_pulse_timer_counter+0x2>
     60c:	30 91 1e 3e 	lds	r19, 0x3E1E	; 0x803e1e <spont_pulse_timer_counter+0x3>
     610:	dc 01       	movw	r26, r24
     612:	cb 01       	movw	r24, r22
     614:	80 1b       	sub	r24, r16
     616:	91 0b       	sbc	r25, r17
     618:	a2 0b       	sbc	r26, r18
     61a:	b3 0b       	sbc	r27, r19
     61c:	89 3e       	cpi	r24, 0xE9	; 233
     61e:	93 40       	sbci	r25, 0x03	; 3
     620:	a1 05       	cpc	r26, r1
     622:	b1 05       	cpc	r27, r1
     624:	88 f0       	brcs	.+34     	; 0x648 <spont_pulse_delta_potential+0x4e>
/*
Function to initiate spontaneous pulse mode.
*/
static void spont_pulse_start(void)
{
	spont_pulse_out = true;
     626:	81 e0       	ldi	r24, 0x01	; 1
     628:	80 93 1a 3e 	sts	0x3E1A, r24	; 0x803e1a <spont_pulse_out>
	spont_pulse_timer_counter = tinyTime_now();
     62c:	c7 de       	rcall	.-626    	; 0x3bc <tinyTime_now>
     62e:	60 93 1b 3e 	sts	0x3E1B, r22	; 0x803e1b <spont_pulse_timer_counter>
     632:	70 93 1c 3e 	sts	0x3E1C, r23	; 0x803e1c <spont_pulse_timer_counter+0x1>
     636:	80 93 1d 3e 	sts	0x3E1D, r24	; 0x803e1d <spont_pulse_timer_counter+0x2>
     63a:	90 93 1e 3e 	sts	0x3E1E, r25	; 0x803e1e <spont_pulse_timer_counter+0x3>
Callable function from outside the module, should be called every main loop cycle
while spontaneous pulse mode is active and will then return the change in potential.
*/
uint8_t spont_pulse_delta_potential(void)
{
	if (spont_pulse())
     63e:	80 91 1a 3e 	lds	r24, 0x3E1A	; 0x803e1a <spont_pulse_out>
     642:	81 11       	cpse	r24, r1
     644:	27 c0       	rjmp	.+78     	; 0x694 <spont_pulse_delta_potential+0x9a>
     646:	27 c0       	rjmp	.+78     	; 0x696 <spont_pulse_delta_potential+0x9c>
/*
Function to check if a second has passed since last pulse out.
*/
static void spont_pulse_time_check(void)
{
	if ((tinyTime_now() - spont_pulse_timer_counter) > SPONT_PULSE_PERIOD)
     648:	b9 de       	rcall	.-654    	; 0x3bc <tinyTime_now>
     64a:	00 91 1b 3e 	lds	r16, 0x3E1B	; 0x803e1b <spont_pulse_timer_counter>
     64e:	10 91 1c 3e 	lds	r17, 0x3E1C	; 0x803e1c <spont_pulse_timer_counter+0x1>
     652:	20 91 1d 3e 	lds	r18, 0x3E1D	; 0x803e1d <spont_pulse_timer_counter+0x2>
     656:	30 91 1e 3e 	lds	r19, 0x3E1E	; 0x803e1e <spont_pulse_timer_counter+0x3>
     65a:	dc 01       	movw	r26, r24
     65c:	cb 01       	movw	r24, r22
     65e:	80 1b       	sub	r24, r16
     660:	91 0b       	sbc	r25, r17
     662:	a2 0b       	sbc	r26, r18
     664:	b3 0b       	sbc	r27, r19
     666:	85 3f       	cpi	r24, 0xF5	; 245
     668:	91 40       	sbci	r25, 0x01	; 1
     66a:	a1 05       	cpc	r26, r1
     66c:	b1 05       	cpc	r27, r1
     66e:	70 f0       	brcs	.+28     	; 0x68c <spont_pulse_delta_potential+0x92>
	{
		spont_pulse_timer_counter = tinyTime_now();
     670:	a5 de       	rcall	.-694    	; 0x3bc <tinyTime_now>
     672:	60 93 1b 3e 	sts	0x3E1B, r22	; 0x803e1b <spont_pulse_timer_counter>
     676:	70 93 1c 3e 	sts	0x3E1C, r23	; 0x803e1c <spont_pulse_timer_counter+0x1>
     67a:	80 93 1d 3e 	sts	0x3E1D, r24	; 0x803e1d <spont_pulse_timer_counter+0x2>
     67e:	90 93 1e 3e 	sts	0x3E1E, r25	; 0x803e1e <spont_pulse_timer_counter+0x3>
		spont_pulse_out = true;
     682:	81 e0       	ldi	r24, 0x01	; 1
     684:	80 93 1a 3e 	sts	0x3E1A, r24	; 0x803e1a <spont_pulse_out>
*/
uint8_t spont_pulse_delta_potential(void)
{
	if (spont_pulse())
	{
		return 26;
     688:	8a e1       	ldi	r24, 0x1A	; 26
     68a:	05 c0       	rjmp	.+10     	; 0x696 <spont_pulse_delta_potential+0x9c>
		spont_pulse_timer_counter = tinyTime_now();
		spont_pulse_out = true;
	}
	else
	{
		spont_pulse_out = false;
     68c:	10 92 1a 3e 	sts	0x3E1A, r1	; 0x803e1a <spont_pulse_out>
	{
		return 26;
	}
	else
	{
		return 0;
     690:	80 e0       	ldi	r24, 0x00	; 0
     692:	01 c0       	rjmp	.+2      	; 0x696 <spont_pulse_delta_potential+0x9c>
*/
uint8_t spont_pulse_delta_potential(void)
{
	if (spont_pulse())
	{
		return 26;
     694:	8a e1       	ldi	r24, 0x1A	; 26
	}
	else
	{
		return 0;
	}
}
     696:	1f 91       	pop	r17
     698:	0f 91       	pop	r16
     69a:	08 95       	ret

0000069c <tinyCCLRGB_SPIWriteByte>:
Function used to send a byte over SPI, which in turn gets
translated to the bit-sequence required by the LEDs over the CCL.
*/
static void tinyCCLRGB_SPIWriteByte(uint8_t byte)
{
	SPI0.INTFLAGS = SPI0_INTFLAGS; // clear the write collision flag to allow writing
     69c:	90 91 23 08 	lds	r25, 0x0823	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
     6a0:	90 93 23 08 	sts	0x0823, r25	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
	TCA0.SINGLE.CNT = 0; // reset TCA counter register to ensure the first rising edge of the PWM is predictable
     6a4:	e0 e0       	ldi	r30, 0x00	; 0
     6a6:	fa e0       	ldi	r31, 0x0A	; 10
     6a8:	10 a2       	std	Z+32, r1	; 0x20
     6aa:	11 a2       	std	Z+33, r1	; 0x21
	
	// start TCA
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 1 << TCA_SPLIT_ENABLE_bp;
     6ac:	91 e0       	ldi	r25, 0x01	; 1
     6ae:	90 83       	st	Z, r25
	SPI0_DATA = byte;
     6b0:	80 93 24 08 	sts	0x0824, r24	; 0x800824 <__TEXT_REGION_LENGTH__+0x700824>

	while((SPI0.INTFLAGS & SPI_RXCIE_bm) == 0){} // wait for transfer to complete
     6b4:	e0 e2       	ldi	r30, 0x20	; 32
     6b6:	f8 e0       	ldi	r31, 0x08	; 8
     6b8:	83 81       	ldd	r24, Z+3	; 0x03
     6ba:	88 23       	and	r24, r24
     6bc:	ec f7       	brge	.-6      	; 0x6b8 <tinyCCLRGB_SPIWriteByte+0x1c>
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 0 << TCA_SPLIT_ENABLE_bp; //Stop TCA
     6be:	10 92 00 0a 	sts	0x0A00, r1	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
     6c2:	08 95       	ret

000006c4 <tinyCCLRGB_setColor>:
/*
changes the values in the variables stored in the led-array.
*/
void tinyCCLRGB_setColor(uint8_t led, uint8_t red, uint8_t green, uint8_t blue) 
{
	tinyCCLRGB_colors[led].red = red;
     6c4:	90 e0       	ldi	r25, 0x00	; 0
     6c6:	fc 01       	movw	r30, r24
     6c8:	ee 0f       	add	r30, r30
     6ca:	ff 1f       	adc	r31, r31
     6cc:	8e 0f       	add	r24, r30
     6ce:	9f 1f       	adc	r25, r31
     6d0:	fc 01       	movw	r30, r24
     6d2:	e1 5e       	subi	r30, 0xE1	; 225
     6d4:	f1 4c       	sbci	r31, 0xC1	; 193
     6d6:	60 83       	st	Z, r22
	tinyCCLRGB_colors[led].green = green;
     6d8:	41 83       	std	Z+1, r20	; 0x01
	tinyCCLRGB_colors[led].blue = blue;
     6da:	22 83       	std	Z+2, r18	; 0x02
     6dc:	08 95       	ret

000006de <tinyCCLRGB_uploadColorsToLeds>:
/*
function to write the current LED-array on to the LEDs and
effectively update the values stored in the LEDs to the values stored in the MCU.
*/
void tinyCCLRGB_uploadColorsToLeds(void)
{
     6de:	0f 93       	push	r16
     6e0:	1f 93       	push	r17
     6e2:	cf 93       	push	r28
     6e4:	df 93       	push	r29
     6e6:	cf e1       	ldi	r28, 0x1F	; 31
     6e8:	de e3       	ldi	r29, 0x3E	; 62
     6ea:	01 e3       	ldi	r16, 0x31	; 49
     6ec:	1e e3       	ldi	r17, 0x3E	; 62
	for (uint8_t i = 0; i < TINYCCLRGB_LEDCOUNT; i++)
	{
		//For some reason unknown to the writer the data-bus to the LEDs is serialized as GRB
		//which means the 24-bit data-bus will look like [Green[0:7], Red[0:7], Blue[0:7]]
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].green);
     6ee:	89 81       	ldd	r24, Y+1	; 0x01
     6f0:	d5 df       	rcall	.-86     	; 0x69c <tinyCCLRGB_SPIWriteByte>
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].red);
     6f2:	88 81       	ld	r24, Y
     6f4:	d3 df       	rcall	.-90     	; 0x69c <tinyCCLRGB_SPIWriteByte>
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].blue);
     6f6:	8a 81       	ldd	r24, Y+2	; 0x02
     6f8:	d1 df       	rcall	.-94     	; 0x69c <tinyCCLRGB_SPIWriteByte>
     6fa:	23 96       	adiw	r28, 0x03	; 3
function to write the current LED-array on to the LEDs and
effectively update the values stored in the LEDs to the values stored in the MCU.
*/
void tinyCCLRGB_uploadColorsToLeds(void)
{
	for (uint8_t i = 0; i < TINYCCLRGB_LEDCOUNT; i++)
     6fc:	c0 17       	cp	r28, r16
     6fe:	d1 07       	cpc	r29, r17
     700:	b1 f7       	brne	.-20     	; 0x6ee <tinyCCLRGB_uploadColorsToLeds+0x10>
		//which means the 24-bit data-bus will look like [Green[0:7], Red[0:7], Blue[0:7]]
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].green);
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].red);
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].blue);
	}
}
     702:	df 91       	pop	r29
     704:	cf 91       	pop	r28
     706:	1f 91       	pop	r17
     708:	0f 91       	pop	r16
     70a:	08 95       	ret

0000070c <tinyDendrite_set_neuron_type>:


//sets neuron type
void tinyDendrite_set_neuron_type(enum NeuronType neuron_type)
{
	this_neurons_type = neuron_type;
     70c:	91 e0       	ldi	r25, 0x01	; 1
     70e:	81 11       	cpse	r24, r1
     710:	01 c0       	rjmp	.+2      	; 0x714 <tinyDendrite_set_neuron_type+0x8>
     712:	90 e0       	ldi	r25, 0x00	; 0
     714:	90 93 35 3e 	sts	0x3E35, r25	; 0x803e35 <this_neurons_type>
     718:	08 95       	ret

0000071a <tinyAxon_remove_pulse>:
/*
solution to remove future firing if a inhibitory signal is received
shortly after a excitatory signal.
*/
bool tinyAxon_remove_pulse(void)
{
     71a:	cf 92       	push	r12
     71c:	df 92       	push	r13
     71e:	ef 92       	push	r14
     720:	ff 92       	push	r15
	// We want to remove the pulse last added to the queue
	// We also want to return a bool indicating whether or not a pulse actually was removed
	uint32_t now = tinyTime_now();
     722:	4c de       	rcall	.-872    	; 0x3bc <tinyTime_now>
     724:	6b 01       	movw	r12, r22
     726:	7c 01       	movw	r14, r24
	uint32_t pulse_time = dequeue_top(&pulse_queue);
     728:	82 e3       	ldi	r24, 0x32	; 50
     72a:	9e e3       	ldi	r25, 0x3E	; 62
     72c:	d5 dd       	rcall	.-1110   	; 0x2d8 <dequeue_top>
	if(pulse_time == 0){ // Here 0 is regarded as an error
     72e:	61 15       	cp	r22, r1
     730:	71 05       	cpc	r23, r1
     732:	81 05       	cpc	r24, r1
     734:	91 05       	cpc	r25, r1
     736:	c1 f0       	breq	.+48     	; 0x768 <tinyAxon_remove_pulse+0x4e>
		return false;
	}
	
	// Now we want to check if the pulse is too far away to be affected by the low potential, or close enough that we decide to remove it
	// (When we say that the pulse is too far away, it refers to the biological process of how the potential spreads from dendrites to axon)
	else if((now + UNDO_PERIOD) < pulse_time){
     738:	2c e3       	ldi	r18, 0x3C	; 60
     73a:	c2 0e       	add	r12, r18
     73c:	d1 1c       	adc	r13, r1
     73e:	e1 1c       	adc	r14, r1
     740:	f1 1c       	adc	r15, r1
     742:	c6 16       	cp	r12, r22
     744:	d7 06       	cpc	r13, r23
     746:	e8 06       	cpc	r14, r24
     748:	f9 06       	cpc	r15, r25
     74a:	38 f4       	brcc	.+14     	; 0x75a <tinyAxon_remove_pulse+0x40>
		// We decided to remove the pulse
		pulses_in_queue--;
     74c:	80 91 34 3e 	lds	r24, 0x3E34	; 0x803e34 <pulses_in_queue>
     750:	81 50       	subi	r24, 0x01	; 1
     752:	80 93 34 3e 	sts	0x3E34, r24	; 0x803e34 <pulses_in_queue>
		return true;
     756:	81 e0       	ldi	r24, 0x01	; 1
     758:	08 c0       	rjmp	.+16     	; 0x76a <tinyAxon_remove_pulse+0x50>
	}
	// Here we have found that the is a pulse queued, but it is old enough to let pass anyway, so now we need to put it back into the queue
	else{
		enqueue(&pulse_queue, pulse_time);
     75a:	ab 01       	movw	r20, r22
     75c:	bc 01       	movw	r22, r24
     75e:	82 e3       	ldi	r24, 0x32	; 50
     760:	9e e3       	ldi	r25, 0x3E	; 62
     762:	5e dd       	rcall	.-1348   	; 0x220 <enqueue>
		return false;
     764:	80 e0       	ldi	r24, 0x00	; 0
     766:	01 c0       	rjmp	.+2      	; 0x76a <tinyAxon_remove_pulse+0x50>
	// We also want to return a bool indicating whether or not a pulse actually was removed
	uint32_t now = tinyTime_now();
	uint32_t pulse_time = dequeue_top(&pulse_queue);
	if(pulse_time == 0){ // Here 0 is regarded as an error
		//There was no pulse to remove
		return false;
     768:	80 e0       	ldi	r24, 0x00	; 0
	// Here we have found that the is a pulse queued, but it is old enough to let pass anyway, so now we need to put it back into the queue
	else{
		enqueue(&pulse_queue, pulse_time);
		return false;
	}
}
     76a:	ff 90       	pop	r15
     76c:	ef 90       	pop	r14
     76e:	df 90       	pop	r13
     770:	cf 90       	pop	r12
     772:	08 95       	ret

00000774 <tinyAxon_update_potential>:
/*
Decides whether or not the axon should fire
If the axon does fire, the potential is drastically reduced
*/
double tinyAxon_update_potential(double potential)
{
     774:	4f 92       	push	r4
     776:	5f 92       	push	r5
     778:	6f 92       	push	r6
     77a:	7f 92       	push	r7
     77c:	8f 92       	push	r8
     77e:	9f 92       	push	r9
     780:	af 92       	push	r10
     782:	bf 92       	push	r11
     784:	cf 92       	push	r12
     786:	df 92       	push	r13
     788:	ef 92       	push	r14
     78a:	ff 92       	push	r15
     78c:	cf 93       	push	r28
     78e:	df 93       	push	r29
     790:	6b 01       	movw	r12, r22
     792:	7c 01       	movw	r14, r24
	int pulse_nr = 0;
	uint32_t now = tinyTime_now();
     794:	13 de       	rcall	.-986    	; 0x3bc <tinyTime_now>
     796:	2b 01       	movw	r4, r22
     798:	3c 01       	movw	r6, r24
	
	//While the neuron has enough potential to fire, we want to fire more
	while (potential > 25)
     79a:	20 e0       	ldi	r18, 0x00	; 0
     79c:	30 e0       	ldi	r19, 0x00	; 0
     79e:	48 ec       	ldi	r20, 0xC8	; 200
     7a0:	51 e4       	ldi	r21, 0x41	; 65
     7a2:	c7 01       	movw	r24, r14
     7a4:	b6 01       	movw	r22, r12
     7a6:	08 d4       	rcall	.+2064   	; 0xfb8 <__gesf2>
     7a8:	18 16       	cp	r1, r24
     7aa:	5c f5       	brge	.+86     	; 0x802 <tinyAxon_update_potential+0x8e>
     7ac:	c0 e0       	ldi	r28, 0x00	; 0
     7ae:	d0 e0       	ldi	r29, 0x00	; 0
/*
Adds an element to the queue
*/
static void tinyAxon_enqueue_pulse(uint32_t new_pulse)
{
	enqueue(&pulse_queue, new_pulse);
     7b0:	53 01       	movw	r10, r6
     7b2:	42 01       	movw	r8, r4
     7b4:	84 e6       	ldi	r24, 0x64	; 100
     7b6:	88 0e       	add	r8, r24
     7b8:	91 1c       	adc	r9, r1
     7ba:	a1 1c       	adc	r10, r1
     7bc:	b1 1c       	adc	r11, r1
     7be:	ae 01       	movw	r20, r28
     7c0:	0d 2e       	mov	r0, r29
     7c2:	00 0c       	add	r0, r0
     7c4:	66 0b       	sbc	r22, r22
     7c6:	77 0b       	sbc	r23, r23
     7c8:	48 0d       	add	r20, r8
     7ca:	59 1d       	adc	r21, r9
     7cc:	6a 1d       	adc	r22, r10
     7ce:	7b 1d       	adc	r23, r11
     7d0:	82 e3       	ldi	r24, 0x32	; 50
     7d2:	9e e3       	ldi	r25, 0x3E	; 62
     7d4:	25 dd       	rcall	.-1462   	; 0x220 <enqueue>
	pulses_in_queue++;
     7d6:	80 91 34 3e 	lds	r24, 0x3E34	; 0x803e34 <pulses_in_queue>
     7da:	8f 5f       	subi	r24, 0xFF	; 255
     7dc:	80 93 34 3e 	sts	0x3E34, r24	; 0x803e34 <pulses_in_queue>
	{
		tinyAxon_enqueue_pulse(now + TRAVLE_DELAY + FIRE_DELAY*pulse_nr);
		pulse_nr++;
		
		// I want to test reducing the potential by 30 instead of 25 to simulate the hyperpolarization
		potential -= 30;
     7e0:	20 e0       	ldi	r18, 0x00	; 0
     7e2:	30 e0       	ldi	r19, 0x00	; 0
     7e4:	40 ef       	ldi	r20, 0xF0	; 240
     7e6:	51 e4       	ldi	r21, 0x41	; 65
     7e8:	c7 01       	movw	r24, r14
     7ea:	b6 01       	movw	r22, r12
     7ec:	b8 d1       	rcall	.+880    	; 0xb5e <__subsf3>
     7ee:	6b 01       	movw	r12, r22
     7f0:	7c 01       	movw	r14, r24
     7f2:	e2 96       	adiw	r28, 0x32	; 50
{
	int pulse_nr = 0;
	uint32_t now = tinyTime_now();
	
	//While the neuron has enough potential to fire, we want to fire more
	while (potential > 25)
     7f4:	20 e0       	ldi	r18, 0x00	; 0
     7f6:	30 e0       	ldi	r19, 0x00	; 0
     7f8:	48 ec       	ldi	r20, 0xC8	; 200
     7fa:	51 e4       	ldi	r21, 0x41	; 65
     7fc:	dd d3       	rcall	.+1978   	; 0xfb8 <__gesf2>
     7fe:	18 16       	cp	r1, r24
     800:	f4 f2       	brlt	.-68     	; 0x7be <tinyAxon_update_potential+0x4a>
		// I want to test reducing the potential by 30 instead of 25 to simulate the hyperpolarization
		potential -= 30;
	}
	
	// If the neuron has a very low potential, we want to remove a pulse from the queue (if there is one)
	if(potential < -25 && pulses_in_queue > 0)
     802:	20 e0       	ldi	r18, 0x00	; 0
     804:	30 e0       	ldi	r19, 0x00	; 0
     806:	48 ec       	ldi	r20, 0xC8	; 200
     808:	51 ec       	ldi	r21, 0xC1	; 193
     80a:	c7 01       	movw	r24, r14
     80c:	b6 01       	movw	r22, r12
     80e:	14 d2       	rcall	.+1064   	; 0xc38 <__cmpsf2>
     810:	88 23       	and	r24, r24
     812:	84 f4       	brge	.+32     	; 0x834 <tinyAxon_update_potential+0xc0>
     814:	80 91 34 3e 	lds	r24, 0x3E34	; 0x803e34 <pulses_in_queue>
     818:	88 23       	and	r24, r24
     81a:	79 f1       	breq	.+94     	; 0x87a <tinyAxon_update_potential+0x106>
	{
		// The neurons potential is low enough to attempt to remove a queued fire (Fire less)
		if(tinyAxon_remove_pulse())
     81c:	7e df       	rcall	.-260    	; 0x71a <tinyAxon_remove_pulse>
     81e:	88 23       	and	r24, r24
     820:	49 f0       	breq	.+18     	; 0x834 <tinyAxon_update_potential+0xc0>
		{
			// The potential has evened out a bit
			potential += 25;
     822:	20 e0       	ldi	r18, 0x00	; 0
     824:	30 e0       	ldi	r19, 0x00	; 0
     826:	48 ec       	ldi	r20, 0xC8	; 200
     828:	51 e4       	ldi	r21, 0x41	; 65
     82a:	c7 01       	movw	r24, r14
     82c:	b6 01       	movw	r22, r12
     82e:	98 d1       	rcall	.+816    	; 0xb60 <__addsf3>
     830:	6b 01       	movw	r12, r22
     832:	7c 01       	movw	r14, r24
		}
	}
	
	// If there are pulses in the queue, and the pulse has been scheduled to fire
	if ((pulses_in_queue > 0) && (next_pulse <= now))
     834:	80 91 34 3e 	lds	r24, 0x3E34	; 0x803e34 <pulses_in_queue>
     838:	88 23       	and	r24, r24
     83a:	f9 f0       	breq	.+62     	; 0x87a <tinyAxon_update_potential+0x106>
     83c:	40 91 56 3e 	lds	r20, 0x3E56	; 0x803e56 <next_pulse>
     840:	50 91 57 3e 	lds	r21, 0x3E57	; 0x803e57 <next_pulse+0x1>
     844:	60 91 58 3e 	lds	r22, 0x3E58	; 0x803e58 <next_pulse+0x2>
     848:	70 91 59 3e 	lds	r23, 0x3E59	; 0x803e59 <next_pulse+0x3>
     84c:	44 16       	cp	r4, r20
     84e:	55 06       	cpc	r5, r21
     850:	66 06       	cpc	r6, r22
     852:	77 06       	cpc	r7, r23
     854:	90 f0       	brcs	.+36     	; 0x87a <tinyAxon_update_potential+0x106>
Function to set firing.
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
     856:	91 e0       	ldi	r25, 0x01	; 1
     858:	90 93 36 3e 	sts	0x3E36, r25	; 0x803e36 <tinyAxon_should_fire>
	pulses_in_queue--;
     85c:	81 50       	subi	r24, 0x01	; 1
     85e:	80 93 34 3e 	sts	0x3E34, r24	; 0x803e34 <pulses_in_queue>
	next_pulse = dequeue(&pulse_queue);
     862:	82 e3       	ldi	r24, 0x32	; 50
     864:	9e e3       	ldi	r25, 0x3E	; 62
     866:	fc dc       	rcall	.-1544   	; 0x260 <dequeue>
     868:	60 93 56 3e 	sts	0x3E56, r22	; 0x803e56 <next_pulse>
     86c:	70 93 57 3e 	sts	0x3E57, r23	; 0x803e57 <next_pulse+0x1>
     870:	80 93 58 3e 	sts	0x3E58, r24	; 0x803e58 <next_pulse+0x2>
     874:	90 93 59 3e 	sts	0x3E59, r25	; 0x803e59 <next_pulse+0x3>
	// If there are pulses in the queue, and the pulse has been scheduled to fire
	if ((pulses_in_queue > 0) && (next_pulse <= now))
	{
		// We fire the axon
		tinyAxon_fire_pulse();
		set_LED_fire();
     878:	d0 dd       	rcall	.-1120   	; 0x41a <set_LED_fire>
The function should set the DAC to fire for two
update cycles once the pulse flag is set high.
*/
static void tinyAxon_update_pulse_transmitter(void)
{
	if (tinyAxon_should_fire)
     87a:	80 91 36 3e 	lds	r24, 0x3E36	; 0x803e36 <tinyAxon_should_fire>
     87e:	88 23       	and	r24, r24
     880:	b9 f0       	breq	.+46     	; 0x8b0 <tinyAxon_update_potential+0x13c>
	{
		tinyAxon_should_fire = false;
     882:	10 92 36 3e 	sts	0x3E36, r1	; 0x803e36 <tinyAxon_should_fire>
		tinyAxon_has_fired = true;
     886:	81 e0       	ldi	r24, 0x01	; 1
     888:	80 93 37 3e 	sts	0x3E37, r24	; 0x803e37 <tinyAxon_has_fired>
Pulse send function.
sends a pulse dependent on the neurons type.
*/
static void tinyAxon_start_sending_pulse()
{
	if (this_neurons_type == EXCITATORY_NEURON)
     88c:	80 91 35 3e 	lds	r24, 0x3E35	; 0x803e35 <this_neurons_type>
     890:	81 11       	cpse	r24, r1
     892:	07 c0       	rjmp	.+14     	; 0x8a2 <tinyAxon_update_potential+0x12e>
	{
		DAC_set_output(255);
     894:	8f ef       	ldi	r24, 0xFF	; 255
     896:	90 e0       	ldi	r25, 0x00	; 0
     898:	3d dc       	rcall	.-1926   	; 0x114 <DAC_set_output>
		axonOutputValue=225;
     89a:	81 ee       	ldi	r24, 0xE1	; 225
     89c:	80 93 31 3e 	sts	0x3E31, r24	; 0x803e31 <axonOutputValue>
     8a0:	13 c0       	rjmp	.+38     	; 0x8c8 <tinyAxon_update_potential+0x154>
	}
	else if(this_neurons_type == INHIBITORY_NEURON)
	{
		DAC_set_output(128);
     8a2:	80 e8       	ldi	r24, 0x80	; 128
     8a4:	90 e0       	ldi	r25, 0x00	; 0
     8a6:	36 dc       	rcall	.-1940   	; 0x114 <DAC_set_output>
		axonOutputValue=128;
     8a8:	80 e8       	ldi	r24, 0x80	; 128
     8aa:	80 93 31 3e 	sts	0x3E31, r24	; 0x803e31 <axonOutputValue>
     8ae:	0c c0       	rjmp	.+24     	; 0x8c8 <tinyAxon_update_potential+0x154>
		tinyAxon_should_fire = false;
		tinyAxon_has_fired = true;
		
		tinyAxon_start_sending_pulse();
	}
	else if (tinyAxon_has_fired)
     8b0:	80 91 37 3e 	lds	r24, 0x3E37	; 0x803e37 <tinyAxon_has_fired>
     8b4:	88 23       	and	r24, r24
     8b6:	19 f0       	breq	.+6      	; 0x8be <tinyAxon_update_potential+0x14a>
	{
		tinyAxon_has_fired = false;
     8b8:	10 92 37 3e 	sts	0x3E37, r1	; 0x803e37 <tinyAxon_has_fired>
     8bc:	05 c0       	rjmp	.+10     	; 0x8c8 <tinyAxon_update_potential+0x154>
}

static void tinyAxon_stop_sending_pulse()
{
	
	DAC_set_output(0);
     8be:	80 e0       	ldi	r24, 0x00	; 0
     8c0:	90 e0       	ldi	r25, 0x00	; 0
     8c2:	28 dc       	rcall	.-1968   	; 0x114 <DAC_set_output>
	axonOutputValue=0;
     8c4:	10 92 31 3e 	sts	0x3E31, r1	; 0x803e31 <axonOutputValue>
	}
	
	// Here we set the actual output of the DAC (Digital to Analog Converter)
	tinyAxon_update_pulse_transmitter();
	return potential;
}
     8c8:	c7 01       	movw	r24, r14
     8ca:	b6 01       	movw	r22, r12
     8cc:	df 91       	pop	r29
     8ce:	cf 91       	pop	r28
     8d0:	ff 90       	pop	r15
     8d2:	ef 90       	pop	r14
     8d4:	df 90       	pop	r13
     8d6:	cf 90       	pop	r12
     8d8:	bf 90       	pop	r11
     8da:	af 90       	pop	r10
     8dc:	9f 90       	pop	r9
     8de:	8f 90       	pop	r8
     8e0:	7f 90       	pop	r7
     8e2:	6f 90       	pop	r6
     8e4:	5f 90       	pop	r5
     8e6:	4f 90       	pop	r4
     8e8:	08 95       	ret

000008ea <tinyDendrite_get_potential>:
/*
This is the master function of the module that is callable from
outside. It uses the previously declared functions to return the potential.
*/
int16_t tinyDendrite_get_potential()
{
     8ea:	8f 92       	push	r8
     8ec:	9f 92       	push	r9
     8ee:	af 92       	push	r10
     8f0:	bf 92       	push	r11
     8f2:	cf 92       	push	r12
     8f4:	df 92       	push	r13
     8f6:	ef 92       	push	r14
     8f8:	ff 92       	push	r15
     8fa:	0f 93       	push	r16
     8fc:	1f 93       	push	r17
     8fe:	cf 93       	push	r28
     900:	df 93       	push	r29
     902:	0f 2e       	mov	r0, r31
     904:	f6 e0       	ldi	r31, 0x06	; 6
     906:	ef 2e       	mov	r14, r31
     908:	fe e3       	ldi	r31, 0x3E	; 62
     90a:	ff 2e       	mov	r15, r31
     90c:	f0 2d       	mov	r31, r0
     90e:	02 e4       	ldi	r16, 0x42	; 66
     910:	1e e3       	ldi	r17, 0x3E	; 62
     912:	0f 2e       	mov	r0, r31
     914:	fc e4       	ldi	r31, 0x4C	; 76
     916:	cf 2e       	mov	r12, r31
     918:	fe e3       	ldi	r31, 0x3E	; 62
     91a:	df 2e       	mov	r13, r31
     91c:	f0 2d       	mov	r31, r0
     91e:	e8 01       	movw	r28, r16
*/
static void tinyDendrite_read_signals(void)
{
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_values[i] = ADC_get_conversion(dendrite_ports[i]);
     920:	f7 01       	movw	r30, r14
     922:	81 91       	ld	r24, Z+
     924:	7f 01       	movw	r14, r30
     926:	c1 db       	rcall	.-2174   	; 0xaa <ADC_get_conversion>
     928:	89 93       	st	Y+, r24
     92a:	99 93       	st	Y+, r25
/*
This function reads the voltage at the dendrite inputs with the ADC
*/
static void tinyDendrite_read_signals(void)
{
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
     92c:	cc 15       	cp	r28, r12
     92e:	dd 05       	cpc	r29, r13
     930:	b9 f7       	brne	.-18     	; 0x920 <tinyDendrite_get_potential+0x36>
     932:	ad e3       	ldi	r26, 0x3D	; 61
     934:	be e3       	ldi	r27, 0x3E	; 62
     936:	68 e3       	ldi	r22, 0x38	; 56
     938:	7e e3       	ldi	r23, 0x3E	; 62
     93a:	42 e4       	ldi	r20, 0x42	; 66
     93c:	5e e3       	ldi	r21, 0x3E	; 62
     93e:	fd 01       	movw	r30, r26
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     940:	aa 24       	eor	r10, r10
     942:	a3 94       	inc	r10
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
		}
		else if (tinyDendrite_values[i] > HIGH_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
     944:	0f 2e       	mov	r0, r31
     946:	f3 e0       	ldi	r31, 0x03	; 3
     948:	bf 2e       	mov	r11, r31
     94a:	f0 2d       	mov	r31, r0
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     94c:	68 94       	set
     94e:	cc 24       	eor	r12, r12
     950:	c1 f8       	bld	r12, 1
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     952:	68 94       	set
     954:	dd 24       	eor	r13, r13
     956:	d2 f8       	bld	r13, 2
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     958:	0f 2e       	mov	r0, r31
     95a:	f6 e0       	ldi	r31, 0x06	; 6
     95c:	ef 2e       	mov	r14, r31
     95e:	f0 2d       	mov	r31, r0
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
		if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     960:	0f 2e       	mov	r0, r31
     962:	f5 e0       	ldi	r31, 0x05	; 5
     964:	ff 2e       	mov	r15, r31
     966:	f0 2d       	mov	r31, r0
     968:	4f 01       	movw	r8, r30
*/
static void tinyDendrite_update_signals(void)
{
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
     96a:	80 81       	ld	r24, Z
     96c:	eb 01       	movw	r28, r22
     96e:	89 93       	st	Y+, r24
     970:	be 01       	movw	r22, r28
		if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
     972:	e8 01       	movw	r28, r16
     974:	29 91       	ld	r18, Y+
     976:	39 91       	ld	r19, Y+
     978:	8e 01       	movw	r16, r28
     97a:	26 3d       	cpi	r18, 0xD6	; 214
     97c:	31 05       	cpc	r19, r1
     97e:	10 f0       	brcs	.+4      	; 0x984 <tinyDendrite_get_potential+0x9a>
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     980:	f0 82       	st	Z, r15
     982:	1a c0       	rjmp	.+52     	; 0x9b8 <tinyDendrite_get_potential+0xce>
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
     984:	21 3a       	cpi	r18, 0xA1	; 161
     986:	31 05       	cpc	r19, r1
     988:	10 f0       	brcs	.+4      	; 0x98e <tinyDendrite_get_potential+0xa4>
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     98a:	e0 82       	st	Z, r14
     98c:	15 c0       	rjmp	.+42     	; 0x9b8 <tinyDendrite_get_potential+0xce>
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
     98e:	2c 38       	cpi	r18, 0x8C	; 140
     990:	31 05       	cpc	r19, r1
     992:	10 f0       	brcs	.+4      	; 0x998 <tinyDendrite_get_potential+0xae>
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     994:	d0 82       	st	Z, r13
     996:	10 c0       	rjmp	.+32     	; 0x9b8 <tinyDendrite_get_potential+0xce>
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
     998:	23 37       	cpi	r18, 0x73	; 115
     99a:	31 05       	cpc	r19, r1
     99c:	10 f0       	brcs	.+4      	; 0x9a2 <tinyDendrite_get_potential+0xb8>
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     99e:	c0 82       	st	Z, r12
     9a0:	0b c0       	rjmp	.+22     	; 0x9b8 <tinyDendrite_get_potential+0xce>
		}
		else if (tinyDendrite_values[i] > HIGH_INHIB_THRESHOLD)
     9a2:	28 35       	cpi	r18, 0x58	; 88
     9a4:	31 05       	cpc	r19, r1
     9a6:	10 f0       	brcs	.+4      	; 0x9ac <tinyDendrite_get_potential+0xc2>
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
     9a8:	b0 82       	st	Z, r11
     9aa:	06 c0       	rjmp	.+12     	; 0x9b8 <tinyDendrite_get_potential+0xce>
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
     9ac:	23 33       	cpi	r18, 0x33	; 51
     9ae:	31 05       	cpc	r19, r1
     9b0:	10 f0       	brcs	.+4      	; 0x9b6 <tinyDendrite_get_potential+0xcc>
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     9b2:	a0 82       	st	Z, r10
     9b4:	01 c0       	rjmp	.+2      	; 0x9b8 <tinyDendrite_get_potential+0xce>
		}
		else
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     9b6:	10 82       	st	Z, r1
		}
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
     9b8:	e4 01       	movw	r28, r8
     9ba:	98 81       	ld	r25, Y
     9bc:	89 13       	cpse	r24, r25
     9be:	01 c0       	rjmp	.+2      	; 0x9c2 <tinyDendrite_get_potential+0xd8>
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     9c0:	18 82       	st	Y, r1
     9c2:	31 96       	adiw	r30, 0x01	; 1
/*
This function converts the 8 bit value from the ADC into one of the signal types defined in DendriteSignal
*/
static void tinyDendrite_update_signals(void)
{
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
     9c4:	e4 17       	cp	r30, r20
     9c6:	f5 07       	cpc	r31, r21
     9c8:	79 f6       	brne	.-98     	; 0x968 <tinyDendrite_get_potential+0x7e>
     9ca:	20 e0       	ldi	r18, 0x00	; 0
     9cc:	30 e0       	ldi	r19, 0x00	; 0
	tinyDendrite_update_signals();
	
	int16_t return_potential_val = 0;
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		switch(tinyDendrite_current_signals[i])
     9ce:	9d 91       	ld	r25, X+
     9d0:	93 30       	cpi	r25, 0x03	; 3
     9d2:	a1 f0       	breq	.+40     	; 0x9fc <tinyDendrite_get_potential+0x112>
     9d4:	28 f4       	brcc	.+10     	; 0x9e0 <tinyDendrite_get_potential+0xf6>
     9d6:	91 30       	cpi	r25, 0x01	; 1
     9d8:	b9 f0       	breq	.+46     	; 0xa08 <tinyDendrite_get_potential+0x11e>
     9da:	92 30       	cpi	r25, 0x02	; 2
     9dc:	91 f0       	breq	.+36     	; 0xa02 <tinyDendrite_get_potential+0x118>
     9de:	16 c0       	rjmp	.+44     	; 0xa0c <tinyDendrite_get_potential+0x122>
     9e0:	95 30       	cpi	r25, 0x05	; 5
     9e2:	31 f0       	breq	.+12     	; 0x9f0 <tinyDendrite_get_potential+0x106>
     9e4:	40 f0       	brcs	.+16     	; 0x9f6 <tinyDendrite_get_potential+0x10c>
     9e6:	96 30       	cpi	r25, 0x06	; 6
     9e8:	89 f4       	brne	.+34     	; 0xa0c <tinyDendrite_get_potential+0x122>
		{
			case NO_SIGNAL:
				return_potential_val += NO_SIGNAL_REACTION;
				break;
			case HIGH_EXCITE:
				return_potential_val += HIGH_EXCITE_REACTION;
     9ea:	2c 5c       	subi	r18, 0xCC	; 204
     9ec:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     9ee:	0e c0       	rjmp	.+28     	; 0xa0c <tinyDendrite_get_potential+0x122>
			case NORMAL_EXCITE:
				return_potential_val += NORMAL_EXCITE_REACTION;
     9f0:	26 5e       	subi	r18, 0xE6	; 230
     9f2:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     9f4:	0b c0       	rjmp	.+22     	; 0xa0c <tinyDendrite_get_potential+0x122>
			case LOW_EXCITE:
				return_potential_val += LOW_EXCITE_REACTION;
     9f6:	2c 5e       	subi	r18, 0xEC	; 236
     9f8:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     9fa:	08 c0       	rjmp	.+16     	; 0xa0c <tinyDendrite_get_potential+0x122>
			case HIGH_INHIB:
				return_potential_val += HIGH_INHIB_REACTION;
     9fc:	22 53       	subi	r18, 0x32	; 50
     9fe:	31 09       	sbc	r19, r1
				break;
     a00:	05 c0       	rjmp	.+10     	; 0xa0c <tinyDendrite_get_potential+0x122>
			case NORMAL_INHIB:
				return_potential_val += NORMAL_INHIB_REACTION;
     a02:	2a 51       	subi	r18, 0x1A	; 26
     a04:	31 09       	sbc	r19, r1
				break;
     a06:	02 c0       	rjmp	.+4      	; 0xa0c <tinyDendrite_get_potential+0x122>
			case LOW_INHIB:
				return_potential_val += LOW_INHIB_REACTION;
     a08:	24 51       	subi	r18, 0x14	; 20
     a0a:	31 09       	sbc	r19, r1
	tinyDendrite_read_signals();
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
	
	int16_t return_potential_val = 0;
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
     a0c:	a4 17       	cp	r26, r20
     a0e:	b5 07       	cpc	r27, r21
     a10:	f1 f6       	brne	.-68     	; 0x9ce <tinyDendrite_get_potential+0xe4>
			default:
				break;
		}
	}
	return return_potential_val;
}
     a12:	c9 01       	movw	r24, r18
     a14:	df 91       	pop	r29
     a16:	cf 91       	pop	r28
     a18:	1f 91       	pop	r17
     a1a:	0f 91       	pop	r16
     a1c:	ff 90       	pop	r15
     a1e:	ef 90       	pop	r14
     a20:	df 90       	pop	r13
     a22:	cf 90       	pop	r12
     a24:	bf 90       	pop	r11
     a26:	af 90       	pop	r10
     a28:	9f 90       	pop	r9
     a2a:	8f 90       	pop	r8
     a2c:	08 95       	ret

00000a2e <__vector_6>:
This function is called every time the RTC (Real Time Clock) counter overflows.
With the current settings, it will be called every ms.
The RTC clock runs at 1kHz, and the number of cycles before overflow is set with RTC.PER = someHexValue (e.g. 0x20) in src/rtc.c
*/
ISR(RTC_CNT_vect)
{
     a2e:	1f 92       	push	r1
     a30:	0f 92       	push	r0
     a32:	0f b6       	in	r0, 0x3f	; 63
     a34:	0f 92       	push	r0
     a36:	11 24       	eor	r1, r1
     a38:	2f 93       	push	r18
     a3a:	3f 93       	push	r19
     a3c:	4f 93       	push	r20
     a3e:	5f 93       	push	r21
     a40:	6f 93       	push	r22
     a42:	7f 93       	push	r23
     a44:	8f 93       	push	r24
     a46:	9f 93       	push	r25
     a48:	af 93       	push	r26
     a4a:	bf 93       	push	r27
     a4c:	cf 93       	push	r28
     a4e:	ef 93       	push	r30
     a50:	ff 93       	push	r31
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     a52:	c1 e0       	ldi	r28, 0x01	; 1
     a54:	c0 93 4c 3e 	sts	0x3E4C, r28	; 0x803e4c <tinyISR_interrupt_flag>
{
	// Set flag to let main loop run a new cycle
	tinyISR_setflag(true);
	
	// Timer counter incrementation
	tinyTime_counter_increment();
     a58:	9d dc       	rcall	.-1734   	; 0x394 <tinyTime_counter_increment>

	/* Overflow interrupt flag has to be cleared manually */
	RTC.INTFLAGS = RTC_OVF_bm;
     a5a:	c0 93 43 01 	sts	0x0143, r28	; 0x800143 <__TEXT_REGION_LENGTH__+0x700143>
}
     a5e:	ff 91       	pop	r31
     a60:	ef 91       	pop	r30
     a62:	cf 91       	pop	r28
     a64:	bf 91       	pop	r27
     a66:	af 91       	pop	r26
     a68:	9f 91       	pop	r25
     a6a:	8f 91       	pop	r24
     a6c:	7f 91       	pop	r23
     a6e:	6f 91       	pop	r22
     a70:	5f 91       	pop	r21
     a72:	4f 91       	pop	r20
     a74:	3f 91       	pop	r19
     a76:	2f 91       	pop	r18
     a78:	0f 90       	pop	r0
     a7a:	0f be       	out	0x3f, r0	; 63
     a7c:	0f 90       	pop	r0
     a7e:	1f 90       	pop	r1
     a80:	18 95       	reti

00000a82 <tinyISR_setflag>:
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     a82:	80 93 4c 3e 	sts	0x3E4C, r24	; 0x803e4c <tinyISR_interrupt_flag>
     a86:	08 95       	ret

00000a88 <tinyISR_getflag>:
}

_Bool tinyISR_getflag(void)
{
	return tinyISR_interrupt_flag;
}
     a88:	80 91 4c 3e 	lds	r24, 0x3E4C	; 0x803e4c <tinyISR_interrupt_flag>
     a8c:	08 95       	ret

00000a8e <tinyPotential_increase_by>:
Internal function to enable incrementing or decrementing
potential from the signal of a button push or dendrite.
*/
static void tinyPotential_increase_by(int8_t delta_potential)
{
	tinyPotential_potential += delta_potential;
     a8e:	68 2f       	mov	r22, r24
     a90:	88 0f       	add	r24, r24
     a92:	77 0b       	sbc	r23, r23
     a94:	88 0b       	sbc	r24, r24
     a96:	99 0b       	sbc	r25, r25
     a98:	b8 d1       	rcall	.+880    	; 0xe0a <__floatsisf>
     a9a:	9b 01       	movw	r18, r22
     a9c:	ac 01       	movw	r20, r24
     a9e:	60 91 52 3e 	lds	r22, 0x3E52	; 0x803e52 <tinyPotential_potential>
     aa2:	70 91 53 3e 	lds	r23, 0x3E53	; 0x803e53 <tinyPotential_potential+0x1>
     aa6:	80 91 54 3e 	lds	r24, 0x3E54	; 0x803e54 <tinyPotential_potential+0x2>
     aaa:	90 91 55 3e 	lds	r25, 0x3E55	; 0x803e55 <tinyPotential_potential+0x3>
     aae:	58 d0       	rcall	.+176    	; 0xb60 <__addsf3>
     ab0:	60 93 52 3e 	sts	0x3E52, r22	; 0x803e52 <tinyPotential_potential>
     ab4:	70 93 53 3e 	sts	0x3E53, r23	; 0x803e53 <tinyPotential_potential+0x1>
     ab8:	80 93 54 3e 	sts	0x3E54, r24	; 0x803e54 <tinyPotential_potential+0x2>
     abc:	90 93 55 3e 	sts	0x3E55, r25	; 0x803e55 <tinyPotential_potential+0x3>
     ac0:	08 95       	ret

00000ac2 <tinyPotential_update>:
/*
The function which will run in the main loop.
This function will run on interrupts by the RTC module.
*/
void tinyPotential_update(double time_since_last_update)
{
     ac2:	cf 93       	push	r28
     ac4:	df 93       	push	r29
/*
Function to decay the potential towards 0
*/
static void tinyPotential_decay(double time_since_last_update)
{
	tinyPotential_potential *= (exp(-(time_since_last_update/TINYPOTENTIAL_TIME_CONST)));
     ac6:	20 e0       	ldi	r18, 0x00	; 0
     ac8:	30 e0       	ldi	r19, 0x00	; 0
     aca:	48 ec       	ldi	r20, 0xC8	; 200
     acc:	52 e4       	ldi	r21, 0x42	; 66
     ace:	b9 d0       	rcall	.+370    	; 0xc42 <__divsf3>
     ad0:	90 58       	subi	r25, 0x80	; 128
     ad2:	31 d1       	rcall	.+610    	; 0xd36 <exp>
     ad4:	9b 01       	movw	r18, r22
     ad6:	ac 01       	movw	r20, r24
     ad8:	60 91 52 3e 	lds	r22, 0x3E52	; 0x803e52 <tinyPotential_potential>
     adc:	70 91 53 3e 	lds	r23, 0x3E53	; 0x803e53 <tinyPotential_potential+0x1>
     ae0:	80 91 54 3e 	lds	r24, 0x3E54	; 0x803e54 <tinyPotential_potential+0x2>
     ae4:	90 91 55 3e 	lds	r25, 0x3E55	; 0x803e55 <tinyPotential_potential+0x3>
     ae8:	e2 d2       	rcall	.+1476   	; 0x10ae <__mulsf3>
     aea:	60 93 52 3e 	sts	0x3E52, r22	; 0x803e52 <tinyPotential_potential>
     aee:	70 93 53 3e 	sts	0x3E53, r23	; 0x803e53 <tinyPotential_potential+0x1>
     af2:	80 93 54 3e 	sts	0x3E54, r24	; 0x803e54 <tinyPotential_potential+0x2>
     af6:	90 93 55 3e 	sts	0x3E55, r25	; 0x803e55 <tinyPotential_potential+0x3>
{
	//Some of the potential in the neuron has decayed away
	tinyPotential_decay(time_since_last_update);
	
	//Update potential with values from dendrites
	tinyPotential_change = tinyDendrite_get_potential();
     afa:	f7 de       	rcall	.-530    	; 0x8ea <tinyDendrite_get_potential>
     afc:	ec 01       	movw	r28, r24
     afe:	bc 01       	movw	r22, r24
     b00:	99 0f       	add	r25, r25
     b02:	88 0b       	sbc	r24, r24
     b04:	99 0b       	sbc	r25, r25
     b06:	81 d1       	rcall	.+770    	; 0xe0a <__floatsisf>
     b08:	60 93 4e 3e 	sts	0x3E4E, r22	; 0x803e4e <tinyPotential_change>
     b0c:	70 93 4f 3e 	sts	0x3E4F, r23	; 0x803e4f <tinyPotential_change+0x1>
     b10:	80 93 50 3e 	sts	0x3E50, r24	; 0x803e50 <tinyPotential_change+0x2>
     b14:	90 93 51 3e 	sts	0x3E51, r25	; 0x803e51 <tinyPotential_change+0x3>
	tinyPotential_increase_by(tinyPotential_change);
     b18:	8c 2f       	mov	r24, r28
     b1a:	b9 df       	rcall	.-142    	; 0xa8e <tinyPotential_increase_by>
Function to update potential and set spontaneous pulse mode
by using the master update function in the button module.
*/
static void tinyPotential_button_update()
{
	if (tinyButton_get_state()) // If the button is pressed, we want the neuron to fire
     b1c:	1e dd       	rcall	.-1476   	; 0x55a <tinyButton_get_state>
     b1e:	88 23       	and	r24, r24
     b20:	11 f0       	breq	.+4      	; 0xb26 <tinyPotential_update+0x64>
	{
		tinyPotential_increase_by(THRESHOLD_POTENTIAL + 1);
     b22:	8a e1       	ldi	r24, 0x1A	; 26
     b24:	b4 df       	rcall	.-152    	; 0xa8e <tinyPotential_increase_by>
	}
	spontaneous_pulse_mode = tinyButton_is_spont_pulse_on();
     b26:	66 dd       	rcall	.-1332   	; 0x5f4 <tinyButton_is_spont_pulse_on>
     b28:	80 93 4d 3e 	sts	0x3E4D, r24	; 0x803e4d <spontaneous_pulse_mode>
	
	//Update potential with values from button
	tinyPotential_button_update();
	
	//Update potential with values from spontaneous pulse.
	if (spontaneous_pulse_mode)
     b2c:	88 23       	and	r24, r24
     b2e:	11 f0       	breq	.+4      	; 0xb34 <tinyPotential_update+0x72>
	{
		tinyPotential_increase_by(spont_pulse_delta_potential());
     b30:	64 dd       	rcall	.-1336   	; 0x5fa <spont_pulse_delta_potential>
     b32:	ad df       	rcall	.-166    	; 0xa8e <tinyPotential_increase_by>
	}
	
	// let the axon affect the potential
	tinyPotential_potential = tinyAxon_update_potential(tinyPotential_potential);
     b34:	60 91 52 3e 	lds	r22, 0x3E52	; 0x803e52 <tinyPotential_potential>
     b38:	70 91 53 3e 	lds	r23, 0x3E53	; 0x803e53 <tinyPotential_potential+0x1>
     b3c:	80 91 54 3e 	lds	r24, 0x3E54	; 0x803e54 <tinyPotential_potential+0x2>
     b40:	90 91 55 3e 	lds	r25, 0x3E55	; 0x803e55 <tinyPotential_potential+0x3>
     b44:	17 de       	rcall	.-978    	; 0x774 <tinyAxon_update_potential>
     b46:	60 93 52 3e 	sts	0x3E52, r22	; 0x803e52 <tinyPotential_potential>
     b4a:	70 93 53 3e 	sts	0x3E53, r23	; 0x803e53 <tinyPotential_potential+0x1>
     b4e:	80 93 54 3e 	sts	0x3E54, r24	; 0x803e54 <tinyPotential_potential+0x2>
     b52:	90 93 55 3e 	sts	0x3E55, r25	; 0x803e55 <tinyPotential_potential+0x3>

	//Update the led
	potential_to_RGB_update_LEDs(tinyPotential_potential);
     b56:	76 dc       	rcall	.-1812   	; 0x444 <potential_to_RGB_update_LEDs>
}
     b58:	df 91       	pop	r29
     b5a:	cf 91       	pop	r28
     b5c:	08 95       	ret

00000b5e <__subsf3>:
     b5e:	50 58       	subi	r21, 0x80	; 128

00000b60 <__addsf3>:
     b60:	bb 27       	eor	r27, r27
     b62:	aa 27       	eor	r26, r26
     b64:	0e 94 c7 05 	call	0xb8e	; 0xb8e <__addsf3x>
     b68:	0c 94 a2 07 	jmp	0xf44	; 0xf44 <__fp_round>
     b6c:	0e 94 94 07 	call	0xf28	; 0xf28 <__fp_pscA>
     b70:	38 f0       	brcs	.+14     	; 0xb80 <__addsf3+0x20>
     b72:	0e 94 9b 07 	call	0xf36	; 0xf36 <__fp_pscB>
     b76:	20 f0       	brcs	.+8      	; 0xb80 <__addsf3+0x20>
     b78:	39 f4       	brne	.+14     	; 0xb88 <__addsf3+0x28>
     b7a:	9f 3f       	cpi	r25, 0xFF	; 255
     b7c:	19 f4       	brne	.+6      	; 0xb84 <__addsf3+0x24>
     b7e:	26 f4       	brtc	.+8      	; 0xb88 <__addsf3+0x28>
     b80:	0c 94 6a 07 	jmp	0xed4	; 0xed4 <__fp_nan>
     b84:	0e f4       	brtc	.+2      	; 0xb88 <__addsf3+0x28>
     b86:	e0 95       	com	r30
     b88:	e7 fb       	bst	r30, 7
     b8a:	0c 94 64 07 	jmp	0xec8	; 0xec8 <__fp_inf>

00000b8e <__addsf3x>:
     b8e:	e9 2f       	mov	r30, r25
     b90:	0e 94 b3 07 	call	0xf66	; 0xf66 <__fp_split3>
     b94:	58 f3       	brcs	.-42     	; 0xb6c <__addsf3+0xc>
     b96:	ba 17       	cp	r27, r26
     b98:	62 07       	cpc	r22, r18
     b9a:	73 07       	cpc	r23, r19
     b9c:	84 07       	cpc	r24, r20
     b9e:	95 07       	cpc	r25, r21
     ba0:	20 f0       	brcs	.+8      	; 0xbaa <__addsf3x+0x1c>
     ba2:	79 f4       	brne	.+30     	; 0xbc2 <__addsf3x+0x34>
     ba4:	a6 f5       	brtc	.+104    	; 0xc0e <__addsf3x+0x80>
     ba6:	0c 94 d5 07 	jmp	0xfaa	; 0xfaa <__fp_zero>
     baa:	0e f4       	brtc	.+2      	; 0xbae <__addsf3x+0x20>
     bac:	e0 95       	com	r30
     bae:	0b 2e       	mov	r0, r27
     bb0:	ba 2f       	mov	r27, r26
     bb2:	a0 2d       	mov	r26, r0
     bb4:	0b 01       	movw	r0, r22
     bb6:	b9 01       	movw	r22, r18
     bb8:	90 01       	movw	r18, r0
     bba:	0c 01       	movw	r0, r24
     bbc:	ca 01       	movw	r24, r20
     bbe:	a0 01       	movw	r20, r0
     bc0:	11 24       	eor	r1, r1
     bc2:	ff 27       	eor	r31, r31
     bc4:	59 1b       	sub	r21, r25
     bc6:	99 f0       	breq	.+38     	; 0xbee <__addsf3x+0x60>
     bc8:	59 3f       	cpi	r21, 0xF9	; 249
     bca:	50 f4       	brcc	.+20     	; 0xbe0 <__addsf3x+0x52>
     bcc:	50 3e       	cpi	r21, 0xE0	; 224
     bce:	68 f1       	brcs	.+90     	; 0xc2a <__addsf3x+0x9c>
     bd0:	1a 16       	cp	r1, r26
     bd2:	f0 40       	sbci	r31, 0x00	; 0
     bd4:	a2 2f       	mov	r26, r18
     bd6:	23 2f       	mov	r18, r19
     bd8:	34 2f       	mov	r19, r20
     bda:	44 27       	eor	r20, r20
     bdc:	58 5f       	subi	r21, 0xF8	; 248
     bde:	f3 cf       	rjmp	.-26     	; 0xbc6 <__addsf3x+0x38>
     be0:	46 95       	lsr	r20
     be2:	37 95       	ror	r19
     be4:	27 95       	ror	r18
     be6:	a7 95       	ror	r26
     be8:	f0 40       	sbci	r31, 0x00	; 0
     bea:	53 95       	inc	r21
     bec:	c9 f7       	brne	.-14     	; 0xbe0 <__addsf3x+0x52>
     bee:	7e f4       	brtc	.+30     	; 0xc0e <__addsf3x+0x80>
     bf0:	1f 16       	cp	r1, r31
     bf2:	ba 0b       	sbc	r27, r26
     bf4:	62 0b       	sbc	r22, r18
     bf6:	73 0b       	sbc	r23, r19
     bf8:	84 0b       	sbc	r24, r20
     bfa:	ba f0       	brmi	.+46     	; 0xc2a <__addsf3x+0x9c>
     bfc:	91 50       	subi	r25, 0x01	; 1
     bfe:	a1 f0       	breq	.+40     	; 0xc28 <__addsf3x+0x9a>
     c00:	ff 0f       	add	r31, r31
     c02:	bb 1f       	adc	r27, r27
     c04:	66 1f       	adc	r22, r22
     c06:	77 1f       	adc	r23, r23
     c08:	88 1f       	adc	r24, r24
     c0a:	c2 f7       	brpl	.-16     	; 0xbfc <__addsf3x+0x6e>
     c0c:	0e c0       	rjmp	.+28     	; 0xc2a <__addsf3x+0x9c>
     c0e:	ba 0f       	add	r27, r26
     c10:	62 1f       	adc	r22, r18
     c12:	73 1f       	adc	r23, r19
     c14:	84 1f       	adc	r24, r20
     c16:	48 f4       	brcc	.+18     	; 0xc2a <__addsf3x+0x9c>
     c18:	87 95       	ror	r24
     c1a:	77 95       	ror	r23
     c1c:	67 95       	ror	r22
     c1e:	b7 95       	ror	r27
     c20:	f7 95       	ror	r31
     c22:	9e 3f       	cpi	r25, 0xFE	; 254
     c24:	08 f0       	brcs	.+2      	; 0xc28 <__addsf3x+0x9a>
     c26:	b0 cf       	rjmp	.-160    	; 0xb88 <__addsf3+0x28>
     c28:	93 95       	inc	r25
     c2a:	88 0f       	add	r24, r24
     c2c:	08 f0       	brcs	.+2      	; 0xc30 <__addsf3x+0xa2>
     c2e:	99 27       	eor	r25, r25
     c30:	ee 0f       	add	r30, r30
     c32:	97 95       	ror	r25
     c34:	87 95       	ror	r24
     c36:	08 95       	ret

00000c38 <__cmpsf2>:
     c38:	0e 94 40 07 	call	0xe80	; 0xe80 <__fp_cmp>
     c3c:	08 f4       	brcc	.+2      	; 0xc40 <__cmpsf2+0x8>
     c3e:	81 e0       	ldi	r24, 0x01	; 1
     c40:	08 95       	ret

00000c42 <__divsf3>:
     c42:	0e 94 35 06 	call	0xc6a	; 0xc6a <__divsf3x>
     c46:	0c 94 a2 07 	jmp	0xf44	; 0xf44 <__fp_round>
     c4a:	0e 94 9b 07 	call	0xf36	; 0xf36 <__fp_pscB>
     c4e:	58 f0       	brcs	.+22     	; 0xc66 <__divsf3+0x24>
     c50:	0e 94 94 07 	call	0xf28	; 0xf28 <__fp_pscA>
     c54:	40 f0       	brcs	.+16     	; 0xc66 <__divsf3+0x24>
     c56:	29 f4       	brne	.+10     	; 0xc62 <__divsf3+0x20>
     c58:	5f 3f       	cpi	r21, 0xFF	; 255
     c5a:	29 f0       	breq	.+10     	; 0xc66 <__divsf3+0x24>
     c5c:	0c 94 64 07 	jmp	0xec8	; 0xec8 <__fp_inf>
     c60:	51 11       	cpse	r21, r1
     c62:	0c 94 d6 07 	jmp	0xfac	; 0xfac <__fp_szero>
     c66:	0c 94 6a 07 	jmp	0xed4	; 0xed4 <__fp_nan>

00000c6a <__divsf3x>:
     c6a:	0e 94 b3 07 	call	0xf66	; 0xf66 <__fp_split3>
     c6e:	68 f3       	brcs	.-38     	; 0xc4a <__divsf3+0x8>

00000c70 <__divsf3_pse>:
     c70:	99 23       	and	r25, r25
     c72:	b1 f3       	breq	.-20     	; 0xc60 <__divsf3+0x1e>
     c74:	55 23       	and	r21, r21
     c76:	91 f3       	breq	.-28     	; 0xc5c <__divsf3+0x1a>
     c78:	95 1b       	sub	r25, r21
     c7a:	55 0b       	sbc	r21, r21
     c7c:	bb 27       	eor	r27, r27
     c7e:	aa 27       	eor	r26, r26
     c80:	62 17       	cp	r22, r18
     c82:	73 07       	cpc	r23, r19
     c84:	84 07       	cpc	r24, r20
     c86:	38 f0       	brcs	.+14     	; 0xc96 <__divsf3_pse+0x26>
     c88:	9f 5f       	subi	r25, 0xFF	; 255
     c8a:	5f 4f       	sbci	r21, 0xFF	; 255
     c8c:	22 0f       	add	r18, r18
     c8e:	33 1f       	adc	r19, r19
     c90:	44 1f       	adc	r20, r20
     c92:	aa 1f       	adc	r26, r26
     c94:	a9 f3       	breq	.-22     	; 0xc80 <__divsf3_pse+0x10>
     c96:	35 d0       	rcall	.+106    	; 0xd02 <__divsf3_pse+0x92>
     c98:	0e 2e       	mov	r0, r30
     c9a:	3a f0       	brmi	.+14     	; 0xcaa <__divsf3_pse+0x3a>
     c9c:	e0 e8       	ldi	r30, 0x80	; 128
     c9e:	32 d0       	rcall	.+100    	; 0xd04 <__divsf3_pse+0x94>
     ca0:	91 50       	subi	r25, 0x01	; 1
     ca2:	50 40       	sbci	r21, 0x00	; 0
     ca4:	e6 95       	lsr	r30
     ca6:	00 1c       	adc	r0, r0
     ca8:	ca f7       	brpl	.-14     	; 0xc9c <__divsf3_pse+0x2c>
     caa:	2b d0       	rcall	.+86     	; 0xd02 <__divsf3_pse+0x92>
     cac:	fe 2f       	mov	r31, r30
     cae:	29 d0       	rcall	.+82     	; 0xd02 <__divsf3_pse+0x92>
     cb0:	66 0f       	add	r22, r22
     cb2:	77 1f       	adc	r23, r23
     cb4:	88 1f       	adc	r24, r24
     cb6:	bb 1f       	adc	r27, r27
     cb8:	26 17       	cp	r18, r22
     cba:	37 07       	cpc	r19, r23
     cbc:	48 07       	cpc	r20, r24
     cbe:	ab 07       	cpc	r26, r27
     cc0:	b0 e8       	ldi	r27, 0x80	; 128
     cc2:	09 f0       	breq	.+2      	; 0xcc6 <__divsf3_pse+0x56>
     cc4:	bb 0b       	sbc	r27, r27
     cc6:	80 2d       	mov	r24, r0
     cc8:	bf 01       	movw	r22, r30
     cca:	ff 27       	eor	r31, r31
     ccc:	93 58       	subi	r25, 0x83	; 131
     cce:	5f 4f       	sbci	r21, 0xFF	; 255
     cd0:	3a f0       	brmi	.+14     	; 0xce0 <__divsf3_pse+0x70>
     cd2:	9e 3f       	cpi	r25, 0xFE	; 254
     cd4:	51 05       	cpc	r21, r1
     cd6:	78 f0       	brcs	.+30     	; 0xcf6 <__divsf3_pse+0x86>
     cd8:	0c 94 64 07 	jmp	0xec8	; 0xec8 <__fp_inf>
     cdc:	0c 94 d6 07 	jmp	0xfac	; 0xfac <__fp_szero>
     ce0:	5f 3f       	cpi	r21, 0xFF	; 255
     ce2:	e4 f3       	brlt	.-8      	; 0xcdc <__divsf3_pse+0x6c>
     ce4:	98 3e       	cpi	r25, 0xE8	; 232
     ce6:	d4 f3       	brlt	.-12     	; 0xcdc <__divsf3_pse+0x6c>
     ce8:	86 95       	lsr	r24
     cea:	77 95       	ror	r23
     cec:	67 95       	ror	r22
     cee:	b7 95       	ror	r27
     cf0:	f7 95       	ror	r31
     cf2:	9f 5f       	subi	r25, 0xFF	; 255
     cf4:	c9 f7       	brne	.-14     	; 0xce8 <__divsf3_pse+0x78>
     cf6:	88 0f       	add	r24, r24
     cf8:	91 1d       	adc	r25, r1
     cfa:	96 95       	lsr	r25
     cfc:	87 95       	ror	r24
     cfe:	97 f9       	bld	r25, 7
     d00:	08 95       	ret
     d02:	e1 e0       	ldi	r30, 0x01	; 1
     d04:	66 0f       	add	r22, r22
     d06:	77 1f       	adc	r23, r23
     d08:	88 1f       	adc	r24, r24
     d0a:	bb 1f       	adc	r27, r27
     d0c:	62 17       	cp	r22, r18
     d0e:	73 07       	cpc	r23, r19
     d10:	84 07       	cpc	r24, r20
     d12:	ba 07       	cpc	r27, r26
     d14:	20 f0       	brcs	.+8      	; 0xd1e <__divsf3_pse+0xae>
     d16:	62 1b       	sub	r22, r18
     d18:	73 0b       	sbc	r23, r19
     d1a:	84 0b       	sbc	r24, r20
     d1c:	ba 0b       	sbc	r27, r26
     d1e:	ee 1f       	adc	r30, r30
     d20:	88 f7       	brcc	.-30     	; 0xd04 <__divsf3_pse+0x94>
     d22:	e0 95       	com	r30
     d24:	08 95       	ret
     d26:	29 f4       	brne	.+10     	; 0xd32 <__divsf3_pse+0xc2>
     d28:	16 f0       	brts	.+4      	; 0xd2e <__divsf3_pse+0xbe>
     d2a:	0c 94 64 07 	jmp	0xec8	; 0xec8 <__fp_inf>
     d2e:	0c 94 d5 07 	jmp	0xfaa	; 0xfaa <__fp_zero>
     d32:	0c 94 6a 07 	jmp	0xed4	; 0xed4 <__fp_nan>

00000d36 <exp>:
     d36:	0e 94 bb 07 	call	0xf76	; 0xf76 <__fp_splitA>
     d3a:	a8 f3       	brcs	.-22     	; 0xd26 <__divsf3_pse+0xb6>
     d3c:	96 38       	cpi	r25, 0x86	; 134
     d3e:	a0 f7       	brcc	.-24     	; 0xd28 <__divsf3_pse+0xb8>
     d40:	07 f8       	bld	r0, 7
     d42:	0f 92       	push	r0
     d44:	e8 94       	clt
     d46:	2b e3       	ldi	r18, 0x3B	; 59
     d48:	3a ea       	ldi	r19, 0xAA	; 170
     d4a:	48 eb       	ldi	r20, 0xB8	; 184
     d4c:	5f e7       	ldi	r21, 0x7F	; 127
     d4e:	0e 94 6d 08 	call	0x10da	; 0x10da <__mulsf3_pse>
     d52:	0f 92       	push	r0
     d54:	0f 92       	push	r0
     d56:	0f 92       	push	r0
     d58:	4d b7       	in	r20, 0x3d	; 61
     d5a:	5e b7       	in	r21, 0x3e	; 62
     d5c:	0f 92       	push	r0
     d5e:	0e 94 23 08 	call	0x1046	; 0x1046 <modf>
     d62:	e4 e3       	ldi	r30, 0x34	; 52
     d64:	f0 e0       	ldi	r31, 0x00	; 0
     d66:	0e 94 6d 07 	call	0xeda	; 0xeda <__fp_powser>
     d6a:	4f 91       	pop	r20
     d6c:	5f 91       	pop	r21
     d6e:	ef 91       	pop	r30
     d70:	ff 91       	pop	r31
     d72:	e5 95       	asr	r30
     d74:	ee 1f       	adc	r30, r30
     d76:	ff 1f       	adc	r31, r31
     d78:	49 f0       	breq	.+18     	; 0xd8c <exp+0x56>
     d7a:	fe 57       	subi	r31, 0x7E	; 126
     d7c:	e0 68       	ori	r30, 0x80	; 128
     d7e:	44 27       	eor	r20, r20
     d80:	ee 0f       	add	r30, r30
     d82:	44 1f       	adc	r20, r20
     d84:	fa 95       	dec	r31
     d86:	e1 f7       	brne	.-8      	; 0xd80 <exp+0x4a>
     d88:	41 95       	neg	r20
     d8a:	55 0b       	sbc	r21, r21
     d8c:	0e 94 ed 07 	call	0xfda	; 0xfda <ldexp>
     d90:	0f 90       	pop	r0
     d92:	07 fe       	sbrs	r0, 7
     d94:	0c 94 e1 07 	jmp	0xfc2	; 0xfc2 <inverse>
     d98:	08 95       	ret

00000d9a <__fixsfsi>:
     d9a:	0e 94 d4 06 	call	0xda8	; 0xda8 <__fixunssfsi>
     d9e:	68 94       	set
     da0:	b1 11       	cpse	r27, r1
     da2:	0c 94 d6 07 	jmp	0xfac	; 0xfac <__fp_szero>
     da6:	08 95       	ret

00000da8 <__fixunssfsi>:
     da8:	0e 94 bb 07 	call	0xf76	; 0xf76 <__fp_splitA>
     dac:	88 f0       	brcs	.+34     	; 0xdd0 <__fixunssfsi+0x28>
     dae:	9f 57       	subi	r25, 0x7F	; 127
     db0:	98 f0       	brcs	.+38     	; 0xdd8 <__fixunssfsi+0x30>
     db2:	b9 2f       	mov	r27, r25
     db4:	99 27       	eor	r25, r25
     db6:	b7 51       	subi	r27, 0x17	; 23
     db8:	b0 f0       	brcs	.+44     	; 0xde6 <__fixunssfsi+0x3e>
     dba:	e1 f0       	breq	.+56     	; 0xdf4 <__fixunssfsi+0x4c>
     dbc:	66 0f       	add	r22, r22
     dbe:	77 1f       	adc	r23, r23
     dc0:	88 1f       	adc	r24, r24
     dc2:	99 1f       	adc	r25, r25
     dc4:	1a f0       	brmi	.+6      	; 0xdcc <__fixunssfsi+0x24>
     dc6:	ba 95       	dec	r27
     dc8:	c9 f7       	brne	.-14     	; 0xdbc <__fixunssfsi+0x14>
     dca:	14 c0       	rjmp	.+40     	; 0xdf4 <__fixunssfsi+0x4c>
     dcc:	b1 30       	cpi	r27, 0x01	; 1
     dce:	91 f0       	breq	.+36     	; 0xdf4 <__fixunssfsi+0x4c>
     dd0:	0e 94 d5 07 	call	0xfaa	; 0xfaa <__fp_zero>
     dd4:	b1 e0       	ldi	r27, 0x01	; 1
     dd6:	08 95       	ret
     dd8:	0c 94 d5 07 	jmp	0xfaa	; 0xfaa <__fp_zero>
     ddc:	67 2f       	mov	r22, r23
     dde:	78 2f       	mov	r23, r24
     de0:	88 27       	eor	r24, r24
     de2:	b8 5f       	subi	r27, 0xF8	; 248
     de4:	39 f0       	breq	.+14     	; 0xdf4 <__fixunssfsi+0x4c>
     de6:	b9 3f       	cpi	r27, 0xF9	; 249
     de8:	cc f3       	brlt	.-14     	; 0xddc <__fixunssfsi+0x34>
     dea:	86 95       	lsr	r24
     dec:	77 95       	ror	r23
     dee:	67 95       	ror	r22
     df0:	b3 95       	inc	r27
     df2:	d9 f7       	brne	.-10     	; 0xdea <__fixunssfsi+0x42>
     df4:	3e f4       	brtc	.+14     	; 0xe04 <__fixunssfsi+0x5c>
     df6:	90 95       	com	r25
     df8:	80 95       	com	r24
     dfa:	70 95       	com	r23
     dfc:	61 95       	neg	r22
     dfe:	7f 4f       	sbci	r23, 0xFF	; 255
     e00:	8f 4f       	sbci	r24, 0xFF	; 255
     e02:	9f 4f       	sbci	r25, 0xFF	; 255
     e04:	08 95       	ret

00000e06 <__floatunsisf>:
     e06:	e8 94       	clt
     e08:	09 c0       	rjmp	.+18     	; 0xe1c <__floatsisf+0x12>

00000e0a <__floatsisf>:
     e0a:	97 fb       	bst	r25, 7
     e0c:	3e f4       	brtc	.+14     	; 0xe1c <__floatsisf+0x12>
     e0e:	90 95       	com	r25
     e10:	80 95       	com	r24
     e12:	70 95       	com	r23
     e14:	61 95       	neg	r22
     e16:	7f 4f       	sbci	r23, 0xFF	; 255
     e18:	8f 4f       	sbci	r24, 0xFF	; 255
     e1a:	9f 4f       	sbci	r25, 0xFF	; 255
     e1c:	99 23       	and	r25, r25
     e1e:	a9 f0       	breq	.+42     	; 0xe4a <__floatsisf+0x40>
     e20:	f9 2f       	mov	r31, r25
     e22:	96 e9       	ldi	r25, 0x96	; 150
     e24:	bb 27       	eor	r27, r27
     e26:	93 95       	inc	r25
     e28:	f6 95       	lsr	r31
     e2a:	87 95       	ror	r24
     e2c:	77 95       	ror	r23
     e2e:	67 95       	ror	r22
     e30:	b7 95       	ror	r27
     e32:	f1 11       	cpse	r31, r1
     e34:	f8 cf       	rjmp	.-16     	; 0xe26 <__floatsisf+0x1c>
     e36:	fa f4       	brpl	.+62     	; 0xe76 <__floatsisf+0x6c>
     e38:	bb 0f       	add	r27, r27
     e3a:	11 f4       	brne	.+4      	; 0xe40 <__floatsisf+0x36>
     e3c:	60 ff       	sbrs	r22, 0
     e3e:	1b c0       	rjmp	.+54     	; 0xe76 <__floatsisf+0x6c>
     e40:	6f 5f       	subi	r22, 0xFF	; 255
     e42:	7f 4f       	sbci	r23, 0xFF	; 255
     e44:	8f 4f       	sbci	r24, 0xFF	; 255
     e46:	9f 4f       	sbci	r25, 0xFF	; 255
     e48:	16 c0       	rjmp	.+44     	; 0xe76 <__floatsisf+0x6c>
     e4a:	88 23       	and	r24, r24
     e4c:	11 f0       	breq	.+4      	; 0xe52 <__floatsisf+0x48>
     e4e:	96 e9       	ldi	r25, 0x96	; 150
     e50:	11 c0       	rjmp	.+34     	; 0xe74 <__floatsisf+0x6a>
     e52:	77 23       	and	r23, r23
     e54:	21 f0       	breq	.+8      	; 0xe5e <__floatsisf+0x54>
     e56:	9e e8       	ldi	r25, 0x8E	; 142
     e58:	87 2f       	mov	r24, r23
     e5a:	76 2f       	mov	r23, r22
     e5c:	05 c0       	rjmp	.+10     	; 0xe68 <__floatsisf+0x5e>
     e5e:	66 23       	and	r22, r22
     e60:	71 f0       	breq	.+28     	; 0xe7e <__floatsisf+0x74>
     e62:	96 e8       	ldi	r25, 0x86	; 134
     e64:	86 2f       	mov	r24, r22
     e66:	70 e0       	ldi	r23, 0x00	; 0
     e68:	60 e0       	ldi	r22, 0x00	; 0
     e6a:	2a f0       	brmi	.+10     	; 0xe76 <__floatsisf+0x6c>
     e6c:	9a 95       	dec	r25
     e6e:	66 0f       	add	r22, r22
     e70:	77 1f       	adc	r23, r23
     e72:	88 1f       	adc	r24, r24
     e74:	da f7       	brpl	.-10     	; 0xe6c <__floatsisf+0x62>
     e76:	88 0f       	add	r24, r24
     e78:	96 95       	lsr	r25
     e7a:	87 95       	ror	r24
     e7c:	97 f9       	bld	r25, 7
     e7e:	08 95       	ret

00000e80 <__fp_cmp>:
     e80:	99 0f       	add	r25, r25
     e82:	00 08       	sbc	r0, r0
     e84:	55 0f       	add	r21, r21
     e86:	aa 0b       	sbc	r26, r26
     e88:	e0 e8       	ldi	r30, 0x80	; 128
     e8a:	fe ef       	ldi	r31, 0xFE	; 254
     e8c:	16 16       	cp	r1, r22
     e8e:	17 06       	cpc	r1, r23
     e90:	e8 07       	cpc	r30, r24
     e92:	f9 07       	cpc	r31, r25
     e94:	c0 f0       	brcs	.+48     	; 0xec6 <__fp_cmp+0x46>
     e96:	12 16       	cp	r1, r18
     e98:	13 06       	cpc	r1, r19
     e9a:	e4 07       	cpc	r30, r20
     e9c:	f5 07       	cpc	r31, r21
     e9e:	98 f0       	brcs	.+38     	; 0xec6 <__fp_cmp+0x46>
     ea0:	62 1b       	sub	r22, r18
     ea2:	73 0b       	sbc	r23, r19
     ea4:	84 0b       	sbc	r24, r20
     ea6:	95 0b       	sbc	r25, r21
     ea8:	39 f4       	brne	.+14     	; 0xeb8 <__fp_cmp+0x38>
     eaa:	0a 26       	eor	r0, r26
     eac:	61 f0       	breq	.+24     	; 0xec6 <__fp_cmp+0x46>
     eae:	23 2b       	or	r18, r19
     eb0:	24 2b       	or	r18, r20
     eb2:	25 2b       	or	r18, r21
     eb4:	21 f4       	brne	.+8      	; 0xebe <__fp_cmp+0x3e>
     eb6:	08 95       	ret
     eb8:	0a 26       	eor	r0, r26
     eba:	09 f4       	brne	.+2      	; 0xebe <__fp_cmp+0x3e>
     ebc:	a1 40       	sbci	r26, 0x01	; 1
     ebe:	a6 95       	lsr	r26
     ec0:	8f ef       	ldi	r24, 0xFF	; 255
     ec2:	81 1d       	adc	r24, r1
     ec4:	81 1d       	adc	r24, r1
     ec6:	08 95       	ret

00000ec8 <__fp_inf>:
     ec8:	97 f9       	bld	r25, 7
     eca:	9f 67       	ori	r25, 0x7F	; 127
     ecc:	80 e8       	ldi	r24, 0x80	; 128
     ece:	70 e0       	ldi	r23, 0x00	; 0
     ed0:	60 e0       	ldi	r22, 0x00	; 0
     ed2:	08 95       	ret

00000ed4 <__fp_nan>:
     ed4:	9f ef       	ldi	r25, 0xFF	; 255
     ed6:	80 ec       	ldi	r24, 0xC0	; 192
     ed8:	08 95       	ret

00000eda <__fp_powser>:
     eda:	df 93       	push	r29
     edc:	cf 93       	push	r28
     ede:	1f 93       	push	r17
     ee0:	0f 93       	push	r16
     ee2:	ff 92       	push	r15
     ee4:	ef 92       	push	r14
     ee6:	df 92       	push	r13
     ee8:	7b 01       	movw	r14, r22
     eea:	8c 01       	movw	r16, r24
     eec:	68 94       	set
     eee:	06 c0       	rjmp	.+12     	; 0xefc <__fp_powser+0x22>
     ef0:	da 2e       	mov	r13, r26
     ef2:	ef 01       	movw	r28, r30
     ef4:	0e 94 6a 08 	call	0x10d4	; 0x10d4 <__mulsf3x>
     ef8:	fe 01       	movw	r30, r28
     efa:	e8 94       	clt
     efc:	a5 91       	lpm	r26, Z+
     efe:	25 91       	lpm	r18, Z+
     f00:	35 91       	lpm	r19, Z+
     f02:	45 91       	lpm	r20, Z+
     f04:	55 91       	lpm	r21, Z+
     f06:	a6 f3       	brts	.-24     	; 0xef0 <__fp_powser+0x16>
     f08:	ef 01       	movw	r28, r30
     f0a:	0e 94 c7 05 	call	0xb8e	; 0xb8e <__addsf3x>
     f0e:	fe 01       	movw	r30, r28
     f10:	97 01       	movw	r18, r14
     f12:	a8 01       	movw	r20, r16
     f14:	da 94       	dec	r13
     f16:	69 f7       	brne	.-38     	; 0xef2 <__fp_powser+0x18>
     f18:	df 90       	pop	r13
     f1a:	ef 90       	pop	r14
     f1c:	ff 90       	pop	r15
     f1e:	0f 91       	pop	r16
     f20:	1f 91       	pop	r17
     f22:	cf 91       	pop	r28
     f24:	df 91       	pop	r29
     f26:	08 95       	ret

00000f28 <__fp_pscA>:
     f28:	00 24       	eor	r0, r0
     f2a:	0a 94       	dec	r0
     f2c:	16 16       	cp	r1, r22
     f2e:	17 06       	cpc	r1, r23
     f30:	18 06       	cpc	r1, r24
     f32:	09 06       	cpc	r0, r25
     f34:	08 95       	ret

00000f36 <__fp_pscB>:
     f36:	00 24       	eor	r0, r0
     f38:	0a 94       	dec	r0
     f3a:	12 16       	cp	r1, r18
     f3c:	13 06       	cpc	r1, r19
     f3e:	14 06       	cpc	r1, r20
     f40:	05 06       	cpc	r0, r21
     f42:	08 95       	ret

00000f44 <__fp_round>:
     f44:	09 2e       	mov	r0, r25
     f46:	03 94       	inc	r0
     f48:	00 0c       	add	r0, r0
     f4a:	11 f4       	brne	.+4      	; 0xf50 <__fp_round+0xc>
     f4c:	88 23       	and	r24, r24
     f4e:	52 f0       	brmi	.+20     	; 0xf64 <__fp_round+0x20>
     f50:	bb 0f       	add	r27, r27
     f52:	40 f4       	brcc	.+16     	; 0xf64 <__fp_round+0x20>
     f54:	bf 2b       	or	r27, r31
     f56:	11 f4       	brne	.+4      	; 0xf5c <__fp_round+0x18>
     f58:	60 ff       	sbrs	r22, 0
     f5a:	04 c0       	rjmp	.+8      	; 0xf64 <__fp_round+0x20>
     f5c:	6f 5f       	subi	r22, 0xFF	; 255
     f5e:	7f 4f       	sbci	r23, 0xFF	; 255
     f60:	8f 4f       	sbci	r24, 0xFF	; 255
     f62:	9f 4f       	sbci	r25, 0xFF	; 255
     f64:	08 95       	ret

00000f66 <__fp_split3>:
     f66:	57 fd       	sbrc	r21, 7
     f68:	90 58       	subi	r25, 0x80	; 128
     f6a:	44 0f       	add	r20, r20
     f6c:	55 1f       	adc	r21, r21
     f6e:	59 f0       	breq	.+22     	; 0xf86 <__fp_splitA+0x10>
     f70:	5f 3f       	cpi	r21, 0xFF	; 255
     f72:	71 f0       	breq	.+28     	; 0xf90 <__fp_splitA+0x1a>
     f74:	47 95       	ror	r20

00000f76 <__fp_splitA>:
     f76:	88 0f       	add	r24, r24
     f78:	97 fb       	bst	r25, 7
     f7a:	99 1f       	adc	r25, r25
     f7c:	61 f0       	breq	.+24     	; 0xf96 <__fp_splitA+0x20>
     f7e:	9f 3f       	cpi	r25, 0xFF	; 255
     f80:	79 f0       	breq	.+30     	; 0xfa0 <__fp_splitA+0x2a>
     f82:	87 95       	ror	r24
     f84:	08 95       	ret
     f86:	12 16       	cp	r1, r18
     f88:	13 06       	cpc	r1, r19
     f8a:	14 06       	cpc	r1, r20
     f8c:	55 1f       	adc	r21, r21
     f8e:	f2 cf       	rjmp	.-28     	; 0xf74 <__fp_split3+0xe>
     f90:	46 95       	lsr	r20
     f92:	f1 df       	rcall	.-30     	; 0xf76 <__fp_splitA>
     f94:	08 c0       	rjmp	.+16     	; 0xfa6 <__fp_splitA+0x30>
     f96:	16 16       	cp	r1, r22
     f98:	17 06       	cpc	r1, r23
     f9a:	18 06       	cpc	r1, r24
     f9c:	99 1f       	adc	r25, r25
     f9e:	f1 cf       	rjmp	.-30     	; 0xf82 <__fp_splitA+0xc>
     fa0:	86 95       	lsr	r24
     fa2:	71 05       	cpc	r23, r1
     fa4:	61 05       	cpc	r22, r1
     fa6:	08 94       	sec
     fa8:	08 95       	ret

00000faa <__fp_zero>:
     faa:	e8 94       	clt

00000fac <__fp_szero>:
     fac:	bb 27       	eor	r27, r27
     fae:	66 27       	eor	r22, r22
     fb0:	77 27       	eor	r23, r23
     fb2:	cb 01       	movw	r24, r22
     fb4:	97 f9       	bld	r25, 7
     fb6:	08 95       	ret

00000fb8 <__gesf2>:
     fb8:	0e 94 40 07 	call	0xe80	; 0xe80 <__fp_cmp>
     fbc:	08 f4       	brcc	.+2      	; 0xfc0 <__gesf2+0x8>
     fbe:	8f ef       	ldi	r24, 0xFF	; 255
     fc0:	08 95       	ret

00000fc2 <inverse>:
     fc2:	9b 01       	movw	r18, r22
     fc4:	ac 01       	movw	r20, r24
     fc6:	60 e0       	ldi	r22, 0x00	; 0
     fc8:	70 e0       	ldi	r23, 0x00	; 0
     fca:	80 e8       	ldi	r24, 0x80	; 128
     fcc:	9f e3       	ldi	r25, 0x3F	; 63
     fce:	0c 94 21 06 	jmp	0xc42	; 0xc42 <__divsf3>
     fd2:	0c 94 64 07 	jmp	0xec8	; 0xec8 <__fp_inf>
     fd6:	0c 94 03 09 	jmp	0x1206	; 0x1206 <__fp_mpack>

00000fda <ldexp>:
     fda:	0e 94 bb 07 	call	0xf76	; 0xf76 <__fp_splitA>
     fde:	d8 f3       	brcs	.-10     	; 0xfd6 <inverse+0x14>
     fe0:	99 23       	and	r25, r25
     fe2:	c9 f3       	breq	.-14     	; 0xfd6 <inverse+0x14>
     fe4:	94 0f       	add	r25, r20
     fe6:	51 1d       	adc	r21, r1
     fe8:	a3 f3       	brvs	.-24     	; 0xfd2 <inverse+0x10>
     fea:	91 50       	subi	r25, 0x01	; 1
     fec:	50 40       	sbci	r21, 0x00	; 0
     fee:	94 f0       	brlt	.+36     	; 0x1014 <ldexp+0x3a>
     ff0:	59 f0       	breq	.+22     	; 0x1008 <ldexp+0x2e>
     ff2:	88 23       	and	r24, r24
     ff4:	32 f0       	brmi	.+12     	; 0x1002 <ldexp+0x28>
     ff6:	66 0f       	add	r22, r22
     ff8:	77 1f       	adc	r23, r23
     ffa:	88 1f       	adc	r24, r24
     ffc:	91 50       	subi	r25, 0x01	; 1
     ffe:	50 40       	sbci	r21, 0x00	; 0
    1000:	c1 f7       	brne	.-16     	; 0xff2 <ldexp+0x18>
    1002:	9e 3f       	cpi	r25, 0xFE	; 254
    1004:	51 05       	cpc	r21, r1
    1006:	2c f7       	brge	.-54     	; 0xfd2 <inverse+0x10>
    1008:	88 0f       	add	r24, r24
    100a:	91 1d       	adc	r25, r1
    100c:	96 95       	lsr	r25
    100e:	87 95       	ror	r24
    1010:	97 f9       	bld	r25, 7
    1012:	08 95       	ret
    1014:	5f 3f       	cpi	r21, 0xFF	; 255
    1016:	ac f0       	brlt	.+42     	; 0x1042 <ldexp+0x68>
    1018:	98 3e       	cpi	r25, 0xE8	; 232
    101a:	9c f0       	brlt	.+38     	; 0x1042 <ldexp+0x68>
    101c:	bb 27       	eor	r27, r27
    101e:	86 95       	lsr	r24
    1020:	77 95       	ror	r23
    1022:	67 95       	ror	r22
    1024:	b7 95       	ror	r27
    1026:	08 f4       	brcc	.+2      	; 0x102a <ldexp+0x50>
    1028:	b1 60       	ori	r27, 0x01	; 1
    102a:	93 95       	inc	r25
    102c:	c1 f7       	brne	.-16     	; 0x101e <ldexp+0x44>
    102e:	bb 0f       	add	r27, r27
    1030:	58 f7       	brcc	.-42     	; 0x1008 <ldexp+0x2e>
    1032:	11 f4       	brne	.+4      	; 0x1038 <ldexp+0x5e>
    1034:	60 ff       	sbrs	r22, 0
    1036:	e8 cf       	rjmp	.-48     	; 0x1008 <ldexp+0x2e>
    1038:	6f 5f       	subi	r22, 0xFF	; 255
    103a:	7f 4f       	sbci	r23, 0xFF	; 255
    103c:	8f 4f       	sbci	r24, 0xFF	; 255
    103e:	9f 4f       	sbci	r25, 0xFF	; 255
    1040:	e3 cf       	rjmp	.-58     	; 0x1008 <ldexp+0x2e>
    1042:	0c 94 d6 07 	jmp	0xfac	; 0xfac <__fp_szero>

00001046 <modf>:
    1046:	fa 01       	movw	r30, r20
    1048:	dc 01       	movw	r26, r24
    104a:	aa 0f       	add	r26, r26
    104c:	bb 1f       	adc	r27, r27
    104e:	9b 01       	movw	r18, r22
    1050:	ac 01       	movw	r20, r24
    1052:	bf 57       	subi	r27, 0x7F	; 127
    1054:	28 f4       	brcc	.+10     	; 0x1060 <modf+0x1a>
    1056:	22 27       	eor	r18, r18
    1058:	33 27       	eor	r19, r19
    105a:	44 27       	eor	r20, r20
    105c:	50 78       	andi	r21, 0x80	; 128
    105e:	20 c0       	rjmp	.+64     	; 0x10a0 <modf+0x5a>
    1060:	b7 51       	subi	r27, 0x17	; 23
    1062:	90 f4       	brcc	.+36     	; 0x1088 <modf+0x42>
    1064:	ab 2f       	mov	r26, r27
    1066:	00 24       	eor	r0, r0
    1068:	46 95       	lsr	r20
    106a:	37 95       	ror	r19
    106c:	27 95       	ror	r18
    106e:	01 1c       	adc	r0, r1
    1070:	a3 95       	inc	r26
    1072:	d2 f3       	brmi	.-12     	; 0x1068 <modf+0x22>
    1074:	00 20       	and	r0, r0
    1076:	71 f0       	breq	.+28     	; 0x1094 <modf+0x4e>
    1078:	22 0f       	add	r18, r18
    107a:	33 1f       	adc	r19, r19
    107c:	44 1f       	adc	r20, r20
    107e:	b3 95       	inc	r27
    1080:	da f3       	brmi	.-10     	; 0x1078 <modf+0x32>
    1082:	0e d0       	rcall	.+28     	; 0x10a0 <modf+0x5a>
    1084:	0c 94 af 05 	jmp	0xb5e	; 0xb5e <__subsf3>
    1088:	61 30       	cpi	r22, 0x01	; 1
    108a:	71 05       	cpc	r23, r1
    108c:	a0 e8       	ldi	r26, 0x80	; 128
    108e:	8a 07       	cpc	r24, r26
    1090:	b9 46       	sbci	r27, 0x69	; 105
    1092:	30 f4       	brcc	.+12     	; 0x10a0 <modf+0x5a>
    1094:	9b 01       	movw	r18, r22
    1096:	ac 01       	movw	r20, r24
    1098:	66 27       	eor	r22, r22
    109a:	77 27       	eor	r23, r23
    109c:	88 27       	eor	r24, r24
    109e:	90 78       	andi	r25, 0x80	; 128
    10a0:	30 96       	adiw	r30, 0x00	; 0
    10a2:	21 f0       	breq	.+8      	; 0x10ac <modf+0x66>
    10a4:	20 83       	st	Z, r18
    10a6:	31 83       	std	Z+1, r19	; 0x01
    10a8:	42 83       	std	Z+2, r20	; 0x02
    10aa:	53 83       	std	Z+3, r21	; 0x03
    10ac:	08 95       	ret

000010ae <__mulsf3>:
    10ae:	0e 94 6a 08 	call	0x10d4	; 0x10d4 <__mulsf3x>
    10b2:	0c 94 a2 07 	jmp	0xf44	; 0xf44 <__fp_round>
    10b6:	0e 94 94 07 	call	0xf28	; 0xf28 <__fp_pscA>
    10ba:	38 f0       	brcs	.+14     	; 0x10ca <__mulsf3+0x1c>
    10bc:	0e 94 9b 07 	call	0xf36	; 0xf36 <__fp_pscB>
    10c0:	20 f0       	brcs	.+8      	; 0x10ca <__mulsf3+0x1c>
    10c2:	95 23       	and	r25, r21
    10c4:	11 f0       	breq	.+4      	; 0x10ca <__mulsf3+0x1c>
    10c6:	0c 94 64 07 	jmp	0xec8	; 0xec8 <__fp_inf>
    10ca:	0c 94 6a 07 	jmp	0xed4	; 0xed4 <__fp_nan>
    10ce:	11 24       	eor	r1, r1
    10d0:	0c 94 d6 07 	jmp	0xfac	; 0xfac <__fp_szero>

000010d4 <__mulsf3x>:
    10d4:	0e 94 b3 07 	call	0xf66	; 0xf66 <__fp_split3>
    10d8:	70 f3       	brcs	.-36     	; 0x10b6 <__mulsf3+0x8>

000010da <__mulsf3_pse>:
    10da:	95 9f       	mul	r25, r21
    10dc:	c1 f3       	breq	.-16     	; 0x10ce <__mulsf3+0x20>
    10de:	95 0f       	add	r25, r21
    10e0:	50 e0       	ldi	r21, 0x00	; 0
    10e2:	55 1f       	adc	r21, r21
    10e4:	62 9f       	mul	r22, r18
    10e6:	f0 01       	movw	r30, r0
    10e8:	72 9f       	mul	r23, r18
    10ea:	bb 27       	eor	r27, r27
    10ec:	f0 0d       	add	r31, r0
    10ee:	b1 1d       	adc	r27, r1
    10f0:	63 9f       	mul	r22, r19
    10f2:	aa 27       	eor	r26, r26
    10f4:	f0 0d       	add	r31, r0
    10f6:	b1 1d       	adc	r27, r1
    10f8:	aa 1f       	adc	r26, r26
    10fa:	64 9f       	mul	r22, r20
    10fc:	66 27       	eor	r22, r22
    10fe:	b0 0d       	add	r27, r0
    1100:	a1 1d       	adc	r26, r1
    1102:	66 1f       	adc	r22, r22
    1104:	82 9f       	mul	r24, r18
    1106:	22 27       	eor	r18, r18
    1108:	b0 0d       	add	r27, r0
    110a:	a1 1d       	adc	r26, r1
    110c:	62 1f       	adc	r22, r18
    110e:	73 9f       	mul	r23, r19
    1110:	b0 0d       	add	r27, r0
    1112:	a1 1d       	adc	r26, r1
    1114:	62 1f       	adc	r22, r18
    1116:	83 9f       	mul	r24, r19
    1118:	a0 0d       	add	r26, r0
    111a:	61 1d       	adc	r22, r1
    111c:	22 1f       	adc	r18, r18
    111e:	74 9f       	mul	r23, r20
    1120:	33 27       	eor	r19, r19
    1122:	a0 0d       	add	r26, r0
    1124:	61 1d       	adc	r22, r1
    1126:	23 1f       	adc	r18, r19
    1128:	84 9f       	mul	r24, r20
    112a:	60 0d       	add	r22, r0
    112c:	21 1d       	adc	r18, r1
    112e:	82 2f       	mov	r24, r18
    1130:	76 2f       	mov	r23, r22
    1132:	6a 2f       	mov	r22, r26
    1134:	11 24       	eor	r1, r1
    1136:	9f 57       	subi	r25, 0x7F	; 127
    1138:	50 40       	sbci	r21, 0x00	; 0
    113a:	9a f0       	brmi	.+38     	; 0x1162 <__mulsf3_pse+0x88>
    113c:	f1 f0       	breq	.+60     	; 0x117a <__mulsf3_pse+0xa0>
    113e:	88 23       	and	r24, r24
    1140:	4a f0       	brmi	.+18     	; 0x1154 <__mulsf3_pse+0x7a>
    1142:	ee 0f       	add	r30, r30
    1144:	ff 1f       	adc	r31, r31
    1146:	bb 1f       	adc	r27, r27
    1148:	66 1f       	adc	r22, r22
    114a:	77 1f       	adc	r23, r23
    114c:	88 1f       	adc	r24, r24
    114e:	91 50       	subi	r25, 0x01	; 1
    1150:	50 40       	sbci	r21, 0x00	; 0
    1152:	a9 f7       	brne	.-22     	; 0x113e <__mulsf3_pse+0x64>
    1154:	9e 3f       	cpi	r25, 0xFE	; 254
    1156:	51 05       	cpc	r21, r1
    1158:	80 f0       	brcs	.+32     	; 0x117a <__mulsf3_pse+0xa0>
    115a:	0c 94 64 07 	jmp	0xec8	; 0xec8 <__fp_inf>
    115e:	0c 94 d6 07 	jmp	0xfac	; 0xfac <__fp_szero>
    1162:	5f 3f       	cpi	r21, 0xFF	; 255
    1164:	e4 f3       	brlt	.-8      	; 0x115e <__mulsf3_pse+0x84>
    1166:	98 3e       	cpi	r25, 0xE8	; 232
    1168:	d4 f3       	brlt	.-12     	; 0x115e <__mulsf3_pse+0x84>
    116a:	86 95       	lsr	r24
    116c:	77 95       	ror	r23
    116e:	67 95       	ror	r22
    1170:	b7 95       	ror	r27
    1172:	f7 95       	ror	r31
    1174:	e7 95       	ror	r30
    1176:	9f 5f       	subi	r25, 0xFF	; 255
    1178:	c1 f7       	brne	.-16     	; 0x116a <__mulsf3_pse+0x90>
    117a:	fe 2b       	or	r31, r30
    117c:	88 0f       	add	r24, r24
    117e:	91 1d       	adc	r25, r1
    1180:	96 95       	lsr	r25
    1182:	87 95       	ror	r24
    1184:	97 f9       	bld	r25, 7
    1186:	08 95       	ret

00001188 <round>:
    1188:	0e 94 bb 07 	call	0xf76	; 0xf76 <__fp_splitA>
    118c:	e8 f0       	brcs	.+58     	; 0x11c8 <round+0x40>
    118e:	9e 37       	cpi	r25, 0x7E	; 126
    1190:	e8 f0       	brcs	.+58     	; 0x11cc <round+0x44>
    1192:	96 39       	cpi	r25, 0x96	; 150
    1194:	b8 f4       	brcc	.+46     	; 0x11c4 <round+0x3c>
    1196:	9e 38       	cpi	r25, 0x8E	; 142
    1198:	48 f4       	brcc	.+18     	; 0x11ac <round+0x24>
    119a:	67 2f       	mov	r22, r23
    119c:	78 2f       	mov	r23, r24
    119e:	88 27       	eor	r24, r24
    11a0:	98 5f       	subi	r25, 0xF8	; 248
    11a2:	f9 cf       	rjmp	.-14     	; 0x1196 <round+0xe>
    11a4:	86 95       	lsr	r24
    11a6:	77 95       	ror	r23
    11a8:	67 95       	ror	r22
    11aa:	93 95       	inc	r25
    11ac:	95 39       	cpi	r25, 0x95	; 149
    11ae:	d0 f3       	brcs	.-12     	; 0x11a4 <round+0x1c>
    11b0:	b6 2f       	mov	r27, r22
    11b2:	b1 70       	andi	r27, 0x01	; 1
    11b4:	6b 0f       	add	r22, r27
    11b6:	71 1d       	adc	r23, r1
    11b8:	81 1d       	adc	r24, r1
    11ba:	20 f4       	brcc	.+8      	; 0x11c4 <round+0x3c>
    11bc:	87 95       	ror	r24
    11be:	77 95       	ror	r23
    11c0:	67 95       	ror	r22
    11c2:	93 95       	inc	r25
    11c4:	0c 94 e8 08 	jmp	0x11d0	; 0x11d0 <__fp_mintl>
    11c8:	0c 94 03 09 	jmp	0x1206	; 0x1206 <__fp_mpack>
    11cc:	0c 94 d6 07 	jmp	0xfac	; 0xfac <__fp_szero>

000011d0 <__fp_mintl>:
    11d0:	88 23       	and	r24, r24
    11d2:	71 f4       	brne	.+28     	; 0x11f0 <__fp_mintl+0x20>
    11d4:	77 23       	and	r23, r23
    11d6:	21 f0       	breq	.+8      	; 0x11e0 <__fp_mintl+0x10>
    11d8:	98 50       	subi	r25, 0x08	; 8
    11da:	87 2b       	or	r24, r23
    11dc:	76 2f       	mov	r23, r22
    11de:	07 c0       	rjmp	.+14     	; 0x11ee <__fp_mintl+0x1e>
    11e0:	66 23       	and	r22, r22
    11e2:	11 f4       	brne	.+4      	; 0x11e8 <__fp_mintl+0x18>
    11e4:	99 27       	eor	r25, r25
    11e6:	0d c0       	rjmp	.+26     	; 0x1202 <__fp_mintl+0x32>
    11e8:	90 51       	subi	r25, 0x10	; 16
    11ea:	86 2b       	or	r24, r22
    11ec:	70 e0       	ldi	r23, 0x00	; 0
    11ee:	60 e0       	ldi	r22, 0x00	; 0
    11f0:	2a f0       	brmi	.+10     	; 0x11fc <__fp_mintl+0x2c>
    11f2:	9a 95       	dec	r25
    11f4:	66 0f       	add	r22, r22
    11f6:	77 1f       	adc	r23, r23
    11f8:	88 1f       	adc	r24, r24
    11fa:	da f7       	brpl	.-10     	; 0x11f2 <__fp_mintl+0x22>
    11fc:	88 0f       	add	r24, r24
    11fe:	96 95       	lsr	r25
    1200:	87 95       	ror	r24
    1202:	97 f9       	bld	r25, 7
    1204:	08 95       	ret

00001206 <__fp_mpack>:
    1206:	9f 3f       	cpi	r25, 0xFF	; 255
    1208:	31 f0       	breq	.+12     	; 0x1216 <__fp_mpack_finite+0xc>

0000120a <__fp_mpack_finite>:
    120a:	91 50       	subi	r25, 0x01	; 1
    120c:	20 f4       	brcc	.+8      	; 0x1216 <__fp_mpack_finite+0xc>
    120e:	87 95       	ror	r24
    1210:	77 95       	ror	r23
    1212:	67 95       	ror	r22
    1214:	b7 95       	ror	r27
    1216:	88 0f       	add	r24, r24
    1218:	91 1d       	adc	r25, r1
    121a:	96 95       	lsr	r25
    121c:	87 95       	ror	r24
    121e:	97 f9       	bld	r25, 7
    1220:	08 95       	ret

00001222 <malloc>:
    1222:	0f 93       	push	r16
    1224:	1f 93       	push	r17
    1226:	cf 93       	push	r28
    1228:	df 93       	push	r29
    122a:	82 30       	cpi	r24, 0x02	; 2
    122c:	91 05       	cpc	r25, r1
    122e:	10 f4       	brcc	.+4      	; 0x1234 <malloc+0x12>
    1230:	82 e0       	ldi	r24, 0x02	; 2
    1232:	90 e0       	ldi	r25, 0x00	; 0
    1234:	e0 91 5c 3e 	lds	r30, 0x3E5C	; 0x803e5c <__flp>
    1238:	f0 91 5d 3e 	lds	r31, 0x3E5D	; 0x803e5d <__flp+0x1>
    123c:	20 e0       	ldi	r18, 0x00	; 0
    123e:	30 e0       	ldi	r19, 0x00	; 0
    1240:	a0 e0       	ldi	r26, 0x00	; 0
    1242:	b0 e0       	ldi	r27, 0x00	; 0
    1244:	30 97       	sbiw	r30, 0x00	; 0
    1246:	19 f1       	breq	.+70     	; 0x128e <malloc+0x6c>
    1248:	40 81       	ld	r20, Z
    124a:	51 81       	ldd	r21, Z+1	; 0x01
    124c:	02 81       	ldd	r16, Z+2	; 0x02
    124e:	13 81       	ldd	r17, Z+3	; 0x03
    1250:	48 17       	cp	r20, r24
    1252:	59 07       	cpc	r21, r25
    1254:	c8 f0       	brcs	.+50     	; 0x1288 <malloc+0x66>
    1256:	84 17       	cp	r24, r20
    1258:	95 07       	cpc	r25, r21
    125a:	69 f4       	brne	.+26     	; 0x1276 <malloc+0x54>
    125c:	10 97       	sbiw	r26, 0x00	; 0
    125e:	31 f0       	breq	.+12     	; 0x126c <malloc+0x4a>
    1260:	12 96       	adiw	r26, 0x02	; 2
    1262:	0c 93       	st	X, r16
    1264:	12 97       	sbiw	r26, 0x02	; 2
    1266:	13 96       	adiw	r26, 0x03	; 3
    1268:	1c 93       	st	X, r17
    126a:	27 c0       	rjmp	.+78     	; 0x12ba <malloc+0x98>
    126c:	00 93 5c 3e 	sts	0x3E5C, r16	; 0x803e5c <__flp>
    1270:	10 93 5d 3e 	sts	0x3E5D, r17	; 0x803e5d <__flp+0x1>
    1274:	22 c0       	rjmp	.+68     	; 0x12ba <malloc+0x98>
    1276:	21 15       	cp	r18, r1
    1278:	31 05       	cpc	r19, r1
    127a:	19 f0       	breq	.+6      	; 0x1282 <malloc+0x60>
    127c:	42 17       	cp	r20, r18
    127e:	53 07       	cpc	r21, r19
    1280:	18 f4       	brcc	.+6      	; 0x1288 <malloc+0x66>
    1282:	9a 01       	movw	r18, r20
    1284:	bd 01       	movw	r22, r26
    1286:	ef 01       	movw	r28, r30
    1288:	df 01       	movw	r26, r30
    128a:	f8 01       	movw	r30, r16
    128c:	db cf       	rjmp	.-74     	; 0x1244 <malloc+0x22>
    128e:	21 15       	cp	r18, r1
    1290:	31 05       	cpc	r19, r1
    1292:	f9 f0       	breq	.+62     	; 0x12d2 <malloc+0xb0>
    1294:	28 1b       	sub	r18, r24
    1296:	39 0b       	sbc	r19, r25
    1298:	24 30       	cpi	r18, 0x04	; 4
    129a:	31 05       	cpc	r19, r1
    129c:	80 f4       	brcc	.+32     	; 0x12be <malloc+0x9c>
    129e:	8a 81       	ldd	r24, Y+2	; 0x02
    12a0:	9b 81       	ldd	r25, Y+3	; 0x03
    12a2:	61 15       	cp	r22, r1
    12a4:	71 05       	cpc	r23, r1
    12a6:	21 f0       	breq	.+8      	; 0x12b0 <malloc+0x8e>
    12a8:	fb 01       	movw	r30, r22
    12aa:	82 83       	std	Z+2, r24	; 0x02
    12ac:	93 83       	std	Z+3, r25	; 0x03
    12ae:	04 c0       	rjmp	.+8      	; 0x12b8 <malloc+0x96>
    12b0:	80 93 5c 3e 	sts	0x3E5C, r24	; 0x803e5c <__flp>
    12b4:	90 93 5d 3e 	sts	0x3E5D, r25	; 0x803e5d <__flp+0x1>
    12b8:	fe 01       	movw	r30, r28
    12ba:	32 96       	adiw	r30, 0x02	; 2
    12bc:	44 c0       	rjmp	.+136    	; 0x1346 <malloc+0x124>
    12be:	fe 01       	movw	r30, r28
    12c0:	e2 0f       	add	r30, r18
    12c2:	f3 1f       	adc	r31, r19
    12c4:	81 93       	st	Z+, r24
    12c6:	91 93       	st	Z+, r25
    12c8:	22 50       	subi	r18, 0x02	; 2
    12ca:	31 09       	sbc	r19, r1
    12cc:	28 83       	st	Y, r18
    12ce:	39 83       	std	Y+1, r19	; 0x01
    12d0:	3a c0       	rjmp	.+116    	; 0x1346 <malloc+0x124>
    12d2:	20 91 5a 3e 	lds	r18, 0x3E5A	; 0x803e5a <__brkval>
    12d6:	30 91 5b 3e 	lds	r19, 0x3E5B	; 0x803e5b <__brkval+0x1>
    12da:	23 2b       	or	r18, r19
    12dc:	41 f4       	brne	.+16     	; 0x12ee <malloc+0xcc>
    12de:	20 91 02 3e 	lds	r18, 0x3E02	; 0x803e02 <__malloc_heap_start>
    12e2:	30 91 03 3e 	lds	r19, 0x3E03	; 0x803e03 <__malloc_heap_start+0x1>
    12e6:	20 93 5a 3e 	sts	0x3E5A, r18	; 0x803e5a <__brkval>
    12ea:	30 93 5b 3e 	sts	0x3E5B, r19	; 0x803e5b <__brkval+0x1>
    12ee:	20 91 00 3e 	lds	r18, 0x3E00	; 0x803e00 <__data_start>
    12f2:	30 91 01 3e 	lds	r19, 0x3E01	; 0x803e01 <__data_start+0x1>
    12f6:	21 15       	cp	r18, r1
    12f8:	31 05       	cpc	r19, r1
    12fa:	41 f4       	brne	.+16     	; 0x130c <malloc+0xea>
    12fc:	2d b7       	in	r18, 0x3d	; 61
    12fe:	3e b7       	in	r19, 0x3e	; 62
    1300:	40 91 04 3e 	lds	r20, 0x3E04	; 0x803e04 <__malloc_margin>
    1304:	50 91 05 3e 	lds	r21, 0x3E05	; 0x803e05 <__malloc_margin+0x1>
    1308:	24 1b       	sub	r18, r20
    130a:	35 0b       	sbc	r19, r21
    130c:	e0 91 5a 3e 	lds	r30, 0x3E5A	; 0x803e5a <__brkval>
    1310:	f0 91 5b 3e 	lds	r31, 0x3E5B	; 0x803e5b <__brkval+0x1>
    1314:	e2 17       	cp	r30, r18
    1316:	f3 07       	cpc	r31, r19
    1318:	a0 f4       	brcc	.+40     	; 0x1342 <malloc+0x120>
    131a:	2e 1b       	sub	r18, r30
    131c:	3f 0b       	sbc	r19, r31
    131e:	28 17       	cp	r18, r24
    1320:	39 07       	cpc	r19, r25
    1322:	78 f0       	brcs	.+30     	; 0x1342 <malloc+0x120>
    1324:	ac 01       	movw	r20, r24
    1326:	4e 5f       	subi	r20, 0xFE	; 254
    1328:	5f 4f       	sbci	r21, 0xFF	; 255
    132a:	24 17       	cp	r18, r20
    132c:	35 07       	cpc	r19, r21
    132e:	48 f0       	brcs	.+18     	; 0x1342 <malloc+0x120>
    1330:	4e 0f       	add	r20, r30
    1332:	5f 1f       	adc	r21, r31
    1334:	40 93 5a 3e 	sts	0x3E5A, r20	; 0x803e5a <__brkval>
    1338:	50 93 5b 3e 	sts	0x3E5B, r21	; 0x803e5b <__brkval+0x1>
    133c:	81 93       	st	Z+, r24
    133e:	91 93       	st	Z+, r25
    1340:	02 c0       	rjmp	.+4      	; 0x1346 <malloc+0x124>
    1342:	e0 e0       	ldi	r30, 0x00	; 0
    1344:	f0 e0       	ldi	r31, 0x00	; 0
    1346:	cf 01       	movw	r24, r30
    1348:	df 91       	pop	r29
    134a:	cf 91       	pop	r28
    134c:	1f 91       	pop	r17
    134e:	0f 91       	pop	r16
    1350:	08 95       	ret

00001352 <free>:
    1352:	cf 93       	push	r28
    1354:	df 93       	push	r29
    1356:	00 97       	sbiw	r24, 0x00	; 0
    1358:	09 f4       	brne	.+2      	; 0x135c <free+0xa>
    135a:	81 c0       	rjmp	.+258    	; 0x145e <free+0x10c>
    135c:	fc 01       	movw	r30, r24
    135e:	32 97       	sbiw	r30, 0x02	; 2
    1360:	12 82       	std	Z+2, r1	; 0x02
    1362:	13 82       	std	Z+3, r1	; 0x03
    1364:	a0 91 5c 3e 	lds	r26, 0x3E5C	; 0x803e5c <__flp>
    1368:	b0 91 5d 3e 	lds	r27, 0x3E5D	; 0x803e5d <__flp+0x1>
    136c:	10 97       	sbiw	r26, 0x00	; 0
    136e:	81 f4       	brne	.+32     	; 0x1390 <free+0x3e>
    1370:	20 81       	ld	r18, Z
    1372:	31 81       	ldd	r19, Z+1	; 0x01
    1374:	82 0f       	add	r24, r18
    1376:	93 1f       	adc	r25, r19
    1378:	20 91 5a 3e 	lds	r18, 0x3E5A	; 0x803e5a <__brkval>
    137c:	30 91 5b 3e 	lds	r19, 0x3E5B	; 0x803e5b <__brkval+0x1>
    1380:	28 17       	cp	r18, r24
    1382:	39 07       	cpc	r19, r25
    1384:	51 f5       	brne	.+84     	; 0x13da <free+0x88>
    1386:	e0 93 5a 3e 	sts	0x3E5A, r30	; 0x803e5a <__brkval>
    138a:	f0 93 5b 3e 	sts	0x3E5B, r31	; 0x803e5b <__brkval+0x1>
    138e:	67 c0       	rjmp	.+206    	; 0x145e <free+0x10c>
    1390:	ed 01       	movw	r28, r26
    1392:	20 e0       	ldi	r18, 0x00	; 0
    1394:	30 e0       	ldi	r19, 0x00	; 0
    1396:	ce 17       	cp	r28, r30
    1398:	df 07       	cpc	r29, r31
    139a:	40 f4       	brcc	.+16     	; 0x13ac <free+0x5a>
    139c:	4a 81       	ldd	r20, Y+2	; 0x02
    139e:	5b 81       	ldd	r21, Y+3	; 0x03
    13a0:	9e 01       	movw	r18, r28
    13a2:	41 15       	cp	r20, r1
    13a4:	51 05       	cpc	r21, r1
    13a6:	f1 f0       	breq	.+60     	; 0x13e4 <free+0x92>
    13a8:	ea 01       	movw	r28, r20
    13aa:	f5 cf       	rjmp	.-22     	; 0x1396 <free+0x44>
    13ac:	c2 83       	std	Z+2, r28	; 0x02
    13ae:	d3 83       	std	Z+3, r29	; 0x03
    13b0:	40 81       	ld	r20, Z
    13b2:	51 81       	ldd	r21, Z+1	; 0x01
    13b4:	84 0f       	add	r24, r20
    13b6:	95 1f       	adc	r25, r21
    13b8:	c8 17       	cp	r28, r24
    13ba:	d9 07       	cpc	r29, r25
    13bc:	59 f4       	brne	.+22     	; 0x13d4 <free+0x82>
    13be:	88 81       	ld	r24, Y
    13c0:	99 81       	ldd	r25, Y+1	; 0x01
    13c2:	84 0f       	add	r24, r20
    13c4:	95 1f       	adc	r25, r21
    13c6:	02 96       	adiw	r24, 0x02	; 2
    13c8:	80 83       	st	Z, r24
    13ca:	91 83       	std	Z+1, r25	; 0x01
    13cc:	8a 81       	ldd	r24, Y+2	; 0x02
    13ce:	9b 81       	ldd	r25, Y+3	; 0x03
    13d0:	82 83       	std	Z+2, r24	; 0x02
    13d2:	93 83       	std	Z+3, r25	; 0x03
    13d4:	21 15       	cp	r18, r1
    13d6:	31 05       	cpc	r19, r1
    13d8:	29 f4       	brne	.+10     	; 0x13e4 <free+0x92>
    13da:	e0 93 5c 3e 	sts	0x3E5C, r30	; 0x803e5c <__flp>
    13de:	f0 93 5d 3e 	sts	0x3E5D, r31	; 0x803e5d <__flp+0x1>
    13e2:	3d c0       	rjmp	.+122    	; 0x145e <free+0x10c>
    13e4:	e9 01       	movw	r28, r18
    13e6:	ea 83       	std	Y+2, r30	; 0x02
    13e8:	fb 83       	std	Y+3, r31	; 0x03
    13ea:	49 91       	ld	r20, Y+
    13ec:	59 91       	ld	r21, Y+
    13ee:	c4 0f       	add	r28, r20
    13f0:	d5 1f       	adc	r29, r21
    13f2:	ec 17       	cp	r30, r28
    13f4:	fd 07       	cpc	r31, r29
    13f6:	61 f4       	brne	.+24     	; 0x1410 <free+0xbe>
    13f8:	80 81       	ld	r24, Z
    13fa:	91 81       	ldd	r25, Z+1	; 0x01
    13fc:	84 0f       	add	r24, r20
    13fe:	95 1f       	adc	r25, r21
    1400:	02 96       	adiw	r24, 0x02	; 2
    1402:	e9 01       	movw	r28, r18
    1404:	88 83       	st	Y, r24
    1406:	99 83       	std	Y+1, r25	; 0x01
    1408:	82 81       	ldd	r24, Z+2	; 0x02
    140a:	93 81       	ldd	r25, Z+3	; 0x03
    140c:	8a 83       	std	Y+2, r24	; 0x02
    140e:	9b 83       	std	Y+3, r25	; 0x03
    1410:	e0 e0       	ldi	r30, 0x00	; 0
    1412:	f0 e0       	ldi	r31, 0x00	; 0
    1414:	12 96       	adiw	r26, 0x02	; 2
    1416:	8d 91       	ld	r24, X+
    1418:	9c 91       	ld	r25, X
    141a:	13 97       	sbiw	r26, 0x03	; 3
    141c:	00 97       	sbiw	r24, 0x00	; 0
    141e:	19 f0       	breq	.+6      	; 0x1426 <free+0xd4>
    1420:	fd 01       	movw	r30, r26
    1422:	dc 01       	movw	r26, r24
    1424:	f7 cf       	rjmp	.-18     	; 0x1414 <free+0xc2>
    1426:	8d 91       	ld	r24, X+
    1428:	9c 91       	ld	r25, X
    142a:	11 97       	sbiw	r26, 0x01	; 1
    142c:	9d 01       	movw	r18, r26
    142e:	2e 5f       	subi	r18, 0xFE	; 254
    1430:	3f 4f       	sbci	r19, 0xFF	; 255
    1432:	82 0f       	add	r24, r18
    1434:	93 1f       	adc	r25, r19
    1436:	20 91 5a 3e 	lds	r18, 0x3E5A	; 0x803e5a <__brkval>
    143a:	30 91 5b 3e 	lds	r19, 0x3E5B	; 0x803e5b <__brkval+0x1>
    143e:	28 17       	cp	r18, r24
    1440:	39 07       	cpc	r19, r25
    1442:	69 f4       	brne	.+26     	; 0x145e <free+0x10c>
    1444:	30 97       	sbiw	r30, 0x00	; 0
    1446:	29 f4       	brne	.+10     	; 0x1452 <free+0x100>
    1448:	10 92 5c 3e 	sts	0x3E5C, r1	; 0x803e5c <__flp>
    144c:	10 92 5d 3e 	sts	0x3E5D, r1	; 0x803e5d <__flp+0x1>
    1450:	02 c0       	rjmp	.+4      	; 0x1456 <free+0x104>
    1452:	12 82       	std	Z+2, r1	; 0x02
    1454:	13 82       	std	Z+3, r1	; 0x03
    1456:	a0 93 5a 3e 	sts	0x3E5A, r26	; 0x803e5a <__brkval>
    145a:	b0 93 5b 3e 	sts	0x3E5B, r27	; 0x803e5b <__brkval+0x1>
    145e:	df 91       	pop	r29
    1460:	cf 91       	pop	r28
    1462:	08 95       	ret

00001464 <_exit>:
    1464:	f8 94       	cli

00001466 <__stop_program>:
    1466:	ff cf       	rjmp	.-2      	; 0x1466 <__stop_program>
