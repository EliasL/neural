
Building_Brains_V4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000e  00803e00  000014a4  00001538  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000014a4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000004f  00803e0e  00803e0e  00001546  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001546  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001578  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000420  00000000  00000000  000015b8  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00006fe7  00000000  00000000  000019d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002dbc  00000000  00000000  000089bf  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00002395  00000000  00000000  0000b77b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000794  00000000  00000000  0000db10  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002d0c  00000000  00000000  0000e2a4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001579  00000000  00000000  00010fb0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000280  00000000  00000000  00012529  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	2d c0       	rjmp	.+90     	; 0x5c <__ctors_end>
       2:	47 c0       	rjmp	.+142    	; 0x92 <__bad_interrupt>
       4:	46 c0       	rjmp	.+140    	; 0x92 <__bad_interrupt>
       6:	45 c0       	rjmp	.+138    	; 0x92 <__bad_interrupt>
       8:	44 c0       	rjmp	.+136    	; 0x92 <__bad_interrupt>
       a:	43 c0       	rjmp	.+134    	; 0x92 <__bad_interrupt>
       c:	58 c5       	rjmp	.+2736   	; 0xabe <__vector_6>
       e:	41 c0       	rjmp	.+130    	; 0x92 <__bad_interrupt>
      10:	40 c0       	rjmp	.+128    	; 0x92 <__bad_interrupt>
      12:	3f c0       	rjmp	.+126    	; 0x92 <__bad_interrupt>
      14:	3e c0       	rjmp	.+124    	; 0x92 <__bad_interrupt>
      16:	3d c0       	rjmp	.+122    	; 0x92 <__bad_interrupt>
      18:	3c c0       	rjmp	.+120    	; 0x92 <__bad_interrupt>
      1a:	3b c0       	rjmp	.+118    	; 0x92 <__bad_interrupt>
      1c:	3a c0       	rjmp	.+116    	; 0x92 <__bad_interrupt>
      1e:	39 c0       	rjmp	.+114    	; 0x92 <__bad_interrupt>
      20:	38 c0       	rjmp	.+112    	; 0x92 <__bad_interrupt>
      22:	37 c0       	rjmp	.+110    	; 0x92 <__bad_interrupt>
      24:	36 c0       	rjmp	.+108    	; 0x92 <__bad_interrupt>
      26:	35 c0       	rjmp	.+106    	; 0x92 <__bad_interrupt>
      28:	34 c0       	rjmp	.+104    	; 0x92 <__bad_interrupt>
      2a:	33 c0       	rjmp	.+102    	; 0x92 <__bad_interrupt>
      2c:	32 c0       	rjmp	.+100    	; 0x92 <__bad_interrupt>
      2e:	31 c0       	rjmp	.+98     	; 0x92 <__bad_interrupt>
      30:	30 c0       	rjmp	.+96     	; 0x92 <__bad_interrupt>
      32:	2f c0       	rjmp	.+94     	; 0x92 <__bad_interrupt>
      34:	07 63       	ori	r16, 0x37	; 55
      36:	42 36       	cpi	r20, 0x62	; 98
      38:	b7 9b       	sbis	0x16, 7	; 22
      3a:	d8 a7       	std	Y+40, r29	; 0x28
      3c:	1a 39       	cpi	r17, 0x9A	; 154
      3e:	68 56       	subi	r22, 0x68	; 104
      40:	18 ae       	std	Y+56, r1	; 0x38
      42:	ba ab       	std	Y+50, r27	; 0x32
      44:	55 8c       	ldd	r5, Z+29	; 0x1d
      46:	1d 3c       	cpi	r17, 0xCD	; 205
      48:	b7 cc       	rjmp	.-1682   	; 0xfffff9b8 <__eeprom_end+0xff7ef9b8>
      4a:	57 63       	ori	r21, 0x37	; 55
      4c:	bd 6d       	ori	r27, 0xDD	; 221
      4e:	ed fd       	.word	0xfded	; ????
      50:	75 3e       	cpi	r23, 0xE5	; 229
      52:	f6 17       	cp	r31, r22
      54:	72 31       	cpi	r23, 0x12	; 18
      56:	bf 00       	.word	0x00bf	; ????
      58:	00 00       	nop
      5a:	80 3f       	cpi	r24, 0xF0	; 240

0000005c <__ctors_end>:
      5c:	11 24       	eor	r1, r1
      5e:	1f be       	out	0x3f, r1	; 63
      60:	cf ef       	ldi	r28, 0xFF	; 255
      62:	cd bf       	out	0x3d, r28	; 61
      64:	df e3       	ldi	r29, 0x3F	; 63
      66:	de bf       	out	0x3e, r29	; 62

00000068 <__do_copy_data>:
      68:	1e e3       	ldi	r17, 0x3E	; 62
      6a:	a0 e0       	ldi	r26, 0x00	; 0
      6c:	be e3       	ldi	r27, 0x3E	; 62
      6e:	e4 ea       	ldi	r30, 0xA4	; 164
      70:	f4 e1       	ldi	r31, 0x14	; 20
      72:	02 c0       	rjmp	.+4      	; 0x78 <__do_copy_data+0x10>
      74:	05 90       	lpm	r0, Z+
      76:	0d 92       	st	X+, r0
      78:	ae 30       	cpi	r26, 0x0E	; 14
      7a:	b1 07       	cpc	r27, r17
      7c:	d9 f7       	brne	.-10     	; 0x74 <__do_copy_data+0xc>

0000007e <__do_clear_bss>:
      7e:	2e e3       	ldi	r18, 0x3E	; 62
      80:	ae e0       	ldi	r26, 0x0E	; 14
      82:	be e3       	ldi	r27, 0x3E	; 62
      84:	01 c0       	rjmp	.+2      	; 0x88 <.do_clear_bss_start>

00000086 <.do_clear_bss_loop>:
      86:	1d 92       	st	X+, r1

00000088 <.do_clear_bss_start>:
      88:	ad 35       	cpi	r26, 0x5D	; 93
      8a:	b2 07       	cpc	r27, r18
      8c:	e1 f7       	brne	.-8      	; 0x86 <.do_clear_bss_loop>
      8e:	fa d1       	rcall	.+1012   	; 0x484 <main>
      90:	07 ca       	rjmp	.-3058   	; 0xfffff4a0 <__eeprom_end+0xff7ef4a0>

00000092 <__bad_interrupt>:
      92:	b6 cf       	rjmp	.-148    	; 0x0 <__vectors>

00000094 <atmel_start_init>:
/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
	system_init();
      94:	b8 d0       	rcall	.+368    	; 0x206 <system_init>
      96:	08 95       	ret

00000098 <ADC_init>:
 * \return Conversion result read from the ADC ADC module
 */
adc_result_t ADC_get_conversion_result(void)
{
	return (ADC0.RES);
}
      98:	85 e0       	ldi	r24, 0x05	; 5
      9a:	80 93 00 06 	sts	0x0600, r24	; 0x800600 <__TEXT_REGION_LENGTH__+0x700600>
      9e:	80 e0       	ldi	r24, 0x00	; 0
      a0:	08 95       	ret

000000a2 <ADC_is_conversion_done>:
      a2:	80 91 0b 06 	lds	r24, 0x060B	; 0x80060b <__TEXT_REGION_LENGTH__+0x70060b>
      a6:	81 70       	andi	r24, 0x01	; 1
      a8:	08 95       	ret

000000aa <ADC_get_conversion>:
 *
 * \return Nothing
 */
void ADC_start_conversion(adc_0_channel_t channel)
{
	ADC0.MUXPOS  = channel;
      aa:	e0 e0       	ldi	r30, 0x00	; 0
      ac:	f6 e0       	ldi	r31, 0x06	; 6
      ae:	86 83       	std	Z+6, r24	; 0x06
	ADC0.COMMAND = ADC_STCONV_bm;
      b0:	81 e0       	ldi	r24, 0x01	; 1
      b2:	80 87       	std	Z+8, r24	; 0x08
adc_result_t ADC_get_conversion(adc_0_channel_t channel)
{
	adc_result_t res;

	ADC_start_conversion(channel);
	while (!ADC_is_conversion_done())
      b4:	f6 df       	rcall	.-20     	; 0xa2 <ADC_is_conversion_done>
      b6:	88 23       	and	r24, r24
      b8:	e9 f3       	breq	.-6      	; 0xb4 <ADC_get_conversion+0xa>
 *
 * \return Conversion result read from the ADC ADC module
 */
adc_result_t ADC_get_conversion_result(void)
{
	return (ADC0.RES);
      ba:	e0 e0       	ldi	r30, 0x00	; 0
      bc:	f6 e0       	ldi	r31, 0x06	; 6
      be:	20 89       	ldd	r18, Z+16	; 0x10
      c0:	31 89       	ldd	r19, Z+17	; 0x11

	ADC_start_conversion(channel);
	while (!ADC_is_conversion_done())
		;
	res = ADC_get_conversion_result();
	ADC0.INTFLAGS |= ADC_RESRDY_bm;
      c2:	93 85       	ldd	r25, Z+11	; 0x0b
      c4:	91 60       	ori	r25, 0x01	; 1
      c6:	93 87       	std	Z+11, r25	; 0x0b
	return res;
}
      c8:	c9 01       	movw	r24, r18
      ca:	08 95       	ret

000000cc <BOD_init>:
	//		 | BOD_VLMCFG_ABOVE_gc; /* Interrupt when supply goes above VLM level */

	// BOD.VLMCTRLA = BOD_VLMLVL_5ABOVE_gc; /* VLM threshold 5% above BOD level */

	return 0;
}
      cc:	80 e0       	ldi	r24, 0x00	; 0
      ce:	08 95       	ret

000000d0 <DIGGSIGG_init>:
	//		 | CCL_EDGEDET_DIS_gc /* Edge detector is disabled */
	//		 | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	//		 | 0 << CCL_ENABLE_bp /* LUT Enable: disabled */
	//		 | 0 << CCL_OUTEN_bp; /* Output Enable: disabled */

	CCL.TRUTH1 = 168; /* Truth 1: 168 */
      d0:	e0 ec       	ldi	r30, 0xC0	; 192
      d2:	f1 e0       	ldi	r31, 0x01	; 1
      d4:	88 ea       	ldi	r24, 0xA8	; 168
      d6:	84 87       	std	Z+12, r24	; 0x0c

	CCL.LUT1CTRLC = CCL_INSEL2_TCA0_gc /* TCA0 WO2 input source */;
      d8:	88 e0       	ldi	r24, 0x08	; 8
      da:	83 87       	std	Z+11, r24	; 0x0b

	CCL.LUT1CTRLB = CCL_INSEL0_SPI0_gc /* SPI0 SCK source */
      dc:	8b eb       	ldi	r24, 0xBB	; 187
      de:	82 87       	std	Z+10, r24	; 0x0a
	                | CCL_INSEL1_SPI0_gc /* SPI0 MOSI input source */;

	CCL.LUT1CTRLA = 0 << CCL_CLKSRC_bp       /* Clock Source Selection: disabled */
      e0:	89 e0       	ldi	r24, 0x09	; 9
      e2:	81 87       	std	Z+9, r24	; 0x09
	                | CCL_EDGEDET_DIS_gc     /* Edge detector is disabled */
	                | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	                | 1 << CCL_ENABLE_bp     /* LUT Enable: enabled */
	                | 1 << CCL_OUTEN_bp;     /* Output Enable: enabled */

	CCL.CTRLA = 1 << CCL_ENABLE_bp      /* Enable: enabled */
      e4:	81 e4       	ldi	r24, 0x41	; 65
      e6:	80 83       	st	Z, r24
	            | 1 << CCL_RUNSTDBY_bp; /* Run in Standby: enabled */

	return 0;
}
      e8:	80 e0       	ldi	r24, 0x00	; 0
      ea:	08 95       	ret

000000ec <CLKCTRL_init>:
 *       on calling convention. The memory model is not visible to the
 *       preprocessor, so it must be defined in the Assembler preprocessor directives.
 */
static inline void ccp_write_io(void *addr, uint8_t value)
{
	protected_write_io(addr, CCP_IOREG_gc, value);
      ec:	47 e0       	ldi	r20, 0x07	; 7
      ee:	68 ed       	ldi	r22, 0xD8	; 216
      f0:	8c e7       	ldi	r24, 0x7C	; 124
      f2:	90 e0       	ldi	r25, 0x00	; 0
      f4:	a2 d0       	rcall	.+324    	; 0x23a <protected_write_io>
      f6:	41 e0       	ldi	r20, 0x01	; 1
      f8:	68 ed       	ldi	r22, 0xD8	; 216
      fa:	81 e6       	ldi	r24, 0x61	; 97
      fc:	90 e0       	ldi	r25, 0x00	; 0
      fe:	9d d0       	rcall	.+314    	; 0x23a <protected_write_io>
	//		 | 0 << CLKCTRL_CLKOUT_bp /* System clock out: disabled */);

	// ccp_write_io((void*)&(CLKCTRL.MCLKLOCK),0 << CLKCTRL_LOCKEN_bp /* lock enable: disabled */);

	return 0;
}
     100:	80 e0       	ldi	r24, 0x00	; 0
     102:	08 95       	ret

00000104 <CPUINT_init>:

	// CPUINT.LVL0PRI = 0x0 << CPUINT_LVL0PRI_gp; /* Interrupt Level Priority: 0x0 */

	// CPUINT.LVL1VEC = 0x0 << CPUINT_LVL1VEC_gp; /* Interrupt Vector with High Priority: 0x0 */

	ENABLE_INTERRUPTS();
     104:	78 94       	sei

	return 0;
}
     106:	80 e0       	ldi	r24, 0x00	; 0
     108:	08 95       	ret

0000010a <DAC_init>:
 *
 * \return Nothing
 */
void DAC_disable()
{
	DAC0.CTRLA &= ~DAC_ENABLE_bm;
     10a:	81 e4       	ldi	r24, 0x41	; 65
     10c:	80 93 80 06 	sts	0x0680, r24	; 0x800680 <__TEXT_REGION_LENGTH__+0x700680>
     110:	80 e0       	ldi	r24, 0x00	; 0
     112:	08 95       	ret

00000114 <DAC_set_output>:
 *
 * \return Nothing
 */
void DAC_set_output(dac_resolution_t value)
{
	DAC0.DATA = value;
     114:	80 93 81 06 	sts	0x0681, r24	; 0x800681 <__TEXT_REGION_LENGTH__+0x700681>
     118:	08 95       	ret

0000011a <mcu_init>:
#ifdef __cplusplus
extern "C" {
#endif

void mcu_init(void)
{
     11a:	e0 e1       	ldi	r30, 0x10	; 16
     11c:	f4 e0       	ldi	r31, 0x04	; 4
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     11e:	80 81       	ld	r24, Z
     120:	88 60       	ori	r24, 0x08	; 8
     122:	81 93       	st	Z+, r24
	 * disables all peripherals to save power. Driver shall enable
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
     124:	e8 31       	cpi	r30, 0x18	; 24
     126:	84 e0       	ldi	r24, 0x04	; 4
     128:	f8 07       	cpc	r31, r24
     12a:	c9 f7       	brne	.-14     	; 0x11e <mcu_init+0x4>
     12c:	e0 e3       	ldi	r30, 0x30	; 48
     12e:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     130:	80 81       	ld	r24, Z
     132:	88 60       	ori	r24, 0x08	; 8
     134:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     136:	e8 33       	cpi	r30, 0x38	; 56
     138:	84 e0       	ldi	r24, 0x04	; 4
     13a:	f8 07       	cpc	r31, r24
     13c:	c9 f7       	brne	.-14     	; 0x130 <mcu_init+0x16>
     13e:	e0 e5       	ldi	r30, 0x50	; 80
     140:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     142:	80 81       	ld	r24, Z
     144:	88 60       	ori	r24, 0x08	; 8
     146:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     148:	e8 35       	cpi	r30, 0x58	; 88
     14a:	84 e0       	ldi	r24, 0x04	; 4
     14c:	f8 07       	cpc	r31, r24
     14e:	c9 f7       	brne	.-14     	; 0x142 <mcu_init+0x28>
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}
}
     150:	08 95       	ret

00000152 <ADC_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     152:	e5 e1       	ldi	r30, 0x15	; 21
     154:	f4 e0       	ldi	r31, 0x04	; 4
     156:	80 81       	ld	r24, Z
     158:	88 7f       	andi	r24, 0xF8	; 248
     15a:	84 60       	ori	r24, 0x04	; 4
     15c:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     15e:	80 81       	ld	r24, Z
     160:	87 7f       	andi	r24, 0xF7	; 247
     162:	80 83       	st	Z, r24
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     164:	e7 e1       	ldi	r30, 0x17	; 23
     166:	f4 e0       	ldi	r31, 0x04	; 4
     168:	80 81       	ld	r24, Z
     16a:	88 7f       	andi	r24, 0xF8	; 248
     16c:	84 60       	ori	r24, 0x04	; 4
     16e:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     170:	80 81       	ld	r24, Z
     172:	87 7f       	andi	r24, 0xF7	; 247
     174:	80 83       	st	Z, r24
 */
static inline void PORTB_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     176:	e4 e3       	ldi	r30, 0x34	; 52
     178:	f4 e0       	ldi	r31, 0x04	; 4
     17a:	80 81       	ld	r24, Z
     17c:	88 7f       	andi	r24, 0xF8	; 248
     17e:	84 60       	ori	r24, 0x04	; 4
     180:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     182:	80 81       	ld	r24, Z
     184:	87 7f       	andi	r24, 0xF7	; 247
     186:	80 83       	st	Z, r24
 */
static inline void PORTB_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     188:	e1 e3       	ldi	r30, 0x31	; 49
     18a:	f4 e0       	ldi	r31, 0x04	; 4
     18c:	80 81       	ld	r24, Z
     18e:	88 7f       	andi	r24, 0xF8	; 248
     190:	84 60       	ori	r24, 0x04	; 4
     192:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     194:	80 81       	ld	r24, Z
     196:	87 7f       	andi	r24, 0xF7	; 247
     198:	80 83       	st	Z, r24
 */
static inline void PORTB_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     19a:	e0 e3       	ldi	r30, 0x30	; 48
     19c:	f4 e0       	ldi	r31, 0x04	; 4
     19e:	80 81       	ld	r24, Z
     1a0:	88 7f       	andi	r24, 0xF8	; 248
     1a2:	84 60       	ori	r24, 0x04	; 4
     1a4:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     1a6:	80 81       	ld	r24, Z
     1a8:	87 7f       	andi	r24, 0xF7	; 247
     1aa:	80 83       	st	Z, r24
	// Disable digital input buffer
	DEN4_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	DEN4_PIN_set_pull_mode(PORT_PULL_OFF);

	ADC_init();
     1ac:	75 df       	rcall	.-278    	; 0x98 <ADC_init>
     1ae:	08 95       	ret

000001b0 <TIMER_0_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     1b0:	25 9a       	sbi	0x04, 5	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     1b2:	2d 98       	cbi	0x05, 5	; 5
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLC |= PORTMUX_TCA02_bm;
     1b4:	e0 e0       	ldi	r30, 0x00	; 0
     1b6:	f2 e0       	ldi	r31, 0x02	; 2
     1b8:	82 81       	ldd	r24, Z+2	; 0x02
     1ba:	84 60       	ori	r24, 0x04	; 4
     1bc:	82 83       	std	Z+2, r24	; 0x02

	TIMER_0_init();
     1be:	eb d0       	rcall	.+470    	; 0x396 <TIMER_0_init>
     1c0:	08 95       	ret

000001c2 <DIGGSIGG_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTC.DIR |= (1 << pin);
     1c2:	41 9a       	sbi	0x08, 1	; 8
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
	} else {
		VPORTC.OUT &= ~(1 << pin);
     1c4:	49 98       	cbi	0x09, 1	; 9
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLA |= PORTMUX_LUT1_bm;
     1c6:	e0 e0       	ldi	r30, 0x00	; 0
     1c8:	f2 e0       	ldi	r31, 0x02	; 2
     1ca:	80 81       	ld	r24, Z
     1cc:	80 62       	ori	r24, 0x20	; 32
     1ce:	80 83       	st	Z, r24

	DIGGSIGG_init();
     1d0:	7f df       	rcall	.-258    	; 0xd0 <DIGGSIGG_init>
     1d2:	08 95       	ret

000001d4 <SPI_0_initialization>:
 */
static inline void PORTA_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
     1d4:	02 98       	cbi	0x00, 2	; 0
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     1d6:	e2 e1       	ldi	r30, 0x12	; 18
     1d8:	f4 e0       	ldi	r31, 0x04	; 4
     1da:	80 81       	ld	r24, Z
     1dc:	87 7f       	andi	r24, 0xF7	; 247
     1de:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     1e0:	01 9a       	sbi	0x00, 1	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     1e2:	09 98       	cbi	0x01, 1	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     1e4:	03 9a       	sbi	0x00, 3	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     1e6:	0b 98       	cbi	0x01, 3	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     1e8:	04 9a       	sbi	0x00, 4	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     1ea:	0c 98       	cbi	0x01, 4	; 1
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	SPI_0_init();
     1ec:	cc d0       	rcall	.+408    	; 0x386 <SPI_0_init>
     1ee:	08 95       	ret

000001f0 <DAC_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     1f0:	e6 e1       	ldi	r30, 0x16	; 22
     1f2:	f4 e0       	ldi	r31, 0x04	; 4
     1f4:	80 81       	ld	r24, Z
     1f6:	88 7f       	andi	r24, 0xF8	; 248
     1f8:	84 60       	ori	r24, 0x04	; 4
     1fa:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     1fc:	80 81       	ld	r24, Z
     1fe:	87 7f       	andi	r24, 0xF7	; 247
     200:	80 83       	st	Z, r24
	// Disable digital input buffer
	AXON_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	AXON_PIN_set_pull_mode(PORT_PULL_OFF);

	DAC_init();
     202:	83 df       	rcall	.-250    	; 0x10a <DAC_init>
     204:	08 95       	ret

00000206 <system_init>:
/**
 * \brief System initialization
 */
void system_init()
{
	mcu_init();
     206:	89 df       	rcall	.-238    	; 0x11a <mcu_init>
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     208:	27 98       	cbi	0x04, 7	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     20a:	e7 e3       	ldi	r30, 0x37	; 55
     20c:	f4 e0       	ldi	r31, 0x04	; 4
     20e:	80 81       	ld	r24, Z
     210:	87 7f       	andi	r24, 0xF7	; 247
     212:	80 83       	st	Z, r24
 */
static inline void PORTC_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
     214:	42 98       	cbi	0x08, 2	; 8
static inline void PORTC_set_pin_pull_mode(const uint8_t pin, const enum port_pull_mode pull_mode)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
     216:	e2 e5       	ldi	r30, 0x52	; 82
     218:	f4 e0       	ldi	r31, 0x04	; 4
     21a:	80 81       	ld	r24, Z
     21c:	88 60       	ori	r24, 0x08	; 8
     21e:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTC.DIR |= (1 << pin);
     220:	45 9a       	sbi	0x08, 5	; 8
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     222:	4d 9a       	sbi	0x09, 5	; 9
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    true);

	CLKCTRL_init();
     224:	63 df       	rcall	.-314    	; 0xec <CLKCTRL_init>

	RTC_init();
     226:	93 d0       	rcall	.+294    	; 0x34e <RTC_init>

	ADC_initialization();
     228:	94 df       	rcall	.-216    	; 0x152 <ADC_initialization>

	TIMER_0_initialization();
     22a:	c2 df       	rcall	.-124    	; 0x1b0 <TIMER_0_initialization>

	DIGGSIGG_initialization();
     22c:	ca df       	rcall	.-108    	; 0x1c2 <DIGGSIGG_initialization>

	SPI_0_initialization();
     22e:	d2 df       	rcall	.-92     	; 0x1d4 <SPI_0_initialization>

	DAC_initialization();
     230:	df df       	rcall	.-66     	; 0x1f0 <DAC_initialization>

	CPUINT_init();
     232:	68 df       	rcall	.-304    	; 0x104 <CPUINT_init>

	SLPCTRL_init();
     234:	a6 d0       	rcall	.+332    	; 0x382 <SLPCTRL_init>

	BOD_init();
     236:	4a df       	rcall	.-364    	; 0xcc <BOD_init>
     238:	08 95       	ret

0000023a <protected_write_io>:
#if defined(__GNUC__)
  
#ifdef RAMPZ
	out     _SFR_IO_ADDR(RAMPZ), r1         // Clear bits 23:16 of Z
#endif
	movw    r30, r24                // Load addr into Z
     23a:	fc 01       	movw	r30, r24
	out     CCP, r22                // Start CCP handshake
     23c:	64 bf       	out	0x34, r22	; 52
	st      Z, r20                  // Write value to I/O register
     23e:	40 83       	st	Z, r20
	ret                             // Return to caller
     240:	08 95       	ret

00000242 <enqueue>:
 */ 
#include <stdio.h>
#include <stdlib.h>
#include "include/queue.h"

void enqueue(node_t **head, uint32_t val) {
     242:	cf 92       	push	r12
     244:	df 92       	push	r13
     246:	ef 92       	push	r14
     248:	ff 92       	push	r15
     24a:	cf 93       	push	r28
     24c:	df 93       	push	r29
     24e:	ec 01       	movw	r28, r24
     250:	6a 01       	movw	r12, r20
     252:	7b 01       	movw	r14, r22
	// remember, head is at the very BACK of the queue (The element that will wait the longest until dequeued)
	
	// we create a new empty node
	node_t *new_node = malloc(sizeof(node_t));
     254:	86 e0       	ldi	r24, 0x06	; 6
     256:	90 e0       	ldi	r25, 0x00	; 0
     258:	02 d8       	rcall	.-4092   	; 0xfffff25e <__eeprom_end+0xff7ef25e>
	// Not quite sure what happens here, but it seems to be some sort of error handling, except you never know if there has been an error :/
	if (!new_node) return;
     25a:	00 97       	sbiw	r24, 0x00	; 0
     25c:	59 f0       	breq	.+22     	; 0x274 <enqueue+0x32>

	// we configure our node
	new_node->val = val;
     25e:	fc 01       	movw	r30, r24
     260:	c0 82       	st	Z, r12
     262:	d1 82       	std	Z+1, r13	; 0x01
     264:	e2 82       	std	Z+2, r14	; 0x02
     266:	f3 82       	std	Z+3, r15	; 0x03
	new_node->next = *head;
     268:	28 81       	ld	r18, Y
     26a:	39 81       	ldd	r19, Y+1	; 0x01
     26c:	24 83       	std	Z+4, r18	; 0x04
     26e:	35 83       	std	Z+5, r19	; 0x05

	// and lastly, we change the pointer pointing to the previous head node, to point to our new node instead
	*head = new_node;
     270:	88 83       	st	Y, r24
     272:	99 83       	std	Y+1, r25	; 0x01
}
     274:	df 91       	pop	r29
     276:	cf 91       	pop	r28
     278:	ff 90       	pop	r15
     27a:	ef 90       	pop	r14
     27c:	df 90       	pop	r13
     27e:	cf 90       	pop	r12
     280:	08 95       	ret

00000282 <dequeue>:

uint32_t dequeue(node_t **head) {
     282:	cf 92       	push	r12
     284:	df 92       	push	r13
     286:	ef 92       	push	r14
     288:	ff 92       	push	r15
     28a:	0f 93       	push	r16
     28c:	1f 93       	push	r17
     28e:	cf 93       	push	r28
     290:	df 93       	push	r29
	node_t *current, *prev = NULL;
	uint32_t retval = 0;

	// If the queue we have been given is empty, we return an error
	// (0 is usually not an error, but it is probably the best option)
	if (*head == NULL) return 0;
     292:	dc 01       	movw	r26, r24
     294:	ed 91       	ld	r30, X+
     296:	fc 91       	ld	r31, X
     298:	30 97       	sbiw	r30, 0x00	; 0
     29a:	11 f1       	breq	.+68     	; 0x2e0 <dequeue+0x5e>
     29c:	c0 e0       	ldi	r28, 0x00	; 0
     29e:	d0 e0       	ldi	r29, 0x00	; 0
     2a0:	02 c0       	rjmp	.+4      	; 0x2a6 <dequeue+0x24>
     2a2:	ef 01       	movw	r28, r30

	// Now we iterate through the queue until we reach the end
	current = *head;
	while (current->next != NULL) {
		prev = current;
		current = current->next;
     2a4:	f9 01       	movw	r30, r18
	// (0 is usually not an error, but it is probably the best option)
	if (*head == NULL) return 0;

	// Now we iterate through the queue until we reach the end
	current = *head;
	while (current->next != NULL) {
     2a6:	24 81       	ldd	r18, Z+4	; 0x04
     2a8:	35 81       	ldd	r19, Z+5	; 0x05
     2aa:	21 15       	cp	r18, r1
     2ac:	31 05       	cpc	r19, r1
     2ae:	c9 f7       	brne	.-14     	; 0x2a2 <dequeue+0x20>
     2b0:	8c 01       	movw	r16, r24
		prev = current;
		current = current->next;
	}

	// We retrieve the value we needed
	retval = current->val;
     2b2:	c0 80       	ld	r12, Z
     2b4:	d1 80       	ldd	r13, Z+1	; 0x01
     2b6:	e2 80       	ldd	r14, Z+2	; 0x02
     2b8:	f3 80       	ldd	r15, Z+3	; 0x03
	// and remove the last element of the queue from the queue
	free(current);
     2ba:	cf 01       	movw	r24, r30
     2bc:	68 d8       	rcall	.-3888   	; 0xfffff38e <__eeprom_end+0xff7ef38e>
	
	// Now we update the previous node so that it becomes the front of the queue
	// In case the queue only had one element, the prev will be null (false)
	if (prev){
     2be:	20 97       	sbiw	r28, 0x00	; 0
     2c0:	39 f0       	breq	.+14     	; 0x2d0 <dequeue+0x4e>
	prev->next = NULL;}
     2c2:	1c 82       	std	Y+4, r1	; 0x04
     2c4:	1d 82       	std	Y+5, r1	; 0x05
	else{
	*head = NULL;}

	return retval;
     2c6:	6c 2d       	mov	r22, r12
     2c8:	7d 2d       	mov	r23, r13
     2ca:	8e 2d       	mov	r24, r14
     2cc:	9f 2d       	mov	r25, r15
     2ce:	0c c0       	rjmp	.+24     	; 0x2e8 <dequeue+0x66>
	// Now we update the previous node so that it becomes the front of the queue
	// In case the queue only had one element, the prev will be null (false)
	if (prev){
	prev->next = NULL;}
	else{
	*head = NULL;}
     2d0:	f8 01       	movw	r30, r16
     2d2:	10 82       	st	Z, r1
     2d4:	11 82       	std	Z+1, r1	; 0x01

	return retval;
     2d6:	6c 2d       	mov	r22, r12
     2d8:	7d 2d       	mov	r23, r13
     2da:	8e 2d       	mov	r24, r14
     2dc:	9f 2d       	mov	r25, r15
     2de:	04 c0       	rjmp	.+8      	; 0x2e8 <dequeue+0x66>
	node_t *current, *prev = NULL;
	uint32_t retval = 0;

	// If the queue we have been given is empty, we return an error
	// (0 is usually not an error, but it is probably the best option)
	if (*head == NULL) return 0;
     2e0:	60 e0       	ldi	r22, 0x00	; 0
     2e2:	70 e0       	ldi	r23, 0x00	; 0
     2e4:	80 e0       	ldi	r24, 0x00	; 0
     2e6:	90 e0       	ldi	r25, 0x00	; 0
	prev->next = NULL;}
	else{
	*head = NULL;}

	return retval;
}
     2e8:	df 91       	pop	r29
     2ea:	cf 91       	pop	r28
     2ec:	1f 91       	pop	r17
     2ee:	0f 91       	pop	r16
     2f0:	ff 90       	pop	r15
     2f2:	ef 90       	pop	r14
     2f4:	df 90       	pop	r13
     2f6:	cf 90       	pop	r12
     2f8:	08 95       	ret

000002fa <dequeue_top>:

// Here we remove the element of the queue that was added last (first in, last out)
uint32_t dequeue_top(node_t **head){
     2fa:	cf 92       	push	r12
     2fc:	df 92       	push	r13
     2fe:	ef 92       	push	r14
     300:	ff 92       	push	r15
     302:	0f 93       	push	r16
     304:	1f 93       	push	r17
     306:	cf 93       	push	r28
     308:	df 93       	push	r29
	node_t *oldHead;
	uint32_t retval = 0;
	
	// If the queue we have been given is empty, we return an error
	// (0 is usually not an error, but it is probably the best option)
	if (*head == NULL) return 0;
     30a:	dc 01       	movw	r26, r24
     30c:	ed 91       	ld	r30, X+
     30e:	fc 91       	ld	r31, X
     310:	30 97       	sbiw	r30, 0x00	; 0
     312:	81 f0       	breq	.+32     	; 0x334 <dequeue_top+0x3a>
     314:	ec 01       	movw	r28, r24
	
	oldHead = *head;
	// We then set the new head to be the second last in the queue
	newHead = oldHead->next;
     316:	c4 80       	ldd	r12, Z+4	; 0x04
     318:	d5 80       	ldd	r13, Z+5	; 0x05
	
	// We retrieve the heads value
	retval = oldHead->val;
     31a:	e0 80       	ld	r14, Z
     31c:	f1 80       	ldd	r15, Z+1	; 0x01
     31e:	02 81       	ldd	r16, Z+2	; 0x02
     320:	13 81       	ldd	r17, Z+3	; 0x03
	
	// We free the memory that was used to store the old head
	free(oldHead);
     322:	cf 01       	movw	r24, r30
     324:	34 d8       	rcall	.-3992   	; 0xfffff38e <__eeprom_end+0xff7ef38e>
	
	//And then we overwrite the value of head to be the second last
	*head = newHead;
     326:	c8 82       	st	Y, r12
     328:	d9 82       	std	Y+1, r13	; 0x01
	
	return retval;
     32a:	6e 2d       	mov	r22, r14
     32c:	7f 2d       	mov	r23, r15
     32e:	80 2f       	mov	r24, r16
     330:	91 2f       	mov	r25, r17
     332:	04 c0       	rjmp	.+8      	; 0x33c <dequeue_top+0x42>
	node_t *oldHead;
	uint32_t retval = 0;
	
	// If the queue we have been given is empty, we return an error
	// (0 is usually not an error, but it is probably the best option)
	if (*head == NULL) return 0;
     334:	60 e0       	ldi	r22, 0x00	; 0
     336:	70 e0       	ldi	r23, 0x00	; 0
     338:	80 e0       	ldi	r24, 0x00	; 0
     33a:	90 e0       	ldi	r25, 0x00	; 0
	//And then we overwrite the value of head to be the second last
	*head = newHead;
	
	return retval;
	
}
     33c:	df 91       	pop	r29
     33e:	cf 91       	pop	r28
     340:	1f 91       	pop	r17
     342:	0f 91       	pop	r16
     344:	ff 90       	pop	r15
     346:	ef 90       	pop	r14
     348:	df 90       	pop	r13
     34a:	cf 90       	pop	r12
     34c:	08 95       	ret

0000034e <RTC_init>:
 * \return Initialization status.
 */
int8_t RTC_init()
{

	while (RTC.STATUS > 0) { /* Wait for all register to be synchronized */
     34e:	e0 e4       	ldi	r30, 0x40	; 64
     350:	f1 e0       	ldi	r31, 0x01	; 1
     352:	81 81       	ldd	r24, Z+1	; 0x01
     354:	81 11       	cpse	r24, r1
     356:	fd cf       	rjmp	.-6      	; 0x352 <RTC_init+0x4>
	}

	// RTC.CMP = 0x0; /* Compare: 0x0 */

	RTC.CNT = 0x20; /* Counter: 0x20 */
     358:	e0 e4       	ldi	r30, 0x40	; 64
     35a:	f1 e0       	ldi	r31, 0x01	; 1
     35c:	80 e2       	ldi	r24, 0x20	; 32
     35e:	90 e0       	ldi	r25, 0x00	; 0
     360:	80 87       	std	Z+8, r24	; 0x08
     362:	91 87       	std	Z+9, r25	; 0x09

	RTC.CTRLA = RTC_PRESCALER_DIV1_gc   /* 1 */
     364:	21 e8       	ldi	r18, 0x81	; 129
     366:	20 83       	st	Z, r18
	            | 1 << RTC_RTCEN_bp     /* Enable: enabled */
	            | 1 << RTC_RUNSTDBY_bp; /* Run In Standby: enabled */

	RTC.PER = 0x20; /* Period: 0x20 */
     368:	82 87       	std	Z+10, r24	; 0x0a
     36a:	93 87       	std	Z+11, r25	; 0x0b

	// RTC.CLKSEL = RTC_CLKSEL_INT32K_gc; /* 32KHz Internal Ultra Low Power Oscillator (OSCULP32K) */

	RTC.DBGCTRL = 1 << RTC_DBGRUN_bp; /* Run in debug: enabled */
     36c:	81 e0       	ldi	r24, 0x01	; 1
     36e:	85 83       	std	Z+5, r24	; 0x05

	RTC.INTCTRL = 0 << RTC_CMP_bp    /* Compare Match Interrupt enable: disabled */
     370:	82 83       	std	Z+2, r24	; 0x02
	              | 1 << RTC_OVF_bp; /* Overflow Interrupt enable: enabled */

	while (RTC.PITSTATUS > 0) { /* Wait for all register to be synchronized */
     372:	81 89       	ldd	r24, Z+17	; 0x11
     374:	81 11       	cpse	r24, r1
     376:	fd cf       	rjmp	.-6      	; 0x372 <RTC_init+0x24>
	}

	RTC.PITCTRLA = RTC_PERIOD_OFF_gc    /* Off */
     378:	81 e0       	ldi	r24, 0x01	; 1
     37a:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <__TEXT_REGION_LENGTH__+0x700150>
	// RTC.PITDBGCTRL = 0 << RTC_DBGRUN_bp; /* Run in debug: disabled */

	// RTC.PITINTCTRL = 0 << RTC_PI_bp; /* Periodic Interrupt: disabled */

	return 0;
}
     37e:	80 e0       	ldi	r24, 0x00	; 0
     380:	08 95       	ret

00000382 <SLPCTRL_init>:

	// SLPCTRL.CTRLA = 0 << SLPCTRL_SEN_bp /* Sleep enable: disabled */
	//		 | SLPCTRL_SMODE_IDLE_gc; /* Idle mode */

	return 0;
}
     382:	80 e0       	ldi	r24, 0x00	; 0
     384:	08 95       	ret

00000386 <SPI_0_init>:
 * \return Initialization status
 */
int8_t SPI_0_init()
{

	SPI0.CTRLA = 0 << SPI_CLK2X_bp     /* Enable Double Speed: disabled */
     386:	e0 e2       	ldi	r30, 0x20	; 32
     388:	f8 e0       	ldi	r31, 0x08	; 8
     38a:	83 e2       	ldi	r24, 0x23	; 35
     38c:	80 83       	st	Z, r24
	             | 0 << SPI_DORD_bp    /* Data Order Setting: disabled */
	             | 1 << SPI_ENABLE_bp  /* Enable Module: enabled */
	             | 1 << SPI_MASTER_bp  /* SPI module in master mode */
	             | SPI_PRESC_DIV16_gc; /* System Clock / 16 */

	SPI0.CTRLB = 0 << SPI_BUFEN_bp   /* Buffer Mode Enable: disabled */
     38e:	84 e0       	ldi	r24, 0x04	; 4
     390:	81 83       	std	Z+1, r24	; 0x01
	//		 | 0 << SPI_RXCIE_bp /* Receive Complete Interrupt Enable: disabled */
	//		 | 0 << SPI_SSIE_bp /* Slave Select Trigger Interrupt Enable: disabled */
	//		 | 0 << SPI_TXCIE_bp; /* Transfer Complete Interrupt Enable: disabled */

	return 0;
}
     392:	80 e0       	ldi	r24, 0x00	; 0
     394:	08 95       	ret

00000396 <TIMER_0_init>:

	// TCA0.SINGLE.CMP0 = 0x0; /* Compare Register 0: 0x0 */

	// TCA0.SINGLE.CMP1 = 0x0; /* Compare Register 1: 0x0 */

	TCA0.SINGLE.CMP2 = 0x4; /* Compare Register 2: 0x4 */
     396:	e0 e0       	ldi	r30, 0x00	; 0
     398:	fa e0       	ldi	r31, 0x0A	; 10
     39a:	84 e0       	ldi	r24, 0x04	; 4
     39c:	90 e0       	ldi	r25, 0x00	; 0
     39e:	84 a7       	std	Z+44, r24	; 0x2c
     3a0:	95 a7       	std	Z+45, r25	; 0x2d

	// TCA0.SINGLE.CNT = 0x0; /* Count: 0x0 */

	TCA0.SINGLE.CTRLB = 0 << TCA_SINGLE_ALUPD_bp            /* Auto Lock Update: disabled */
     3a2:	83 e4       	ldi	r24, 0x43	; 67
     3a4:	81 83       	std	Z+1, r24	; 0x01
	                    | 0 << TCA_SINGLE_CMP0EN_bp         /* Compare 0 Enable: disabled */
	                    | 0 << TCA_SINGLE_CMP1EN_bp         /* Compare 1 Enable: disabled */
	                    | 1 << TCA_SINGLE_CMP2EN_bp         /* Compare 2 Enable: enabled */
	                    | TCA_SINGLE_WGMODE_SINGLESLOPE_gc; /*  */

	TCA0.SINGLE.CTRLC = 0 << TCA_SINGLE_CMP0OV_bp    /* Compare 0 Waveform Output Value: disabled */
     3a6:	84 e0       	ldi	r24, 0x04	; 4
     3a8:	82 83       	std	Z+2, r24	; 0x02
	// TCA0.SINGLE.INTCTRL = 0 << TCA_SINGLE_CMP0_bp /* Compare 0 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP1_bp /* Compare 1 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP2_bp /* Compare 2 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_OVF_bp; /* Overflow Interrupt: disabled */

	TCA0.SINGLE.PER = 0x7; /* Period: 0x7 */
     3aa:	87 e0       	ldi	r24, 0x07	; 7
     3ac:	90 e0       	ldi	r25, 0x00	; 0
     3ae:	86 a3       	std	Z+38, r24	; 0x26
     3b0:	97 a3       	std	Z+39, r25	; 0x27

	// TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV1_gc /* System Clock */
	//		 | 0 << TCA_SINGLE_ENABLE_bp; /* Module Enable: disabled */

	return 0;
}
     3b2:	80 e0       	ldi	r24, 0x00	; 0
     3b4:	08 95       	ret

000003b6 <tinyCharge_is_charging>:

_Bool charging;

_Bool tinyCharge_is_charging(){
	return charging;
}
     3b6:	80 91 54 3e 	lds	r24, 0x3E54	; 0x803e54 <charging>
     3ba:	08 95       	ret

000003bc <tinyCharge_set_charging>:

void tinyCharge_set_charging(_Bool charging_status){
	charging = charging_status;
     3bc:	80 93 54 3e 	sts	0x3E54, r24	; 0x803e54 <charging>
     3c0:	08 95       	ret

000003c2 <tinyCharge_set_transistors>:
}


void tinyCharge_set_transistors(){
	if(charging){
     3c2:	80 91 54 3e 	lds	r24, 0x3E54	; 0x803e54 <charging>
     3c6:	88 23       	and	r24, r24
     3c8:	11 f0       	breq	.+4      	; 0x3ce <tinyCharge_set_transistors+0xc>
	} else {
		VPORTC.OUT &= ~(1 << pin);
     3ca:	4d 98       	cbi	0x09, 5	; 9
     3cc:	08 95       	ret
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     3ce:	4d 9a       	sbi	0x09, 5	; 9
     3d0:	08 95       	ret

000003d2 <tinyPulse_toggle_pulse_mode>:
uint32_t time_of_last_pulse = 0;
uint16_t time_since_last_pulse = 0;
uint16_t ideal_time_between_pulses = 1000/PULSEMODE_FREQUENCY;

void tinyPulse_toggle_pulse_mode(){
	pulse_mode = !pulse_mode;
     3d2:	90 91 14 3e 	lds	r25, 0x3E14	; 0x803e14 <pulse_mode>
     3d6:	81 e0       	ldi	r24, 0x01	; 1
     3d8:	89 27       	eor	r24, r25
     3da:	80 93 14 3e 	sts	0x3E14, r24	; 0x803e14 <pulse_mode>
     3de:	08 95       	ret

000003e0 <tinyPulse_update_potential>:
}

double tinyPulse_update_potential(double potential){
     3e0:	cf 92       	push	r12
     3e2:	df 92       	push	r13
     3e4:	ef 92       	push	r14
     3e6:	ff 92       	push	r15
     3e8:	6b 01       	movw	r12, r22
     3ea:	7c 01       	movw	r14, r24
	if(pulse_mode){
     3ec:	80 91 14 3e 	lds	r24, 0x3E14	; 0x803e14 <pulse_mode>
     3f0:	88 23       	and	r24, r24
     3f2:	21 f1       	breq	.+72     	; 0x43c <__LOCK_REGION_LENGTH__+0x3c>
		
		time_since_last_pulse = tinyTime_now() - time_of_last_pulse;
     3f4:	3e d0       	rcall	.+124    	; 0x472 <tinyTime_now>
     3f6:	20 91 10 3e 	lds	r18, 0x3E10	; 0x803e10 <time_of_last_pulse>
     3fa:	30 91 11 3e 	lds	r19, 0x3E11	; 0x803e11 <time_of_last_pulse+0x1>
     3fe:	62 1b       	sub	r22, r18
     400:	73 0b       	sbc	r23, r19
     402:	60 93 0e 3e 	sts	0x3E0E, r22	; 0x803e0e <__data_end>
     406:	70 93 0f 3e 	sts	0x3E0F, r23	; 0x803e0f <__data_end+0x1>
		
		if(time_since_last_pulse >= ideal_time_between_pulses){
     40a:	80 91 06 3e 	lds	r24, 0x3E06	; 0x803e06 <ideal_time_between_pulses>
     40e:	90 91 07 3e 	lds	r25, 0x3E07	; 0x803e07 <ideal_time_between_pulses+0x1>
     412:	68 17       	cp	r22, r24
     414:	79 07       	cpc	r23, r25
     416:	90 f0       	brcs	.+36     	; 0x43c <__LOCK_REGION_LENGTH__+0x3c>
			potential += BUTTON_PRESS_REACTION;
     418:	20 e0       	ldi	r18, 0x00	; 0
     41a:	30 e0       	ldi	r19, 0x00	; 0
     41c:	40 ed       	ldi	r20, 0xD0	; 208
     41e:	51 e4       	ldi	r21, 0x41	; 65
     420:	c7 01       	movw	r24, r14
     422:	b6 01       	movw	r22, r12
     424:	bb d3       	rcall	.+1910   	; 0xb9c <__addsf3>
     426:	6b 01       	movw	r12, r22
     428:	7c 01       	movw	r14, r24
			time_of_last_pulse = tinyTime_now();			
     42a:	23 d0       	rcall	.+70     	; 0x472 <tinyTime_now>
     42c:	60 93 10 3e 	sts	0x3E10, r22	; 0x803e10 <time_of_last_pulse>
     430:	70 93 11 3e 	sts	0x3E11, r23	; 0x803e11 <time_of_last_pulse+0x1>
     434:	80 93 12 3e 	sts	0x3E12, r24	; 0x803e12 <time_of_last_pulse+0x2>
     438:	90 93 13 3e 	sts	0x3E13, r25	; 0x803e13 <time_of_last_pulse+0x3>
		}
	}
	return potential;
}
     43c:	c7 01       	movw	r24, r14
     43e:	b6 01       	movw	r22, r12
     440:	ff 90       	pop	r15
     442:	ef 90       	pop	r14
     444:	df 90       	pop	r13
     446:	cf 90       	pop	r12
     448:	08 95       	ret

0000044a <tinyTime_counter_increment>:
If the Interrupt Service Routine is clocked by a crystal oscillator
it gives a very precise timer-counter.
*/
void tinyTime_counter_increment(void)
{
	time_counter++;
     44a:	80 91 15 3e 	lds	r24, 0x3E15	; 0x803e15 <time_counter>
     44e:	90 91 16 3e 	lds	r25, 0x3E16	; 0x803e16 <time_counter+0x1>
     452:	a0 91 17 3e 	lds	r26, 0x3E17	; 0x803e17 <time_counter+0x2>
     456:	b0 91 18 3e 	lds	r27, 0x3E18	; 0x803e18 <time_counter+0x3>
     45a:	01 96       	adiw	r24, 0x01	; 1
     45c:	a1 1d       	adc	r26, r1
     45e:	b1 1d       	adc	r27, r1
     460:	80 93 15 3e 	sts	0x3E15, r24	; 0x803e15 <time_counter>
     464:	90 93 16 3e 	sts	0x3E16, r25	; 0x803e16 <time_counter+0x1>
     468:	a0 93 17 3e 	sts	0x3E17, r26	; 0x803e17 <time_counter+0x2>
     46c:	b0 93 18 3e 	sts	0x3E18, r27	; 0x803e18 <time_counter+0x3>
     470:	08 95       	ret

00000472 <tinyTime_now>:
/*
This function is callable by external libraries to give them the counted time so far.
*/
uint32_t tinyTime_now(void)
{
	return time_counter;
     472:	60 91 15 3e 	lds	r22, 0x3E15	; 0x803e15 <time_counter>
     476:	70 91 16 3e 	lds	r23, 0x3E16	; 0x803e16 <time_counter+0x1>
     47a:	80 91 17 3e 	lds	r24, 0x3E17	; 0x803e17 <time_counter+0x2>
     47e:	90 91 18 3e 	lds	r25, 0x3E18	; 0x803e18 <time_counter+0x3>
     482:	08 95       	ret

00000484 <main>:

*/


int main(void)
{	
     484:	cf 93       	push	r28
     486:	df 93       	push	r29
     488:	00 d0       	rcall	.+0      	; 0x48a <main+0x6>
     48a:	cd b7       	in	r28, 0x3d	; 61
     48c:	de b7       	in	r29, 0x3e	; 62
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
     48e:	02 de       	rcall	.-1020   	; 0x94 <atmel_start_init>
	Setting this value will mean that the ADC (Analog to Digital Converter) will read 4.32v as 255, and 0v as 0.
	For some reason, instead of the reference voltage being 4.32v, it is 3.3v. 
	A plausible explanation is that the microchip does not up the voltage, so that if the microchip is only ever 
	supplied with 3.3v, it will output 3.3v as the max.
	*/
	VREF.CTRLB = VREF_ADC0REFSEL_4V34_gc;
     490:	80 e3       	ldi	r24, 0x30	; 48
     492:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
	
	
	uint32_t current_cycle_time = 1;
	uint32_t previous_cycle_time = 0;
	uint16_t time_passed = 0;
	uint16_t volatile cycles=0;
     496:	19 82       	std	Y+1, r1	; 0x01
     498:	1a 82       	std	Y+2, r1	; 0x02
	*/
	VREF.CTRLB = VREF_ADC0REFSEL_4V34_gc;
	
	
	uint32_t current_cycle_time = 1;
	uint32_t previous_cycle_time = 0;
     49a:	81 2c       	mov	r8, r1
     49c:	91 2c       	mov	r9, r1
     49e:	54 01       	movw	r10, r8
	uint16_t volatile cycles=0;
	
	while (1)
	{
		// We don't want to update the neuron too often because of various reasons. The tinyISR_getflag is set every ms, and so the loop is only run once every ms.  
		if(tinyISR_getflag())
     4a0:	3b d3       	rcall	.+1654   	; 0xb18 <tinyISR_getflag>
     4a2:	88 23       	and	r24, r24
     4a4:	e9 f3       	breq	.-6      	; 0x4a0 <main+0x1c>
		{
			// update cycle time
			current_cycle_time = tinyTime_now();
     4a6:	e5 df       	rcall	.-54     	; 0x472 <tinyTime_now>
     4a8:	6b 01       	movw	r12, r22
     4aa:	7c 01       	movw	r14, r24
			
			
			if(tinyCharge_is_charging()){
     4ac:	84 df       	rcall	.-248    	; 0x3b6 <tinyCharge_is_charging>
     4ae:	88 23       	and	r24, r24
     4b0:	11 f0       	breq	.+4      	; 0x4b6 <main+0x32>
				// Charge loop
				
				// We check the Dendriteites in order to detect if we have stopped charging
				tinyDendriteite_update_signals();
     4b2:	20 d2       	rcall	.+1088   	; 0x8f4 <tinyDendriteite_update_signals>
     4b4:	08 c0       	rjmp	.+16     	; 0x4c6 <main+0x42>
				
				
			}
			else{
				// Main loop				
				tinyButton_update();
     4b6:	b2 d0       	rcall	.+356    	; 0x61c <tinyButton_update>
				
				time_passed = current_cycle_time - previous_cycle_time;
				tinyPotential_update(time_passed);
     4b8:	b6 01       	movw	r22, r12
     4ba:	68 19       	sub	r22, r8
     4bc:	79 09       	sbc	r23, r9
     4be:	80 e0       	ldi	r24, 0x00	; 0
     4c0:	90 e0       	ldi	r25, 0x00	; 0
     4c2:	bf d4       	rcall	.+2430   	; 0xe42 <__floatunsisf>
     4c4:	2c d3       	rcall	.+1624   	; 0xb1e <tinyPotential_update>
			}
			
			
			
			// Switch transistors
			tinyCharge_set_transistors();
     4c6:	7d df       	rcall	.-262    	; 0x3c2 <tinyCharge_set_transistors>
			
			// Prepare for next cycle
			previous_cycle_time = current_cycle_time;
			cycles++;
     4c8:	89 81       	ldd	r24, Y+1	; 0x01
     4ca:	9a 81       	ldd	r25, Y+2	; 0x02
     4cc:	01 96       	adiw	r24, 0x01	; 1
     4ce:	89 83       	std	Y+1, r24	; 0x01
     4d0:	9a 83       	std	Y+2, r25	; 0x02
			tinyISR_setflag(false);
     4d2:	80 e0       	ldi	r24, 0x00	; 0
     4d4:	1e d3       	rcall	.+1596   	; 0xb12 <tinyISR_setflag>
			
			// Switch transistors
			tinyCharge_set_transistors();
			
			// Prepare for next cycle
			previous_cycle_time = current_cycle_time;
     4d6:	46 01       	movw	r8, r12
     4d8:	57 01       	movw	r10, r14
     4da:	e2 cf       	rjmp	.-60     	; 0x4a0 <main+0x1c>

000004dc <set_LED_fire>:



//function to be called upon when firing flag has been raised.
void set_LED_fire(void)
{
     4dc:	cf 93       	push	r28
	fire_flash_time_counter = tinyTime_now();
     4de:	c9 df       	rcall	.-110    	; 0x472 <tinyTime_now>
     4e0:	60 93 19 3e 	sts	0x3E19, r22	; 0x803e19 <fire_flash_time_counter>
     4e4:	70 93 1a 3e 	sts	0x3E1A, r23	; 0x803e1a <fire_flash_time_counter+0x1>
     4e8:	80 93 1b 3e 	sts	0x3E1B, r24	; 0x803e1b <fire_flash_time_counter+0x2>
     4ec:	90 93 1c 3e 	sts	0x3E1C, r25	; 0x803e1c <fire_flash_time_counter+0x3>
     4f0:	c0 e0       	ldi	r28, 0x00	; 0
	for (int i = 0; i < NUMBER_OF_LEDS; i++)
	{
		tinyCCLRGB_setColor(i, MAX_BRIGHTNESS, MAX_BRIGHTNESS, MAX_BRIGHTNESS);//As per the specs, all LEDs should be blue while firing.
     4f2:	20 e3       	ldi	r18, 0x30	; 48
     4f4:	40 e3       	ldi	r20, 0x30	; 48
     4f6:	60 e3       	ldi	r22, 0x30	; 48
     4f8:	8c 2f       	mov	r24, r28
     4fa:	fb d0       	rcall	.+502    	; 0x6f2 <tinyCCLRGB_setColor>
     4fc:	cf 5f       	subi	r28, 0xFF	; 255

//function to be called upon when firing flag has been raised.
void set_LED_fire(void)
{
	fire_flash_time_counter = tinyTime_now();
	for (int i = 0; i < NUMBER_OF_LEDS; i++)
     4fe:	c6 30       	cpi	r28, 0x06	; 6
     500:	c1 f7       	brne	.-16     	; 0x4f2 <set_LED_fire+0x16>
	{
		tinyCCLRGB_setColor(i, MAX_BRIGHTNESS, MAX_BRIGHTNESS, MAX_BRIGHTNESS);//As per the specs, all LEDs should be blue while firing.
	}
}
     502:	cf 91       	pop	r28
     504:	08 95       	ret

00000506 <potential_to_RGB_update_LEDs>:



void potential_to_RGB_update_LEDs(double potential)
{
     506:	8f 92       	push	r8
     508:	9f 92       	push	r9
     50a:	af 92       	push	r10
     50c:	bf 92       	push	r11
     50e:	cf 92       	push	r12
     510:	df 92       	push	r13
     512:	ef 92       	push	r14
     514:	ff 92       	push	r15
     516:	0f 93       	push	r16
     518:	1f 93       	push	r17
     51a:	cf 93       	push	r28
     51c:	6b 01       	movw	r12, r22
     51e:	7c 01       	movw	r14, r24
	if ((tinyTime_now() - fire_flash_time_counter) < FIRE_FLASH_TIME)
     520:	a8 df       	rcall	.-176    	; 0x472 <tinyTime_now>
     522:	00 91 19 3e 	lds	r16, 0x3E19	; 0x803e19 <fire_flash_time_counter>
     526:	10 91 1a 3e 	lds	r17, 0x3E1A	; 0x803e1a <fire_flash_time_counter+0x1>
     52a:	20 91 1b 3e 	lds	r18, 0x3E1B	; 0x803e1b <fire_flash_time_counter+0x2>
     52e:	30 91 1c 3e 	lds	r19, 0x3E1C	; 0x803e1c <fire_flash_time_counter+0x3>
     532:	dc 01       	movw	r26, r24
     534:	cb 01       	movw	r24, r22
     536:	80 1b       	sub	r24, r16
     538:	91 0b       	sbc	r25, r17
     53a:	a2 0b       	sbc	r26, r18
     53c:	b3 0b       	sbc	r27, r19
     53e:	84 36       	cpi	r24, 0x64	; 100
     540:	91 05       	cpc	r25, r1
     542:	a1 05       	cpc	r26, r1
     544:	b1 05       	cpc	r27, r1
     546:	50 f4       	brcc	.+20     	; 0x55c <potential_to_RGB_update_LEDs+0x56>
     548:	c0 e0       	ldi	r28, 0x00	; 0
	{
		for (int i = 0; i < NUMBER_OF_LEDS; i++)
		{
			tinyCCLRGB_setColor(i, MAX_BRIGHTNESS, MAX_BRIGHTNESS, MAX_BRIGHTNESS);
     54a:	20 e3       	ldi	r18, 0x30	; 48
     54c:	40 e3       	ldi	r20, 0x30	; 48
     54e:	60 e3       	ldi	r22, 0x30	; 48
     550:	8c 2f       	mov	r24, r28
     552:	cf d0       	rcall	.+414    	; 0x6f2 <tinyCCLRGB_setColor>
     554:	cf 5f       	subi	r28, 0xFF	; 255

void potential_to_RGB_update_LEDs(double potential)
{
	if ((tinyTime_now() - fire_flash_time_counter) < FIRE_FLASH_TIME)
	{
		for (int i = 0; i < NUMBER_OF_LEDS; i++)
     556:	c6 30       	cpi	r28, 0x06	; 6
     558:	c1 f7       	brne	.-16     	; 0x54a <potential_to_RGB_update_LEDs+0x44>
     55a:	53 c0       	rjmp	.+166    	; 0x602 <potential_to_RGB_update_LEDs+0xfc>
     55c:	c0 e0       	ldi	r28, 0x00	; 0
*/
static void potential_to_RGB_set_color(double potential)
{
	for (int i = 0; i < NUMBER_OF_LEDS; i++)
	{
		tinyCCLRGB_setColor(i, 0x0, 0x0, 0x0);//Clear all LED stored values on the MCU before writing again.
     55e:	20 e0       	ldi	r18, 0x00	; 0
     560:	40 e0       	ldi	r20, 0x00	; 0
     562:	60 e0       	ldi	r22, 0x00	; 0
     564:	8c 2f       	mov	r24, r28
     566:	c5 d0       	rcall	.+394    	; 0x6f2 <tinyCCLRGB_setColor>
     568:	cf 5f       	subi	r28, 0xFF	; 255
When firing all lights turn blue for ~100ms, but this needs to be tested.
LEDs are numbered right way on top of PCB, but opposite way on bottom of PCB.
*/
static void potential_to_RGB_set_color(double potential)
{
	for (int i = 0; i < NUMBER_OF_LEDS; i++)
     56a:	c6 30       	cpi	r28, 0x06	; 6
     56c:	c1 f7       	brne	.-16     	; 0x55e <potential_to_RGB_update_LEDs+0x58>
	{
		tinyCCLRGB_setColor(i, 0x0, 0x0, 0x0);//Clear all LED stored values on the MCU before writing again.
	}
	double absolute_potential = abs(potential);//setting variable for absolute potential so it won't have to be calculated more than once.
     56e:	c7 01       	movw	r24, r14
     570:	b6 01       	movw	r22, r12
     572:	31 d4       	rcall	.+2146   	; 0xdd6 <__fixsfsi>
     574:	9b 01       	movw	r18, r22
     576:	77 23       	and	r23, r23
     578:	24 f4       	brge	.+8      	; 0x582 <potential_to_RGB_update_LEDs+0x7c>
     57a:	22 27       	eor	r18, r18
     57c:	33 27       	eor	r19, r19
     57e:	26 1b       	sub	r18, r22
     580:	37 0b       	sbc	r19, r23
     582:	b9 01       	movw	r22, r18
     584:	33 0f       	add	r19, r19
     586:	88 0b       	sbc	r24, r24
     588:	99 0b       	sbc	r25, r25
     58a:	5d d4       	rcall	.+2234   	; 0xe46 <__floatsisf>
     58c:	4b 01       	movw	r8, r22
     58e:	5c 01       	movw	r10, r24
	if (absolute_potential < 1)//set the middle lights as white both top side and bottom side.
     590:	20 e0       	ldi	r18, 0x00	; 0
     592:	30 e0       	ldi	r19, 0x00	; 0
     594:	40 e8       	ldi	r20, 0x80	; 128
     596:	5f e3       	ldi	r21, 0x3F	; 63
     598:	6d d3       	rcall	.+1754   	; 0xc74 <__cmpsf2>
     59a:	88 23       	and	r24, r24
     59c:	34 f4       	brge	.+12     	; 0x5aa <potential_to_RGB_update_LEDs+0xa4>
	{
		tinyCCLRGB_setColor(2, MAX_BRIGHTNESS/3, MAX_BRIGHTNESS/3, MAX_BRIGHTNESS/3);
     59e:	20 e1       	ldi	r18, 0x10	; 16
     5a0:	40 e1       	ldi	r20, 0x10	; 16
     5a2:	60 e1       	ldi	r22, 0x10	; 16
     5a4:	82 e0       	ldi	r24, 0x02	; 2
     5a6:	a5 d0       	rcall	.+330    	; 0x6f2 <tinyCCLRGB_setColor>
     5a8:	2c c0       	rjmp	.+88     	; 0x602 <potential_to_RGB_update_LEDs+0xfc>
		//tinyCCLRGB_setColor(4, max_brightness/3, max_brightness/3, max_brightness/3);
	}
	else
	{
		uint8_t brightness_intensity = round((absolute_potential/25)*MAX_BRIGHTNESS);//brightness intensity for the LED that shows potential.
     5aa:	20 e0       	ldi	r18, 0x00	; 0
     5ac:	30 e0       	ldi	r19, 0x00	; 0
     5ae:	48 ec       	ldi	r20, 0xC8	; 200
     5b0:	51 e4       	ldi	r21, 0x41	; 65
     5b2:	c5 01       	movw	r24, r10
     5b4:	b4 01       	movw	r22, r8
     5b6:	63 d3       	rcall	.+1734   	; 0xc7e <__divsf3>
     5b8:	20 e0       	ldi	r18, 0x00	; 0
     5ba:	30 e0       	ldi	r19, 0x00	; 0
     5bc:	40 e4       	ldi	r20, 0x40	; 64
     5be:	52 e4       	ldi	r21, 0x42	; 66
     5c0:	94 d5       	rcall	.+2856   	; 0x10ea <__mulsf3>
     5c2:	00 d6       	rcall	.+3072   	; 0x11c4 <round>
     5c4:	0f d4       	rcall	.+2078   	; 0xde4 <__fixunssfsi>
     5c6:	c6 2f       	mov	r28, r22
		if (potential < 0)
     5c8:	20 e0       	ldi	r18, 0x00	; 0
     5ca:	30 e0       	ldi	r19, 0x00	; 0
     5cc:	a9 01       	movw	r20, r18
     5ce:	c7 01       	movw	r24, r14
     5d0:	b6 01       	movw	r22, r12
     5d2:	50 d3       	rcall	.+1696   	; 0xc74 <__cmpsf2>
     5d4:	88 23       	and	r24, r24
     5d6:	5c f4       	brge	.+22     	; 0x5ee <potential_to_RGB_update_LEDs+0xe8>
		{
			tinyCCLRGB_setColor(0, brightness_intensity, 0x0, 0x0);
     5d8:	20 e0       	ldi	r18, 0x00	; 0
     5da:	40 e0       	ldi	r20, 0x00	; 0
     5dc:	6c 2f       	mov	r22, r28
     5de:	80 e0       	ldi	r24, 0x00	; 0
     5e0:	88 d0       	rcall	.+272    	; 0x6f2 <tinyCCLRGB_setColor>
			tinyCCLRGB_setColor(1, brightness_intensity, 0x0, 0x0);//sets lower LEDs red if potential is negative.
     5e2:	20 e0       	ldi	r18, 0x00	; 0
     5e4:	40 e0       	ldi	r20, 0x00	; 0
     5e6:	6c 2f       	mov	r22, r28
     5e8:	81 e0       	ldi	r24, 0x01	; 1
     5ea:	83 d0       	rcall	.+262    	; 0x6f2 <tinyCCLRGB_setColor>
     5ec:	0a c0       	rjmp	.+20     	; 0x602 <potential_to_RGB_update_LEDs+0xfc>
		} 
		else
		{
			tinyCCLRGB_setColor(3, 0x0, brightness_intensity, 0x0);//sets upper LEDs green if potential is positive.
     5ee:	20 e0       	ldi	r18, 0x00	; 0
     5f0:	4c 2f       	mov	r20, r28
     5f2:	60 e0       	ldi	r22, 0x00	; 0
     5f4:	83 e0       	ldi	r24, 0x03	; 3
     5f6:	7d d0       	rcall	.+250    	; 0x6f2 <tinyCCLRGB_setColor>
			tinyCCLRGB_setColor(4, 0x0, brightness_intensity, 0x0);
     5f8:	20 e0       	ldi	r18, 0x00	; 0
     5fa:	4c 2f       	mov	r20, r28
     5fc:	60 e0       	ldi	r22, 0x00	; 0
     5fe:	84 e0       	ldi	r24, 0x04	; 4
     600:	78 d0       	rcall	.+240    	; 0x6f2 <tinyCCLRGB_setColor>
	}
	else
	{
		potential_to_RGB_set_color(potential);
	}
	tinyCCLRGB_uploadColorsToLeds();
     602:	84 d0       	rcall	.+264    	; 0x70c <tinyCCLRGB_uploadColorsToLeds>
}
     604:	cf 91       	pop	r28
     606:	1f 91       	pop	r17
     608:	0f 91       	pop	r16
     60a:	ff 90       	pop	r15
     60c:	ef 90       	pop	r14
     60e:	df 90       	pop	r13
     610:	cf 90       	pop	r12
     612:	bf 90       	pop	r11
     614:	af 90       	pop	r10
     616:	9f 90       	pop	r9
     618:	8f 90       	pop	r8
     61a:	08 95       	ret

0000061c <tinyButton_update>:
/*
If the button has been let go, we change button_press to true. This only lasts one cycle, before it is set to false again.
If the button is held down for longer than PULSEMODE_BUTTON_PRESS_TIME, we toggle the pulse mode state.
*/
void tinyButton_update(void)
{
     61c:	0f 93       	push	r16
     61e:	1f 93       	push	r17
     620:	cf 93       	push	r28
     622:	df 93       	push	r29
	button_press = false;
     624:	10 92 21 3e 	sts	0x3E21, r1	; 0x803e21 <button_press>
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTC_get_pin_level(const uint8_t pin)
{
	return VPORTC.IN & (1 << pin);
     628:	8a b1       	in	r24, 0x0a	; 10
	_Bool button_is_pushed_down = !BUTTON_PIN_get_level(); // The digital port will be read as low if the button is pushed down.
     62a:	d1 e0       	ldi	r29, 0x01	; 1
     62c:	c8 2f       	mov	r28, r24
     62e:	c4 70       	andi	r28, 0x04	; 4
     630:	82 fd       	sbrc	r24, 2
     632:	d0 e0       	ldi	r29, 0x00	; 0

	if (button_is_pushed_down && !button_was_pushed_down)
     634:	c1 11       	cpse	r28, r1
     636:	2f c0       	rjmp	.+94     	; 0x696 <tinyButton_update+0x7a>
     638:	80 91 22 3e 	lds	r24, 0x3E22	; 0x803e22 <button_was_pushed_down>
     63c:	81 11       	cpse	r24, r1
     63e:	0d c0       	rjmp	.+26     	; 0x65a <tinyButton_update+0x3e>
	{
		tinyButton_start_time = tinyTime_now();
     640:	18 df       	rcall	.-464    	; 0x472 <tinyTime_now>
     642:	60 93 1d 3e 	sts	0x3E1D, r22	; 0x803e1d <tinyButton_start_time>
     646:	70 93 1e 3e 	sts	0x3E1E, r23	; 0x803e1e <tinyButton_start_time+0x1>
     64a:	80 93 1f 3e 	sts	0x3E1F, r24	; 0x803e1f <tinyButton_start_time+0x2>
     64e:	90 93 20 3e 	sts	0x3E20, r25	; 0x803e20 <tinyButton_start_time+0x3>
	}
	if (button_is_pushed_down && button_was_pushed_down)
     652:	80 91 22 3e 	lds	r24, 0x3E22	; 0x803e22 <button_was_pushed_down>
     656:	88 23       	and	r24, r24
     658:	39 f1       	breq	.+78     	; 0x6a8 <tinyButton_update+0x8c>
	{
		if ((tinyTime_now() - tinyButton_start_time) > PULSEMODE_BUTTON_PRESS_TIME)
     65a:	0b df       	rcall	.-490    	; 0x472 <tinyTime_now>
     65c:	00 91 1d 3e 	lds	r16, 0x3E1D	; 0x803e1d <tinyButton_start_time>
     660:	10 91 1e 3e 	lds	r17, 0x3E1E	; 0x803e1e <tinyButton_start_time+0x1>
     664:	20 91 1f 3e 	lds	r18, 0x3E1F	; 0x803e1f <tinyButton_start_time+0x2>
     668:	30 91 20 3e 	lds	r19, 0x3E20	; 0x803e20 <tinyButton_start_time+0x3>
     66c:	dc 01       	movw	r26, r24
     66e:	cb 01       	movw	r24, r22
     670:	80 1b       	sub	r24, r16
     672:	91 0b       	sbc	r25, r17
     674:	a2 0b       	sbc	r26, r18
     676:	b3 0b       	sbc	r27, r19
     678:	81 3d       	cpi	r24, 0xD1	; 209
     67a:	97 40       	sbci	r25, 0x07	; 7
     67c:	a1 05       	cpc	r26, r1
     67e:	b1 05       	cpc	r27, r1
     680:	50 f0       	brcs	.+20     	; 0x696 <tinyButton_update+0x7a>
		{
			tinyPulse_toggle_pulse_mode();
     682:	a7 de       	rcall	.-690    	; 0x3d2 <tinyPulse_toggle_pulse_mode>
			tinyButton_start_time = tinyTime_now();
     684:	f6 de       	rcall	.-532    	; 0x472 <tinyTime_now>
     686:	60 93 1d 3e 	sts	0x3E1D, r22	; 0x803e1d <tinyButton_start_time>
     68a:	70 93 1e 3e 	sts	0x3E1E, r23	; 0x803e1e <tinyButton_start_time+0x1>
     68e:	80 93 1f 3e 	sts	0x3E1F, r24	; 0x803e1f <tinyButton_start_time+0x2>
     692:	90 93 20 3e 	sts	0x3E20, r25	; 0x803e20 <tinyButton_start_time+0x3>
		}
	}
	if (!button_is_pushed_down && button_was_pushed_down)
     696:	cc 23       	and	r28, r28
     698:	39 f0       	breq	.+14     	; 0x6a8 <tinyButton_update+0x8c>
     69a:	80 91 22 3e 	lds	r24, 0x3E22	; 0x803e22 <button_was_pushed_down>
     69e:	88 23       	and	r24, r24
     6a0:	19 f0       	breq	.+6      	; 0x6a8 <tinyButton_update+0x8c>
	{
		button_press = true;
     6a2:	81 e0       	ldi	r24, 0x01	; 1
     6a4:	80 93 21 3e 	sts	0x3E21, r24	; 0x803e21 <button_press>
	}
	button_was_pushed_down = button_is_pushed_down;
     6a8:	d0 93 22 3e 	sts	0x3E22, r29	; 0x803e22 <button_was_pushed_down>
}
     6ac:	df 91       	pop	r29
     6ae:	cf 91       	pop	r28
     6b0:	1f 91       	pop	r17
     6b2:	0f 91       	pop	r16
     6b4:	08 95       	ret

000006b6 <tinyButton_update_potential>:

double tinyButton_update_potential(double potential){
	if(button_press){
     6b6:	20 91 21 3e 	lds	r18, 0x3E21	; 0x803e21 <button_press>
     6ba:	22 23       	and	r18, r18
     6bc:	29 f0       	breq	.+10     	; 0x6c8 <tinyButton_update_potential+0x12>
		potential += BUTTON_PRESS_REACTION;
     6be:	20 e0       	ldi	r18, 0x00	; 0
     6c0:	30 e0       	ldi	r19, 0x00	; 0
     6c2:	40 ed       	ldi	r20, 0xD0	; 208
     6c4:	51 e4       	ldi	r21, 0x41	; 65
     6c6:	6a d2       	rcall	.+1236   	; 0xb9c <__addsf3>
	}
	return potential;
}
     6c8:	08 95       	ret

000006ca <tinyCCLRGB_SPIWriteByte>:
Function used to send a byte over SPI, which in turn gets
translated to the bit-sequence required by the LEDs over the CCL.
*/
static void tinyCCLRGB_SPIWriteByte(uint8_t byte)
{
	SPI0.INTFLAGS = SPI0_INTFLAGS; // clear the write collision flag to allow writing
     6ca:	90 91 23 08 	lds	r25, 0x0823	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
     6ce:	90 93 23 08 	sts	0x0823, r25	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
	TCA0.SINGLE.CNT = 0; // reset TCA counter register to ensure the first rising edge of the PWM is predictable
     6d2:	e0 e0       	ldi	r30, 0x00	; 0
     6d4:	fa e0       	ldi	r31, 0x0A	; 10
     6d6:	10 a2       	std	Z+32, r1	; 0x20
     6d8:	11 a2       	std	Z+33, r1	; 0x21
	
	// start TCA
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 1 << TCA_SPLIT_ENABLE_bp;
     6da:	91 e0       	ldi	r25, 0x01	; 1
     6dc:	90 83       	st	Z, r25
	SPI0_DATA = byte;
     6de:	80 93 24 08 	sts	0x0824, r24	; 0x800824 <__TEXT_REGION_LENGTH__+0x700824>

	while((SPI0.INTFLAGS & SPI_RXCIE_bm) == 0){} // wait for transfer to complete
     6e2:	e0 e2       	ldi	r30, 0x20	; 32
     6e4:	f8 e0       	ldi	r31, 0x08	; 8
     6e6:	83 81       	ldd	r24, Z+3	; 0x03
     6e8:	88 23       	and	r24, r24
     6ea:	ec f7       	brge	.-6      	; 0x6e6 <tinyCCLRGB_SPIWriteByte+0x1c>
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 0 << TCA_SPLIT_ENABLE_bp; //Stop TCA
     6ec:	10 92 00 0a 	sts	0x0A00, r1	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
     6f0:	08 95       	ret

000006f2 <tinyCCLRGB_setColor>:
/*
changes the values in the variables stored in the led-array.
*/
void tinyCCLRGB_setColor(uint8_t led, uint8_t red, uint8_t green, uint8_t blue) 
{
	tinyCCLRGB_colors[led].red = red;
     6f2:	90 e0       	ldi	r25, 0x00	; 0
     6f4:	fc 01       	movw	r30, r24
     6f6:	ee 0f       	add	r30, r30
     6f8:	ff 1f       	adc	r31, r31
     6fa:	8e 0f       	add	r24, r30
     6fc:	9f 1f       	adc	r25, r31
     6fe:	fc 01       	movw	r30, r24
     700:	ed 5d       	subi	r30, 0xDD	; 221
     702:	f1 4c       	sbci	r31, 0xC1	; 193
     704:	60 83       	st	Z, r22
	tinyCCLRGB_colors[led].green = green;
     706:	41 83       	std	Z+1, r20	; 0x01
	tinyCCLRGB_colors[led].blue = blue;
     708:	22 83       	std	Z+2, r18	; 0x02
     70a:	08 95       	ret

0000070c <tinyCCLRGB_uploadColorsToLeds>:
/*
function to write the current LED-array on to the LEDs and
effectively update the values stored in the LEDs to the values stored in the MCU.
*/
void tinyCCLRGB_uploadColorsToLeds(void)
{
     70c:	0f 93       	push	r16
     70e:	1f 93       	push	r17
     710:	cf 93       	push	r28
     712:	df 93       	push	r29
     714:	c3 e2       	ldi	r28, 0x23	; 35
     716:	de e3       	ldi	r29, 0x3E	; 62
     718:	05 e3       	ldi	r16, 0x35	; 53
     71a:	1e e3       	ldi	r17, 0x3E	; 62
	for (uint8_t i = 0; i < TINYCCLRGB_LEDCOUNT; i++)
	{
		//For some reason unknown to the writer the data-bus to the LEDs is serialized as GRB
		//which means the 24-bit data-bus will look like [Green[0:7], Red[0:7], Blue[0:7]]
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].green);
     71c:	89 81       	ldd	r24, Y+1	; 0x01
     71e:	d5 df       	rcall	.-86     	; 0x6ca <tinyCCLRGB_SPIWriteByte>
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].red);
     720:	88 81       	ld	r24, Y
     722:	d3 df       	rcall	.-90     	; 0x6ca <tinyCCLRGB_SPIWriteByte>
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].blue);
     724:	8a 81       	ldd	r24, Y+2	; 0x02
     726:	d1 df       	rcall	.-94     	; 0x6ca <tinyCCLRGB_SPIWriteByte>
     728:	23 96       	adiw	r28, 0x03	; 3
function to write the current LED-array on to the LEDs and
effectively update the values stored in the LEDs to the values stored in the MCU.
*/
void tinyCCLRGB_uploadColorsToLeds(void)
{
	for (uint8_t i = 0; i < TINYCCLRGB_LEDCOUNT; i++)
     72a:	c0 17       	cp	r28, r16
     72c:	d1 07       	cpc	r29, r17
     72e:	b1 f7       	brne	.-20     	; 0x71c <tinyCCLRGB_uploadColorsToLeds+0x10>
		//which means the 24-bit data-bus will look like [Green[0:7], Red[0:7], Blue[0:7]]
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].green);
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].red);
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].blue);
	}
}
     730:	df 91       	pop	r29
     732:	cf 91       	pop	r28
     734:	1f 91       	pop	r17
     736:	0f 91       	pop	r16
     738:	08 95       	ret

0000073a <tinyAxon_remove_pulse>:
/*
solution to remove future firing if a inhibitory signal is received
shortly after a excitatory signal.
*/
bool tinyAxon_remove_pulse(void)
{
     73a:	cf 92       	push	r12
     73c:	df 92       	push	r13
     73e:	ef 92       	push	r14
     740:	ff 92       	push	r15
	// We want to remove the pulse last added to the queue
	// We also want to return a bool indicating whether or not a pulse actually was removed
	uint32_t now = tinyTime_now();
     742:	97 de       	rcall	.-722    	; 0x472 <tinyTime_now>
     744:	6b 01       	movw	r12, r22
     746:	7c 01       	movw	r14, r24
	uint32_t pulse_time = dequeue_top(&pulse_queue);
     748:	86 e3       	ldi	r24, 0x36	; 54
     74a:	9e e3       	ldi	r25, 0x3E	; 62
     74c:	d6 dd       	rcall	.-1108   	; 0x2fa <dequeue_top>
	if(pulse_time == 0){ // Here, 0 is regarded as an error
     74e:	61 15       	cp	r22, r1
     750:	71 05       	cpc	r23, r1
     752:	81 05       	cpc	r24, r1
     754:	91 05       	cpc	r25, r1
     756:	c1 f0       	breq	.+48     	; 0x788 <tinyAxon_remove_pulse+0x4e>
		return false;
	}
	
	// Now we want to check if the pulse is too far away to be affected by the low potential, or close enough that we decide to remove it
	// (When we say that the pulse is too far away, it refers to the biological process of how the potential spreads from Dendriteites to axon)
	else if((now + UNDO_PERIOD) < pulse_time){
     758:	2c e3       	ldi	r18, 0x3C	; 60
     75a:	c2 0e       	add	r12, r18
     75c:	d1 1c       	adc	r13, r1
     75e:	e1 1c       	adc	r14, r1
     760:	f1 1c       	adc	r15, r1
     762:	c6 16       	cp	r12, r22
     764:	d7 06       	cpc	r13, r23
     766:	e8 06       	cpc	r14, r24
     768:	f9 06       	cpc	r15, r25
     76a:	38 f4       	brcc	.+14     	; 0x77a <tinyAxon_remove_pulse+0x40>
		// We decided to remove the pulse
		pulses_in_queue--;
     76c:	80 91 38 3e 	lds	r24, 0x3E38	; 0x803e38 <pulses_in_queue>
     770:	81 50       	subi	r24, 0x01	; 1
     772:	80 93 38 3e 	sts	0x3E38, r24	; 0x803e38 <pulses_in_queue>
		return true;
     776:	81 e0       	ldi	r24, 0x01	; 1
     778:	08 c0       	rjmp	.+16     	; 0x78a <tinyAxon_remove_pulse+0x50>
	}
	// Here we have found that there is a pulse queued, but it is old enough to let pass anyway, so now we need to put it back into the queue
	else{
		enqueue(&pulse_queue, pulse_time);
     77a:	ab 01       	movw	r20, r22
     77c:	bc 01       	movw	r22, r24
     77e:	86 e3       	ldi	r24, 0x36	; 54
     780:	9e e3       	ldi	r25, 0x3E	; 62
     782:	5f dd       	rcall	.-1346   	; 0x242 <enqueue>
		return false;
     784:	80 e0       	ldi	r24, 0x00	; 0
     786:	01 c0       	rjmp	.+2      	; 0x78a <tinyAxon_remove_pulse+0x50>
	// We also want to return a bool indicating whether or not a pulse actually was removed
	uint32_t now = tinyTime_now();
	uint32_t pulse_time = dequeue_top(&pulse_queue);
	if(pulse_time == 0){ // Here, 0 is regarded as an error
		//There was no pulse to remove
		return false;
     788:	80 e0       	ldi	r24, 0x00	; 0
	// Here we have found that there is a pulse queued, but it is old enough to let pass anyway, so now we need to put it back into the queue
	else{
		enqueue(&pulse_queue, pulse_time);
		return false;
	}
}
     78a:	ff 90       	pop	r15
     78c:	ef 90       	pop	r14
     78e:	df 90       	pop	r13
     790:	cf 90       	pop	r12
     792:	08 95       	ret

00000794 <tinyAxon_update_potential>:
/*
Decides whether or not the axon should fire
If the axon does fire, the potential is reduced
*/
double tinyAxon_update_potential(double potential)
{
     794:	4f 92       	push	r4
     796:	5f 92       	push	r5
     798:	6f 92       	push	r6
     79a:	7f 92       	push	r7
     79c:	8f 92       	push	r8
     79e:	9f 92       	push	r9
     7a0:	af 92       	push	r10
     7a2:	bf 92       	push	r11
     7a4:	cf 92       	push	r12
     7a6:	df 92       	push	r13
     7a8:	ef 92       	push	r14
     7aa:	ff 92       	push	r15
     7ac:	cf 93       	push	r28
     7ae:	df 93       	push	r29
     7b0:	6b 01       	movw	r12, r22
     7b2:	7c 01       	movw	r14, r24
	int pulse_nr = 0;
	uint32_t now = tinyTime_now();
     7b4:	5e de       	rcall	.-836    	; 0x472 <tinyTime_now>
     7b6:	2b 01       	movw	r4, r22
     7b8:	3c 01       	movw	r6, r24
	
	//While the neuron has enough potential to fire, we want to fire more
	while (potential > THRESHOLD_POTENTIAL)
     7ba:	20 e0       	ldi	r18, 0x00	; 0
     7bc:	30 e0       	ldi	r19, 0x00	; 0
     7be:	48 ec       	ldi	r20, 0xC8	; 200
     7c0:	51 e4       	ldi	r21, 0x41	; 65
     7c2:	c7 01       	movw	r24, r14
     7c4:	b6 01       	movw	r22, r12
     7c6:	16 d4       	rcall	.+2092   	; 0xff4 <__gesf2>
     7c8:	18 16       	cp	r1, r24
     7ca:	5c f5       	brge	.+86     	; 0x822 <tinyAxon_update_potential+0x8e>
     7cc:	c0 e0       	ldi	r28, 0x00	; 0
     7ce:	d0 e0       	ldi	r29, 0x00	; 0
/*
Adds an element to the queue
*/
static void tinyAxon_enqueue_pulse(uint32_t new_pulse)
{
	enqueue(&pulse_queue, new_pulse);
     7d0:	53 01       	movw	r10, r6
     7d2:	42 01       	movw	r8, r4
     7d4:	84 e6       	ldi	r24, 0x64	; 100
     7d6:	88 0e       	add	r8, r24
     7d8:	91 1c       	adc	r9, r1
     7da:	a1 1c       	adc	r10, r1
     7dc:	b1 1c       	adc	r11, r1
     7de:	ae 01       	movw	r20, r28
     7e0:	0d 2e       	mov	r0, r29
     7e2:	00 0c       	add	r0, r0
     7e4:	66 0b       	sbc	r22, r22
     7e6:	77 0b       	sbc	r23, r23
     7e8:	48 0d       	add	r20, r8
     7ea:	59 1d       	adc	r21, r9
     7ec:	6a 1d       	adc	r22, r10
     7ee:	7b 1d       	adc	r23, r11
     7f0:	86 e3       	ldi	r24, 0x36	; 54
     7f2:	9e e3       	ldi	r25, 0x3E	; 62
     7f4:	26 dd       	rcall	.-1460   	; 0x242 <enqueue>
	pulses_in_queue++;
     7f6:	80 91 38 3e 	lds	r24, 0x3E38	; 0x803e38 <pulses_in_queue>
     7fa:	8f 5f       	subi	r24, 0xFF	; 255
     7fc:	80 93 38 3e 	sts	0x3E38, r24	; 0x803e38 <pulses_in_queue>
	{
		tinyAxon_enqueue_pulse(now + TRAVLE_DELAY + FIRE_DELAY*pulse_nr);
		pulse_nr++;
		
		// I want to test reducing the potential by -30 instead of -25 to simulate the hyperpolarization
		potential += POSTFIRE_POTENTIAL_REACTION; // This is usually defined as a negative value, don't be confused by the +=
     800:	20 e0       	ldi	r18, 0x00	; 0
     802:	30 e0       	ldi	r19, 0x00	; 0
     804:	40 ef       	ldi	r20, 0xF0	; 240
     806:	51 e4       	ldi	r21, 0x41	; 65
     808:	c7 01       	movw	r24, r14
     80a:	b6 01       	movw	r22, r12
     80c:	c6 d1       	rcall	.+908    	; 0xb9a <__subsf3>
     80e:	6b 01       	movw	r12, r22
     810:	7c 01       	movw	r14, r24
     812:	e2 96       	adiw	r28, 0x32	; 50
{
	int pulse_nr = 0;
	uint32_t now = tinyTime_now();
	
	//While the neuron has enough potential to fire, we want to fire more
	while (potential > THRESHOLD_POTENTIAL)
     814:	20 e0       	ldi	r18, 0x00	; 0
     816:	30 e0       	ldi	r19, 0x00	; 0
     818:	48 ec       	ldi	r20, 0xC8	; 200
     81a:	51 e4       	ldi	r21, 0x41	; 65
     81c:	eb d3       	rcall	.+2006   	; 0xff4 <__gesf2>
     81e:	18 16       	cp	r1, r24
     820:	f4 f2       	brlt	.-68     	; 0x7de <tinyAxon_update_potential+0x4a>
		// I want to test reducing the potential by -30 instead of -25 to simulate the hyperpolarization
		potential += POSTFIRE_POTENTIAL_REACTION; // This is usually defined as a negative value, don't be confused by the +=
	}
	
	// If the neuron has a very low potential, we want to remove a pulse from the queue (if there is one)
	if(potential < -THRESHOLD_POTENTIAL && pulses_in_queue > 0) // Perhaps this should be a separate variable? For now, we will just simply use -THRESHOLD_POTENTIAL
     822:	20 e0       	ldi	r18, 0x00	; 0
     824:	30 e0       	ldi	r19, 0x00	; 0
     826:	48 ec       	ldi	r20, 0xC8	; 200
     828:	51 ec       	ldi	r21, 0xC1	; 193
     82a:	c7 01       	movw	r24, r14
     82c:	b6 01       	movw	r22, r12
     82e:	22 d2       	rcall	.+1092   	; 0xc74 <__cmpsf2>
     830:	88 23       	and	r24, r24
     832:	84 f4       	brge	.+32     	; 0x854 <tinyAxon_update_potential+0xc0>
     834:	80 91 38 3e 	lds	r24, 0x3E38	; 0x803e38 <pulses_in_queue>
     838:	88 23       	and	r24, r24
     83a:	79 f1       	breq	.+94     	; 0x89a <tinyAxon_update_potential+0x106>
	{
		// The neurons potential is low enough to attempt to remove a queued fire (Fire less)
		if(tinyAxon_remove_pulse())
     83c:	7e df       	rcall	.-260    	; 0x73a <tinyAxon_remove_pulse>
     83e:	88 23       	and	r24, r24
     840:	49 f0       	breq	.+18     	; 0x854 <tinyAxon_update_potential+0xc0>
		{
			// The potential has evened out a bit
			potential += THRESHOLD_POTENTIAL;
     842:	20 e0       	ldi	r18, 0x00	; 0
     844:	30 e0       	ldi	r19, 0x00	; 0
     846:	48 ec       	ldi	r20, 0xC8	; 200
     848:	51 e4       	ldi	r21, 0x41	; 65
     84a:	c7 01       	movw	r24, r14
     84c:	b6 01       	movw	r22, r12
     84e:	a6 d1       	rcall	.+844    	; 0xb9c <__addsf3>
     850:	6b 01       	movw	r12, r22
     852:	7c 01       	movw	r14, r24
		}
	}
	
	// If there are pulses in the queue, and the pulse has been scheduled to fire
	if ((pulses_in_queue > 0) && (next_pulse <= now))
     854:	80 91 38 3e 	lds	r24, 0x3E38	; 0x803e38 <pulses_in_queue>
     858:	88 23       	and	r24, r24
     85a:	f9 f0       	breq	.+62     	; 0x89a <tinyAxon_update_potential+0x106>
     85c:	40 91 55 3e 	lds	r20, 0x3E55	; 0x803e55 <next_pulse>
     860:	50 91 56 3e 	lds	r21, 0x3E56	; 0x803e56 <next_pulse+0x1>
     864:	60 91 57 3e 	lds	r22, 0x3E57	; 0x803e57 <next_pulse+0x2>
     868:	70 91 58 3e 	lds	r23, 0x3E58	; 0x803e58 <next_pulse+0x3>
     86c:	44 16       	cp	r4, r20
     86e:	55 06       	cpc	r5, r21
     870:	66 06       	cpc	r6, r22
     872:	77 06       	cpc	r7, r23
     874:	90 f0       	brcs	.+36     	; 0x89a <tinyAxon_update_potential+0x106>
Function to set firing.
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
     876:	91 e0       	ldi	r25, 0x01	; 1
     878:	90 93 39 3e 	sts	0x3E39, r25	; 0x803e39 <tinyAxon_should_fire>
	pulses_in_queue--;
     87c:	81 50       	subi	r24, 0x01	; 1
     87e:	80 93 38 3e 	sts	0x3E38, r24	; 0x803e38 <pulses_in_queue>
	next_pulse = dequeue(&pulse_queue);
     882:	86 e3       	ldi	r24, 0x36	; 54
     884:	9e e3       	ldi	r25, 0x3E	; 62
     886:	fd dc       	rcall	.-1542   	; 0x282 <dequeue>
     888:	60 93 55 3e 	sts	0x3E55, r22	; 0x803e55 <next_pulse>
     88c:	70 93 56 3e 	sts	0x3E56, r23	; 0x803e56 <next_pulse+0x1>
     890:	80 93 57 3e 	sts	0x3E57, r24	; 0x803e57 <next_pulse+0x2>
     894:	90 93 58 3e 	sts	0x3E58, r25	; 0x803e58 <next_pulse+0x3>
	// If there are pulses in the queue, and the pulse has been scheduled to fire
	if ((pulses_in_queue > 0) && (next_pulse <= now))
	{
		// We fire the axon
		tinyAxon_fire_pulse();
		set_LED_fire();
     898:	21 de       	rcall	.-958    	; 0x4dc <set_LED_fire>
The function should set the DAC to fire for two
update cycles once the pulse flag is set high.
*/
static void tinyAxon_update_pulse_transmitter(void)
{
	if (tinyAxon_should_fire)
     89a:	80 91 39 3e 	lds	r24, 0x3E39	; 0x803e39 <tinyAxon_should_fire>
     89e:	88 23       	and	r24, r24
     8a0:	61 f0       	breq	.+24     	; 0x8ba <tinyAxon_update_potential+0x126>
	{
		tinyAxon_should_fire = false;
     8a2:	10 92 39 3e 	sts	0x3E39, r1	; 0x803e39 <tinyAxon_should_fire>
		tinyAxon_has_fired = true;
     8a6:	81 e0       	ldi	r24, 0x01	; 1
     8a8:	80 93 3a 3e 	sts	0x3E3A, r24	; 0x803e3a <tinyAxon_has_fired>
*/
static void tinyAxon_start_sending_pulse()
{
	if (NEURONTYPE == EXCITATORY_NEURON)
	{
		DAC_set_output(EXCITATORY_NEURON_OUTPUT);
     8ac:	87 ed       	ldi	r24, 0xD7	; 215
     8ae:	90 e0       	ldi	r25, 0x00	; 0
     8b0:	31 dc       	rcall	.-1950   	; 0x114 <DAC_set_output>
		axonOutputValue=EXCITATORY_NEURON_OUTPUT;
     8b2:	87 ed       	ldi	r24, 0xD7	; 215
     8b4:	80 93 35 3e 	sts	0x3E35, r24	; 0x803e35 <axonOutputValue>
     8b8:	0c c0       	rjmp	.+24     	; 0x8d2 <tinyAxon_update_potential+0x13e>
		tinyAxon_should_fire = false;
		tinyAxon_has_fired = true;
		
		tinyAxon_start_sending_pulse();
	}
	else if (tinyAxon_has_fired)
     8ba:	80 91 3a 3e 	lds	r24, 0x3E3A	; 0x803e3a <tinyAxon_has_fired>
     8be:	88 23       	and	r24, r24
     8c0:	19 f0       	breq	.+6      	; 0x8c8 <tinyAxon_update_potential+0x134>
	{
		tinyAxon_has_fired = false;
     8c2:	10 92 3a 3e 	sts	0x3E3A, r1	; 0x803e3a <tinyAxon_has_fired>
     8c6:	05 c0       	rjmp	.+10     	; 0x8d2 <tinyAxon_update_potential+0x13e>
}

static void tinyAxon_stop_sending_pulse()
{
	
	DAC_set_output(NO_SIGNAL_OUTPUT);
     8c8:	80 e0       	ldi	r24, 0x00	; 0
     8ca:	90 e0       	ldi	r25, 0x00	; 0
     8cc:	23 dc       	rcall	.-1978   	; 0x114 <DAC_set_output>
	axonOutputValue=NO_SIGNAL_OUTPUT;
     8ce:	10 92 35 3e 	sts	0x3E35, r1	; 0x803e35 <axonOutputValue>
	}
	
	// Here we set the actual output of the DAC (Digital to Analog Converter)
	tinyAxon_update_pulse_transmitter();
	return potential;
}
     8d2:	c7 01       	movw	r24, r14
     8d4:	b6 01       	movw	r22, r12
     8d6:	df 91       	pop	r29
     8d8:	cf 91       	pop	r28
     8da:	ff 90       	pop	r15
     8dc:	ef 90       	pop	r14
     8de:	df 90       	pop	r13
     8e0:	cf 90       	pop	r12
     8e2:	bf 90       	pop	r11
     8e4:	af 90       	pop	r10
     8e6:	9f 90       	pop	r9
     8e8:	8f 90       	pop	r8
     8ea:	7f 90       	pop	r7
     8ec:	6f 90       	pop	r6
     8ee:	5f 90       	pop	r5
     8f0:	4f 90       	pop	r4
     8f2:	08 95       	ret

000008f4 <tinyDendriteite_update_signals>:
/*
This function converts the 8 bit value from the ADC into one of the signal types defined in DendriteiteSignal
We also update the charging state
*/
void tinyDendriteite_update_signals(void)
{
     8f4:	2f 92       	push	r2
     8f6:	3f 92       	push	r3
     8f8:	4f 92       	push	r4
     8fa:	5f 92       	push	r5
     8fc:	6f 92       	push	r6
     8fe:	7f 92       	push	r7
     900:	8f 92       	push	r8
     902:	9f 92       	push	r9
     904:	af 92       	push	r10
     906:	bf 92       	push	r11
     908:	cf 92       	push	r12
     90a:	df 92       	push	r13
     90c:	ef 92       	push	r14
     90e:	ff 92       	push	r15
     910:	0f 93       	push	r16
     912:	1f 93       	push	r17
     914:	cf 93       	push	r28
     916:	df 93       	push	r29
	tinyCharge_set_charging(false);
     918:	80 e0       	ldi	r24, 0x00	; 0
     91a:	50 dd       	rcall	.-1376   	; 0x3bc <tinyCharge_set_charging>
     91c:	c0 e4       	ldi	r28, 0x40	; 64
     91e:	de e3       	ldi	r29, 0x3E	; 62
     920:	0f 2e       	mov	r0, r31
     922:	f5 e4       	ldi	r31, 0x45	; 69
     924:	cf 2e       	mov	r12, r31
     926:	fe e3       	ldi	r31, 0x3E	; 62
     928:	df 2e       	mov	r13, r31
     92a:	f0 2d       	mov	r31, r0
     92c:	0b e3       	ldi	r16, 0x3B	; 59
     92e:	1e e3       	ldi	r17, 0x3E	; 62
     930:	0f 2e       	mov	r0, r31
     932:	f5 e4       	ldi	r31, 0x45	; 69
     934:	8f 2e       	mov	r8, r31
     936:	fe e3       	ldi	r31, 0x3E	; 62
     938:	9f 2e       	mov	r9, r31
     93a:	f0 2d       	mov	r31, r0
		{
			tinyDendriteite_current_signals[i] = HIGH_INHIB;
		}
		else if (tinyDendriteite_values[i] > LOW_INHIB_THRESHOLD)
		{
			tinyDendriteite_current_signals[i] = LOW_INHIB;
     93c:	66 24       	eor	r6, r6
     93e:	63 94       	inc	r6
		{
			tinyDendriteite_current_signals[i] = LOW_EXCITE;
		}
		else if (tinyDendriteite_values[i] > NORMAL_INHIB_THRESHOLD)
		{
			tinyDendriteite_current_signals[i] = NORMAL_INHIB;
     940:	68 94       	set
     942:	22 24       	eor	r2, r2
     944:	21 f8       	bld	r2, 1
		{
			tinyDendriteite_current_signals[i] = HIGH_EXCITE;
		}
		else if (tinyDendriteite_values[i] > LOW_EXCITE_THRESHOLD)
		{
			tinyDendriteite_current_signals[i] = LOW_EXCITE;
     946:	68 94       	set
     948:	33 24       	eor	r3, r3
     94a:	32 f8       	bld	r3, 2
		{
			tinyDendriteite_current_signals[i] = NORMAL_EXCITE;
		}
		else if (tinyDendriteite_values[i] > HIGH_EXCITE_THRESHOLD)
		{
			tinyDendriteite_current_signals[i] = HIGH_EXCITE;
     94c:	0f 2e       	mov	r0, r31
     94e:	f6 e0       	ldi	r31, 0x06	; 6
     950:	4f 2e       	mov	r4, r31
     952:	f0 2d       	mov	r31, r0
			tinyDendriteite_current_signals[i] = CHARGING;
			tinyCharge_set_charging(true);
		}
		else if (tinyDendriteite_values[i] > NORMAL_EXCITE_THRESHOLD)
		{
			tinyDendriteite_current_signals[i] = NORMAL_EXCITE;
     954:	0f 2e       	mov	r0, r31
     956:	f5 e0       	ldi	r31, 0x05	; 5
     958:	7f 2e       	mov	r7, r31
     95a:	f0 2d       	mov	r31, r0
	for (uint8_t i = 0; i < TINYDENDRITEITE_COUNT; i++)
	{
		tinyDendriteite_previous_signals[i] = tinyDendriteite_current_signals[i];
		if (tinyDendriteite_values[i] > CHARGING_THRESHOLD)
		{
			tinyDendriteite_current_signals[i] = CHARGING;
     95c:	0f 2e       	mov	r0, r31
     95e:	f7 e0       	ldi	r31, 0x07	; 7
     960:	5f 2e       	mov	r5, r31
     962:	f0 2d       	mov	r31, r0
     964:	7e 01       	movw	r14, r28
     966:	58 01       	movw	r10, r16
{
	tinyCharge_set_charging(false);
	
	for (uint8_t i = 0; i < TINYDENDRITEITE_COUNT; i++)
	{
		tinyDendriteite_previous_signals[i] = tinyDendriteite_current_signals[i];
     968:	88 81       	ld	r24, Y
     96a:	f8 01       	movw	r30, r16
     96c:	80 83       	st	Z, r24
		if (tinyDendriteite_values[i] > CHARGING_THRESHOLD)
     96e:	f6 01       	movw	r30, r12
     970:	81 91       	ld	r24, Z+
     972:	91 91       	ld	r25, Z+
     974:	6f 01       	movw	r12, r30
     976:	89 3e       	cpi	r24, 0xE9	; 233
     978:	91 05       	cpc	r25, r1
     97a:	20 f0       	brcs	.+8      	; 0x984 <tinyDendriteite_update_signals+0x90>
		{
			tinyDendriteite_current_signals[i] = CHARGING;
     97c:	58 82       	st	Y, r5
			tinyCharge_set_charging(true);
     97e:	86 2d       	mov	r24, r6
     980:	1d dd       	rcall	.-1478   	; 0x3bc <tinyCharge_set_charging>
     982:	1f c0       	rjmp	.+62     	; 0x9c2 <tinyDendriteite_update_signals+0xce>
		}
		else if (tinyDendriteite_values[i] > NORMAL_EXCITE_THRESHOLD)
     984:	88 3c       	cpi	r24, 0xC8	; 200
     986:	91 05       	cpc	r25, r1
     988:	10 f0       	brcs	.+4      	; 0x98e <tinyDendriteite_update_signals+0x9a>
		{
			tinyDendriteite_current_signals[i] = NORMAL_EXCITE;
     98a:	78 82       	st	Y, r7
     98c:	1a c0       	rjmp	.+52     	; 0x9c2 <tinyDendriteite_update_signals+0xce>
		}
		else if (tinyDendriteite_values[i] > HIGH_EXCITE_THRESHOLD)
     98e:	87 3a       	cpi	r24, 0xA7	; 167
     990:	91 05       	cpc	r25, r1
     992:	10 f0       	brcs	.+4      	; 0x998 <tinyDendriteite_update_signals+0xa4>
		{
			tinyDendriteite_current_signals[i] = HIGH_EXCITE;
     994:	48 82       	st	Y, r4
     996:	15 c0       	rjmp	.+42     	; 0x9c2 <tinyDendriteite_update_signals+0xce>
		}
		else if (tinyDendriteite_values[i] > LOW_EXCITE_THRESHOLD)
     998:	85 38       	cpi	r24, 0x85	; 133
     99a:	91 05       	cpc	r25, r1
     99c:	10 f0       	brcs	.+4      	; 0x9a2 <tinyDendriteite_update_signals+0xae>
		{
			tinyDendriteite_current_signals[i] = LOW_EXCITE;
     99e:	38 82       	st	Y, r3
     9a0:	10 c0       	rjmp	.+32     	; 0x9c2 <tinyDendriteite_update_signals+0xce>
		}
		else if (tinyDendriteite_values[i] > NORMAL_INHIB_THRESHOLD)
     9a2:	84 36       	cpi	r24, 0x64	; 100
     9a4:	91 05       	cpc	r25, r1
     9a6:	10 f0       	brcs	.+4      	; 0x9ac <tinyDendriteite_update_signals+0xb8>
		{
			tinyDendriteite_current_signals[i] = NORMAL_INHIB;
     9a8:	28 82       	st	Y, r2
     9aa:	0b c0       	rjmp	.+22     	; 0x9c2 <tinyDendriteite_update_signals+0xce>
		}
		else if (tinyDendriteite_values[i] > HIGH_INHIB_THRESHOLD)
     9ac:	83 34       	cpi	r24, 0x43	; 67
     9ae:	91 05       	cpc	r25, r1
     9b0:	18 f0       	brcs	.+6      	; 0x9b8 <tinyDendriteite_update_signals+0xc4>
		{
			tinyDendriteite_current_signals[i] = HIGH_INHIB;
     9b2:	83 e0       	ldi	r24, 0x03	; 3
     9b4:	88 83       	st	Y, r24
     9b6:	05 c0       	rjmp	.+10     	; 0x9c2 <tinyDendriteite_update_signals+0xce>
		}
		else if (tinyDendriteite_values[i] > LOW_INHIB_THRESHOLD)
     9b8:	82 97       	sbiw	r24, 0x22	; 34
     9ba:	10 f0       	brcs	.+4      	; 0x9c0 <tinyDendriteite_update_signals+0xcc>
		{
			tinyDendriteite_current_signals[i] = LOW_INHIB;
     9bc:	68 82       	st	Y, r6
     9be:	01 c0       	rjmp	.+2      	; 0x9c2 <tinyDendriteite_update_signals+0xce>
		}
		else
		{
			tinyDendriteite_current_signals[i] = NO_SIGNAL;
     9c0:	18 82       	st	Y, r1
     9c2:	0f 5f       	subi	r16, 0xFF	; 255
     9c4:	1f 4f       	sbci	r17, 0xFF	; 255
		}
		if (tinyDendriteite_current_signals[i] == tinyDendriteite_previous_signals[i])
     9c6:	f7 01       	movw	r30, r14
     9c8:	90 81       	ld	r25, Z
     9ca:	f5 01       	movw	r30, r10
     9cc:	80 81       	ld	r24, Z
     9ce:	98 13       	cpse	r25, r24
     9d0:	02 c0       	rjmp	.+4      	; 0x9d6 <tinyDendriteite_update_signals+0xe2>
		{
			tinyDendriteite_current_signals[i] = NO_SIGNAL;
     9d2:	f7 01       	movw	r30, r14
     9d4:	10 82       	st	Z, r1
     9d6:	21 96       	adiw	r28, 0x01	; 1
*/
void tinyDendriteite_update_signals(void)
{
	tinyCharge_set_charging(false);
	
	for (uint8_t i = 0; i < TINYDENDRITEITE_COUNT; i++)
     9d8:	c8 15       	cp	r28, r8
     9da:	d9 05       	cpc	r29, r9
     9dc:	19 f6       	brne	.-122    	; 0x964 <tinyDendriteite_update_signals+0x70>
		if (tinyDendriteite_current_signals[i] == tinyDendriteite_previous_signals[i])
		{
			tinyDendriteite_current_signals[i] = NO_SIGNAL;
		}
	}
}
     9de:	df 91       	pop	r29
     9e0:	cf 91       	pop	r28
     9e2:	1f 91       	pop	r17
     9e4:	0f 91       	pop	r16
     9e6:	ff 90       	pop	r15
     9e8:	ef 90       	pop	r14
     9ea:	df 90       	pop	r13
     9ec:	cf 90       	pop	r12
     9ee:	bf 90       	pop	r11
     9f0:	af 90       	pop	r10
     9f2:	9f 90       	pop	r9
     9f4:	8f 90       	pop	r8
     9f6:	7f 90       	pop	r7
     9f8:	6f 90       	pop	r6
     9fa:	5f 90       	pop	r5
     9fc:	4f 90       	pop	r4
     9fe:	3f 90       	pop	r3
     a00:	2f 90       	pop	r2
     a02:	08 95       	ret

00000a04 <tinyDendriteite_get_potential>:
/*
This is the master function of the module that is callable from
outside. It uses the previously declared functions to return the potential.
*/
int16_t tinyDendriteite_get_potential()
{
     a04:	ef 92       	push	r14
     a06:	ff 92       	push	r15
     a08:	0f 93       	push	r16
     a0a:	1f 93       	push	r17
     a0c:	cf 93       	push	r28
     a0e:	df 93       	push	r29
     a10:	08 e0       	ldi	r16, 0x08	; 8
     a12:	1e e3       	ldi	r17, 0x3E	; 62
     a14:	c5 e4       	ldi	r28, 0x45	; 69
     a16:	de e3       	ldi	r29, 0x3E	; 62
     a18:	0f 2e       	mov	r0, r31
     a1a:	ff e4       	ldi	r31, 0x4F	; 79
     a1c:	ef 2e       	mov	r14, r31
     a1e:	fe e3       	ldi	r31, 0x3E	; 62
     a20:	ff 2e       	mov	r15, r31
     a22:	f0 2d       	mov	r31, r0
*/
static void tinyDendriteite_read_signals(void)
{
	for (int i = 0; i < TINYDENDRITEITE_COUNT; i++)
	{
		tinyDendriteite_values[i] = ADC_get_conversion(Dendriteite_ports[i]);
     a24:	f8 01       	movw	r30, r16
     a26:	81 91       	ld	r24, Z+
     a28:	8f 01       	movw	r16, r30
     a2a:	3f db       	rcall	.-2434   	; 0xaa <ADC_get_conversion>
     a2c:	89 93       	st	Y+, r24
     a2e:	99 93       	st	Y+, r25
/*
This function reads the voltage at the Dendriteite inputs with the ADC
*/
static void tinyDendriteite_read_signals(void)
{
	for (int i = 0; i < TINYDENDRITEITE_COUNT; i++)
     a30:	ce 15       	cp	r28, r14
     a32:	df 05       	cpc	r29, r15
     a34:	b9 f7       	brne	.-18     	; 0xa24 <tinyDendriteite_get_potential+0x20>
int16_t tinyDendriteite_get_potential()
{
	//Read the analog voltage values on each of the Dendriteites
	tinyDendriteite_read_signals();
	//Convert the digital value to the various signals defined in DendriteiteSignalType
	tinyDendriteite_update_signals();
     a36:	5e df       	rcall	.-324    	; 0x8f4 <tinyDendriteite_update_signals>
     a38:	e0 e4       	ldi	r30, 0x40	; 64
     a3a:	fe e3       	ldi	r31, 0x3E	; 62
     a3c:	45 e4       	ldi	r20, 0x45	; 69
     a3e:	5e e3       	ldi	r21, 0x3E	; 62
	
	int16_t return_potential_val = 0;
     a40:	20 e0       	ldi	r18, 0x00	; 0
     a42:	30 e0       	ldi	r19, 0x00	; 0
	for (int i = 0; i < TINYDENDRITEITE_COUNT; i++)
	{
		switch(tinyDendriteite_current_signals[i])
     a44:	91 91       	ld	r25, Z+
     a46:	93 30       	cpi	r25, 0x03	; 3
     a48:	a1 f0       	breq	.+40     	; 0xa72 <tinyDendriteite_get_potential+0x6e>
     a4a:	28 f4       	brcc	.+10     	; 0xa56 <tinyDendriteite_get_potential+0x52>
     a4c:	91 30       	cpi	r25, 0x01	; 1
     a4e:	b9 f0       	breq	.+46     	; 0xa7e <tinyDendriteite_get_potential+0x7a>
     a50:	92 30       	cpi	r25, 0x02	; 2
     a52:	91 f0       	breq	.+36     	; 0xa78 <tinyDendriteite_get_potential+0x74>
     a54:	16 c0       	rjmp	.+44     	; 0xa82 <tinyDendriteite_get_potential+0x7e>
     a56:	95 30       	cpi	r25, 0x05	; 5
     a58:	31 f0       	breq	.+12     	; 0xa66 <tinyDendriteite_get_potential+0x62>
     a5a:	40 f0       	brcs	.+16     	; 0xa6c <tinyDendriteite_get_potential+0x68>
     a5c:	96 30       	cpi	r25, 0x06	; 6
     a5e:	89 f4       	brne	.+34     	; 0xa82 <tinyDendriteite_get_potential+0x7e>
		{
			case NO_SIGNAL:
				return_potential_val += NO_SIGNAL_REACTION;
				break;
			case HIGH_EXCITE:
				return_potential_val += HIGH_EXCITE_REACTION;
     a60:	2c 5c       	subi	r18, 0xCC	; 204
     a62:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     a64:	0e c0       	rjmp	.+28     	; 0xa82 <tinyDendriteite_get_potential+0x7e>
			case NORMAL_EXCITE:
				return_potential_val += NORMAL_EXCITE_REACTION;
     a66:	26 5e       	subi	r18, 0xE6	; 230
     a68:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     a6a:	0b c0       	rjmp	.+22     	; 0xa82 <tinyDendriteite_get_potential+0x7e>
			case LOW_EXCITE:
				return_potential_val += LOW_EXCITE_REACTION;
     a6c:	2c 5e       	subi	r18, 0xEC	; 236
     a6e:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     a70:	08 c0       	rjmp	.+16     	; 0xa82 <tinyDendriteite_get_potential+0x7e>
			case HIGH_INHIB:
				return_potential_val += HIGH_INHIB_REACTION;
     a72:	22 53       	subi	r18, 0x32	; 50
     a74:	31 09       	sbc	r19, r1
				break;
     a76:	05 c0       	rjmp	.+10     	; 0xa82 <tinyDendriteite_get_potential+0x7e>
			case NORMAL_INHIB:
				return_potential_val += NORMAL_INHIB_REACTION;
     a78:	2a 51       	subi	r18, 0x1A	; 26
     a7a:	31 09       	sbc	r19, r1
				break;
     a7c:	02 c0       	rjmp	.+4      	; 0xa82 <tinyDendriteite_get_potential+0x7e>
			case LOW_INHIB:
				return_potential_val += LOW_INHIB_REACTION;
     a7e:	24 51       	subi	r18, 0x14	; 20
     a80:	31 09       	sbc	r19, r1
	tinyDendriteite_read_signals();
	//Convert the digital value to the various signals defined in DendriteiteSignalType
	tinyDendriteite_update_signals();
	
	int16_t return_potential_val = 0;
	for (int i = 0; i < TINYDENDRITEITE_COUNT; i++)
     a82:	e4 17       	cp	r30, r20
     a84:	f5 07       	cpc	r31, r21
     a86:	f1 f6       	brne	.-68     	; 0xa44 <tinyDendriteite_get_potential+0x40>
			default:
				break;
		}
	}
	return return_potential_val;
}
     a88:	c9 01       	movw	r24, r18
     a8a:	df 91       	pop	r29
     a8c:	cf 91       	pop	r28
     a8e:	1f 91       	pop	r17
     a90:	0f 91       	pop	r16
     a92:	ff 90       	pop	r15
     a94:	ef 90       	pop	r14
     a96:	08 95       	ret

00000a98 <tinyDendriteite_update_potential>:

double tinyDendriteite_update_potential(double potential){
     a98:	cf 92       	push	r12
     a9a:	df 92       	push	r13
     a9c:	ef 92       	push	r14
     a9e:	ff 92       	push	r15
     aa0:	6b 01       	movw	r12, r22
     aa2:	7c 01       	movw	r14, r24
	
	uint16_t potential_change = tinyDendriteite_get_potential();
     aa4:	af df       	rcall	.-162    	; 0xa04 <tinyDendriteite_get_potential>
	potential += potential_change;
	return potential;
     aa6:	bc 01       	movw	r22, r24
     aa8:	80 e0       	ldi	r24, 0x00	; 0
     aaa:	90 e0       	ldi	r25, 0x00	; 0
     aac:	ca d1       	rcall	.+916    	; 0xe42 <__floatunsisf>
     aae:	a7 01       	movw	r20, r14
     ab0:	96 01       	movw	r18, r12
     ab2:	74 d0       	rcall	.+232    	; 0xb9c <__addsf3>
     ab4:	ff 90       	pop	r15
     ab6:	ef 90       	pop	r14
     ab8:	df 90       	pop	r13
     aba:	cf 90       	pop	r12
     abc:	08 95       	ret

00000abe <__vector_6>:
This function is called every time the RTC (Real Time Clock) counter overflows.
With the current settings, it will be called every ms.
The RTC clock runs at 1kHz, and the number of cycles before overflow is set with RTC.PER = someHexValue (e.g. 0x20) in src/rtc.c
*/
ISR(RTC_CNT_vect)
{
     abe:	1f 92       	push	r1
     ac0:	0f 92       	push	r0
     ac2:	0f b6       	in	r0, 0x3f	; 63
     ac4:	0f 92       	push	r0
     ac6:	11 24       	eor	r1, r1
     ac8:	2f 93       	push	r18
     aca:	3f 93       	push	r19
     acc:	4f 93       	push	r20
     ace:	5f 93       	push	r21
     ad0:	6f 93       	push	r22
     ad2:	7f 93       	push	r23
     ad4:	8f 93       	push	r24
     ad6:	9f 93       	push	r25
     ad8:	af 93       	push	r26
     ada:	bf 93       	push	r27
     adc:	cf 93       	push	r28
     ade:	ef 93       	push	r30
     ae0:	ff 93       	push	r31
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     ae2:	c1 e0       	ldi	r28, 0x01	; 1
     ae4:	c0 93 4f 3e 	sts	0x3E4F, r28	; 0x803e4f <tinyISR_interrupt_flag>
{
	// Set flag to let main loop run a new cycle
	tinyISR_setflag(true);
	
	// Timer counter incrementation
	tinyTime_counter_increment();
     ae8:	b0 dc       	rcall	.-1696   	; 0x44a <tinyTime_counter_increment>

	/* Overflow interrupt flag has to be cleared manually */
	RTC.INTFLAGS = RTC_OVF_bm;
     aea:	c0 93 43 01 	sts	0x0143, r28	; 0x800143 <__TEXT_REGION_LENGTH__+0x700143>
}
     aee:	ff 91       	pop	r31
     af0:	ef 91       	pop	r30
     af2:	cf 91       	pop	r28
     af4:	bf 91       	pop	r27
     af6:	af 91       	pop	r26
     af8:	9f 91       	pop	r25
     afa:	8f 91       	pop	r24
     afc:	7f 91       	pop	r23
     afe:	6f 91       	pop	r22
     b00:	5f 91       	pop	r21
     b02:	4f 91       	pop	r20
     b04:	3f 91       	pop	r19
     b06:	2f 91       	pop	r18
     b08:	0f 90       	pop	r0
     b0a:	0f be       	out	0x3f, r0	; 63
     b0c:	0f 90       	pop	r0
     b0e:	1f 90       	pop	r1
     b10:	18 95       	reti

00000b12 <tinyISR_setflag>:
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     b12:	80 93 4f 3e 	sts	0x3E4F, r24	; 0x803e4f <tinyISR_interrupt_flag>
     b16:	08 95       	ret

00000b18 <tinyISR_getflag>:
}

_Bool tinyISR_getflag(void)
{
	return tinyISR_interrupt_flag;
}
     b18:	80 91 4f 3e 	lds	r24, 0x3E4F	; 0x803e4f <tinyISR_interrupt_flag>
     b1c:	08 95       	ret

00000b1e <tinyPotential_update>:
/*
Function to decay the potential towards 0
*/
static void tinyPotential_decay(double time_since_last_update)
{
	tinyPotential_potential *= (exp(-(time_since_last_update/TINYPOTENTIAL_TIME_CONST)));
     b1e:	20 e0       	ldi	r18, 0x00	; 0
     b20:	30 e0       	ldi	r19, 0x00	; 0
     b22:	48 ec       	ldi	r20, 0xC8	; 200
     b24:	52 e4       	ldi	r21, 0x42	; 66
     b26:	ab d0       	rcall	.+342    	; 0xc7e <__divsf3>
     b28:	90 58       	subi	r25, 0x80	; 128
     b2a:	23 d1       	rcall	.+582    	; 0xd72 <exp>
     b2c:	20 91 50 3e 	lds	r18, 0x3E50	; 0x803e50 <tinyPotential_potential>
     b30:	30 91 51 3e 	lds	r19, 0x3E51	; 0x803e51 <tinyPotential_potential+0x1>
     b34:	40 91 52 3e 	lds	r20, 0x3E52	; 0x803e52 <tinyPotential_potential+0x2>
     b38:	50 91 53 3e 	lds	r21, 0x3E53	; 0x803e53 <tinyPotential_potential+0x3>
     b3c:	d6 d2       	rcall	.+1452   	; 0x10ea <__mulsf3>
     b3e:	60 93 50 3e 	sts	0x3E50, r22	; 0x803e50 <tinyPotential_potential>
     b42:	70 93 51 3e 	sts	0x3E51, r23	; 0x803e51 <tinyPotential_potential+0x1>
     b46:	80 93 52 3e 	sts	0x3E52, r24	; 0x803e52 <tinyPotential_potential+0x2>
     b4a:	90 93 53 3e 	sts	0x3E53, r25	; 0x803e53 <tinyPotential_potential+0x3>
{
	//Some of the potential in the neuron has decayed away
	tinyPotential_decay(time_since_last_update);
	
	// Update potential with values from Dendriteites
	tinyPotential_potential = tinyDendriteite_update_potential(tinyPotential_potential);
     b4e:	a4 df       	rcall	.-184    	; 0xa98 <tinyDendriteite_update_potential>
     b50:	60 93 50 3e 	sts	0x3E50, r22	; 0x803e50 <tinyPotential_potential>
     b54:	70 93 51 3e 	sts	0x3E51, r23	; 0x803e51 <tinyPotential_potential+0x1>
     b58:	80 93 52 3e 	sts	0x3E52, r24	; 0x803e52 <tinyPotential_potential+0x2>
     b5c:	90 93 53 3e 	sts	0x3E53, r25	; 0x803e53 <tinyPotential_potential+0x3>
	
	// Update potential from button press
	tinyPotential_potential = tinyButton_update_potential(tinyPotential_potential);
     b60:	aa dd       	rcall	.-1196   	; 0x6b6 <tinyButton_update_potential>
     b62:	60 93 50 3e 	sts	0x3E50, r22	; 0x803e50 <tinyPotential_potential>
     b66:	70 93 51 3e 	sts	0x3E51, r23	; 0x803e51 <tinyPotential_potential+0x1>
     b6a:	80 93 52 3e 	sts	0x3E52, r24	; 0x803e52 <tinyPotential_potential+0x2>
     b6e:	90 93 53 3e 	sts	0x3E53, r25	; 0x803e53 <tinyPotential_potential+0x3>
	
	// Update potential with values from spontaneous pulse.
	tinyPotential_potential = tinyPulse_update_potential(tinyPotential_potential);
     b72:	36 dc       	rcall	.-1940   	; 0x3e0 <tinyPulse_update_potential>
     b74:	60 93 50 3e 	sts	0x3E50, r22	; 0x803e50 <tinyPotential_potential>
     b78:	70 93 51 3e 	sts	0x3E51, r23	; 0x803e51 <tinyPotential_potential+0x1>
     b7c:	80 93 52 3e 	sts	0x3E52, r24	; 0x803e52 <tinyPotential_potential+0x2>
     b80:	90 93 53 3e 	sts	0x3E53, r25	; 0x803e53 <tinyPotential_potential+0x3>
	
	// Let the axon affect the potential
	// This is also where we decide whether or not the axon should fire
	tinyPotential_potential = tinyAxon_update_potential(tinyPotential_potential);
     b84:	07 de       	rcall	.-1010   	; 0x794 <tinyAxon_update_potential>
     b86:	60 93 50 3e 	sts	0x3E50, r22	; 0x803e50 <tinyPotential_potential>
     b8a:	70 93 51 3e 	sts	0x3E51, r23	; 0x803e51 <tinyPotential_potential+0x1>
     b8e:	80 93 52 3e 	sts	0x3E52, r24	; 0x803e52 <tinyPotential_potential+0x2>
     b92:	90 93 53 3e 	sts	0x3E53, r25	; 0x803e53 <tinyPotential_potential+0x3>

	//Update the led
	potential_to_RGB_update_LEDs(tinyPotential_potential);
     b96:	b7 dc       	rcall	.-1682   	; 0x506 <potential_to_RGB_update_LEDs>
     b98:	08 95       	ret

00000b9a <__subsf3>:
     b9a:	50 58       	subi	r21, 0x80	; 128

00000b9c <__addsf3>:
     b9c:	bb 27       	eor	r27, r27
     b9e:	aa 27       	eor	r26, r26
     ba0:	0e 94 e5 05 	call	0xbca	; 0xbca <__addsf3x>
     ba4:	0c 94 c0 07 	jmp	0xf80	; 0xf80 <__fp_round>
     ba8:	0e 94 b2 07 	call	0xf64	; 0xf64 <__fp_pscA>
     bac:	38 f0       	brcs	.+14     	; 0xbbc <__addsf3+0x20>
     bae:	0e 94 b9 07 	call	0xf72	; 0xf72 <__fp_pscB>
     bb2:	20 f0       	brcs	.+8      	; 0xbbc <__addsf3+0x20>
     bb4:	39 f4       	brne	.+14     	; 0xbc4 <__addsf3+0x28>
     bb6:	9f 3f       	cpi	r25, 0xFF	; 255
     bb8:	19 f4       	brne	.+6      	; 0xbc0 <__addsf3+0x24>
     bba:	26 f4       	brtc	.+8      	; 0xbc4 <__addsf3+0x28>
     bbc:	0c 94 88 07 	jmp	0xf10	; 0xf10 <__fp_nan>
     bc0:	0e f4       	brtc	.+2      	; 0xbc4 <__addsf3+0x28>
     bc2:	e0 95       	com	r30
     bc4:	e7 fb       	bst	r30, 7
     bc6:	0c 94 82 07 	jmp	0xf04	; 0xf04 <__fp_inf>

00000bca <__addsf3x>:
     bca:	e9 2f       	mov	r30, r25
     bcc:	0e 94 d1 07 	call	0xfa2	; 0xfa2 <__fp_split3>
     bd0:	58 f3       	brcs	.-42     	; 0xba8 <__addsf3+0xc>
     bd2:	ba 17       	cp	r27, r26
     bd4:	62 07       	cpc	r22, r18
     bd6:	73 07       	cpc	r23, r19
     bd8:	84 07       	cpc	r24, r20
     bda:	95 07       	cpc	r25, r21
     bdc:	20 f0       	brcs	.+8      	; 0xbe6 <__addsf3x+0x1c>
     bde:	79 f4       	brne	.+30     	; 0xbfe <__addsf3x+0x34>
     be0:	a6 f5       	brtc	.+104    	; 0xc4a <__addsf3x+0x80>
     be2:	0c 94 f3 07 	jmp	0xfe6	; 0xfe6 <__fp_zero>
     be6:	0e f4       	brtc	.+2      	; 0xbea <__addsf3x+0x20>
     be8:	e0 95       	com	r30
     bea:	0b 2e       	mov	r0, r27
     bec:	ba 2f       	mov	r27, r26
     bee:	a0 2d       	mov	r26, r0
     bf0:	0b 01       	movw	r0, r22
     bf2:	b9 01       	movw	r22, r18
     bf4:	90 01       	movw	r18, r0
     bf6:	0c 01       	movw	r0, r24
     bf8:	ca 01       	movw	r24, r20
     bfa:	a0 01       	movw	r20, r0
     bfc:	11 24       	eor	r1, r1
     bfe:	ff 27       	eor	r31, r31
     c00:	59 1b       	sub	r21, r25
     c02:	99 f0       	breq	.+38     	; 0xc2a <__addsf3x+0x60>
     c04:	59 3f       	cpi	r21, 0xF9	; 249
     c06:	50 f4       	brcc	.+20     	; 0xc1c <__addsf3x+0x52>
     c08:	50 3e       	cpi	r21, 0xE0	; 224
     c0a:	68 f1       	brcs	.+90     	; 0xc66 <__addsf3x+0x9c>
     c0c:	1a 16       	cp	r1, r26
     c0e:	f0 40       	sbci	r31, 0x00	; 0
     c10:	a2 2f       	mov	r26, r18
     c12:	23 2f       	mov	r18, r19
     c14:	34 2f       	mov	r19, r20
     c16:	44 27       	eor	r20, r20
     c18:	58 5f       	subi	r21, 0xF8	; 248
     c1a:	f3 cf       	rjmp	.-26     	; 0xc02 <__addsf3x+0x38>
     c1c:	46 95       	lsr	r20
     c1e:	37 95       	ror	r19
     c20:	27 95       	ror	r18
     c22:	a7 95       	ror	r26
     c24:	f0 40       	sbci	r31, 0x00	; 0
     c26:	53 95       	inc	r21
     c28:	c9 f7       	brne	.-14     	; 0xc1c <__addsf3x+0x52>
     c2a:	7e f4       	brtc	.+30     	; 0xc4a <__addsf3x+0x80>
     c2c:	1f 16       	cp	r1, r31
     c2e:	ba 0b       	sbc	r27, r26
     c30:	62 0b       	sbc	r22, r18
     c32:	73 0b       	sbc	r23, r19
     c34:	84 0b       	sbc	r24, r20
     c36:	ba f0       	brmi	.+46     	; 0xc66 <__addsf3x+0x9c>
     c38:	91 50       	subi	r25, 0x01	; 1
     c3a:	a1 f0       	breq	.+40     	; 0xc64 <__addsf3x+0x9a>
     c3c:	ff 0f       	add	r31, r31
     c3e:	bb 1f       	adc	r27, r27
     c40:	66 1f       	adc	r22, r22
     c42:	77 1f       	adc	r23, r23
     c44:	88 1f       	adc	r24, r24
     c46:	c2 f7       	brpl	.-16     	; 0xc38 <__addsf3x+0x6e>
     c48:	0e c0       	rjmp	.+28     	; 0xc66 <__addsf3x+0x9c>
     c4a:	ba 0f       	add	r27, r26
     c4c:	62 1f       	adc	r22, r18
     c4e:	73 1f       	adc	r23, r19
     c50:	84 1f       	adc	r24, r20
     c52:	48 f4       	brcc	.+18     	; 0xc66 <__addsf3x+0x9c>
     c54:	87 95       	ror	r24
     c56:	77 95       	ror	r23
     c58:	67 95       	ror	r22
     c5a:	b7 95       	ror	r27
     c5c:	f7 95       	ror	r31
     c5e:	9e 3f       	cpi	r25, 0xFE	; 254
     c60:	08 f0       	brcs	.+2      	; 0xc64 <__addsf3x+0x9a>
     c62:	b0 cf       	rjmp	.-160    	; 0xbc4 <__addsf3+0x28>
     c64:	93 95       	inc	r25
     c66:	88 0f       	add	r24, r24
     c68:	08 f0       	brcs	.+2      	; 0xc6c <__addsf3x+0xa2>
     c6a:	99 27       	eor	r25, r25
     c6c:	ee 0f       	add	r30, r30
     c6e:	97 95       	ror	r25
     c70:	87 95       	ror	r24
     c72:	08 95       	ret

00000c74 <__cmpsf2>:
     c74:	0e 94 5e 07 	call	0xebc	; 0xebc <__fp_cmp>
     c78:	08 f4       	brcc	.+2      	; 0xc7c <__cmpsf2+0x8>
     c7a:	81 e0       	ldi	r24, 0x01	; 1
     c7c:	08 95       	ret

00000c7e <__divsf3>:
     c7e:	0e 94 53 06 	call	0xca6	; 0xca6 <__divsf3x>
     c82:	0c 94 c0 07 	jmp	0xf80	; 0xf80 <__fp_round>
     c86:	0e 94 b9 07 	call	0xf72	; 0xf72 <__fp_pscB>
     c8a:	58 f0       	brcs	.+22     	; 0xca2 <__divsf3+0x24>
     c8c:	0e 94 b2 07 	call	0xf64	; 0xf64 <__fp_pscA>
     c90:	40 f0       	brcs	.+16     	; 0xca2 <__divsf3+0x24>
     c92:	29 f4       	brne	.+10     	; 0xc9e <__divsf3+0x20>
     c94:	5f 3f       	cpi	r21, 0xFF	; 255
     c96:	29 f0       	breq	.+10     	; 0xca2 <__divsf3+0x24>
     c98:	0c 94 82 07 	jmp	0xf04	; 0xf04 <__fp_inf>
     c9c:	51 11       	cpse	r21, r1
     c9e:	0c 94 f4 07 	jmp	0xfe8	; 0xfe8 <__fp_szero>
     ca2:	0c 94 88 07 	jmp	0xf10	; 0xf10 <__fp_nan>

00000ca6 <__divsf3x>:
     ca6:	0e 94 d1 07 	call	0xfa2	; 0xfa2 <__fp_split3>
     caa:	68 f3       	brcs	.-38     	; 0xc86 <__divsf3+0x8>

00000cac <__divsf3_pse>:
     cac:	99 23       	and	r25, r25
     cae:	b1 f3       	breq	.-20     	; 0xc9c <__divsf3+0x1e>
     cb0:	55 23       	and	r21, r21
     cb2:	91 f3       	breq	.-28     	; 0xc98 <__divsf3+0x1a>
     cb4:	95 1b       	sub	r25, r21
     cb6:	55 0b       	sbc	r21, r21
     cb8:	bb 27       	eor	r27, r27
     cba:	aa 27       	eor	r26, r26
     cbc:	62 17       	cp	r22, r18
     cbe:	73 07       	cpc	r23, r19
     cc0:	84 07       	cpc	r24, r20
     cc2:	38 f0       	brcs	.+14     	; 0xcd2 <__divsf3_pse+0x26>
     cc4:	9f 5f       	subi	r25, 0xFF	; 255
     cc6:	5f 4f       	sbci	r21, 0xFF	; 255
     cc8:	22 0f       	add	r18, r18
     cca:	33 1f       	adc	r19, r19
     ccc:	44 1f       	adc	r20, r20
     cce:	aa 1f       	adc	r26, r26
     cd0:	a9 f3       	breq	.-22     	; 0xcbc <__divsf3_pse+0x10>
     cd2:	35 d0       	rcall	.+106    	; 0xd3e <__divsf3_pse+0x92>
     cd4:	0e 2e       	mov	r0, r30
     cd6:	3a f0       	brmi	.+14     	; 0xce6 <__divsf3_pse+0x3a>
     cd8:	e0 e8       	ldi	r30, 0x80	; 128
     cda:	32 d0       	rcall	.+100    	; 0xd40 <__divsf3_pse+0x94>
     cdc:	91 50       	subi	r25, 0x01	; 1
     cde:	50 40       	sbci	r21, 0x00	; 0
     ce0:	e6 95       	lsr	r30
     ce2:	00 1c       	adc	r0, r0
     ce4:	ca f7       	brpl	.-14     	; 0xcd8 <__divsf3_pse+0x2c>
     ce6:	2b d0       	rcall	.+86     	; 0xd3e <__divsf3_pse+0x92>
     ce8:	fe 2f       	mov	r31, r30
     cea:	29 d0       	rcall	.+82     	; 0xd3e <__divsf3_pse+0x92>
     cec:	66 0f       	add	r22, r22
     cee:	77 1f       	adc	r23, r23
     cf0:	88 1f       	adc	r24, r24
     cf2:	bb 1f       	adc	r27, r27
     cf4:	26 17       	cp	r18, r22
     cf6:	37 07       	cpc	r19, r23
     cf8:	48 07       	cpc	r20, r24
     cfa:	ab 07       	cpc	r26, r27
     cfc:	b0 e8       	ldi	r27, 0x80	; 128
     cfe:	09 f0       	breq	.+2      	; 0xd02 <__divsf3_pse+0x56>
     d00:	bb 0b       	sbc	r27, r27
     d02:	80 2d       	mov	r24, r0
     d04:	bf 01       	movw	r22, r30
     d06:	ff 27       	eor	r31, r31
     d08:	93 58       	subi	r25, 0x83	; 131
     d0a:	5f 4f       	sbci	r21, 0xFF	; 255
     d0c:	3a f0       	brmi	.+14     	; 0xd1c <__divsf3_pse+0x70>
     d0e:	9e 3f       	cpi	r25, 0xFE	; 254
     d10:	51 05       	cpc	r21, r1
     d12:	78 f0       	brcs	.+30     	; 0xd32 <__divsf3_pse+0x86>
     d14:	0c 94 82 07 	jmp	0xf04	; 0xf04 <__fp_inf>
     d18:	0c 94 f4 07 	jmp	0xfe8	; 0xfe8 <__fp_szero>
     d1c:	5f 3f       	cpi	r21, 0xFF	; 255
     d1e:	e4 f3       	brlt	.-8      	; 0xd18 <__divsf3_pse+0x6c>
     d20:	98 3e       	cpi	r25, 0xE8	; 232
     d22:	d4 f3       	brlt	.-12     	; 0xd18 <__divsf3_pse+0x6c>
     d24:	86 95       	lsr	r24
     d26:	77 95       	ror	r23
     d28:	67 95       	ror	r22
     d2a:	b7 95       	ror	r27
     d2c:	f7 95       	ror	r31
     d2e:	9f 5f       	subi	r25, 0xFF	; 255
     d30:	c9 f7       	brne	.-14     	; 0xd24 <__divsf3_pse+0x78>
     d32:	88 0f       	add	r24, r24
     d34:	91 1d       	adc	r25, r1
     d36:	96 95       	lsr	r25
     d38:	87 95       	ror	r24
     d3a:	97 f9       	bld	r25, 7
     d3c:	08 95       	ret
     d3e:	e1 e0       	ldi	r30, 0x01	; 1
     d40:	66 0f       	add	r22, r22
     d42:	77 1f       	adc	r23, r23
     d44:	88 1f       	adc	r24, r24
     d46:	bb 1f       	adc	r27, r27
     d48:	62 17       	cp	r22, r18
     d4a:	73 07       	cpc	r23, r19
     d4c:	84 07       	cpc	r24, r20
     d4e:	ba 07       	cpc	r27, r26
     d50:	20 f0       	brcs	.+8      	; 0xd5a <__divsf3_pse+0xae>
     d52:	62 1b       	sub	r22, r18
     d54:	73 0b       	sbc	r23, r19
     d56:	84 0b       	sbc	r24, r20
     d58:	ba 0b       	sbc	r27, r26
     d5a:	ee 1f       	adc	r30, r30
     d5c:	88 f7       	brcc	.-30     	; 0xd40 <__divsf3_pse+0x94>
     d5e:	e0 95       	com	r30
     d60:	08 95       	ret
     d62:	29 f4       	brne	.+10     	; 0xd6e <__divsf3_pse+0xc2>
     d64:	16 f0       	brts	.+4      	; 0xd6a <__divsf3_pse+0xbe>
     d66:	0c 94 82 07 	jmp	0xf04	; 0xf04 <__fp_inf>
     d6a:	0c 94 f3 07 	jmp	0xfe6	; 0xfe6 <__fp_zero>
     d6e:	0c 94 88 07 	jmp	0xf10	; 0xf10 <__fp_nan>

00000d72 <exp>:
     d72:	0e 94 d9 07 	call	0xfb2	; 0xfb2 <__fp_splitA>
     d76:	a8 f3       	brcs	.-22     	; 0xd62 <__divsf3_pse+0xb6>
     d78:	96 38       	cpi	r25, 0x86	; 134
     d7a:	a0 f7       	brcc	.-24     	; 0xd64 <__divsf3_pse+0xb8>
     d7c:	07 f8       	bld	r0, 7
     d7e:	0f 92       	push	r0
     d80:	e8 94       	clt
     d82:	2b e3       	ldi	r18, 0x3B	; 59
     d84:	3a ea       	ldi	r19, 0xAA	; 170
     d86:	48 eb       	ldi	r20, 0xB8	; 184
     d88:	5f e7       	ldi	r21, 0x7F	; 127
     d8a:	0e 94 8b 08 	call	0x1116	; 0x1116 <__mulsf3_pse>
     d8e:	0f 92       	push	r0
     d90:	0f 92       	push	r0
     d92:	0f 92       	push	r0
     d94:	4d b7       	in	r20, 0x3d	; 61
     d96:	5e b7       	in	r21, 0x3e	; 62
     d98:	0f 92       	push	r0
     d9a:	0e 94 41 08 	call	0x1082	; 0x1082 <modf>
     d9e:	e4 e3       	ldi	r30, 0x34	; 52
     da0:	f0 e0       	ldi	r31, 0x00	; 0
     da2:	0e 94 8b 07 	call	0xf16	; 0xf16 <__fp_powser>
     da6:	4f 91       	pop	r20
     da8:	5f 91       	pop	r21
     daa:	ef 91       	pop	r30
     dac:	ff 91       	pop	r31
     dae:	e5 95       	asr	r30
     db0:	ee 1f       	adc	r30, r30
     db2:	ff 1f       	adc	r31, r31
     db4:	49 f0       	breq	.+18     	; 0xdc8 <exp+0x56>
     db6:	fe 57       	subi	r31, 0x7E	; 126
     db8:	e0 68       	ori	r30, 0x80	; 128
     dba:	44 27       	eor	r20, r20
     dbc:	ee 0f       	add	r30, r30
     dbe:	44 1f       	adc	r20, r20
     dc0:	fa 95       	dec	r31
     dc2:	e1 f7       	brne	.-8      	; 0xdbc <exp+0x4a>
     dc4:	41 95       	neg	r20
     dc6:	55 0b       	sbc	r21, r21
     dc8:	0e 94 0b 08 	call	0x1016	; 0x1016 <ldexp>
     dcc:	0f 90       	pop	r0
     dce:	07 fe       	sbrs	r0, 7
     dd0:	0c 94 ff 07 	jmp	0xffe	; 0xffe <inverse>
     dd4:	08 95       	ret

00000dd6 <__fixsfsi>:
     dd6:	0e 94 f2 06 	call	0xde4	; 0xde4 <__fixunssfsi>
     dda:	68 94       	set
     ddc:	b1 11       	cpse	r27, r1
     dde:	0c 94 f4 07 	jmp	0xfe8	; 0xfe8 <__fp_szero>
     de2:	08 95       	ret

00000de4 <__fixunssfsi>:
     de4:	0e 94 d9 07 	call	0xfb2	; 0xfb2 <__fp_splitA>
     de8:	88 f0       	brcs	.+34     	; 0xe0c <__fixunssfsi+0x28>
     dea:	9f 57       	subi	r25, 0x7F	; 127
     dec:	98 f0       	brcs	.+38     	; 0xe14 <__fixunssfsi+0x30>
     dee:	b9 2f       	mov	r27, r25
     df0:	99 27       	eor	r25, r25
     df2:	b7 51       	subi	r27, 0x17	; 23
     df4:	b0 f0       	brcs	.+44     	; 0xe22 <__fixunssfsi+0x3e>
     df6:	e1 f0       	breq	.+56     	; 0xe30 <__fixunssfsi+0x4c>
     df8:	66 0f       	add	r22, r22
     dfa:	77 1f       	adc	r23, r23
     dfc:	88 1f       	adc	r24, r24
     dfe:	99 1f       	adc	r25, r25
     e00:	1a f0       	brmi	.+6      	; 0xe08 <__fixunssfsi+0x24>
     e02:	ba 95       	dec	r27
     e04:	c9 f7       	brne	.-14     	; 0xdf8 <__fixunssfsi+0x14>
     e06:	14 c0       	rjmp	.+40     	; 0xe30 <__fixunssfsi+0x4c>
     e08:	b1 30       	cpi	r27, 0x01	; 1
     e0a:	91 f0       	breq	.+36     	; 0xe30 <__fixunssfsi+0x4c>
     e0c:	0e 94 f3 07 	call	0xfe6	; 0xfe6 <__fp_zero>
     e10:	b1 e0       	ldi	r27, 0x01	; 1
     e12:	08 95       	ret
     e14:	0c 94 f3 07 	jmp	0xfe6	; 0xfe6 <__fp_zero>
     e18:	67 2f       	mov	r22, r23
     e1a:	78 2f       	mov	r23, r24
     e1c:	88 27       	eor	r24, r24
     e1e:	b8 5f       	subi	r27, 0xF8	; 248
     e20:	39 f0       	breq	.+14     	; 0xe30 <__fixunssfsi+0x4c>
     e22:	b9 3f       	cpi	r27, 0xF9	; 249
     e24:	cc f3       	brlt	.-14     	; 0xe18 <__fixunssfsi+0x34>
     e26:	86 95       	lsr	r24
     e28:	77 95       	ror	r23
     e2a:	67 95       	ror	r22
     e2c:	b3 95       	inc	r27
     e2e:	d9 f7       	brne	.-10     	; 0xe26 <__fixunssfsi+0x42>
     e30:	3e f4       	brtc	.+14     	; 0xe40 <__fixunssfsi+0x5c>
     e32:	90 95       	com	r25
     e34:	80 95       	com	r24
     e36:	70 95       	com	r23
     e38:	61 95       	neg	r22
     e3a:	7f 4f       	sbci	r23, 0xFF	; 255
     e3c:	8f 4f       	sbci	r24, 0xFF	; 255
     e3e:	9f 4f       	sbci	r25, 0xFF	; 255
     e40:	08 95       	ret

00000e42 <__floatunsisf>:
     e42:	e8 94       	clt
     e44:	09 c0       	rjmp	.+18     	; 0xe58 <__floatsisf+0x12>

00000e46 <__floatsisf>:
     e46:	97 fb       	bst	r25, 7
     e48:	3e f4       	brtc	.+14     	; 0xe58 <__floatsisf+0x12>
     e4a:	90 95       	com	r25
     e4c:	80 95       	com	r24
     e4e:	70 95       	com	r23
     e50:	61 95       	neg	r22
     e52:	7f 4f       	sbci	r23, 0xFF	; 255
     e54:	8f 4f       	sbci	r24, 0xFF	; 255
     e56:	9f 4f       	sbci	r25, 0xFF	; 255
     e58:	99 23       	and	r25, r25
     e5a:	a9 f0       	breq	.+42     	; 0xe86 <__floatsisf+0x40>
     e5c:	f9 2f       	mov	r31, r25
     e5e:	96 e9       	ldi	r25, 0x96	; 150
     e60:	bb 27       	eor	r27, r27
     e62:	93 95       	inc	r25
     e64:	f6 95       	lsr	r31
     e66:	87 95       	ror	r24
     e68:	77 95       	ror	r23
     e6a:	67 95       	ror	r22
     e6c:	b7 95       	ror	r27
     e6e:	f1 11       	cpse	r31, r1
     e70:	f8 cf       	rjmp	.-16     	; 0xe62 <__floatsisf+0x1c>
     e72:	fa f4       	brpl	.+62     	; 0xeb2 <__floatsisf+0x6c>
     e74:	bb 0f       	add	r27, r27
     e76:	11 f4       	brne	.+4      	; 0xe7c <__floatsisf+0x36>
     e78:	60 ff       	sbrs	r22, 0
     e7a:	1b c0       	rjmp	.+54     	; 0xeb2 <__floatsisf+0x6c>
     e7c:	6f 5f       	subi	r22, 0xFF	; 255
     e7e:	7f 4f       	sbci	r23, 0xFF	; 255
     e80:	8f 4f       	sbci	r24, 0xFF	; 255
     e82:	9f 4f       	sbci	r25, 0xFF	; 255
     e84:	16 c0       	rjmp	.+44     	; 0xeb2 <__floatsisf+0x6c>
     e86:	88 23       	and	r24, r24
     e88:	11 f0       	breq	.+4      	; 0xe8e <__floatsisf+0x48>
     e8a:	96 e9       	ldi	r25, 0x96	; 150
     e8c:	11 c0       	rjmp	.+34     	; 0xeb0 <__floatsisf+0x6a>
     e8e:	77 23       	and	r23, r23
     e90:	21 f0       	breq	.+8      	; 0xe9a <__floatsisf+0x54>
     e92:	9e e8       	ldi	r25, 0x8E	; 142
     e94:	87 2f       	mov	r24, r23
     e96:	76 2f       	mov	r23, r22
     e98:	05 c0       	rjmp	.+10     	; 0xea4 <__floatsisf+0x5e>
     e9a:	66 23       	and	r22, r22
     e9c:	71 f0       	breq	.+28     	; 0xeba <__floatsisf+0x74>
     e9e:	96 e8       	ldi	r25, 0x86	; 134
     ea0:	86 2f       	mov	r24, r22
     ea2:	70 e0       	ldi	r23, 0x00	; 0
     ea4:	60 e0       	ldi	r22, 0x00	; 0
     ea6:	2a f0       	brmi	.+10     	; 0xeb2 <__floatsisf+0x6c>
     ea8:	9a 95       	dec	r25
     eaa:	66 0f       	add	r22, r22
     eac:	77 1f       	adc	r23, r23
     eae:	88 1f       	adc	r24, r24
     eb0:	da f7       	brpl	.-10     	; 0xea8 <__floatsisf+0x62>
     eb2:	88 0f       	add	r24, r24
     eb4:	96 95       	lsr	r25
     eb6:	87 95       	ror	r24
     eb8:	97 f9       	bld	r25, 7
     eba:	08 95       	ret

00000ebc <__fp_cmp>:
     ebc:	99 0f       	add	r25, r25
     ebe:	00 08       	sbc	r0, r0
     ec0:	55 0f       	add	r21, r21
     ec2:	aa 0b       	sbc	r26, r26
     ec4:	e0 e8       	ldi	r30, 0x80	; 128
     ec6:	fe ef       	ldi	r31, 0xFE	; 254
     ec8:	16 16       	cp	r1, r22
     eca:	17 06       	cpc	r1, r23
     ecc:	e8 07       	cpc	r30, r24
     ece:	f9 07       	cpc	r31, r25
     ed0:	c0 f0       	brcs	.+48     	; 0xf02 <__fp_cmp+0x46>
     ed2:	12 16       	cp	r1, r18
     ed4:	13 06       	cpc	r1, r19
     ed6:	e4 07       	cpc	r30, r20
     ed8:	f5 07       	cpc	r31, r21
     eda:	98 f0       	brcs	.+38     	; 0xf02 <__fp_cmp+0x46>
     edc:	62 1b       	sub	r22, r18
     ede:	73 0b       	sbc	r23, r19
     ee0:	84 0b       	sbc	r24, r20
     ee2:	95 0b       	sbc	r25, r21
     ee4:	39 f4       	brne	.+14     	; 0xef4 <__fp_cmp+0x38>
     ee6:	0a 26       	eor	r0, r26
     ee8:	61 f0       	breq	.+24     	; 0xf02 <__fp_cmp+0x46>
     eea:	23 2b       	or	r18, r19
     eec:	24 2b       	or	r18, r20
     eee:	25 2b       	or	r18, r21
     ef0:	21 f4       	brne	.+8      	; 0xefa <__fp_cmp+0x3e>
     ef2:	08 95       	ret
     ef4:	0a 26       	eor	r0, r26
     ef6:	09 f4       	brne	.+2      	; 0xefa <__fp_cmp+0x3e>
     ef8:	a1 40       	sbci	r26, 0x01	; 1
     efa:	a6 95       	lsr	r26
     efc:	8f ef       	ldi	r24, 0xFF	; 255
     efe:	81 1d       	adc	r24, r1
     f00:	81 1d       	adc	r24, r1
     f02:	08 95       	ret

00000f04 <__fp_inf>:
     f04:	97 f9       	bld	r25, 7
     f06:	9f 67       	ori	r25, 0x7F	; 127
     f08:	80 e8       	ldi	r24, 0x80	; 128
     f0a:	70 e0       	ldi	r23, 0x00	; 0
     f0c:	60 e0       	ldi	r22, 0x00	; 0
     f0e:	08 95       	ret

00000f10 <__fp_nan>:
     f10:	9f ef       	ldi	r25, 0xFF	; 255
     f12:	80 ec       	ldi	r24, 0xC0	; 192
     f14:	08 95       	ret

00000f16 <__fp_powser>:
     f16:	df 93       	push	r29
     f18:	cf 93       	push	r28
     f1a:	1f 93       	push	r17
     f1c:	0f 93       	push	r16
     f1e:	ff 92       	push	r15
     f20:	ef 92       	push	r14
     f22:	df 92       	push	r13
     f24:	7b 01       	movw	r14, r22
     f26:	8c 01       	movw	r16, r24
     f28:	68 94       	set
     f2a:	06 c0       	rjmp	.+12     	; 0xf38 <__fp_powser+0x22>
     f2c:	da 2e       	mov	r13, r26
     f2e:	ef 01       	movw	r28, r30
     f30:	0e 94 88 08 	call	0x1110	; 0x1110 <__mulsf3x>
     f34:	fe 01       	movw	r30, r28
     f36:	e8 94       	clt
     f38:	a5 91       	lpm	r26, Z+
     f3a:	25 91       	lpm	r18, Z+
     f3c:	35 91       	lpm	r19, Z+
     f3e:	45 91       	lpm	r20, Z+
     f40:	55 91       	lpm	r21, Z+
     f42:	a6 f3       	brts	.-24     	; 0xf2c <__fp_powser+0x16>
     f44:	ef 01       	movw	r28, r30
     f46:	0e 94 e5 05 	call	0xbca	; 0xbca <__addsf3x>
     f4a:	fe 01       	movw	r30, r28
     f4c:	97 01       	movw	r18, r14
     f4e:	a8 01       	movw	r20, r16
     f50:	da 94       	dec	r13
     f52:	69 f7       	brne	.-38     	; 0xf2e <__fp_powser+0x18>
     f54:	df 90       	pop	r13
     f56:	ef 90       	pop	r14
     f58:	ff 90       	pop	r15
     f5a:	0f 91       	pop	r16
     f5c:	1f 91       	pop	r17
     f5e:	cf 91       	pop	r28
     f60:	df 91       	pop	r29
     f62:	08 95       	ret

00000f64 <__fp_pscA>:
     f64:	00 24       	eor	r0, r0
     f66:	0a 94       	dec	r0
     f68:	16 16       	cp	r1, r22
     f6a:	17 06       	cpc	r1, r23
     f6c:	18 06       	cpc	r1, r24
     f6e:	09 06       	cpc	r0, r25
     f70:	08 95       	ret

00000f72 <__fp_pscB>:
     f72:	00 24       	eor	r0, r0
     f74:	0a 94       	dec	r0
     f76:	12 16       	cp	r1, r18
     f78:	13 06       	cpc	r1, r19
     f7a:	14 06       	cpc	r1, r20
     f7c:	05 06       	cpc	r0, r21
     f7e:	08 95       	ret

00000f80 <__fp_round>:
     f80:	09 2e       	mov	r0, r25
     f82:	03 94       	inc	r0
     f84:	00 0c       	add	r0, r0
     f86:	11 f4       	brne	.+4      	; 0xf8c <__fp_round+0xc>
     f88:	88 23       	and	r24, r24
     f8a:	52 f0       	brmi	.+20     	; 0xfa0 <__fp_round+0x20>
     f8c:	bb 0f       	add	r27, r27
     f8e:	40 f4       	brcc	.+16     	; 0xfa0 <__fp_round+0x20>
     f90:	bf 2b       	or	r27, r31
     f92:	11 f4       	brne	.+4      	; 0xf98 <__fp_round+0x18>
     f94:	60 ff       	sbrs	r22, 0
     f96:	04 c0       	rjmp	.+8      	; 0xfa0 <__fp_round+0x20>
     f98:	6f 5f       	subi	r22, 0xFF	; 255
     f9a:	7f 4f       	sbci	r23, 0xFF	; 255
     f9c:	8f 4f       	sbci	r24, 0xFF	; 255
     f9e:	9f 4f       	sbci	r25, 0xFF	; 255
     fa0:	08 95       	ret

00000fa2 <__fp_split3>:
     fa2:	57 fd       	sbrc	r21, 7
     fa4:	90 58       	subi	r25, 0x80	; 128
     fa6:	44 0f       	add	r20, r20
     fa8:	55 1f       	adc	r21, r21
     faa:	59 f0       	breq	.+22     	; 0xfc2 <__fp_splitA+0x10>
     fac:	5f 3f       	cpi	r21, 0xFF	; 255
     fae:	71 f0       	breq	.+28     	; 0xfcc <__fp_splitA+0x1a>
     fb0:	47 95       	ror	r20

00000fb2 <__fp_splitA>:
     fb2:	88 0f       	add	r24, r24
     fb4:	97 fb       	bst	r25, 7
     fb6:	99 1f       	adc	r25, r25
     fb8:	61 f0       	breq	.+24     	; 0xfd2 <__fp_splitA+0x20>
     fba:	9f 3f       	cpi	r25, 0xFF	; 255
     fbc:	79 f0       	breq	.+30     	; 0xfdc <__fp_splitA+0x2a>
     fbe:	87 95       	ror	r24
     fc0:	08 95       	ret
     fc2:	12 16       	cp	r1, r18
     fc4:	13 06       	cpc	r1, r19
     fc6:	14 06       	cpc	r1, r20
     fc8:	55 1f       	adc	r21, r21
     fca:	f2 cf       	rjmp	.-28     	; 0xfb0 <__fp_split3+0xe>
     fcc:	46 95       	lsr	r20
     fce:	f1 df       	rcall	.-30     	; 0xfb2 <__fp_splitA>
     fd0:	08 c0       	rjmp	.+16     	; 0xfe2 <__fp_splitA+0x30>
     fd2:	16 16       	cp	r1, r22
     fd4:	17 06       	cpc	r1, r23
     fd6:	18 06       	cpc	r1, r24
     fd8:	99 1f       	adc	r25, r25
     fda:	f1 cf       	rjmp	.-30     	; 0xfbe <__fp_splitA+0xc>
     fdc:	86 95       	lsr	r24
     fde:	71 05       	cpc	r23, r1
     fe0:	61 05       	cpc	r22, r1
     fe2:	08 94       	sec
     fe4:	08 95       	ret

00000fe6 <__fp_zero>:
     fe6:	e8 94       	clt

00000fe8 <__fp_szero>:
     fe8:	bb 27       	eor	r27, r27
     fea:	66 27       	eor	r22, r22
     fec:	77 27       	eor	r23, r23
     fee:	cb 01       	movw	r24, r22
     ff0:	97 f9       	bld	r25, 7
     ff2:	08 95       	ret

00000ff4 <__gesf2>:
     ff4:	0e 94 5e 07 	call	0xebc	; 0xebc <__fp_cmp>
     ff8:	08 f4       	brcc	.+2      	; 0xffc <__gesf2+0x8>
     ffa:	8f ef       	ldi	r24, 0xFF	; 255
     ffc:	08 95       	ret

00000ffe <inverse>:
     ffe:	9b 01       	movw	r18, r22
    1000:	ac 01       	movw	r20, r24
    1002:	60 e0       	ldi	r22, 0x00	; 0
    1004:	70 e0       	ldi	r23, 0x00	; 0
    1006:	80 e8       	ldi	r24, 0x80	; 128
    1008:	9f e3       	ldi	r25, 0x3F	; 63
    100a:	0c 94 3f 06 	jmp	0xc7e	; 0xc7e <__divsf3>
    100e:	0c 94 82 07 	jmp	0xf04	; 0xf04 <__fp_inf>
    1012:	0c 94 21 09 	jmp	0x1242	; 0x1242 <__fp_mpack>

00001016 <ldexp>:
    1016:	0e 94 d9 07 	call	0xfb2	; 0xfb2 <__fp_splitA>
    101a:	d8 f3       	brcs	.-10     	; 0x1012 <inverse+0x14>
    101c:	99 23       	and	r25, r25
    101e:	c9 f3       	breq	.-14     	; 0x1012 <inverse+0x14>
    1020:	94 0f       	add	r25, r20
    1022:	51 1d       	adc	r21, r1
    1024:	a3 f3       	brvs	.-24     	; 0x100e <inverse+0x10>
    1026:	91 50       	subi	r25, 0x01	; 1
    1028:	50 40       	sbci	r21, 0x00	; 0
    102a:	94 f0       	brlt	.+36     	; 0x1050 <ldexp+0x3a>
    102c:	59 f0       	breq	.+22     	; 0x1044 <ldexp+0x2e>
    102e:	88 23       	and	r24, r24
    1030:	32 f0       	brmi	.+12     	; 0x103e <ldexp+0x28>
    1032:	66 0f       	add	r22, r22
    1034:	77 1f       	adc	r23, r23
    1036:	88 1f       	adc	r24, r24
    1038:	91 50       	subi	r25, 0x01	; 1
    103a:	50 40       	sbci	r21, 0x00	; 0
    103c:	c1 f7       	brne	.-16     	; 0x102e <ldexp+0x18>
    103e:	9e 3f       	cpi	r25, 0xFE	; 254
    1040:	51 05       	cpc	r21, r1
    1042:	2c f7       	brge	.-54     	; 0x100e <inverse+0x10>
    1044:	88 0f       	add	r24, r24
    1046:	91 1d       	adc	r25, r1
    1048:	96 95       	lsr	r25
    104a:	87 95       	ror	r24
    104c:	97 f9       	bld	r25, 7
    104e:	08 95       	ret
    1050:	5f 3f       	cpi	r21, 0xFF	; 255
    1052:	ac f0       	brlt	.+42     	; 0x107e <ldexp+0x68>
    1054:	98 3e       	cpi	r25, 0xE8	; 232
    1056:	9c f0       	brlt	.+38     	; 0x107e <ldexp+0x68>
    1058:	bb 27       	eor	r27, r27
    105a:	86 95       	lsr	r24
    105c:	77 95       	ror	r23
    105e:	67 95       	ror	r22
    1060:	b7 95       	ror	r27
    1062:	08 f4       	brcc	.+2      	; 0x1066 <ldexp+0x50>
    1064:	b1 60       	ori	r27, 0x01	; 1
    1066:	93 95       	inc	r25
    1068:	c1 f7       	brne	.-16     	; 0x105a <ldexp+0x44>
    106a:	bb 0f       	add	r27, r27
    106c:	58 f7       	brcc	.-42     	; 0x1044 <ldexp+0x2e>
    106e:	11 f4       	brne	.+4      	; 0x1074 <ldexp+0x5e>
    1070:	60 ff       	sbrs	r22, 0
    1072:	e8 cf       	rjmp	.-48     	; 0x1044 <ldexp+0x2e>
    1074:	6f 5f       	subi	r22, 0xFF	; 255
    1076:	7f 4f       	sbci	r23, 0xFF	; 255
    1078:	8f 4f       	sbci	r24, 0xFF	; 255
    107a:	9f 4f       	sbci	r25, 0xFF	; 255
    107c:	e3 cf       	rjmp	.-58     	; 0x1044 <ldexp+0x2e>
    107e:	0c 94 f4 07 	jmp	0xfe8	; 0xfe8 <__fp_szero>

00001082 <modf>:
    1082:	fa 01       	movw	r30, r20
    1084:	dc 01       	movw	r26, r24
    1086:	aa 0f       	add	r26, r26
    1088:	bb 1f       	adc	r27, r27
    108a:	9b 01       	movw	r18, r22
    108c:	ac 01       	movw	r20, r24
    108e:	bf 57       	subi	r27, 0x7F	; 127
    1090:	28 f4       	brcc	.+10     	; 0x109c <modf+0x1a>
    1092:	22 27       	eor	r18, r18
    1094:	33 27       	eor	r19, r19
    1096:	44 27       	eor	r20, r20
    1098:	50 78       	andi	r21, 0x80	; 128
    109a:	20 c0       	rjmp	.+64     	; 0x10dc <modf+0x5a>
    109c:	b7 51       	subi	r27, 0x17	; 23
    109e:	90 f4       	brcc	.+36     	; 0x10c4 <modf+0x42>
    10a0:	ab 2f       	mov	r26, r27
    10a2:	00 24       	eor	r0, r0
    10a4:	46 95       	lsr	r20
    10a6:	37 95       	ror	r19
    10a8:	27 95       	ror	r18
    10aa:	01 1c       	adc	r0, r1
    10ac:	a3 95       	inc	r26
    10ae:	d2 f3       	brmi	.-12     	; 0x10a4 <modf+0x22>
    10b0:	00 20       	and	r0, r0
    10b2:	71 f0       	breq	.+28     	; 0x10d0 <modf+0x4e>
    10b4:	22 0f       	add	r18, r18
    10b6:	33 1f       	adc	r19, r19
    10b8:	44 1f       	adc	r20, r20
    10ba:	b3 95       	inc	r27
    10bc:	da f3       	brmi	.-10     	; 0x10b4 <modf+0x32>
    10be:	0e d0       	rcall	.+28     	; 0x10dc <modf+0x5a>
    10c0:	0c 94 cd 05 	jmp	0xb9a	; 0xb9a <__subsf3>
    10c4:	61 30       	cpi	r22, 0x01	; 1
    10c6:	71 05       	cpc	r23, r1
    10c8:	a0 e8       	ldi	r26, 0x80	; 128
    10ca:	8a 07       	cpc	r24, r26
    10cc:	b9 46       	sbci	r27, 0x69	; 105
    10ce:	30 f4       	brcc	.+12     	; 0x10dc <modf+0x5a>
    10d0:	9b 01       	movw	r18, r22
    10d2:	ac 01       	movw	r20, r24
    10d4:	66 27       	eor	r22, r22
    10d6:	77 27       	eor	r23, r23
    10d8:	88 27       	eor	r24, r24
    10da:	90 78       	andi	r25, 0x80	; 128
    10dc:	30 96       	adiw	r30, 0x00	; 0
    10de:	21 f0       	breq	.+8      	; 0x10e8 <modf+0x66>
    10e0:	20 83       	st	Z, r18
    10e2:	31 83       	std	Z+1, r19	; 0x01
    10e4:	42 83       	std	Z+2, r20	; 0x02
    10e6:	53 83       	std	Z+3, r21	; 0x03
    10e8:	08 95       	ret

000010ea <__mulsf3>:
    10ea:	0e 94 88 08 	call	0x1110	; 0x1110 <__mulsf3x>
    10ee:	0c 94 c0 07 	jmp	0xf80	; 0xf80 <__fp_round>
    10f2:	0e 94 b2 07 	call	0xf64	; 0xf64 <__fp_pscA>
    10f6:	38 f0       	brcs	.+14     	; 0x1106 <__mulsf3+0x1c>
    10f8:	0e 94 b9 07 	call	0xf72	; 0xf72 <__fp_pscB>
    10fc:	20 f0       	brcs	.+8      	; 0x1106 <__mulsf3+0x1c>
    10fe:	95 23       	and	r25, r21
    1100:	11 f0       	breq	.+4      	; 0x1106 <__mulsf3+0x1c>
    1102:	0c 94 82 07 	jmp	0xf04	; 0xf04 <__fp_inf>
    1106:	0c 94 88 07 	jmp	0xf10	; 0xf10 <__fp_nan>
    110a:	11 24       	eor	r1, r1
    110c:	0c 94 f4 07 	jmp	0xfe8	; 0xfe8 <__fp_szero>

00001110 <__mulsf3x>:
    1110:	0e 94 d1 07 	call	0xfa2	; 0xfa2 <__fp_split3>
    1114:	70 f3       	brcs	.-36     	; 0x10f2 <__mulsf3+0x8>

00001116 <__mulsf3_pse>:
    1116:	95 9f       	mul	r25, r21
    1118:	c1 f3       	breq	.-16     	; 0x110a <__mulsf3+0x20>
    111a:	95 0f       	add	r25, r21
    111c:	50 e0       	ldi	r21, 0x00	; 0
    111e:	55 1f       	adc	r21, r21
    1120:	62 9f       	mul	r22, r18
    1122:	f0 01       	movw	r30, r0
    1124:	72 9f       	mul	r23, r18
    1126:	bb 27       	eor	r27, r27
    1128:	f0 0d       	add	r31, r0
    112a:	b1 1d       	adc	r27, r1
    112c:	63 9f       	mul	r22, r19
    112e:	aa 27       	eor	r26, r26
    1130:	f0 0d       	add	r31, r0
    1132:	b1 1d       	adc	r27, r1
    1134:	aa 1f       	adc	r26, r26
    1136:	64 9f       	mul	r22, r20
    1138:	66 27       	eor	r22, r22
    113a:	b0 0d       	add	r27, r0
    113c:	a1 1d       	adc	r26, r1
    113e:	66 1f       	adc	r22, r22
    1140:	82 9f       	mul	r24, r18
    1142:	22 27       	eor	r18, r18
    1144:	b0 0d       	add	r27, r0
    1146:	a1 1d       	adc	r26, r1
    1148:	62 1f       	adc	r22, r18
    114a:	73 9f       	mul	r23, r19
    114c:	b0 0d       	add	r27, r0
    114e:	a1 1d       	adc	r26, r1
    1150:	62 1f       	adc	r22, r18
    1152:	83 9f       	mul	r24, r19
    1154:	a0 0d       	add	r26, r0
    1156:	61 1d       	adc	r22, r1
    1158:	22 1f       	adc	r18, r18
    115a:	74 9f       	mul	r23, r20
    115c:	33 27       	eor	r19, r19
    115e:	a0 0d       	add	r26, r0
    1160:	61 1d       	adc	r22, r1
    1162:	23 1f       	adc	r18, r19
    1164:	84 9f       	mul	r24, r20
    1166:	60 0d       	add	r22, r0
    1168:	21 1d       	adc	r18, r1
    116a:	82 2f       	mov	r24, r18
    116c:	76 2f       	mov	r23, r22
    116e:	6a 2f       	mov	r22, r26
    1170:	11 24       	eor	r1, r1
    1172:	9f 57       	subi	r25, 0x7F	; 127
    1174:	50 40       	sbci	r21, 0x00	; 0
    1176:	9a f0       	brmi	.+38     	; 0x119e <__mulsf3_pse+0x88>
    1178:	f1 f0       	breq	.+60     	; 0x11b6 <__mulsf3_pse+0xa0>
    117a:	88 23       	and	r24, r24
    117c:	4a f0       	brmi	.+18     	; 0x1190 <__mulsf3_pse+0x7a>
    117e:	ee 0f       	add	r30, r30
    1180:	ff 1f       	adc	r31, r31
    1182:	bb 1f       	adc	r27, r27
    1184:	66 1f       	adc	r22, r22
    1186:	77 1f       	adc	r23, r23
    1188:	88 1f       	adc	r24, r24
    118a:	91 50       	subi	r25, 0x01	; 1
    118c:	50 40       	sbci	r21, 0x00	; 0
    118e:	a9 f7       	brne	.-22     	; 0x117a <__mulsf3_pse+0x64>
    1190:	9e 3f       	cpi	r25, 0xFE	; 254
    1192:	51 05       	cpc	r21, r1
    1194:	80 f0       	brcs	.+32     	; 0x11b6 <__mulsf3_pse+0xa0>
    1196:	0c 94 82 07 	jmp	0xf04	; 0xf04 <__fp_inf>
    119a:	0c 94 f4 07 	jmp	0xfe8	; 0xfe8 <__fp_szero>
    119e:	5f 3f       	cpi	r21, 0xFF	; 255
    11a0:	e4 f3       	brlt	.-8      	; 0x119a <__mulsf3_pse+0x84>
    11a2:	98 3e       	cpi	r25, 0xE8	; 232
    11a4:	d4 f3       	brlt	.-12     	; 0x119a <__mulsf3_pse+0x84>
    11a6:	86 95       	lsr	r24
    11a8:	77 95       	ror	r23
    11aa:	67 95       	ror	r22
    11ac:	b7 95       	ror	r27
    11ae:	f7 95       	ror	r31
    11b0:	e7 95       	ror	r30
    11b2:	9f 5f       	subi	r25, 0xFF	; 255
    11b4:	c1 f7       	brne	.-16     	; 0x11a6 <__mulsf3_pse+0x90>
    11b6:	fe 2b       	or	r31, r30
    11b8:	88 0f       	add	r24, r24
    11ba:	91 1d       	adc	r25, r1
    11bc:	96 95       	lsr	r25
    11be:	87 95       	ror	r24
    11c0:	97 f9       	bld	r25, 7
    11c2:	08 95       	ret

000011c4 <round>:
    11c4:	0e 94 d9 07 	call	0xfb2	; 0xfb2 <__fp_splitA>
    11c8:	e8 f0       	brcs	.+58     	; 0x1204 <round+0x40>
    11ca:	9e 37       	cpi	r25, 0x7E	; 126
    11cc:	e8 f0       	brcs	.+58     	; 0x1208 <round+0x44>
    11ce:	96 39       	cpi	r25, 0x96	; 150
    11d0:	b8 f4       	brcc	.+46     	; 0x1200 <round+0x3c>
    11d2:	9e 38       	cpi	r25, 0x8E	; 142
    11d4:	48 f4       	brcc	.+18     	; 0x11e8 <round+0x24>
    11d6:	67 2f       	mov	r22, r23
    11d8:	78 2f       	mov	r23, r24
    11da:	88 27       	eor	r24, r24
    11dc:	98 5f       	subi	r25, 0xF8	; 248
    11de:	f9 cf       	rjmp	.-14     	; 0x11d2 <round+0xe>
    11e0:	86 95       	lsr	r24
    11e2:	77 95       	ror	r23
    11e4:	67 95       	ror	r22
    11e6:	93 95       	inc	r25
    11e8:	95 39       	cpi	r25, 0x95	; 149
    11ea:	d0 f3       	brcs	.-12     	; 0x11e0 <round+0x1c>
    11ec:	b6 2f       	mov	r27, r22
    11ee:	b1 70       	andi	r27, 0x01	; 1
    11f0:	6b 0f       	add	r22, r27
    11f2:	71 1d       	adc	r23, r1
    11f4:	81 1d       	adc	r24, r1
    11f6:	20 f4       	brcc	.+8      	; 0x1200 <round+0x3c>
    11f8:	87 95       	ror	r24
    11fa:	77 95       	ror	r23
    11fc:	67 95       	ror	r22
    11fe:	93 95       	inc	r25
    1200:	0c 94 06 09 	jmp	0x120c	; 0x120c <__fp_mintl>
    1204:	0c 94 21 09 	jmp	0x1242	; 0x1242 <__fp_mpack>
    1208:	0c 94 f4 07 	jmp	0xfe8	; 0xfe8 <__fp_szero>

0000120c <__fp_mintl>:
    120c:	88 23       	and	r24, r24
    120e:	71 f4       	brne	.+28     	; 0x122c <__fp_mintl+0x20>
    1210:	77 23       	and	r23, r23
    1212:	21 f0       	breq	.+8      	; 0x121c <__fp_mintl+0x10>
    1214:	98 50       	subi	r25, 0x08	; 8
    1216:	87 2b       	or	r24, r23
    1218:	76 2f       	mov	r23, r22
    121a:	07 c0       	rjmp	.+14     	; 0x122a <__fp_mintl+0x1e>
    121c:	66 23       	and	r22, r22
    121e:	11 f4       	brne	.+4      	; 0x1224 <__fp_mintl+0x18>
    1220:	99 27       	eor	r25, r25
    1222:	0d c0       	rjmp	.+26     	; 0x123e <__fp_mintl+0x32>
    1224:	90 51       	subi	r25, 0x10	; 16
    1226:	86 2b       	or	r24, r22
    1228:	70 e0       	ldi	r23, 0x00	; 0
    122a:	60 e0       	ldi	r22, 0x00	; 0
    122c:	2a f0       	brmi	.+10     	; 0x1238 <__fp_mintl+0x2c>
    122e:	9a 95       	dec	r25
    1230:	66 0f       	add	r22, r22
    1232:	77 1f       	adc	r23, r23
    1234:	88 1f       	adc	r24, r24
    1236:	da f7       	brpl	.-10     	; 0x122e <__fp_mintl+0x22>
    1238:	88 0f       	add	r24, r24
    123a:	96 95       	lsr	r25
    123c:	87 95       	ror	r24
    123e:	97 f9       	bld	r25, 7
    1240:	08 95       	ret

00001242 <__fp_mpack>:
    1242:	9f 3f       	cpi	r25, 0xFF	; 255
    1244:	31 f0       	breq	.+12     	; 0x1252 <__fp_mpack_finite+0xc>

00001246 <__fp_mpack_finite>:
    1246:	91 50       	subi	r25, 0x01	; 1
    1248:	20 f4       	brcc	.+8      	; 0x1252 <__fp_mpack_finite+0xc>
    124a:	87 95       	ror	r24
    124c:	77 95       	ror	r23
    124e:	67 95       	ror	r22
    1250:	b7 95       	ror	r27
    1252:	88 0f       	add	r24, r24
    1254:	91 1d       	adc	r25, r1
    1256:	96 95       	lsr	r25
    1258:	87 95       	ror	r24
    125a:	97 f9       	bld	r25, 7
    125c:	08 95       	ret

0000125e <malloc>:
    125e:	0f 93       	push	r16
    1260:	1f 93       	push	r17
    1262:	cf 93       	push	r28
    1264:	df 93       	push	r29
    1266:	82 30       	cpi	r24, 0x02	; 2
    1268:	91 05       	cpc	r25, r1
    126a:	10 f4       	brcc	.+4      	; 0x1270 <malloc+0x12>
    126c:	82 e0       	ldi	r24, 0x02	; 2
    126e:	90 e0       	ldi	r25, 0x00	; 0
    1270:	e0 91 5b 3e 	lds	r30, 0x3E5B	; 0x803e5b <__flp>
    1274:	f0 91 5c 3e 	lds	r31, 0x3E5C	; 0x803e5c <__flp+0x1>
    1278:	20 e0       	ldi	r18, 0x00	; 0
    127a:	30 e0       	ldi	r19, 0x00	; 0
    127c:	a0 e0       	ldi	r26, 0x00	; 0
    127e:	b0 e0       	ldi	r27, 0x00	; 0
    1280:	30 97       	sbiw	r30, 0x00	; 0
    1282:	19 f1       	breq	.+70     	; 0x12ca <malloc+0x6c>
    1284:	40 81       	ld	r20, Z
    1286:	51 81       	ldd	r21, Z+1	; 0x01
    1288:	02 81       	ldd	r16, Z+2	; 0x02
    128a:	13 81       	ldd	r17, Z+3	; 0x03
    128c:	48 17       	cp	r20, r24
    128e:	59 07       	cpc	r21, r25
    1290:	c8 f0       	brcs	.+50     	; 0x12c4 <malloc+0x66>
    1292:	84 17       	cp	r24, r20
    1294:	95 07       	cpc	r25, r21
    1296:	69 f4       	brne	.+26     	; 0x12b2 <malloc+0x54>
    1298:	10 97       	sbiw	r26, 0x00	; 0
    129a:	31 f0       	breq	.+12     	; 0x12a8 <malloc+0x4a>
    129c:	12 96       	adiw	r26, 0x02	; 2
    129e:	0c 93       	st	X, r16
    12a0:	12 97       	sbiw	r26, 0x02	; 2
    12a2:	13 96       	adiw	r26, 0x03	; 3
    12a4:	1c 93       	st	X, r17
    12a6:	27 c0       	rjmp	.+78     	; 0x12f6 <malloc+0x98>
    12a8:	00 93 5b 3e 	sts	0x3E5B, r16	; 0x803e5b <__flp>
    12ac:	10 93 5c 3e 	sts	0x3E5C, r17	; 0x803e5c <__flp+0x1>
    12b0:	22 c0       	rjmp	.+68     	; 0x12f6 <malloc+0x98>
    12b2:	21 15       	cp	r18, r1
    12b4:	31 05       	cpc	r19, r1
    12b6:	19 f0       	breq	.+6      	; 0x12be <malloc+0x60>
    12b8:	42 17       	cp	r20, r18
    12ba:	53 07       	cpc	r21, r19
    12bc:	18 f4       	brcc	.+6      	; 0x12c4 <malloc+0x66>
    12be:	9a 01       	movw	r18, r20
    12c0:	bd 01       	movw	r22, r26
    12c2:	ef 01       	movw	r28, r30
    12c4:	df 01       	movw	r26, r30
    12c6:	f8 01       	movw	r30, r16
    12c8:	db cf       	rjmp	.-74     	; 0x1280 <malloc+0x22>
    12ca:	21 15       	cp	r18, r1
    12cc:	31 05       	cpc	r19, r1
    12ce:	f9 f0       	breq	.+62     	; 0x130e <malloc+0xb0>
    12d0:	28 1b       	sub	r18, r24
    12d2:	39 0b       	sbc	r19, r25
    12d4:	24 30       	cpi	r18, 0x04	; 4
    12d6:	31 05       	cpc	r19, r1
    12d8:	80 f4       	brcc	.+32     	; 0x12fa <malloc+0x9c>
    12da:	8a 81       	ldd	r24, Y+2	; 0x02
    12dc:	9b 81       	ldd	r25, Y+3	; 0x03
    12de:	61 15       	cp	r22, r1
    12e0:	71 05       	cpc	r23, r1
    12e2:	21 f0       	breq	.+8      	; 0x12ec <malloc+0x8e>
    12e4:	fb 01       	movw	r30, r22
    12e6:	82 83       	std	Z+2, r24	; 0x02
    12e8:	93 83       	std	Z+3, r25	; 0x03
    12ea:	04 c0       	rjmp	.+8      	; 0x12f4 <malloc+0x96>
    12ec:	80 93 5b 3e 	sts	0x3E5B, r24	; 0x803e5b <__flp>
    12f0:	90 93 5c 3e 	sts	0x3E5C, r25	; 0x803e5c <__flp+0x1>
    12f4:	fe 01       	movw	r30, r28
    12f6:	32 96       	adiw	r30, 0x02	; 2
    12f8:	44 c0       	rjmp	.+136    	; 0x1382 <malloc+0x124>
    12fa:	fe 01       	movw	r30, r28
    12fc:	e2 0f       	add	r30, r18
    12fe:	f3 1f       	adc	r31, r19
    1300:	81 93       	st	Z+, r24
    1302:	91 93       	st	Z+, r25
    1304:	22 50       	subi	r18, 0x02	; 2
    1306:	31 09       	sbc	r19, r1
    1308:	28 83       	st	Y, r18
    130a:	39 83       	std	Y+1, r19	; 0x01
    130c:	3a c0       	rjmp	.+116    	; 0x1382 <malloc+0x124>
    130e:	20 91 59 3e 	lds	r18, 0x3E59	; 0x803e59 <__brkval>
    1312:	30 91 5a 3e 	lds	r19, 0x3E5A	; 0x803e5a <__brkval+0x1>
    1316:	23 2b       	or	r18, r19
    1318:	41 f4       	brne	.+16     	; 0x132a <malloc+0xcc>
    131a:	20 91 02 3e 	lds	r18, 0x3E02	; 0x803e02 <__malloc_heap_start>
    131e:	30 91 03 3e 	lds	r19, 0x3E03	; 0x803e03 <__malloc_heap_start+0x1>
    1322:	20 93 59 3e 	sts	0x3E59, r18	; 0x803e59 <__brkval>
    1326:	30 93 5a 3e 	sts	0x3E5A, r19	; 0x803e5a <__brkval+0x1>
    132a:	20 91 00 3e 	lds	r18, 0x3E00	; 0x803e00 <__data_start>
    132e:	30 91 01 3e 	lds	r19, 0x3E01	; 0x803e01 <__data_start+0x1>
    1332:	21 15       	cp	r18, r1
    1334:	31 05       	cpc	r19, r1
    1336:	41 f4       	brne	.+16     	; 0x1348 <malloc+0xea>
    1338:	2d b7       	in	r18, 0x3d	; 61
    133a:	3e b7       	in	r19, 0x3e	; 62
    133c:	40 91 04 3e 	lds	r20, 0x3E04	; 0x803e04 <__malloc_margin>
    1340:	50 91 05 3e 	lds	r21, 0x3E05	; 0x803e05 <__malloc_margin+0x1>
    1344:	24 1b       	sub	r18, r20
    1346:	35 0b       	sbc	r19, r21
    1348:	e0 91 59 3e 	lds	r30, 0x3E59	; 0x803e59 <__brkval>
    134c:	f0 91 5a 3e 	lds	r31, 0x3E5A	; 0x803e5a <__brkval+0x1>
    1350:	e2 17       	cp	r30, r18
    1352:	f3 07       	cpc	r31, r19
    1354:	a0 f4       	brcc	.+40     	; 0x137e <malloc+0x120>
    1356:	2e 1b       	sub	r18, r30
    1358:	3f 0b       	sbc	r19, r31
    135a:	28 17       	cp	r18, r24
    135c:	39 07       	cpc	r19, r25
    135e:	78 f0       	brcs	.+30     	; 0x137e <malloc+0x120>
    1360:	ac 01       	movw	r20, r24
    1362:	4e 5f       	subi	r20, 0xFE	; 254
    1364:	5f 4f       	sbci	r21, 0xFF	; 255
    1366:	24 17       	cp	r18, r20
    1368:	35 07       	cpc	r19, r21
    136a:	48 f0       	brcs	.+18     	; 0x137e <malloc+0x120>
    136c:	4e 0f       	add	r20, r30
    136e:	5f 1f       	adc	r21, r31
    1370:	40 93 59 3e 	sts	0x3E59, r20	; 0x803e59 <__brkval>
    1374:	50 93 5a 3e 	sts	0x3E5A, r21	; 0x803e5a <__brkval+0x1>
    1378:	81 93       	st	Z+, r24
    137a:	91 93       	st	Z+, r25
    137c:	02 c0       	rjmp	.+4      	; 0x1382 <malloc+0x124>
    137e:	e0 e0       	ldi	r30, 0x00	; 0
    1380:	f0 e0       	ldi	r31, 0x00	; 0
    1382:	cf 01       	movw	r24, r30
    1384:	df 91       	pop	r29
    1386:	cf 91       	pop	r28
    1388:	1f 91       	pop	r17
    138a:	0f 91       	pop	r16
    138c:	08 95       	ret

0000138e <free>:
    138e:	cf 93       	push	r28
    1390:	df 93       	push	r29
    1392:	00 97       	sbiw	r24, 0x00	; 0
    1394:	09 f4       	brne	.+2      	; 0x1398 <free+0xa>
    1396:	81 c0       	rjmp	.+258    	; 0x149a <free+0x10c>
    1398:	fc 01       	movw	r30, r24
    139a:	32 97       	sbiw	r30, 0x02	; 2
    139c:	12 82       	std	Z+2, r1	; 0x02
    139e:	13 82       	std	Z+3, r1	; 0x03
    13a0:	a0 91 5b 3e 	lds	r26, 0x3E5B	; 0x803e5b <__flp>
    13a4:	b0 91 5c 3e 	lds	r27, 0x3E5C	; 0x803e5c <__flp+0x1>
    13a8:	10 97       	sbiw	r26, 0x00	; 0
    13aa:	81 f4       	brne	.+32     	; 0x13cc <free+0x3e>
    13ac:	20 81       	ld	r18, Z
    13ae:	31 81       	ldd	r19, Z+1	; 0x01
    13b0:	82 0f       	add	r24, r18
    13b2:	93 1f       	adc	r25, r19
    13b4:	20 91 59 3e 	lds	r18, 0x3E59	; 0x803e59 <__brkval>
    13b8:	30 91 5a 3e 	lds	r19, 0x3E5A	; 0x803e5a <__brkval+0x1>
    13bc:	28 17       	cp	r18, r24
    13be:	39 07       	cpc	r19, r25
    13c0:	51 f5       	brne	.+84     	; 0x1416 <free+0x88>
    13c2:	e0 93 59 3e 	sts	0x3E59, r30	; 0x803e59 <__brkval>
    13c6:	f0 93 5a 3e 	sts	0x3E5A, r31	; 0x803e5a <__brkval+0x1>
    13ca:	67 c0       	rjmp	.+206    	; 0x149a <free+0x10c>
    13cc:	ed 01       	movw	r28, r26
    13ce:	20 e0       	ldi	r18, 0x00	; 0
    13d0:	30 e0       	ldi	r19, 0x00	; 0
    13d2:	ce 17       	cp	r28, r30
    13d4:	df 07       	cpc	r29, r31
    13d6:	40 f4       	brcc	.+16     	; 0x13e8 <free+0x5a>
    13d8:	4a 81       	ldd	r20, Y+2	; 0x02
    13da:	5b 81       	ldd	r21, Y+3	; 0x03
    13dc:	9e 01       	movw	r18, r28
    13de:	41 15       	cp	r20, r1
    13e0:	51 05       	cpc	r21, r1
    13e2:	f1 f0       	breq	.+60     	; 0x1420 <free+0x92>
    13e4:	ea 01       	movw	r28, r20
    13e6:	f5 cf       	rjmp	.-22     	; 0x13d2 <free+0x44>
    13e8:	c2 83       	std	Z+2, r28	; 0x02
    13ea:	d3 83       	std	Z+3, r29	; 0x03
    13ec:	40 81       	ld	r20, Z
    13ee:	51 81       	ldd	r21, Z+1	; 0x01
    13f0:	84 0f       	add	r24, r20
    13f2:	95 1f       	adc	r25, r21
    13f4:	c8 17       	cp	r28, r24
    13f6:	d9 07       	cpc	r29, r25
    13f8:	59 f4       	brne	.+22     	; 0x1410 <free+0x82>
    13fa:	88 81       	ld	r24, Y
    13fc:	99 81       	ldd	r25, Y+1	; 0x01
    13fe:	84 0f       	add	r24, r20
    1400:	95 1f       	adc	r25, r21
    1402:	02 96       	adiw	r24, 0x02	; 2
    1404:	80 83       	st	Z, r24
    1406:	91 83       	std	Z+1, r25	; 0x01
    1408:	8a 81       	ldd	r24, Y+2	; 0x02
    140a:	9b 81       	ldd	r25, Y+3	; 0x03
    140c:	82 83       	std	Z+2, r24	; 0x02
    140e:	93 83       	std	Z+3, r25	; 0x03
    1410:	21 15       	cp	r18, r1
    1412:	31 05       	cpc	r19, r1
    1414:	29 f4       	brne	.+10     	; 0x1420 <free+0x92>
    1416:	e0 93 5b 3e 	sts	0x3E5B, r30	; 0x803e5b <__flp>
    141a:	f0 93 5c 3e 	sts	0x3E5C, r31	; 0x803e5c <__flp+0x1>
    141e:	3d c0       	rjmp	.+122    	; 0x149a <free+0x10c>
    1420:	e9 01       	movw	r28, r18
    1422:	ea 83       	std	Y+2, r30	; 0x02
    1424:	fb 83       	std	Y+3, r31	; 0x03
    1426:	49 91       	ld	r20, Y+
    1428:	59 91       	ld	r21, Y+
    142a:	c4 0f       	add	r28, r20
    142c:	d5 1f       	adc	r29, r21
    142e:	ec 17       	cp	r30, r28
    1430:	fd 07       	cpc	r31, r29
    1432:	61 f4       	brne	.+24     	; 0x144c <free+0xbe>
    1434:	80 81       	ld	r24, Z
    1436:	91 81       	ldd	r25, Z+1	; 0x01
    1438:	84 0f       	add	r24, r20
    143a:	95 1f       	adc	r25, r21
    143c:	02 96       	adiw	r24, 0x02	; 2
    143e:	e9 01       	movw	r28, r18
    1440:	88 83       	st	Y, r24
    1442:	99 83       	std	Y+1, r25	; 0x01
    1444:	82 81       	ldd	r24, Z+2	; 0x02
    1446:	93 81       	ldd	r25, Z+3	; 0x03
    1448:	8a 83       	std	Y+2, r24	; 0x02
    144a:	9b 83       	std	Y+3, r25	; 0x03
    144c:	e0 e0       	ldi	r30, 0x00	; 0
    144e:	f0 e0       	ldi	r31, 0x00	; 0
    1450:	12 96       	adiw	r26, 0x02	; 2
    1452:	8d 91       	ld	r24, X+
    1454:	9c 91       	ld	r25, X
    1456:	13 97       	sbiw	r26, 0x03	; 3
    1458:	00 97       	sbiw	r24, 0x00	; 0
    145a:	19 f0       	breq	.+6      	; 0x1462 <free+0xd4>
    145c:	fd 01       	movw	r30, r26
    145e:	dc 01       	movw	r26, r24
    1460:	f7 cf       	rjmp	.-18     	; 0x1450 <free+0xc2>
    1462:	8d 91       	ld	r24, X+
    1464:	9c 91       	ld	r25, X
    1466:	11 97       	sbiw	r26, 0x01	; 1
    1468:	9d 01       	movw	r18, r26
    146a:	2e 5f       	subi	r18, 0xFE	; 254
    146c:	3f 4f       	sbci	r19, 0xFF	; 255
    146e:	82 0f       	add	r24, r18
    1470:	93 1f       	adc	r25, r19
    1472:	20 91 59 3e 	lds	r18, 0x3E59	; 0x803e59 <__brkval>
    1476:	30 91 5a 3e 	lds	r19, 0x3E5A	; 0x803e5a <__brkval+0x1>
    147a:	28 17       	cp	r18, r24
    147c:	39 07       	cpc	r19, r25
    147e:	69 f4       	brne	.+26     	; 0x149a <free+0x10c>
    1480:	30 97       	sbiw	r30, 0x00	; 0
    1482:	29 f4       	brne	.+10     	; 0x148e <free+0x100>
    1484:	10 92 5b 3e 	sts	0x3E5B, r1	; 0x803e5b <__flp>
    1488:	10 92 5c 3e 	sts	0x3E5C, r1	; 0x803e5c <__flp+0x1>
    148c:	02 c0       	rjmp	.+4      	; 0x1492 <free+0x104>
    148e:	12 82       	std	Z+2, r1	; 0x02
    1490:	13 82       	std	Z+3, r1	; 0x03
    1492:	a0 93 59 3e 	sts	0x3E59, r26	; 0x803e59 <__brkval>
    1496:	b0 93 5a 3e 	sts	0x3E5A, r27	; 0x803e5a <__brkval+0x1>
    149a:	df 91       	pop	r29
    149c:	cf 91       	pop	r28
    149e:	08 95       	ret

000014a0 <_exit>:
    14a0:	f8 94       	cli

000014a2 <__stop_program>:
    14a2:	ff cf       	rjmp	.-2      	; 0x14a2 <__stop_program>
