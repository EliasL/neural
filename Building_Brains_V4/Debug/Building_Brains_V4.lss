
Building_Brains_V4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000006  00803e00  00001184  00001218  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001184  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000058  00803e06  00803e06  0000121e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000121e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001250  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000003c0  00000000  00000000  00001290  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00006aec  00000000  00000000  00001650  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002bdd  00000000  00000000  0000813c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000210c  00000000  00000000  0000ad19  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000063c  00000000  00000000  0000ce28  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002c89  00000000  00000000  0000d464  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000e69  00000000  00000000  000100ed  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000278  00000000  00000000  00010f56  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	2d c0       	rjmp	.+90     	; 0x5c <__ctors_end>
       2:	47 c0       	rjmp	.+142    	; 0x92 <__bad_interrupt>
       4:	46 c0       	rjmp	.+140    	; 0x92 <__bad_interrupt>
       6:	45 c0       	rjmp	.+138    	; 0x92 <__bad_interrupt>
       8:	44 c0       	rjmp	.+136    	; 0x92 <__bad_interrupt>
       a:	43 c0       	rjmp	.+134    	; 0x92 <__bad_interrupt>
       c:	72 c4       	rjmp	.+2276   	; 0x8f2 <__vector_6>
       e:	41 c0       	rjmp	.+130    	; 0x92 <__bad_interrupt>
      10:	40 c0       	rjmp	.+128    	; 0x92 <__bad_interrupt>
      12:	3f c0       	rjmp	.+126    	; 0x92 <__bad_interrupt>
      14:	3e c0       	rjmp	.+124    	; 0x92 <__bad_interrupt>
      16:	3d c0       	rjmp	.+122    	; 0x92 <__bad_interrupt>
      18:	3c c0       	rjmp	.+120    	; 0x92 <__bad_interrupt>
      1a:	3b c0       	rjmp	.+118    	; 0x92 <__bad_interrupt>
      1c:	3a c0       	rjmp	.+116    	; 0x92 <__bad_interrupt>
      1e:	39 c0       	rjmp	.+114    	; 0x92 <__bad_interrupt>
      20:	38 c0       	rjmp	.+112    	; 0x92 <__bad_interrupt>
      22:	37 c0       	rjmp	.+110    	; 0x92 <__bad_interrupt>
      24:	36 c0       	rjmp	.+108    	; 0x92 <__bad_interrupt>
      26:	35 c0       	rjmp	.+106    	; 0x92 <__bad_interrupt>
      28:	34 c0       	rjmp	.+104    	; 0x92 <__bad_interrupt>
      2a:	33 c0       	rjmp	.+102    	; 0x92 <__bad_interrupt>
      2c:	32 c0       	rjmp	.+100    	; 0x92 <__bad_interrupt>
      2e:	31 c0       	rjmp	.+98     	; 0x92 <__bad_interrupt>
      30:	30 c0       	rjmp	.+96     	; 0x92 <__bad_interrupt>
      32:	2f c0       	rjmp	.+94     	; 0x92 <__bad_interrupt>
      34:	07 63       	ori	r16, 0x37	; 55
      36:	42 36       	cpi	r20, 0x62	; 98
      38:	b7 9b       	sbis	0x16, 7	; 22
      3a:	d8 a7       	std	Y+40, r29	; 0x28
      3c:	1a 39       	cpi	r17, 0x9A	; 154
      3e:	68 56       	subi	r22, 0x68	; 104
      40:	18 ae       	std	Y+56, r1	; 0x38
      42:	ba ab       	std	Y+50, r27	; 0x32
      44:	55 8c       	ldd	r5, Z+29	; 0x1d
      46:	1d 3c       	cpi	r17, 0xCD	; 205
      48:	b7 cc       	rjmp	.-1682   	; 0xfffff9b8 <__eeprom_end+0xff7ef9b8>
      4a:	57 63       	ori	r21, 0x37	; 55
      4c:	bd 6d       	ori	r27, 0xDD	; 221
      4e:	ed fd       	.word	0xfded	; ????
      50:	75 3e       	cpi	r23, 0xE5	; 229
      52:	f6 17       	cp	r31, r22
      54:	72 31       	cpi	r23, 0x12	; 18
      56:	bf 00       	.word	0x00bf	; ????
      58:	00 00       	nop
      5a:	80 3f       	cpi	r24, 0xF0	; 240

0000005c <__ctors_end>:
      5c:	11 24       	eor	r1, r1
      5e:	1f be       	out	0x3f, r1	; 63
      60:	cf ef       	ldi	r28, 0xFF	; 255
      62:	cd bf       	out	0x3d, r28	; 61
      64:	df e3       	ldi	r29, 0x3F	; 63
      66:	de bf       	out	0x3e, r29	; 62

00000068 <__do_copy_data>:
      68:	1e e3       	ldi	r17, 0x3E	; 62
      6a:	a0 e0       	ldi	r26, 0x00	; 0
      6c:	be e3       	ldi	r27, 0x3E	; 62
      6e:	e4 e8       	ldi	r30, 0x84	; 132
      70:	f1 e1       	ldi	r31, 0x11	; 17
      72:	02 c0       	rjmp	.+4      	; 0x78 <__do_copy_data+0x10>
      74:	05 90       	lpm	r0, Z+
      76:	0d 92       	st	X+, r0
      78:	a6 30       	cpi	r26, 0x06	; 6
      7a:	b1 07       	cpc	r27, r17
      7c:	d9 f7       	brne	.-10     	; 0x74 <__do_copy_data+0xc>

0000007e <__do_clear_bss>:
      7e:	2e e3       	ldi	r18, 0x3E	; 62
      80:	a6 e0       	ldi	r26, 0x06	; 6
      82:	be e3       	ldi	r27, 0x3E	; 62
      84:	01 c0       	rjmp	.+2      	; 0x88 <.do_clear_bss_start>

00000086 <.do_clear_bss_loop>:
      86:	1d 92       	st	X+, r1

00000088 <.do_clear_bss_start>:
      88:	ae 35       	cpi	r26, 0x5E	; 94
      8a:	b2 07       	cpc	r27, r18
      8c:	e1 f7       	brne	.-8      	; 0x86 <.do_clear_bss_loop>
      8e:	21 d0       	rcall	.+66     	; 0xd2 <main>
      90:	77 c8       	rjmp	.-3858   	; 0xfffff180 <__eeprom_end+0xff7ef180>

00000092 <__bad_interrupt>:
      92:	b6 cf       	rjmp	.-148    	; 0x0 <__vectors>

00000094 <atmel_start_init>:
/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
	system_init();
      94:	31 d2       	rcall	.+1122   	; 0x4f8 <system_init>
      96:	08 95       	ret

00000098 <ISR_timer_counter_increment>:
If the Interrupt Service Routine is clocked by a crystal oscillator
it gives a very precise timer-counter.
*/
void ISR_timer_counter_increment(void)
{
	timer_counter_integer++;
      98:	80 91 06 3e 	lds	r24, 0x3E06	; 0x803e06 <__data_end>
      9c:	90 91 07 3e 	lds	r25, 0x3E07	; 0x803e07 <__data_end+0x1>
      a0:	a0 91 08 3e 	lds	r26, 0x3E08	; 0x803e08 <__data_end+0x2>
      a4:	b0 91 09 3e 	lds	r27, 0x3E09	; 0x803e09 <__data_end+0x3>
      a8:	01 96       	adiw	r24, 0x01	; 1
      aa:	a1 1d       	adc	r26, r1
      ac:	b1 1d       	adc	r27, r1
      ae:	80 93 06 3e 	sts	0x3E06, r24	; 0x803e06 <__data_end>
      b2:	90 93 07 3e 	sts	0x3E07, r25	; 0x803e07 <__data_end+0x1>
      b6:	a0 93 08 3e 	sts	0x3E08, r26	; 0x803e08 <__data_end+0x2>
      ba:	b0 93 09 3e 	sts	0x3E09, r27	; 0x803e09 <__data_end+0x3>
      be:	08 95       	ret

000000c0 <ISR_timer_count>:
/*
This function is callable by external libraries to give them the counted time so far.
*/
uint32_t ISR_timer_count(void)
{
	return timer_counter_integer;
      c0:	60 91 06 3e 	lds	r22, 0x3E06	; 0x803e06 <__data_end>
      c4:	70 91 07 3e 	lds	r23, 0x3E07	; 0x803e07 <__data_end+0x1>
      c8:	80 91 08 3e 	lds	r24, 0x3E08	; 0x803e08 <__data_end+0x2>
      cc:	90 91 09 3e 	lds	r25, 0x3E09	; 0x803e09 <__data_end+0x3>
      d0:	08 95       	ret

000000d2 <main>:
#include "tiny_timed_ISR/tiny_timed_ISR.h"
#include "ISR_timer_counter/ISR_timer_counter.h"


int main(void)
{
      d2:	cf 93       	push	r28
      d4:	df 93       	push	r29
      d6:	00 d0       	rcall	.+0      	; 0xd8 <main+0x6>
      d8:	cd b7       	in	r28, 0x3d	; 61
      da:	de b7       	in	r29, 0x3e	; 62
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
      dc:	db df       	rcall	.-74     	; 0x94 <atmel_start_init>
	set reference voltage to 4.32 Volts. This is done to ensure relatively low interference from
	nearby induced magnetic fields from high voltage AC-signals, such as outlets or transformers.
	Setting this value will mean that the ADC (Analog to Digital Converter) will read 4.32v as 255, and 0v as 0.
	For some reason, instead of the reference voltage being 4.32v, it is 3.3v. 
	*/
	VREF.CTRLB = VREF_ADC0REFSEL_4V34_gc;
      de:	80 e3       	ldi	r24, 0x30	; 48
      e0:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
	
	
	uint32_t current_time = 1;
	uint32_t previous_cycle_time = 0;
	uint16_t time_passed_since_last_cycle = 0;
	uint16_t volatile cycles=0;
      e4:	19 82       	std	Y+1, r1	; 0x01
      e6:	1a 82       	std	Y+2, r1	; 0x02
	tiny_DAC_set_neuron_type(EXCITATORY_NEURON);
      e8:	80 e0       	ldi	r24, 0x00	; 0
      ea:	9d d2       	rcall	.+1338   	; 0x626 <tiny_DAC_set_neuron_type>
	*/
	VREF.CTRLB = VREF_ADC0REFSEL_4V34_gc;
	
	
	uint32_t current_time = 1;
	uint32_t previous_cycle_time = 0;
      ec:	81 2c       	mov	r8, r1
      ee:	91 2c       	mov	r9, r1
      f0:	54 01       	movw	r10, r8
	uint16_t time_passed_since_last_cycle = 0;
	uint16_t volatile cycles=0;
	tiny_DAC_set_neuron_type(EXCITATORY_NEURON);
	while (1)
	{
		if(tiny_timed_ISR_getflag())
      f2:	2c d4       	rcall	.+2136   	; 0x94c <tiny_timed_ISR_getflag>
      f4:	88 23       	and	r24, r24
      f6:	e9 f3       	breq	.-6      	; 0xf2 <main+0x20>
		{
			current_time = ISR_timer_count();
      f8:	e3 df       	rcall	.-58     	; 0xc0 <ISR_timer_count>
      fa:	6b 01       	movw	r12, r22
      fc:	7c 01       	movw	r14, r24
			time_passed_since_last_cycle = current_time - previous_cycle_time;
			
			tiny_potential_master_update(time_passed_since_last_cycle);
      fe:	68 19       	sub	r22, r8
     100:	79 09       	sbc	r23, r9
     102:	80 e0       	ldi	r24, 0x00	; 0
     104:	90 e0       	ldi	r25, 0x00	; 0
     106:	2e d6       	rcall	.+3164   	; 0xd64 <__floatunsisf>
     108:	3e d4       	rcall	.+2172   	; 0x986 <tiny_potential_master_update>
			
			previous_cycle_time = current_time;
			tiny_timed_ISR_setflag(false);
     10a:	80 e0       	ldi	r24, 0x00	; 0
     10c:	1c d4       	rcall	.+2104   	; 0x946 <tiny_timed_ISR_setflag>
			cycles++;
     10e:	89 81       	ldd	r24, Y+1	; 0x01
     110:	9a 81       	ldd	r25, Y+2	; 0x02
     112:	01 96       	adiw	r24, 0x01	; 1
     114:	89 83       	std	Y+1, r24	; 0x01
     116:	9a 83       	std	Y+2, r25	; 0x02
			current_time = ISR_timer_count();
			time_passed_since_last_cycle = current_time - previous_cycle_time;
			
			tiny_potential_master_update(time_passed_since_last_cycle);
			
			previous_cycle_time = current_time;
     118:	46 01       	movw	r8, r12
     11a:	57 01       	movw	r10, r14
     11c:	ea cf       	rjmp	.-44     	; 0xf2 <main+0x20>

0000011e <set_LED_fire>:



//function to be called upon when firing flag has been raised.
void set_LED_fire(void)
{
     11e:	cf 93       	push	r28
	fire_flash_time_counter = ISR_timer_count();
     120:	cf df       	rcall	.-98     	; 0xc0 <ISR_timer_count>
     122:	60 93 0a 3e 	sts	0x3E0A, r22	; 0x803e0a <fire_flash_time_counter>
     126:	70 93 0b 3e 	sts	0x3E0B, r23	; 0x803e0b <fire_flash_time_counter+0x1>
     12a:	80 93 0c 3e 	sts	0x3E0C, r24	; 0x803e0c <fire_flash_time_counter+0x2>
     12e:	90 93 0d 3e 	sts	0x3E0D, r25	; 0x803e0d <fire_flash_time_counter+0x3>
     132:	c0 e0       	ldi	r28, 0x00	; 0
	for (int i = 0; i < NUMBER_OF_LEDS; i++)
	{
		tinyCCLRGB_setColor(i, MAX_BRIGHTNESS, MAX_BRIGHTNESS, MAX_BRIGHTNESS);//As per the specs, all LEDs should be blue while firing.
     134:	20 e3       	ldi	r18, 0x30	; 48
     136:	40 e3       	ldi	r20, 0x30	; 48
     138:	60 e3       	ldi	r22, 0x30	; 48
     13a:	8c 2f       	mov	r24, r28
     13c:	3d d2       	rcall	.+1146   	; 0x5b8 <tinyCCLRGB_setColor>
     13e:	cf 5f       	subi	r28, 0xFF	; 255

//function to be called upon when firing flag has been raised.
void set_LED_fire(void)
{
	fire_flash_time_counter = ISR_timer_count();
	for (int i = 0; i < NUMBER_OF_LEDS; i++)
     140:	c6 30       	cpi	r28, 0x06	; 6
     142:	c1 f7       	brne	.-16     	; 0x134 <set_LED_fire+0x16>
	{
		tinyCCLRGB_setColor(i, MAX_BRIGHTNESS, MAX_BRIGHTNESS, MAX_BRIGHTNESS);//As per the specs, all LEDs should be blue while firing.
	}
}
     144:	cf 91       	pop	r28
     146:	08 95       	ret

00000148 <potential_to_RGB_update_LEDs>:



void potential_to_RGB_update_LEDs(double potential)
{
     148:	8f 92       	push	r8
     14a:	9f 92       	push	r9
     14c:	af 92       	push	r10
     14e:	bf 92       	push	r11
     150:	cf 92       	push	r12
     152:	df 92       	push	r13
     154:	ef 92       	push	r14
     156:	ff 92       	push	r15
     158:	0f 93       	push	r16
     15a:	1f 93       	push	r17
     15c:	cf 93       	push	r28
     15e:	6b 01       	movw	r12, r22
     160:	7c 01       	movw	r14, r24
	if ((ISR_timer_count() - fire_flash_time_counter) < FIRE_FLASH_TIME)
     162:	ae df       	rcall	.-164    	; 0xc0 <ISR_timer_count>
     164:	00 91 0a 3e 	lds	r16, 0x3E0A	; 0x803e0a <fire_flash_time_counter>
     168:	10 91 0b 3e 	lds	r17, 0x3E0B	; 0x803e0b <fire_flash_time_counter+0x1>
     16c:	20 91 0c 3e 	lds	r18, 0x3E0C	; 0x803e0c <fire_flash_time_counter+0x2>
     170:	30 91 0d 3e 	lds	r19, 0x3E0D	; 0x803e0d <fire_flash_time_counter+0x3>
     174:	dc 01       	movw	r26, r24
     176:	cb 01       	movw	r24, r22
     178:	80 1b       	sub	r24, r16
     17a:	91 0b       	sbc	r25, r17
     17c:	a2 0b       	sbc	r26, r18
     17e:	b3 0b       	sbc	r27, r19
     180:	84 36       	cpi	r24, 0x64	; 100
     182:	91 05       	cpc	r25, r1
     184:	a1 05       	cpc	r26, r1
     186:	b1 05       	cpc	r27, r1
     188:	50 f4       	brcc	.+20     	; 0x19e <potential_to_RGB_update_LEDs+0x56>
     18a:	c0 e0       	ldi	r28, 0x00	; 0
	{
		for (int i = 0; i < NUMBER_OF_LEDS; i++)
		{
			tinyCCLRGB_setColor(i, MAX_BRIGHTNESS, MAX_BRIGHTNESS, MAX_BRIGHTNESS);
     18c:	20 e3       	ldi	r18, 0x30	; 48
     18e:	40 e3       	ldi	r20, 0x30	; 48
     190:	60 e3       	ldi	r22, 0x30	; 48
     192:	8c 2f       	mov	r24, r28
     194:	11 d2       	rcall	.+1058   	; 0x5b8 <tinyCCLRGB_setColor>
     196:	cf 5f       	subi	r28, 0xFF	; 255

void potential_to_RGB_update_LEDs(double potential)
{
	if ((ISR_timer_count() - fire_flash_time_counter) < FIRE_FLASH_TIME)
	{
		for (int i = 0; i < NUMBER_OF_LEDS; i++)
     198:	c6 30       	cpi	r28, 0x06	; 6
     19a:	c1 f7       	brne	.-16     	; 0x18c <potential_to_RGB_update_LEDs+0x44>
     19c:	53 c0       	rjmp	.+166    	; 0x244 <potential_to_RGB_update_LEDs+0xfc>
     19e:	c0 e0       	ldi	r28, 0x00	; 0
*/
static void potential_to_RGB_set_color(double potential)
{
	for (int i = 0; i < NUMBER_OF_LEDS; i++)
	{
		tinyCCLRGB_setColor(i, 0x0, 0x0, 0x0);//Clear all LED stored values on the MCU before writing again.
     1a0:	20 e0       	ldi	r18, 0x00	; 0
     1a2:	40 e0       	ldi	r20, 0x00	; 0
     1a4:	60 e0       	ldi	r22, 0x00	; 0
     1a6:	8c 2f       	mov	r24, r28
     1a8:	07 d2       	rcall	.+1038   	; 0x5b8 <tinyCCLRGB_setColor>
     1aa:	cf 5f       	subi	r28, 0xFF	; 255
When firing all lights turn blue for ~100ms, but this needs to be tested.
LEDs are numbered right way on top of PCB, but opposite way on bottom of PCB.
*/
static void potential_to_RGB_set_color(double potential)
{
	for (int i = 0; i < NUMBER_OF_LEDS; i++)
     1ac:	c6 30       	cpi	r28, 0x06	; 6
     1ae:	c1 f7       	brne	.-16     	; 0x1a0 <potential_to_RGB_update_LEDs+0x58>
	{
		tinyCCLRGB_setColor(i, 0x0, 0x0, 0x0);//Clear all LED stored values on the MCU before writing again.
	}
	double absolute_potential = abs(potential);//setting variable for absolute potential so it won't have to be calculated more than once.
     1b0:	c7 01       	movw	r24, r14
     1b2:	b6 01       	movw	r22, r12
     1b4:	a1 d5       	rcall	.+2882   	; 0xcf8 <__fixsfsi>
     1b6:	9b 01       	movw	r18, r22
     1b8:	77 23       	and	r23, r23
     1ba:	24 f4       	brge	.+8      	; 0x1c4 <potential_to_RGB_update_LEDs+0x7c>
     1bc:	22 27       	eor	r18, r18
     1be:	33 27       	eor	r19, r19
     1c0:	26 1b       	sub	r18, r22
     1c2:	37 0b       	sbc	r19, r23
     1c4:	b9 01       	movw	r22, r18
     1c6:	33 0f       	add	r19, r19
     1c8:	88 0b       	sbc	r24, r24
     1ca:	99 0b       	sbc	r25, r25
     1cc:	cd d5       	rcall	.+2970   	; 0xd68 <__floatsisf>
     1ce:	4b 01       	movw	r8, r22
     1d0:	5c 01       	movw	r10, r24
	if (absolute_potential < 1)//set the middle lights as white both top side and bottom side.
     1d2:	20 e0       	ldi	r18, 0x00	; 0
     1d4:	30 e0       	ldi	r19, 0x00	; 0
     1d6:	40 e8       	ldi	r20, 0x80	; 128
     1d8:	5f e3       	ldi	r21, 0x3F	; 63
     1da:	dd d4       	rcall	.+2490   	; 0xb96 <__cmpsf2>
     1dc:	88 23       	and	r24, r24
     1de:	34 f4       	brge	.+12     	; 0x1ec <potential_to_RGB_update_LEDs+0xa4>
	{
		tinyCCLRGB_setColor(2, MAX_BRIGHTNESS/3, MAX_BRIGHTNESS/3, MAX_BRIGHTNESS/3);
     1e0:	20 e1       	ldi	r18, 0x10	; 16
     1e2:	40 e1       	ldi	r20, 0x10	; 16
     1e4:	60 e1       	ldi	r22, 0x10	; 16
     1e6:	82 e0       	ldi	r24, 0x02	; 2
     1e8:	e7 d1       	rcall	.+974    	; 0x5b8 <tinyCCLRGB_setColor>
     1ea:	2c c0       	rjmp	.+88     	; 0x244 <potential_to_RGB_update_LEDs+0xfc>
		//tinyCCLRGB_setColor(4, max_brightness/3, max_brightness/3, max_brightness/3);
	}
	else
	{
		uint8_t brightness_intensity = round((absolute_potential/25)*MAX_BRIGHTNESS);//brightness intensity for the LED that shows potential.
     1ec:	20 e0       	ldi	r18, 0x00	; 0
     1ee:	30 e0       	ldi	r19, 0x00	; 0
     1f0:	48 ec       	ldi	r20, 0xC8	; 200
     1f2:	51 e4       	ldi	r21, 0x41	; 65
     1f4:	c5 01       	movw	r24, r10
     1f6:	b4 01       	movw	r22, r8
     1f8:	d3 d4       	rcall	.+2470   	; 0xba0 <__divsf3>
     1fa:	20 e0       	ldi	r18, 0x00	; 0
     1fc:	30 e0       	ldi	r19, 0x00	; 0
     1fe:	40 e4       	ldi	r20, 0x40	; 64
     200:	52 e4       	ldi	r21, 0x42	; 66
     202:	04 d7       	rcall	.+3592   	; 0x100c <__mulsf3>
     204:	70 d7       	rcall	.+3808   	; 0x10e6 <round>
     206:	7f d5       	rcall	.+2814   	; 0xd06 <__fixunssfsi>
     208:	c6 2f       	mov	r28, r22
		if (potential < 0)
     20a:	20 e0       	ldi	r18, 0x00	; 0
     20c:	30 e0       	ldi	r19, 0x00	; 0
     20e:	a9 01       	movw	r20, r18
     210:	c7 01       	movw	r24, r14
     212:	b6 01       	movw	r22, r12
     214:	c0 d4       	rcall	.+2432   	; 0xb96 <__cmpsf2>
     216:	88 23       	and	r24, r24
     218:	5c f4       	brge	.+22     	; 0x230 <potential_to_RGB_update_LEDs+0xe8>
		{
			tinyCCLRGB_setColor(0, brightness_intensity, 0x0, 0x0);
     21a:	20 e0       	ldi	r18, 0x00	; 0
     21c:	40 e0       	ldi	r20, 0x00	; 0
     21e:	6c 2f       	mov	r22, r28
     220:	80 e0       	ldi	r24, 0x00	; 0
     222:	ca d1       	rcall	.+916    	; 0x5b8 <tinyCCLRGB_setColor>
			tinyCCLRGB_setColor(1, brightness_intensity, 0x0, 0x0);//sets lower LEDs red if potential is negative.
     224:	20 e0       	ldi	r18, 0x00	; 0
     226:	40 e0       	ldi	r20, 0x00	; 0
     228:	6c 2f       	mov	r22, r28
     22a:	81 e0       	ldi	r24, 0x01	; 1
     22c:	c5 d1       	rcall	.+906    	; 0x5b8 <tinyCCLRGB_setColor>
     22e:	0a c0       	rjmp	.+20     	; 0x244 <potential_to_RGB_update_LEDs+0xfc>
		} 
		else
		{
			tinyCCLRGB_setColor(3, 0x0, brightness_intensity, 0x0);//sets upper LEDs green if potential is positive.
     230:	20 e0       	ldi	r18, 0x00	; 0
     232:	4c 2f       	mov	r20, r28
     234:	60 e0       	ldi	r22, 0x00	; 0
     236:	83 e0       	ldi	r24, 0x03	; 3
     238:	bf d1       	rcall	.+894    	; 0x5b8 <tinyCCLRGB_setColor>
			tinyCCLRGB_setColor(4, 0x0, brightness_intensity, 0x0);
     23a:	20 e0       	ldi	r18, 0x00	; 0
     23c:	4c 2f       	mov	r20, r28
     23e:	60 e0       	ldi	r22, 0x00	; 0
     240:	84 e0       	ldi	r24, 0x04	; 4
     242:	ba d1       	rcall	.+884    	; 0x5b8 <tinyCCLRGB_setColor>
	}
	else
	{
		potential_to_RGB_set_color(potential);
	}
	tinyCCLRGB_uploadColorsToLeds();
     244:	c6 d1       	rcall	.+908    	; 0x5d2 <tinyCCLRGB_uploadColorsToLeds>
}
     246:	cf 91       	pop	r28
     248:	1f 91       	pop	r17
     24a:	0f 91       	pop	r16
     24c:	ff 90       	pop	r15
     24e:	ef 90       	pop	r14
     250:	df 90       	pop	r13
     252:	cf 90       	pop	r12
     254:	bf 90       	pop	r11
     256:	af 90       	pop	r10
     258:	9f 90       	pop	r9
     25a:	8f 90       	pop	r8
     25c:	08 95       	ret

0000025e <tiny_button_get_state>:
Master-function for button-checking, returns 2 if the neuron should spontaneously fire.
Returns 1 if the system has received a button push shorter than two seconds.
Returns 0 if the button is still pushed in, or it has not yet received a button push.
*/
_Bool tiny_button_get_state(void)
{
     25e:	0f 93       	push	r16
     260:	1f 93       	push	r17
     262:	cf 93       	push	r28
     264:	df 93       	push	r29
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTC_get_pin_level(const uint8_t pin)
{
	return VPORTC.IN & (1 << pin);
     266:	8a b1       	in	r24, 0x0a	; 10
function changes state of button_spont_pulse, if button has been held down for 2 secs.
*/
static _Bool tiny_button_check(void)
{
	_Bool re_var = false;
	_Bool button_is_pushed_down = !Button_get_level();//the digital port will be read as low if the button is pushed down.
     268:	d1 e0       	ldi	r29, 0x01	; 1
     26a:	c8 2f       	mov	r28, r24
     26c:	c4 70       	andi	r28, 0x04	; 4
     26e:	82 fd       	sbrc	r24, 2
     270:	d0 e0       	ldi	r29, 0x00	; 0
	if (!button_is_pushed_down && !button_was_pushed_down)//button is not pushed down, and was not pushed down
	{
		re_var = false;
	}
	if (button_is_pushed_down && !button_was_pushed_down)
     272:	c1 11       	cpse	r28, r1
     274:	34 c0       	rjmp	.+104    	; 0x2de <tiny_button_get_state+0x80>
     276:	80 91 13 3e 	lds	r24, 0x3E13	; 0x803e13 <button_was_pushed_down>
     27a:	81 11       	cpse	r24, r1
     27c:	0d c0       	rjmp	.+26     	; 0x298 <tiny_button_get_state+0x3a>
	{
		tiny_button_start_time = ISR_timer_count();
     27e:	20 df       	rcall	.-448    	; 0xc0 <ISR_timer_count>
     280:	60 93 0f 3e 	sts	0x3E0F, r22	; 0x803e0f <tiny_button_start_time>
     284:	70 93 10 3e 	sts	0x3E10, r23	; 0x803e10 <tiny_button_start_time+0x1>
     288:	80 93 11 3e 	sts	0x3E11, r24	; 0x803e11 <tiny_button_start_time+0x2>
     28c:	90 93 12 3e 	sts	0x3E12, r25	; 0x803e12 <tiny_button_start_time+0x3>
		re_var = false;
	}
	if (button_is_pushed_down && button_was_pushed_down)
     290:	80 91 13 3e 	lds	r24, 0x3E13	; 0x803e13 <button_was_pushed_down>
     294:	88 23       	and	r24, r24
     296:	19 f1       	breq	.+70     	; 0x2de <tiny_button_get_state+0x80>
	{
		if ((ISR_timer_count() - tiny_button_start_time) > 2000)
     298:	13 df       	rcall	.-474    	; 0xc0 <ISR_timer_count>
     29a:	00 91 0f 3e 	lds	r16, 0x3E0F	; 0x803e0f <tiny_button_start_time>
     29e:	10 91 10 3e 	lds	r17, 0x3E10	; 0x803e10 <tiny_button_start_time+0x1>
     2a2:	20 91 11 3e 	lds	r18, 0x3E11	; 0x803e11 <tiny_button_start_time+0x2>
     2a6:	30 91 12 3e 	lds	r19, 0x3E12	; 0x803e12 <tiny_button_start_time+0x3>
     2aa:	dc 01       	movw	r26, r24
     2ac:	cb 01       	movw	r24, r22
     2ae:	80 1b       	sub	r24, r16
     2b0:	91 0b       	sbc	r25, r17
     2b2:	a2 0b       	sbc	r26, r18
     2b4:	b3 0b       	sbc	r27, r19
     2b6:	81 3d       	cpi	r24, 0xD1	; 209
     2b8:	97 40       	sbci	r25, 0x07	; 7
     2ba:	a1 05       	cpc	r26, r1
     2bc:	b1 05       	cpc	r27, r1
     2be:	78 f0       	brcs	.+30     	; 0x2de <tiny_button_get_state+0x80>
tiny_button_toggle_spont_pulse changes the state of the boolean value determining
if the neuron is in spontaneous fire-mode or not.
*/
static void tiny_button_toggle_spont_pulse(void)
{
	tiny_button_spont_pulse = !tiny_button_spont_pulse;
     2c0:	90 91 0e 3e 	lds	r25, 0x3E0E	; 0x803e0e <tiny_button_spont_pulse>
     2c4:	81 e0       	ldi	r24, 0x01	; 1
     2c6:	89 27       	eor	r24, r25
     2c8:	80 93 0e 3e 	sts	0x3E0E, r24	; 0x803e0e <tiny_button_spont_pulse>
	if (button_is_pushed_down && button_was_pushed_down)
	{
		if ((ISR_timer_count() - tiny_button_start_time) > 2000)
		{
			tiny_button_toggle_spont_pulse();
			tiny_button_start_time = ISR_timer_count();
     2cc:	f9 de       	rcall	.-526    	; 0xc0 <ISR_timer_count>
     2ce:	60 93 0f 3e 	sts	0x3E0F, r22	; 0x803e0f <tiny_button_start_time>
     2d2:	70 93 10 3e 	sts	0x3E10, r23	; 0x803e10 <tiny_button_start_time+0x1>
     2d6:	80 93 11 3e 	sts	0x3E11, r24	; 0x803e11 <tiny_button_start_time+0x2>
     2da:	90 93 12 3e 	sts	0x3E12, r25	; 0x803e12 <tiny_button_start_time+0x3>
		}
		re_var = false;
	}
	if (!button_is_pushed_down && button_was_pushed_down)
     2de:	cc 23       	and	r28, r28
     2e0:	19 f0       	breq	.+6      	; 0x2e8 <tiny_button_get_state+0x8a>
     2e2:	80 91 13 3e 	lds	r24, 0x3E13	; 0x803e13 <button_was_pushed_down>
     2e6:	01 c0       	rjmp	.+2      	; 0x2ea <tiny_button_get_state+0x8c>
     2e8:	80 e0       	ldi	r24, 0x00	; 0
	{
		re_var = true;
	}
	button_was_pushed_down = button_is_pushed_down;
     2ea:	d0 93 13 3e 	sts	0x3E13, r29	; 0x803e13 <button_was_pushed_down>
Returns 0 if the button is still pushed in, or it has not yet received a button push.
*/
_Bool tiny_button_get_state(void)
{
	return tiny_button_check();
}
     2ee:	df 91       	pop	r29
     2f0:	cf 91       	pop	r28
     2f2:	1f 91       	pop	r17
     2f4:	0f 91       	pop	r16
     2f6:	08 95       	ret

000002f8 <tiny_button_is_spont_pulse_on>:

_Bool tiny_button_is_spont_pulse_on(void)
{
	return tiny_button_spont_pulse;
}
     2f8:	80 91 0e 3e 	lds	r24, 0x3E0E	; 0x803e0e <tiny_button_spont_pulse>
     2fc:	08 95       	ret

000002fe <spont_pulse_delta_potential>:
/*
Callable function from outside the module, should be called every main loop cycle
while spontaneous pulse mode is active and will then return the change in potential.
*/
uint8_t spont_pulse_delta_potential(void)
{
     2fe:	0f 93       	push	r16
     300:	1f 93       	push	r17
Function to determine whether a spontaneous pulse
should increase the membrane potential or not.
*/
static _Bool spont_pulse(void)
{
	if ((ISR_timer_count() - spont_pulse_timer_counter) > SPONT_PULSE_PERIOD*2)
     302:	de de       	rcall	.-580    	; 0xc0 <ISR_timer_count>
     304:	00 91 15 3e 	lds	r16, 0x3E15	; 0x803e15 <spont_pulse_timer_counter>
     308:	10 91 16 3e 	lds	r17, 0x3E16	; 0x803e16 <spont_pulse_timer_counter+0x1>
     30c:	20 91 17 3e 	lds	r18, 0x3E17	; 0x803e17 <spont_pulse_timer_counter+0x2>
     310:	30 91 18 3e 	lds	r19, 0x3E18	; 0x803e18 <spont_pulse_timer_counter+0x3>
     314:	dc 01       	movw	r26, r24
     316:	cb 01       	movw	r24, r22
     318:	80 1b       	sub	r24, r16
     31a:	91 0b       	sbc	r25, r17
     31c:	a2 0b       	sbc	r26, r18
     31e:	b3 0b       	sbc	r27, r19
     320:	89 3e       	cpi	r24, 0xE9	; 233
     322:	93 40       	sbci	r25, 0x03	; 3
     324:	a1 05       	cpc	r26, r1
     326:	b1 05       	cpc	r27, r1
     328:	88 f0       	brcs	.+34     	; 0x34c <spont_pulse_delta_potential+0x4e>
/*
Function to initiate spontaneous pulse mode.
*/
static void spont_pulse_start(void)
{
	spont_pulse_out = true;
     32a:	81 e0       	ldi	r24, 0x01	; 1
     32c:	80 93 14 3e 	sts	0x3E14, r24	; 0x803e14 <spont_pulse_out>
	spont_pulse_timer_counter = ISR_timer_count();
     330:	c7 de       	rcall	.-626    	; 0xc0 <ISR_timer_count>
     332:	60 93 15 3e 	sts	0x3E15, r22	; 0x803e15 <spont_pulse_timer_counter>
     336:	70 93 16 3e 	sts	0x3E16, r23	; 0x803e16 <spont_pulse_timer_counter+0x1>
     33a:	80 93 17 3e 	sts	0x3E17, r24	; 0x803e17 <spont_pulse_timer_counter+0x2>
     33e:	90 93 18 3e 	sts	0x3E18, r25	; 0x803e18 <spont_pulse_timer_counter+0x3>
Callable function from outside the module, should be called every main loop cycle
while spontaneous pulse mode is active and will then return the change in potential.
*/
uint8_t spont_pulse_delta_potential(void)
{
	if (spont_pulse())
     342:	80 91 14 3e 	lds	r24, 0x3E14	; 0x803e14 <spont_pulse_out>
     346:	81 11       	cpse	r24, r1
     348:	27 c0       	rjmp	.+78     	; 0x398 <spont_pulse_delta_potential+0x9a>
     34a:	27 c0       	rjmp	.+78     	; 0x39a <spont_pulse_delta_potential+0x9c>
/*
Function to check if a second has passed since last pulse out.
*/
static void spont_pulse_time_check(void)
{
	if ((ISR_timer_count() - spont_pulse_timer_counter) > SPONT_PULSE_PERIOD)
     34c:	b9 de       	rcall	.-654    	; 0xc0 <ISR_timer_count>
     34e:	00 91 15 3e 	lds	r16, 0x3E15	; 0x803e15 <spont_pulse_timer_counter>
     352:	10 91 16 3e 	lds	r17, 0x3E16	; 0x803e16 <spont_pulse_timer_counter+0x1>
     356:	20 91 17 3e 	lds	r18, 0x3E17	; 0x803e17 <spont_pulse_timer_counter+0x2>
     35a:	30 91 18 3e 	lds	r19, 0x3E18	; 0x803e18 <spont_pulse_timer_counter+0x3>
     35e:	dc 01       	movw	r26, r24
     360:	cb 01       	movw	r24, r22
     362:	80 1b       	sub	r24, r16
     364:	91 0b       	sbc	r25, r17
     366:	a2 0b       	sbc	r26, r18
     368:	b3 0b       	sbc	r27, r19
     36a:	85 3f       	cpi	r24, 0xF5	; 245
     36c:	91 40       	sbci	r25, 0x01	; 1
     36e:	a1 05       	cpc	r26, r1
     370:	b1 05       	cpc	r27, r1
     372:	70 f0       	brcs	.+28     	; 0x390 <spont_pulse_delta_potential+0x92>
	{
		spont_pulse_timer_counter = ISR_timer_count();
     374:	a5 de       	rcall	.-694    	; 0xc0 <ISR_timer_count>
     376:	60 93 15 3e 	sts	0x3E15, r22	; 0x803e15 <spont_pulse_timer_counter>
     37a:	70 93 16 3e 	sts	0x3E16, r23	; 0x803e16 <spont_pulse_timer_counter+0x1>
     37e:	80 93 17 3e 	sts	0x3E17, r24	; 0x803e17 <spont_pulse_timer_counter+0x2>
     382:	90 93 18 3e 	sts	0x3E18, r25	; 0x803e18 <spont_pulse_timer_counter+0x3>
		spont_pulse_out = true;
     386:	81 e0       	ldi	r24, 0x01	; 1
     388:	80 93 14 3e 	sts	0x3E14, r24	; 0x803e14 <spont_pulse_out>
*/
uint8_t spont_pulse_delta_potential(void)
{
	if (spont_pulse())
	{
		return 26;
     38c:	8a e1       	ldi	r24, 0x1A	; 26
     38e:	05 c0       	rjmp	.+10     	; 0x39a <spont_pulse_delta_potential+0x9c>
		spont_pulse_timer_counter = ISR_timer_count();
		spont_pulse_out = true;
	}
	else
	{
		spont_pulse_out = false;
     390:	10 92 14 3e 	sts	0x3E14, r1	; 0x803e14 <spont_pulse_out>
	{
		return 26;
	}
	else
	{
		return 0;
     394:	80 e0       	ldi	r24, 0x00	; 0
     396:	01 c0       	rjmp	.+2      	; 0x39a <spont_pulse_delta_potential+0x9c>
*/
uint8_t spont_pulse_delta_potential(void)
{
	if (spont_pulse())
	{
		return 26;
     398:	8a e1       	ldi	r24, 0x1A	; 26
	}
	else
	{
		return 0;
	}
}
     39a:	1f 91       	pop	r17
     39c:	0f 91       	pop	r16
     39e:	08 95       	ret

000003a0 <ADC_init>:
 * \return Conversion result read from the ADC ADC module
 */
adc_result_t ADC_get_conversion_result(void)
{
	return (ADC0.RES);
}
     3a0:	85 e0       	ldi	r24, 0x05	; 5
     3a2:	80 93 00 06 	sts	0x0600, r24	; 0x800600 <__TEXT_REGION_LENGTH__+0x700600>
     3a6:	80 e0       	ldi	r24, 0x00	; 0
     3a8:	08 95       	ret

000003aa <ADC_is_conversion_done>:
     3aa:	80 91 0b 06 	lds	r24, 0x060B	; 0x80060b <__TEXT_REGION_LENGTH__+0x70060b>
     3ae:	81 70       	andi	r24, 0x01	; 1
     3b0:	08 95       	ret

000003b2 <ADC_get_conversion>:
 *
 * \return Nothing
 */
void ADC_start_conversion(adc_0_channel_t channel)
{
	ADC0.MUXPOS  = channel;
     3b2:	e0 e0       	ldi	r30, 0x00	; 0
     3b4:	f6 e0       	ldi	r31, 0x06	; 6
     3b6:	86 83       	std	Z+6, r24	; 0x06
	ADC0.COMMAND = ADC_STCONV_bm;
     3b8:	81 e0       	ldi	r24, 0x01	; 1
     3ba:	80 87       	std	Z+8, r24	; 0x08
adc_result_t ADC_get_conversion(adc_0_channel_t channel)
{
	adc_result_t res;

	ADC_start_conversion(channel);
	while (!ADC_is_conversion_done())
     3bc:	f6 df       	rcall	.-20     	; 0x3aa <ADC_is_conversion_done>
     3be:	88 23       	and	r24, r24
     3c0:	e9 f3       	breq	.-6      	; 0x3bc <ADC_get_conversion+0xa>
 *
 * \return Conversion result read from the ADC ADC module
 */
adc_result_t ADC_get_conversion_result(void)
{
	return (ADC0.RES);
     3c2:	e0 e0       	ldi	r30, 0x00	; 0
     3c4:	f6 e0       	ldi	r31, 0x06	; 6
     3c6:	20 89       	ldd	r18, Z+16	; 0x10
     3c8:	31 89       	ldd	r19, Z+17	; 0x11

	ADC_start_conversion(channel);
	while (!ADC_is_conversion_done())
		;
	res = ADC_get_conversion_result();
	ADC0.INTFLAGS |= ADC_RESRDY_bm;
     3ca:	93 85       	ldd	r25, Z+11	; 0x0b
     3cc:	91 60       	ori	r25, 0x01	; 1
     3ce:	93 87       	std	Z+11, r25	; 0x0b
	return res;
}
     3d0:	c9 01       	movw	r24, r18
     3d2:	08 95       	ret

000003d4 <BOD_init>:
	//		 | BOD_VLMCFG_ABOVE_gc; /* Interrupt when supply goes above VLM level */

	// BOD.VLMCTRLA = BOD_VLMLVL_5ABOVE_gc; /* VLM threshold 5% above BOD level */

	return 0;
}
     3d4:	80 e0       	ldi	r24, 0x00	; 0
     3d6:	08 95       	ret

000003d8 <DIGGSIGG_init>:
	//		 | CCL_EDGEDET_DIS_gc /* Edge detector is disabled */
	//		 | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	//		 | 0 << CCL_ENABLE_bp /* LUT Enable: disabled */
	//		 | 0 << CCL_OUTEN_bp; /* Output Enable: disabled */

	CCL.TRUTH1 = 168; /* Truth 1: 168 */
     3d8:	e0 ec       	ldi	r30, 0xC0	; 192
     3da:	f1 e0       	ldi	r31, 0x01	; 1
     3dc:	88 ea       	ldi	r24, 0xA8	; 168
     3de:	84 87       	std	Z+12, r24	; 0x0c

	CCL.LUT1CTRLC = CCL_INSEL2_TCA0_gc /* TCA0 WO2 input source */;
     3e0:	88 e0       	ldi	r24, 0x08	; 8
     3e2:	83 87       	std	Z+11, r24	; 0x0b

	CCL.LUT1CTRLB = CCL_INSEL0_SPI0_gc /* SPI0 SCK source */
     3e4:	8b eb       	ldi	r24, 0xBB	; 187
     3e6:	82 87       	std	Z+10, r24	; 0x0a
	                | CCL_INSEL1_SPI0_gc /* SPI0 MOSI input source */;

	CCL.LUT1CTRLA = 0 << CCL_CLKSRC_bp       /* Clock Source Selection: disabled */
     3e8:	89 e0       	ldi	r24, 0x09	; 9
     3ea:	81 87       	std	Z+9, r24	; 0x09
	                | CCL_EDGEDET_DIS_gc     /* Edge detector is disabled */
	                | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	                | 1 << CCL_ENABLE_bp     /* LUT Enable: enabled */
	                | 1 << CCL_OUTEN_bp;     /* Output Enable: enabled */

	CCL.CTRLA = 1 << CCL_ENABLE_bp      /* Enable: enabled */
     3ec:	81 e4       	ldi	r24, 0x41	; 65
     3ee:	80 83       	st	Z, r24
	            | 1 << CCL_RUNSTDBY_bp; /* Run in Standby: enabled */

	return 0;
}
     3f0:	80 e0       	ldi	r24, 0x00	; 0
     3f2:	08 95       	ret

000003f4 <CLKCTRL_init>:
 *       on calling convention. The memory model is not visible to the
 *       preprocessor, so it must be defined in the Assembler preprocessor directives.
 */
static inline void ccp_write_io(void *addr, uint8_t value)
{
	protected_write_io(addr, CCP_IOREG_gc, value);
     3f4:	47 e0       	ldi	r20, 0x07	; 7
     3f6:	68 ed       	ldi	r22, 0xD8	; 216
     3f8:	8c e7       	ldi	r24, 0x7C	; 124
     3fa:	90 e0       	ldi	r25, 0x00	; 0
     3fc:	91 d0       	rcall	.+290    	; 0x520 <protected_write_io>
     3fe:	41 e0       	ldi	r20, 0x01	; 1
     400:	68 ed       	ldi	r22, 0xD8	; 216
     402:	81 e6       	ldi	r24, 0x61	; 97
     404:	90 e0       	ldi	r25, 0x00	; 0
     406:	8c d0       	rcall	.+280    	; 0x520 <protected_write_io>
	//		 | 0 << CLKCTRL_CLKOUT_bp /* System clock out: disabled */);

	// ccp_write_io((void*)&(CLKCTRL.MCLKLOCK),0 << CLKCTRL_LOCKEN_bp /* lock enable: disabled */);

	return 0;
}
     408:	80 e0       	ldi	r24, 0x00	; 0
     40a:	08 95       	ret

0000040c <CPUINT_init>:

	// CPUINT.LVL0PRI = 0x0 << CPUINT_LVL0PRI_gp; /* Interrupt Level Priority: 0x0 */

	// CPUINT.LVL1VEC = 0x0 << CPUINT_LVL1VEC_gp; /* Interrupt Vector with High Priority: 0x0 */

	ENABLE_INTERRUPTS();
     40c:	78 94       	sei

	return 0;
}
     40e:	80 e0       	ldi	r24, 0x00	; 0
     410:	08 95       	ret

00000412 <DAC_init>:
 *
 * \return Nothing
 */
void DAC_disable()
{
	DAC0.CTRLA &= ~DAC_ENABLE_bm;
     412:	81 e4       	ldi	r24, 0x41	; 65
     414:	80 93 80 06 	sts	0x0680, r24	; 0x800680 <__TEXT_REGION_LENGTH__+0x700680>
     418:	80 e0       	ldi	r24, 0x00	; 0
     41a:	08 95       	ret

0000041c <DAC_set_output>:
 *
 * \return Nothing
 */
void DAC_set_output(dac_resolution_t value)
{
	DAC0.DATA = value;
     41c:	80 93 81 06 	sts	0x0681, r24	; 0x800681 <__TEXT_REGION_LENGTH__+0x700681>
     420:	08 95       	ret

00000422 <mcu_init>:

/* configure pins and initialize registers */
void DAC_initialization(void)
{

	DAC_init();
     422:	e0 e1       	ldi	r30, 0x10	; 16
     424:	f4 e0       	ldi	r31, 0x04	; 4
     426:	80 81       	ld	r24, Z
     428:	88 60       	ori	r24, 0x08	; 8
     42a:	81 93       	st	Z+, r24
     42c:	e8 31       	cpi	r30, 0x18	; 24
     42e:	84 e0       	ldi	r24, 0x04	; 4
     430:	f8 07       	cpc	r31, r24
     432:	c9 f7       	brne	.-14     	; 0x426 <mcu_init+0x4>
     434:	e0 e3       	ldi	r30, 0x30	; 48
     436:	f4 e0       	ldi	r31, 0x04	; 4
     438:	80 81       	ld	r24, Z
     43a:	88 60       	ori	r24, 0x08	; 8
     43c:	81 93       	st	Z+, r24
     43e:	e8 33       	cpi	r30, 0x38	; 56
     440:	84 e0       	ldi	r24, 0x04	; 4
     442:	f8 07       	cpc	r31, r24
     444:	c9 f7       	brne	.-14     	; 0x438 <mcu_init+0x16>
     446:	e0 e5       	ldi	r30, 0x50	; 80
     448:	f4 e0       	ldi	r31, 0x04	; 4
     44a:	80 81       	ld	r24, Z
     44c:	88 60       	ori	r24, 0x08	; 8
     44e:	81 93       	st	Z+, r24
     450:	e8 35       	cpi	r30, 0x58	; 88
     452:	84 e0       	ldi	r24, 0x04	; 4
     454:	f8 07       	cpc	r31, r24
     456:	c9 f7       	brne	.-14     	; 0x44a <mcu_init+0x28>
     458:	08 95       	ret

0000045a <ADC_initialization>:
     45a:	e5 e1       	ldi	r30, 0x15	; 21
     45c:	f4 e0       	ldi	r31, 0x04	; 4
     45e:	80 81       	ld	r24, Z
     460:	88 7f       	andi	r24, 0xF8	; 248
     462:	84 60       	ori	r24, 0x04	; 4
     464:	80 83       	st	Z, r24
     466:	80 81       	ld	r24, Z
     468:	87 7f       	andi	r24, 0xF7	; 247
     46a:	80 83       	st	Z, r24
     46c:	e7 e1       	ldi	r30, 0x17	; 23
     46e:	f4 e0       	ldi	r31, 0x04	; 4
     470:	80 81       	ld	r24, Z
     472:	88 7f       	andi	r24, 0xF8	; 248
     474:	84 60       	ori	r24, 0x04	; 4
     476:	80 83       	st	Z, r24
     478:	80 81       	ld	r24, Z
     47a:	87 7f       	andi	r24, 0xF7	; 247
     47c:	80 83       	st	Z, r24
     47e:	e4 e3       	ldi	r30, 0x34	; 52
     480:	f4 e0       	ldi	r31, 0x04	; 4
     482:	80 81       	ld	r24, Z
     484:	88 7f       	andi	r24, 0xF8	; 248
     486:	84 60       	ori	r24, 0x04	; 4
     488:	80 83       	st	Z, r24
     48a:	80 81       	ld	r24, Z
     48c:	87 7f       	andi	r24, 0xF7	; 247
     48e:	80 83       	st	Z, r24
     490:	e1 e3       	ldi	r30, 0x31	; 49
     492:	f4 e0       	ldi	r31, 0x04	; 4
     494:	80 81       	ld	r24, Z
     496:	88 7f       	andi	r24, 0xF8	; 248
     498:	84 60       	ori	r24, 0x04	; 4
     49a:	80 83       	st	Z, r24
     49c:	80 81       	ld	r24, Z
     49e:	87 7f       	andi	r24, 0xF7	; 247
     4a0:	80 83       	st	Z, r24
     4a2:	e0 e3       	ldi	r30, 0x30	; 48
     4a4:	f4 e0       	ldi	r31, 0x04	; 4
     4a6:	80 81       	ld	r24, Z
     4a8:	88 7f       	andi	r24, 0xF8	; 248
     4aa:	84 60       	ori	r24, 0x04	; 4
     4ac:	80 83       	st	Z, r24
     4ae:	80 81       	ld	r24, Z
     4b0:	87 7f       	andi	r24, 0xF7	; 247
     4b2:	80 83       	st	Z, r24
     4b4:	75 df       	rcall	.-278    	; 0x3a0 <ADC_init>
     4b6:	08 95       	ret

000004b8 <TIMER_0_initialization>:
     4b8:	25 9a       	sbi	0x04, 5	; 4
     4ba:	2d 98       	cbi	0x05, 5	; 5
     4bc:	e0 e0       	ldi	r30, 0x00	; 0
     4be:	f2 e0       	ldi	r31, 0x02	; 2
     4c0:	82 81       	ldd	r24, Z+2	; 0x02
     4c2:	84 60       	ori	r24, 0x04	; 4
     4c4:	82 83       	std	Z+2, r24	; 0x02
     4c6:	54 d0       	rcall	.+168    	; 0x570 <TIMER_0_init>
     4c8:	08 95       	ret

000004ca <DIGGSIGG_initialization>:
     4ca:	41 9a       	sbi	0x08, 1	; 8
     4cc:	49 98       	cbi	0x09, 1	; 9
     4ce:	e0 e0       	ldi	r30, 0x00	; 0
     4d0:	f2 e0       	ldi	r31, 0x02	; 2
     4d2:	80 81       	ld	r24, Z
     4d4:	80 62       	ori	r24, 0x20	; 32
     4d6:	80 83       	st	Z, r24
     4d8:	7f df       	rcall	.-258    	; 0x3d8 <DIGGSIGG_init>
     4da:	08 95       	ret

000004dc <SPI_0_initialization>:
     4dc:	02 98       	cbi	0x00, 2	; 0
     4de:	e2 e1       	ldi	r30, 0x12	; 18
     4e0:	f4 e0       	ldi	r31, 0x04	; 4
     4e2:	80 81       	ld	r24, Z
     4e4:	87 7f       	andi	r24, 0xF7	; 247
     4e6:	80 83       	st	Z, r24
     4e8:	01 9a       	sbi	0x00, 1	; 0
     4ea:	09 98       	cbi	0x01, 1	; 1
     4ec:	03 9a       	sbi	0x00, 3	; 0
     4ee:	0b 98       	cbi	0x01, 3	; 1
     4f0:	04 9a       	sbi	0x00, 4	; 0
     4f2:	0c 98       	cbi	0x01, 4	; 1
     4f4:	35 d0       	rcall	.+106    	; 0x560 <SPI_0_init>
     4f6:	08 95       	ret

000004f8 <system_init>:
/**
 * \brief System initialization
 */
void system_init()
{
	mcu_init();
     4f8:	94 df       	rcall	.-216    	; 0x422 <mcu_init>
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     4fa:	27 9a       	sbi	0x04, 7	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     4fc:	2f 98       	cbi	0x05, 7	; 5
 */
static inline void PORTC_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
     4fe:	42 98       	cbi	0x08, 2	; 8
static inline void PORTC_set_pin_pull_mode(const uint8_t pin, const enum port_pull_mode pull_mode)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
     500:	e2 e5       	ldi	r30, 0x52	; 82
     502:	f4 e0       	ldi	r31, 0x04	; 4
     504:	80 81       	ld	r24, Z
     506:	88 60       	ori	r24, 0x08	; 8
     508:	80 83       	st	Z, r24
	    // <id> pad_pull_config
	    // <PORT_PULL_OFF"> Off
	    // <PORT_PULL_UP"> Pull-up
	    PORT_PULL_UP);

	CLKCTRL_init();
     50a:	74 df       	rcall	.-280    	; 0x3f4 <CLKCTRL_init>

	RTC_init();
     50c:	0d d0       	rcall	.+26     	; 0x528 <RTC_init>

	ADC_initialization();
     50e:	a5 df       	rcall	.-182    	; 0x45a <ADC_initialization>

	TIMER_0_initialization();
     510:	d3 df       	rcall	.-90     	; 0x4b8 <TIMER_0_initialization>

	DIGGSIGG_initialization();
     512:	db df       	rcall	.-74     	; 0x4ca <DIGGSIGG_initialization>

	SPI_0_initialization();
     514:	e3 df       	rcall	.-58     	; 0x4dc <SPI_0_initialization>

/* configure pins and initialize registers */
void DAC_initialization(void)
{

	DAC_init();
     516:	7d df       	rcall	.-262    	; 0x412 <DAC_init>

	SPI_0_initialization();

	DAC_initialization();

	CPUINT_init();
     518:	79 df       	rcall	.-270    	; 0x40c <CPUINT_init>

	SLPCTRL_init();
     51a:	20 d0       	rcall	.+64     	; 0x55c <SLPCTRL_init>

	BOD_init();
     51c:	5b df       	rcall	.-330    	; 0x3d4 <BOD_init>
     51e:	08 95       	ret

00000520 <protected_write_io>:
#if defined(__GNUC__)
  
#ifdef RAMPZ
	out     _SFR_IO_ADDR(RAMPZ), r1         // Clear bits 23:16 of Z
#endif
	movw    r30, r24                // Load addr into Z
     520:	fc 01       	movw	r30, r24
	out     CCP, r22                // Start CCP handshake
     522:	64 bf       	out	0x34, r22	; 52
	st      Z, r20                  // Write value to I/O register
     524:	40 83       	st	Z, r20
	ret                             // Return to caller
     526:	08 95       	ret

00000528 <RTC_init>:
 * \return Initialization status.
 */
int8_t RTC_init()
{

	while (RTC.STATUS > 0) { /* Wait for all register to be synchronized */
     528:	e0 e4       	ldi	r30, 0x40	; 64
     52a:	f1 e0       	ldi	r31, 0x01	; 1
     52c:	81 81       	ldd	r24, Z+1	; 0x01
     52e:	81 11       	cpse	r24, r1
     530:	fd cf       	rjmp	.-6      	; 0x52c <RTC_init+0x4>
	}

	// RTC.CMP = 0x0; /* Compare: 0x0 */

	RTC.CNT = 0x20; /* Counter: 0x20 */
     532:	e0 e4       	ldi	r30, 0x40	; 64
     534:	f1 e0       	ldi	r31, 0x01	; 1
     536:	80 e2       	ldi	r24, 0x20	; 32
     538:	90 e0       	ldi	r25, 0x00	; 0
     53a:	80 87       	std	Z+8, r24	; 0x08
     53c:	91 87       	std	Z+9, r25	; 0x09

	RTC.CTRLA = RTC_PRESCALER_DIV1_gc   /* 1 */
     53e:	21 e8       	ldi	r18, 0x81	; 129
     540:	20 83       	st	Z, r18
	            | 1 << RTC_RTCEN_bp     /* Enable: enabled */
	            | 1 << RTC_RUNSTDBY_bp; /* Run In Standby: enabled */

	RTC.PER = 0x20; /* Period: 0x20 */
     542:	82 87       	std	Z+10, r24	; 0x0a
     544:	93 87       	std	Z+11, r25	; 0x0b

	// RTC.CLKSEL = RTC_CLKSEL_INT32K_gc; /* 32KHz Internal Ultra Low Power Oscillator (OSCULP32K) */

	RTC.DBGCTRL = 1 << RTC_DBGRUN_bp; /* Run in debug: enabled */
     546:	81 e0       	ldi	r24, 0x01	; 1
     548:	85 83       	std	Z+5, r24	; 0x05

	RTC.INTCTRL = 0 << RTC_CMP_bp    /* Compare Match Interrupt enable: disabled */
     54a:	82 83       	std	Z+2, r24	; 0x02
	              | 1 << RTC_OVF_bp; /* Overflow Interrupt enable: enabled */

	while (RTC.PITSTATUS > 0) { /* Wait for all register to be synchronized */
     54c:	81 89       	ldd	r24, Z+17	; 0x11
     54e:	81 11       	cpse	r24, r1
     550:	fd cf       	rjmp	.-6      	; 0x54c <RTC_init+0x24>
	}

	RTC.PITCTRLA = RTC_PERIOD_OFF_gc    /* Off */
     552:	81 e0       	ldi	r24, 0x01	; 1
     554:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <__TEXT_REGION_LENGTH__+0x700150>
	// RTC.PITDBGCTRL = 0 << RTC_DBGRUN_bp; /* Run in debug: disabled */

	// RTC.PITINTCTRL = 0 << RTC_PI_bp; /* Periodic Interrupt: disabled */

	return 0;
}
     558:	80 e0       	ldi	r24, 0x00	; 0
     55a:	08 95       	ret

0000055c <SLPCTRL_init>:

	// SLPCTRL.CTRLA = 0 << SLPCTRL_SEN_bp /* Sleep enable: disabled */
	//		 | SLPCTRL_SMODE_IDLE_gc; /* Idle mode */

	return 0;
}
     55c:	80 e0       	ldi	r24, 0x00	; 0
     55e:	08 95       	ret

00000560 <SPI_0_init>:
 * \return Initialization status
 */
int8_t SPI_0_init()
{

	SPI0.CTRLA = 0 << SPI_CLK2X_bp     /* Enable Double Speed: disabled */
     560:	e0 e2       	ldi	r30, 0x20	; 32
     562:	f8 e0       	ldi	r31, 0x08	; 8
     564:	83 e2       	ldi	r24, 0x23	; 35
     566:	80 83       	st	Z, r24
	             | 0 << SPI_DORD_bp    /* Data Order Setting: disabled */
	             | 1 << SPI_ENABLE_bp  /* Enable Module: enabled */
	             | 1 << SPI_MASTER_bp  /* SPI module in master mode */
	             | SPI_PRESC_DIV16_gc; /* System Clock / 16 */

	SPI0.CTRLB = 0 << SPI_BUFEN_bp   /* Buffer Mode Enable: disabled */
     568:	84 e0       	ldi	r24, 0x04	; 4
     56a:	81 83       	std	Z+1, r24	; 0x01
	//		 | 0 << SPI_RXCIE_bp /* Receive Complete Interrupt Enable: disabled */
	//		 | 0 << SPI_SSIE_bp /* Slave Select Trigger Interrupt Enable: disabled */
	//		 | 0 << SPI_TXCIE_bp; /* Transfer Complete Interrupt Enable: disabled */

	return 0;
}
     56c:	80 e0       	ldi	r24, 0x00	; 0
     56e:	08 95       	ret

00000570 <TIMER_0_init>:

	// TCA0.SINGLE.CMP0 = 0x0; /* Compare Register 0: 0x0 */

	// TCA0.SINGLE.CMP1 = 0x0; /* Compare Register 1: 0x0 */

	TCA0.SINGLE.CMP2 = 0x4; /* Compare Register 2: 0x4 */
     570:	e0 e0       	ldi	r30, 0x00	; 0
     572:	fa e0       	ldi	r31, 0x0A	; 10
     574:	84 e0       	ldi	r24, 0x04	; 4
     576:	90 e0       	ldi	r25, 0x00	; 0
     578:	84 a7       	std	Z+44, r24	; 0x2c
     57a:	95 a7       	std	Z+45, r25	; 0x2d

	// TCA0.SINGLE.CNT = 0x0; /* Count: 0x0 */

	TCA0.SINGLE.CTRLB = 0 << TCA_SINGLE_ALUPD_bp            /* Auto Lock Update: disabled */
     57c:	83 e4       	ldi	r24, 0x43	; 67
     57e:	81 83       	std	Z+1, r24	; 0x01
	                    | 0 << TCA_SINGLE_CMP0EN_bp         /* Compare 0 Enable: disabled */
	                    | 0 << TCA_SINGLE_CMP1EN_bp         /* Compare 1 Enable: disabled */
	                    | 1 << TCA_SINGLE_CMP2EN_bp         /* Compare 2 Enable: enabled */
	                    | TCA_SINGLE_WGMODE_SINGLESLOPE_gc; /*  */

	TCA0.SINGLE.CTRLC = 0 << TCA_SINGLE_CMP0OV_bp    /* Compare 0 Waveform Output Value: disabled */
     580:	84 e0       	ldi	r24, 0x04	; 4
     582:	82 83       	std	Z+2, r24	; 0x02
	// TCA0.SINGLE.INTCTRL = 0 << TCA_SINGLE_CMP0_bp /* Compare 0 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP1_bp /* Compare 1 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP2_bp /* Compare 2 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_OVF_bp; /* Overflow Interrupt: disabled */

	TCA0.SINGLE.PER = 0x7; /* Period: 0x7 */
     584:	87 e0       	ldi	r24, 0x07	; 7
     586:	90 e0       	ldi	r25, 0x00	; 0
     588:	86 a3       	std	Z+38, r24	; 0x26
     58a:	97 a3       	std	Z+39, r25	; 0x27

	// TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV1_gc /* System Clock */
	//		 | 0 << TCA_SINGLE_ENABLE_bp; /* Module Enable: disabled */

	return 0;
}
     58c:	80 e0       	ldi	r24, 0x00	; 0
     58e:	08 95       	ret

00000590 <tinyCCLRGB_SPIWriteByte>:
Function used to send a byte over SPI, which in turn gets
translated to the bit-sequence required by the LEDs over the CCL.
*/
static void tinyCCLRGB_SPIWriteByte(uint8_t byte)
{
	SPI0.INTFLAGS = SPI0_INTFLAGS; // clear the write collision flag to allow writing
     590:	90 91 23 08 	lds	r25, 0x0823	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
     594:	90 93 23 08 	sts	0x0823, r25	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
	TCA0.SINGLE.CNT = 0; // reset TCA counter register to ensure the first rising edge of the PWM is predictable
     598:	e0 e0       	ldi	r30, 0x00	; 0
     59a:	fa e0       	ldi	r31, 0x0A	; 10
     59c:	10 a2       	std	Z+32, r1	; 0x20
     59e:	11 a2       	std	Z+33, r1	; 0x21
	
	// start TCA
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 1 << TCA_SPLIT_ENABLE_bp;
     5a0:	91 e0       	ldi	r25, 0x01	; 1
     5a2:	90 83       	st	Z, r25
	SPI0_DATA = byte;
     5a4:	80 93 24 08 	sts	0x0824, r24	; 0x800824 <__TEXT_REGION_LENGTH__+0x700824>

	while((SPI0.INTFLAGS & SPI_RXCIE_bm) == 0){} // wait for transfer to complete
     5a8:	e0 e2       	ldi	r30, 0x20	; 32
     5aa:	f8 e0       	ldi	r31, 0x08	; 8
     5ac:	83 81       	ldd	r24, Z+3	; 0x03
     5ae:	88 23       	and	r24, r24
     5b0:	ec f7       	brge	.-6      	; 0x5ac <tinyCCLRGB_SPIWriteByte+0x1c>
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 0 << TCA_SPLIT_ENABLE_bp; //Stop TCA
     5b2:	10 92 00 0a 	sts	0x0A00, r1	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
     5b6:	08 95       	ret

000005b8 <tinyCCLRGB_setColor>:
/*
changes the values in the variables stored in the led-array.
*/
void tinyCCLRGB_setColor(uint8_t led, uint8_t red, uint8_t green, uint8_t blue) 
{
	tinyCCLRGB_colors[led].red = red;
     5b8:	90 e0       	ldi	r25, 0x00	; 0
     5ba:	fc 01       	movw	r30, r24
     5bc:	ee 0f       	add	r30, r30
     5be:	ff 1f       	adc	r31, r31
     5c0:	8e 0f       	add	r24, r30
     5c2:	9f 1f       	adc	r25, r31
     5c4:	fc 01       	movw	r30, r24
     5c6:	e7 5e       	subi	r30, 0xE7	; 231
     5c8:	f1 4c       	sbci	r31, 0xC1	; 193
     5ca:	60 83       	st	Z, r22
	tinyCCLRGB_colors[led].green = green;
     5cc:	41 83       	std	Z+1, r20	; 0x01
	tinyCCLRGB_colors[led].blue = blue;
     5ce:	22 83       	std	Z+2, r18	; 0x02
     5d0:	08 95       	ret

000005d2 <tinyCCLRGB_uploadColorsToLeds>:
/*
function to write the current LED-array on to the LEDs and
effectively update the values stored in the LEDs to the values stored in the MCU.
*/
void tinyCCLRGB_uploadColorsToLeds(void)
{
     5d2:	0f 93       	push	r16
     5d4:	1f 93       	push	r17
     5d6:	cf 93       	push	r28
     5d8:	df 93       	push	r29
     5da:	c9 e1       	ldi	r28, 0x19	; 25
     5dc:	de e3       	ldi	r29, 0x3E	; 62
     5de:	0b e2       	ldi	r16, 0x2B	; 43
     5e0:	1e e3       	ldi	r17, 0x3E	; 62
	for (uint8_t i = 0; i < TINYCCLRGB_LEDCOUNT; i++)
	{
		//For some reason unknown to the writer the data-bus to the LEDs is serialized as GRB
		//which means the 24-bit data-bus will look like [Green[0:7], Red[0:7], Blue[0:7]]
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].green);
     5e2:	89 81       	ldd	r24, Y+1	; 0x01
     5e4:	d5 df       	rcall	.-86     	; 0x590 <tinyCCLRGB_SPIWriteByte>
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].red);
     5e6:	88 81       	ld	r24, Y
     5e8:	d3 df       	rcall	.-90     	; 0x590 <tinyCCLRGB_SPIWriteByte>
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].blue);
     5ea:	8a 81       	ldd	r24, Y+2	; 0x02
     5ec:	d1 df       	rcall	.-94     	; 0x590 <tinyCCLRGB_SPIWriteByte>
     5ee:	23 96       	adiw	r28, 0x03	; 3
function to write the current LED-array on to the LEDs and
effectively update the values stored in the LEDs to the values stored in the MCU.
*/
void tinyCCLRGB_uploadColorsToLeds(void)
{
	for (uint8_t i = 0; i < TINYCCLRGB_LEDCOUNT; i++)
     5f0:	c0 17       	cp	r28, r16
     5f2:	d1 07       	cpc	r29, r17
     5f4:	b1 f7       	brne	.-20     	; 0x5e2 <tinyCCLRGB_uploadColorsToLeds+0x10>
		//which means the 24-bit data-bus will look like [Green[0:7], Red[0:7], Blue[0:7]]
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].green);
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].red);
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].blue);
	}
}
     5f6:	df 91       	pop	r29
     5f8:	cf 91       	pop	r28
     5fa:	1f 91       	pop	r17
     5fc:	0f 91       	pop	r16
     5fe:	08 95       	ret

00000600 <tiny_DAC_axon_queue_fire_time>:
Adds an element to the queue of axon pulse times.
The variable new_fire_time sets the time of when the axon should fire.
*/
static void tiny_DAC_axon_queue_fire_time(uint32_t new_fire_time)
{
	if (pulses_in_queue < 4)
     600:	e0 91 3c 3e 	lds	r30, 0x3E3C	; 0x803e3c <pulses_in_queue>
     604:	e4 30       	cpi	r30, 0x04	; 4
     606:	70 f4       	brcc	.+28     	; 0x624 <tiny_DAC_axon_queue_fire_time+0x24>
	{
		pulses_in_queue++;
     608:	ef 5f       	subi	r30, 0xFF	; 255
     60a:	e0 93 3c 3e 	sts	0x3E3C, r30	; 0x803e3c <pulses_in_queue>
		axon_pulse_time_queue[pulses_in_queue-1] = new_fire_time;
     60e:	f0 e0       	ldi	r31, 0x00	; 0
     610:	ee 0f       	add	r30, r30
     612:	ff 1f       	adc	r31, r31
     614:	ee 0f       	add	r30, r30
     616:	ff 1f       	adc	r31, r31
     618:	e8 5d       	subi	r30, 0xD8	; 216
     61a:	f1 4c       	sbci	r31, 0xC1	; 193
     61c:	60 83       	st	Z, r22
     61e:	71 83       	std	Z+1, r23	; 0x01
     620:	82 83       	std	Z+2, r24	; 0x02
     622:	93 83       	std	Z+3, r25	; 0x03
     624:	08 95       	ret

00000626 <tiny_DAC_set_neuron_type>:
sets neuron type, should probably be accessible from the master function
of the entire neuron, maybe I'm wrong though.
*/
void tiny_DAC_set_neuron_type(enum NeuronType neuron_type) // Make into enum
{
	this_neurons_type = neuron_type;
     626:	91 e0       	ldi	r25, 0x01	; 1
     628:	81 11       	cpse	r24, r1
     62a:	01 c0       	rjmp	.+2      	; 0x62e <tiny_DAC_set_neuron_type+0x8>
     62c:	90 e0       	ldi	r25, 0x00	; 0
     62e:	90 93 3d 3e 	sts	0x3E3D, r25	; 0x803e3d <this_neurons_type>
     632:	08 95       	ret

00000634 <tiny_DAC_axon_neg_pulse_queue_check>:
/*
solution to remove future firing if a inhibitory signal is received
shortly after a excitatory signal.
*/
bool tiny_DAC_axon_neg_pulse_queue_check(void)
{
     634:	cf 92       	push	r12
     636:	df 92       	push	r13
     638:	ef 92       	push	r14
     63a:	ff 92       	push	r15
     63c:	0f 93       	push	r16
     63e:	1f 93       	push	r17
     640:	cf 93       	push	r28
     642:	df 93       	push	r29
     644:	cc e2       	ldi	r28, 0x2C	; 44
     646:	de e3       	ldi	r29, 0x3E	; 62
     648:	10 e0       	ldi	r17, 0x00	; 0
	uint8_t element = 5;
     64a:	05 e0       	ldi	r16, 0x05	; 5
	for(int i = 0; i < 4; i++)
	{
		if ((ISR_timer_count()+60) < axon_pulse_time_queue[i])
     64c:	39 dd       	rcall	.-1422   	; 0xc0 <ISR_timer_count>
     64e:	c9 90       	ld	r12, Y+
     650:	d9 90       	ld	r13, Y+
     652:	e9 90       	ld	r14, Y+
     654:	f9 90       	ld	r15, Y+
     656:	dc 01       	movw	r26, r24
     658:	cb 01       	movw	r24, r22
     65a:	cc 96       	adiw	r24, 0x3c	; 60
     65c:	a1 1d       	adc	r26, r1
     65e:	b1 1d       	adc	r27, r1
     660:	8c 15       	cp	r24, r12
     662:	9d 05       	cpc	r25, r13
     664:	ae 05       	cpc	r26, r14
     666:	bf 05       	cpc	r27, r15
     668:	08 f4       	brcc	.+2      	; 0x66c <tiny_DAC_axon_neg_pulse_queue_check+0x38>
		{
			element = i;
     66a:	01 2f       	mov	r16, r17
     66c:	1f 5f       	subi	r17, 0xFF	; 255
shortly after a excitatory signal.
*/
bool tiny_DAC_axon_neg_pulse_queue_check(void)
{
	uint8_t element = 5;
	for(int i = 0; i < 4; i++)
     66e:	14 30       	cpi	r17, 0x04	; 4
     670:	69 f7       	brne	.-38     	; 0x64c <tiny_DAC_axon_neg_pulse_queue_check+0x18>
		if ((ISR_timer_count()+60) < axon_pulse_time_queue[i])
		{
			element = i;
		}
	}
	if(element != 5)
     672:	05 30       	cpi	r16, 0x05	; 5
     674:	99 f0       	breq	.+38     	; 0x69c <tiny_DAC_axon_neg_pulse_queue_check+0x68>
	{
		axon_pulse_time_queue[element] = 0;
     676:	e0 2f       	mov	r30, r16
     678:	f0 e0       	ldi	r31, 0x00	; 0
     67a:	ee 0f       	add	r30, r30
     67c:	ff 1f       	adc	r31, r31
     67e:	ee 0f       	add	r30, r30
     680:	ff 1f       	adc	r31, r31
     682:	e4 5d       	subi	r30, 0xD4	; 212
     684:	f1 4c       	sbci	r31, 0xC1	; 193
     686:	10 82       	st	Z, r1
     688:	11 82       	std	Z+1, r1	; 0x01
     68a:	12 82       	std	Z+2, r1	; 0x02
     68c:	13 82       	std	Z+3, r1	; 0x03
		pulses_in_queue--;
     68e:	80 91 3c 3e 	lds	r24, 0x3E3C	; 0x803e3c <pulses_in_queue>
     692:	81 50       	subi	r24, 0x01	; 1
     694:	80 93 3c 3e 	sts	0x3E3C, r24	; 0x803e3c <pulses_in_queue>
		return true;
     698:	81 e0       	ldi	r24, 0x01	; 1
     69a:	01 c0       	rjmp	.+2      	; 0x69e <tiny_DAC_axon_neg_pulse_queue_check+0x6a>
	}
	else
	{
		return false;
     69c:	80 e0       	ldi	r24, 0x00	; 0
	}
}
     69e:	df 91       	pop	r29
     6a0:	cf 91       	pop	r28
     6a2:	1f 91       	pop	r17
     6a4:	0f 91       	pop	r16
     6a6:	ff 90       	pop	r15
     6a8:	ef 90       	pop	r14
     6aa:	df 90       	pop	r13
     6ac:	cf 90       	pop	r12
     6ae:	08 95       	ret

000006b0 <tiny_DAC_axon_master_update>:
This will be functionally the same as required by specs.
Will look into updating if I find a more elegant solution to the problem
that's at least as effective as this one.
*/
void tiny_DAC_axon_master_update(_Bool over_25, _Bool over_50)
{
     6b0:	cf 92       	push	r12
     6b2:	df 92       	push	r13
     6b4:	ef 92       	push	r14
     6b6:	ff 92       	push	r15
	if(over_25 && over_50)
     6b8:	88 23       	and	r24, r24
     6ba:	a9 f0       	breq	.+42     	; 0x6e6 <tiny_DAC_axon_master_update+0x36>
     6bc:	66 23       	and	r22, r22
     6be:	69 f0       	breq	.+26     	; 0x6da <tiny_DAC_axon_master_update+0x2a>
	{
		tiny_DAC_axon_queue_fire_time(ISR_timer_count() + 100);
     6c0:	ff dc       	rcall	.-1538   	; 0xc0 <ISR_timer_count>
     6c2:	6c 59       	subi	r22, 0x9C	; 156
     6c4:	7f 4f       	sbci	r23, 0xFF	; 255
     6c6:	8f 4f       	sbci	r24, 0xFF	; 255
     6c8:	9f 4f       	sbci	r25, 0xFF	; 255
     6ca:	9a df       	rcall	.-204    	; 0x600 <tiny_DAC_axon_queue_fire_time>
		tiny_DAC_axon_queue_fire_time(ISR_timer_count() + 150);//hacky solution to add 2 firing pulses in case of very high received potential.
     6cc:	f9 dc       	rcall	.-1550   	; 0xc0 <ISR_timer_count>
     6ce:	6a 56       	subi	r22, 0x6A	; 106
     6d0:	7f 4f       	sbci	r23, 0xFF	; 255
     6d2:	8f 4f       	sbci	r24, 0xFF	; 255
     6d4:	9f 4f       	sbci	r25, 0xFF	; 255
     6d6:	94 df       	rcall	.-216    	; 0x600 <tiny_DAC_axon_queue_fire_time>
     6d8:	06 c0       	rjmp	.+12     	; 0x6e6 <tiny_DAC_axon_master_update+0x36>
	}
	else if (over_25)
	{
		tiny_DAC_axon_queue_fire_time(ISR_timer_count()+100);
     6da:	f2 dc       	rcall	.-1564   	; 0xc0 <ISR_timer_count>
     6dc:	6c 59       	subi	r22, 0x9C	; 156
     6de:	7f 4f       	sbci	r23, 0xFF	; 255
     6e0:	8f 4f       	sbci	r24, 0xFF	; 255
     6e2:	9f 4f       	sbci	r25, 0xFF	; 255
     6e4:	8d df       	rcall	.-230    	; 0x600 <tiny_DAC_axon_queue_fire_time>
	}
	if ((pulses_in_queue > 0) && (axon_pulse_time_queue[0] < ISR_timer_count()))
     6e6:	80 91 3c 3e 	lds	r24, 0x3E3C	; 0x803e3c <pulses_in_queue>
     6ea:	88 23       	and	r24, r24
     6ec:	a9 f1       	breq	.+106    	; 0x758 <tiny_DAC_axon_master_update+0xa8>
     6ee:	c0 90 2c 3e 	lds	r12, 0x3E2C	; 0x803e2c <axon_pulse_time_queue>
     6f2:	d0 90 2d 3e 	lds	r13, 0x3E2D	; 0x803e2d <axon_pulse_time_queue+0x1>
     6f6:	e0 90 2e 3e 	lds	r14, 0x3E2E	; 0x803e2e <axon_pulse_time_queue+0x2>
     6fa:	f0 90 2f 3e 	lds	r15, 0x3E2F	; 0x803e2f <axon_pulse_time_queue+0x3>
     6fe:	e0 dc       	rcall	.-1600   	; 0xc0 <ISR_timer_count>
     700:	c6 16       	cp	r12, r22
     702:	d7 06       	cpc	r13, r23
     704:	e8 06       	cpc	r14, r24
     706:	f9 06       	cpc	r15, r25
     708:	38 f5       	brcc	.+78     	; 0x758 <tiny_DAC_axon_master_update+0xa8>
Function to set firing.
Function also updates the pulse queue accordingly.
*/
static void tiny_DAC_axon_set_fire()
{
	tiny_DAC_axon_fire = true;
     70a:	81 e0       	ldi	r24, 0x01	; 1
     70c:	80 93 3e 3e 	sts	0x3E3E, r24	; 0x803e3e <tiny_DAC_axon_fire>
	pulses_in_queue--;
     710:	80 91 3c 3e 	lds	r24, 0x3E3C	; 0x803e3c <pulses_in_queue>
     714:	81 50       	subi	r24, 0x01	; 1
     716:	80 93 3c 3e 	sts	0x3E3C, r24	; 0x803e3c <pulses_in_queue>
	axon_pulse_time_queue[0] = axon_pulse_time_queue[1];
     71a:	ec e2       	ldi	r30, 0x2C	; 44
     71c:	fe e3       	ldi	r31, 0x3E	; 62
     71e:	84 81       	ldd	r24, Z+4	; 0x04
     720:	95 81       	ldd	r25, Z+5	; 0x05
     722:	a6 81       	ldd	r26, Z+6	; 0x06
     724:	b7 81       	ldd	r27, Z+7	; 0x07
     726:	80 83       	st	Z, r24
     728:	91 83       	std	Z+1, r25	; 0x01
     72a:	a2 83       	std	Z+2, r26	; 0x02
     72c:	b3 83       	std	Z+3, r27	; 0x03
	axon_pulse_time_queue[1] = axon_pulse_time_queue[2];
     72e:	80 85       	ldd	r24, Z+8	; 0x08
     730:	91 85       	ldd	r25, Z+9	; 0x09
     732:	a2 85       	ldd	r26, Z+10	; 0x0a
     734:	b3 85       	ldd	r27, Z+11	; 0x0b
     736:	84 83       	std	Z+4, r24	; 0x04
     738:	95 83       	std	Z+5, r25	; 0x05
     73a:	a6 83       	std	Z+6, r26	; 0x06
     73c:	b7 83       	std	Z+7, r27	; 0x07
	axon_pulse_time_queue[2] = axon_pulse_time_queue[3];
     73e:	84 85       	ldd	r24, Z+12	; 0x0c
     740:	95 85       	ldd	r25, Z+13	; 0x0d
     742:	a6 85       	ldd	r26, Z+14	; 0x0e
     744:	b7 85       	ldd	r27, Z+15	; 0x0f
     746:	80 87       	std	Z+8, r24	; 0x08
     748:	91 87       	std	Z+9, r25	; 0x09
     74a:	a2 87       	std	Z+10, r26	; 0x0a
     74c:	b3 87       	std	Z+11, r27	; 0x0b
	axon_pulse_time_queue[3] = 0;
     74e:	14 86       	std	Z+12, r1	; 0x0c
     750:	15 86       	std	Z+13, r1	; 0x0d
     752:	16 86       	std	Z+14, r1	; 0x0e
     754:	17 86       	std	Z+15, r1	; 0x0f
		tiny_DAC_axon_queue_fire_time(ISR_timer_count()+100);
	}
	if ((pulses_in_queue > 0) && (axon_pulse_time_queue[0] < ISR_timer_count()))
	{
		tiny_DAC_axon_set_fire();
		set_LED_fire();
     756:	e3 dc       	rcall	.-1594   	; 0x11e <set_LED_fire>
The function should set the DAC to fire for two
update cycles once the pulse flag is set high.
*/
static void tiny_DAC_update_axon(void)
{
	if (tiny_DAC_axon_fire)
     758:	80 91 3e 3e 	lds	r24, 0x3E3E	; 0x803e3e <tiny_DAC_axon_fire>
     75c:	88 23       	and	r24, r24
     75e:	b9 f0       	breq	.+46     	; 0x78e <tiny_DAC_axon_master_update+0xde>
	{
		tiny_DAC_axon_fire = false;
     760:	10 92 3e 3e 	sts	0x3E3E, r1	; 0x803e3e <tiny_DAC_axon_fire>
Pulse send function.
sends a pulse dependent on the neurons type.
*/
static void tiny_DAC_axon_send_pulse(void)
{
	if (this_neurons_type == EXCITATORY_NEURON)
     764:	80 91 3d 3e 	lds	r24, 0x3E3D	; 0x803e3d <this_neurons_type>
     768:	81 11       	cpse	r24, r1
     76a:	07 c0       	rjmp	.+14     	; 0x77a <tiny_DAC_axon_master_update+0xca>
	{
		DAC_set_output(255);
     76c:	8f ef       	ldi	r24, 0xFF	; 255
     76e:	90 e0       	ldi	r25, 0x00	; 0
     770:	55 de       	rcall	.-854    	; 0x41c <DAC_set_output>
		axonOutputValue=225;
     772:	81 ee       	ldi	r24, 0xE1	; 225
     774:	80 93 2b 3e 	sts	0x3E2B, r24	; 0x803e2b <axonOutputValue>
     778:	06 c0       	rjmp	.+12     	; 0x786 <tiny_DAC_axon_master_update+0xd6>
	}
	else if(this_neurons_type == INHIBITORY_NEURON)
	{
		DAC_set_output(128);
     77a:	80 e8       	ldi	r24, 0x80	; 128
     77c:	90 e0       	ldi	r25, 0x00	; 0
     77e:	4e de       	rcall	.-868    	; 0x41c <DAC_set_output>
		axonOutputValue=128;
     780:	80 e8       	ldi	r24, 0x80	; 128
     782:	80 93 2b 3e 	sts	0x3E2B, r24	; 0x803e2b <axonOutputValue>
{
	if (tiny_DAC_axon_fire)
	{
		tiny_DAC_axon_fire = false;
		tiny_DAC_axon_send_pulse();
		tiny_DAC_axon_prev = true;
     786:	81 e0       	ldi	r24, 0x01	; 1
     788:	80 93 3f 3e 	sts	0x3E3F, r24	; 0x803e3f <tiny_DAC_axon_prev>
     78c:	0c c0       	rjmp	.+24     	; 0x7a6 <tiny_DAC_axon_master_update+0xf6>
	}
	else if (tiny_DAC_axon_prev)
     78e:	80 91 3f 3e 	lds	r24, 0x3E3F	; 0x803e3f <tiny_DAC_axon_prev>
     792:	88 23       	and	r24, r24
     794:	19 f0       	breq	.+6      	; 0x79c <tiny_DAC_axon_master_update+0xec>
	{
		tiny_DAC_axon_prev = false;
     796:	10 92 3f 3e 	sts	0x3E3F, r1	; 0x803e3f <tiny_DAC_axon_prev>
     79a:	05 c0       	rjmp	.+10     	; 0x7a6 <tiny_DAC_axon_master_update+0xf6>
	}
	else if (!tiny_DAC_axon_prev && !tiny_DAC_axon_fire)
	{
		DAC_set_output(0);
     79c:	80 e0       	ldi	r24, 0x00	; 0
     79e:	90 e0       	ldi	r25, 0x00	; 0
     7a0:	3d de       	rcall	.-902    	; 0x41c <DAC_set_output>
		axonOutputValue=0;
     7a2:	10 92 2b 3e 	sts	0x3E2B, r1	; 0x803e2b <axonOutputValue>
	{
		tiny_DAC_axon_set_fire();
		set_LED_fire();
	}
	tiny_DAC_update_axon();
}
     7a6:	ff 90       	pop	r15
     7a8:	ef 90       	pop	r14
     7aa:	df 90       	pop	r13
     7ac:	cf 90       	pop	r12
     7ae:	08 95       	ret

000007b0 <tiny_ADC_dendrite_potential>:
/*
This is the master function of the module that is callable from
outside. It uses the previously declared functions to return the potential.
*/
int8_t tiny_ADC_dendrite_potential()
{
     7b0:	8f 92       	push	r8
     7b2:	9f 92       	push	r9
     7b4:	af 92       	push	r10
     7b6:	bf 92       	push	r11
     7b8:	cf 92       	push	r12
     7ba:	df 92       	push	r13
     7bc:	ef 92       	push	r14
     7be:	ff 92       	push	r15
     7c0:	0f 93       	push	r16
     7c2:	1f 93       	push	r17
     7c4:	cf 93       	push	r28
     7c6:	df 93       	push	r29
     7c8:	0f 2e       	mov	r0, r31
     7ca:	f0 e0       	ldi	r31, 0x00	; 0
     7cc:	ef 2e       	mov	r14, r31
     7ce:	fe e3       	ldi	r31, 0x3E	; 62
     7d0:	ff 2e       	mov	r15, r31
     7d2:	f0 2d       	mov	r31, r0
     7d4:	0a e4       	ldi	r16, 0x4A	; 74
     7d6:	1e e3       	ldi	r17, 0x3E	; 62
     7d8:	0f 2e       	mov	r0, r31
     7da:	f4 e5       	ldi	r31, 0x54	; 84
     7dc:	cf 2e       	mov	r12, r31
     7de:	fe e3       	ldi	r31, 0x3E	; 62
     7e0:	df 2e       	mov	r13, r31
     7e2:	f0 2d       	mov	r31, r0
     7e4:	e8 01       	movw	r28, r16
*/
static void tiny_ADC_dendrites_update_values(void)
{
	for (int i = 0; i < TINY_ADC_DENDRITE_COUNT; i++)
	{
		tiny_ADC_values[i] = ADC_get_conversion(dendrite_ports[i]);
     7e6:	f7 01       	movw	r30, r14
     7e8:	81 91       	ld	r24, Z+
     7ea:	7f 01       	movw	r14, r30
     7ec:	e2 dd       	rcall	.-1084   	; 0x3b2 <ADC_get_conversion>
     7ee:	89 93       	st	Y+, r24
     7f0:	99 93       	st	Y+, r25
/*
This function updates the vector containing 8-bit ADC conversions
*/
static void tiny_ADC_dendrites_update_values(void)
{
	for (int i = 0; i < TINY_ADC_DENDRITE_COUNT; i++)
     7f2:	cc 15       	cp	r28, r12
     7f4:	dd 05       	cpc	r29, r13
     7f6:	b9 f7       	brne	.-18     	; 0x7e6 <tiny_ADC_dendrite_potential+0x36>
     7f8:	a5 e4       	ldi	r26, 0x45	; 69
     7fa:	be e3       	ldi	r27, 0x3E	; 62
     7fc:	60 e4       	ldi	r22, 0x40	; 64
     7fe:	7e e3       	ldi	r23, 0x3E	; 62
     800:	4a e4       	ldi	r20, 0x4A	; 74
     802:	5e e3       	ldi	r21, 0x3E	; 62
     804:	fd 01       	movw	r30, r26
		{
			tiny_ADC_dendrite_cur_signals[i] = HIGH_INHIB;
		}
		else if (tiny_ADC_values[i] > 50)
		{
			tiny_ADC_dendrite_cur_signals[i] = LOW_INHIB;
     806:	aa 24       	eor	r10, r10
     808:	a3 94       	inc	r10
		{
			tiny_ADC_dendrite_cur_signals[i] = NORMAL_INHIB;
		}
		else if (tiny_ADC_values[i] > 87)
		{
			tiny_ADC_dendrite_cur_signals[i] = HIGH_INHIB;
     80a:	0f 2e       	mov	r0, r31
     80c:	f3 e0       	ldi	r31, 0x03	; 3
     80e:	bf 2e       	mov	r11, r31
     810:	f0 2d       	mov	r31, r0
		{
			tiny_ADC_dendrite_cur_signals[i] = LOW_EXCITE;
		}
		else if (tiny_ADC_values[i] > 114)
		{
			tiny_ADC_dendrite_cur_signals[i] = NORMAL_INHIB;
     812:	68 94       	set
     814:	cc 24       	eor	r12, r12
     816:	c1 f8       	bld	r12, 1
		{
			tiny_ADC_dendrite_cur_signals[i] = HIGH_EXCITE;
		}
		else if (tiny_ADC_values[i] > 139)
		{
			tiny_ADC_dendrite_cur_signals[i] = LOW_EXCITE;
     818:	68 94       	set
     81a:	dd 24       	eor	r13, r13
     81c:	d2 f8       	bld	r13, 2
		{
			tiny_ADC_dendrite_cur_signals[i] = NORMAL_EXCITE;
		}
		else if (tiny_ADC_values[i] > 160)
		{
			tiny_ADC_dendrite_cur_signals[i] = HIGH_EXCITE;
     81e:	0f 2e       	mov	r0, r31
     820:	f6 e0       	ldi	r31, 0x06	; 6
     822:	ef 2e       	mov	r14, r31
     824:	f0 2d       	mov	r31, r0
	for (uint8_t i = 0; i < TINY_ADC_DENDRITE_COUNT; i++)
	{
		tiny_ADC_dendrite_prev_signals[i] = tiny_ADC_dendrite_cur_signals[i];
		if (tiny_ADC_values[i] > 213)
		{
			tiny_ADC_dendrite_cur_signals[i] = NORMAL_EXCITE;
     826:	0f 2e       	mov	r0, r31
     828:	f5 e0       	ldi	r31, 0x05	; 5
     82a:	ff 2e       	mov	r15, r31
     82c:	f0 2d       	mov	r31, r0
     82e:	4f 01       	movw	r8, r30
*/
static void tiny_ADC_update_signal(void)
{
	for (uint8_t i = 0; i < TINY_ADC_DENDRITE_COUNT; i++)
	{
		tiny_ADC_dendrite_prev_signals[i] = tiny_ADC_dendrite_cur_signals[i];
     830:	80 81       	ld	r24, Z
     832:	eb 01       	movw	r28, r22
     834:	89 93       	st	Y+, r24
     836:	be 01       	movw	r22, r28
		if (tiny_ADC_values[i] > 213)
     838:	e8 01       	movw	r28, r16
     83a:	29 91       	ld	r18, Y+
     83c:	39 91       	ld	r19, Y+
     83e:	8e 01       	movw	r16, r28
     840:	26 3d       	cpi	r18, 0xD6	; 214
     842:	31 05       	cpc	r19, r1
     844:	10 f0       	brcs	.+4      	; 0x84a <tiny_ADC_dendrite_potential+0x9a>
		{
			tiny_ADC_dendrite_cur_signals[i] = NORMAL_EXCITE;
     846:	f0 82       	st	Z, r15
     848:	1a c0       	rjmp	.+52     	; 0x87e <tiny_ADC_dendrite_potential+0xce>
		}
		else if (tiny_ADC_values[i] > 160)
     84a:	21 3a       	cpi	r18, 0xA1	; 161
     84c:	31 05       	cpc	r19, r1
     84e:	10 f0       	brcs	.+4      	; 0x854 <tiny_ADC_dendrite_potential+0xa4>
		{
			tiny_ADC_dendrite_cur_signals[i] = HIGH_EXCITE;
     850:	e0 82       	st	Z, r14
     852:	15 c0       	rjmp	.+42     	; 0x87e <tiny_ADC_dendrite_potential+0xce>
		}
		else if (tiny_ADC_values[i] > 139)
     854:	2c 38       	cpi	r18, 0x8C	; 140
     856:	31 05       	cpc	r19, r1
     858:	10 f0       	brcs	.+4      	; 0x85e <tiny_ADC_dendrite_potential+0xae>
		{
			tiny_ADC_dendrite_cur_signals[i] = LOW_EXCITE;
     85a:	d0 82       	st	Z, r13
     85c:	10 c0       	rjmp	.+32     	; 0x87e <tiny_ADC_dendrite_potential+0xce>
		}
		else if (tiny_ADC_values[i] > 114)
     85e:	23 37       	cpi	r18, 0x73	; 115
     860:	31 05       	cpc	r19, r1
     862:	10 f0       	brcs	.+4      	; 0x868 <tiny_ADC_dendrite_potential+0xb8>
		{
			tiny_ADC_dendrite_cur_signals[i] = NORMAL_INHIB;
     864:	c0 82       	st	Z, r12
     866:	0b c0       	rjmp	.+22     	; 0x87e <tiny_ADC_dendrite_potential+0xce>
		}
		else if (tiny_ADC_values[i] > 87)
     868:	28 35       	cpi	r18, 0x58	; 88
     86a:	31 05       	cpc	r19, r1
     86c:	10 f0       	brcs	.+4      	; 0x872 <tiny_ADC_dendrite_potential+0xc2>
		{
			tiny_ADC_dendrite_cur_signals[i] = HIGH_INHIB;
     86e:	b0 82       	st	Z, r11
     870:	06 c0       	rjmp	.+12     	; 0x87e <tiny_ADC_dendrite_potential+0xce>
		}
		else if (tiny_ADC_values[i] > 50)
     872:	23 33       	cpi	r18, 0x33	; 51
     874:	31 05       	cpc	r19, r1
     876:	10 f0       	brcs	.+4      	; 0x87c <tiny_ADC_dendrite_potential+0xcc>
		{
			tiny_ADC_dendrite_cur_signals[i] = LOW_INHIB;
     878:	a0 82       	st	Z, r10
     87a:	01 c0       	rjmp	.+2      	; 0x87e <tiny_ADC_dendrite_potential+0xce>
		}
		else
		{
			tiny_ADC_dendrite_cur_signals[i] = NO_SIGNAL;
     87c:	10 82       	st	Z, r1
		}
		if (tiny_ADC_dendrite_cur_signals[i] == tiny_ADC_dendrite_prev_signals[i])
     87e:	e4 01       	movw	r28, r8
     880:	98 81       	ld	r25, Y
     882:	89 13       	cpse	r24, r25
     884:	01 c0       	rjmp	.+2      	; 0x888 <tiny_ADC_dendrite_potential+0xd8>
		{
			tiny_ADC_dendrite_cur_signals[i] = NO_SIGNAL;
     886:	18 82       	st	Y, r1
     888:	31 96       	adiw	r30, 0x01	; 1
The function also sets the vector for previous signals and takes into account that
if the same reading has been received twice in a row it should be no_signal.
*/
static void tiny_ADC_update_signal(void)
{
	for (uint8_t i = 0; i < TINY_ADC_DENDRITE_COUNT; i++)
     88a:	e4 17       	cp	r30, r20
     88c:	f5 07       	cpc	r31, r21
     88e:	79 f6       	brne	.-98     	; 0x82e <tiny_ADC_dendrite_potential+0x7e>
     890:	20 e0       	ldi	r18, 0x00	; 0
     892:	30 e0       	ldi	r19, 0x00	; 0
	tiny_ADC_update_signal();
	
	int16_t return_potential_val = 0;
	for (int i = 0; i < TINY_ADC_DENDRITE_COUNT; i++)
	{
		switch(tiny_ADC_dendrite_cur_signals[i])
     894:	9d 91       	ld	r25, X+
     896:	93 30       	cpi	r25, 0x03	; 3
     898:	a1 f0       	breq	.+40     	; 0x8c2 <tiny_ADC_dendrite_potential+0x112>
     89a:	28 f4       	brcc	.+10     	; 0x8a6 <tiny_ADC_dendrite_potential+0xf6>
     89c:	91 30       	cpi	r25, 0x01	; 1
     89e:	b1 f0       	breq	.+44     	; 0x8cc <tiny_ADC_dendrite_potential+0x11c>
     8a0:	92 30       	cpi	r25, 0x02	; 2
     8a2:	91 f0       	breq	.+36     	; 0x8c8 <tiny_ADC_dendrite_potential+0x118>
     8a4:	15 c0       	rjmp	.+42     	; 0x8d0 <tiny_ADC_dendrite_potential+0x120>
     8a6:	95 30       	cpi	r25, 0x05	; 5
     8a8:	31 f0       	breq	.+12     	; 0x8b6 <tiny_ADC_dendrite_potential+0x106>
     8aa:	40 f0       	brcs	.+16     	; 0x8bc <tiny_ADC_dendrite_potential+0x10c>
     8ac:	96 30       	cpi	r25, 0x06	; 6
     8ae:	81 f4       	brne	.+32     	; 0x8d0 <tiny_ADC_dendrite_potential+0x120>
		{
			case NO_SIGNAL:
				break;
			case HIGH_EXCITE:
				return_potential_val += 52;
     8b0:	2c 5c       	subi	r18, 0xCC	; 204
     8b2:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     8b4:	0d c0       	rjmp	.+26     	; 0x8d0 <tiny_ADC_dendrite_potential+0x120>
			case NORMAL_EXCITE:
				return_potential_val += 26;
     8b6:	26 5e       	subi	r18, 0xE6	; 230
     8b8:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     8ba:	0a c0       	rjmp	.+20     	; 0x8d0 <tiny_ADC_dendrite_potential+0x120>
			case LOW_EXCITE:
				return_potential_val += 20;
     8bc:	2c 5e       	subi	r18, 0xEC	; 236
     8be:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     8c0:	07 c0       	rjmp	.+14     	; 0x8d0 <tiny_ADC_dendrite_potential+0x120>
			case HIGH_INHIB:
				return_potential_val -= 50;
     8c2:	22 53       	subi	r18, 0x32	; 50
     8c4:	31 09       	sbc	r19, r1
				break;
     8c6:	04 c0       	rjmp	.+8      	; 0x8d0 <tiny_ADC_dendrite_potential+0x120>
			case NORMAL_INHIB:
				return_potential_val -= 26;
     8c8:	2a 51       	subi	r18, 0x1A	; 26
     8ca:	31 09       	sbc	r19, r1
			case LOW_INHIB:
				return_potential_val -= 20;
     8cc:	24 51       	subi	r18, 0x14	; 20
     8ce:	31 09       	sbc	r19, r1
	tiny_ADC_dendrites_update_values();
	//Convert the digital value to the various signals defined in DendriteSignalType
	tiny_ADC_update_signal();
	
	int16_t return_potential_val = 0;
	for (int i = 0; i < TINY_ADC_DENDRITE_COUNT; i++)
     8d0:	a4 17       	cp	r26, r20
     8d2:	b5 07       	cpc	r27, r21
     8d4:	f9 f6       	brne	.-66     	; 0x894 <tiny_ADC_dendrite_potential+0xe4>
			default:
				break;
		}
	}
	return return_potential_val;
}
     8d6:	82 2f       	mov	r24, r18
     8d8:	df 91       	pop	r29
     8da:	cf 91       	pop	r28
     8dc:	1f 91       	pop	r17
     8de:	0f 91       	pop	r16
     8e0:	ff 90       	pop	r15
     8e2:	ef 90       	pop	r14
     8e4:	df 90       	pop	r13
     8e6:	cf 90       	pop	r12
     8e8:	bf 90       	pop	r11
     8ea:	af 90       	pop	r10
     8ec:	9f 90       	pop	r9
     8ee:	8f 90       	pop	r8
     8f0:	08 95       	ret

000008f2 <__vector_6>:
This function is called every time the RTC (Real Time Clock) counter overflows. 
The RTC clock runs at 1kHz, and the number of cycles before overflow is set with RTC.PER = someHexValue (e.g. 0x20)
*/

ISR(RTC_CNT_vect)
{
     8f2:	1f 92       	push	r1
     8f4:	0f 92       	push	r0
     8f6:	0f b6       	in	r0, 0x3f	; 63
     8f8:	0f 92       	push	r0
     8fa:	11 24       	eor	r1, r1
     8fc:	2f 93       	push	r18
     8fe:	3f 93       	push	r19
     900:	4f 93       	push	r20
     902:	5f 93       	push	r21
     904:	6f 93       	push	r22
     906:	7f 93       	push	r23
     908:	8f 93       	push	r24
     90a:	9f 93       	push	r25
     90c:	af 93       	push	r26
     90e:	bf 93       	push	r27
     910:	cf 93       	push	r28
     912:	ef 93       	push	r30
     914:	ff 93       	push	r31



void tiny_timed_ISR_setflag(_Bool new_flag_val)
{
	tiny_timed_ISR_interruptflag = new_flag_val;
     916:	c1 e0       	ldi	r28, 0x01	; 1
     918:	c0 93 54 3e 	sts	0x3E54, r28	; 0x803e54 <tiny_timed_ISR_interruptflag>
	The main loop will catch up on the external flag and the external flag will remain high
	until the CPU/peripherals has completed its tasks
	*/
	
	//timer counter incrementation.
	ISR_timer_counter_increment();
     91c:	bd db       	rcall	.-2182   	; 0x98 <ISR_timer_counter_increment>


	/* Overflow interrupt flag has to be cleared manually */
	RTC.INTFLAGS = RTC_OVF_bm;
     91e:	c0 93 43 01 	sts	0x0143, r28	; 0x800143 <__TEXT_REGION_LENGTH__+0x700143>
}
     922:	ff 91       	pop	r31
     924:	ef 91       	pop	r30
     926:	cf 91       	pop	r28
     928:	bf 91       	pop	r27
     92a:	af 91       	pop	r26
     92c:	9f 91       	pop	r25
     92e:	8f 91       	pop	r24
     930:	7f 91       	pop	r23
     932:	6f 91       	pop	r22
     934:	5f 91       	pop	r21
     936:	4f 91       	pop	r20
     938:	3f 91       	pop	r19
     93a:	2f 91       	pop	r18
     93c:	0f 90       	pop	r0
     93e:	0f be       	out	0x3f, r0	; 63
     940:	0f 90       	pop	r0
     942:	1f 90       	pop	r1
     944:	18 95       	reti

00000946 <tiny_timed_ISR_setflag>:



void tiny_timed_ISR_setflag(_Bool new_flag_val)
{
	tiny_timed_ISR_interruptflag = new_flag_val;
     946:	80 93 54 3e 	sts	0x3E54, r24	; 0x803e54 <tiny_timed_ISR_interruptflag>
     94a:	08 95       	ret

0000094c <tiny_timed_ISR_getflag>:
}

_Bool tiny_timed_ISR_getflag(void)
{
	return tiny_timed_ISR_interruptflag;
}
     94c:	80 91 54 3e 	lds	r24, 0x3E54	; 0x803e54 <tiny_timed_ISR_interruptflag>
     950:	08 95       	ret

00000952 <tiny_potential_increase_by>:
Internal function to enable incrementing or decrementing
potential from the signal of a button push or dendrite.
*/
static void tiny_potential_increase_by(int8_t delta_potential)
{
	tiny_potential += delta_potential;
     952:	68 2f       	mov	r22, r24
     954:	88 0f       	add	r24, r24
     956:	77 0b       	sbc	r23, r23
     958:	88 0b       	sbc	r24, r24
     95a:	99 0b       	sbc	r25, r25
     95c:	05 d2       	rcall	.+1034   	; 0xd68 <__floatsisf>
     95e:	9b 01       	movw	r18, r22
     960:	ac 01       	movw	r20, r24
     962:	60 91 5a 3e 	lds	r22, 0x3E5A	; 0x803e5a <tiny_potential>
     966:	70 91 5b 3e 	lds	r23, 0x3E5B	; 0x803e5b <tiny_potential+0x1>
     96a:	80 91 5c 3e 	lds	r24, 0x3E5C	; 0x803e5c <tiny_potential+0x2>
     96e:	90 91 5d 3e 	lds	r25, 0x3E5D	; 0x803e5d <tiny_potential+0x3>
     972:	a5 d0       	rcall	.+330    	; 0xabe <__addsf3>
     974:	60 93 5a 3e 	sts	0x3E5A, r22	; 0x803e5a <tiny_potential>
     978:	70 93 5b 3e 	sts	0x3E5B, r23	; 0x803e5b <tiny_potential+0x1>
     97c:	80 93 5c 3e 	sts	0x3E5C, r24	; 0x803e5c <tiny_potential+0x2>
     980:	90 93 5d 3e 	sts	0x3E5D, r25	; 0x803e5d <tiny_potential+0x3>
     984:	08 95       	ret

00000986 <tiny_potential_master_update>:
/*
The function which will run in the main loop.
This function will run on interrupts by the RTC module.
*/
void tiny_potential_master_update(double time_since_last_update)
{
     986:	cf 92       	push	r12
     988:	df 92       	push	r13
     98a:	ef 92       	push	r14
     98c:	ff 92       	push	r15
     98e:	cf 93       	push	r28


//function to update potential as it should decay over time and converge towards 0.
static void tiny_potential_time_update(double time_since_last_update)//time since last update will have to be given in ms, and therefore needs precision.
{
	tiny_potential *= (exp(-(time_since_last_update/TINY_POTENTIAL_TIME_CONST)));
     990:	20 e0       	ldi	r18, 0x00	; 0
     992:	30 e0       	ldi	r19, 0x00	; 0
     994:	48 ec       	ldi	r20, 0xC8	; 200
     996:	52 e4       	ldi	r21, 0x42	; 66
     998:	03 d1       	rcall	.+518    	; 0xba0 <__divsf3>
     99a:	90 58       	subi	r25, 0x80	; 128
     99c:	7b d1       	rcall	.+758    	; 0xc94 <exp>
     99e:	9b 01       	movw	r18, r22
     9a0:	ac 01       	movw	r20, r24
     9a2:	60 91 5a 3e 	lds	r22, 0x3E5A	; 0x803e5a <tiny_potential>
     9a6:	70 91 5b 3e 	lds	r23, 0x3E5B	; 0x803e5b <tiny_potential+0x1>
     9aa:	80 91 5c 3e 	lds	r24, 0x3E5C	; 0x803e5c <tiny_potential+0x2>
     9ae:	90 91 5d 3e 	lds	r25, 0x3E5D	; 0x803e5d <tiny_potential+0x3>
     9b2:	2c d3       	rcall	.+1624   	; 0x100c <__mulsf3>
     9b4:	60 93 5a 3e 	sts	0x3E5A, r22	; 0x803e5a <tiny_potential>
     9b8:	70 93 5b 3e 	sts	0x3E5B, r23	; 0x803e5b <tiny_potential+0x1>
     9bc:	80 93 5c 3e 	sts	0x3E5C, r24	; 0x803e5c <tiny_potential+0x2>
     9c0:	90 93 5d 3e 	sts	0x3E5D, r25	; 0x803e5d <tiny_potential+0x3>
{
	//Some of the potential in the neuron has decayed away
	tiny_potential_time_update(time_since_last_update);//set the potential in accordance with the time since last update.
	
	//Update potential with values from dendrites
	tiny_potential_change = tiny_ADC_dendrite_potential();
     9c4:	f5 de       	rcall	.-534    	; 0x7b0 <tiny_ADC_dendrite_potential>
     9c6:	c8 2f       	mov	r28, r24
     9c8:	68 2f       	mov	r22, r24
     9ca:	88 0f       	add	r24, r24
     9cc:	77 0b       	sbc	r23, r23
     9ce:	88 0b       	sbc	r24, r24
     9d0:	99 0b       	sbc	r25, r25
     9d2:	ca d1       	rcall	.+916    	; 0xd68 <__floatsisf>
     9d4:	60 93 56 3e 	sts	0x3E56, r22	; 0x803e56 <tiny_potential_change>
     9d8:	70 93 57 3e 	sts	0x3E57, r23	; 0x803e57 <tiny_potential_change+0x1>
     9dc:	80 93 58 3e 	sts	0x3E58, r24	; 0x803e58 <tiny_potential_change+0x2>
     9e0:	90 93 59 3e 	sts	0x3E59, r25	; 0x803e59 <tiny_potential_change+0x3>
	tiny_potential_increase_by(tiny_potential_change);
     9e4:	8c 2f       	mov	r24, r28
     9e6:	b5 df       	rcall	.-150    	; 0x952 <tiny_potential_increase_by>
Function to update potential and set spontaneous pulse mode
by using the master update function in the button module.
*/
static void tiny_potential_button_update()
{
	if (tiny_button_get_state()) // If the button is pressed, we want the neuron to fire
     9e8:	3a dc       	rcall	.-1932   	; 0x25e <tiny_button_get_state>
     9ea:	88 23       	and	r24, r24
     9ec:	11 f0       	breq	.+4      	; 0x9f2 <tiny_potential_master_update+0x6c>
	{
		tiny_potential_increase_by(26);
     9ee:	8a e1       	ldi	r24, 0x1A	; 26
     9f0:	b0 df       	rcall	.-160    	; 0x952 <tiny_potential_increase_by>
	}
	spontaneous_pulse_mode = tiny_button_is_spont_pulse_on();
     9f2:	82 dc       	rcall	.-1788   	; 0x2f8 <tiny_button_is_spont_pulse_on>
     9f4:	80 93 55 3e 	sts	0x3E55, r24	; 0x803e55 <spontaneous_pulse_mode>
	
	//Update potential with values from button
	tiny_potential_button_update();
	
	//Update potential with values from spontaneous pulse.
	if (spontaneous_pulse_mode)
     9f8:	88 23       	and	r24, r24
     9fa:	11 f0       	breq	.+4      	; 0xa00 <tiny_potential_master_update+0x7a>
	{
		tiny_potential_increase_by(spont_pulse_delta_potential());
     9fc:	80 dc       	rcall	.-1792   	; 0x2fe <spont_pulse_delta_potential>
     9fe:	a9 df       	rcall	.-174    	; 0x952 <tiny_potential_increase_by>
	}
	
	//Check to see if the axon should fire
	if (tiny_potential > 50)
     a00:	c0 90 5a 3e 	lds	r12, 0x3E5A	; 0x803e5a <tiny_potential>
     a04:	d0 90 5b 3e 	lds	r13, 0x3E5B	; 0x803e5b <tiny_potential+0x1>
     a08:	e0 90 5c 3e 	lds	r14, 0x3E5C	; 0x803e5c <tiny_potential+0x2>
     a0c:	f0 90 5d 3e 	lds	r15, 0x3E5D	; 0x803e5d <tiny_potential+0x3>
     a10:	20 e0       	ldi	r18, 0x00	; 0
     a12:	30 e0       	ldi	r19, 0x00	; 0
     a14:	48 e4       	ldi	r20, 0x48	; 72
     a16:	52 e4       	ldi	r21, 0x42	; 66
     a18:	c7 01       	movw	r24, r14
     a1a:	b6 01       	movw	r22, r12
     a1c:	7c d2       	rcall	.+1272   	; 0xf16 <__gesf2>
     a1e:	18 16       	cp	r1, r24
     a20:	64 f4       	brge	.+24     	; 0xa3a <tiny_potential_master_update+0xb4>
	{
		//The neurons potential is very high, so we fire twice
		tiny_DAC_axon_master_update(true, true);//DAC is used to write pulse signal.
     a22:	61 e0       	ldi	r22, 0x01	; 1
     a24:	81 e0       	ldi	r24, 0x01	; 1
     a26:	44 de       	rcall	.-888    	; 0x6b0 <tiny_DAC_axon_master_update>
internal function within the module to manually set the potential.
function is used to manually set the potential post-pulse to post_fire_potential.
*/
static void tiny_potential_set(int8_t new_potential)
{
	tiny_potential = new_potential;
     a28:	10 92 5a 3e 	sts	0x3E5A, r1	; 0x803e5a <tiny_potential>
     a2c:	10 92 5b 3e 	sts	0x3E5B, r1	; 0x803e5b <tiny_potential+0x1>
     a30:	10 92 5c 3e 	sts	0x3E5C, r1	; 0x803e5c <tiny_potential+0x2>
     a34:	10 92 5d 3e 	sts	0x3E5D, r1	; 0x803e5d <tiny_potential+0x3>
     a38:	32 c0       	rjmp	.+100    	; 0xa9e <tiny_potential_master_update+0x118>
	{
		//The neurons potential is very high, so we fire twice
		tiny_DAC_axon_master_update(true, true);//DAC is used to write pulse signal.
		tiny_potential_set(POST_FIRE_POTENTIAL);//post-pulse potential is set.
	}
	else if (tiny_potential > 25)
     a3a:	20 e0       	ldi	r18, 0x00	; 0
     a3c:	30 e0       	ldi	r19, 0x00	; 0
     a3e:	48 ec       	ldi	r20, 0xC8	; 200
     a40:	51 e4       	ldi	r21, 0x41	; 65
     a42:	c7 01       	movw	r24, r14
     a44:	b6 01       	movw	r22, r12
     a46:	67 d2       	rcall	.+1230   	; 0xf16 <__gesf2>
     a48:	18 16       	cp	r1, r24
     a4a:	64 f4       	brge	.+24     	; 0xa64 <tiny_potential_master_update+0xde>
	{
		//The neurons potential is high enough to fire
		tiny_DAC_axon_master_update(true, false);
     a4c:	60 e0       	ldi	r22, 0x00	; 0
     a4e:	81 e0       	ldi	r24, 0x01	; 1
     a50:	2f de       	rcall	.-930    	; 0x6b0 <tiny_DAC_axon_master_update>
internal function within the module to manually set the potential.
function is used to manually set the potential post-pulse to post_fire_potential.
*/
static void tiny_potential_set(int8_t new_potential)
{
	tiny_potential = new_potential;
     a52:	10 92 5a 3e 	sts	0x3E5A, r1	; 0x803e5a <tiny_potential>
     a56:	10 92 5b 3e 	sts	0x3E5B, r1	; 0x803e5b <tiny_potential+0x1>
     a5a:	10 92 5c 3e 	sts	0x3E5C, r1	; 0x803e5c <tiny_potential+0x2>
     a5e:	10 92 5d 3e 	sts	0x3E5D, r1	; 0x803e5d <tiny_potential+0x3>
     a62:	1d c0       	rjmp	.+58     	; 0xa9e <tiny_potential_master_update+0x118>
		tiny_potential_set(POST_FIRE_POTENTIAL);
	}
	else
	{
		//The neurons potential is not high enough to fire
		tiny_DAC_axon_master_update(false, false);//DAC needs to be updated so that the timed pulses can be written later on.
     a64:	60 e0       	ldi	r22, 0x00	; 0
     a66:	80 e0       	ldi	r24, 0x00	; 0
     a68:	23 de       	rcall	.-954    	; 0x6b0 <tiny_DAC_axon_master_update>
		
		if(tiny_potential < -25)
     a6a:	20 e0       	ldi	r18, 0x00	; 0
     a6c:	30 e0       	ldi	r19, 0x00	; 0
     a6e:	48 ec       	ldi	r20, 0xC8	; 200
     a70:	51 ec       	ldi	r21, 0xC1	; 193
     a72:	60 91 5a 3e 	lds	r22, 0x3E5A	; 0x803e5a <tiny_potential>
     a76:	70 91 5b 3e 	lds	r23, 0x3E5B	; 0x803e5b <tiny_potential+0x1>
     a7a:	80 91 5c 3e 	lds	r24, 0x3E5C	; 0x803e5c <tiny_potential+0x2>
     a7e:	90 91 5d 3e 	lds	r25, 0x3E5D	; 0x803e5d <tiny_potential+0x3>
     a82:	89 d0       	rcall	.+274    	; 0xb96 <__cmpsf2>
     a84:	88 23       	and	r24, r24
     a86:	5c f4       	brge	.+22     	; 0xa9e <tiny_potential_master_update+0x118>
		{
			//The neurons potential is low enough to remove a queued fire (Fire less)
			if(tiny_DAC_axon_neg_pulse_queue_check())
     a88:	d5 dd       	rcall	.-1110   	; 0x634 <tiny_DAC_axon_neg_pulse_queue_check>
     a8a:	88 23       	and	r24, r24
     a8c:	41 f0       	breq	.+16     	; 0xa9e <tiny_potential_master_update+0x118>
internal function within the module to manually set the potential.
function is used to manually set the potential post-pulse to post_fire_potential.
*/
static void tiny_potential_set(int8_t new_potential)
{
	tiny_potential = new_potential;
     a8e:	10 92 5a 3e 	sts	0x3E5A, r1	; 0x803e5a <tiny_potential>
     a92:	10 92 5b 3e 	sts	0x3E5B, r1	; 0x803e5b <tiny_potential+0x1>
     a96:	10 92 5c 3e 	sts	0x3E5C, r1	; 0x803e5c <tiny_potential+0x2>
     a9a:	10 92 5d 3e 	sts	0x3E5D, r1	; 0x803e5d <tiny_potential+0x3>
			}
		}
	}
	
	//Update the led
	potential_to_RGB_update_LEDs(tiny_potential);
     a9e:	60 91 5a 3e 	lds	r22, 0x3E5A	; 0x803e5a <tiny_potential>
     aa2:	70 91 5b 3e 	lds	r23, 0x3E5B	; 0x803e5b <tiny_potential+0x1>
     aa6:	80 91 5c 3e 	lds	r24, 0x3E5C	; 0x803e5c <tiny_potential+0x2>
     aaa:	90 91 5d 3e 	lds	r25, 0x3E5D	; 0x803e5d <tiny_potential+0x3>
     aae:	4c db       	rcall	.-2408   	; 0x148 <potential_to_RGB_update_LEDs>
}
     ab0:	cf 91       	pop	r28
     ab2:	ff 90       	pop	r15
     ab4:	ef 90       	pop	r14
     ab6:	df 90       	pop	r13
     ab8:	cf 90       	pop	r12
     aba:	08 95       	ret

00000abc <__subsf3>:
     abc:	50 58       	subi	r21, 0x80	; 128

00000abe <__addsf3>:
     abe:	bb 27       	eor	r27, r27
     ac0:	aa 27       	eor	r26, r26
     ac2:	0e 94 76 05 	call	0xaec	; 0xaec <__addsf3x>
     ac6:	0c 94 51 07 	jmp	0xea2	; 0xea2 <__fp_round>
     aca:	0e 94 43 07 	call	0xe86	; 0xe86 <__fp_pscA>
     ace:	38 f0       	brcs	.+14     	; 0xade <__addsf3+0x20>
     ad0:	0e 94 4a 07 	call	0xe94	; 0xe94 <__fp_pscB>
     ad4:	20 f0       	brcs	.+8      	; 0xade <__addsf3+0x20>
     ad6:	39 f4       	brne	.+14     	; 0xae6 <__addsf3+0x28>
     ad8:	9f 3f       	cpi	r25, 0xFF	; 255
     ada:	19 f4       	brne	.+6      	; 0xae2 <__addsf3+0x24>
     adc:	26 f4       	brtc	.+8      	; 0xae6 <__addsf3+0x28>
     ade:	0c 94 19 07 	jmp	0xe32	; 0xe32 <__fp_nan>
     ae2:	0e f4       	brtc	.+2      	; 0xae6 <__addsf3+0x28>
     ae4:	e0 95       	com	r30
     ae6:	e7 fb       	bst	r30, 7
     ae8:	0c 94 13 07 	jmp	0xe26	; 0xe26 <__fp_inf>

00000aec <__addsf3x>:
     aec:	e9 2f       	mov	r30, r25
     aee:	0e 94 62 07 	call	0xec4	; 0xec4 <__fp_split3>
     af2:	58 f3       	brcs	.-42     	; 0xaca <__addsf3+0xc>
     af4:	ba 17       	cp	r27, r26
     af6:	62 07       	cpc	r22, r18
     af8:	73 07       	cpc	r23, r19
     afa:	84 07       	cpc	r24, r20
     afc:	95 07       	cpc	r25, r21
     afe:	20 f0       	brcs	.+8      	; 0xb08 <__addsf3x+0x1c>
     b00:	79 f4       	brne	.+30     	; 0xb20 <__addsf3x+0x34>
     b02:	a6 f5       	brtc	.+104    	; 0xb6c <__addsf3x+0x80>
     b04:	0c 94 84 07 	jmp	0xf08	; 0xf08 <__fp_zero>
     b08:	0e f4       	brtc	.+2      	; 0xb0c <__addsf3x+0x20>
     b0a:	e0 95       	com	r30
     b0c:	0b 2e       	mov	r0, r27
     b0e:	ba 2f       	mov	r27, r26
     b10:	a0 2d       	mov	r26, r0
     b12:	0b 01       	movw	r0, r22
     b14:	b9 01       	movw	r22, r18
     b16:	90 01       	movw	r18, r0
     b18:	0c 01       	movw	r0, r24
     b1a:	ca 01       	movw	r24, r20
     b1c:	a0 01       	movw	r20, r0
     b1e:	11 24       	eor	r1, r1
     b20:	ff 27       	eor	r31, r31
     b22:	59 1b       	sub	r21, r25
     b24:	99 f0       	breq	.+38     	; 0xb4c <__addsf3x+0x60>
     b26:	59 3f       	cpi	r21, 0xF9	; 249
     b28:	50 f4       	brcc	.+20     	; 0xb3e <__addsf3x+0x52>
     b2a:	50 3e       	cpi	r21, 0xE0	; 224
     b2c:	68 f1       	brcs	.+90     	; 0xb88 <__addsf3x+0x9c>
     b2e:	1a 16       	cp	r1, r26
     b30:	f0 40       	sbci	r31, 0x00	; 0
     b32:	a2 2f       	mov	r26, r18
     b34:	23 2f       	mov	r18, r19
     b36:	34 2f       	mov	r19, r20
     b38:	44 27       	eor	r20, r20
     b3a:	58 5f       	subi	r21, 0xF8	; 248
     b3c:	f3 cf       	rjmp	.-26     	; 0xb24 <__addsf3x+0x38>
     b3e:	46 95       	lsr	r20
     b40:	37 95       	ror	r19
     b42:	27 95       	ror	r18
     b44:	a7 95       	ror	r26
     b46:	f0 40       	sbci	r31, 0x00	; 0
     b48:	53 95       	inc	r21
     b4a:	c9 f7       	brne	.-14     	; 0xb3e <__addsf3x+0x52>
     b4c:	7e f4       	brtc	.+30     	; 0xb6c <__addsf3x+0x80>
     b4e:	1f 16       	cp	r1, r31
     b50:	ba 0b       	sbc	r27, r26
     b52:	62 0b       	sbc	r22, r18
     b54:	73 0b       	sbc	r23, r19
     b56:	84 0b       	sbc	r24, r20
     b58:	ba f0       	brmi	.+46     	; 0xb88 <__addsf3x+0x9c>
     b5a:	91 50       	subi	r25, 0x01	; 1
     b5c:	a1 f0       	breq	.+40     	; 0xb86 <__addsf3x+0x9a>
     b5e:	ff 0f       	add	r31, r31
     b60:	bb 1f       	adc	r27, r27
     b62:	66 1f       	adc	r22, r22
     b64:	77 1f       	adc	r23, r23
     b66:	88 1f       	adc	r24, r24
     b68:	c2 f7       	brpl	.-16     	; 0xb5a <__addsf3x+0x6e>
     b6a:	0e c0       	rjmp	.+28     	; 0xb88 <__addsf3x+0x9c>
     b6c:	ba 0f       	add	r27, r26
     b6e:	62 1f       	adc	r22, r18
     b70:	73 1f       	adc	r23, r19
     b72:	84 1f       	adc	r24, r20
     b74:	48 f4       	brcc	.+18     	; 0xb88 <__addsf3x+0x9c>
     b76:	87 95       	ror	r24
     b78:	77 95       	ror	r23
     b7a:	67 95       	ror	r22
     b7c:	b7 95       	ror	r27
     b7e:	f7 95       	ror	r31
     b80:	9e 3f       	cpi	r25, 0xFE	; 254
     b82:	08 f0       	brcs	.+2      	; 0xb86 <__addsf3x+0x9a>
     b84:	b0 cf       	rjmp	.-160    	; 0xae6 <__addsf3+0x28>
     b86:	93 95       	inc	r25
     b88:	88 0f       	add	r24, r24
     b8a:	08 f0       	brcs	.+2      	; 0xb8e <__addsf3x+0xa2>
     b8c:	99 27       	eor	r25, r25
     b8e:	ee 0f       	add	r30, r30
     b90:	97 95       	ror	r25
     b92:	87 95       	ror	r24
     b94:	08 95       	ret

00000b96 <__cmpsf2>:
     b96:	0e 94 ef 06 	call	0xdde	; 0xdde <__fp_cmp>
     b9a:	08 f4       	brcc	.+2      	; 0xb9e <__cmpsf2+0x8>
     b9c:	81 e0       	ldi	r24, 0x01	; 1
     b9e:	08 95       	ret

00000ba0 <__divsf3>:
     ba0:	0e 94 e4 05 	call	0xbc8	; 0xbc8 <__divsf3x>
     ba4:	0c 94 51 07 	jmp	0xea2	; 0xea2 <__fp_round>
     ba8:	0e 94 4a 07 	call	0xe94	; 0xe94 <__fp_pscB>
     bac:	58 f0       	brcs	.+22     	; 0xbc4 <__divsf3+0x24>
     bae:	0e 94 43 07 	call	0xe86	; 0xe86 <__fp_pscA>
     bb2:	40 f0       	brcs	.+16     	; 0xbc4 <__divsf3+0x24>
     bb4:	29 f4       	brne	.+10     	; 0xbc0 <__divsf3+0x20>
     bb6:	5f 3f       	cpi	r21, 0xFF	; 255
     bb8:	29 f0       	breq	.+10     	; 0xbc4 <__divsf3+0x24>
     bba:	0c 94 13 07 	jmp	0xe26	; 0xe26 <__fp_inf>
     bbe:	51 11       	cpse	r21, r1
     bc0:	0c 94 85 07 	jmp	0xf0a	; 0xf0a <__fp_szero>
     bc4:	0c 94 19 07 	jmp	0xe32	; 0xe32 <__fp_nan>

00000bc8 <__divsf3x>:
     bc8:	0e 94 62 07 	call	0xec4	; 0xec4 <__fp_split3>
     bcc:	68 f3       	brcs	.-38     	; 0xba8 <__divsf3+0x8>

00000bce <__divsf3_pse>:
     bce:	99 23       	and	r25, r25
     bd0:	b1 f3       	breq	.-20     	; 0xbbe <__divsf3+0x1e>
     bd2:	55 23       	and	r21, r21
     bd4:	91 f3       	breq	.-28     	; 0xbba <__divsf3+0x1a>
     bd6:	95 1b       	sub	r25, r21
     bd8:	55 0b       	sbc	r21, r21
     bda:	bb 27       	eor	r27, r27
     bdc:	aa 27       	eor	r26, r26
     bde:	62 17       	cp	r22, r18
     be0:	73 07       	cpc	r23, r19
     be2:	84 07       	cpc	r24, r20
     be4:	38 f0       	brcs	.+14     	; 0xbf4 <__divsf3_pse+0x26>
     be6:	9f 5f       	subi	r25, 0xFF	; 255
     be8:	5f 4f       	sbci	r21, 0xFF	; 255
     bea:	22 0f       	add	r18, r18
     bec:	33 1f       	adc	r19, r19
     bee:	44 1f       	adc	r20, r20
     bf0:	aa 1f       	adc	r26, r26
     bf2:	a9 f3       	breq	.-22     	; 0xbde <__divsf3_pse+0x10>
     bf4:	35 d0       	rcall	.+106    	; 0xc60 <__divsf3_pse+0x92>
     bf6:	0e 2e       	mov	r0, r30
     bf8:	3a f0       	brmi	.+14     	; 0xc08 <__divsf3_pse+0x3a>
     bfa:	e0 e8       	ldi	r30, 0x80	; 128
     bfc:	32 d0       	rcall	.+100    	; 0xc62 <__divsf3_pse+0x94>
     bfe:	91 50       	subi	r25, 0x01	; 1
     c00:	50 40       	sbci	r21, 0x00	; 0
     c02:	e6 95       	lsr	r30
     c04:	00 1c       	adc	r0, r0
     c06:	ca f7       	brpl	.-14     	; 0xbfa <__divsf3_pse+0x2c>
     c08:	2b d0       	rcall	.+86     	; 0xc60 <__divsf3_pse+0x92>
     c0a:	fe 2f       	mov	r31, r30
     c0c:	29 d0       	rcall	.+82     	; 0xc60 <__divsf3_pse+0x92>
     c0e:	66 0f       	add	r22, r22
     c10:	77 1f       	adc	r23, r23
     c12:	88 1f       	adc	r24, r24
     c14:	bb 1f       	adc	r27, r27
     c16:	26 17       	cp	r18, r22
     c18:	37 07       	cpc	r19, r23
     c1a:	48 07       	cpc	r20, r24
     c1c:	ab 07       	cpc	r26, r27
     c1e:	b0 e8       	ldi	r27, 0x80	; 128
     c20:	09 f0       	breq	.+2      	; 0xc24 <__divsf3_pse+0x56>
     c22:	bb 0b       	sbc	r27, r27
     c24:	80 2d       	mov	r24, r0
     c26:	bf 01       	movw	r22, r30
     c28:	ff 27       	eor	r31, r31
     c2a:	93 58       	subi	r25, 0x83	; 131
     c2c:	5f 4f       	sbci	r21, 0xFF	; 255
     c2e:	3a f0       	brmi	.+14     	; 0xc3e <__divsf3_pse+0x70>
     c30:	9e 3f       	cpi	r25, 0xFE	; 254
     c32:	51 05       	cpc	r21, r1
     c34:	78 f0       	brcs	.+30     	; 0xc54 <__divsf3_pse+0x86>
     c36:	0c 94 13 07 	jmp	0xe26	; 0xe26 <__fp_inf>
     c3a:	0c 94 85 07 	jmp	0xf0a	; 0xf0a <__fp_szero>
     c3e:	5f 3f       	cpi	r21, 0xFF	; 255
     c40:	e4 f3       	brlt	.-8      	; 0xc3a <__divsf3_pse+0x6c>
     c42:	98 3e       	cpi	r25, 0xE8	; 232
     c44:	d4 f3       	brlt	.-12     	; 0xc3a <__divsf3_pse+0x6c>
     c46:	86 95       	lsr	r24
     c48:	77 95       	ror	r23
     c4a:	67 95       	ror	r22
     c4c:	b7 95       	ror	r27
     c4e:	f7 95       	ror	r31
     c50:	9f 5f       	subi	r25, 0xFF	; 255
     c52:	c9 f7       	brne	.-14     	; 0xc46 <__divsf3_pse+0x78>
     c54:	88 0f       	add	r24, r24
     c56:	91 1d       	adc	r25, r1
     c58:	96 95       	lsr	r25
     c5a:	87 95       	ror	r24
     c5c:	97 f9       	bld	r25, 7
     c5e:	08 95       	ret
     c60:	e1 e0       	ldi	r30, 0x01	; 1
     c62:	66 0f       	add	r22, r22
     c64:	77 1f       	adc	r23, r23
     c66:	88 1f       	adc	r24, r24
     c68:	bb 1f       	adc	r27, r27
     c6a:	62 17       	cp	r22, r18
     c6c:	73 07       	cpc	r23, r19
     c6e:	84 07       	cpc	r24, r20
     c70:	ba 07       	cpc	r27, r26
     c72:	20 f0       	brcs	.+8      	; 0xc7c <__divsf3_pse+0xae>
     c74:	62 1b       	sub	r22, r18
     c76:	73 0b       	sbc	r23, r19
     c78:	84 0b       	sbc	r24, r20
     c7a:	ba 0b       	sbc	r27, r26
     c7c:	ee 1f       	adc	r30, r30
     c7e:	88 f7       	brcc	.-30     	; 0xc62 <__divsf3_pse+0x94>
     c80:	e0 95       	com	r30
     c82:	08 95       	ret
     c84:	29 f4       	brne	.+10     	; 0xc90 <__divsf3_pse+0xc2>
     c86:	16 f0       	brts	.+4      	; 0xc8c <__divsf3_pse+0xbe>
     c88:	0c 94 13 07 	jmp	0xe26	; 0xe26 <__fp_inf>
     c8c:	0c 94 84 07 	jmp	0xf08	; 0xf08 <__fp_zero>
     c90:	0c 94 19 07 	jmp	0xe32	; 0xe32 <__fp_nan>

00000c94 <exp>:
     c94:	0e 94 6a 07 	call	0xed4	; 0xed4 <__fp_splitA>
     c98:	a8 f3       	brcs	.-22     	; 0xc84 <__divsf3_pse+0xb6>
     c9a:	96 38       	cpi	r25, 0x86	; 134
     c9c:	a0 f7       	brcc	.-24     	; 0xc86 <__divsf3_pse+0xb8>
     c9e:	07 f8       	bld	r0, 7
     ca0:	0f 92       	push	r0
     ca2:	e8 94       	clt
     ca4:	2b e3       	ldi	r18, 0x3B	; 59
     ca6:	3a ea       	ldi	r19, 0xAA	; 170
     ca8:	48 eb       	ldi	r20, 0xB8	; 184
     caa:	5f e7       	ldi	r21, 0x7F	; 127
     cac:	0e 94 1c 08 	call	0x1038	; 0x1038 <__mulsf3_pse>
     cb0:	0f 92       	push	r0
     cb2:	0f 92       	push	r0
     cb4:	0f 92       	push	r0
     cb6:	4d b7       	in	r20, 0x3d	; 61
     cb8:	5e b7       	in	r21, 0x3e	; 62
     cba:	0f 92       	push	r0
     cbc:	0e 94 d2 07 	call	0xfa4	; 0xfa4 <modf>
     cc0:	e4 e3       	ldi	r30, 0x34	; 52
     cc2:	f0 e0       	ldi	r31, 0x00	; 0
     cc4:	0e 94 1c 07 	call	0xe38	; 0xe38 <__fp_powser>
     cc8:	4f 91       	pop	r20
     cca:	5f 91       	pop	r21
     ccc:	ef 91       	pop	r30
     cce:	ff 91       	pop	r31
     cd0:	e5 95       	asr	r30
     cd2:	ee 1f       	adc	r30, r30
     cd4:	ff 1f       	adc	r31, r31
     cd6:	49 f0       	breq	.+18     	; 0xcea <exp+0x56>
     cd8:	fe 57       	subi	r31, 0x7E	; 126
     cda:	e0 68       	ori	r30, 0x80	; 128
     cdc:	44 27       	eor	r20, r20
     cde:	ee 0f       	add	r30, r30
     ce0:	44 1f       	adc	r20, r20
     ce2:	fa 95       	dec	r31
     ce4:	e1 f7       	brne	.-8      	; 0xcde <exp+0x4a>
     ce6:	41 95       	neg	r20
     ce8:	55 0b       	sbc	r21, r21
     cea:	0e 94 9c 07 	call	0xf38	; 0xf38 <ldexp>
     cee:	0f 90       	pop	r0
     cf0:	07 fe       	sbrs	r0, 7
     cf2:	0c 94 90 07 	jmp	0xf20	; 0xf20 <inverse>
     cf6:	08 95       	ret

00000cf8 <__fixsfsi>:
     cf8:	0e 94 83 06 	call	0xd06	; 0xd06 <__fixunssfsi>
     cfc:	68 94       	set
     cfe:	b1 11       	cpse	r27, r1
     d00:	0c 94 85 07 	jmp	0xf0a	; 0xf0a <__fp_szero>
     d04:	08 95       	ret

00000d06 <__fixunssfsi>:
     d06:	0e 94 6a 07 	call	0xed4	; 0xed4 <__fp_splitA>
     d0a:	88 f0       	brcs	.+34     	; 0xd2e <__fixunssfsi+0x28>
     d0c:	9f 57       	subi	r25, 0x7F	; 127
     d0e:	98 f0       	brcs	.+38     	; 0xd36 <__fixunssfsi+0x30>
     d10:	b9 2f       	mov	r27, r25
     d12:	99 27       	eor	r25, r25
     d14:	b7 51       	subi	r27, 0x17	; 23
     d16:	b0 f0       	brcs	.+44     	; 0xd44 <__fixunssfsi+0x3e>
     d18:	e1 f0       	breq	.+56     	; 0xd52 <__fixunssfsi+0x4c>
     d1a:	66 0f       	add	r22, r22
     d1c:	77 1f       	adc	r23, r23
     d1e:	88 1f       	adc	r24, r24
     d20:	99 1f       	adc	r25, r25
     d22:	1a f0       	brmi	.+6      	; 0xd2a <__fixunssfsi+0x24>
     d24:	ba 95       	dec	r27
     d26:	c9 f7       	brne	.-14     	; 0xd1a <__fixunssfsi+0x14>
     d28:	14 c0       	rjmp	.+40     	; 0xd52 <__fixunssfsi+0x4c>
     d2a:	b1 30       	cpi	r27, 0x01	; 1
     d2c:	91 f0       	breq	.+36     	; 0xd52 <__fixunssfsi+0x4c>
     d2e:	0e 94 84 07 	call	0xf08	; 0xf08 <__fp_zero>
     d32:	b1 e0       	ldi	r27, 0x01	; 1
     d34:	08 95       	ret
     d36:	0c 94 84 07 	jmp	0xf08	; 0xf08 <__fp_zero>
     d3a:	67 2f       	mov	r22, r23
     d3c:	78 2f       	mov	r23, r24
     d3e:	88 27       	eor	r24, r24
     d40:	b8 5f       	subi	r27, 0xF8	; 248
     d42:	39 f0       	breq	.+14     	; 0xd52 <__fixunssfsi+0x4c>
     d44:	b9 3f       	cpi	r27, 0xF9	; 249
     d46:	cc f3       	brlt	.-14     	; 0xd3a <__fixunssfsi+0x34>
     d48:	86 95       	lsr	r24
     d4a:	77 95       	ror	r23
     d4c:	67 95       	ror	r22
     d4e:	b3 95       	inc	r27
     d50:	d9 f7       	brne	.-10     	; 0xd48 <__fixunssfsi+0x42>
     d52:	3e f4       	brtc	.+14     	; 0xd62 <__fixunssfsi+0x5c>
     d54:	90 95       	com	r25
     d56:	80 95       	com	r24
     d58:	70 95       	com	r23
     d5a:	61 95       	neg	r22
     d5c:	7f 4f       	sbci	r23, 0xFF	; 255
     d5e:	8f 4f       	sbci	r24, 0xFF	; 255
     d60:	9f 4f       	sbci	r25, 0xFF	; 255
     d62:	08 95       	ret

00000d64 <__floatunsisf>:
     d64:	e8 94       	clt
     d66:	09 c0       	rjmp	.+18     	; 0xd7a <__floatsisf+0x12>

00000d68 <__floatsisf>:
     d68:	97 fb       	bst	r25, 7
     d6a:	3e f4       	brtc	.+14     	; 0xd7a <__floatsisf+0x12>
     d6c:	90 95       	com	r25
     d6e:	80 95       	com	r24
     d70:	70 95       	com	r23
     d72:	61 95       	neg	r22
     d74:	7f 4f       	sbci	r23, 0xFF	; 255
     d76:	8f 4f       	sbci	r24, 0xFF	; 255
     d78:	9f 4f       	sbci	r25, 0xFF	; 255
     d7a:	99 23       	and	r25, r25
     d7c:	a9 f0       	breq	.+42     	; 0xda8 <__floatsisf+0x40>
     d7e:	f9 2f       	mov	r31, r25
     d80:	96 e9       	ldi	r25, 0x96	; 150
     d82:	bb 27       	eor	r27, r27
     d84:	93 95       	inc	r25
     d86:	f6 95       	lsr	r31
     d88:	87 95       	ror	r24
     d8a:	77 95       	ror	r23
     d8c:	67 95       	ror	r22
     d8e:	b7 95       	ror	r27
     d90:	f1 11       	cpse	r31, r1
     d92:	f8 cf       	rjmp	.-16     	; 0xd84 <__floatsisf+0x1c>
     d94:	fa f4       	brpl	.+62     	; 0xdd4 <__floatsisf+0x6c>
     d96:	bb 0f       	add	r27, r27
     d98:	11 f4       	brne	.+4      	; 0xd9e <__floatsisf+0x36>
     d9a:	60 ff       	sbrs	r22, 0
     d9c:	1b c0       	rjmp	.+54     	; 0xdd4 <__floatsisf+0x6c>
     d9e:	6f 5f       	subi	r22, 0xFF	; 255
     da0:	7f 4f       	sbci	r23, 0xFF	; 255
     da2:	8f 4f       	sbci	r24, 0xFF	; 255
     da4:	9f 4f       	sbci	r25, 0xFF	; 255
     da6:	16 c0       	rjmp	.+44     	; 0xdd4 <__floatsisf+0x6c>
     da8:	88 23       	and	r24, r24
     daa:	11 f0       	breq	.+4      	; 0xdb0 <__floatsisf+0x48>
     dac:	96 e9       	ldi	r25, 0x96	; 150
     dae:	11 c0       	rjmp	.+34     	; 0xdd2 <__floatsisf+0x6a>
     db0:	77 23       	and	r23, r23
     db2:	21 f0       	breq	.+8      	; 0xdbc <__floatsisf+0x54>
     db4:	9e e8       	ldi	r25, 0x8E	; 142
     db6:	87 2f       	mov	r24, r23
     db8:	76 2f       	mov	r23, r22
     dba:	05 c0       	rjmp	.+10     	; 0xdc6 <__floatsisf+0x5e>
     dbc:	66 23       	and	r22, r22
     dbe:	71 f0       	breq	.+28     	; 0xddc <__floatsisf+0x74>
     dc0:	96 e8       	ldi	r25, 0x86	; 134
     dc2:	86 2f       	mov	r24, r22
     dc4:	70 e0       	ldi	r23, 0x00	; 0
     dc6:	60 e0       	ldi	r22, 0x00	; 0
     dc8:	2a f0       	brmi	.+10     	; 0xdd4 <__floatsisf+0x6c>
     dca:	9a 95       	dec	r25
     dcc:	66 0f       	add	r22, r22
     dce:	77 1f       	adc	r23, r23
     dd0:	88 1f       	adc	r24, r24
     dd2:	da f7       	brpl	.-10     	; 0xdca <__floatsisf+0x62>
     dd4:	88 0f       	add	r24, r24
     dd6:	96 95       	lsr	r25
     dd8:	87 95       	ror	r24
     dda:	97 f9       	bld	r25, 7
     ddc:	08 95       	ret

00000dde <__fp_cmp>:
     dde:	99 0f       	add	r25, r25
     de0:	00 08       	sbc	r0, r0
     de2:	55 0f       	add	r21, r21
     de4:	aa 0b       	sbc	r26, r26
     de6:	e0 e8       	ldi	r30, 0x80	; 128
     de8:	fe ef       	ldi	r31, 0xFE	; 254
     dea:	16 16       	cp	r1, r22
     dec:	17 06       	cpc	r1, r23
     dee:	e8 07       	cpc	r30, r24
     df0:	f9 07       	cpc	r31, r25
     df2:	c0 f0       	brcs	.+48     	; 0xe24 <__fp_cmp+0x46>
     df4:	12 16       	cp	r1, r18
     df6:	13 06       	cpc	r1, r19
     df8:	e4 07       	cpc	r30, r20
     dfa:	f5 07       	cpc	r31, r21
     dfc:	98 f0       	brcs	.+38     	; 0xe24 <__fp_cmp+0x46>
     dfe:	62 1b       	sub	r22, r18
     e00:	73 0b       	sbc	r23, r19
     e02:	84 0b       	sbc	r24, r20
     e04:	95 0b       	sbc	r25, r21
     e06:	39 f4       	brne	.+14     	; 0xe16 <__fp_cmp+0x38>
     e08:	0a 26       	eor	r0, r26
     e0a:	61 f0       	breq	.+24     	; 0xe24 <__fp_cmp+0x46>
     e0c:	23 2b       	or	r18, r19
     e0e:	24 2b       	or	r18, r20
     e10:	25 2b       	or	r18, r21
     e12:	21 f4       	brne	.+8      	; 0xe1c <__fp_cmp+0x3e>
     e14:	08 95       	ret
     e16:	0a 26       	eor	r0, r26
     e18:	09 f4       	brne	.+2      	; 0xe1c <__fp_cmp+0x3e>
     e1a:	a1 40       	sbci	r26, 0x01	; 1
     e1c:	a6 95       	lsr	r26
     e1e:	8f ef       	ldi	r24, 0xFF	; 255
     e20:	81 1d       	adc	r24, r1
     e22:	81 1d       	adc	r24, r1
     e24:	08 95       	ret

00000e26 <__fp_inf>:
     e26:	97 f9       	bld	r25, 7
     e28:	9f 67       	ori	r25, 0x7F	; 127
     e2a:	80 e8       	ldi	r24, 0x80	; 128
     e2c:	70 e0       	ldi	r23, 0x00	; 0
     e2e:	60 e0       	ldi	r22, 0x00	; 0
     e30:	08 95       	ret

00000e32 <__fp_nan>:
     e32:	9f ef       	ldi	r25, 0xFF	; 255
     e34:	80 ec       	ldi	r24, 0xC0	; 192
     e36:	08 95       	ret

00000e38 <__fp_powser>:
     e38:	df 93       	push	r29
     e3a:	cf 93       	push	r28
     e3c:	1f 93       	push	r17
     e3e:	0f 93       	push	r16
     e40:	ff 92       	push	r15
     e42:	ef 92       	push	r14
     e44:	df 92       	push	r13
     e46:	7b 01       	movw	r14, r22
     e48:	8c 01       	movw	r16, r24
     e4a:	68 94       	set
     e4c:	06 c0       	rjmp	.+12     	; 0xe5a <__fp_powser+0x22>
     e4e:	da 2e       	mov	r13, r26
     e50:	ef 01       	movw	r28, r30
     e52:	0e 94 19 08 	call	0x1032	; 0x1032 <__mulsf3x>
     e56:	fe 01       	movw	r30, r28
     e58:	e8 94       	clt
     e5a:	a5 91       	lpm	r26, Z+
     e5c:	25 91       	lpm	r18, Z+
     e5e:	35 91       	lpm	r19, Z+
     e60:	45 91       	lpm	r20, Z+
     e62:	55 91       	lpm	r21, Z+
     e64:	a6 f3       	brts	.-24     	; 0xe4e <__fp_powser+0x16>
     e66:	ef 01       	movw	r28, r30
     e68:	0e 94 76 05 	call	0xaec	; 0xaec <__addsf3x>
     e6c:	fe 01       	movw	r30, r28
     e6e:	97 01       	movw	r18, r14
     e70:	a8 01       	movw	r20, r16
     e72:	da 94       	dec	r13
     e74:	69 f7       	brne	.-38     	; 0xe50 <__fp_powser+0x18>
     e76:	df 90       	pop	r13
     e78:	ef 90       	pop	r14
     e7a:	ff 90       	pop	r15
     e7c:	0f 91       	pop	r16
     e7e:	1f 91       	pop	r17
     e80:	cf 91       	pop	r28
     e82:	df 91       	pop	r29
     e84:	08 95       	ret

00000e86 <__fp_pscA>:
     e86:	00 24       	eor	r0, r0
     e88:	0a 94       	dec	r0
     e8a:	16 16       	cp	r1, r22
     e8c:	17 06       	cpc	r1, r23
     e8e:	18 06       	cpc	r1, r24
     e90:	09 06       	cpc	r0, r25
     e92:	08 95       	ret

00000e94 <__fp_pscB>:
     e94:	00 24       	eor	r0, r0
     e96:	0a 94       	dec	r0
     e98:	12 16       	cp	r1, r18
     e9a:	13 06       	cpc	r1, r19
     e9c:	14 06       	cpc	r1, r20
     e9e:	05 06       	cpc	r0, r21
     ea0:	08 95       	ret

00000ea2 <__fp_round>:
     ea2:	09 2e       	mov	r0, r25
     ea4:	03 94       	inc	r0
     ea6:	00 0c       	add	r0, r0
     ea8:	11 f4       	brne	.+4      	; 0xeae <__fp_round+0xc>
     eaa:	88 23       	and	r24, r24
     eac:	52 f0       	brmi	.+20     	; 0xec2 <__fp_round+0x20>
     eae:	bb 0f       	add	r27, r27
     eb0:	40 f4       	brcc	.+16     	; 0xec2 <__fp_round+0x20>
     eb2:	bf 2b       	or	r27, r31
     eb4:	11 f4       	brne	.+4      	; 0xeba <__fp_round+0x18>
     eb6:	60 ff       	sbrs	r22, 0
     eb8:	04 c0       	rjmp	.+8      	; 0xec2 <__fp_round+0x20>
     eba:	6f 5f       	subi	r22, 0xFF	; 255
     ebc:	7f 4f       	sbci	r23, 0xFF	; 255
     ebe:	8f 4f       	sbci	r24, 0xFF	; 255
     ec0:	9f 4f       	sbci	r25, 0xFF	; 255
     ec2:	08 95       	ret

00000ec4 <__fp_split3>:
     ec4:	57 fd       	sbrc	r21, 7
     ec6:	90 58       	subi	r25, 0x80	; 128
     ec8:	44 0f       	add	r20, r20
     eca:	55 1f       	adc	r21, r21
     ecc:	59 f0       	breq	.+22     	; 0xee4 <__fp_splitA+0x10>
     ece:	5f 3f       	cpi	r21, 0xFF	; 255
     ed0:	71 f0       	breq	.+28     	; 0xeee <__fp_splitA+0x1a>
     ed2:	47 95       	ror	r20

00000ed4 <__fp_splitA>:
     ed4:	88 0f       	add	r24, r24
     ed6:	97 fb       	bst	r25, 7
     ed8:	99 1f       	adc	r25, r25
     eda:	61 f0       	breq	.+24     	; 0xef4 <__fp_splitA+0x20>
     edc:	9f 3f       	cpi	r25, 0xFF	; 255
     ede:	79 f0       	breq	.+30     	; 0xefe <__fp_splitA+0x2a>
     ee0:	87 95       	ror	r24
     ee2:	08 95       	ret
     ee4:	12 16       	cp	r1, r18
     ee6:	13 06       	cpc	r1, r19
     ee8:	14 06       	cpc	r1, r20
     eea:	55 1f       	adc	r21, r21
     eec:	f2 cf       	rjmp	.-28     	; 0xed2 <__fp_split3+0xe>
     eee:	46 95       	lsr	r20
     ef0:	f1 df       	rcall	.-30     	; 0xed4 <__fp_splitA>
     ef2:	08 c0       	rjmp	.+16     	; 0xf04 <__fp_splitA+0x30>
     ef4:	16 16       	cp	r1, r22
     ef6:	17 06       	cpc	r1, r23
     ef8:	18 06       	cpc	r1, r24
     efa:	99 1f       	adc	r25, r25
     efc:	f1 cf       	rjmp	.-30     	; 0xee0 <__fp_splitA+0xc>
     efe:	86 95       	lsr	r24
     f00:	71 05       	cpc	r23, r1
     f02:	61 05       	cpc	r22, r1
     f04:	08 94       	sec
     f06:	08 95       	ret

00000f08 <__fp_zero>:
     f08:	e8 94       	clt

00000f0a <__fp_szero>:
     f0a:	bb 27       	eor	r27, r27
     f0c:	66 27       	eor	r22, r22
     f0e:	77 27       	eor	r23, r23
     f10:	cb 01       	movw	r24, r22
     f12:	97 f9       	bld	r25, 7
     f14:	08 95       	ret

00000f16 <__gesf2>:
     f16:	0e 94 ef 06 	call	0xdde	; 0xdde <__fp_cmp>
     f1a:	08 f4       	brcc	.+2      	; 0xf1e <__gesf2+0x8>
     f1c:	8f ef       	ldi	r24, 0xFF	; 255
     f1e:	08 95       	ret

00000f20 <inverse>:
     f20:	9b 01       	movw	r18, r22
     f22:	ac 01       	movw	r20, r24
     f24:	60 e0       	ldi	r22, 0x00	; 0
     f26:	70 e0       	ldi	r23, 0x00	; 0
     f28:	80 e8       	ldi	r24, 0x80	; 128
     f2a:	9f e3       	ldi	r25, 0x3F	; 63
     f2c:	0c 94 d0 05 	jmp	0xba0	; 0xba0 <__divsf3>
     f30:	0c 94 13 07 	jmp	0xe26	; 0xe26 <__fp_inf>
     f34:	0c 94 b2 08 	jmp	0x1164	; 0x1164 <__fp_mpack>

00000f38 <ldexp>:
     f38:	0e 94 6a 07 	call	0xed4	; 0xed4 <__fp_splitA>
     f3c:	d8 f3       	brcs	.-10     	; 0xf34 <inverse+0x14>
     f3e:	99 23       	and	r25, r25
     f40:	c9 f3       	breq	.-14     	; 0xf34 <inverse+0x14>
     f42:	94 0f       	add	r25, r20
     f44:	51 1d       	adc	r21, r1
     f46:	a3 f3       	brvs	.-24     	; 0xf30 <inverse+0x10>
     f48:	91 50       	subi	r25, 0x01	; 1
     f4a:	50 40       	sbci	r21, 0x00	; 0
     f4c:	94 f0       	brlt	.+36     	; 0xf72 <ldexp+0x3a>
     f4e:	59 f0       	breq	.+22     	; 0xf66 <ldexp+0x2e>
     f50:	88 23       	and	r24, r24
     f52:	32 f0       	brmi	.+12     	; 0xf60 <ldexp+0x28>
     f54:	66 0f       	add	r22, r22
     f56:	77 1f       	adc	r23, r23
     f58:	88 1f       	adc	r24, r24
     f5a:	91 50       	subi	r25, 0x01	; 1
     f5c:	50 40       	sbci	r21, 0x00	; 0
     f5e:	c1 f7       	brne	.-16     	; 0xf50 <ldexp+0x18>
     f60:	9e 3f       	cpi	r25, 0xFE	; 254
     f62:	51 05       	cpc	r21, r1
     f64:	2c f7       	brge	.-54     	; 0xf30 <inverse+0x10>
     f66:	88 0f       	add	r24, r24
     f68:	91 1d       	adc	r25, r1
     f6a:	96 95       	lsr	r25
     f6c:	87 95       	ror	r24
     f6e:	97 f9       	bld	r25, 7
     f70:	08 95       	ret
     f72:	5f 3f       	cpi	r21, 0xFF	; 255
     f74:	ac f0       	brlt	.+42     	; 0xfa0 <ldexp+0x68>
     f76:	98 3e       	cpi	r25, 0xE8	; 232
     f78:	9c f0       	brlt	.+38     	; 0xfa0 <ldexp+0x68>
     f7a:	bb 27       	eor	r27, r27
     f7c:	86 95       	lsr	r24
     f7e:	77 95       	ror	r23
     f80:	67 95       	ror	r22
     f82:	b7 95       	ror	r27
     f84:	08 f4       	brcc	.+2      	; 0xf88 <ldexp+0x50>
     f86:	b1 60       	ori	r27, 0x01	; 1
     f88:	93 95       	inc	r25
     f8a:	c1 f7       	brne	.-16     	; 0xf7c <ldexp+0x44>
     f8c:	bb 0f       	add	r27, r27
     f8e:	58 f7       	brcc	.-42     	; 0xf66 <ldexp+0x2e>
     f90:	11 f4       	brne	.+4      	; 0xf96 <ldexp+0x5e>
     f92:	60 ff       	sbrs	r22, 0
     f94:	e8 cf       	rjmp	.-48     	; 0xf66 <ldexp+0x2e>
     f96:	6f 5f       	subi	r22, 0xFF	; 255
     f98:	7f 4f       	sbci	r23, 0xFF	; 255
     f9a:	8f 4f       	sbci	r24, 0xFF	; 255
     f9c:	9f 4f       	sbci	r25, 0xFF	; 255
     f9e:	e3 cf       	rjmp	.-58     	; 0xf66 <ldexp+0x2e>
     fa0:	0c 94 85 07 	jmp	0xf0a	; 0xf0a <__fp_szero>

00000fa4 <modf>:
     fa4:	fa 01       	movw	r30, r20
     fa6:	dc 01       	movw	r26, r24
     fa8:	aa 0f       	add	r26, r26
     faa:	bb 1f       	adc	r27, r27
     fac:	9b 01       	movw	r18, r22
     fae:	ac 01       	movw	r20, r24
     fb0:	bf 57       	subi	r27, 0x7F	; 127
     fb2:	28 f4       	brcc	.+10     	; 0xfbe <modf+0x1a>
     fb4:	22 27       	eor	r18, r18
     fb6:	33 27       	eor	r19, r19
     fb8:	44 27       	eor	r20, r20
     fba:	50 78       	andi	r21, 0x80	; 128
     fbc:	20 c0       	rjmp	.+64     	; 0xffe <modf+0x5a>
     fbe:	b7 51       	subi	r27, 0x17	; 23
     fc0:	90 f4       	brcc	.+36     	; 0xfe6 <modf+0x42>
     fc2:	ab 2f       	mov	r26, r27
     fc4:	00 24       	eor	r0, r0
     fc6:	46 95       	lsr	r20
     fc8:	37 95       	ror	r19
     fca:	27 95       	ror	r18
     fcc:	01 1c       	adc	r0, r1
     fce:	a3 95       	inc	r26
     fd0:	d2 f3       	brmi	.-12     	; 0xfc6 <modf+0x22>
     fd2:	00 20       	and	r0, r0
     fd4:	71 f0       	breq	.+28     	; 0xff2 <modf+0x4e>
     fd6:	22 0f       	add	r18, r18
     fd8:	33 1f       	adc	r19, r19
     fda:	44 1f       	adc	r20, r20
     fdc:	b3 95       	inc	r27
     fde:	da f3       	brmi	.-10     	; 0xfd6 <modf+0x32>
     fe0:	0e d0       	rcall	.+28     	; 0xffe <modf+0x5a>
     fe2:	0c 94 5e 05 	jmp	0xabc	; 0xabc <__subsf3>
     fe6:	61 30       	cpi	r22, 0x01	; 1
     fe8:	71 05       	cpc	r23, r1
     fea:	a0 e8       	ldi	r26, 0x80	; 128
     fec:	8a 07       	cpc	r24, r26
     fee:	b9 46       	sbci	r27, 0x69	; 105
     ff0:	30 f4       	brcc	.+12     	; 0xffe <modf+0x5a>
     ff2:	9b 01       	movw	r18, r22
     ff4:	ac 01       	movw	r20, r24
     ff6:	66 27       	eor	r22, r22
     ff8:	77 27       	eor	r23, r23
     ffa:	88 27       	eor	r24, r24
     ffc:	90 78       	andi	r25, 0x80	; 128
     ffe:	30 96       	adiw	r30, 0x00	; 0
    1000:	21 f0       	breq	.+8      	; 0x100a <modf+0x66>
    1002:	20 83       	st	Z, r18
    1004:	31 83       	std	Z+1, r19	; 0x01
    1006:	42 83       	std	Z+2, r20	; 0x02
    1008:	53 83       	std	Z+3, r21	; 0x03
    100a:	08 95       	ret

0000100c <__mulsf3>:
    100c:	0e 94 19 08 	call	0x1032	; 0x1032 <__mulsf3x>
    1010:	0c 94 51 07 	jmp	0xea2	; 0xea2 <__fp_round>
    1014:	0e 94 43 07 	call	0xe86	; 0xe86 <__fp_pscA>
    1018:	38 f0       	brcs	.+14     	; 0x1028 <__mulsf3+0x1c>
    101a:	0e 94 4a 07 	call	0xe94	; 0xe94 <__fp_pscB>
    101e:	20 f0       	brcs	.+8      	; 0x1028 <__mulsf3+0x1c>
    1020:	95 23       	and	r25, r21
    1022:	11 f0       	breq	.+4      	; 0x1028 <__mulsf3+0x1c>
    1024:	0c 94 13 07 	jmp	0xe26	; 0xe26 <__fp_inf>
    1028:	0c 94 19 07 	jmp	0xe32	; 0xe32 <__fp_nan>
    102c:	11 24       	eor	r1, r1
    102e:	0c 94 85 07 	jmp	0xf0a	; 0xf0a <__fp_szero>

00001032 <__mulsf3x>:
    1032:	0e 94 62 07 	call	0xec4	; 0xec4 <__fp_split3>
    1036:	70 f3       	brcs	.-36     	; 0x1014 <__mulsf3+0x8>

00001038 <__mulsf3_pse>:
    1038:	95 9f       	mul	r25, r21
    103a:	c1 f3       	breq	.-16     	; 0x102c <__mulsf3+0x20>
    103c:	95 0f       	add	r25, r21
    103e:	50 e0       	ldi	r21, 0x00	; 0
    1040:	55 1f       	adc	r21, r21
    1042:	62 9f       	mul	r22, r18
    1044:	f0 01       	movw	r30, r0
    1046:	72 9f       	mul	r23, r18
    1048:	bb 27       	eor	r27, r27
    104a:	f0 0d       	add	r31, r0
    104c:	b1 1d       	adc	r27, r1
    104e:	63 9f       	mul	r22, r19
    1050:	aa 27       	eor	r26, r26
    1052:	f0 0d       	add	r31, r0
    1054:	b1 1d       	adc	r27, r1
    1056:	aa 1f       	adc	r26, r26
    1058:	64 9f       	mul	r22, r20
    105a:	66 27       	eor	r22, r22
    105c:	b0 0d       	add	r27, r0
    105e:	a1 1d       	adc	r26, r1
    1060:	66 1f       	adc	r22, r22
    1062:	82 9f       	mul	r24, r18
    1064:	22 27       	eor	r18, r18
    1066:	b0 0d       	add	r27, r0
    1068:	a1 1d       	adc	r26, r1
    106a:	62 1f       	adc	r22, r18
    106c:	73 9f       	mul	r23, r19
    106e:	b0 0d       	add	r27, r0
    1070:	a1 1d       	adc	r26, r1
    1072:	62 1f       	adc	r22, r18
    1074:	83 9f       	mul	r24, r19
    1076:	a0 0d       	add	r26, r0
    1078:	61 1d       	adc	r22, r1
    107a:	22 1f       	adc	r18, r18
    107c:	74 9f       	mul	r23, r20
    107e:	33 27       	eor	r19, r19
    1080:	a0 0d       	add	r26, r0
    1082:	61 1d       	adc	r22, r1
    1084:	23 1f       	adc	r18, r19
    1086:	84 9f       	mul	r24, r20
    1088:	60 0d       	add	r22, r0
    108a:	21 1d       	adc	r18, r1
    108c:	82 2f       	mov	r24, r18
    108e:	76 2f       	mov	r23, r22
    1090:	6a 2f       	mov	r22, r26
    1092:	11 24       	eor	r1, r1
    1094:	9f 57       	subi	r25, 0x7F	; 127
    1096:	50 40       	sbci	r21, 0x00	; 0
    1098:	9a f0       	brmi	.+38     	; 0x10c0 <__mulsf3_pse+0x88>
    109a:	f1 f0       	breq	.+60     	; 0x10d8 <__mulsf3_pse+0xa0>
    109c:	88 23       	and	r24, r24
    109e:	4a f0       	brmi	.+18     	; 0x10b2 <__mulsf3_pse+0x7a>
    10a0:	ee 0f       	add	r30, r30
    10a2:	ff 1f       	adc	r31, r31
    10a4:	bb 1f       	adc	r27, r27
    10a6:	66 1f       	adc	r22, r22
    10a8:	77 1f       	adc	r23, r23
    10aa:	88 1f       	adc	r24, r24
    10ac:	91 50       	subi	r25, 0x01	; 1
    10ae:	50 40       	sbci	r21, 0x00	; 0
    10b0:	a9 f7       	brne	.-22     	; 0x109c <__mulsf3_pse+0x64>
    10b2:	9e 3f       	cpi	r25, 0xFE	; 254
    10b4:	51 05       	cpc	r21, r1
    10b6:	80 f0       	brcs	.+32     	; 0x10d8 <__mulsf3_pse+0xa0>
    10b8:	0c 94 13 07 	jmp	0xe26	; 0xe26 <__fp_inf>
    10bc:	0c 94 85 07 	jmp	0xf0a	; 0xf0a <__fp_szero>
    10c0:	5f 3f       	cpi	r21, 0xFF	; 255
    10c2:	e4 f3       	brlt	.-8      	; 0x10bc <__mulsf3_pse+0x84>
    10c4:	98 3e       	cpi	r25, 0xE8	; 232
    10c6:	d4 f3       	brlt	.-12     	; 0x10bc <__mulsf3_pse+0x84>
    10c8:	86 95       	lsr	r24
    10ca:	77 95       	ror	r23
    10cc:	67 95       	ror	r22
    10ce:	b7 95       	ror	r27
    10d0:	f7 95       	ror	r31
    10d2:	e7 95       	ror	r30
    10d4:	9f 5f       	subi	r25, 0xFF	; 255
    10d6:	c1 f7       	brne	.-16     	; 0x10c8 <__mulsf3_pse+0x90>
    10d8:	fe 2b       	or	r31, r30
    10da:	88 0f       	add	r24, r24
    10dc:	91 1d       	adc	r25, r1
    10de:	96 95       	lsr	r25
    10e0:	87 95       	ror	r24
    10e2:	97 f9       	bld	r25, 7
    10e4:	08 95       	ret

000010e6 <round>:
    10e6:	0e 94 6a 07 	call	0xed4	; 0xed4 <__fp_splitA>
    10ea:	e8 f0       	brcs	.+58     	; 0x1126 <round+0x40>
    10ec:	9e 37       	cpi	r25, 0x7E	; 126
    10ee:	e8 f0       	brcs	.+58     	; 0x112a <round+0x44>
    10f0:	96 39       	cpi	r25, 0x96	; 150
    10f2:	b8 f4       	brcc	.+46     	; 0x1122 <round+0x3c>
    10f4:	9e 38       	cpi	r25, 0x8E	; 142
    10f6:	48 f4       	brcc	.+18     	; 0x110a <round+0x24>
    10f8:	67 2f       	mov	r22, r23
    10fa:	78 2f       	mov	r23, r24
    10fc:	88 27       	eor	r24, r24
    10fe:	98 5f       	subi	r25, 0xF8	; 248
    1100:	f9 cf       	rjmp	.-14     	; 0x10f4 <round+0xe>
    1102:	86 95       	lsr	r24
    1104:	77 95       	ror	r23
    1106:	67 95       	ror	r22
    1108:	93 95       	inc	r25
    110a:	95 39       	cpi	r25, 0x95	; 149
    110c:	d0 f3       	brcs	.-12     	; 0x1102 <round+0x1c>
    110e:	b6 2f       	mov	r27, r22
    1110:	b1 70       	andi	r27, 0x01	; 1
    1112:	6b 0f       	add	r22, r27
    1114:	71 1d       	adc	r23, r1
    1116:	81 1d       	adc	r24, r1
    1118:	20 f4       	brcc	.+8      	; 0x1122 <round+0x3c>
    111a:	87 95       	ror	r24
    111c:	77 95       	ror	r23
    111e:	67 95       	ror	r22
    1120:	93 95       	inc	r25
    1122:	0c 94 97 08 	jmp	0x112e	; 0x112e <__fp_mintl>
    1126:	0c 94 b2 08 	jmp	0x1164	; 0x1164 <__fp_mpack>
    112a:	0c 94 85 07 	jmp	0xf0a	; 0xf0a <__fp_szero>

0000112e <__fp_mintl>:
    112e:	88 23       	and	r24, r24
    1130:	71 f4       	brne	.+28     	; 0x114e <__fp_mintl+0x20>
    1132:	77 23       	and	r23, r23
    1134:	21 f0       	breq	.+8      	; 0x113e <__fp_mintl+0x10>
    1136:	98 50       	subi	r25, 0x08	; 8
    1138:	87 2b       	or	r24, r23
    113a:	76 2f       	mov	r23, r22
    113c:	07 c0       	rjmp	.+14     	; 0x114c <__fp_mintl+0x1e>
    113e:	66 23       	and	r22, r22
    1140:	11 f4       	brne	.+4      	; 0x1146 <__fp_mintl+0x18>
    1142:	99 27       	eor	r25, r25
    1144:	0d c0       	rjmp	.+26     	; 0x1160 <__fp_mintl+0x32>
    1146:	90 51       	subi	r25, 0x10	; 16
    1148:	86 2b       	or	r24, r22
    114a:	70 e0       	ldi	r23, 0x00	; 0
    114c:	60 e0       	ldi	r22, 0x00	; 0
    114e:	2a f0       	brmi	.+10     	; 0x115a <__fp_mintl+0x2c>
    1150:	9a 95       	dec	r25
    1152:	66 0f       	add	r22, r22
    1154:	77 1f       	adc	r23, r23
    1156:	88 1f       	adc	r24, r24
    1158:	da f7       	brpl	.-10     	; 0x1150 <__fp_mintl+0x22>
    115a:	88 0f       	add	r24, r24
    115c:	96 95       	lsr	r25
    115e:	87 95       	ror	r24
    1160:	97 f9       	bld	r25, 7
    1162:	08 95       	ret

00001164 <__fp_mpack>:
    1164:	9f 3f       	cpi	r25, 0xFF	; 255
    1166:	31 f0       	breq	.+12     	; 0x1174 <__fp_mpack_finite+0xc>

00001168 <__fp_mpack_finite>:
    1168:	91 50       	subi	r25, 0x01	; 1
    116a:	20 f4       	brcc	.+8      	; 0x1174 <__fp_mpack_finite+0xc>
    116c:	87 95       	ror	r24
    116e:	77 95       	ror	r23
    1170:	67 95       	ror	r22
    1172:	b7 95       	ror	r27
    1174:	88 0f       	add	r24, r24
    1176:	91 1d       	adc	r25, r1
    1178:	96 95       	lsr	r25
    117a:	87 95       	ror	r24
    117c:	97 f9       	bld	r25, 7
    117e:	08 95       	ret

00001180 <_exit>:
    1180:	f8 94       	cli

00001182 <__stop_program>:
    1182:	ff cf       	rjmp	.-2      	; 0x1182 <__stop_program>
