
Building_Brains_V4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000016  00803e00  00001640  000016f4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001614  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000002c  00009614  00001614  000016c8  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .bss          00000059  00803e16  00803e16  0000170a  2**0
                  ALLOC
  4 .comment      00000030  00000000  00000000  0000170a  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  0000173c  2**2
                  CONTENTS, READONLY
  6 .debug_aranges 000004b8  00000000  00000000  00001778  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00007968  00000000  00000000  00001c30  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00002fe9  00000000  00000000  00009598  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000026e0  00000000  00000000  0000c581  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000804  00000000  00000000  0000ec64  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00002fe1  00000000  00000000  0000f468  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000012a4  00000000  00000000  00012449  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000330  00000000  00000000  000136ed  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	3c c0       	rjmp	.+120    	; 0x7a <__ctors_end>
       2:	56 c0       	rjmp	.+172    	; 0xb0 <__bad_interrupt>
       4:	55 c0       	rjmp	.+170    	; 0xb0 <__bad_interrupt>
       6:	54 c0       	rjmp	.+168    	; 0xb0 <__bad_interrupt>
       8:	53 c0       	rjmp	.+166    	; 0xb0 <__bad_interrupt>
       a:	52 c0       	rjmp	.+164    	; 0xb0 <__bad_interrupt>
       c:	96 c6       	rjmp	.+3372   	; 0xd3a <__vector_6>
       e:	50 c0       	rjmp	.+160    	; 0xb0 <__bad_interrupt>
      10:	4f c0       	rjmp	.+158    	; 0xb0 <__bad_interrupt>
      12:	4e c0       	rjmp	.+156    	; 0xb0 <__bad_interrupt>
      14:	4d c0       	rjmp	.+154    	; 0xb0 <__bad_interrupt>
      16:	4c c0       	rjmp	.+152    	; 0xb0 <__bad_interrupt>
      18:	4b c0       	rjmp	.+150    	; 0xb0 <__bad_interrupt>
      1a:	4a c0       	rjmp	.+148    	; 0xb0 <__bad_interrupt>
      1c:	49 c0       	rjmp	.+146    	; 0xb0 <__bad_interrupt>
      1e:	48 c0       	rjmp	.+144    	; 0xb0 <__bad_interrupt>
      20:	47 c0       	rjmp	.+142    	; 0xb0 <__bad_interrupt>
      22:	46 c0       	rjmp	.+140    	; 0xb0 <__bad_interrupt>
      24:	45 c0       	rjmp	.+138    	; 0xb0 <__bad_interrupt>
      26:	44 c0       	rjmp	.+136    	; 0xb0 <__bad_interrupt>
      28:	43 c0       	rjmp	.+134    	; 0xb0 <__bad_interrupt>
      2a:	42 c0       	rjmp	.+132    	; 0xb0 <__bad_interrupt>
      2c:	41 c0       	rjmp	.+130    	; 0xb0 <__bad_interrupt>
      2e:	40 c0       	rjmp	.+128    	; 0xb0 <__bad_interrupt>
      30:	3f c0       	rjmp	.+126    	; 0xb0 <__bad_interrupt>
      32:	3e c0       	rjmp	.+124    	; 0xb0 <__bad_interrupt>
      34:	07 63       	ori	r16, 0x37	; 55
      36:	42 36       	cpi	r20, 0x62	; 98
      38:	b7 9b       	sbis	0x16, 7	; 22
      3a:	d8 a7       	std	Y+40, r29	; 0x28
      3c:	1a 39       	cpi	r17, 0x9A	; 154
      3e:	68 56       	subi	r22, 0x68	; 104
      40:	18 ae       	std	Y+56, r1	; 0x38
      42:	ba ab       	std	Y+50, r27	; 0x32
      44:	55 8c       	ldd	r5, Z+29	; 0x1d
      46:	1d 3c       	cpi	r17, 0xCD	; 205
      48:	b7 cc       	rjmp	.-1682   	; 0xfffff9b8 <__eeprom_end+0xff7ef9b8>
      4a:	57 63       	ori	r21, 0x37	; 55
      4c:	bd 6d       	ori	r27, 0xDD	; 221
      4e:	ed fd       	.word	0xfded	; ????
      50:	75 3e       	cpi	r23, 0xE5	; 229
      52:	f6 17       	cp	r31, r22
      54:	72 31       	cpi	r23, 0x12	; 18
      56:	bf 00       	.word	0x00bf	; ????
      58:	00 00       	nop
      5a:	80 3f       	cpi	r24, 0xF0	; 240
      5c:	05 a8       	ldd	r0, Z+53	; 0x35
      5e:	4c cd       	rjmp	.-1384   	; 0xfffffaf8 <__eeprom_end+0xff7efaf8>
      60:	b2 d4       	rcall	.+2404   	; 0x9c6 <find_newest_pulse+0x1e>
      62:	4e b9       	out	0x0e, r20	; 14
      64:	38 36       	cpi	r19, 0x68	; 104
      66:	a9 02       	muls	r26, r25
      68:	0c 50       	subi	r16, 0x0C	; 12
      6a:	b9 91       	ld	r27, Y+
      6c:	86 88       	ldd	r8, Z+22	; 0x16
      6e:	08 3c       	cpi	r16, 0xC8	; 200
      70:	a6 aa       	std	Z+54, r10	; 0x36
      72:	aa 2a       	or	r10, r26
      74:	be 00       	.word	0x00be	; ????
      76:	00 00       	nop
      78:	80 3f       	cpi	r24, 0xF0	; 240

0000007a <__ctors_end>:
      7a:	11 24       	eor	r1, r1
      7c:	1f be       	out	0x3f, r1	; 63
      7e:	cf ef       	ldi	r28, 0xFF	; 255
      80:	cd bf       	out	0x3d, r28	; 61
      82:	df e3       	ldi	r29, 0x3F	; 63
      84:	de bf       	out	0x3e, r29	; 62

00000086 <__do_copy_data>:
      86:	1e e3       	ldi	r17, 0x3E	; 62
      88:	a0 e0       	ldi	r26, 0x00	; 0
      8a:	be e3       	ldi	r27, 0x3E	; 62
      8c:	e0 e4       	ldi	r30, 0x40	; 64
      8e:	f6 e1       	ldi	r31, 0x16	; 22
      90:	02 c0       	rjmp	.+4      	; 0x96 <__do_copy_data+0x10>
      92:	05 90       	lpm	r0, Z+
      94:	0d 92       	st	X+, r0
      96:	a6 31       	cpi	r26, 0x16	; 22
      98:	b1 07       	cpc	r27, r17
      9a:	d9 f7       	brne	.-10     	; 0x92 <__do_copy_data+0xc>

0000009c <__do_clear_bss>:
      9c:	2e e3       	ldi	r18, 0x3E	; 62
      9e:	a6 e1       	ldi	r26, 0x16	; 22
      a0:	be e3       	ldi	r27, 0x3E	; 62
      a2:	01 c0       	rjmp	.+2      	; 0xa6 <.do_clear_bss_start>

000000a4 <.do_clear_bss_loop>:
      a4:	1d 92       	st	X+, r1

000000a6 <.do_clear_bss_start>:
      a6:	af 36       	cpi	r26, 0x6F	; 111
      a8:	b2 07       	cpc	r27, r18
      aa:	e1 f7       	brne	.-8      	; 0xa4 <.do_clear_bss_loop>
      ac:	a6 d1       	rcall	.+844    	; 0x3fa <main>
      ae:	b0 ca       	rjmp	.-2720   	; 0xfffff610 <__eeprom_end+0xff7ef610>

000000b0 <__bad_interrupt>:
      b0:	a7 cf       	rjmp	.-178    	; 0x0 <__vectors>

000000b2 <atmel_start_init>:
/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
	system_init();
      b2:	c2 d0       	rcall	.+388    	; 0x238 <system_init>
      b4:	08 95       	ret

000000b6 <ADC_init>:
 * \return Conversion result read from the ADC ADC module
 */
adc_result_t ADC_get_conversion_result(void)
{
	return (ADC0.RES);
}
      b6:	85 e0       	ldi	r24, 0x05	; 5
      b8:	80 93 00 06 	sts	0x0600, r24	; 0x800600 <__TEXT_REGION_LENGTH__+0x700600>
      bc:	80 e0       	ldi	r24, 0x00	; 0
      be:	08 95       	ret

000000c0 <ADC_is_conversion_done>:
      c0:	80 91 0b 06 	lds	r24, 0x060B	; 0x80060b <__TEXT_REGION_LENGTH__+0x70060b>
      c4:	81 70       	andi	r24, 0x01	; 1
      c6:	08 95       	ret

000000c8 <ADC_get_conversion>:
 *
 * \return Nothing
 */
void ADC_start_conversion(adc_0_channel_t channel)
{
	ADC0.MUXPOS  = channel;
      c8:	e0 e0       	ldi	r30, 0x00	; 0
      ca:	f6 e0       	ldi	r31, 0x06	; 6
      cc:	86 83       	std	Z+6, r24	; 0x06
	ADC0.COMMAND = ADC_STCONV_bm;
      ce:	81 e0       	ldi	r24, 0x01	; 1
      d0:	80 87       	std	Z+8, r24	; 0x08
adc_result_t ADC_get_conversion(adc_0_channel_t channel)
{
	adc_result_t res;

	ADC_start_conversion(channel);
	while (!ADC_is_conversion_done())
      d2:	f6 df       	rcall	.-20     	; 0xc0 <ADC_is_conversion_done>
      d4:	88 23       	and	r24, r24
      d6:	e9 f3       	breq	.-6      	; 0xd2 <ADC_get_conversion+0xa>
 *
 * \return Conversion result read from the ADC ADC module
 */
adc_result_t ADC_get_conversion_result(void)
{
	return (ADC0.RES);
      d8:	e0 e0       	ldi	r30, 0x00	; 0
      da:	f6 e0       	ldi	r31, 0x06	; 6
      dc:	20 89       	ldd	r18, Z+16	; 0x10
      de:	31 89       	ldd	r19, Z+17	; 0x11

	ADC_start_conversion(channel);
	while (!ADC_is_conversion_done())
		;
	res = ADC_get_conversion_result();
	ADC0.INTFLAGS |= ADC_RESRDY_bm;
      e0:	93 85       	ldd	r25, Z+11	; 0x0b
      e2:	91 60       	ori	r25, 0x01	; 1
      e4:	93 87       	std	Z+11, r25	; 0x0b
	return res;
}
      e6:	c9 01       	movw	r24, r18
      e8:	08 95       	ret

000000ea <BOD_init>:
	//		 | BOD_VLMCFG_ABOVE_gc; /* Interrupt when supply goes above VLM level */

	// BOD.VLMCTRLA = BOD_VLMLVL_5ABOVE_gc; /* VLM threshold 5% above BOD level */

	return 0;
}
      ea:	80 e0       	ldi	r24, 0x00	; 0
      ec:	08 95       	ret

000000ee <DIGGSIGG_init>:
	//		 | CCL_EDGEDET_DIS_gc /* Edge detector is disabled */
	//		 | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	//		 | 0 << CCL_ENABLE_bp /* LUT Enable: disabled */
	//		 | 0 << CCL_OUTEN_bp; /* Output Enable: disabled */

	CCL.TRUTH1 = 168; /* Truth 1: 168 */
      ee:	e0 ec       	ldi	r30, 0xC0	; 192
      f0:	f1 e0       	ldi	r31, 0x01	; 1
      f2:	88 ea       	ldi	r24, 0xA8	; 168
      f4:	84 87       	std	Z+12, r24	; 0x0c

	CCL.LUT1CTRLC = CCL_INSEL2_TCA0_gc /* TCA0 WO2 input source */;
      f6:	88 e0       	ldi	r24, 0x08	; 8
      f8:	83 87       	std	Z+11, r24	; 0x0b

	CCL.LUT1CTRLB = CCL_INSEL0_SPI0_gc /* SPI0 SCK source */
      fa:	8b eb       	ldi	r24, 0xBB	; 187
      fc:	82 87       	std	Z+10, r24	; 0x0a
	                | CCL_INSEL1_SPI0_gc /* SPI0 MOSI input source */;

	CCL.LUT1CTRLA = 0 << CCL_CLKSRC_bp       /* Clock Source Selection: disabled */
      fe:	89 e0       	ldi	r24, 0x09	; 9
     100:	81 87       	std	Z+9, r24	; 0x09
	                | CCL_EDGEDET_DIS_gc     /* Edge detector is disabled */
	                | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	                | 1 << CCL_ENABLE_bp     /* LUT Enable: enabled */
	                | 1 << CCL_OUTEN_bp;     /* Output Enable: enabled */

	CCL.CTRLA = 1 << CCL_ENABLE_bp      /* Enable: enabled */
     102:	81 e4       	ldi	r24, 0x41	; 65
     104:	80 83       	st	Z, r24
	            | 1 << CCL_RUNSTDBY_bp; /* Run in Standby: enabled */

	return 0;
}
     106:	80 e0       	ldi	r24, 0x00	; 0
     108:	08 95       	ret

0000010a <CLKCTRL_init>:
 *       on calling convention. The memory model is not visible to the
 *       preprocessor, so it must be defined in the Assembler preprocessor directives.
 */
static inline void ccp_write_io(void *addr, uint8_t value)
{
	protected_write_io(addr, CCP_IOREG_gc, value);
     10a:	47 e0       	ldi	r20, 0x07	; 7
     10c:	68 ed       	ldi	r22, 0xD8	; 216
     10e:	8c e7       	ldi	r24, 0x7C	; 124
     110:	90 e0       	ldi	r25, 0x00	; 0
     112:	ad d0       	rcall	.+346    	; 0x26e <protected_write_io>
     114:	41 e0       	ldi	r20, 0x01	; 1
     116:	68 ed       	ldi	r22, 0xD8	; 216
     118:	81 e6       	ldi	r24, 0x61	; 97
     11a:	90 e0       	ldi	r25, 0x00	; 0
     11c:	a8 d0       	rcall	.+336    	; 0x26e <protected_write_io>
	//		 | 0 << CLKCTRL_CLKOUT_bp /* System clock out: disabled */);

	// ccp_write_io((void*)&(CLKCTRL.MCLKLOCK),0 << CLKCTRL_LOCKEN_bp /* lock enable: disabled */);

	return 0;
}
     11e:	80 e0       	ldi	r24, 0x00	; 0
     120:	08 95       	ret

00000122 <CPUINT_init>:

	// CPUINT.LVL0PRI = 0x0 << CPUINT_LVL0PRI_gp; /* Interrupt Level Priority: 0x0 */

	// CPUINT.LVL1VEC = 0x0 << CPUINT_LVL1VEC_gp; /* Interrupt Vector with High Priority: 0x0 */

	ENABLE_INTERRUPTS();
     122:	78 94       	sei

	return 0;
}
     124:	80 e0       	ldi	r24, 0x00	; 0
     126:	08 95       	ret

00000128 <DAC_init>:
 *
 * \return Nothing
 */
void DAC_disable()
{
	DAC0.CTRLA &= ~DAC_ENABLE_bm;
     128:	81 e4       	ldi	r24, 0x41	; 65
     12a:	80 93 80 06 	sts	0x0680, r24	; 0x800680 <__TEXT_REGION_LENGTH__+0x700680>
     12e:	80 e0       	ldi	r24, 0x00	; 0
     130:	08 95       	ret

00000132 <DAC_set_output>:
 *
 * \return Nothing
 */
void DAC_set_output(dac_resolution_t value)
{
	DAC0.DATA = value;
     132:	80 93 81 06 	sts	0x0681, r24	; 0x800681 <__TEXT_REGION_LENGTH__+0x700681>
     136:	08 95       	ret

00000138 <mcu_init>:
#ifdef __cplusplus
extern "C" {
#endif

void mcu_init(void)
{
     138:	e0 e1       	ldi	r30, 0x10	; 16
     13a:	f4 e0       	ldi	r31, 0x04	; 4
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     13c:	80 81       	ld	r24, Z
     13e:	88 60       	ori	r24, 0x08	; 8
     140:	81 93       	st	Z+, r24
	 * disables all peripherals to save power. Driver shall enable
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
     142:	e8 31       	cpi	r30, 0x18	; 24
     144:	84 e0       	ldi	r24, 0x04	; 4
     146:	f8 07       	cpc	r31, r24
     148:	c9 f7       	brne	.-14     	; 0x13c <mcu_init+0x4>
     14a:	e0 e3       	ldi	r30, 0x30	; 48
     14c:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     14e:	80 81       	ld	r24, Z
     150:	88 60       	ori	r24, 0x08	; 8
     152:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     154:	e8 33       	cpi	r30, 0x38	; 56
     156:	84 e0       	ldi	r24, 0x04	; 4
     158:	f8 07       	cpc	r31, r24
     15a:	c9 f7       	brne	.-14     	; 0x14e <mcu_init+0x16>
     15c:	e0 e5       	ldi	r30, 0x50	; 80
     15e:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     160:	80 81       	ld	r24, Z
     162:	88 60       	ori	r24, 0x08	; 8
     164:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     166:	e8 35       	cpi	r30, 0x58	; 88
     168:	84 e0       	ldi	r24, 0x04	; 4
     16a:	f8 07       	cpc	r31, r24
     16c:	c9 f7       	brne	.-14     	; 0x160 <mcu_init+0x28>
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}
}
     16e:	08 95       	ret

00000170 <ADC_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     170:	e5 e1       	ldi	r30, 0x15	; 21
     172:	f4 e0       	ldi	r31, 0x04	; 4
     174:	80 81       	ld	r24, Z
     176:	88 7f       	andi	r24, 0xF8	; 248
     178:	84 60       	ori	r24, 0x04	; 4
     17a:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     17c:	80 81       	ld	r24, Z
     17e:	87 7f       	andi	r24, 0xF7	; 247
     180:	80 83       	st	Z, r24
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     182:	e7 e1       	ldi	r30, 0x17	; 23
     184:	f4 e0       	ldi	r31, 0x04	; 4
     186:	80 81       	ld	r24, Z
     188:	88 7f       	andi	r24, 0xF8	; 248
     18a:	84 60       	ori	r24, 0x04	; 4
     18c:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     18e:	80 81       	ld	r24, Z
     190:	87 7f       	andi	r24, 0xF7	; 247
     192:	80 83       	st	Z, r24
 */
static inline void PORTB_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     194:	e4 e3       	ldi	r30, 0x34	; 52
     196:	f4 e0       	ldi	r31, 0x04	; 4
     198:	80 81       	ld	r24, Z
     19a:	88 7f       	andi	r24, 0xF8	; 248
     19c:	84 60       	ori	r24, 0x04	; 4
     19e:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     1a0:	80 81       	ld	r24, Z
     1a2:	87 7f       	andi	r24, 0xF7	; 247
     1a4:	80 83       	st	Z, r24
 */
static inline void PORTB_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     1a6:	e1 e3       	ldi	r30, 0x31	; 49
     1a8:	f4 e0       	ldi	r31, 0x04	; 4
     1aa:	80 81       	ld	r24, Z
     1ac:	88 7f       	andi	r24, 0xF8	; 248
     1ae:	84 60       	ori	r24, 0x04	; 4
     1b0:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     1b2:	80 81       	ld	r24, Z
     1b4:	87 7f       	andi	r24, 0xF7	; 247
     1b6:	80 83       	st	Z, r24
 */
static inline void PORTB_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     1b8:	e0 e3       	ldi	r30, 0x30	; 48
     1ba:	f4 e0       	ldi	r31, 0x04	; 4
     1bc:	80 81       	ld	r24, Z
     1be:	88 7f       	andi	r24, 0xF8	; 248
     1c0:	84 60       	ori	r24, 0x04	; 4
     1c2:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     1c4:	80 81       	ld	r24, Z
     1c6:	87 7f       	andi	r24, 0xF7	; 247
     1c8:	80 83       	st	Z, r24
	// Disable digital input buffer
	DEN4_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	DEN4_PIN_set_pull_mode(PORT_PULL_OFF);

	ADC_init();
     1ca:	75 df       	rcall	.-278    	; 0xb6 <ADC_init>
     1cc:	08 95       	ret

000001ce <USART_0_initialization>:
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     1ce:	23 98       	cbi	0x04, 3	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     1d0:	e3 e3       	ldi	r30, 0x33	; 51
     1d2:	f4 e0       	ldi	r31, 0x04	; 4
     1d4:	80 81       	ld	r24, Z
     1d6:	87 7f       	andi	r24, 0xF7	; 247
     1d8:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     1da:	22 9a       	sbi	0x04, 2	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     1dc:	2a 98       	cbi	0x05, 2	; 5
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	USART_0_init();
     1de:	81 d0       	rcall	.+258    	; 0x2e2 <USART_0_init>
     1e0:	08 95       	ret

000001e2 <TIMER_0_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     1e2:	25 9a       	sbi	0x04, 5	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     1e4:	2d 98       	cbi	0x05, 5	; 5
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLC |= PORTMUX_TCA02_bm;
     1e6:	e0 e0       	ldi	r30, 0x00	; 0
     1e8:	f2 e0       	ldi	r31, 0x02	; 2
     1ea:	82 81       	ldd	r24, Z+2	; 0x02
     1ec:	84 60       	ori	r24, 0x04	; 4
     1ee:	82 83       	std	Z+2, r24	; 0x02

	TIMER_0_init();
     1f0:	68 d0       	rcall	.+208    	; 0x2c2 <TIMER_0_init>
     1f2:	08 95       	ret

000001f4 <DIGGSIGG_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTC.DIR |= (1 << pin);
     1f4:	41 9a       	sbi	0x08, 1	; 8
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
	} else {
		VPORTC.OUT &= ~(1 << pin);
     1f6:	49 98       	cbi	0x09, 1	; 9
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLA |= PORTMUX_LUT1_bm;
     1f8:	e0 e0       	ldi	r30, 0x00	; 0
     1fa:	f2 e0       	ldi	r31, 0x02	; 2
     1fc:	80 81       	ld	r24, Z
     1fe:	80 62       	ori	r24, 0x20	; 32
     200:	80 83       	st	Z, r24

	DIGGSIGG_init();
     202:	75 df       	rcall	.-278    	; 0xee <DIGGSIGG_init>
     204:	08 95       	ret

00000206 <SPI_0_initialization>:
 */
static inline void PORTA_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
     206:	02 98       	cbi	0x00, 2	; 0
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     208:	e2 e1       	ldi	r30, 0x12	; 18
     20a:	f4 e0       	ldi	r31, 0x04	; 4
     20c:	80 81       	ld	r24, Z
     20e:	87 7f       	andi	r24, 0xF7	; 247
     210:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     212:	01 9a       	sbi	0x00, 1	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     214:	09 98       	cbi	0x01, 1	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     216:	03 9a       	sbi	0x00, 3	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     218:	0b 98       	cbi	0x01, 3	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     21a:	04 9a       	sbi	0x00, 4	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     21c:	0c 98       	cbi	0x01, 4	; 1
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	SPI_0_init();
     21e:	49 d0       	rcall	.+146    	; 0x2b2 <SPI_0_init>
     220:	08 95       	ret

00000222 <DAC_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     222:	e6 e1       	ldi	r30, 0x16	; 22
     224:	f4 e0       	ldi	r31, 0x04	; 4
     226:	80 81       	ld	r24, Z
     228:	88 7f       	andi	r24, 0xF8	; 248
     22a:	84 60       	ori	r24, 0x04	; 4
     22c:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     22e:	80 81       	ld	r24, Z
     230:	87 7f       	andi	r24, 0xF7	; 247
     232:	80 83       	st	Z, r24
	// Disable digital input buffer
	AXON_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	AXON_PIN_set_pull_mode(PORT_PULL_OFF);

	DAC_init();
     234:	79 df       	rcall	.-270    	; 0x128 <DAC_init>
     236:	08 95       	ret

00000238 <system_init>:
/**
 * \brief System initialization
 */
void system_init()
{
	mcu_init();
     238:	7f df       	rcall	.-258    	; 0x138 <mcu_init>
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     23a:	27 98       	cbi	0x04, 7	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     23c:	e7 e3       	ldi	r30, 0x37	; 55
     23e:	f4 e0       	ldi	r31, 0x04	; 4
     240:	80 81       	ld	r24, Z
     242:	87 7f       	andi	r24, 0xF7	; 247
     244:	80 83       	st	Z, r24
 */
static inline void PORTC_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
     246:	42 98       	cbi	0x08, 2	; 8
static inline void PORTC_set_pin_pull_mode(const uint8_t pin, const enum port_pull_mode pull_mode)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
     248:	e2 e5       	ldi	r30, 0x52	; 82
     24a:	f4 e0       	ldi	r31, 0x04	; 4
     24c:	80 81       	ld	r24, Z
     24e:	88 60       	ori	r24, 0x08	; 8
     250:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTC.DIR |= (1 << pin);
     252:	45 9a       	sbi	0x08, 5	; 8
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     254:	4d 9a       	sbi	0x09, 5	; 9
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    true);

	CLKCTRL_init();
     256:	59 df       	rcall	.-334    	; 0x10a <CLKCTRL_init>

	RTC_init();
     258:	0e d0       	rcall	.+28     	; 0x276 <RTC_init>

	ADC_initialization();
     25a:	8a df       	rcall	.-236    	; 0x170 <ADC_initialization>

	USART_0_initialization();
     25c:	b8 df       	rcall	.-144    	; 0x1ce <USART_0_initialization>

	TIMER_0_initialization();
     25e:	c1 df       	rcall	.-126    	; 0x1e2 <TIMER_0_initialization>

	DIGGSIGG_initialization();
     260:	c9 df       	rcall	.-110    	; 0x1f4 <DIGGSIGG_initialization>

	SPI_0_initialization();
     262:	d1 df       	rcall	.-94     	; 0x206 <SPI_0_initialization>

	DAC_initialization();
     264:	de df       	rcall	.-68     	; 0x222 <DAC_initialization>

	CPUINT_init();
     266:	5d df       	rcall	.-326    	; 0x122 <CPUINT_init>

	SLPCTRL_init();
     268:	22 d0       	rcall	.+68     	; 0x2ae <SLPCTRL_init>

	BOD_init();
     26a:	3f df       	rcall	.-386    	; 0xea <BOD_init>
     26c:	08 95       	ret

0000026e <protected_write_io>:
#if defined(__GNUC__)
  
#ifdef RAMPZ
	out     _SFR_IO_ADDR(RAMPZ), r1         // Clear bits 23:16 of Z
#endif
	movw    r30, r24                // Load addr into Z
     26e:	fc 01       	movw	r30, r24
	out     CCP, r22                // Start CCP handshake
     270:	64 bf       	out	0x34, r22	; 52
	st      Z, r20                  // Write value to I/O register
     272:	40 83       	st	Z, r20
	ret                             // Return to caller
     274:	08 95       	ret

00000276 <RTC_init>:
 * \return Initialization status.
 */
int8_t RTC_init()
{

	while (RTC.STATUS > 0) { /* Wait for all register to be synchronized */
     276:	e0 e4       	ldi	r30, 0x40	; 64
     278:	f1 e0       	ldi	r31, 0x01	; 1
     27a:	81 81       	ldd	r24, Z+1	; 0x01
     27c:	81 11       	cpse	r24, r1
     27e:	fd cf       	rjmp	.-6      	; 0x27a <RTC_init+0x4>
	}

	// RTC.CMP = 0x0; /* Compare: 0x0 */

	RTC.CNT = 0x20; /* Counter: 0x20 */
     280:	e0 e4       	ldi	r30, 0x40	; 64
     282:	f1 e0       	ldi	r31, 0x01	; 1
     284:	80 e2       	ldi	r24, 0x20	; 32
     286:	90 e0       	ldi	r25, 0x00	; 0
     288:	80 87       	std	Z+8, r24	; 0x08
     28a:	91 87       	std	Z+9, r25	; 0x09

	RTC.CTRLA = RTC_PRESCALER_DIV1_gc   /* 1 */
     28c:	81 e8       	ldi	r24, 0x81	; 129
     28e:	80 83       	st	Z, r24
	            | 1 << RTC_RTCEN_bp     /* Enable: enabled */
	            | 1 << RTC_RUNSTDBY_bp; /* Run In Standby: enabled */

	RTC.PER = 0x20 / TIMESCALE; /* Period: 0x20 */
     290:	80 e8       	ldi	r24, 0x80	; 128
     292:	92 e0       	ldi	r25, 0x02	; 2
     294:	82 87       	std	Z+10, r24	; 0x0a
     296:	93 87       	std	Z+11, r25	; 0x0b

	// RTC.CLKSEL = RTC_CLKSEL_INT32K_gc; /* 32KHz Internal Ultra Low Power Oscillator (OSCULP32K) */

	RTC.DBGCTRL = 1 << RTC_DBGRUN_bp; /* Run in debug: enabled */
     298:	81 e0       	ldi	r24, 0x01	; 1
     29a:	85 83       	std	Z+5, r24	; 0x05

	RTC.INTCTRL = 0 << RTC_CMP_bp    /* Compare Match Interrupt enable: disabled */
     29c:	82 83       	std	Z+2, r24	; 0x02
	              | 1 << RTC_OVF_bp; /* Overflow Interrupt enable: enabled */

	while (RTC.PITSTATUS > 0) { /* Wait for all register to be synchronized */
     29e:	81 89       	ldd	r24, Z+17	; 0x11
     2a0:	81 11       	cpse	r24, r1
     2a2:	fd cf       	rjmp	.-6      	; 0x29e <RTC_init+0x28>
	}

	RTC.PITCTRLA = RTC_PERIOD_OFF_gc    /* Off */
     2a4:	81 e0       	ldi	r24, 0x01	; 1
     2a6:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <__TEXT_REGION_LENGTH__+0x700150>
	// RTC.PITDBGCTRL = 0 << RTC_DBGRUN_bp; /* Run in debug: disabled */

	// RTC.PITINTCTRL = 0 << RTC_PI_bp; /* Periodic Interrupt: disabled */

	return 0;
}
     2aa:	80 e0       	ldi	r24, 0x00	; 0
     2ac:	08 95       	ret

000002ae <SLPCTRL_init>:

	// SLPCTRL.CTRLA = 0 << SLPCTRL_SEN_bp /* Sleep enable: disabled */
	//		 | SLPCTRL_SMODE_IDLE_gc; /* Idle mode */

	return 0;
}
     2ae:	80 e0       	ldi	r24, 0x00	; 0
     2b0:	08 95       	ret

000002b2 <SPI_0_init>:
 * \return Initialization status
 */
int8_t SPI_0_init()
{

	SPI0.CTRLA = 0 << SPI_CLK2X_bp     /* Enable Double Speed: disabled */
     2b2:	e0 e2       	ldi	r30, 0x20	; 32
     2b4:	f8 e0       	ldi	r31, 0x08	; 8
     2b6:	83 e2       	ldi	r24, 0x23	; 35
     2b8:	80 83       	st	Z, r24
	             | 0 << SPI_DORD_bp    /* Data Order Setting: disabled */
	             | 1 << SPI_ENABLE_bp  /* Enable Module: enabled */
	             | 1 << SPI_MASTER_bp  /* SPI module in master mode */
	             | SPI_PRESC_DIV16_gc; /* System Clock / 16 */

	SPI0.CTRLB = 0 << SPI_BUFEN_bp   /* Buffer Mode Enable: disabled */
     2ba:	84 e0       	ldi	r24, 0x04	; 4
     2bc:	81 83       	std	Z+1, r24	; 0x01
	//		 | 0 << SPI_RXCIE_bp /* Receive Complete Interrupt Enable: disabled */
	//		 | 0 << SPI_SSIE_bp /* Slave Select Trigger Interrupt Enable: disabled */
	//		 | 0 << SPI_TXCIE_bp; /* Transfer Complete Interrupt Enable: disabled */

	return 0;
}
     2be:	80 e0       	ldi	r24, 0x00	; 0
     2c0:	08 95       	ret

000002c2 <TIMER_0_init>:

	// TCA0.SINGLE.CMP0 = 0x0; /* Compare Register 0: 0x0 */

	// TCA0.SINGLE.CMP1 = 0x0; /* Compare Register 1: 0x0 */

	TCA0.SINGLE.CMP2 = 0x4; /* Compare Register 2: 0x4 */
     2c2:	e0 e0       	ldi	r30, 0x00	; 0
     2c4:	fa e0       	ldi	r31, 0x0A	; 10
     2c6:	84 e0       	ldi	r24, 0x04	; 4
     2c8:	90 e0       	ldi	r25, 0x00	; 0
     2ca:	84 a7       	std	Z+44, r24	; 0x2c
     2cc:	95 a7       	std	Z+45, r25	; 0x2d

	// TCA0.SINGLE.CNT = 0x0; /* Count: 0x0 */

	TCA0.SINGLE.CTRLB = 0 << TCA_SINGLE_ALUPD_bp            /* Auto Lock Update: disabled */
     2ce:	83 e4       	ldi	r24, 0x43	; 67
     2d0:	81 83       	std	Z+1, r24	; 0x01
	                    | 0 << TCA_SINGLE_CMP0EN_bp         /* Compare 0 Enable: disabled */
	                    | 0 << TCA_SINGLE_CMP1EN_bp         /* Compare 1 Enable: disabled */
	                    | 1 << TCA_SINGLE_CMP2EN_bp         /* Compare 2 Enable: enabled */
	                    | TCA_SINGLE_WGMODE_SINGLESLOPE_gc; /*  */

	TCA0.SINGLE.CTRLC = 0 << TCA_SINGLE_CMP0OV_bp    /* Compare 0 Waveform Output Value: disabled */
     2d2:	84 e0       	ldi	r24, 0x04	; 4
     2d4:	82 83       	std	Z+2, r24	; 0x02
	// TCA0.SINGLE.INTCTRL = 0 << TCA_SINGLE_CMP0_bp /* Compare 0 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP1_bp /* Compare 1 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP2_bp /* Compare 2 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_OVF_bp; /* Overflow Interrupt: disabled */

	TCA0.SINGLE.PER = 0x7; /* Period: 0x7 */
     2d6:	87 e0       	ldi	r24, 0x07	; 7
     2d8:	90 e0       	ldi	r25, 0x00	; 0
     2da:	86 a3       	std	Z+38, r24	; 0x26
     2dc:	97 a3       	std	Z+39, r25	; 0x27

	// TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV1_gc /* System Clock */
	//		 | 0 << TCA_SINGLE_ENABLE_bp; /* Module Enable: disabled */

	return 0;
}
     2de:	80 e0       	ldi	r24, 0x00	; 0
     2e0:	08 95       	ret

000002e2 <USART_0_init>:
uint8_t USART_0_read()
{
	while (!(USART0.STATUS & USART_RXCIF_bm))
		;
	return USART0.RXDATAL;
}
     2e2:	e0 e0       	ldi	r30, 0x00	; 0
     2e4:	f8 e0       	ldi	r31, 0x08	; 8
     2e6:	87 e4       	ldi	r24, 0x47	; 71
     2e8:	90 e1       	ldi	r25, 0x10	; 16
     2ea:	80 87       	std	Z+8, r24	; 0x08
     2ec:	91 87       	std	Z+9, r25	; 0x09
     2ee:	80 ec       	ldi	r24, 0xC0	; 192
     2f0:	86 83       	std	Z+6, r24	; 0x06
     2f2:	80 e0       	ldi	r24, 0x00	; 0
     2f4:	9e e3       	ldi	r25, 0x3E	; 62
     2f6:	80 93 6b 3e 	sts	0x3E6B, r24	; 0x803e6b <__iob+0x2>
     2fa:	90 93 6c 3e 	sts	0x3E6C, r25	; 0x803e6c <__iob+0x3>
     2fe:	80 e0       	ldi	r24, 0x00	; 0
     300:	08 95       	ret

00000302 <USART_0_write>:
 *
 * \return Nothing
 */
void USART_0_write(const uint8_t data)
{
	while (!(USART0.STATUS & USART_DREIF_bm))
     302:	e0 e0       	ldi	r30, 0x00	; 0
     304:	f8 e0       	ldi	r31, 0x08	; 8
     306:	94 81       	ldd	r25, Z+4	; 0x04
     308:	95 ff       	sbrs	r25, 5
     30a:	fd cf       	rjmp	.-6      	; 0x306 <USART_0_write+0x4>
		;
	USART0.TXDATAL = data;
     30c:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <__TEXT_REGION_LENGTH__+0x700802>
     310:	08 95       	ret

00000312 <USART_0_printCHAR>:

#if defined(__GNUC__)

int USART_0_printCHAR(char character, FILE *stream)
{
	USART_0_write(character);
     312:	f7 df       	rcall	.-18     	; 0x302 <USART_0_write>
	return 0;
}
     314:	80 e0       	ldi	r24, 0x00	; 0
     316:	90 e0       	ldi	r25, 0x00	; 0
     318:	08 95       	ret

0000031a <tinyCharge_is_connected_to_charger>:

_Bool connected_to_charger;

_Bool tinyCharge_is_connected_to_charger(){
	return connected_to_charger;
}
     31a:	80 91 5c 3e 	lds	r24, 0x3E5C	; 0x803e5c <connected_to_charger>
     31e:	08 95       	ret

00000320 <tinyCharge_is_fully_charged>:
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTB_get_pin_level(const uint8_t pin)
{
	return VPORTB.IN & (1 << pin);
     320:	86 b1       	in	r24, 0x06	; 6

_Bool tinyCharge_is_fully_charged(){
	return CHARGING_STATUS_PIN_get_level();
}
     322:	88 1f       	adc	r24, r24
     324:	88 27       	eor	r24, r24
     326:	88 1f       	adc	r24, r24
     328:	08 95       	ret

0000032a <tinyCharge_set_charging_mode>:

void tinyCharge_set_charging_mode(_Bool charging_status){
	connected_to_charger = charging_status;
     32a:	80 93 5c 3e 	sts	0x3E5C, r24	; 0x803e5c <connected_to_charger>
     32e:	08 95       	ret

00000330 <tinyCharge_set_transistors>:
}


void tinyCharge_set_transistors(){
	if(connected_to_charger){
     330:	80 91 5c 3e 	lds	r24, 0x3E5C	; 0x803e5c <connected_to_charger>
     334:	88 23       	and	r24, r24
     336:	11 f0       	breq	.+4      	; 0x33c <tinyCharge_set_transistors+0xc>
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
	} else {
		VPORTC.OUT &= ~(1 << pin);
     338:	4d 98       	cbi	0x09, 5	; 9
     33a:	08 95       	ret
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     33c:	4d 9a       	sbi	0x09, 5	; 9
     33e:	08 95       	ret

00000340 <tinyDebugger_send_int>:
		char number[20]; // Arbitrary max
		dtostrf(value,1,NUMBER_OF_DECIMALS, number);
		printf("%s:%s;", name, number);
	}
}
void tinyDebugger_send_string(const char* name, char * value){
     340:	08 95       	ret

00000342 <tinyDebugger_send_uint8>:
     342:	08 95       	ret

00000344 <tinyDebugger_send_double>:
     344:	08 95       	ret

00000346 <tinyDebugger_end_line>:
	if(DEBUGGING){
		printf("%s:%s;", name, value);
	}
}
void tinyDebugger_end_line(){
     346:	08 95       	ret

00000348 <tinyPulse_toggle_pulse_mode>:
uint32_t time_of_last_pulse = 0;
uint16_t time_since_last_pulse = 0;
uint16_t ideal_time_between_pulses = 1000/PULSEMODE_FREQUENCY;

void tinyPulse_toggle_pulse_mode(){
	pulse_mode = !pulse_mode;
     348:	90 91 1c 3e 	lds	r25, 0x3E1C	; 0x803e1c <pulse_mode>
     34c:	81 e0       	ldi	r24, 0x01	; 1
     34e:	89 27       	eor	r24, r25
     350:	80 93 1c 3e 	sts	0x3E1C, r24	; 0x803e1c <pulse_mode>
     354:	08 95       	ret

00000356 <tinyPulse_update_potential>:
}

double tinyPulse_update_potential(double potential){
     356:	cf 92       	push	r12
     358:	df 92       	push	r13
     35a:	ef 92       	push	r14
     35c:	ff 92       	push	r15
     35e:	6b 01       	movw	r12, r22
     360:	7c 01       	movw	r14, r24
	if(pulse_mode){
     362:	80 91 1c 3e 	lds	r24, 0x3E1C	; 0x803e1c <pulse_mode>
     366:	88 23       	and	r24, r24
     368:	21 f1       	breq	.+72     	; 0x3b2 <tinyPulse_update_potential+0x5c>
		
		time_since_last_pulse = tinyTime_now() - time_of_last_pulse;
     36a:	3e d0       	rcall	.+124    	; 0x3e8 <tinyTime_now>
     36c:	20 91 18 3e 	lds	r18, 0x3E18	; 0x803e18 <time_of_last_pulse>
     370:	30 91 19 3e 	lds	r19, 0x3E19	; 0x803e19 <time_of_last_pulse+0x1>
     374:	62 1b       	sub	r22, r18
     376:	73 0b       	sbc	r23, r19
     378:	60 93 16 3e 	sts	0x3E16, r22	; 0x803e16 <__data_end>
     37c:	70 93 17 3e 	sts	0x3E17, r23	; 0x803e17 <__data_end+0x1>
		
		if(time_since_last_pulse >= ideal_time_between_pulses){
     380:	80 91 0e 3e 	lds	r24, 0x3E0E	; 0x803e0e <ideal_time_between_pulses>
     384:	90 91 0f 3e 	lds	r25, 0x3E0F	; 0x803e0f <ideal_time_between_pulses+0x1>
     388:	68 17       	cp	r22, r24
     38a:	79 07       	cpc	r23, r25
     38c:	90 f0       	brcs	.+36     	; 0x3b2 <tinyPulse_update_potential+0x5c>
			potential += BUTTON_PRESS_REACTION;
     38e:	20 e0       	ldi	r18, 0x00	; 0
     390:	30 e0       	ldi	r19, 0x00	; 0
     392:	40 ed       	ldi	r20, 0xD0	; 208
     394:	51 e4       	ldi	r21, 0x41	; 65
     396:	c7 01       	movw	r24, r14
     398:	b6 01       	movw	r22, r12
     39a:	83 d5       	rcall	.+2822   	; 0xea2 <__addsf3>
     39c:	6b 01       	movw	r12, r22
     39e:	7c 01       	movw	r14, r24
			time_of_last_pulse = tinyTime_now();			
     3a0:	23 d0       	rcall	.+70     	; 0x3e8 <tinyTime_now>
     3a2:	60 93 18 3e 	sts	0x3E18, r22	; 0x803e18 <time_of_last_pulse>
     3a6:	70 93 19 3e 	sts	0x3E19, r23	; 0x803e19 <time_of_last_pulse+0x1>
     3aa:	80 93 1a 3e 	sts	0x3E1A, r24	; 0x803e1a <time_of_last_pulse+0x2>
     3ae:	90 93 1b 3e 	sts	0x3E1B, r25	; 0x803e1b <time_of_last_pulse+0x3>
		}
	}
	return potential;
}
     3b2:	c7 01       	movw	r24, r14
     3b4:	b6 01       	movw	r22, r12
     3b6:	ff 90       	pop	r15
     3b8:	ef 90       	pop	r14
     3ba:	df 90       	pop	r13
     3bc:	cf 90       	pop	r12
     3be:	08 95       	ret

000003c0 <tinyTime_counter_increment>:
If the Interrupt Service Routine is clocked by a crystal oscillator
it gives a very precise timer-counter.
*/
void tinyTime_counter_increment(void)
{
	time_counter++;
     3c0:	80 91 1d 3e 	lds	r24, 0x3E1D	; 0x803e1d <time_counter>
     3c4:	90 91 1e 3e 	lds	r25, 0x3E1E	; 0x803e1e <time_counter+0x1>
     3c8:	a0 91 1f 3e 	lds	r26, 0x3E1F	; 0x803e1f <time_counter+0x2>
     3cc:	b0 91 20 3e 	lds	r27, 0x3E20	; 0x803e20 <time_counter+0x3>
     3d0:	01 96       	adiw	r24, 0x01	; 1
     3d2:	a1 1d       	adc	r26, r1
     3d4:	b1 1d       	adc	r27, r1
     3d6:	80 93 1d 3e 	sts	0x3E1D, r24	; 0x803e1d <time_counter>
     3da:	90 93 1e 3e 	sts	0x3E1E, r25	; 0x803e1e <time_counter+0x1>
     3de:	a0 93 1f 3e 	sts	0x3E1F, r26	; 0x803e1f <time_counter+0x2>
     3e2:	b0 93 20 3e 	sts	0x3E20, r27	; 0x803e20 <time_counter+0x3>
     3e6:	08 95       	ret

000003e8 <tinyTime_now>:
/*
This function is callable by external libraries to give them the counted time so far.
*/
uint32_t tinyTime_now(void)
{
	return time_counter;
     3e8:	60 91 1d 3e 	lds	r22, 0x3E1D	; 0x803e1d <time_counter>
     3ec:	70 91 1e 3e 	lds	r23, 0x3E1E	; 0x803e1e <time_counter+0x1>
     3f0:	80 91 1f 3e 	lds	r24, 0x3E1F	; 0x803e1f <time_counter+0x2>
     3f4:	90 91 20 3e 	lds	r25, 0x3E20	; 0x803e20 <time_counter+0x3>
     3f8:	08 95       	ret

000003fa <main>:


int main(void)
{	
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
     3fa:	5b de       	rcall	.-842    	; 0xb2 <atmel_start_init>
	Setting this value will mean that the ADC (Analog to Digital Converter) will read 4.32v as 255, and 0v as 0.
	For some reason, instead of the reference voltage being 4.32v, it is 3.3v. 
	A plausible explanation is that the microchip does not up the voltage, so that if the microchip is only ever 
	supplied with 3.3v, it will output 3.3v as the max.
	*/
	VREF.CTRLA = VREF_ADC0REFSEL_4V34_gc;
     3fc:	80 e3       	ldi	r24, 0x30	; 48
     3fe:	80 93 a0 00 	sts	0x00A0, r24	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
	

	while (1)
	{
		// We don't want to update the neuron too often because of various reasons. The tinyISR_getflag is set every ms, and so the loop is only run once every ms.  
		if(tinyISR_getflag())
     402:	c8 d4       	rcall	.+2448   	; 0xd94 <tinyISR_getflag>
     404:	88 23       	and	r24, r24
     406:	e9 f3       	breq	.-6      	; 0x402 <__LOCK_REGION_LENGTH__+0x2>
		{			
			
			if(tinyCharge_is_connected_to_charger()){
     408:	88 df       	rcall	.-240    	; 0x31a <tinyCharge_is_connected_to_charger>
     40a:	88 23       	and	r24, r24
     40c:	81 f0       	breq	.+32     	; 0x42e <__LOCK_REGION_LENGTH__+0x2e>
				// Charge loop
				
				if(tinyCharge_is_fully_charged()){
     40e:	88 df       	rcall	.-240    	; 0x320 <tinyCharge_is_fully_charged>
     410:	88 23       	and	r24, r24
     412:	21 f0       	breq	.+8      	; 0x41c <__LOCK_REGION_LENGTH__+0x1c>
					tinyLED_set_color(INN_LED, CHARGING_DONE_COLOR);
     414:	63 e0       	ldi	r22, 0x03	; 3
     416:	81 e0       	ldi	r24, 0x01	; 1
     418:	89 d0       	rcall	.+274    	; 0x52c <tinyLED_set_color>
     41a:	03 c0       	rjmp	.+6      	; 0x422 <__LOCK_REGION_LENGTH__+0x22>
				}
				else{
					
					tinyLED_set_color(INN_LED, OFF);
     41c:	60 e0       	ldi	r22, 0x00	; 0
     41e:	81 e0       	ldi	r24, 0x01	; 1
     420:	85 d0       	rcall	.+266    	; 0x52c <tinyLED_set_color>
				}
				
				// We check the Dendrites in order to detect if we have stopped charging
				tinyDendrite_update_signals();
     422:	97 d3       	rcall	.+1838   	; 0xb52 <tinyDendrite_update_signals>
				
				// Set LED
				tinyLED_set_color_mode(OUT_LED, CHARGING_COLOR, SWING);
     424:	42 e0       	ldi	r20, 0x02	; 2
     426:	61 e0       	ldi	r22, 0x01	; 1
     428:	80 e0       	ldi	r24, 0x00	; 0
     42a:	91 d0       	rcall	.+290    	; 0x54e <tinyLED_set_color_mode>
     42c:	09 c0       	rjmp	.+18     	; 0x440 <__LOCK_REGION_LENGTH__+0x40>
				
			}
			else{
				// Main loop				
				tinyButton_update();
     42e:	12 d0       	rcall	.+36     	; 0x454 <tinyButton_update>
				
				tinyPotential_update();
     430:	b4 d4       	rcall	.+2408   	; 0xd9a <tinyPotential_update>
				
				//Set LED
				if(tinyLED_get_color(OUT_LED) == OFF){
     432:	80 e0       	ldi	r24, 0x00	; 0
     434:	84 d0       	rcall	.+264    	; 0x53e <tinyLED_get_color>
     436:	81 11       	cpse	r24, r1
     438:	03 c0       	rjmp	.+6      	; 0x440 <__LOCK_REGION_LENGTH__+0x40>
					tinyLED_set_color_mode(OUT_LED, PING_COLOR, PING);
     43a:	43 e0       	ldi	r20, 0x03	; 3
     43c:	62 e0       	ldi	r22, 0x02	; 2
     43e:	87 d0       	rcall	.+270    	; 0x54e <tinyLED_set_color_mode>
				}
			}
			// Update LED
			tinyLED_update();
     440:	c6 d0       	rcall	.+396    	; 0x5ce <tinyLED_update>
				
			// Switch transistors
			tinyCharge_set_transistors();
     442:	76 df       	rcall	.-276    	; 0x330 <tinyCharge_set_transistors>
			
			// Prepare for next cycle
			tinyISR_setflag(false);
     444:	80 e0       	ldi	r24, 0x00	; 0
     446:	a3 d4       	rcall	.+2374   	; 0xd8e <tinyISR_setflag>
			tinyDebugger_send_int("time", tinyTime_now());
     448:	cf df       	rcall	.-98     	; 0x3e8 <tinyTime_now>
     44a:	84 e1       	ldi	r24, 0x14	; 20
     44c:	96 e9       	ldi	r25, 0x96	; 150
     44e:	78 df       	rcall	.-272    	; 0x340 <tinyDebugger_send_int>
			tinyDebugger_end_line();
     450:	7a df       	rcall	.-268    	; 0x346 <tinyDebugger_end_line>
     452:	d7 cf       	rjmp	.-82     	; 0x402 <__LOCK_REGION_LENGTH__+0x2>

00000454 <tinyButton_update>:
/*
If the button has been let go, we change button_press to true. This only lasts one cycle, before it is set to false again.
If the button is held down for longer than PULSEMODE_BUTTON_PRESS_TIME, we toggle the pulse mode state.
*/
void tinyButton_update(void)
{
     454:	0f 93       	push	r16
     456:	1f 93       	push	r17
     458:	cf 93       	push	r28
     45a:	df 93       	push	r29
	button_press = false;
     45c:	10 92 25 3e 	sts	0x3E25, r1	; 0x803e25 <button_press>
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTC_get_pin_level(const uint8_t pin)
{
	return VPORTC.IN & (1 << pin);
     460:	8a b1       	in	r24, 0x0a	; 10
	_Bool button_is_pushed_down = !BUTTON_PIN_get_level(); // The digital port will be read as low if the button is pushed down.
     462:	d1 e0       	ldi	r29, 0x01	; 1
     464:	c8 2f       	mov	r28, r24
     466:	c4 70       	andi	r28, 0x04	; 4
     468:	82 fd       	sbrc	r24, 2
     46a:	d0 e0       	ldi	r29, 0x00	; 0

	if (button_is_pushed_down && !button_was_pushed_down)
     46c:	c1 11       	cpse	r28, r1
     46e:	30 c0       	rjmp	.+96     	; 0x4d0 <tinyButton_update+0x7c>
     470:	80 91 26 3e 	lds	r24, 0x3E26	; 0x803e26 <button_was_pushed_down>
     474:	81 11       	cpse	r24, r1
     476:	0d c0       	rjmp	.+26     	; 0x492 <tinyButton_update+0x3e>
	{
		tinyButton_start_time = tinyTime_now();
     478:	b7 df       	rcall	.-146    	; 0x3e8 <tinyTime_now>
     47a:	60 93 21 3e 	sts	0x3E21, r22	; 0x803e21 <tinyButton_start_time>
     47e:	70 93 22 3e 	sts	0x3E22, r23	; 0x803e22 <tinyButton_start_time+0x1>
     482:	80 93 23 3e 	sts	0x3E23, r24	; 0x803e23 <tinyButton_start_time+0x2>
     486:	90 93 24 3e 	sts	0x3E24, r25	; 0x803e24 <tinyButton_start_time+0x3>
	}
	if (button_is_pushed_down && button_was_pushed_down)
     48a:	80 91 26 3e 	lds	r24, 0x3E26	; 0x803e26 <button_was_pushed_down>
     48e:	88 23       	and	r24, r24
     490:	41 f1       	breq	.+80     	; 0x4e2 <tinyButton_update+0x8e>
	{
		if ((tinyTime_now() - tinyButton_start_time) > PULSEMODE_BUTTON_PRESS_TIME)
     492:	aa df       	rcall	.-172    	; 0x3e8 <tinyTime_now>
     494:	00 91 21 3e 	lds	r16, 0x3E21	; 0x803e21 <tinyButton_start_time>
     498:	10 91 22 3e 	lds	r17, 0x3E22	; 0x803e22 <tinyButton_start_time+0x1>
     49c:	20 91 23 3e 	lds	r18, 0x3E23	; 0x803e23 <tinyButton_start_time+0x2>
     4a0:	30 91 24 3e 	lds	r19, 0x3E24	; 0x803e24 <tinyButton_start_time+0x3>
     4a4:	60 1b       	sub	r22, r16
     4a6:	71 0b       	sbc	r23, r17
     4a8:	82 0b       	sbc	r24, r18
     4aa:	93 0b       	sbc	r25, r19
     4ac:	46 d6       	rcall	.+3212   	; 0x113a <__floatunsisf>
     4ae:	20 e0       	ldi	r18, 0x00	; 0
     4b0:	30 e0       	ldi	r19, 0x00	; 0
     4b2:	48 ec       	ldi	r20, 0xC8	; 200
     4b4:	52 e4       	ldi	r21, 0x42	; 66
     4b6:	39 d7       	rcall	.+3698   	; 0x132a <__gesf2>
     4b8:	18 16       	cp	r1, r24
     4ba:	54 f4       	brge	.+20     	; 0x4d0 <tinyButton_update+0x7c>
		{
			tinyPulse_toggle_pulse_mode();
     4bc:	45 df       	rcall	.-374    	; 0x348 <tinyPulse_toggle_pulse_mode>
			tinyButton_start_time = tinyTime_now();
     4be:	94 df       	rcall	.-216    	; 0x3e8 <tinyTime_now>
     4c0:	60 93 21 3e 	sts	0x3E21, r22	; 0x803e21 <tinyButton_start_time>
     4c4:	70 93 22 3e 	sts	0x3E22, r23	; 0x803e22 <tinyButton_start_time+0x1>
     4c8:	80 93 23 3e 	sts	0x3E23, r24	; 0x803e23 <tinyButton_start_time+0x2>
     4cc:	90 93 24 3e 	sts	0x3E24, r25	; 0x803e24 <tinyButton_start_time+0x3>
		}
	}
	if (!button_is_pushed_down && button_was_pushed_down)
     4d0:	cc 23       	and	r28, r28
     4d2:	39 f0       	breq	.+14     	; 0x4e2 <tinyButton_update+0x8e>
     4d4:	80 91 26 3e 	lds	r24, 0x3E26	; 0x803e26 <button_was_pushed_down>
     4d8:	88 23       	and	r24, r24
     4da:	19 f0       	breq	.+6      	; 0x4e2 <tinyButton_update+0x8e>
	{
		button_press = true;
     4dc:	81 e0       	ldi	r24, 0x01	; 1
     4de:	80 93 25 3e 	sts	0x3E25, r24	; 0x803e25 <button_press>
	}
	button_was_pushed_down = button_is_pushed_down;
     4e2:	d0 93 26 3e 	sts	0x3E26, r29	; 0x803e26 <button_was_pushed_down>
}
     4e6:	df 91       	pop	r29
     4e8:	cf 91       	pop	r28
     4ea:	1f 91       	pop	r17
     4ec:	0f 91       	pop	r16
     4ee:	08 95       	ret

000004f0 <tinyButton_update_potential>:

double tinyButton_update_potential(double potential){
	if(button_press){
     4f0:	20 91 25 3e 	lds	r18, 0x3E25	; 0x803e25 <button_press>
     4f4:	22 23       	and	r18, r18
     4f6:	29 f0       	breq	.+10     	; 0x502 <tinyButton_update_potential+0x12>
		potential += BUTTON_PRESS_REACTION;
     4f8:	20 e0       	ldi	r18, 0x00	; 0
     4fa:	30 e0       	ldi	r19, 0x00	; 0
     4fc:	40 ed       	ldi	r20, 0xD0	; 208
     4fe:	51 e4       	ldi	r21, 0x41	; 65
     500:	d0 d4       	rcall	.+2464   	; 0xea2 <__addsf3>
	}
	return potential;
}
     502:	08 95       	ret

00000504 <tinyLED_SPIWriteByte>:
Function used to send a byte over SPI, which in turn gets
translated to the bit-sequence required by the LEDs over the CCL.
*/
static void tinyLED_SPIWriteByte(uint8_t byte)
{
	SPI0.INTFLAGS = SPI0_INTFLAGS; // clear the write collision flag to allow writing
     504:	90 91 23 08 	lds	r25, 0x0823	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
     508:	90 93 23 08 	sts	0x0823, r25	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
	TCA0.SINGLE.CNT = 0; // reset TCA counter register to ensure the first rising edge of the PWM is predictable
     50c:	e0 e0       	ldi	r30, 0x00	; 0
     50e:	fa e0       	ldi	r31, 0x0A	; 10
     510:	10 a2       	std	Z+32, r1	; 0x20
     512:	11 a2       	std	Z+33, r1	; 0x21
	
	// start TCA
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 1 << TCA_SPLIT_ENABLE_bp;
     514:	91 e0       	ldi	r25, 0x01	; 1
     516:	90 83       	st	Z, r25
	SPI0_DATA = byte;
     518:	80 93 24 08 	sts	0x0824, r24	; 0x800824 <__TEXT_REGION_LENGTH__+0x700824>

	while((SPI0.INTFLAGS & SPI_RXCIE_bm) == 0){} // wait for transfer to complete
     51c:	e0 e2       	ldi	r30, 0x20	; 32
     51e:	f8 e0       	ldi	r31, 0x08	; 8
     520:	83 81       	ldd	r24, Z+3	; 0x03
     522:	88 23       	and	r24, r24
     524:	ec f7       	brge	.-6      	; 0x520 <tinyLED_SPIWriteByte+0x1c>
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 0 << TCA_SPLIT_ENABLE_bp; //Stop TCA
     526:	10 92 00 0a 	sts	0x0A00, r1	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
     52a:	08 95       	ret

0000052c <tinyLED_set_color>:
changes the values in the variables stored in the LED-array.
*/
void tinyLED_set_color_mode(uint8_t LED_id, enum Colors color, enum ColorModes mode)
{
	struct ColorSetting setting = {.color=color, .mode=mode};
	tinyLED_colors[LED_id] = setting;
     52c:	e8 2f       	mov	r30, r24
     52e:	f0 e0       	ldi	r31, 0x00	; 0
     530:	ee 0f       	add	r30, r30
     532:	ff 1f       	adc	r31, r31
     534:	eb 59       	subi	r30, 0x9B	; 155
     536:	f1 4c       	sbci	r31, 0xC1	; 193
     538:	60 83       	st	Z, r22
     53a:	11 82       	std	Z+1, r1	; 0x01
     53c:	08 95       	ret

0000053e <tinyLED_get_color>:
	tinyLED_set_color_mode(LED_id, color, STABLE);
}

enum Colors tinyLED_get_color(uint8_t LED_id)
{
	return tinyLED_colors[LED_id].color;
     53e:	e8 2f       	mov	r30, r24
     540:	f0 e0       	ldi	r31, 0x00	; 0
     542:	ee 0f       	add	r30, r30
     544:	ff 1f       	adc	r31, r31
     546:	eb 59       	subi	r30, 0x9B	; 155
     548:	f1 4c       	sbci	r31, 0xC1	; 193
}
     54a:	80 81       	ld	r24, Z
     54c:	08 95       	ret

0000054e <tinyLED_set_color_mode>:
changes the values in the variables stored in the LED-array.
*/
void tinyLED_set_color_mode(uint8_t LED_id, enum Colors color, enum ColorModes mode)
{
	struct ColorSetting setting = {.color=color, .mode=mode};
	tinyLED_colors[LED_id] = setting;
     54e:	90 e0       	ldi	r25, 0x00	; 0
     550:	fc 01       	movw	r30, r24
     552:	ee 0f       	add	r30, r30
     554:	ff 1f       	adc	r31, r31
     556:	eb 59       	subi	r30, 0x9B	; 155
     558:	f1 4c       	sbci	r31, 0xC1	; 193
     55a:	60 83       	st	Z, r22
     55c:	41 83       	std	Z+1, r20	; 0x01
	if (mode == FLASH_ONCE)
     55e:	44 30       	cpi	r20, 0x04	; 4
     560:	29 f4       	brne	.+10     	; 0x56c <tinyLED_set_color_mode+0x1e>
	{
		tinyLED_flash_once_time[LED_id] = 1000*FLASH_TIME;
     562:	fc 01       	movw	r30, r24
     564:	e3 5a       	subi	r30, 0xA3	; 163
     566:	f1 4c       	sbci	r31, 0xC1	; 193
     568:	2a e0       	ldi	r18, 0x0A	; 10
     56a:	20 83       	st	Z, r18
     56c:	08 95       	ret

0000056e <tinyLED_RGB_Color_Compare>:
	}
	return rgb_color;
			
};

_Bool tinyLED_RGB_Color_Compare(struct RGB_Color* a, struct RGB_Color* b){
     56e:	dc 01       	movw	r26, r24
     570:	fb 01       	movw	r30, r22
	for (int i=0; i<NUMBER_OF_LEDS; i++)
	{
		if(!(a[i].red==b[i].red && a[i].green==b[i].green && a[i].blue==b[i].blue)){
     572:	9c 91       	ld	r25, X
     574:	80 81       	ld	r24, Z
     576:	98 13       	cpse	r25, r24
     578:	20 c0       	rjmp	.+64     	; 0x5ba <tinyLED_RGB_Color_Compare+0x4c>
     57a:	11 96       	adiw	r26, 0x01	; 1
     57c:	9c 91       	ld	r25, X
     57e:	11 97       	sbiw	r26, 0x01	; 1
     580:	81 81       	ldd	r24, Z+1	; 0x01
     582:	98 13       	cpse	r25, r24
     584:	1c c0       	rjmp	.+56     	; 0x5be <tinyLED_RGB_Color_Compare+0x50>
     586:	12 96       	adiw	r26, 0x02	; 2
     588:	9c 91       	ld	r25, X
     58a:	12 97       	sbiw	r26, 0x02	; 2
     58c:	82 81       	ldd	r24, Z+2	; 0x02
     58e:	98 13       	cpse	r25, r24
     590:	18 c0       	rjmp	.+48     	; 0x5c2 <tinyLED_RGB_Color_Compare+0x54>
     592:	13 96       	adiw	r26, 0x03	; 3
     594:	9c 91       	ld	r25, X
     596:	13 97       	sbiw	r26, 0x03	; 3
     598:	83 81       	ldd	r24, Z+3	; 0x03
     59a:	98 13       	cpse	r25, r24
     59c:	14 c0       	rjmp	.+40     	; 0x5c6 <tinyLED_RGB_Color_Compare+0x58>
     59e:	14 96       	adiw	r26, 0x04	; 4
     5a0:	9c 91       	ld	r25, X
     5a2:	14 97       	sbiw	r26, 0x04	; 4
     5a4:	84 81       	ldd	r24, Z+4	; 0x04
     5a6:	98 13       	cpse	r25, r24
     5a8:	10 c0       	rjmp	.+32     	; 0x5ca <tinyLED_RGB_Color_Compare+0x5c>
     5aa:	81 e0       	ldi	r24, 0x01	; 1
     5ac:	15 96       	adiw	r26, 0x05	; 5
     5ae:	2c 91       	ld	r18, X
     5b0:	95 81       	ldd	r25, Z+5	; 0x05
     5b2:	29 17       	cp	r18, r25
     5b4:	59 f0       	breq	.+22     	; 0x5cc <tinyLED_RGB_Color_Compare+0x5e>
     5b6:	80 e0       	ldi	r24, 0x00	; 0
     5b8:	08 95       	ret
			return false;
     5ba:	80 e0       	ldi	r24, 0x00	; 0
     5bc:	08 95       	ret
     5be:	80 e0       	ldi	r24, 0x00	; 0
     5c0:	08 95       	ret
     5c2:	80 e0       	ldi	r24, 0x00	; 0
     5c4:	08 95       	ret
     5c6:	80 e0       	ldi	r24, 0x00	; 0
     5c8:	08 95       	ret
     5ca:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	return true;
}
     5cc:	08 95       	ret

000005ce <tinyLED_update>:
/*
function to write the current LED-array on to the LEDs and
effectively update the values stored in the LEDs to the values stored in the MCU.
*/
void tinyLED_update(void)
{
     5ce:	2f 92       	push	r2
     5d0:	3f 92       	push	r3
     5d2:	4f 92       	push	r4
     5d4:	5f 92       	push	r5
     5d6:	6f 92       	push	r6
     5d8:	7f 92       	push	r7
     5da:	8f 92       	push	r8
     5dc:	9f 92       	push	r9
     5de:	af 92       	push	r10
     5e0:	bf 92       	push	r11
     5e2:	cf 92       	push	r12
     5e4:	df 92       	push	r13
     5e6:	ef 92       	push	r14
     5e8:	ff 92       	push	r15
     5ea:	0f 93       	push	r16
     5ec:	1f 93       	push	r17
     5ee:	cf 93       	push	r28
     5f0:	df 93       	push	r29
     5f2:	cd b7       	in	r28, 0x3d	; 61
     5f4:	de b7       	in	r29, 0x3e	; 62
     5f6:	6f 97       	sbiw	r28, 0x1f	; 31
     5f8:	cd bf       	out	0x3d, r28	; 61
     5fa:	de bf       	out	0x3e, r29	; 62
			
	uint32_t now = tinyTime_now();
     5fc:	f5 de       	rcall	.-534    	; 0x3e8 <tinyTime_now>
     5fe:	6b 01       	movw	r12, r22
     600:	7c 01       	movw	r14, r24
	double sinValue = 1+sin((double)now/(100*M_PI/SWING_RATE));
     602:	9b d5       	rcall	.+2870   	; 0x113a <__floatunsisf>
     604:	22 ed       	ldi	r18, 0xD2	; 210
     606:	33 e5       	ldi	r19, 0x53	; 83
     608:	4b ef       	ldi	r20, 0xFB	; 251
     60a:	51 e4       	ldi	r21, 0x41	; 65
     60c:	bb d4       	rcall	.+2422   	; 0xf84 <__divsf3>
     60e:	75 d7       	rcall	.+3818   	; 0x14fa <sin>
     610:	20 e0       	ldi	r18, 0x00	; 0
     612:	30 e0       	ldi	r19, 0x00	; 0
     614:	40 e8       	ldi	r20, 0x80	; 128
     616:	5f e3       	ldi	r21, 0x3F	; 63
     618:	44 d4       	rcall	.+2184   	; 0xea2 <__addsf3>
     61a:	69 87       	std	Y+9, r22	; 0x09
     61c:	7a 87       	std	Y+10, r23	; 0x0a
     61e:	8b 87       	std	Y+11, r24	; 0x0b
     620:	9c 87       	std	Y+12, r25	; 0x0c
	_Bool flash_on = now%(uint32_t)(1000/FLASH_RATE)   <   500/FLASH_RATE;
     622:	c7 01       	movw	r24, r14
     624:	b6 01       	movw	r22, r12
     626:	22 e3       	ldi	r18, 0x32	; 50
     628:	30 e0       	ldi	r19, 0x00	; 0
     62a:	40 e0       	ldi	r20, 0x00	; 0
     62c:	50 e0       	ldi	r21, 0x00	; 0
     62e:	ce d7       	rcall	.+3996   	; 0x15cc <__udivmodsi4>
     630:	84 d5       	rcall	.+2824   	; 0x113a <__floatunsisf>
     632:	20 e0       	ldi	r18, 0x00	; 0
     634:	30 e0       	ldi	r19, 0x00	; 0
     636:	48 ec       	ldi	r20, 0xC8	; 200
     638:	51 e4       	ldi	r21, 0x41	; 65
     63a:	9f d4       	rcall	.+2366   	; 0xf7a <__cmpsf2>
     63c:	88 1f       	adc	r24, r24
     63e:	88 27       	eor	r24, r24
     640:	88 1f       	adc	r24, r24
     642:	8d 87       	std	Y+13, r24	; 0x0d
	_Bool ping_on = now%(uint32_t)(1000/PING_RATE)   <   1000*FLASH_TIME;
     644:	c7 01       	movw	r24, r14
     646:	b6 01       	movw	r22, r12
     648:	24 ef       	ldi	r18, 0xF4	; 244
     64a:	31 e0       	ldi	r19, 0x01	; 1
     64c:	40 e0       	ldi	r20, 0x00	; 0
     64e:	50 e0       	ldi	r21, 0x00	; 0
     650:	bd d7       	rcall	.+3962   	; 0x15cc <__udivmodsi4>
     652:	73 d5       	rcall	.+2790   	; 0x113a <__floatunsisf>
     654:	20 e0       	ldi	r18, 0x00	; 0
     656:	30 e0       	ldi	r19, 0x00	; 0
     658:	40 e2       	ldi	r20, 0x20	; 32
     65a:	51 e4       	ldi	r21, 0x41	; 65
     65c:	8e d4       	rcall	.+2332   	; 0xf7a <__cmpsf2>
     65e:	88 1f       	adc	r24, r24
     660:	88 27       	eor	r24, r24
     662:	88 1f       	adc	r24, r24
     664:	0f 2e       	mov	r0, r31
     666:	f5 e6       	ldi	r31, 0x65	; 101
     668:	2f 2e       	mov	r2, r31
     66a:	fe e3       	ldi	r31, 0x3E	; 62
     66c:	3f 2e       	mov	r3, r31
     66e:	f0 2d       	mov	r31, r0
     670:	9e 01       	movw	r18, r28
     672:	2f 5f       	subi	r18, 0xFF	; 255
     674:	3f 4f       	sbci	r19, 0xFF	; 255
     676:	0d e5       	ldi	r16, 0x5D	; 93
     678:	1e e3       	ldi	r17, 0x3E	; 62
     67a:	0f 2e       	mov	r0, r31
     67c:	f9 e6       	ldi	r31, 0x69	; 105
     67e:	cf 2e       	mov	r12, r31
     680:	fe e3       	ldi	r31, 0x3E	; 62
     682:	df 2e       	mov	r13, r31
     684:	f0 2d       	mov	r31, r0
     686:	49 01       	movw	r8, r18
			case SWING:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*sinValue, rgb_colors[i].green*sinValue, rgb_colors[i].blue*sinValue};
				break;
			case PING:
				// PING brightness should always be very low
				rgb_colors[i] = (struct RGB_Color){5*fmin(1,rgb_colors[i].red)*ping_on, 5*fmin(1,rgb_colors[i].green)*ping_on, 5*fmin(1,rgb_colors[i].blue)*ping_on};
     688:	48 2e       	mov	r4, r24
     68a:	51 2c       	mov	r5, r1
     68c:	61 2c       	mov	r6, r1
     68e:	71 2c       	mov	r7, r1
     690:	2e 87       	std	Y+14, r18	; 0x0e
     692:	3f 87       	std	Y+15, r19	; 0x0f
     694:	f1 01       	movw	r30, r2
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 0 << TCA_SPLIT_ENABLE_bp; //Stop TCA
}

static struct RGB_Color tinyLED_enum_to_RGB_Color(enum Colors color){
	struct RGB_Color rgb_color;
	switch(color)
     696:	80 81       	ld	r24, Z
     698:	82 30       	cpi	r24, 0x02	; 2
     69a:	a1 f0       	breq	.+40     	; 0x6c4 <tinyLED_update+0xf6>
     69c:	18 f4       	brcc	.+6      	; 0x6a4 <tinyLED_update+0xd6>
     69e:	81 30       	cpi	r24, 0x01	; 1
     6a0:	31 f0       	breq	.+12     	; 0x6ae <tinyLED_update+0xe0>
     6a2:	21 c0       	rjmp	.+66     	; 0x6e6 <tinyLED_update+0x118>
     6a4:	83 30       	cpi	r24, 0x03	; 3
     6a6:	39 f0       	breq	.+14     	; 0x6b6 <tinyLED_update+0xe8>
     6a8:	84 30       	cpi	r24, 0x04	; 4
     6aa:	99 f0       	breq	.+38     	; 0x6d2 <tinyLED_update+0x104>
     6ac:	1c c0       	rjmp	.+56     	; 0x6e6 <tinyLED_update+0x118>
	{
		case OFF:
			rgb_color = (struct RGB_Color){0, 0, 0};
			break;
		case RED:
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 0, 0};
     6ae:	f1 2c       	mov	r15, r1
     6b0:	e1 2c       	mov	r14, r1
     6b2:	69 e1       	ldi	r22, 0x19	; 25
     6b4:	1b c0       	rjmp	.+54     	; 0x6ec <tinyLED_update+0x11e>
			break;
		case GREEN:
			rgb_color = (struct RGB_Color){0, 255*LED_BRIGHTNESS, 0};
     6b6:	f1 2c       	mov	r15, r1
     6b8:	0f 2e       	mov	r0, r31
     6ba:	f9 e1       	ldi	r31, 0x19	; 25
     6bc:	ef 2e       	mov	r14, r31
     6be:	f0 2d       	mov	r31, r0
     6c0:	60 e0       	ldi	r22, 0x00	; 0
     6c2:	14 c0       	rjmp	.+40     	; 0x6ec <tinyLED_update+0x11e>
			break;
		case BLUE:
			rgb_color = (struct RGB_Color){0, 0, 255*LED_BRIGHTNESS};
     6c4:	0f 2e       	mov	r0, r31
     6c6:	f9 e1       	ldi	r31, 0x19	; 25
     6c8:	ff 2e       	mov	r15, r31
     6ca:	f0 2d       	mov	r31, r0
     6cc:	e1 2c       	mov	r14, r1
     6ce:	60 e0       	ldi	r22, 0x00	; 0
     6d0:	0d c0       	rjmp	.+26     	; 0x6ec <tinyLED_update+0x11e>
			// Should the /3 be there? This requires testing.
			// After testing, findings were that at 0.1 brightness, one would see the three LEDs instead of one white led
			// We try with /2 instead.
			// We find that the best results come from not dividing by anything. At leasts in the lower brightness settings, and that
			// is where we suspect it will be most of the time.
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS};
     6d2:	0f 2e       	mov	r0, r31
     6d4:	f9 e1       	ldi	r31, 0x19	; 25
     6d6:	ff 2e       	mov	r15, r31
     6d8:	f0 2d       	mov	r31, r0
     6da:	0f 2e       	mov	r0, r31
     6dc:	f9 e1       	ldi	r31, 0x19	; 25
     6de:	ef 2e       	mov	r14, r31
     6e0:	f0 2d       	mov	r31, r0
     6e2:	69 e1       	ldi	r22, 0x19	; 25
     6e4:	03 c0       	rjmp	.+6      	; 0x6ec <tinyLED_update+0x11e>
static struct RGB_Color tinyLED_enum_to_RGB_Color(enum Colors color){
	struct RGB_Color rgb_color;
	switch(color)
	{
		case OFF:
			rgb_color = (struct RGB_Color){0, 0, 0};
     6e6:	f1 2c       	mov	r15, r1
     6e8:	e1 2c       	mov	r14, r1
     6ea:	60 e0       	ldi	r22, 0x00	; 0
     6ec:	8f 82       	std	Y+7, r8	; 0x07
     6ee:	98 86       	std	Y+8, r9	; 0x08
	
		
	for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
	{		
		// Convert enum to RGB_Color
		rgb_colors[i] = tinyLED_enum_to_RGB_Color(tinyLED_colors[i].color);
     6f0:	d4 01       	movw	r26, r8
     6f2:	6c 93       	st	X, r22
     6f4:	11 96       	adiw	r26, 0x01	; 1
     6f6:	ec 92       	st	X, r14
     6f8:	11 97       	sbiw	r26, 0x01	; 1
     6fa:	12 96       	adiw	r26, 0x02	; 2
     6fc:	fc 92       	st	X, r15
			
		// Adjust colors according to mode
		switch(tinyLED_colors[i].mode)
     6fe:	81 81       	ldd	r24, Z+1	; 0x01
     700:	82 30       	cpi	r24, 0x02	; 2
     702:	d1 f0       	breq	.+52     	; 0x738 <tinyLED_update+0x16a>
     704:	18 f4       	brcc	.+6      	; 0x70c <tinyLED_update+0x13e>
     706:	81 30       	cpi	r24, 0x01	; 1
     708:	39 f0       	breq	.+14     	; 0x718 <tinyLED_update+0x14a>
     70a:	e0 c0       	rjmp	.+448    	; 0x8cc <tinyLED_update+0x2fe>
     70c:	83 30       	cpi	r24, 0x03	; 3
     70e:	e1 f1       	breq	.+120    	; 0x788 <tinyLED_update+0x1ba>
     710:	84 30       	cpi	r24, 0x04	; 4
     712:	09 f4       	brne	.+2      	; 0x716 <tinyLED_update+0x148>
     714:	a7 c0       	rjmp	.+334    	; 0x864 <tinyLED_update+0x296>
     716:	da c0       	rjmp	.+436    	; 0x8cc <tinyLED_update+0x2fe>
		{
			case STABLE:
				break;
			case FLASH:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*flash_on, rgb_colors[i].green*flash_on, rgb_colors[i].blue*flash_on};
     718:	bd 85       	ldd	r27, Y+13	; 0x0d
     71a:	b6 9f       	mul	r27, r22
     71c:	60 2d       	mov	r22, r0
     71e:	11 24       	eor	r1, r1
     720:	ef 81       	ldd	r30, Y+7	; 0x07
     722:	f8 85       	ldd	r31, Y+8	; 0x08
     724:	60 83       	st	Z, r22
     726:	be 9d       	mul	r27, r14
     728:	e0 2c       	mov	r14, r0
     72a:	11 24       	eor	r1, r1
     72c:	e1 82       	std	Z+1, r14	; 0x01
     72e:	bf 9d       	mul	r27, r15
     730:	f0 2c       	mov	r15, r0
     732:	11 24       	eor	r1, r1
     734:	f2 82       	std	Z+2, r15	; 0x02
				break;
     736:	ca c0       	rjmp	.+404    	; 0x8cc <tinyLED_update+0x2fe>
			case SWING:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*sinValue, rgb_colors[i].green*sinValue, rgb_colors[i].blue*sinValue};
     738:	70 e0       	ldi	r23, 0x00	; 0
     73a:	80 e0       	ldi	r24, 0x00	; 0
     73c:	90 e0       	ldi	r25, 0x00	; 0
     73e:	ff d4       	rcall	.+2558   	; 0x113e <__floatsisf>
     740:	29 85       	ldd	r18, Y+9	; 0x09
     742:	3a 85       	ldd	r19, Y+10	; 0x0a
     744:	4b 85       	ldd	r20, Y+11	; 0x0b
     746:	5c 85       	ldd	r21, Y+12	; 0x0c
     748:	6b d6       	rcall	.+3286   	; 0x1420 <__mulsf3>
     74a:	c8 d4       	rcall	.+2448   	; 0x10dc <__fixunssfsi>
     74c:	d4 01       	movw	r26, r8
     74e:	6c 93       	st	X, r22
     750:	6e 2d       	mov	r22, r14
     752:	70 e0       	ldi	r23, 0x00	; 0
     754:	80 e0       	ldi	r24, 0x00	; 0
     756:	90 e0       	ldi	r25, 0x00	; 0
     758:	f2 d4       	rcall	.+2532   	; 0x113e <__floatsisf>
     75a:	29 85       	ldd	r18, Y+9	; 0x09
     75c:	3a 85       	ldd	r19, Y+10	; 0x0a
     75e:	4b 85       	ldd	r20, Y+11	; 0x0b
     760:	5c 85       	ldd	r21, Y+12	; 0x0c
     762:	5e d6       	rcall	.+3260   	; 0x1420 <__mulsf3>
     764:	bb d4       	rcall	.+2422   	; 0x10dc <__fixunssfsi>
     766:	f4 01       	movw	r30, r8
     768:	61 83       	std	Z+1, r22	; 0x01
     76a:	6f 2d       	mov	r22, r15
     76c:	70 e0       	ldi	r23, 0x00	; 0
     76e:	80 e0       	ldi	r24, 0x00	; 0
     770:	90 e0       	ldi	r25, 0x00	; 0
     772:	e5 d4       	rcall	.+2506   	; 0x113e <__floatsisf>
     774:	29 85       	ldd	r18, Y+9	; 0x09
     776:	3a 85       	ldd	r19, Y+10	; 0x0a
     778:	4b 85       	ldd	r20, Y+11	; 0x0b
     77a:	5c 85       	ldd	r21, Y+12	; 0x0c
     77c:	51 d6       	rcall	.+3234   	; 0x1420 <__mulsf3>
     77e:	ae d4       	rcall	.+2396   	; 0x10dc <__fixunssfsi>
     780:	d4 01       	movw	r26, r8
     782:	12 96       	adiw	r26, 0x02	; 2
     784:	6c 93       	st	X, r22
				break;
     786:	a2 c0       	rjmp	.+324    	; 0x8cc <tinyLED_update+0x2fe>
			case PING:
				// PING brightness should always be very low
				rgb_colors[i] = (struct RGB_Color){5*fmin(1,rgb_colors[i].red)*ping_on, 5*fmin(1,rgb_colors[i].green)*ping_on, 5*fmin(1,rgb_colors[i].blue)*ping_on};
     788:	70 e0       	ldi	r23, 0x00	; 0
     78a:	80 e0       	ldi	r24, 0x00	; 0
     78c:	90 e0       	ldi	r25, 0x00	; 0
     78e:	d5 d4       	rcall	.+2474   	; 0x113a <__floatunsisf>
     790:	9b 01       	movw	r18, r22
     792:	ac 01       	movw	r20, r24
     794:	60 e0       	ldi	r22, 0x00	; 0
     796:	70 e0       	ldi	r23, 0x00	; 0
     798:	80 e8       	ldi	r24, 0x80	; 128
     79a:	9f e3       	ldi	r25, 0x3F	; 63
     79c:	0b d5       	rcall	.+2582   	; 0x11b4 <fmin>
     79e:	6c 8b       	std	Y+20, r22	; 0x14
     7a0:	7d 8b       	std	Y+21, r23	; 0x15
     7a2:	8e 8b       	std	Y+22, r24	; 0x16
     7a4:	9f 8b       	std	Y+23, r25	; 0x17
     7a6:	c3 01       	movw	r24, r6
     7a8:	b2 01       	movw	r22, r4
     7aa:	c9 d4       	rcall	.+2450   	; 0x113e <__floatsisf>
     7ac:	68 8b       	std	Y+16, r22	; 0x10
     7ae:	79 8b       	std	Y+17, r23	; 0x11
     7b0:	8a 8b       	std	Y+18, r24	; 0x12
     7b2:	9b 8b       	std	Y+19, r25	; 0x13
     7b4:	6e 2d       	mov	r22, r14
     7b6:	70 e0       	ldi	r23, 0x00	; 0
     7b8:	80 e0       	ldi	r24, 0x00	; 0
     7ba:	90 e0       	ldi	r25, 0x00	; 0
     7bc:	be d4       	rcall	.+2428   	; 0x113a <__floatunsisf>
     7be:	9b 01       	movw	r18, r22
     7c0:	ac 01       	movw	r20, r24
     7c2:	60 e0       	ldi	r22, 0x00	; 0
     7c4:	70 e0       	ldi	r23, 0x00	; 0
     7c6:	80 e8       	ldi	r24, 0x80	; 128
     7c8:	9f e3       	ldi	r25, 0x3F	; 63
     7ca:	f4 d4       	rcall	.+2536   	; 0x11b4 <fmin>
     7cc:	68 8f       	std	Y+24, r22	; 0x18
     7ce:	79 8f       	std	Y+25, r23	; 0x19
     7d0:	8a 8f       	std	Y+26, r24	; 0x1a
     7d2:	9b 8f       	std	Y+27, r25	; 0x1b
     7d4:	6f 2d       	mov	r22, r15
     7d6:	70 e0       	ldi	r23, 0x00	; 0
     7d8:	80 e0       	ldi	r24, 0x00	; 0
     7da:	90 e0       	ldi	r25, 0x00	; 0
     7dc:	ae d4       	rcall	.+2396   	; 0x113a <__floatunsisf>
     7de:	9b 01       	movw	r18, r22
     7e0:	ac 01       	movw	r20, r24
     7e2:	60 e0       	ldi	r22, 0x00	; 0
     7e4:	70 e0       	ldi	r23, 0x00	; 0
     7e6:	80 e8       	ldi	r24, 0x80	; 128
     7e8:	9f e3       	ldi	r25, 0x3F	; 63
     7ea:	e4 d4       	rcall	.+2504   	; 0x11b4 <fmin>
     7ec:	6c 8f       	std	Y+28, r22	; 0x1c
     7ee:	7d 8f       	std	Y+29, r23	; 0x1d
     7f0:	8e 8f       	std	Y+30, r24	; 0x1e
     7f2:	9f 8f       	std	Y+31, r25	; 0x1f
     7f4:	20 e0       	ldi	r18, 0x00	; 0
     7f6:	30 e0       	ldi	r19, 0x00	; 0
     7f8:	40 ea       	ldi	r20, 0xA0	; 160
     7fa:	50 e4       	ldi	r21, 0x40	; 64
     7fc:	6c 89       	ldd	r22, Y+20	; 0x14
     7fe:	7d 89       	ldd	r23, Y+21	; 0x15
     800:	8e 89       	ldd	r24, Y+22	; 0x16
     802:	9f 89       	ldd	r25, Y+23	; 0x17
     804:	0d d6       	rcall	.+3098   	; 0x1420 <__mulsf3>
     806:	28 89       	ldd	r18, Y+16	; 0x10
     808:	39 89       	ldd	r19, Y+17	; 0x11
     80a:	4a 89       	ldd	r20, Y+18	; 0x12
     80c:	5b 89       	ldd	r21, Y+19	; 0x13
     80e:	08 d6       	rcall	.+3088   	; 0x1420 <__mulsf3>
     810:	65 d4       	rcall	.+2250   	; 0x10dc <__fixunssfsi>
     812:	ef 81       	ldd	r30, Y+7	; 0x07
     814:	f8 85       	ldd	r31, Y+8	; 0x08
     816:	60 83       	st	Z, r22
     818:	20 e0       	ldi	r18, 0x00	; 0
     81a:	30 e0       	ldi	r19, 0x00	; 0
     81c:	40 ea       	ldi	r20, 0xA0	; 160
     81e:	50 e4       	ldi	r21, 0x40	; 64
     820:	68 8d       	ldd	r22, Y+24	; 0x18
     822:	79 8d       	ldd	r23, Y+25	; 0x19
     824:	8a 8d       	ldd	r24, Y+26	; 0x1a
     826:	9b 8d       	ldd	r25, Y+27	; 0x1b
     828:	fb d5       	rcall	.+3062   	; 0x1420 <__mulsf3>
     82a:	28 89       	ldd	r18, Y+16	; 0x10
     82c:	39 89       	ldd	r19, Y+17	; 0x11
     82e:	4a 89       	ldd	r20, Y+18	; 0x12
     830:	5b 89       	ldd	r21, Y+19	; 0x13
     832:	f6 d5       	rcall	.+3052   	; 0x1420 <__mulsf3>
     834:	53 d4       	rcall	.+2214   	; 0x10dc <__fixunssfsi>
     836:	af 81       	ldd	r26, Y+7	; 0x07
     838:	b8 85       	ldd	r27, Y+8	; 0x08
     83a:	11 96       	adiw	r26, 0x01	; 1
     83c:	6c 93       	st	X, r22
     83e:	20 e0       	ldi	r18, 0x00	; 0
     840:	30 e0       	ldi	r19, 0x00	; 0
     842:	40 ea       	ldi	r20, 0xA0	; 160
     844:	50 e4       	ldi	r21, 0x40	; 64
     846:	6c 8d       	ldd	r22, Y+28	; 0x1c
     848:	7d 8d       	ldd	r23, Y+29	; 0x1d
     84a:	8e 8d       	ldd	r24, Y+30	; 0x1e
     84c:	9f 8d       	ldd	r25, Y+31	; 0x1f
     84e:	e8 d5       	rcall	.+3024   	; 0x1420 <__mulsf3>
     850:	28 89       	ldd	r18, Y+16	; 0x10
     852:	39 89       	ldd	r19, Y+17	; 0x11
     854:	4a 89       	ldd	r20, Y+18	; 0x12
     856:	5b 89       	ldd	r21, Y+19	; 0x13
     858:	e3 d5       	rcall	.+3014   	; 0x1420 <__mulsf3>
     85a:	40 d4       	rcall	.+2176   	; 0x10dc <__fixunssfsi>
     85c:	ef 81       	ldd	r30, Y+7	; 0x07
     85e:	f8 85       	ldd	r31, Y+8	; 0x08
     860:	62 83       	std	Z+2, r22	; 0x02
				break;
     862:	34 c0       	rjmp	.+104    	; 0x8cc <tinyLED_update+0x2fe>
			case FLASH_ONCE:
				if(tinyLED_flash_once_time[i]>0){
     864:	d8 01       	movw	r26, r16
     866:	bc 90       	ld	r11, X
     868:	bb 20       	and	r11, r11
     86a:	79 f1       	breq	.+94     	; 0x8ca <tinyLED_update+0x2fc>
					rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*sinValue, rgb_colors[i].green*sinValue, rgb_colors[i].blue*sinValue};
     86c:	70 e0       	ldi	r23, 0x00	; 0
     86e:	80 e0       	ldi	r24, 0x00	; 0
     870:	90 e0       	ldi	r25, 0x00	; 0
     872:	65 d4       	rcall	.+2250   	; 0x113e <__floatsisf>
     874:	29 85       	ldd	r18, Y+9	; 0x09
     876:	3a 85       	ldd	r19, Y+10	; 0x0a
     878:	4b 85       	ldd	r20, Y+11	; 0x0b
     87a:	5c 85       	ldd	r21, Y+12	; 0x0c
     87c:	d1 d5       	rcall	.+2978   	; 0x1420 <__mulsf3>
     87e:	2e d4       	rcall	.+2140   	; 0x10dc <__fixunssfsi>
     880:	ef 81       	ldd	r30, Y+7	; 0x07
     882:	f8 85       	ldd	r31, Y+8	; 0x08
     884:	60 83       	st	Z, r22
     886:	6e 2d       	mov	r22, r14
     888:	70 e0       	ldi	r23, 0x00	; 0
     88a:	80 e0       	ldi	r24, 0x00	; 0
     88c:	90 e0       	ldi	r25, 0x00	; 0
     88e:	57 d4       	rcall	.+2222   	; 0x113e <__floatsisf>
     890:	29 85       	ldd	r18, Y+9	; 0x09
     892:	3a 85       	ldd	r19, Y+10	; 0x0a
     894:	4b 85       	ldd	r20, Y+11	; 0x0b
     896:	5c 85       	ldd	r21, Y+12	; 0x0c
     898:	c3 d5       	rcall	.+2950   	; 0x1420 <__mulsf3>
     89a:	20 d4       	rcall	.+2112   	; 0x10dc <__fixunssfsi>
     89c:	af 81       	ldd	r26, Y+7	; 0x07
     89e:	b8 85       	ldd	r27, Y+8	; 0x08
     8a0:	11 96       	adiw	r26, 0x01	; 1
     8a2:	6c 93       	st	X, r22
     8a4:	6f 2d       	mov	r22, r15
     8a6:	70 e0       	ldi	r23, 0x00	; 0
     8a8:	80 e0       	ldi	r24, 0x00	; 0
     8aa:	90 e0       	ldi	r25, 0x00	; 0
     8ac:	48 d4       	rcall	.+2192   	; 0x113e <__floatsisf>
     8ae:	29 85       	ldd	r18, Y+9	; 0x09
     8b0:	3a 85       	ldd	r19, Y+10	; 0x0a
     8b2:	4b 85       	ldd	r20, Y+11	; 0x0b
     8b4:	5c 85       	ldd	r21, Y+12	; 0x0c
     8b6:	b4 d5       	rcall	.+2920   	; 0x1420 <__mulsf3>
     8b8:	11 d4       	rcall	.+2082   	; 0x10dc <__fixunssfsi>
     8ba:	ef 81       	ldd	r30, Y+7	; 0x07
     8bc:	f8 85       	ldd	r31, Y+8	; 0x08
     8be:	62 83       	std	Z+2, r22	; 0x02
					tinyLED_flash_once_time[i]--;
     8c0:	8f ef       	ldi	r24, 0xFF	; 255
     8c2:	8b 0d       	add	r24, r11
     8c4:	d8 01       	movw	r26, r16
     8c6:	8c 93       	st	X, r24
     8c8:	01 c0       	rjmp	.+2      	; 0x8cc <tinyLED_update+0x2fe>
				}
				else{
					tinyLED_colors[i].color = OFF;
     8ca:	10 82       	st	Z, r1
     8cc:	b2 e0       	ldi	r27, 0x02	; 2
     8ce:	2b 0e       	add	r2, r27
     8d0:	31 1c       	adc	r3, r1
     8d2:	e3 e0       	ldi	r30, 0x03	; 3
     8d4:	8e 0e       	add	r8, r30
     8d6:	91 1c       	adc	r9, r1
     8d8:	0f 5f       	subi	r16, 0xFF	; 255
     8da:	1f 4f       	sbci	r17, 0xFF	; 255
	_Bool flash_on = now%(uint32_t)(1000/FLASH_RATE)   <   500/FLASH_RATE;
	_Bool ping_on = now%(uint32_t)(1000/PING_RATE)   <   1000*FLASH_TIME;
	struct RGB_Color rgb_colors[NUMBER_OF_LEDS];
	
		
	for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
     8dc:	2c 14       	cp	r2, r12
     8de:	3d 04       	cpc	r3, r13
     8e0:	09 f0       	breq	.+2      	; 0x8e4 <tinyLED_update+0x316>
     8e2:	d8 ce       	rjmp	.-592    	; 0x694 <tinyLED_update+0xc6>
     8e4:	ae 84       	ldd	r10, Y+14	; 0x0e
     8e6:	bf 84       	ldd	r11, Y+15	; 0x0f
				break;
			default:
				break;
		}
	}
	if(!tinyLED_RGB_Color_Compare(&rgb_colors, &tinyLED_old_colors)){
     8e8:	6f e5       	ldi	r22, 0x5F	; 95
     8ea:	7e e3       	ldi	r23, 0x3E	; 62
     8ec:	ce 01       	movw	r24, r28
     8ee:	01 96       	adiw	r24, 0x01	; 1
     8f0:	3e de       	rcall	.-900    	; 0x56e <tinyLED_RGB_Color_Compare>
     8f2:	81 11       	cpse	r24, r1
     8f4:	1e c0       	rjmp	.+60     	; 0x932 <tinyLED_update+0x364>
     8f6:	0f e5       	ldi	r16, 0x5F	; 95
     8f8:	1e e3       	ldi	r17, 0x3E	; 62
     8fa:	7e 01       	movw	r14, r28
     8fc:	f7 e0       	ldi	r31, 0x07	; 7
     8fe:	ef 0e       	add	r14, r31
     900:	f1 1c       	adc	r15, r1
		for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
		{
			// Write to LEDs
			//For some reason unknown to the writer the data-bus to the LEDs is serialized as GRB
			//which means the 24-bit data-bus will look like [Green[0:7], Red[0:7], Blue[0:7]]
			tinyLED_SPIWriteByte(rgb_colors[i].green);
     902:	d5 01       	movw	r26, r10
     904:	11 96       	adiw	r26, 0x01	; 1
     906:	8c 91       	ld	r24, X
     908:	fd dd       	rcall	.-1030   	; 0x504 <tinyLED_SPIWriteByte>
			tinyLED_SPIWriteByte(rgb_colors[i].red);
     90a:	f5 01       	movw	r30, r10
     90c:	80 81       	ld	r24, Z
     90e:	fa dd       	rcall	.-1036   	; 0x504 <tinyLED_SPIWriteByte>
			tinyLED_SPIWriteByte(rgb_colors[i].blue);
     910:	d5 01       	movw	r26, r10
     912:	12 96       	adiw	r26, 0x02	; 2
     914:	8c 91       	ld	r24, X
     916:	f6 dd       	rcall	.-1044   	; 0x504 <tinyLED_SPIWriteByte>
			tinyLED_old_colors[i] = rgb_colors[i];
     918:	f5 01       	movw	r30, r10
     91a:	81 91       	ld	r24, Z+
     91c:	91 91       	ld	r25, Z+
     91e:	a1 91       	ld	r26, Z+
     920:	5f 01       	movw	r10, r30
     922:	f8 01       	movw	r30, r16
     924:	81 93       	st	Z+, r24
     926:	91 93       	st	Z+, r25
     928:	a1 93       	st	Z+, r26
     92a:	8f 01       	movw	r16, r30
			default:
				break;
		}
	}
	if(!tinyLED_RGB_Color_Compare(&rgb_colors, &tinyLED_old_colors)){
		for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
     92c:	ae 14       	cp	r10, r14
     92e:	bf 04       	cpc	r11, r15
     930:	41 f7       	brne	.-48     	; 0x902 <tinyLED_update+0x334>
			tinyLED_SPIWriteByte(rgb_colors[i].red);
			tinyLED_SPIWriteByte(rgb_colors[i].blue);
			tinyLED_old_colors[i] = rgb_colors[i];
		}
	}
}
     932:	6f 96       	adiw	r28, 0x1f	; 31
     934:	cd bf       	out	0x3d, r28	; 61
     936:	de bf       	out	0x3e, r29	; 62
     938:	df 91       	pop	r29
     93a:	cf 91       	pop	r28
     93c:	1f 91       	pop	r17
     93e:	0f 91       	pop	r16
     940:	ff 90       	pop	r15
     942:	ef 90       	pop	r14
     944:	df 90       	pop	r13
     946:	cf 90       	pop	r12
     948:	bf 90       	pop	r11
     94a:	af 90       	pop	r10
     94c:	9f 90       	pop	r9
     94e:	8f 90       	pop	r8
     950:	7f 90       	pop	r7
     952:	6f 90       	pop	r6
     954:	5f 90       	pop	r5
     956:	4f 90       	pop	r4
     958:	3f 90       	pop	r3
     95a:	2f 90       	pop	r2
     95c:	08 95       	ret

0000095e <tinyAxon_add_pulse>:
{
	// We want to check each slot in the pulse_queue, and
	// if we find an empty slot (0), we add a pulse.
	for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
	{
		if(pulse_queue[i] == 0){
     95e:	20 91 28 3e 	lds	r18, 0x3E28	; 0x803e28 <pulse_queue>
     962:	30 91 29 3e 	lds	r19, 0x3E29	; 0x803e29 <pulse_queue+0x1>
     966:	23 2b       	or	r18, r19
     968:	51 f0       	breq	.+20     	; 0x97e <tinyAxon_add_pulse+0x20>
     96a:	ea e2       	ldi	r30, 0x2A	; 42
     96c:	fe e3       	ldi	r31, 0x3E	; 62
     96e:	21 e0       	ldi	r18, 0x01	; 1
     970:	30 e0       	ldi	r19, 0x00	; 0
     972:	b9 01       	movw	r22, r18
     974:	41 91       	ld	r20, Z+
     976:	51 91       	ld	r21, Z+
     978:	45 2b       	or	r20, r21
     97a:	81 f4       	brne	.+32     	; 0x99c <tinyAxon_add_pulse+0x3e>
     97c:	02 c0       	rjmp	.+4      	; 0x982 <tinyAxon_add_pulse+0x24>
     97e:	60 e0       	ldi	r22, 0x00	; 0
     980:	70 e0       	ldi	r23, 0x00	; 0
			pulse_queue[i] = new_pulse;
     982:	66 0f       	add	r22, r22
     984:	77 1f       	adc	r23, r23
     986:	fb 01       	movw	r30, r22
     988:	e8 5d       	subi	r30, 0xD8	; 216
     98a:	f1 4c       	sbci	r31, 0xC1	; 193
     98c:	80 83       	st	Z, r24
     98e:	91 83       	std	Z+1, r25	; 0x01
			pulses_in_queue++;
     990:	80 91 3c 3e 	lds	r24, 0x3E3C	; 0x803e3c <pulses_in_queue>
     994:	8f 5f       	subi	r24, 0xFF	; 255
     996:	80 93 3c 3e 	sts	0x3E3C, r24	; 0x803e3c <pulses_in_queue>
			// We return so we only ever add one
			break;
     99a:	08 95       	ret
     99c:	2f 5f       	subi	r18, 0xFF	; 255
     99e:	3f 4f       	sbci	r19, 0xFF	; 255
*/
static void tinyAxon_add_pulse(uint16_t new_pulse)
{
	// We want to check each slot in the pulse_queue, and
	// if we find an empty slot (0), we add a pulse.
	for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
     9a0:	2a 30       	cpi	r18, 0x0A	; 10
     9a2:	31 05       	cpc	r19, r1
     9a4:	31 f7       	brne	.-52     	; 0x972 <tinyAxon_add_pulse+0x14>
     9a6:	08 95       	ret

000009a8 <find_newest_pulse>:
uint8_t find_newest_pulse() {
	uint16_t max;
	uint8_t current_index = 0;
	uint8_t return_index = 0;
	
	max = pulse_queue[current_index];
     9a8:	40 91 28 3e 	lds	r20, 0x3E28	; 0x803e28 <pulse_queue>
     9ac:	50 91 29 3e 	lds	r21, 0x3E29	; 0x803e29 <pulse_queue+0x1>
     9b0:	ea e2       	ldi	r30, 0x2A	; 42
     9b2:	fe e3       	ldi	r31, 0x3E	; 62
	
// This function will be used with pulse_queue to find the newest pulse
uint8_t find_newest_pulse() {
	uint16_t max;
	uint8_t current_index = 0;
	uint8_t return_index = 0;
     9b4:	80 e0       	ldi	r24, 0x00	; 0
	
	max = pulse_queue[current_index];
	
	for (current_index = 1; current_index < MAX_NUMBER_OF_PULSES; current_index++) {
     9b6:	91 e0       	ldi	r25, 0x01	; 1
		if (pulse_queue[current_index] > max) {
     9b8:	21 91       	ld	r18, Z+
     9ba:	31 91       	ld	r19, Z+
     9bc:	42 17       	cp	r20, r18
     9be:	53 07       	cpc	r21, r19
     9c0:	10 f4       	brcc	.+4      	; 0x9c6 <find_newest_pulse+0x1e>
     9c2:	89 2f       	mov	r24, r25
			return_index = current_index;
			max = pulse_queue[current_index];
     9c4:	a9 01       	movw	r20, r18
	uint8_t current_index = 0;
	uint8_t return_index = 0;
	
	max = pulse_queue[current_index];
	
	for (current_index = 1; current_index < MAX_NUMBER_OF_PULSES; current_index++) {
     9c6:	9f 5f       	subi	r25, 0xFF	; 255
     9c8:	9a 30       	cpi	r25, 0x0A	; 10
     9ca:	b1 f7       	brne	.-20     	; 0x9b8 <find_newest_pulse+0x10>
			return_index = current_index;
			max = pulse_queue[current_index];
		}
	}
	return return_index;
}
     9cc:	08 95       	ret

000009ce <tinyAxon_remove_pulse>:

/*
If the potential is very low, we want to try to remove a pulse.
*/
bool tinyAxon_remove_pulse(void)
{
     9ce:	cf 93       	push	r28
	// We want to return a bool indicating whether or not a pulse actually was removed.
	if(pulses_in_queue == 0){
     9d0:	c0 91 3c 3e 	lds	r28, 0x3E3C	; 0x803e3c <pulses_in_queue>
     9d4:	cc 23       	and	r28, r28
     9d6:	81 f0       	breq	.+32     	; 0x9f8 <tinyAxon_remove_pulse+0x2a>
		//There was no pulse to remove.
		return false;
	}
	else{
		// If we are to remove a pulse, we want to remove the one that will fire last.
		uint16_t newest_pulse = pulse_queue[find_newest_pulse()];
     9d8:	e7 df       	rcall	.-50     	; 0x9a8 <find_newest_pulse>
     9da:	e8 2f       	mov	r30, r24
     9dc:	f0 e0       	ldi	r31, 0x00	; 0
     9de:	ee 0f       	add	r30, r30
     9e0:	ff 1f       	adc	r31, r31
     9e2:	e8 5d       	subi	r30, 0xD8	; 216
     9e4:	f1 4c       	sbci	r31, 0xC1	; 193
	
		// Now we want to check if the pulse is too far away to be affected by the low potential, or close enough that we decide to remove it.
		// (When we say that the pulse is too far away, it refers to the biological process of how the potential spreads from Dendrites to axon).
		if(newest_pulse > PULSE_NO_RETURN_TIME){
     9e6:	80 81       	ld	r24, Z
     9e8:	91 81       	ldd	r25, Z+1	; 0x01
     9ea:	cd 97       	sbiw	r24, 0x3d	; 61
     9ec:	38 f0       	brcs	.+14     	; 0x9fc <tinyAxon_remove_pulse+0x2e>
			// We decided to remove the pulse
			pulses_in_queue--;
     9ee:	c1 50       	subi	r28, 0x01	; 1
     9f0:	c0 93 3c 3e 	sts	0x3E3C, r28	; 0x803e3c <pulses_in_queue>
			return true;
     9f4:	81 e0       	ldi	r24, 0x01	; 1
     9f6:	03 c0       	rjmp	.+6      	; 0x9fe <tinyAxon_remove_pulse+0x30>
bool tinyAxon_remove_pulse(void)
{
	// We want to return a bool indicating whether or not a pulse actually was removed.
	if(pulses_in_queue == 0){
		//There was no pulse to remove.
		return false;
     9f8:	80 e0       	ldi	r24, 0x00	; 0
     9fa:	01 c0       	rjmp	.+2      	; 0x9fe <tinyAxon_remove_pulse+0x30>
			pulses_in_queue--;
			return true;
		}
		// Here we have found that there is a pulse queued, but it is old enough to let pass anyway, so now we need to put it back into the queue.
		else{
			return false;
     9fc:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     9fe:	cf 91       	pop	r28
     a00:	08 95       	ret

00000a02 <tinyAxon_update_potential>:
/*
Decides whether or not the axon should fire
If the axon does fire, the potential is reduced
*/
double tinyAxon_update_potential(double potential)
{	
     a02:	cf 92       	push	r12
     a04:	df 92       	push	r13
     a06:	ef 92       	push	r14
     a08:	ff 92       	push	r15
     a0a:	6b 01       	movw	r12, r22
     a0c:	7c 01       	movw	r14, r24
	//While the neuron has enough potential to fire, we want to fire more
	while (potential > THRESHOLD_POTENTIAL)
     a0e:	20 e0       	ldi	r18, 0x00	; 0
     a10:	30 e0       	ldi	r19, 0x00	; 0
     a12:	48 ec       	ldi	r20, 0xC8	; 200
     a14:	51 e4       	ldi	r21, 0x41	; 65
     a16:	89 d4       	rcall	.+2322   	; 0x132a <__gesf2>
     a18:	18 16       	cp	r1, r24
     a1a:	84 f5       	brge	.+96     	; 0xa7c <tinyAxon_update_potential+0x7a>
	{
		// We have to check if there are already queued pulses, so that the frequency never exceeds FIRE_DELAY
		if(pulses_in_queue>0){
     a1c:	80 91 3c 3e 	lds	r24, 0x3E3C	; 0x803e3c <pulses_in_queue>
     a20:	88 23       	and	r24, r24
     a22:	99 f0       	breq	.+38     	; 0xa4a <tinyAxon_update_potential+0x48>
			uint16_t newest_pulse = pulse_queue[find_newest_pulse()];
     a24:	c1 df       	rcall	.-126    	; 0x9a8 <find_newest_pulse>
     a26:	e8 2f       	mov	r30, r24
     a28:	f0 e0       	ldi	r31, 0x00	; 0
     a2a:	ee 0f       	add	r30, r30
     a2c:	ff 1f       	adc	r31, r31
     a2e:	e8 5d       	subi	r30, 0xD8	; 216
     a30:	f1 4c       	sbci	r31, 0xC1	; 193
			
			// There is at least one pulse in the queue, and it is so close, that we need to offset the new pulse, so that we keep at least
			// one FIRE_DELAY between each pulse
			if(newest_pulse + FIRE_DELAY > TRAVLE_DELAY){
     a32:	80 81       	ld	r24, Z
     a34:	91 81       	ldd	r25, Z+1	; 0x01
     a36:	c2 96       	adiw	r24, 0x32	; 50
     a38:	85 36       	cpi	r24, 0x65	; 101
     a3a:	91 05       	cpc	r25, r1
     a3c:	10 f0       	brcs	.+4      	; 0xa42 <tinyAxon_update_potential+0x40>
				tinyAxon_add_pulse(newest_pulse + FIRE_DELAY);
     a3e:	8f df       	rcall	.-226    	; 0x95e <tinyAxon_add_pulse>
     a40:	07 c0       	rjmp	.+14     	; 0xa50 <tinyAxon_update_potential+0x4e>
			}
			// There is at least one pulse in the queue, but it's far enough away to ignore
			else{
				tinyAxon_add_pulse(TRAVLE_DELAY);
     a42:	84 e6       	ldi	r24, 0x64	; 100
     a44:	90 e0       	ldi	r25, 0x00	; 0
     a46:	8b df       	rcall	.-234    	; 0x95e <tinyAxon_add_pulse>
     a48:	03 c0       	rjmp	.+6      	; 0xa50 <tinyAxon_update_potential+0x4e>
			}
		}
		// There are no pulses in the queue, so we add a pulse as normal
		else{
			tinyAxon_add_pulse(TRAVLE_DELAY);		
     a4a:	84 e6       	ldi	r24, 0x64	; 100
     a4c:	90 e0       	ldi	r25, 0x00	; 0
     a4e:	87 df       	rcall	.-242    	; 0x95e <tinyAxon_add_pulse>
		}
		
		potential += POSTFIRE_POTENTIAL_REACTION; // This is usually defined as a negative value, don't be confused by the +=
     a50:	20 e0       	ldi	r18, 0x00	; 0
     a52:	30 e0       	ldi	r19, 0x00	; 0
     a54:	40 ef       	ldi	r20, 0xF0	; 240
     a56:	51 e4       	ldi	r21, 0x41	; 65
     a58:	c7 01       	movw	r24, r14
     a5a:	b6 01       	movw	r22, r12
     a5c:	21 d2       	rcall	.+1090   	; 0xea0 <__subsf3>
     a5e:	6b 01       	movw	r12, r22
     a60:	7c 01       	movw	r14, r24
		
		tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
     a62:	44 e0       	ldi	r20, 0x04	; 4
     a64:	63 e0       	ldi	r22, 0x03	; 3
     a66:	81 e0       	ldi	r24, 0x01	; 1
     a68:	72 dd       	rcall	.-1308   	; 0x54e <tinyLED_set_color_mode>
If the axon does fire, the potential is reduced
*/
double tinyAxon_update_potential(double potential)
{	
	//While the neuron has enough potential to fire, we want to fire more
	while (potential > THRESHOLD_POTENTIAL)
     a6a:	20 e0       	ldi	r18, 0x00	; 0
     a6c:	30 e0       	ldi	r19, 0x00	; 0
     a6e:	48 ec       	ldi	r20, 0xC8	; 200
     a70:	51 e4       	ldi	r21, 0x41	; 65
     a72:	c7 01       	movw	r24, r14
     a74:	b6 01       	movw	r22, r12
     a76:	59 d4       	rcall	.+2226   	; 0x132a <__gesf2>
     a78:	18 16       	cp	r1, r24
     a7a:	84 f2       	brlt	.-96     	; 0xa1c <tinyAxon_update_potential+0x1a>
		
		tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
	}
	
	// If the neuron has a very low potential, we want to remove a pulse from the queue (if there is one)
	if(potential < -THRESHOLD_POTENTIAL && pulses_in_queue > 0) // Perhaps this should be a separate variable? For now, we will just simply use -THRESHOLD_POTENTIAL
     a7c:	20 e0       	ldi	r18, 0x00	; 0
     a7e:	30 e0       	ldi	r19, 0x00	; 0
     a80:	48 ec       	ldi	r20, 0xC8	; 200
     a82:	51 ec       	ldi	r21, 0xC1	; 193
     a84:	c7 01       	movw	r24, r14
     a86:	b6 01       	movw	r22, r12
     a88:	78 d2       	rcall	.+1264   	; 0xf7a <__cmpsf2>
     a8a:	88 23       	and	r24, r24
     a8c:	0c f0       	brlt	.+2      	; 0xa90 <tinyAxon_update_potential+0x8e>
     a8e:	45 c0       	rjmp	.+138    	; 0xb1a <tinyAxon_update_potential+0x118>
     a90:	80 91 3c 3e 	lds	r24, 0x3E3C	; 0x803e3c <pulses_in_queue>
     a94:	88 23       	and	r24, r24
     a96:	01 f1       	breq	.+64     	; 0xad8 <tinyAxon_update_potential+0xd6>
	{
		// The neurons potential is low enough to attempt to remove a queued fire (Fire less)
		if(tinyAxon_remove_pulse())
     a98:	9a df       	rcall	.-204    	; 0x9ce <tinyAxon_remove_pulse>
     a9a:	88 23       	and	r24, r24
     a9c:	f1 f1       	breq	.+124    	; 0xb1a <tinyAxon_update_potential+0x118>
		{
			// The potential has evened out a bit
			potential += THRESHOLD_POTENTIAL;
     a9e:	20 e0       	ldi	r18, 0x00	; 0
     aa0:	30 e0       	ldi	r19, 0x00	; 0
     aa2:	48 ec       	ldi	r20, 0xC8	; 200
     aa4:	51 e4       	ldi	r21, 0x41	; 65
     aa6:	c7 01       	movw	r24, r14
     aa8:	b6 01       	movw	r22, r12
     aaa:	fb d1       	rcall	.+1014   	; 0xea2 <__addsf3>
     aac:	6b 01       	movw	r12, r22
     aae:	7c 01       	movw	r14, r24
     ab0:	34 c0       	rjmp	.+104    	; 0xb1a <tinyAxon_update_potential+0x118>
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
	{
		for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
		{
			if(pulse_queue[i] != 0){
     ab2:	80 81       	ld	r24, Z
     ab4:	91 81       	ldd	r25, Z+1	; 0x01
     ab6:	00 97       	sbiw	r24, 0x00	; 0
     ab8:	39 f0       	breq	.+14     	; 0xac8 <tinyAxon_update_potential+0xc6>
				pulse_queue[i]--;
     aba:	01 97       	sbiw	r24, 0x01	; 1
     abc:	80 83       	st	Z, r24
     abe:	91 83       	std	Z+1, r25	; 0x01
				
				// If the time went from 1 to 0, we fire the axon
				if(pulse_queue[i] == 0){
     ac0:	89 2b       	or	r24, r25
     ac2:	11 f4       	brne	.+4      	; 0xac8 <tinyAxon_update_potential+0xc6>
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
	pulses_in_queue--;
     ac4:	41 50       	subi	r20, 0x01	; 1
Function to set firing.
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
     ac6:	51 e0       	ldi	r21, 0x01	; 1
     ac8:	32 96       	adiw	r30, 0x02	; 2
	}
	
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
	{
		for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
     aca:	e2 17       	cp	r30, r18
     acc:	f3 07       	cpc	r31, r19
     ace:	89 f7       	brne	.-30     	; 0xab2 <tinyAxon_update_potential+0xb0>
     ad0:	50 93 3d 3e 	sts	0x3E3D, r21	; 0x803e3d <tinyAxon_should_fire>
     ad4:	40 93 3c 3e 	sts	0x3E3C, r20	; 0x803e3c <pulses_in_queue>
The function should set the DAC to fire for two
update cycles once the pulse flag is set high.
*/
static void tinyAxon_update_pulse_transmitter(void)
{
	if (tinyAxon_should_fire)
     ad8:	80 91 3d 3e 	lds	r24, 0x3E3D	; 0x803e3d <tinyAxon_should_fire>
     adc:	88 23       	and	r24, r24
     ade:	81 f0       	breq	.+32     	; 0xb00 <tinyAxon_update_potential+0xfe>
	{
		tinyAxon_should_fire = false;
     ae0:	10 92 3d 3e 	sts	0x3E3D, r1	; 0x803e3d <tinyAxon_should_fire>
		tinyAxon_has_fired = true;
     ae4:	81 e0       	ldi	r24, 0x01	; 1
     ae6:	80 93 3e 3e 	sts	0x3E3E, r24	; 0x803e3e <tinyAxon_has_fired>
*/
static void tinyAxon_start_sending_pulse()
{
	if (NEURONTYPE == EXCITATORY_NEURON)
	{
		DAC_set_output(EXCITATORY_NEURON_OUTPUT);
     aea:	87 ed       	ldi	r24, 0xD7	; 215
     aec:	90 e0       	ldi	r25, 0x00	; 0
     aee:	21 db       	rcall	.-2494   	; 0x132 <DAC_set_output>
		axonOutputValue=EXCITATORY_NEURON_OUTPUT;
     af0:	87 ed       	ldi	r24, 0xD7	; 215
     af2:	80 93 27 3e 	sts	0x3E27, r24	; 0x803e27 <axonOutputValue>
	{
		DAC_set_output(INHIBITORY_NEURON_OUTPUT);
		axonOutputValue=INHIBITORY_NEURON_OUTPUT;
	}
	
	tinyLED_set_color_mode(OUT_LED, WHITE, FLASH_ONCE);
     af6:	44 e0       	ldi	r20, 0x04	; 4
     af8:	64 e0       	ldi	r22, 0x04	; 4
     afa:	80 e0       	ldi	r24, 0x00	; 0
     afc:	28 dd       	rcall	.-1456   	; 0x54e <tinyLED_set_color_mode>
     afe:	18 c0       	rjmp	.+48     	; 0xb30 <tinyAxon_update_potential+0x12e>
		tinyAxon_should_fire = false;
		tinyAxon_has_fired = true;
		
		tinyAxon_start_sending_pulse();
	}
	else if (tinyAxon_has_fired)
     b00:	80 91 3e 3e 	lds	r24, 0x3E3E	; 0x803e3e <tinyAxon_has_fired>
     b04:	88 23       	and	r24, r24
     b06:	19 f0       	breq	.+6      	; 0xb0e <tinyAxon_update_potential+0x10c>
	{
		tinyAxon_has_fired = false;
     b08:	10 92 3e 3e 	sts	0x3E3E, r1	; 0x803e3e <tinyAxon_has_fired>
     b0c:	11 c0       	rjmp	.+34     	; 0xb30 <tinyAxon_update_potential+0x12e>
	tinyLED_set_color_mode(OUT_LED, WHITE, FLASH_ONCE);
}

static void tinyAxon_stop_sending_pulse()
{
	DAC_set_output(NO_SIGNAL_OUTPUT);
     b0e:	80 e0       	ldi	r24, 0x00	; 0
     b10:	90 e0       	ldi	r25, 0x00	; 0
     b12:	0f db       	rcall	.-2530   	; 0x132 <DAC_set_output>
	axonOutputValue=NO_SIGNAL_OUTPUT;
     b14:	10 92 27 3e 	sts	0x3E27, r1	; 0x803e27 <axonOutputValue>
     b18:	0b c0       	rjmp	.+22     	; 0xb30 <tinyAxon_update_potential+0x12e>
			potential += THRESHOLD_POTENTIAL;
		}
	}
	
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
     b1a:	40 91 3c 3e 	lds	r20, 0x3E3C	; 0x803e3c <pulses_in_queue>
     b1e:	44 23       	and	r20, r20
     b20:	d9 f2       	breq	.-74     	; 0xad8 <tinyAxon_update_potential+0xd6>
     b22:	50 91 3d 3e 	lds	r21, 0x3E3D	; 0x803e3d <tinyAxon_should_fire>
     b26:	e8 e2       	ldi	r30, 0x28	; 40
     b28:	fe e3       	ldi	r31, 0x3E	; 62
     b2a:	2c e3       	ldi	r18, 0x3C	; 60
     b2c:	3e e3       	ldi	r19, 0x3E	; 62
     b2e:	c1 cf       	rjmp	.-126    	; 0xab2 <tinyAxon_update_potential+0xb0>
	}
	
	// Here we set the actual output of the DAC (Digital to Analog Converter)
	tinyAxon_update_pulse_transmitter();
	
	tinyDebugger_send_uint8("Axon", axonOutputValue);
     b30:	60 91 27 3e 	lds	r22, 0x3E27	; 0x803e27 <axonOutputValue>
     b34:	89 e1       	ldi	r24, 0x19	; 25
     b36:	96 e9       	ldi	r25, 0x96	; 150
     b38:	04 dc       	rcall	.-2040   	; 0x342 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("Pulses", pulses_in_queue);
     b3a:	60 91 3c 3e 	lds	r22, 0x3E3C	; 0x803e3c <pulses_in_queue>
     b3e:	8e e1       	ldi	r24, 0x1E	; 30
     b40:	96 e9       	ldi	r25, 0x96	; 150
     b42:	ff db       	rcall	.-2050   	; 0x342 <tinyDebugger_send_uint8>
	
	return potential;
}
     b44:	c7 01       	movw	r24, r14
     b46:	b6 01       	movw	r22, r12
     b48:	ff 90       	pop	r15
     b4a:	ef 90       	pop	r14
     b4c:	df 90       	pop	r13
     b4e:	cf 90       	pop	r12
     b50:	08 95       	ret

00000b52 <tinyDendrite_update_signals>:
/*
This function converts the 8 bit value from the ADC into one of the signal types defined in DendriteSignal
We also update the charging state
*/
void tinyDendrite_update_signals(void)
{
     b52:	2f 92       	push	r2
     b54:	3f 92       	push	r3
     b56:	4f 92       	push	r4
     b58:	5f 92       	push	r5
     b5a:	6f 92       	push	r6
     b5c:	7f 92       	push	r7
     b5e:	8f 92       	push	r8
     b60:	9f 92       	push	r9
     b62:	af 92       	push	r10
     b64:	bf 92       	push	r11
     b66:	cf 92       	push	r12
     b68:	df 92       	push	r13
     b6a:	ef 92       	push	r14
     b6c:	ff 92       	push	r15
     b6e:	0f 93       	push	r16
     b70:	1f 93       	push	r17
     b72:	cf 93       	push	r28
     b74:	df 93       	push	r29
     b76:	00 e1       	ldi	r16, 0x10	; 16
     b78:	1e e3       	ldi	r17, 0x3E	; 62
     b7a:	0f 2e       	mov	r0, r31
     b7c:	f9 e4       	ldi	r31, 0x49	; 73
     b7e:	cf 2e       	mov	r12, r31
     b80:	fe e3       	ldi	r31, 0x3E	; 62
     b82:	df 2e       	mov	r13, r31
     b84:	f0 2d       	mov	r31, r0
     b86:	0f 2e       	mov	r0, r31
     b88:	f3 e5       	ldi	r31, 0x53	; 83
     b8a:	ef 2e       	mov	r14, r31
     b8c:	fe e3       	ldi	r31, 0x3E	; 62
     b8e:	ff 2e       	mov	r15, r31
     b90:	f0 2d       	mov	r31, r0
     b92:	e6 01       	movw	r28, r12
*/
static void tinyDendrite_read_signals(void)
{
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_values[i] = ADC_get_conversion(Dendrite_ports[i]);
     b94:	f8 01       	movw	r30, r16
     b96:	81 91       	ld	r24, Z+
     b98:	8f 01       	movw	r16, r30
     b9a:	96 da       	rcall	.-2772   	; 0xc8 <ADC_get_conversion>
     b9c:	89 93       	st	Y+, r24
     b9e:	99 93       	st	Y+, r25
/*
This function reads the voltage at the Dendrite inputs with the ADC
*/
static void tinyDendrite_read_signals(void)
{
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
     ba0:	ce 15       	cp	r28, r14
     ba2:	df 05       	cpc	r29, r15
     ba4:	b9 f7       	brne	.-18     	; 0xb94 <tinyDendrite_update_signals+0x42>
	{
		tinyDendrite_values[i] = ADC_get_conversion(Dendrite_ports[i]);
	}
	tinyDebugger_send_int("D1", tinyDendrite_values[0]);
     ba6:	c9 e4       	ldi	r28, 0x49	; 73
     ba8:	de e3       	ldi	r29, 0x3E	; 62
     baa:	68 81       	ld	r22, Y
     bac:	79 81       	ldd	r23, Y+1	; 0x01
     bae:	85 e2       	ldi	r24, 0x25	; 37
     bb0:	96 e9       	ldi	r25, 0x96	; 150
     bb2:	c6 db       	rcall	.-2164   	; 0x340 <tinyDebugger_send_int>
	tinyDebugger_send_int("D2", tinyDendrite_values[1]);
     bb4:	6a 81       	ldd	r22, Y+2	; 0x02
     bb6:	7b 81       	ldd	r23, Y+3	; 0x03
     bb8:	88 e2       	ldi	r24, 0x28	; 40
     bba:	96 e9       	ldi	r25, 0x96	; 150
     bbc:	c1 db       	rcall	.-2174   	; 0x340 <tinyDebugger_send_int>
	tinyDebugger_send_int("D3", tinyDendrite_values[2]);
     bbe:	6c 81       	ldd	r22, Y+4	; 0x04
     bc0:	7d 81       	ldd	r23, Y+5	; 0x05
     bc2:	8b e2       	ldi	r24, 0x2B	; 43
     bc4:	96 e9       	ldi	r25, 0x96	; 150
     bc6:	bc db       	rcall	.-2184   	; 0x340 <tinyDebugger_send_int>
	tinyDebugger_send_int("D4", tinyDendrite_values[3]);
     bc8:	6e 81       	ldd	r22, Y+6	; 0x06
     bca:	7f 81       	ldd	r23, Y+7	; 0x07
     bcc:	8e e2       	ldi	r24, 0x2E	; 46
     bce:	96 e9       	ldi	r25, 0x96	; 150
     bd0:	b7 db       	rcall	.-2194   	; 0x340 <tinyDebugger_send_int>
	tinyDebugger_send_int("D5", tinyDendrite_values[4]);
     bd2:	68 85       	ldd	r22, Y+8	; 0x08
     bd4:	79 85       	ldd	r23, Y+9	; 0x09
     bd6:	81 e3       	ldi	r24, 0x31	; 49
     bd8:	96 e9       	ldi	r25, 0x96	; 150
     bda:	b2 db       	rcall	.-2204   	; 0x340 <tinyDebugger_send_int>
{
	
	//Read the analog voltage values on each of the Dendrites
	tinyDendrite_read_signals();
	
	tinyCharge_set_charging_mode(false);
     bdc:	80 e0       	ldi	r24, 0x00	; 0
     bde:	a5 db       	rcall	.-2230   	; 0x32a <tinyCharge_set_charging_mode>
     be0:	c4 e4       	ldi	r28, 0x44	; 68
     be2:	de e3       	ldi	r29, 0x3E	; 62
     be4:	0f e3       	ldi	r16, 0x3F	; 63
     be6:	1e e3       	ldi	r17, 0x3E	; 62
     be8:	0f 2e       	mov	r0, r31
     bea:	f9 e4       	ldi	r31, 0x49	; 73
     bec:	8f 2e       	mov	r8, r31
     bee:	fe e3       	ldi	r31, 0x3E	; 62
     bf0:	9f 2e       	mov	r9, r31
     bf2:	f0 2d       	mov	r31, r0
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     bf4:	66 24       	eor	r6, r6
     bf6:	63 94       	inc	r6
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     bf8:	68 94       	set
     bfa:	22 24       	eor	r2, r2
     bfc:	21 f8       	bld	r2, 1
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     bfe:	68 94       	set
     c00:	33 24       	eor	r3, r3
     c02:	32 f8       	bld	r3, 2
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     c04:	0f 2e       	mov	r0, r31
     c06:	f6 e0       	ldi	r31, 0x06	; 6
     c08:	4f 2e       	mov	r4, r31
     c0a:	f0 2d       	mov	r31, r0
			tinyDendrite_current_signals[i] = CHARGING;
			tinyCharge_set_charging_mode(true);
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     c0c:	0f 2e       	mov	r0, r31
     c0e:	f5 e0       	ldi	r31, 0x05	; 5
     c10:	7f 2e       	mov	r7, r31
     c12:	f0 2d       	mov	r31, r0
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = CHARGING;
     c14:	0f 2e       	mov	r0, r31
     c16:	f7 e0       	ldi	r31, 0x07	; 7
     c18:	5f 2e       	mov	r5, r31
     c1a:	f0 2d       	mov	r31, r0
     c1c:	7e 01       	movw	r14, r28
     c1e:	58 01       	movw	r10, r16
	
	tinyCharge_set_charging_mode(false);
	
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
     c20:	88 81       	ld	r24, Y
     c22:	f8 01       	movw	r30, r16
     c24:	80 83       	st	Z, r24
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
     c26:	f6 01       	movw	r30, r12
     c28:	81 91       	ld	r24, Z+
     c2a:	91 91       	ld	r25, Z+
     c2c:	6f 01       	movw	r12, r30
     c2e:	89 3e       	cpi	r24, 0xE9	; 233
     c30:	91 05       	cpc	r25, r1
     c32:	20 f0       	brcs	.+8      	; 0xc3c <tinyDendrite_update_signals+0xea>
		{
			tinyDendrite_current_signals[i] = CHARGING;
     c34:	58 82       	st	Y, r5
			tinyCharge_set_charging_mode(true);
     c36:	86 2d       	mov	r24, r6
     c38:	78 db       	rcall	.-2320   	; 0x32a <tinyCharge_set_charging_mode>
     c3a:	1f c0       	rjmp	.+62     	; 0xc7a <tinyDendrite_update_signals+0x128>
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
     c3c:	88 3c       	cpi	r24, 0xC8	; 200
     c3e:	91 05       	cpc	r25, r1
     c40:	10 f0       	brcs	.+4      	; 0xc46 <tinyDendrite_update_signals+0xf4>
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     c42:	78 82       	st	Y, r7
     c44:	1a c0       	rjmp	.+52     	; 0xc7a <tinyDendrite_update_signals+0x128>
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
     c46:	87 3a       	cpi	r24, 0xA7	; 167
     c48:	91 05       	cpc	r25, r1
     c4a:	10 f0       	brcs	.+4      	; 0xc50 <tinyDendrite_update_signals+0xfe>
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     c4c:	48 82       	st	Y, r4
     c4e:	15 c0       	rjmp	.+42     	; 0xc7a <tinyDendrite_update_signals+0x128>
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
     c50:	85 38       	cpi	r24, 0x85	; 133
     c52:	91 05       	cpc	r25, r1
     c54:	10 f0       	brcs	.+4      	; 0xc5a <tinyDendrite_update_signals+0x108>
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     c56:	38 82       	st	Y, r3
     c58:	10 c0       	rjmp	.+32     	; 0xc7a <tinyDendrite_update_signals+0x128>
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
     c5a:	84 36       	cpi	r24, 0x64	; 100
     c5c:	91 05       	cpc	r25, r1
     c5e:	10 f0       	brcs	.+4      	; 0xc64 <tinyDendrite_update_signals+0x112>
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     c60:	28 82       	st	Y, r2
     c62:	0b c0       	rjmp	.+22     	; 0xc7a <tinyDendrite_update_signals+0x128>
		}
		else if (tinyDendrite_values[i] > HIGH_INHIB_THRESHOLD)
     c64:	83 34       	cpi	r24, 0x43	; 67
     c66:	91 05       	cpc	r25, r1
     c68:	18 f0       	brcs	.+6      	; 0xc70 <tinyDendrite_update_signals+0x11e>
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
     c6a:	83 e0       	ldi	r24, 0x03	; 3
     c6c:	88 83       	st	Y, r24
     c6e:	05 c0       	rjmp	.+10     	; 0xc7a <tinyDendrite_update_signals+0x128>
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
     c70:	82 97       	sbiw	r24, 0x22	; 34
     c72:	10 f0       	brcs	.+4      	; 0xc78 <tinyDendrite_update_signals+0x126>
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     c74:	68 82       	st	Y, r6
     c76:	01 c0       	rjmp	.+2      	; 0xc7a <tinyDendrite_update_signals+0x128>
		}
		else
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     c78:	18 82       	st	Y, r1
     c7a:	0f 5f       	subi	r16, 0xFF	; 255
     c7c:	1f 4f       	sbci	r17, 0xFF	; 255
		}
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
     c7e:	f7 01       	movw	r30, r14
     c80:	90 81       	ld	r25, Z
     c82:	f5 01       	movw	r30, r10
     c84:	80 81       	ld	r24, Z
     c86:	98 13       	cpse	r25, r24
     c88:	02 c0       	rjmp	.+4      	; 0xc8e <tinyDendrite_update_signals+0x13c>
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     c8a:	f7 01       	movw	r30, r14
     c8c:	10 82       	st	Z, r1
     c8e:	21 96       	adiw	r28, 0x01	; 1
	//Read the analog voltage values on each of the Dendrites
	tinyDendrite_read_signals();
	
	tinyCharge_set_charging_mode(false);
	
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
     c90:	c8 15       	cp	r28, r8
     c92:	d9 05       	cpc	r29, r9
     c94:	19 f6       	brne	.-122    	; 0xc1c <tinyDendrite_update_signals+0xca>
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
		}
	}
}
     c96:	df 91       	pop	r29
     c98:	cf 91       	pop	r28
     c9a:	1f 91       	pop	r17
     c9c:	0f 91       	pop	r16
     c9e:	ff 90       	pop	r15
     ca0:	ef 90       	pop	r14
     ca2:	df 90       	pop	r13
     ca4:	cf 90       	pop	r12
     ca6:	bf 90       	pop	r11
     ca8:	af 90       	pop	r10
     caa:	9f 90       	pop	r9
     cac:	8f 90       	pop	r8
     cae:	7f 90       	pop	r7
     cb0:	6f 90       	pop	r6
     cb2:	5f 90       	pop	r5
     cb4:	4f 90       	pop	r4
     cb6:	3f 90       	pop	r3
     cb8:	2f 90       	pop	r2
     cba:	08 95       	ret

00000cbc <tinyDendrite_get_potential>:
outside. It uses the previously declared functions to return the potential.
*/
int16_t tinyDendrite_get_potential()
{
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
     cbc:	4a df       	rcall	.-364    	; 0xb52 <tinyDendrite_update_signals>
     cbe:	e4 e4       	ldi	r30, 0x44	; 68
     cc0:	fe e3       	ldi	r31, 0x3E	; 62
     cc2:	49 e4       	ldi	r20, 0x49	; 73
     cc4:	5e e3       	ldi	r21, 0x3E	; 62
	
	int16_t return_potential_val = 0;
     cc6:	20 e0       	ldi	r18, 0x00	; 0
     cc8:	30 e0       	ldi	r19, 0x00	; 0
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		switch(tinyDendrite_current_signals[i])
     cca:	91 91       	ld	r25, Z+
     ccc:	93 30       	cpi	r25, 0x03	; 3
     cce:	a1 f0       	breq	.+40     	; 0xcf8 <tinyDendrite_get_potential+0x3c>
     cd0:	28 f4       	brcc	.+10     	; 0xcdc <tinyDendrite_get_potential+0x20>
     cd2:	91 30       	cpi	r25, 0x01	; 1
     cd4:	b9 f0       	breq	.+46     	; 0xd04 <tinyDendrite_get_potential+0x48>
     cd6:	92 30       	cpi	r25, 0x02	; 2
     cd8:	91 f0       	breq	.+36     	; 0xcfe <tinyDendrite_get_potential+0x42>
     cda:	16 c0       	rjmp	.+44     	; 0xd08 <tinyDendrite_get_potential+0x4c>
     cdc:	95 30       	cpi	r25, 0x05	; 5
     cde:	31 f0       	breq	.+12     	; 0xcec <tinyDendrite_get_potential+0x30>
     ce0:	40 f0       	brcs	.+16     	; 0xcf2 <tinyDendrite_get_potential+0x36>
     ce2:	96 30       	cpi	r25, 0x06	; 6
     ce4:	89 f4       	brne	.+34     	; 0xd08 <tinyDendrite_get_potential+0x4c>
		{
			case NO_SIGNAL:
				return_potential_val += NO_SIGNAL_REACTION;
				break;
			case HIGH_EXCITE:
				return_potential_val += HIGH_EXCITE_REACTION;
     ce6:	2c 5c       	subi	r18, 0xCC	; 204
     ce8:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     cea:	0e c0       	rjmp	.+28     	; 0xd08 <tinyDendrite_get_potential+0x4c>
			case NORMAL_EXCITE:
				return_potential_val += NORMAL_EXCITE_REACTION;
     cec:	26 5e       	subi	r18, 0xE6	; 230
     cee:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     cf0:	0b c0       	rjmp	.+22     	; 0xd08 <tinyDendrite_get_potential+0x4c>
			case LOW_EXCITE:
				return_potential_val += LOW_EXCITE_REACTION;
     cf2:	2c 5e       	subi	r18, 0xEC	; 236
     cf4:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     cf6:	08 c0       	rjmp	.+16     	; 0xd08 <tinyDendrite_get_potential+0x4c>
			case HIGH_INHIB:
				return_potential_val += HIGH_INHIB_REACTION;
     cf8:	22 53       	subi	r18, 0x32	; 50
     cfa:	31 09       	sbc	r19, r1
				break;
     cfc:	05 c0       	rjmp	.+10     	; 0xd08 <tinyDendrite_get_potential+0x4c>
			case NORMAL_INHIB:
				return_potential_val += NORMAL_INHIB_REACTION;
     cfe:	2a 51       	subi	r18, 0x1A	; 26
     d00:	31 09       	sbc	r19, r1
				break;
     d02:	02 c0       	rjmp	.+4      	; 0xd08 <tinyDendrite_get_potential+0x4c>
			case LOW_INHIB:
				return_potential_val += LOW_INHIB_REACTION;
     d04:	24 51       	subi	r18, 0x14	; 20
     d06:	31 09       	sbc	r19, r1
{
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
	
	int16_t return_potential_val = 0;
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
     d08:	e4 17       	cp	r30, r20
     d0a:	f5 07       	cpc	r31, r21
     d0c:	f1 f6       	brne	.-68     	; 0xcca <tinyDendrite_get_potential+0xe>
			default:
				break;
		}
	}
	return return_potential_val;
}
     d0e:	c9 01       	movw	r24, r18
     d10:	08 95       	ret

00000d12 <tinyDendrite_update_potential>:

double tinyDendrite_update_potential(double potential){
     d12:	cf 92       	push	r12
     d14:	df 92       	push	r13
     d16:	ef 92       	push	r14
     d18:	ff 92       	push	r15
     d1a:	6b 01       	movw	r12, r22
     d1c:	7c 01       	movw	r14, r24
	
	int16_t potential_change = tinyDendrite_get_potential();
     d1e:	ce df       	rcall	.-100    	; 0xcbc <tinyDendrite_get_potential>
	potential += potential_change;
	return potential;
     d20:	bc 01       	movw	r22, r24
     d22:	99 0f       	add	r25, r25
     d24:	88 0b       	sbc	r24, r24
     d26:	99 0b       	sbc	r25, r25
     d28:	0a d2       	rcall	.+1044   	; 0x113e <__floatsisf>
     d2a:	a7 01       	movw	r20, r14
     d2c:	96 01       	movw	r18, r12
     d2e:	b9 d0       	rcall	.+370    	; 0xea2 <__addsf3>
     d30:	ff 90       	pop	r15
     d32:	ef 90       	pop	r14
     d34:	df 90       	pop	r13
     d36:	cf 90       	pop	r12
     d38:	08 95       	ret

00000d3a <__vector_6>:
This function is called every time the RTC (Real Time Clock) counter overflows.
With the current settings, it will be called every ms.
The RTC clock runs at 1kHz, and the number of cycles before overflow is set with RTC.PER = someHexValue (e.g. 0x20) in src/rtc.c
*/
ISR(RTC_CNT_vect)
{
     d3a:	1f 92       	push	r1
     d3c:	0f 92       	push	r0
     d3e:	0f b6       	in	r0, 0x3f	; 63
     d40:	0f 92       	push	r0
     d42:	11 24       	eor	r1, r1
     d44:	2f 93       	push	r18
     d46:	3f 93       	push	r19
     d48:	4f 93       	push	r20
     d4a:	5f 93       	push	r21
     d4c:	6f 93       	push	r22
     d4e:	7f 93       	push	r23
     d50:	8f 93       	push	r24
     d52:	9f 93       	push	r25
     d54:	af 93       	push	r26
     d56:	bf 93       	push	r27
     d58:	cf 93       	push	r28
     d5a:	ef 93       	push	r30
     d5c:	ff 93       	push	r31
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     d5e:	c1 e0       	ldi	r28, 0x01	; 1
     d60:	c0 93 53 3e 	sts	0x3E53, r28	; 0x803e53 <tinyISR_interrupt_flag>
{
	// Set flag to let main loop run a new cycle
	tinyISR_setflag(true);
	
	// Timer counter incrementation
	tinyTime_counter_increment();
     d64:	2d db       	rcall	.-2470   	; 0x3c0 <tinyTime_counter_increment>

	/* Overflow interrupt flag has to be cleared manually */
	RTC.INTFLAGS = RTC_OVF_bm;
     d66:	c0 93 43 01 	sts	0x0143, r28	; 0x800143 <__TEXT_REGION_LENGTH__+0x700143>
}
     d6a:	ff 91       	pop	r31
     d6c:	ef 91       	pop	r30
     d6e:	cf 91       	pop	r28
     d70:	bf 91       	pop	r27
     d72:	af 91       	pop	r26
     d74:	9f 91       	pop	r25
     d76:	8f 91       	pop	r24
     d78:	7f 91       	pop	r23
     d7a:	6f 91       	pop	r22
     d7c:	5f 91       	pop	r21
     d7e:	4f 91       	pop	r20
     d80:	3f 91       	pop	r19
     d82:	2f 91       	pop	r18
     d84:	0f 90       	pop	r0
     d86:	0f be       	out	0x3f, r0	; 63
     d88:	0f 90       	pop	r0
     d8a:	1f 90       	pop	r1
     d8c:	18 95       	reti

00000d8e <tinyISR_setflag>:
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     d8e:	80 93 53 3e 	sts	0x3E53, r24	; 0x803e53 <tinyISR_interrupt_flag>
     d92:	08 95       	ret

00000d94 <tinyISR_getflag>:
}

_Bool tinyISR_getflag(void)
{
	return tinyISR_interrupt_flag;
}
     d94:	80 91 53 3e 	lds	r24, 0x3E53	; 0x803e53 <tinyISR_interrupt_flag>
     d98:	08 95       	ret

00000d9a <tinyPotential_update>:
/*
The function which will run in the main loop.
This function will run on interrupts by the RTC module.
*/
void tinyPotential_update()
{
     d9a:	cf 92       	push	r12
     d9c:	df 92       	push	r13
     d9e:	ef 92       	push	r14
     da0:	ff 92       	push	r15
Function to decay the potential towards 0
*/
static void tinyPotential_decay()
{
		
	uint8_t time_since_last_update = tinyTime_now() - previous_update_time;
     da2:	22 db       	rcall	.-2492   	; 0x3e8 <tinyTime_now>
	tinyPotential_potential *= (exp(-((float)time_since_last_update/(float)TINYPOTENTIAL_TIME_CONST)));
     da4:	80 91 54 3e 	lds	r24, 0x3E54	; 0x803e54 <previous_update_time>
     da8:	68 1b       	sub	r22, r24
     daa:	70 e0       	ldi	r23, 0x00	; 0
     dac:	80 e0       	ldi	r24, 0x00	; 0
     dae:	90 e0       	ldi	r25, 0x00	; 0
     db0:	c4 d1       	rcall	.+904    	; 0x113a <__floatunsisf>
     db2:	20 e0       	ldi	r18, 0x00	; 0
     db4:	30 e0       	ldi	r19, 0x00	; 0
     db6:	48 ec       	ldi	r20, 0xC8	; 200
     db8:	52 e4       	ldi	r21, 0x42	; 66
     dba:	e4 d0       	rcall	.+456    	; 0xf84 <__divsf3>
     dbc:	90 58       	subi	r25, 0x80	; 128
     dbe:	5c d1       	rcall	.+696    	; 0x1078 <exp>
     dc0:	20 91 58 3e 	lds	r18, 0x3E58	; 0x803e58 <tinyPotential_potential>
     dc4:	30 91 59 3e 	lds	r19, 0x3E59	; 0x803e59 <tinyPotential_potential+0x1>
     dc8:	40 91 5a 3e 	lds	r20, 0x3E5A	; 0x803e5a <tinyPotential_potential+0x2>
     dcc:	50 91 5b 3e 	lds	r21, 0x3E5B	; 0x803e5b <tinyPotential_potential+0x3>
     dd0:	27 d3       	rcall	.+1614   	; 0x1420 <__mulsf3>
     dd2:	6b 01       	movw	r12, r22
     dd4:	7c 01       	movw	r14, r24
	if(fabs(tinyPotential_potential)<0.1){
     dd6:	9f 77       	andi	r25, 0x7F	; 127
     dd8:	2d ec       	ldi	r18, 0xCD	; 205
     dda:	3c ec       	ldi	r19, 0xCC	; 204
     ddc:	4c ec       	ldi	r20, 0xCC	; 204
     dde:	5d e3       	ldi	r21, 0x3D	; 61
     de0:	cc d0       	rcall	.+408    	; 0xf7a <__cmpsf2>
     de2:	88 23       	and	r24, r24
     de4:	4c f0       	brlt	.+18     	; 0xdf8 <tinyPotential_update+0x5e>
*/
static void tinyPotential_decay()
{
		
	uint8_t time_since_last_update = tinyTime_now() - previous_update_time;
	tinyPotential_potential *= (exp(-((float)time_since_last_update/(float)TINYPOTENTIAL_TIME_CONST)));
     de6:	c0 92 58 3e 	sts	0x3E58, r12	; 0x803e58 <tinyPotential_potential>
     dea:	d0 92 59 3e 	sts	0x3E59, r13	; 0x803e59 <tinyPotential_potential+0x1>
     dee:	e0 92 5a 3e 	sts	0x3E5A, r14	; 0x803e5a <tinyPotential_potential+0x2>
     df2:	f0 92 5b 3e 	sts	0x3E5B, r15	; 0x803e5b <tinyPotential_potential+0x3>
     df6:	08 c0       	rjmp	.+16     	; 0xe08 <tinyPotential_update+0x6e>
	if(fabs(tinyPotential_potential)<0.1){
		tinyPotential_potential=0;
     df8:	10 92 58 3e 	sts	0x3E58, r1	; 0x803e58 <tinyPotential_potential>
     dfc:	10 92 59 3e 	sts	0x3E59, r1	; 0x803e59 <tinyPotential_potential+0x1>
     e00:	10 92 5a 3e 	sts	0x3E5A, r1	; 0x803e5a <tinyPotential_potential+0x2>
     e04:	10 92 5b 3e 	sts	0x3E5B, r1	; 0x803e5b <tinyPotential_potential+0x3>
	}
	previous_update_time = tinyTime_now();
     e08:	ef da       	rcall	.-2594   	; 0x3e8 <tinyTime_now>
     e0a:	60 93 54 3e 	sts	0x3E54, r22	; 0x803e54 <previous_update_time>
     e0e:	70 93 55 3e 	sts	0x3E55, r23	; 0x803e55 <previous_update_time+0x1>
     e12:	80 93 56 3e 	sts	0x3E56, r24	; 0x803e56 <previous_update_time+0x2>
     e16:	90 93 57 3e 	sts	0x3E57, r25	; 0x803e57 <previous_update_time+0x3>
void tinyPotential_update()
{
	//Some of the potential in the neuron has decayed away
	tinyPotential_decay();
	// Update potential with values from Dendrites
	tinyPotential_potential = tinyDendrite_update_potential(tinyPotential_potential);
     e1a:	60 91 58 3e 	lds	r22, 0x3E58	; 0x803e58 <tinyPotential_potential>
     e1e:	70 91 59 3e 	lds	r23, 0x3E59	; 0x803e59 <tinyPotential_potential+0x1>
     e22:	80 91 5a 3e 	lds	r24, 0x3E5A	; 0x803e5a <tinyPotential_potential+0x2>
     e26:	90 91 5b 3e 	lds	r25, 0x3E5B	; 0x803e5b <tinyPotential_potential+0x3>
     e2a:	73 df       	rcall	.-282    	; 0xd12 <tinyDendrite_update_potential>
     e2c:	ab 01       	movw	r20, r22
     e2e:	bc 01       	movw	r22, r24
     e30:	40 93 58 3e 	sts	0x3E58, r20	; 0x803e58 <tinyPotential_potential>
     e34:	50 93 59 3e 	sts	0x3E59, r21	; 0x803e59 <tinyPotential_potential+0x1>
     e38:	60 93 5a 3e 	sts	0x3E5A, r22	; 0x803e5a <tinyPotential_potential+0x2>
     e3c:	70 93 5b 3e 	sts	0x3E5B, r23	; 0x803e5b <tinyPotential_potential+0x3>
	tinyDebugger_send_double("DendP", tinyPotential_potential);
     e40:	84 e3       	ldi	r24, 0x34	; 52
     e42:	96 e9       	ldi	r25, 0x96	; 150
     e44:	7f da       	rcall	.-2818   	; 0x344 <tinyDebugger_send_double>
	
	// Update potential from button press
	tinyPotential_potential = tinyButton_update_potential(tinyPotential_potential);
     e46:	60 91 58 3e 	lds	r22, 0x3E58	; 0x803e58 <tinyPotential_potential>
     e4a:	70 91 59 3e 	lds	r23, 0x3E59	; 0x803e59 <tinyPotential_potential+0x1>
     e4e:	80 91 5a 3e 	lds	r24, 0x3E5A	; 0x803e5a <tinyPotential_potential+0x2>
     e52:	90 91 5b 3e 	lds	r25, 0x3E5B	; 0x803e5b <tinyPotential_potential+0x3>
     e56:	4c db       	rcall	.-2408   	; 0x4f0 <tinyButton_update_potential>
     e58:	60 93 58 3e 	sts	0x3E58, r22	; 0x803e58 <tinyPotential_potential>
     e5c:	70 93 59 3e 	sts	0x3E59, r23	; 0x803e59 <tinyPotential_potential+0x1>
     e60:	80 93 5a 3e 	sts	0x3E5A, r24	; 0x803e5a <tinyPotential_potential+0x2>
     e64:	90 93 5b 3e 	sts	0x3E5B, r25	; 0x803e5b <tinyPotential_potential+0x3>
	
	// Update potential with values from spontaneous pulse.
	tinyPotential_potential = tinyPulse_update_potential(tinyPotential_potential);
     e68:	76 da       	rcall	.-2836   	; 0x356 <tinyPulse_update_potential>
     e6a:	60 93 58 3e 	sts	0x3E58, r22	; 0x803e58 <tinyPotential_potential>
     e6e:	70 93 59 3e 	sts	0x3E59, r23	; 0x803e59 <tinyPotential_potential+0x1>
     e72:	80 93 5a 3e 	sts	0x3E5A, r24	; 0x803e5a <tinyPotential_potential+0x2>
     e76:	90 93 5b 3e 	sts	0x3E5B, r25	; 0x803e5b <tinyPotential_potential+0x3>
	
	// Let the axon affect the potential
	// This is also where we decide whether or not the axon should fire
	tinyPotential_potential = tinyAxon_update_potential(tinyPotential_potential);
     e7a:	c3 dd       	rcall	.-1146   	; 0xa02 <tinyAxon_update_potential>
     e7c:	ab 01       	movw	r20, r22
     e7e:	bc 01       	movw	r22, r24
     e80:	40 93 58 3e 	sts	0x3E58, r20	; 0x803e58 <tinyPotential_potential>
     e84:	50 93 59 3e 	sts	0x3E59, r21	; 0x803e59 <tinyPotential_potential+0x1>
     e88:	60 93 5a 3e 	sts	0x3E5A, r22	; 0x803e5a <tinyPotential_potential+0x2>
     e8c:	70 93 5b 3e 	sts	0x3E5B, r23	; 0x803e5b <tinyPotential_potential+0x3>
	tinyDebugger_send_double("AxonP", tinyPotential_potential);
     e90:	8a e3       	ldi	r24, 0x3A	; 58
     e92:	96 e9       	ldi	r25, 0x96	; 150
     e94:	57 da       	rcall	.-2898   	; 0x344 <tinyDebugger_send_double>

	//Update the led
	//potential_to_RGB_update_LEDs(tinyPotential_potential);
}
     e96:	ff 90       	pop	r15
     e98:	ef 90       	pop	r14
     e9a:	df 90       	pop	r13
     e9c:	cf 90       	pop	r12
     e9e:	08 95       	ret

00000ea0 <__subsf3>:
     ea0:	50 58       	subi	r21, 0x80	; 128

00000ea2 <__addsf3>:
     ea2:	bb 27       	eor	r27, r27
     ea4:	aa 27       	eor	r26, r26
     ea6:	0e 94 68 07 	call	0xed0	; 0xed0 <__addsf3x>
     eaa:	0c 94 5b 09 	jmp	0x12b6	; 0x12b6 <__fp_round>
     eae:	0e 94 4d 09 	call	0x129a	; 0x129a <__fp_pscA>
     eb2:	38 f0       	brcs	.+14     	; 0xec2 <__addsf3+0x20>
     eb4:	0e 94 54 09 	call	0x12a8	; 0x12a8 <__fp_pscB>
     eb8:	20 f0       	brcs	.+8      	; 0xec2 <__addsf3+0x20>
     eba:	39 f4       	brne	.+14     	; 0xeca <__addsf3+0x28>
     ebc:	9f 3f       	cpi	r25, 0xFF	; 255
     ebe:	19 f4       	brne	.+6      	; 0xec6 <__addsf3+0x24>
     ec0:	26 f4       	brtc	.+8      	; 0xeca <__addsf3+0x28>
     ec2:	0c 94 23 09 	jmp	0x1246	; 0x1246 <__fp_nan>
     ec6:	0e f4       	brtc	.+2      	; 0xeca <__addsf3+0x28>
     ec8:	e0 95       	com	r30
     eca:	e7 fb       	bst	r30, 7
     ecc:	0c 94 1d 09 	jmp	0x123a	; 0x123a <__fp_inf>

00000ed0 <__addsf3x>:
     ed0:	e9 2f       	mov	r30, r25
     ed2:	0e 94 6c 09 	call	0x12d8	; 0x12d8 <__fp_split3>
     ed6:	58 f3       	brcs	.-42     	; 0xeae <__addsf3+0xc>
     ed8:	ba 17       	cp	r27, r26
     eda:	62 07       	cpc	r22, r18
     edc:	73 07       	cpc	r23, r19
     ede:	84 07       	cpc	r24, r20
     ee0:	95 07       	cpc	r25, r21
     ee2:	20 f0       	brcs	.+8      	; 0xeec <__addsf3x+0x1c>
     ee4:	79 f4       	brne	.+30     	; 0xf04 <__addsf3x+0x34>
     ee6:	a6 f5       	brtc	.+104    	; 0xf50 <__addsf3x+0x80>
     ee8:	0c 94 8e 09 	jmp	0x131c	; 0x131c <__fp_zero>
     eec:	0e f4       	brtc	.+2      	; 0xef0 <__addsf3x+0x20>
     eee:	e0 95       	com	r30
     ef0:	0b 2e       	mov	r0, r27
     ef2:	ba 2f       	mov	r27, r26
     ef4:	a0 2d       	mov	r26, r0
     ef6:	0b 01       	movw	r0, r22
     ef8:	b9 01       	movw	r22, r18
     efa:	90 01       	movw	r18, r0
     efc:	0c 01       	movw	r0, r24
     efe:	ca 01       	movw	r24, r20
     f00:	a0 01       	movw	r20, r0
     f02:	11 24       	eor	r1, r1
     f04:	ff 27       	eor	r31, r31
     f06:	59 1b       	sub	r21, r25
     f08:	99 f0       	breq	.+38     	; 0xf30 <__addsf3x+0x60>
     f0a:	59 3f       	cpi	r21, 0xF9	; 249
     f0c:	50 f4       	brcc	.+20     	; 0xf22 <__addsf3x+0x52>
     f0e:	50 3e       	cpi	r21, 0xE0	; 224
     f10:	68 f1       	brcs	.+90     	; 0xf6c <__addsf3x+0x9c>
     f12:	1a 16       	cp	r1, r26
     f14:	f0 40       	sbci	r31, 0x00	; 0
     f16:	a2 2f       	mov	r26, r18
     f18:	23 2f       	mov	r18, r19
     f1a:	34 2f       	mov	r19, r20
     f1c:	44 27       	eor	r20, r20
     f1e:	58 5f       	subi	r21, 0xF8	; 248
     f20:	f3 cf       	rjmp	.-26     	; 0xf08 <__addsf3x+0x38>
     f22:	46 95       	lsr	r20
     f24:	37 95       	ror	r19
     f26:	27 95       	ror	r18
     f28:	a7 95       	ror	r26
     f2a:	f0 40       	sbci	r31, 0x00	; 0
     f2c:	53 95       	inc	r21
     f2e:	c9 f7       	brne	.-14     	; 0xf22 <__addsf3x+0x52>
     f30:	7e f4       	brtc	.+30     	; 0xf50 <__addsf3x+0x80>
     f32:	1f 16       	cp	r1, r31
     f34:	ba 0b       	sbc	r27, r26
     f36:	62 0b       	sbc	r22, r18
     f38:	73 0b       	sbc	r23, r19
     f3a:	84 0b       	sbc	r24, r20
     f3c:	ba f0       	brmi	.+46     	; 0xf6c <__addsf3x+0x9c>
     f3e:	91 50       	subi	r25, 0x01	; 1
     f40:	a1 f0       	breq	.+40     	; 0xf6a <__addsf3x+0x9a>
     f42:	ff 0f       	add	r31, r31
     f44:	bb 1f       	adc	r27, r27
     f46:	66 1f       	adc	r22, r22
     f48:	77 1f       	adc	r23, r23
     f4a:	88 1f       	adc	r24, r24
     f4c:	c2 f7       	brpl	.-16     	; 0xf3e <__addsf3x+0x6e>
     f4e:	0e c0       	rjmp	.+28     	; 0xf6c <__addsf3x+0x9c>
     f50:	ba 0f       	add	r27, r26
     f52:	62 1f       	adc	r22, r18
     f54:	73 1f       	adc	r23, r19
     f56:	84 1f       	adc	r24, r20
     f58:	48 f4       	brcc	.+18     	; 0xf6c <__addsf3x+0x9c>
     f5a:	87 95       	ror	r24
     f5c:	77 95       	ror	r23
     f5e:	67 95       	ror	r22
     f60:	b7 95       	ror	r27
     f62:	f7 95       	ror	r31
     f64:	9e 3f       	cpi	r25, 0xFE	; 254
     f66:	08 f0       	brcs	.+2      	; 0xf6a <__addsf3x+0x9a>
     f68:	b0 cf       	rjmp	.-160    	; 0xeca <__addsf3+0x28>
     f6a:	93 95       	inc	r25
     f6c:	88 0f       	add	r24, r24
     f6e:	08 f0       	brcs	.+2      	; 0xf72 <__addsf3x+0xa2>
     f70:	99 27       	eor	r25, r25
     f72:	ee 0f       	add	r30, r30
     f74:	97 95       	ror	r25
     f76:	87 95       	ror	r24
     f78:	08 95       	ret

00000f7a <__cmpsf2>:
     f7a:	0e 94 f9 08 	call	0x11f2	; 0x11f2 <__fp_cmp>
     f7e:	08 f4       	brcc	.+2      	; 0xf82 <__cmpsf2+0x8>
     f80:	81 e0       	ldi	r24, 0x01	; 1
     f82:	08 95       	ret

00000f84 <__divsf3>:
     f84:	0e 94 d6 07 	call	0xfac	; 0xfac <__divsf3x>
     f88:	0c 94 5b 09 	jmp	0x12b6	; 0x12b6 <__fp_round>
     f8c:	0e 94 54 09 	call	0x12a8	; 0x12a8 <__fp_pscB>
     f90:	58 f0       	brcs	.+22     	; 0xfa8 <__divsf3+0x24>
     f92:	0e 94 4d 09 	call	0x129a	; 0x129a <__fp_pscA>
     f96:	40 f0       	brcs	.+16     	; 0xfa8 <__divsf3+0x24>
     f98:	29 f4       	brne	.+10     	; 0xfa4 <__divsf3+0x20>
     f9a:	5f 3f       	cpi	r21, 0xFF	; 255
     f9c:	29 f0       	breq	.+10     	; 0xfa8 <__divsf3+0x24>
     f9e:	0c 94 1d 09 	jmp	0x123a	; 0x123a <__fp_inf>
     fa2:	51 11       	cpse	r21, r1
     fa4:	0c 94 8f 09 	jmp	0x131e	; 0x131e <__fp_szero>
     fa8:	0c 94 23 09 	jmp	0x1246	; 0x1246 <__fp_nan>

00000fac <__divsf3x>:
     fac:	0e 94 6c 09 	call	0x12d8	; 0x12d8 <__fp_split3>
     fb0:	68 f3       	brcs	.-38     	; 0xf8c <__divsf3+0x8>

00000fb2 <__divsf3_pse>:
     fb2:	99 23       	and	r25, r25
     fb4:	b1 f3       	breq	.-20     	; 0xfa2 <__divsf3+0x1e>
     fb6:	55 23       	and	r21, r21
     fb8:	91 f3       	breq	.-28     	; 0xf9e <__divsf3+0x1a>
     fba:	95 1b       	sub	r25, r21
     fbc:	55 0b       	sbc	r21, r21
     fbe:	bb 27       	eor	r27, r27
     fc0:	aa 27       	eor	r26, r26
     fc2:	62 17       	cp	r22, r18
     fc4:	73 07       	cpc	r23, r19
     fc6:	84 07       	cpc	r24, r20
     fc8:	38 f0       	brcs	.+14     	; 0xfd8 <__divsf3_pse+0x26>
     fca:	9f 5f       	subi	r25, 0xFF	; 255
     fcc:	5f 4f       	sbci	r21, 0xFF	; 255
     fce:	22 0f       	add	r18, r18
     fd0:	33 1f       	adc	r19, r19
     fd2:	44 1f       	adc	r20, r20
     fd4:	aa 1f       	adc	r26, r26
     fd6:	a9 f3       	breq	.-22     	; 0xfc2 <__divsf3_pse+0x10>
     fd8:	35 d0       	rcall	.+106    	; 0x1044 <__divsf3_pse+0x92>
     fda:	0e 2e       	mov	r0, r30
     fdc:	3a f0       	brmi	.+14     	; 0xfec <__divsf3_pse+0x3a>
     fde:	e0 e8       	ldi	r30, 0x80	; 128
     fe0:	32 d0       	rcall	.+100    	; 0x1046 <__divsf3_pse+0x94>
     fe2:	91 50       	subi	r25, 0x01	; 1
     fe4:	50 40       	sbci	r21, 0x00	; 0
     fe6:	e6 95       	lsr	r30
     fe8:	00 1c       	adc	r0, r0
     fea:	ca f7       	brpl	.-14     	; 0xfde <__divsf3_pse+0x2c>
     fec:	2b d0       	rcall	.+86     	; 0x1044 <__divsf3_pse+0x92>
     fee:	fe 2f       	mov	r31, r30
     ff0:	29 d0       	rcall	.+82     	; 0x1044 <__divsf3_pse+0x92>
     ff2:	66 0f       	add	r22, r22
     ff4:	77 1f       	adc	r23, r23
     ff6:	88 1f       	adc	r24, r24
     ff8:	bb 1f       	adc	r27, r27
     ffa:	26 17       	cp	r18, r22
     ffc:	37 07       	cpc	r19, r23
     ffe:	48 07       	cpc	r20, r24
    1000:	ab 07       	cpc	r26, r27
    1002:	b0 e8       	ldi	r27, 0x80	; 128
    1004:	09 f0       	breq	.+2      	; 0x1008 <__divsf3_pse+0x56>
    1006:	bb 0b       	sbc	r27, r27
    1008:	80 2d       	mov	r24, r0
    100a:	bf 01       	movw	r22, r30
    100c:	ff 27       	eor	r31, r31
    100e:	93 58       	subi	r25, 0x83	; 131
    1010:	5f 4f       	sbci	r21, 0xFF	; 255
    1012:	3a f0       	brmi	.+14     	; 0x1022 <__divsf3_pse+0x70>
    1014:	9e 3f       	cpi	r25, 0xFE	; 254
    1016:	51 05       	cpc	r21, r1
    1018:	78 f0       	brcs	.+30     	; 0x1038 <__divsf3_pse+0x86>
    101a:	0c 94 1d 09 	jmp	0x123a	; 0x123a <__fp_inf>
    101e:	0c 94 8f 09 	jmp	0x131e	; 0x131e <__fp_szero>
    1022:	5f 3f       	cpi	r21, 0xFF	; 255
    1024:	e4 f3       	brlt	.-8      	; 0x101e <__divsf3_pse+0x6c>
    1026:	98 3e       	cpi	r25, 0xE8	; 232
    1028:	d4 f3       	brlt	.-12     	; 0x101e <__divsf3_pse+0x6c>
    102a:	86 95       	lsr	r24
    102c:	77 95       	ror	r23
    102e:	67 95       	ror	r22
    1030:	b7 95       	ror	r27
    1032:	f7 95       	ror	r31
    1034:	9f 5f       	subi	r25, 0xFF	; 255
    1036:	c9 f7       	brne	.-14     	; 0x102a <__divsf3_pse+0x78>
    1038:	88 0f       	add	r24, r24
    103a:	91 1d       	adc	r25, r1
    103c:	96 95       	lsr	r25
    103e:	87 95       	ror	r24
    1040:	97 f9       	bld	r25, 7
    1042:	08 95       	ret
    1044:	e1 e0       	ldi	r30, 0x01	; 1
    1046:	66 0f       	add	r22, r22
    1048:	77 1f       	adc	r23, r23
    104a:	88 1f       	adc	r24, r24
    104c:	bb 1f       	adc	r27, r27
    104e:	62 17       	cp	r22, r18
    1050:	73 07       	cpc	r23, r19
    1052:	84 07       	cpc	r24, r20
    1054:	ba 07       	cpc	r27, r26
    1056:	20 f0       	brcs	.+8      	; 0x1060 <__divsf3_pse+0xae>
    1058:	62 1b       	sub	r22, r18
    105a:	73 0b       	sbc	r23, r19
    105c:	84 0b       	sbc	r24, r20
    105e:	ba 0b       	sbc	r27, r26
    1060:	ee 1f       	adc	r30, r30
    1062:	88 f7       	brcc	.-30     	; 0x1046 <__divsf3_pse+0x94>
    1064:	e0 95       	com	r30
    1066:	08 95       	ret
    1068:	29 f4       	brne	.+10     	; 0x1074 <__divsf3_pse+0xc2>
    106a:	16 f0       	brts	.+4      	; 0x1070 <__divsf3_pse+0xbe>
    106c:	0c 94 1d 09 	jmp	0x123a	; 0x123a <__fp_inf>
    1070:	0c 94 8e 09 	jmp	0x131c	; 0x131c <__fp_zero>
    1074:	0c 94 23 09 	jmp	0x1246	; 0x1246 <__fp_nan>

00001078 <exp>:
    1078:	0e 94 74 09 	call	0x12e8	; 0x12e8 <__fp_splitA>
    107c:	a8 f3       	brcs	.-22     	; 0x1068 <__divsf3_pse+0xb6>
    107e:	96 38       	cpi	r25, 0x86	; 134
    1080:	a0 f7       	brcc	.-24     	; 0x106a <__divsf3_pse+0xb8>
    1082:	07 f8       	bld	r0, 7
    1084:	0f 92       	push	r0
    1086:	e8 94       	clt
    1088:	2b e3       	ldi	r18, 0x3B	; 59
    108a:	3a ea       	ldi	r19, 0xAA	; 170
    108c:	48 eb       	ldi	r20, 0xB8	; 184
    108e:	5f e7       	ldi	r21, 0x7F	; 127
    1090:	0e 94 26 0a 	call	0x144c	; 0x144c <__mulsf3_pse>
    1094:	0f 92       	push	r0
    1096:	0f 92       	push	r0
    1098:	0f 92       	push	r0
    109a:	4d b7       	in	r20, 0x3d	; 61
    109c:	5e b7       	in	r21, 0x3e	; 62
    109e:	0f 92       	push	r0
    10a0:	0e 94 dc 09 	call	0x13b8	; 0x13b8 <modf>
    10a4:	e4 e3       	ldi	r30, 0x34	; 52
    10a6:	f0 e0       	ldi	r31, 0x00	; 0
    10a8:	0e 94 26 09 	call	0x124c	; 0x124c <__fp_powser>
    10ac:	4f 91       	pop	r20
    10ae:	5f 91       	pop	r21
    10b0:	ef 91       	pop	r30
    10b2:	ff 91       	pop	r31
    10b4:	e5 95       	asr	r30
    10b6:	ee 1f       	adc	r30, r30
    10b8:	ff 1f       	adc	r31, r31
    10ba:	49 f0       	breq	.+18     	; 0x10ce <exp+0x56>
    10bc:	fe 57       	subi	r31, 0x7E	; 126
    10be:	e0 68       	ori	r30, 0x80	; 128
    10c0:	44 27       	eor	r20, r20
    10c2:	ee 0f       	add	r30, r30
    10c4:	44 1f       	adc	r20, r20
    10c6:	fa 95       	dec	r31
    10c8:	e1 f7       	brne	.-8      	; 0x10c2 <exp+0x4a>
    10ca:	41 95       	neg	r20
    10cc:	55 0b       	sbc	r21, r21
    10ce:	0e 94 a6 09 	call	0x134c	; 0x134c <ldexp>
    10d2:	0f 90       	pop	r0
    10d4:	07 fe       	sbrs	r0, 7
    10d6:	0c 94 9a 09 	jmp	0x1334	; 0x1334 <inverse>
    10da:	08 95       	ret

000010dc <__fixunssfsi>:
    10dc:	0e 94 74 09 	call	0x12e8	; 0x12e8 <__fp_splitA>
    10e0:	88 f0       	brcs	.+34     	; 0x1104 <__fixunssfsi+0x28>
    10e2:	9f 57       	subi	r25, 0x7F	; 127
    10e4:	98 f0       	brcs	.+38     	; 0x110c <__fixunssfsi+0x30>
    10e6:	b9 2f       	mov	r27, r25
    10e8:	99 27       	eor	r25, r25
    10ea:	b7 51       	subi	r27, 0x17	; 23
    10ec:	b0 f0       	brcs	.+44     	; 0x111a <__fixunssfsi+0x3e>
    10ee:	e1 f0       	breq	.+56     	; 0x1128 <__fixunssfsi+0x4c>
    10f0:	66 0f       	add	r22, r22
    10f2:	77 1f       	adc	r23, r23
    10f4:	88 1f       	adc	r24, r24
    10f6:	99 1f       	adc	r25, r25
    10f8:	1a f0       	brmi	.+6      	; 0x1100 <__fixunssfsi+0x24>
    10fa:	ba 95       	dec	r27
    10fc:	c9 f7       	brne	.-14     	; 0x10f0 <__fixunssfsi+0x14>
    10fe:	14 c0       	rjmp	.+40     	; 0x1128 <__fixunssfsi+0x4c>
    1100:	b1 30       	cpi	r27, 0x01	; 1
    1102:	91 f0       	breq	.+36     	; 0x1128 <__fixunssfsi+0x4c>
    1104:	0e 94 8e 09 	call	0x131c	; 0x131c <__fp_zero>
    1108:	b1 e0       	ldi	r27, 0x01	; 1
    110a:	08 95       	ret
    110c:	0c 94 8e 09 	jmp	0x131c	; 0x131c <__fp_zero>
    1110:	67 2f       	mov	r22, r23
    1112:	78 2f       	mov	r23, r24
    1114:	88 27       	eor	r24, r24
    1116:	b8 5f       	subi	r27, 0xF8	; 248
    1118:	39 f0       	breq	.+14     	; 0x1128 <__fixunssfsi+0x4c>
    111a:	b9 3f       	cpi	r27, 0xF9	; 249
    111c:	cc f3       	brlt	.-14     	; 0x1110 <__fixunssfsi+0x34>
    111e:	86 95       	lsr	r24
    1120:	77 95       	ror	r23
    1122:	67 95       	ror	r22
    1124:	b3 95       	inc	r27
    1126:	d9 f7       	brne	.-10     	; 0x111e <__fixunssfsi+0x42>
    1128:	3e f4       	brtc	.+14     	; 0x1138 <__fixunssfsi+0x5c>
    112a:	90 95       	com	r25
    112c:	80 95       	com	r24
    112e:	70 95       	com	r23
    1130:	61 95       	neg	r22
    1132:	7f 4f       	sbci	r23, 0xFF	; 255
    1134:	8f 4f       	sbci	r24, 0xFF	; 255
    1136:	9f 4f       	sbci	r25, 0xFF	; 255
    1138:	08 95       	ret

0000113a <__floatunsisf>:
    113a:	e8 94       	clt
    113c:	09 c0       	rjmp	.+18     	; 0x1150 <__floatsisf+0x12>

0000113e <__floatsisf>:
    113e:	97 fb       	bst	r25, 7
    1140:	3e f4       	brtc	.+14     	; 0x1150 <__floatsisf+0x12>
    1142:	90 95       	com	r25
    1144:	80 95       	com	r24
    1146:	70 95       	com	r23
    1148:	61 95       	neg	r22
    114a:	7f 4f       	sbci	r23, 0xFF	; 255
    114c:	8f 4f       	sbci	r24, 0xFF	; 255
    114e:	9f 4f       	sbci	r25, 0xFF	; 255
    1150:	99 23       	and	r25, r25
    1152:	a9 f0       	breq	.+42     	; 0x117e <__floatsisf+0x40>
    1154:	f9 2f       	mov	r31, r25
    1156:	96 e9       	ldi	r25, 0x96	; 150
    1158:	bb 27       	eor	r27, r27
    115a:	93 95       	inc	r25
    115c:	f6 95       	lsr	r31
    115e:	87 95       	ror	r24
    1160:	77 95       	ror	r23
    1162:	67 95       	ror	r22
    1164:	b7 95       	ror	r27
    1166:	f1 11       	cpse	r31, r1
    1168:	f8 cf       	rjmp	.-16     	; 0x115a <__floatsisf+0x1c>
    116a:	fa f4       	brpl	.+62     	; 0x11aa <__floatsisf+0x6c>
    116c:	bb 0f       	add	r27, r27
    116e:	11 f4       	brne	.+4      	; 0x1174 <__floatsisf+0x36>
    1170:	60 ff       	sbrs	r22, 0
    1172:	1b c0       	rjmp	.+54     	; 0x11aa <__floatsisf+0x6c>
    1174:	6f 5f       	subi	r22, 0xFF	; 255
    1176:	7f 4f       	sbci	r23, 0xFF	; 255
    1178:	8f 4f       	sbci	r24, 0xFF	; 255
    117a:	9f 4f       	sbci	r25, 0xFF	; 255
    117c:	16 c0       	rjmp	.+44     	; 0x11aa <__floatsisf+0x6c>
    117e:	88 23       	and	r24, r24
    1180:	11 f0       	breq	.+4      	; 0x1186 <__floatsisf+0x48>
    1182:	96 e9       	ldi	r25, 0x96	; 150
    1184:	11 c0       	rjmp	.+34     	; 0x11a8 <__floatsisf+0x6a>
    1186:	77 23       	and	r23, r23
    1188:	21 f0       	breq	.+8      	; 0x1192 <__floatsisf+0x54>
    118a:	9e e8       	ldi	r25, 0x8E	; 142
    118c:	87 2f       	mov	r24, r23
    118e:	76 2f       	mov	r23, r22
    1190:	05 c0       	rjmp	.+10     	; 0x119c <__floatsisf+0x5e>
    1192:	66 23       	and	r22, r22
    1194:	71 f0       	breq	.+28     	; 0x11b2 <__floatsisf+0x74>
    1196:	96 e8       	ldi	r25, 0x86	; 134
    1198:	86 2f       	mov	r24, r22
    119a:	70 e0       	ldi	r23, 0x00	; 0
    119c:	60 e0       	ldi	r22, 0x00	; 0
    119e:	2a f0       	brmi	.+10     	; 0x11aa <__floatsisf+0x6c>
    11a0:	9a 95       	dec	r25
    11a2:	66 0f       	add	r22, r22
    11a4:	77 1f       	adc	r23, r23
    11a6:	88 1f       	adc	r24, r24
    11a8:	da f7       	brpl	.-10     	; 0x11a0 <__floatsisf+0x62>
    11aa:	88 0f       	add	r24, r24
    11ac:	96 95       	lsr	r25
    11ae:	87 95       	ror	r24
    11b0:	97 f9       	bld	r25, 7
    11b2:	08 95       	ret

000011b4 <fmin>:
    11b4:	99 0f       	add	r25, r25
    11b6:	bb 0b       	sbc	r27, r27
    11b8:	55 0f       	add	r21, r21
    11ba:	aa 0b       	sbc	r26, r26
    11bc:	e0 e8       	ldi	r30, 0x80	; 128
    11be:	fe ef       	ldi	r31, 0xFE	; 254
    11c0:	16 16       	cp	r1, r22
    11c2:	17 06       	cpc	r1, r23
    11c4:	e8 07       	cpc	r30, r24
    11c6:	f9 07       	cpc	r31, r25
    11c8:	70 f0       	brcs	.+28     	; 0x11e6 <fmin+0x32>
    11ca:	12 16       	cp	r1, r18
    11cc:	13 06       	cpc	r1, r19
    11ce:	e4 07       	cpc	r30, r20
    11d0:	f5 07       	cpc	r31, r21
    11d2:	60 f0       	brcs	.+24     	; 0x11ec <fmin+0x38>
    11d4:	ba 17       	cp	r27, r26
    11d6:	54 f0       	brlt	.+20     	; 0x11ec <fmin+0x38>
    11d8:	31 f4       	brne	.+12     	; 0x11e6 <fmin+0x32>
    11da:	26 17       	cp	r18, r22
    11dc:	37 07       	cpc	r19, r23
    11de:	48 07       	cpc	r20, r24
    11e0:	59 07       	cpc	r21, r25
    11e2:	a7 95       	ror	r26
    11e4:	1b f4       	brvc	.+6      	; 0x11ec <fmin+0x38>
    11e6:	b9 01       	movw	r22, r18
    11e8:	ca 01       	movw	r24, r20
    11ea:	ba 2f       	mov	r27, r26
    11ec:	b6 95       	lsr	r27
    11ee:	97 95       	ror	r25
    11f0:	08 95       	ret

000011f2 <__fp_cmp>:
    11f2:	99 0f       	add	r25, r25
    11f4:	00 08       	sbc	r0, r0
    11f6:	55 0f       	add	r21, r21
    11f8:	aa 0b       	sbc	r26, r26
    11fa:	e0 e8       	ldi	r30, 0x80	; 128
    11fc:	fe ef       	ldi	r31, 0xFE	; 254
    11fe:	16 16       	cp	r1, r22
    1200:	17 06       	cpc	r1, r23
    1202:	e8 07       	cpc	r30, r24
    1204:	f9 07       	cpc	r31, r25
    1206:	c0 f0       	brcs	.+48     	; 0x1238 <__fp_cmp+0x46>
    1208:	12 16       	cp	r1, r18
    120a:	13 06       	cpc	r1, r19
    120c:	e4 07       	cpc	r30, r20
    120e:	f5 07       	cpc	r31, r21
    1210:	98 f0       	brcs	.+38     	; 0x1238 <__fp_cmp+0x46>
    1212:	62 1b       	sub	r22, r18
    1214:	73 0b       	sbc	r23, r19
    1216:	84 0b       	sbc	r24, r20
    1218:	95 0b       	sbc	r25, r21
    121a:	39 f4       	brne	.+14     	; 0x122a <__fp_cmp+0x38>
    121c:	0a 26       	eor	r0, r26
    121e:	61 f0       	breq	.+24     	; 0x1238 <__fp_cmp+0x46>
    1220:	23 2b       	or	r18, r19
    1222:	24 2b       	or	r18, r20
    1224:	25 2b       	or	r18, r21
    1226:	21 f4       	brne	.+8      	; 0x1230 <__fp_cmp+0x3e>
    1228:	08 95       	ret
    122a:	0a 26       	eor	r0, r26
    122c:	09 f4       	brne	.+2      	; 0x1230 <__fp_cmp+0x3e>
    122e:	a1 40       	sbci	r26, 0x01	; 1
    1230:	a6 95       	lsr	r26
    1232:	8f ef       	ldi	r24, 0xFF	; 255
    1234:	81 1d       	adc	r24, r1
    1236:	81 1d       	adc	r24, r1
    1238:	08 95       	ret

0000123a <__fp_inf>:
    123a:	97 f9       	bld	r25, 7
    123c:	9f 67       	ori	r25, 0x7F	; 127
    123e:	80 e8       	ldi	r24, 0x80	; 128
    1240:	70 e0       	ldi	r23, 0x00	; 0
    1242:	60 e0       	ldi	r22, 0x00	; 0
    1244:	08 95       	ret

00001246 <__fp_nan>:
    1246:	9f ef       	ldi	r25, 0xFF	; 255
    1248:	80 ec       	ldi	r24, 0xC0	; 192
    124a:	08 95       	ret

0000124c <__fp_powser>:
    124c:	df 93       	push	r29
    124e:	cf 93       	push	r28
    1250:	1f 93       	push	r17
    1252:	0f 93       	push	r16
    1254:	ff 92       	push	r15
    1256:	ef 92       	push	r14
    1258:	df 92       	push	r13
    125a:	7b 01       	movw	r14, r22
    125c:	8c 01       	movw	r16, r24
    125e:	68 94       	set
    1260:	06 c0       	rjmp	.+12     	; 0x126e <__fp_powser+0x22>
    1262:	da 2e       	mov	r13, r26
    1264:	ef 01       	movw	r28, r30
    1266:	0e 94 23 0a 	call	0x1446	; 0x1446 <__mulsf3x>
    126a:	fe 01       	movw	r30, r28
    126c:	e8 94       	clt
    126e:	a5 91       	lpm	r26, Z+
    1270:	25 91       	lpm	r18, Z+
    1272:	35 91       	lpm	r19, Z+
    1274:	45 91       	lpm	r20, Z+
    1276:	55 91       	lpm	r21, Z+
    1278:	a6 f3       	brts	.-24     	; 0x1262 <__fp_powser+0x16>
    127a:	ef 01       	movw	r28, r30
    127c:	0e 94 68 07 	call	0xed0	; 0xed0 <__addsf3x>
    1280:	fe 01       	movw	r30, r28
    1282:	97 01       	movw	r18, r14
    1284:	a8 01       	movw	r20, r16
    1286:	da 94       	dec	r13
    1288:	69 f7       	brne	.-38     	; 0x1264 <__fp_powser+0x18>
    128a:	df 90       	pop	r13
    128c:	ef 90       	pop	r14
    128e:	ff 90       	pop	r15
    1290:	0f 91       	pop	r16
    1292:	1f 91       	pop	r17
    1294:	cf 91       	pop	r28
    1296:	df 91       	pop	r29
    1298:	08 95       	ret

0000129a <__fp_pscA>:
    129a:	00 24       	eor	r0, r0
    129c:	0a 94       	dec	r0
    129e:	16 16       	cp	r1, r22
    12a0:	17 06       	cpc	r1, r23
    12a2:	18 06       	cpc	r1, r24
    12a4:	09 06       	cpc	r0, r25
    12a6:	08 95       	ret

000012a8 <__fp_pscB>:
    12a8:	00 24       	eor	r0, r0
    12aa:	0a 94       	dec	r0
    12ac:	12 16       	cp	r1, r18
    12ae:	13 06       	cpc	r1, r19
    12b0:	14 06       	cpc	r1, r20
    12b2:	05 06       	cpc	r0, r21
    12b4:	08 95       	ret

000012b6 <__fp_round>:
    12b6:	09 2e       	mov	r0, r25
    12b8:	03 94       	inc	r0
    12ba:	00 0c       	add	r0, r0
    12bc:	11 f4       	brne	.+4      	; 0x12c2 <__fp_round+0xc>
    12be:	88 23       	and	r24, r24
    12c0:	52 f0       	brmi	.+20     	; 0x12d6 <__fp_round+0x20>
    12c2:	bb 0f       	add	r27, r27
    12c4:	40 f4       	brcc	.+16     	; 0x12d6 <__fp_round+0x20>
    12c6:	bf 2b       	or	r27, r31
    12c8:	11 f4       	brne	.+4      	; 0x12ce <__fp_round+0x18>
    12ca:	60 ff       	sbrs	r22, 0
    12cc:	04 c0       	rjmp	.+8      	; 0x12d6 <__fp_round+0x20>
    12ce:	6f 5f       	subi	r22, 0xFF	; 255
    12d0:	7f 4f       	sbci	r23, 0xFF	; 255
    12d2:	8f 4f       	sbci	r24, 0xFF	; 255
    12d4:	9f 4f       	sbci	r25, 0xFF	; 255
    12d6:	08 95       	ret

000012d8 <__fp_split3>:
    12d8:	57 fd       	sbrc	r21, 7
    12da:	90 58       	subi	r25, 0x80	; 128
    12dc:	44 0f       	add	r20, r20
    12de:	55 1f       	adc	r21, r21
    12e0:	59 f0       	breq	.+22     	; 0x12f8 <__fp_splitA+0x10>
    12e2:	5f 3f       	cpi	r21, 0xFF	; 255
    12e4:	71 f0       	breq	.+28     	; 0x1302 <__fp_splitA+0x1a>
    12e6:	47 95       	ror	r20

000012e8 <__fp_splitA>:
    12e8:	88 0f       	add	r24, r24
    12ea:	97 fb       	bst	r25, 7
    12ec:	99 1f       	adc	r25, r25
    12ee:	61 f0       	breq	.+24     	; 0x1308 <__fp_splitA+0x20>
    12f0:	9f 3f       	cpi	r25, 0xFF	; 255
    12f2:	79 f0       	breq	.+30     	; 0x1312 <__fp_splitA+0x2a>
    12f4:	87 95       	ror	r24
    12f6:	08 95       	ret
    12f8:	12 16       	cp	r1, r18
    12fa:	13 06       	cpc	r1, r19
    12fc:	14 06       	cpc	r1, r20
    12fe:	55 1f       	adc	r21, r21
    1300:	f2 cf       	rjmp	.-28     	; 0x12e6 <__fp_split3+0xe>
    1302:	46 95       	lsr	r20
    1304:	f1 df       	rcall	.-30     	; 0x12e8 <__fp_splitA>
    1306:	08 c0       	rjmp	.+16     	; 0x1318 <__fp_splitA+0x30>
    1308:	16 16       	cp	r1, r22
    130a:	17 06       	cpc	r1, r23
    130c:	18 06       	cpc	r1, r24
    130e:	99 1f       	adc	r25, r25
    1310:	f1 cf       	rjmp	.-30     	; 0x12f4 <__fp_splitA+0xc>
    1312:	86 95       	lsr	r24
    1314:	71 05       	cpc	r23, r1
    1316:	61 05       	cpc	r22, r1
    1318:	08 94       	sec
    131a:	08 95       	ret

0000131c <__fp_zero>:
    131c:	e8 94       	clt

0000131e <__fp_szero>:
    131e:	bb 27       	eor	r27, r27
    1320:	66 27       	eor	r22, r22
    1322:	77 27       	eor	r23, r23
    1324:	cb 01       	movw	r24, r22
    1326:	97 f9       	bld	r25, 7
    1328:	08 95       	ret

0000132a <__gesf2>:
    132a:	0e 94 f9 08 	call	0x11f2	; 0x11f2 <__fp_cmp>
    132e:	08 f4       	brcc	.+2      	; 0x1332 <__gesf2+0x8>
    1330:	8f ef       	ldi	r24, 0xFF	; 255
    1332:	08 95       	ret

00001334 <inverse>:
    1334:	9b 01       	movw	r18, r22
    1336:	ac 01       	movw	r20, r24
    1338:	60 e0       	ldi	r22, 0x00	; 0
    133a:	70 e0       	ldi	r23, 0x00	; 0
    133c:	80 e8       	ldi	r24, 0x80	; 128
    133e:	9f e3       	ldi	r25, 0x3F	; 63
    1340:	0c 94 c2 07 	jmp	0xf84	; 0xf84 <__divsf3>
    1344:	0c 94 1d 09 	jmp	0x123a	; 0x123a <__fp_inf>
    1348:	0c 94 85 0a 	jmp	0x150a	; 0x150a <__fp_mpack>

0000134c <ldexp>:
    134c:	0e 94 74 09 	call	0x12e8	; 0x12e8 <__fp_splitA>
    1350:	d8 f3       	brcs	.-10     	; 0x1348 <inverse+0x14>
    1352:	99 23       	and	r25, r25
    1354:	c9 f3       	breq	.-14     	; 0x1348 <inverse+0x14>
    1356:	94 0f       	add	r25, r20
    1358:	51 1d       	adc	r21, r1
    135a:	a3 f3       	brvs	.-24     	; 0x1344 <inverse+0x10>
    135c:	91 50       	subi	r25, 0x01	; 1
    135e:	50 40       	sbci	r21, 0x00	; 0
    1360:	94 f0       	brlt	.+36     	; 0x1386 <ldexp+0x3a>
    1362:	59 f0       	breq	.+22     	; 0x137a <ldexp+0x2e>
    1364:	88 23       	and	r24, r24
    1366:	32 f0       	brmi	.+12     	; 0x1374 <ldexp+0x28>
    1368:	66 0f       	add	r22, r22
    136a:	77 1f       	adc	r23, r23
    136c:	88 1f       	adc	r24, r24
    136e:	91 50       	subi	r25, 0x01	; 1
    1370:	50 40       	sbci	r21, 0x00	; 0
    1372:	c1 f7       	brne	.-16     	; 0x1364 <ldexp+0x18>
    1374:	9e 3f       	cpi	r25, 0xFE	; 254
    1376:	51 05       	cpc	r21, r1
    1378:	2c f7       	brge	.-54     	; 0x1344 <inverse+0x10>
    137a:	88 0f       	add	r24, r24
    137c:	91 1d       	adc	r25, r1
    137e:	96 95       	lsr	r25
    1380:	87 95       	ror	r24
    1382:	97 f9       	bld	r25, 7
    1384:	08 95       	ret
    1386:	5f 3f       	cpi	r21, 0xFF	; 255
    1388:	ac f0       	brlt	.+42     	; 0x13b4 <ldexp+0x68>
    138a:	98 3e       	cpi	r25, 0xE8	; 232
    138c:	9c f0       	brlt	.+38     	; 0x13b4 <ldexp+0x68>
    138e:	bb 27       	eor	r27, r27
    1390:	86 95       	lsr	r24
    1392:	77 95       	ror	r23
    1394:	67 95       	ror	r22
    1396:	b7 95       	ror	r27
    1398:	08 f4       	brcc	.+2      	; 0x139c <ldexp+0x50>
    139a:	b1 60       	ori	r27, 0x01	; 1
    139c:	93 95       	inc	r25
    139e:	c1 f7       	brne	.-16     	; 0x1390 <ldexp+0x44>
    13a0:	bb 0f       	add	r27, r27
    13a2:	58 f7       	brcc	.-42     	; 0x137a <ldexp+0x2e>
    13a4:	11 f4       	brne	.+4      	; 0x13aa <ldexp+0x5e>
    13a6:	60 ff       	sbrs	r22, 0
    13a8:	e8 cf       	rjmp	.-48     	; 0x137a <ldexp+0x2e>
    13aa:	6f 5f       	subi	r22, 0xFF	; 255
    13ac:	7f 4f       	sbci	r23, 0xFF	; 255
    13ae:	8f 4f       	sbci	r24, 0xFF	; 255
    13b0:	9f 4f       	sbci	r25, 0xFF	; 255
    13b2:	e3 cf       	rjmp	.-58     	; 0x137a <ldexp+0x2e>
    13b4:	0c 94 8f 09 	jmp	0x131e	; 0x131e <__fp_szero>

000013b8 <modf>:
    13b8:	fa 01       	movw	r30, r20
    13ba:	dc 01       	movw	r26, r24
    13bc:	aa 0f       	add	r26, r26
    13be:	bb 1f       	adc	r27, r27
    13c0:	9b 01       	movw	r18, r22
    13c2:	ac 01       	movw	r20, r24
    13c4:	bf 57       	subi	r27, 0x7F	; 127
    13c6:	28 f4       	brcc	.+10     	; 0x13d2 <modf+0x1a>
    13c8:	22 27       	eor	r18, r18
    13ca:	33 27       	eor	r19, r19
    13cc:	44 27       	eor	r20, r20
    13ce:	50 78       	andi	r21, 0x80	; 128
    13d0:	20 c0       	rjmp	.+64     	; 0x1412 <modf+0x5a>
    13d2:	b7 51       	subi	r27, 0x17	; 23
    13d4:	90 f4       	brcc	.+36     	; 0x13fa <modf+0x42>
    13d6:	ab 2f       	mov	r26, r27
    13d8:	00 24       	eor	r0, r0
    13da:	46 95       	lsr	r20
    13dc:	37 95       	ror	r19
    13de:	27 95       	ror	r18
    13e0:	01 1c       	adc	r0, r1
    13e2:	a3 95       	inc	r26
    13e4:	d2 f3       	brmi	.-12     	; 0x13da <modf+0x22>
    13e6:	00 20       	and	r0, r0
    13e8:	71 f0       	breq	.+28     	; 0x1406 <modf+0x4e>
    13ea:	22 0f       	add	r18, r18
    13ec:	33 1f       	adc	r19, r19
    13ee:	44 1f       	adc	r20, r20
    13f0:	b3 95       	inc	r27
    13f2:	da f3       	brmi	.-10     	; 0x13ea <modf+0x32>
    13f4:	0e d0       	rcall	.+28     	; 0x1412 <modf+0x5a>
    13f6:	0c 94 50 07 	jmp	0xea0	; 0xea0 <__subsf3>
    13fa:	61 30       	cpi	r22, 0x01	; 1
    13fc:	71 05       	cpc	r23, r1
    13fe:	a0 e8       	ldi	r26, 0x80	; 128
    1400:	8a 07       	cpc	r24, r26
    1402:	b9 46       	sbci	r27, 0x69	; 105
    1404:	30 f4       	brcc	.+12     	; 0x1412 <modf+0x5a>
    1406:	9b 01       	movw	r18, r22
    1408:	ac 01       	movw	r20, r24
    140a:	66 27       	eor	r22, r22
    140c:	77 27       	eor	r23, r23
    140e:	88 27       	eor	r24, r24
    1410:	90 78       	andi	r25, 0x80	; 128
    1412:	30 96       	adiw	r30, 0x00	; 0
    1414:	21 f0       	breq	.+8      	; 0x141e <modf+0x66>
    1416:	20 83       	st	Z, r18
    1418:	31 83       	std	Z+1, r19	; 0x01
    141a:	42 83       	std	Z+2, r20	; 0x02
    141c:	53 83       	std	Z+3, r21	; 0x03
    141e:	08 95       	ret

00001420 <__mulsf3>:
    1420:	0e 94 23 0a 	call	0x1446	; 0x1446 <__mulsf3x>
    1424:	0c 94 5b 09 	jmp	0x12b6	; 0x12b6 <__fp_round>
    1428:	0e 94 4d 09 	call	0x129a	; 0x129a <__fp_pscA>
    142c:	38 f0       	brcs	.+14     	; 0x143c <__mulsf3+0x1c>
    142e:	0e 94 54 09 	call	0x12a8	; 0x12a8 <__fp_pscB>
    1432:	20 f0       	brcs	.+8      	; 0x143c <__mulsf3+0x1c>
    1434:	95 23       	and	r25, r21
    1436:	11 f0       	breq	.+4      	; 0x143c <__mulsf3+0x1c>
    1438:	0c 94 1d 09 	jmp	0x123a	; 0x123a <__fp_inf>
    143c:	0c 94 23 09 	jmp	0x1246	; 0x1246 <__fp_nan>
    1440:	11 24       	eor	r1, r1
    1442:	0c 94 8f 09 	jmp	0x131e	; 0x131e <__fp_szero>

00001446 <__mulsf3x>:
    1446:	0e 94 6c 09 	call	0x12d8	; 0x12d8 <__fp_split3>
    144a:	70 f3       	brcs	.-36     	; 0x1428 <__mulsf3+0x8>

0000144c <__mulsf3_pse>:
    144c:	95 9f       	mul	r25, r21
    144e:	c1 f3       	breq	.-16     	; 0x1440 <__mulsf3+0x20>
    1450:	95 0f       	add	r25, r21
    1452:	50 e0       	ldi	r21, 0x00	; 0
    1454:	55 1f       	adc	r21, r21
    1456:	62 9f       	mul	r22, r18
    1458:	f0 01       	movw	r30, r0
    145a:	72 9f       	mul	r23, r18
    145c:	bb 27       	eor	r27, r27
    145e:	f0 0d       	add	r31, r0
    1460:	b1 1d       	adc	r27, r1
    1462:	63 9f       	mul	r22, r19
    1464:	aa 27       	eor	r26, r26
    1466:	f0 0d       	add	r31, r0
    1468:	b1 1d       	adc	r27, r1
    146a:	aa 1f       	adc	r26, r26
    146c:	64 9f       	mul	r22, r20
    146e:	66 27       	eor	r22, r22
    1470:	b0 0d       	add	r27, r0
    1472:	a1 1d       	adc	r26, r1
    1474:	66 1f       	adc	r22, r22
    1476:	82 9f       	mul	r24, r18
    1478:	22 27       	eor	r18, r18
    147a:	b0 0d       	add	r27, r0
    147c:	a1 1d       	adc	r26, r1
    147e:	62 1f       	adc	r22, r18
    1480:	73 9f       	mul	r23, r19
    1482:	b0 0d       	add	r27, r0
    1484:	a1 1d       	adc	r26, r1
    1486:	62 1f       	adc	r22, r18
    1488:	83 9f       	mul	r24, r19
    148a:	a0 0d       	add	r26, r0
    148c:	61 1d       	adc	r22, r1
    148e:	22 1f       	adc	r18, r18
    1490:	74 9f       	mul	r23, r20
    1492:	33 27       	eor	r19, r19
    1494:	a0 0d       	add	r26, r0
    1496:	61 1d       	adc	r22, r1
    1498:	23 1f       	adc	r18, r19
    149a:	84 9f       	mul	r24, r20
    149c:	60 0d       	add	r22, r0
    149e:	21 1d       	adc	r18, r1
    14a0:	82 2f       	mov	r24, r18
    14a2:	76 2f       	mov	r23, r22
    14a4:	6a 2f       	mov	r22, r26
    14a6:	11 24       	eor	r1, r1
    14a8:	9f 57       	subi	r25, 0x7F	; 127
    14aa:	50 40       	sbci	r21, 0x00	; 0
    14ac:	9a f0       	brmi	.+38     	; 0x14d4 <__mulsf3_pse+0x88>
    14ae:	f1 f0       	breq	.+60     	; 0x14ec <__mulsf3_pse+0xa0>
    14b0:	88 23       	and	r24, r24
    14b2:	4a f0       	brmi	.+18     	; 0x14c6 <__mulsf3_pse+0x7a>
    14b4:	ee 0f       	add	r30, r30
    14b6:	ff 1f       	adc	r31, r31
    14b8:	bb 1f       	adc	r27, r27
    14ba:	66 1f       	adc	r22, r22
    14bc:	77 1f       	adc	r23, r23
    14be:	88 1f       	adc	r24, r24
    14c0:	91 50       	subi	r25, 0x01	; 1
    14c2:	50 40       	sbci	r21, 0x00	; 0
    14c4:	a9 f7       	brne	.-22     	; 0x14b0 <__mulsf3_pse+0x64>
    14c6:	9e 3f       	cpi	r25, 0xFE	; 254
    14c8:	51 05       	cpc	r21, r1
    14ca:	80 f0       	brcs	.+32     	; 0x14ec <__mulsf3_pse+0xa0>
    14cc:	0c 94 1d 09 	jmp	0x123a	; 0x123a <__fp_inf>
    14d0:	0c 94 8f 09 	jmp	0x131e	; 0x131e <__fp_szero>
    14d4:	5f 3f       	cpi	r21, 0xFF	; 255
    14d6:	e4 f3       	brlt	.-8      	; 0x14d0 <__mulsf3_pse+0x84>
    14d8:	98 3e       	cpi	r25, 0xE8	; 232
    14da:	d4 f3       	brlt	.-12     	; 0x14d0 <__mulsf3_pse+0x84>
    14dc:	86 95       	lsr	r24
    14de:	77 95       	ror	r23
    14e0:	67 95       	ror	r22
    14e2:	b7 95       	ror	r27
    14e4:	f7 95       	ror	r31
    14e6:	e7 95       	ror	r30
    14e8:	9f 5f       	subi	r25, 0xFF	; 255
    14ea:	c1 f7       	brne	.-16     	; 0x14dc <__mulsf3_pse+0x90>
    14ec:	fe 2b       	or	r31, r30
    14ee:	88 0f       	add	r24, r24
    14f0:	91 1d       	adc	r25, r1
    14f2:	96 95       	lsr	r25
    14f4:	87 95       	ror	r24
    14f6:	97 f9       	bld	r25, 7
    14f8:	08 95       	ret

000014fa <sin>:
    14fa:	9f 93       	push	r25
    14fc:	0e 94 95 0a 	call	0x152a	; 0x152a <__fp_rempio2>
    1500:	0f 90       	pop	r0
    1502:	07 fc       	sbrc	r0, 7
    1504:	ee 5f       	subi	r30, 0xFE	; 254
    1506:	0c 94 be 0a 	jmp	0x157c	; 0x157c <__fp_sinus>

0000150a <__fp_mpack>:
    150a:	9f 3f       	cpi	r25, 0xFF	; 255
    150c:	31 f0       	breq	.+12     	; 0x151a <__fp_mpack_finite+0xc>

0000150e <__fp_mpack_finite>:
    150e:	91 50       	subi	r25, 0x01	; 1
    1510:	20 f4       	brcc	.+8      	; 0x151a <__fp_mpack_finite+0xc>
    1512:	87 95       	ror	r24
    1514:	77 95       	ror	r23
    1516:	67 95       	ror	r22
    1518:	b7 95       	ror	r27
    151a:	88 0f       	add	r24, r24
    151c:	91 1d       	adc	r25, r1
    151e:	96 95       	lsr	r25
    1520:	87 95       	ror	r24
    1522:	97 f9       	bld	r25, 7
    1524:	08 95       	ret
    1526:	0c 94 23 09 	jmp	0x1246	; 0x1246 <__fp_nan>

0000152a <__fp_rempio2>:
    152a:	0e 94 74 09 	call	0x12e8	; 0x12e8 <__fp_splitA>
    152e:	d8 f3       	brcs	.-10     	; 0x1526 <__fp_mpack_finite+0x18>
    1530:	e8 94       	clt
    1532:	e0 e0       	ldi	r30, 0x00	; 0
    1534:	bb 27       	eor	r27, r27
    1536:	9f 57       	subi	r25, 0x7F	; 127
    1538:	f0 f0       	brcs	.+60     	; 0x1576 <__fp_rempio2+0x4c>
    153a:	2a ed       	ldi	r18, 0xDA	; 218
    153c:	3f e0       	ldi	r19, 0x0F	; 15
    153e:	49 ec       	ldi	r20, 0xC9	; 201
    1540:	06 c0       	rjmp	.+12     	; 0x154e <__fp_rempio2+0x24>
    1542:	ee 0f       	add	r30, r30
    1544:	bb 0f       	add	r27, r27
    1546:	66 1f       	adc	r22, r22
    1548:	77 1f       	adc	r23, r23
    154a:	88 1f       	adc	r24, r24
    154c:	28 f0       	brcs	.+10     	; 0x1558 <__fp_rempio2+0x2e>
    154e:	b2 3a       	cpi	r27, 0xA2	; 162
    1550:	62 07       	cpc	r22, r18
    1552:	73 07       	cpc	r23, r19
    1554:	84 07       	cpc	r24, r20
    1556:	28 f0       	brcs	.+10     	; 0x1562 <__fp_rempio2+0x38>
    1558:	b2 5a       	subi	r27, 0xA2	; 162
    155a:	62 0b       	sbc	r22, r18
    155c:	73 0b       	sbc	r23, r19
    155e:	84 0b       	sbc	r24, r20
    1560:	e3 95       	inc	r30
    1562:	9a 95       	dec	r25
    1564:	72 f7       	brpl	.-36     	; 0x1542 <__fp_rempio2+0x18>
    1566:	80 38       	cpi	r24, 0x80	; 128
    1568:	30 f4       	brcc	.+12     	; 0x1576 <__fp_rempio2+0x4c>
    156a:	9a 95       	dec	r25
    156c:	bb 0f       	add	r27, r27
    156e:	66 1f       	adc	r22, r22
    1570:	77 1f       	adc	r23, r23
    1572:	88 1f       	adc	r24, r24
    1574:	d2 f7       	brpl	.-12     	; 0x156a <__fp_rempio2+0x40>
    1576:	90 48       	sbci	r25, 0x80	; 128
    1578:	0c 94 87 0a 	jmp	0x150e	; 0x150e <__fp_mpack_finite>

0000157c <__fp_sinus>:
    157c:	ef 93       	push	r30
    157e:	e0 ff       	sbrs	r30, 0
    1580:	07 c0       	rjmp	.+14     	; 0x1590 <__fp_sinus+0x14>
    1582:	a2 ea       	ldi	r26, 0xA2	; 162
    1584:	2a ed       	ldi	r18, 0xDA	; 218
    1586:	3f e0       	ldi	r19, 0x0F	; 15
    1588:	49 ec       	ldi	r20, 0xC9	; 201
    158a:	5f eb       	ldi	r21, 0xBF	; 191
    158c:	0e 94 68 07 	call	0xed0	; 0xed0 <__addsf3x>
    1590:	0e 94 5b 09 	call	0x12b6	; 0x12b6 <__fp_round>
    1594:	0f 90       	pop	r0
    1596:	03 94       	inc	r0
    1598:	01 fc       	sbrc	r0, 1
    159a:	90 58       	subi	r25, 0x80	; 128
    159c:	ec e5       	ldi	r30, 0x5C	; 92
    159e:	f0 e0       	ldi	r31, 0x00	; 0
    15a0:	0c 94 d2 0a 	jmp	0x15a4	; 0x15a4 <__fp_powsodd>

000015a4 <__fp_powsodd>:
    15a4:	9f 93       	push	r25
    15a6:	8f 93       	push	r24
    15a8:	7f 93       	push	r23
    15aa:	6f 93       	push	r22
    15ac:	ff 93       	push	r31
    15ae:	ef 93       	push	r30
    15b0:	9b 01       	movw	r18, r22
    15b2:	ac 01       	movw	r20, r24
    15b4:	0e 94 10 0a 	call	0x1420	; 0x1420 <__mulsf3>
    15b8:	ef 91       	pop	r30
    15ba:	ff 91       	pop	r31
    15bc:	0e 94 26 09 	call	0x124c	; 0x124c <__fp_powser>
    15c0:	2f 91       	pop	r18
    15c2:	3f 91       	pop	r19
    15c4:	4f 91       	pop	r20
    15c6:	5f 91       	pop	r21
    15c8:	0c 94 10 0a 	jmp	0x1420	; 0x1420 <__mulsf3>

000015cc <__udivmodsi4>:
    15cc:	a1 e2       	ldi	r26, 0x21	; 33
    15ce:	1a 2e       	mov	r1, r26
    15d0:	aa 1b       	sub	r26, r26
    15d2:	bb 1b       	sub	r27, r27
    15d4:	fd 01       	movw	r30, r26
    15d6:	0d c0       	rjmp	.+26     	; 0x15f2 <__udivmodsi4_ep>

000015d8 <__udivmodsi4_loop>:
    15d8:	aa 1f       	adc	r26, r26
    15da:	bb 1f       	adc	r27, r27
    15dc:	ee 1f       	adc	r30, r30
    15de:	ff 1f       	adc	r31, r31
    15e0:	a2 17       	cp	r26, r18
    15e2:	b3 07       	cpc	r27, r19
    15e4:	e4 07       	cpc	r30, r20
    15e6:	f5 07       	cpc	r31, r21
    15e8:	20 f0       	brcs	.+8      	; 0x15f2 <__udivmodsi4_ep>
    15ea:	a2 1b       	sub	r26, r18
    15ec:	b3 0b       	sbc	r27, r19
    15ee:	e4 0b       	sbc	r30, r20
    15f0:	f5 0b       	sbc	r31, r21

000015f2 <__udivmodsi4_ep>:
    15f2:	66 1f       	adc	r22, r22
    15f4:	77 1f       	adc	r23, r23
    15f6:	88 1f       	adc	r24, r24
    15f8:	99 1f       	adc	r25, r25
    15fa:	1a 94       	dec	r1
    15fc:	69 f7       	brne	.-38     	; 0x15d8 <__udivmodsi4_loop>
    15fe:	60 95       	com	r22
    1600:	70 95       	com	r23
    1602:	80 95       	com	r24
    1604:	90 95       	com	r25
    1606:	9b 01       	movw	r18, r22
    1608:	ac 01       	movw	r20, r24
    160a:	bd 01       	movw	r22, r26
    160c:	cf 01       	movw	r24, r30
    160e:	08 95       	ret

00001610 <_exit>:
    1610:	f8 94       	cli

00001612 <__stop_program>:
    1612:	ff cf       	rjmp	.-2      	; 0x1612 <__stop_program>
