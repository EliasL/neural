
Building_Brains_V4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000001c  00803e00  00001fd3  00002087  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001f66  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000006d  00009f66  00001f66  0000201a  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .bss          00000055  00803e1c  00803e1c  000020a3  2**0
                  ALLOC
  4 .comment      0000005c  00000000  00000000  000020a3  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00002100  2**2
                  CONTENTS, READONLY
  6 .debug_aranges 000004d8  00000000  00000000  00002140  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00007953  00000000  00000000  00002618  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000030dc  00000000  00000000  00009f6b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000280f  00000000  00000000  0000d047  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000008fc  00000000  00000000  0000f858  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00002fa8  00000000  00000000  00010154  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000176e  00000000  00000000  000130fc  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000318  00000000  00000000  0001486a  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	96 c0       	rjmp	.+300    	; 0x12e <__ctors_end>
       2:	b0 c0       	rjmp	.+352    	; 0x164 <__bad_interrupt>
       4:	af c0       	rjmp	.+350    	; 0x164 <__bad_interrupt>
       6:	ae c0       	rjmp	.+348    	; 0x164 <__bad_interrupt>
       8:	ad c0       	rjmp	.+346    	; 0x164 <__bad_interrupt>
       a:	ac c0       	rjmp	.+344    	; 0x164 <__bad_interrupt>
       c:	37 c6       	rjmp	.+3182   	; 0xc7c <__vector_6>
       e:	aa c0       	rjmp	.+340    	; 0x164 <__bad_interrupt>
      10:	a9 c0       	rjmp	.+338    	; 0x164 <__bad_interrupt>
      12:	a8 c0       	rjmp	.+336    	; 0x164 <__bad_interrupt>
      14:	a7 c0       	rjmp	.+334    	; 0x164 <__bad_interrupt>
      16:	a6 c0       	rjmp	.+332    	; 0x164 <__bad_interrupt>
      18:	a5 c0       	rjmp	.+330    	; 0x164 <__bad_interrupt>
      1a:	a4 c0       	rjmp	.+328    	; 0x164 <__bad_interrupt>
      1c:	a3 c0       	rjmp	.+326    	; 0x164 <__bad_interrupt>
      1e:	a2 c0       	rjmp	.+324    	; 0x164 <__bad_interrupt>
      20:	a1 c0       	rjmp	.+322    	; 0x164 <__bad_interrupt>
      22:	a0 c0       	rjmp	.+320    	; 0x164 <__bad_interrupt>
      24:	9f c0       	rjmp	.+318    	; 0x164 <__bad_interrupt>
      26:	9e c0       	rjmp	.+316    	; 0x164 <__bad_interrupt>
      28:	9d c0       	rjmp	.+314    	; 0x164 <__bad_interrupt>
      2a:	9c c0       	rjmp	.+312    	; 0x164 <__bad_interrupt>
      2c:	9b c0       	rjmp	.+310    	; 0x164 <__bad_interrupt>
      2e:	9a c0       	rjmp	.+308    	; 0x164 <__bad_interrupt>
      30:	99 c0       	rjmp	.+306    	; 0x164 <__bad_interrupt>
      32:	98 c0       	rjmp	.+304    	; 0x164 <__bad_interrupt>

00000034 <__trampolines_end>:
      34:	00 40       	sbci	r16, 0x00	; 0
      36:	7a 10       	cpse	r7, r10
      38:	f3 5a       	subi	r31, 0xA3	; 163
      3a:	00 a0       	ldd	r0, Z+32	; 0x20
      3c:	72 4e       	sbci	r23, 0xE2	; 226
      3e:	18 09       	sbc	r17, r8
      40:	00 10       	cpse	r0, r0
      42:	a5 d4       	rcall	.+2378   	; 0x98e <tinyAxon_update_potential+0x70>
      44:	e8 00       	.word	0x00e8	; ????
      46:	00 e8       	ldi	r16, 0x80	; 128
      48:	76 48       	sbci	r23, 0x86	; 134
      4a:	17 00       	.word	0x0017	; ????
      4c:	00 e4       	ldi	r16, 0x40	; 64
      4e:	0b 54       	subi	r16, 0x4B	; 75
      50:	02 00       	.word	0x0002	; ????
      52:	00 ca       	rjmp	.-3072   	; 0xfffff454 <__eeprom_end+0xff7ef454>
      54:	9a 3b       	cpi	r25, 0xBA	; 186
      56:	00 00       	nop
      58:	00 e1       	ldi	r16, 0x10	; 16
      5a:	f5 05       	cpc	r31, r5
      5c:	00 00       	nop
      5e:	80 96       	adiw	r24, 0x20	; 32
      60:	98 00       	.word	0x0098	; ????
      62:	00 00       	nop
      64:	40 42       	sbci	r20, 0x20	; 32
      66:	0f 00       	.word	0x000f	; ????
      68:	00 00       	nop
      6a:	a0 86       	std	Z+8, r10	; 0x08
      6c:	01 00       	.word	0x0001	; ????
      6e:	00 00       	nop
      70:	10 27       	eor	r17, r16
      72:	00 00       	nop
      74:	00 00       	nop
      76:	e8 03       	fmulsu	r22, r16
      78:	00 00       	nop
      7a:	00 00       	nop
      7c:	64 00       	.word	0x0064	; ????
      7e:	00 00       	nop
      80:	00 00       	nop
      82:	0a 00       	.word	0x000a	; ????
      84:	00 00       	nop
      86:	00 00       	nop
      88:	01 00       	.word	0x0001	; ????
      8a:	00 00       	nop
      8c:	00 00       	nop
      8e:	2c 76       	andi	r18, 0x6C	; 108
      90:	d8 88       	ldd	r13, Y+16	; 0x10
      92:	dc 67       	ori	r29, 0x7C	; 124
      94:	4f 08       	sbc	r4, r15
      96:	23 df       	rcall	.-442    	; 0xfffffede <__eeprom_end+0xff7efede>
      98:	c1 df       	rcall	.-126    	; 0x1c <__FUSE_REGION_LENGTH__+0x13>
      9a:	ae 59       	subi	r26, 0x9E	; 158
      9c:	e1 b1       	in	r30, 0x01	; 1
      9e:	b7 96       	adiw	r30, 0x27	; 39
      a0:	e5 e3       	ldi	r30, 0x35	; 53
      a2:	e4 53       	subi	r30, 0x34	; 52
      a4:	c6 3a       	cpi	r28, 0xA6	; 166
      a6:	e6 51       	subi	r30, 0x16	; 22
      a8:	99 76       	andi	r25, 0x69	; 105
      aa:	96 e8       	ldi	r25, 0x86	; 134
      ac:	e6 c2       	rjmp	.+1484   	; 0x67a <set_LED_fire+0x16>
      ae:	84 26       	eor	r8, r20
      b0:	eb 89       	ldd	r30, Y+19	; 0x13
      b2:	8c 9b       	sbis	0x11, 4	; 17
      b4:	62 ed       	ldi	r22, 0xD2	; 210
      b6:	40 7c       	andi	r20, 0xC0	; 192
      b8:	6f fc       	.word	0xfc6f	; ????
      ba:	ef bc       	out	0x2f, r14	; 47
      bc:	9c 9f       	mul	r25, r28
      be:	40 f2       	brcs	.-112    	; 0x50 <__SREG__+0x11>
      c0:	ba a5       	ldd	r27, Y+42	; 0x2a
      c2:	6f a5       	ldd	r22, Y+47	; 0x2f
      c4:	f4 90       	lpm	r15, Z
      c6:	05 5a       	subi	r16, 0xA5	; 165
      c8:	2a f7       	brpl	.-54     	; 0x94 <__SREG__+0x55>
      ca:	5c 93       	st	X, r21
      cc:	6b 6c       	ori	r22, 0xCB	; 203
      ce:	f9 67       	ori	r31, 0x79	; 121
      d0:	6d c1       	rjmp	.+730    	; 0x3ac <dequeue+0x42>
      d2:	1b fc       	.word	0xfc1b	; ????
      d4:	e0 e4       	ldi	r30, 0x40	; 64
      d6:	0d 47       	sbci	r16, 0x7D	; 125
      d8:	fe f5       	brtc	.+126    	; 0x158 <.do_clear_bss_loop>
      da:	20 e6       	ldi	r18, 0x60	; 96
      dc:	b5 00       	.word	0x00b5	; ????
      de:	d0 ed       	ldi	r29, 0xD0	; 208
      e0:	90 2e       	mov	r9, r16
      e2:	03 00       	.word	0x0003	; ????
      e4:	94 35       	cpi	r25, 0x54	; 84
      e6:	77 05       	cpc	r23, r7
      e8:	00 80       	ld	r0, Z
      ea:	84 1e       	adc	r8, r20
      ec:	08 00       	.word	0x0008	; ????
      ee:	00 20       	and	r0, r0
      f0:	4e 0a       	sbc	r4, r30
      f2:	00 00       	nop
      f4:	00 c8       	rjmp	.-4096   	; 0xfffff0f6 <__eeprom_end+0xff7ef0f6>
      f6:	0c 33       	cpi	r16, 0x3C	; 60
      f8:	33 33       	cpi	r19, 0x33	; 51
      fa:	33 0f       	add	r19, r19
      fc:	98 6e       	ori	r25, 0xE8	; 232
      fe:	12 83       	std	Z+2, r17	; 0x02
     100:	11 41       	sbci	r17, 0x11	; 17
     102:	ef 8d       	ldd	r30, Y+31	; 0x1f
     104:	21 14       	cp	r2, r1
     106:	89 3b       	cpi	r24, 0xB9	; 185
     108:	e6 55       	subi	r30, 0x56	; 86
     10a:	16 cf       	rjmp	.-468    	; 0xffffff38 <__eeprom_end+0xff7eff38>
     10c:	fe e6       	ldi	r31, 0x6E	; 110
     10e:	db 18       	sub	r13, r11
     110:	d1 84       	ldd	r13, Z+9	; 0x09
     112:	4b 38       	cpi	r20, 0x8B	; 139
     114:	1b f7       	brvc	.-58     	; 0xdc <__SREG__+0x9d>
     116:	7c 1d       	adc	r23, r12
     118:	90 1d       	adc	r25, r0
     11a:	a4 bb       	out	0x14, r26	; 20
     11c:	e4 24       	eor	r14, r4
     11e:	20 32       	cpi	r18, 0x20	; 32
     120:	84 72       	andi	r24, 0x24	; 36
     122:	5e 22       	and	r5, r30
     124:	81 00       	.word	0x0081	; ????
     126:	c9 f1       	breq	.+114    	; 0x19a <ADC_get_conversion+0x1e>
     128:	24 ec       	ldi	r18, 0xC4	; 196
     12a:	a1 e5       	ldi	r26, 0x51	; 81
     12c:	3d 27       	eor	r19, r29

0000012e <__ctors_end>:
     12e:	11 24       	eor	r1, r1
     130:	1f be       	out	0x3f, r1	; 63
     132:	cf ef       	ldi	r28, 0xFF	; 255
     134:	cd bf       	out	0x3d, r28	; 61
     136:	df e3       	ldi	r29, 0x3F	; 63
     138:	de bf       	out	0x3e, r29	; 62

0000013a <__do_copy_data>:
     13a:	1e e3       	ldi	r17, 0x3E	; 62
     13c:	a0 e0       	ldi	r26, 0x00	; 0
     13e:	be e3       	ldi	r27, 0x3E	; 62
     140:	e3 ed       	ldi	r30, 0xD3	; 211
     142:	ff e1       	ldi	r31, 0x1F	; 31
     144:	02 c0       	rjmp	.+4      	; 0x14a <__do_copy_data+0x10>
     146:	05 90       	lpm	r0, Z+
     148:	0d 92       	st	X+, r0
     14a:	ac 31       	cpi	r26, 0x1C	; 28
     14c:	b1 07       	cpc	r27, r17
     14e:	d9 f7       	brne	.-10     	; 0x146 <__do_copy_data+0xc>

00000150 <__do_clear_bss>:
     150:	2e e3       	ldi	r18, 0x3E	; 62
     152:	ac e1       	ldi	r26, 0x1C	; 28
     154:	be e3       	ldi	r27, 0x3E	; 62
     156:	01 c0       	rjmp	.+2      	; 0x15a <.do_clear_bss_start>

00000158 <.do_clear_bss_loop>:
     158:	1d 92       	st	X+, r1

0000015a <.do_clear_bss_start>:
     15a:	a1 37       	cpi	r26, 0x71	; 113
     15c:	b2 07       	cpc	r27, r18
     15e:	e1 f7       	brne	.-8      	; 0x158 <.do_clear_bss_loop>
     160:	6a d2       	rcall	.+1236   	; 0x636 <main>
     162:	ff ce       	rjmp	.-514    	; 0xffffff62 <__eeprom_end+0xff7eff62>

00000164 <__bad_interrupt>:
     164:	4d cf       	rjmp	.-358    	; 0x0 <__vectors>

00000166 <atmel_start_init>:
/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
	system_init();
     166:	c2 d0       	rcall	.+388    	; 0x2ec <system_init>
     168:	08 95       	ret

0000016a <ADC_init>:
 * \return Conversion result read from the ADC ADC module
 */
adc_result_t ADC_get_conversion_result(void)
{
	return (ADC0.RES);
}
     16a:	85 e0       	ldi	r24, 0x05	; 5
     16c:	80 93 00 06 	sts	0x0600, r24	; 0x800600 <__TEXT_REGION_LENGTH__+0x700600>
     170:	80 e0       	ldi	r24, 0x00	; 0
     172:	08 95       	ret

00000174 <ADC_is_conversion_done>:
     174:	80 91 0b 06 	lds	r24, 0x060B	; 0x80060b <__TEXT_REGION_LENGTH__+0x70060b>
     178:	81 70       	andi	r24, 0x01	; 1
     17a:	08 95       	ret

0000017c <ADC_get_conversion>:
 *
 * \return Nothing
 */
void ADC_start_conversion(adc_0_channel_t channel)
{
	ADC0.MUXPOS  = channel;
     17c:	e0 e0       	ldi	r30, 0x00	; 0
     17e:	f6 e0       	ldi	r31, 0x06	; 6
     180:	86 83       	std	Z+6, r24	; 0x06
	ADC0.COMMAND = ADC_STCONV_bm;
     182:	81 e0       	ldi	r24, 0x01	; 1
     184:	80 87       	std	Z+8, r24	; 0x08
adc_result_t ADC_get_conversion(adc_0_channel_t channel)
{
	adc_result_t res;

	ADC_start_conversion(channel);
	while (!ADC_is_conversion_done())
     186:	f6 df       	rcall	.-20     	; 0x174 <ADC_is_conversion_done>
     188:	88 23       	and	r24, r24
     18a:	e9 f3       	breq	.-6      	; 0x186 <ADC_get_conversion+0xa>
 *
 * \return Conversion result read from the ADC ADC module
 */
adc_result_t ADC_get_conversion_result(void)
{
	return (ADC0.RES);
     18c:	e0 e0       	ldi	r30, 0x00	; 0
     18e:	f6 e0       	ldi	r31, 0x06	; 6
     190:	20 89       	ldd	r18, Z+16	; 0x10
     192:	31 89       	ldd	r19, Z+17	; 0x11

	ADC_start_conversion(channel);
	while (!ADC_is_conversion_done())
		;
	res = ADC_get_conversion_result();
	ADC0.INTFLAGS |= ADC_RESRDY_bm;
     194:	93 85       	ldd	r25, Z+11	; 0x0b
     196:	91 60       	ori	r25, 0x01	; 1
     198:	93 87       	std	Z+11, r25	; 0x0b
	return res;
}
     19a:	c9 01       	movw	r24, r18
     19c:	08 95       	ret

0000019e <BOD_init>:
	//		 | BOD_VLMCFG_ABOVE_gc; /* Interrupt when supply goes above VLM level */

	// BOD.VLMCTRLA = BOD_VLMLVL_5ABOVE_gc; /* VLM threshold 5% above BOD level */

	return 0;
}
     19e:	80 e0       	ldi	r24, 0x00	; 0
     1a0:	08 95       	ret

000001a2 <DIGGSIGG_init>:
	//		 | CCL_EDGEDET_DIS_gc /* Edge detector is disabled */
	//		 | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	//		 | 0 << CCL_ENABLE_bp /* LUT Enable: disabled */
	//		 | 0 << CCL_OUTEN_bp; /* Output Enable: disabled */

	CCL.TRUTH1 = 168; /* Truth 1: 168 */
     1a2:	e0 ec       	ldi	r30, 0xC0	; 192
     1a4:	f1 e0       	ldi	r31, 0x01	; 1
     1a6:	88 ea       	ldi	r24, 0xA8	; 168
     1a8:	84 87       	std	Z+12, r24	; 0x0c

	CCL.LUT1CTRLC = CCL_INSEL2_TCA0_gc /* TCA0 WO2 input source */;
     1aa:	88 e0       	ldi	r24, 0x08	; 8
     1ac:	83 87       	std	Z+11, r24	; 0x0b

	CCL.LUT1CTRLB = CCL_INSEL0_SPI0_gc /* SPI0 SCK source */
     1ae:	8b eb       	ldi	r24, 0xBB	; 187
     1b0:	82 87       	std	Z+10, r24	; 0x0a
	                | CCL_INSEL1_SPI0_gc /* SPI0 MOSI input source */;

	CCL.LUT1CTRLA = 0 << CCL_CLKSRC_bp       /* Clock Source Selection: disabled */
     1b2:	89 e0       	ldi	r24, 0x09	; 9
     1b4:	81 87       	std	Z+9, r24	; 0x09
	                | CCL_EDGEDET_DIS_gc     /* Edge detector is disabled */
	                | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	                | 1 << CCL_ENABLE_bp     /* LUT Enable: enabled */
	                | 1 << CCL_OUTEN_bp;     /* Output Enable: enabled */

	CCL.CTRLA = 1 << CCL_ENABLE_bp      /* Enable: enabled */
     1b6:	81 e4       	ldi	r24, 0x41	; 65
     1b8:	80 83       	st	Z, r24
	            | 1 << CCL_RUNSTDBY_bp; /* Run in Standby: enabled */

	return 0;
}
     1ba:	80 e0       	ldi	r24, 0x00	; 0
     1bc:	08 95       	ret

000001be <CLKCTRL_init>:
 *       on calling convention. The memory model is not visible to the
 *       preprocessor, so it must be defined in the Assembler preprocessor directives.
 */
static inline void ccp_write_io(void *addr, uint8_t value)
{
	protected_write_io(addr, CCP_IOREG_gc, value);
     1be:	47 e0       	ldi	r20, 0x07	; 7
     1c0:	68 ed       	ldi	r22, 0xD8	; 216
     1c2:	8c e7       	ldi	r24, 0x7C	; 124
     1c4:	90 e0       	ldi	r25, 0x00	; 0
     1c6:	ad d0       	rcall	.+346    	; 0x322 <protected_write_io>
     1c8:	41 e0       	ldi	r20, 0x01	; 1
     1ca:	68 ed       	ldi	r22, 0xD8	; 216
     1cc:	81 e6       	ldi	r24, 0x61	; 97
     1ce:	90 e0       	ldi	r25, 0x00	; 0
     1d0:	a8 d0       	rcall	.+336    	; 0x322 <protected_write_io>
	//		 | 0 << CLKCTRL_CLKOUT_bp /* System clock out: disabled */);

	// ccp_write_io((void*)&(CLKCTRL.MCLKLOCK),0 << CLKCTRL_LOCKEN_bp /* lock enable: disabled */);

	return 0;
}
     1d2:	80 e0       	ldi	r24, 0x00	; 0
     1d4:	08 95       	ret

000001d6 <CPUINT_init>:

	// CPUINT.LVL0PRI = 0x0 << CPUINT_LVL0PRI_gp; /* Interrupt Level Priority: 0x0 */

	// CPUINT.LVL1VEC = 0x0 << CPUINT_LVL1VEC_gp; /* Interrupt Vector with High Priority: 0x0 */

	ENABLE_INTERRUPTS();
     1d6:	78 94       	sei

	return 0;
}
     1d8:	80 e0       	ldi	r24, 0x00	; 0
     1da:	08 95       	ret

000001dc <DAC_init>:
 *
 * \return Nothing
 */
void DAC_disable()
{
	DAC0.CTRLA &= ~DAC_ENABLE_bm;
     1dc:	81 e4       	ldi	r24, 0x41	; 65
     1de:	80 93 80 06 	sts	0x0680, r24	; 0x800680 <__TEXT_REGION_LENGTH__+0x700680>
     1e2:	80 e0       	ldi	r24, 0x00	; 0
     1e4:	08 95       	ret

000001e6 <DAC_set_output>:
 *
 * \return Nothing
 */
void DAC_set_output(dac_resolution_t value)
{
	DAC0.DATA = value;
     1e6:	80 93 81 06 	sts	0x0681, r24	; 0x800681 <__TEXT_REGION_LENGTH__+0x700681>
     1ea:	08 95       	ret

000001ec <mcu_init>:
#ifdef __cplusplus
extern "C" {
#endif

void mcu_init(void)
{
     1ec:	e0 e1       	ldi	r30, 0x10	; 16
     1ee:	f4 e0       	ldi	r31, 0x04	; 4
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     1f0:	80 81       	ld	r24, Z
     1f2:	88 60       	ori	r24, 0x08	; 8
     1f4:	81 93       	st	Z+, r24
	 * disables all peripherals to save power. Driver shall enable
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
     1f6:	e8 31       	cpi	r30, 0x18	; 24
     1f8:	84 e0       	ldi	r24, 0x04	; 4
     1fa:	f8 07       	cpc	r31, r24
     1fc:	c9 f7       	brne	.-14     	; 0x1f0 <mcu_init+0x4>
     1fe:	e0 e3       	ldi	r30, 0x30	; 48
     200:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     202:	80 81       	ld	r24, Z
     204:	88 60       	ori	r24, 0x08	; 8
     206:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     208:	e8 33       	cpi	r30, 0x38	; 56
     20a:	84 e0       	ldi	r24, 0x04	; 4
     20c:	f8 07       	cpc	r31, r24
     20e:	c9 f7       	brne	.-14     	; 0x202 <mcu_init+0x16>
     210:	e0 e5       	ldi	r30, 0x50	; 80
     212:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     214:	80 81       	ld	r24, Z
     216:	88 60       	ori	r24, 0x08	; 8
     218:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     21a:	e8 35       	cpi	r30, 0x58	; 88
     21c:	84 e0       	ldi	r24, 0x04	; 4
     21e:	f8 07       	cpc	r31, r24
     220:	c9 f7       	brne	.-14     	; 0x214 <mcu_init+0x28>
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}
}
     222:	08 95       	ret

00000224 <ADC_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     224:	e5 e1       	ldi	r30, 0x15	; 21
     226:	f4 e0       	ldi	r31, 0x04	; 4
     228:	80 81       	ld	r24, Z
     22a:	88 7f       	andi	r24, 0xF8	; 248
     22c:	84 60       	ori	r24, 0x04	; 4
     22e:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     230:	80 81       	ld	r24, Z
     232:	87 7f       	andi	r24, 0xF7	; 247
     234:	80 83       	st	Z, r24
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     236:	e7 e1       	ldi	r30, 0x17	; 23
     238:	f4 e0       	ldi	r31, 0x04	; 4
     23a:	80 81       	ld	r24, Z
     23c:	88 7f       	andi	r24, 0xF8	; 248
     23e:	84 60       	ori	r24, 0x04	; 4
     240:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     242:	80 81       	ld	r24, Z
     244:	87 7f       	andi	r24, 0xF7	; 247
     246:	80 83       	st	Z, r24
 */
static inline void PORTB_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     248:	e4 e3       	ldi	r30, 0x34	; 52
     24a:	f4 e0       	ldi	r31, 0x04	; 4
     24c:	80 81       	ld	r24, Z
     24e:	88 7f       	andi	r24, 0xF8	; 248
     250:	84 60       	ori	r24, 0x04	; 4
     252:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     254:	80 81       	ld	r24, Z
     256:	87 7f       	andi	r24, 0xF7	; 247
     258:	80 83       	st	Z, r24
 */
static inline void PORTB_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     25a:	e1 e3       	ldi	r30, 0x31	; 49
     25c:	f4 e0       	ldi	r31, 0x04	; 4
     25e:	80 81       	ld	r24, Z
     260:	88 7f       	andi	r24, 0xF8	; 248
     262:	84 60       	ori	r24, 0x04	; 4
     264:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     266:	80 81       	ld	r24, Z
     268:	87 7f       	andi	r24, 0xF7	; 247
     26a:	80 83       	st	Z, r24
 */
static inline void PORTB_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     26c:	e0 e3       	ldi	r30, 0x30	; 48
     26e:	f4 e0       	ldi	r31, 0x04	; 4
     270:	80 81       	ld	r24, Z
     272:	88 7f       	andi	r24, 0xF8	; 248
     274:	84 60       	ori	r24, 0x04	; 4
     276:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     278:	80 81       	ld	r24, Z
     27a:	87 7f       	andi	r24, 0xF7	; 247
     27c:	80 83       	st	Z, r24
	// Disable digital input buffer
	DEN4_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	DEN4_PIN_set_pull_mode(PORT_PULL_OFF);

	ADC_init();
     27e:	75 df       	rcall	.-278    	; 0x16a <ADC_init>
     280:	08 95       	ret

00000282 <USART_0_initialization>:
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     282:	23 98       	cbi	0x04, 3	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     284:	e3 e3       	ldi	r30, 0x33	; 51
     286:	f4 e0       	ldi	r31, 0x04	; 4
     288:	80 81       	ld	r24, Z
     28a:	87 7f       	andi	r24, 0xF7	; 247
     28c:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     28e:	22 9a       	sbi	0x04, 2	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     290:	2a 98       	cbi	0x05, 2	; 5
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	USART_0_init();
     292:	07 d1       	rcall	.+526    	; 0x4a2 <USART_0_init>
     294:	08 95       	ret

00000296 <TIMER_0_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     296:	25 9a       	sbi	0x04, 5	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     298:	2d 98       	cbi	0x05, 5	; 5
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLC |= PORTMUX_TCA02_bm;
     29a:	e0 e0       	ldi	r30, 0x00	; 0
     29c:	f2 e0       	ldi	r31, 0x02	; 2
     29e:	82 81       	ldd	r24, Z+2	; 0x02
     2a0:	84 60       	ori	r24, 0x04	; 4
     2a2:	82 83       	std	Z+2, r24	; 0x02

	TIMER_0_init();
     2a4:	ee d0       	rcall	.+476    	; 0x482 <TIMER_0_init>
     2a6:	08 95       	ret

000002a8 <DIGGSIGG_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTC.DIR |= (1 << pin);
     2a8:	41 9a       	sbi	0x08, 1	; 8
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
	} else {
		VPORTC.OUT &= ~(1 << pin);
     2aa:	49 98       	cbi	0x09, 1	; 9
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLA |= PORTMUX_LUT1_bm;
     2ac:	e0 e0       	ldi	r30, 0x00	; 0
     2ae:	f2 e0       	ldi	r31, 0x02	; 2
     2b0:	80 81       	ld	r24, Z
     2b2:	80 62       	ori	r24, 0x20	; 32
     2b4:	80 83       	st	Z, r24

	DIGGSIGG_init();
     2b6:	75 df       	rcall	.-278    	; 0x1a2 <DIGGSIGG_init>
     2b8:	08 95       	ret

000002ba <SPI_0_initialization>:
 */
static inline void PORTA_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
     2ba:	02 98       	cbi	0x00, 2	; 0
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2bc:	e2 e1       	ldi	r30, 0x12	; 18
     2be:	f4 e0       	ldi	r31, 0x04	; 4
     2c0:	80 81       	ld	r24, Z
     2c2:	87 7f       	andi	r24, 0xF7	; 247
     2c4:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     2c6:	01 9a       	sbi	0x00, 1	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     2c8:	09 98       	cbi	0x01, 1	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     2ca:	03 9a       	sbi	0x00, 3	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     2cc:	0b 98       	cbi	0x01, 3	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     2ce:	04 9a       	sbi	0x00, 4	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     2d0:	0c 98       	cbi	0x01, 4	; 1
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	SPI_0_init();
     2d2:	cf d0       	rcall	.+414    	; 0x472 <SPI_0_init>
     2d4:	08 95       	ret

000002d6 <DAC_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     2d6:	e6 e1       	ldi	r30, 0x16	; 22
     2d8:	f4 e0       	ldi	r31, 0x04	; 4
     2da:	80 81       	ld	r24, Z
     2dc:	88 7f       	andi	r24, 0xF8	; 248
     2de:	84 60       	ori	r24, 0x04	; 4
     2e0:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2e2:	80 81       	ld	r24, Z
     2e4:	87 7f       	andi	r24, 0xF7	; 247
     2e6:	80 83       	st	Z, r24
	// Disable digital input buffer
	AXON_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	AXON_PIN_set_pull_mode(PORT_PULL_OFF);

	DAC_init();
     2e8:	79 df       	rcall	.-270    	; 0x1dc <DAC_init>
     2ea:	08 95       	ret

000002ec <system_init>:
/**
 * \brief System initialization
 */
void system_init()
{
	mcu_init();
     2ec:	7f df       	rcall	.-258    	; 0x1ec <mcu_init>
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     2ee:	27 98       	cbi	0x04, 7	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2f0:	e7 e3       	ldi	r30, 0x37	; 55
     2f2:	f4 e0       	ldi	r31, 0x04	; 4
     2f4:	80 81       	ld	r24, Z
     2f6:	87 7f       	andi	r24, 0xF7	; 247
     2f8:	80 83       	st	Z, r24
 */
static inline void PORTC_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
     2fa:	42 98       	cbi	0x08, 2	; 8
static inline void PORTC_set_pin_pull_mode(const uint8_t pin, const enum port_pull_mode pull_mode)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
     2fc:	e2 e5       	ldi	r30, 0x52	; 82
     2fe:	f4 e0       	ldi	r31, 0x04	; 4
     300:	80 81       	ld	r24, Z
     302:	88 60       	ori	r24, 0x08	; 8
     304:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTC.DIR |= (1 << pin);
     306:	45 9a       	sbi	0x08, 5	; 8
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     308:	4d 9a       	sbi	0x09, 5	; 9
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    true);

	CLKCTRL_init();
     30a:	59 df       	rcall	.-334    	; 0x1be <CLKCTRL_init>

	RTC_init();
     30c:	94 d0       	rcall	.+296    	; 0x436 <RTC_init>

	ADC_initialization();
     30e:	8a df       	rcall	.-236    	; 0x224 <ADC_initialization>

	USART_0_initialization();
     310:	b8 df       	rcall	.-144    	; 0x282 <USART_0_initialization>

	TIMER_0_initialization();
     312:	c1 df       	rcall	.-126    	; 0x296 <TIMER_0_initialization>

	DIGGSIGG_initialization();
     314:	c9 df       	rcall	.-110    	; 0x2a8 <DIGGSIGG_initialization>

	SPI_0_initialization();
     316:	d1 df       	rcall	.-94     	; 0x2ba <SPI_0_initialization>

	DAC_initialization();
     318:	de df       	rcall	.-68     	; 0x2d6 <DAC_initialization>

	CPUINT_init();
     31a:	5d df       	rcall	.-326    	; 0x1d6 <CPUINT_init>

	SLPCTRL_init();
     31c:	a8 d0       	rcall	.+336    	; 0x46e <SLPCTRL_init>

	BOD_init();
     31e:	3f df       	rcall	.-386    	; 0x19e <BOD_init>
     320:	08 95       	ret

00000322 <protected_write_io>:
#if defined(__GNUC__)
  
#ifdef RAMPZ
	out     _SFR_IO_ADDR(RAMPZ), r1         // Clear bits 23:16 of Z
#endif
	movw    r30, r24                // Load addr into Z
     322:	fc 01       	movw	r30, r24
	out     CCP, r22                // Start CCP handshake
     324:	64 bf       	out	0x34, r22	; 52
	st      Z, r20                  // Write value to I/O register
     326:	40 83       	st	Z, r20
	ret                             // Return to caller
     328:	08 95       	ret

0000032a <enqueue>:
 */ 
#include <stdio.h>
#include <stdlib.h>
#include "include/queue.h"

void enqueue(node_t **head, uint32_t val) {
     32a:	cf 92       	push	r12
     32c:	df 92       	push	r13
     32e:	ef 92       	push	r14
     330:	ff 92       	push	r15
     332:	cf 93       	push	r28
     334:	df 93       	push	r29
     336:	ec 01       	movw	r28, r24
     338:	6a 01       	movw	r12, r20
     33a:	7b 01       	movw	r14, r22
	// remember, head is at the very BACK of the queue (The element that will wait the longest until dequeued)
	
	// we create a new empty node
	node_t *new_node = malloc(sizeof(node_t));
     33c:	86 e0       	ldi	r24, 0x06	; 6
     33e:	90 e0       	ldi	r25, 0x00	; 0
     340:	ca d7       	rcall	.+3988   	; 0x12d6 <malloc>
	// Not quite sure what happens here, but it seems to be some sort of error handling, except you never know if there has been an error :/
	if (!new_node) return;
     342:	00 97       	sbiw	r24, 0x00	; 0
     344:	59 f0       	breq	.+22     	; 0x35c <enqueue+0x32>

	// we configure our node
	new_node->val = val;
     346:	fc 01       	movw	r30, r24
     348:	c0 82       	st	Z, r12
     34a:	d1 82       	std	Z+1, r13	; 0x01
     34c:	e2 82       	std	Z+2, r14	; 0x02
     34e:	f3 82       	std	Z+3, r15	; 0x03
	new_node->next = *head;
     350:	28 81       	ld	r18, Y
     352:	39 81       	ldd	r19, Y+1	; 0x01
     354:	24 83       	std	Z+4, r18	; 0x04
     356:	35 83       	std	Z+5, r19	; 0x05

	// and lastly, we change the pointer pointing to the previous head node, to point to our new node instead
	*head = new_node;
     358:	88 83       	st	Y, r24
     35a:	99 83       	std	Y+1, r25	; 0x01
}
     35c:	df 91       	pop	r29
     35e:	cf 91       	pop	r28
     360:	ff 90       	pop	r15
     362:	ef 90       	pop	r14
     364:	df 90       	pop	r13
     366:	cf 90       	pop	r12
     368:	08 95       	ret

0000036a <dequeue>:

uint32_t dequeue(node_t **head) {
     36a:	cf 92       	push	r12
     36c:	df 92       	push	r13
     36e:	ef 92       	push	r14
     370:	ff 92       	push	r15
     372:	0f 93       	push	r16
     374:	1f 93       	push	r17
     376:	cf 93       	push	r28
     378:	df 93       	push	r29
	node_t *current, *prev = NULL;
	uint32_t retval = 0;

	// If the queue we have been given is empty, we return an error
	// (0 is usually not an error, but it is probably the best option)
	if (*head == NULL) return 0;
     37a:	dc 01       	movw	r26, r24
     37c:	ed 91       	ld	r30, X+
     37e:	fc 91       	ld	r31, X
     380:	30 97       	sbiw	r30, 0x00	; 0
     382:	11 f1       	breq	.+68     	; 0x3c8 <dequeue+0x5e>
     384:	c0 e0       	ldi	r28, 0x00	; 0
     386:	d0 e0       	ldi	r29, 0x00	; 0
     388:	02 c0       	rjmp	.+4      	; 0x38e <dequeue+0x24>
     38a:	ef 01       	movw	r28, r30

	// Now we iterate through the queue until we reach the end
	current = *head;
	while (current->next != NULL) {
		prev = current;
		current = current->next;
     38c:	f9 01       	movw	r30, r18
	// (0 is usually not an error, but it is probably the best option)
	if (*head == NULL) return 0;

	// Now we iterate through the queue until we reach the end
	current = *head;
	while (current->next != NULL) {
     38e:	24 81       	ldd	r18, Z+4	; 0x04
     390:	35 81       	ldd	r19, Z+5	; 0x05
     392:	21 15       	cp	r18, r1
     394:	31 05       	cpc	r19, r1
     396:	c9 f7       	brne	.-14     	; 0x38a <dequeue+0x20>
     398:	8c 01       	movw	r16, r24
		prev = current;
		current = current->next;
	}

	// We retrieve the value we needed
	retval = current->val;
     39a:	c0 80       	ld	r12, Z
     39c:	d1 80       	ldd	r13, Z+1	; 0x01
     39e:	e2 80       	ldd	r14, Z+2	; 0x02
     3a0:	f3 80       	ldd	r15, Z+3	; 0x03
	// and remove the last element of the queue from the queue
	free(current);
     3a2:	cf 01       	movw	r24, r30
     3a4:	30 d8       	rcall	.-4000   	; 0xfffff406 <__eeprom_end+0xff7ef406>
	
	// Now we update the previous node so that it becomes the front of the queue
	// In case the queue only had one element, the prev will be null (false)
	if (prev){
     3a6:	20 97       	sbiw	r28, 0x00	; 0
     3a8:	39 f0       	breq	.+14     	; 0x3b8 <dequeue+0x4e>
	prev->next = NULL;}
     3aa:	1c 82       	std	Y+4, r1	; 0x04
     3ac:	1d 82       	std	Y+5, r1	; 0x05
	else{
	*head = NULL;}

	return retval;
     3ae:	6c 2d       	mov	r22, r12
     3b0:	7d 2d       	mov	r23, r13
     3b2:	8e 2d       	mov	r24, r14
     3b4:	9f 2d       	mov	r25, r15
     3b6:	0c c0       	rjmp	.+24     	; 0x3d0 <dequeue+0x66>
	// Now we update the previous node so that it becomes the front of the queue
	// In case the queue only had one element, the prev will be null (false)
	if (prev){
	prev->next = NULL;}
	else{
	*head = NULL;}
     3b8:	f8 01       	movw	r30, r16
     3ba:	10 82       	st	Z, r1
     3bc:	11 82       	std	Z+1, r1	; 0x01

	return retval;
     3be:	6c 2d       	mov	r22, r12
     3c0:	7d 2d       	mov	r23, r13
     3c2:	8e 2d       	mov	r24, r14
     3c4:	9f 2d       	mov	r25, r15
     3c6:	04 c0       	rjmp	.+8      	; 0x3d0 <dequeue+0x66>
	node_t *current, *prev = NULL;
	uint32_t retval = 0;

	// If the queue we have been given is empty, we return an error
	// (0 is usually not an error, but it is probably the best option)
	if (*head == NULL) return 0;
     3c8:	60 e0       	ldi	r22, 0x00	; 0
     3ca:	70 e0       	ldi	r23, 0x00	; 0
     3cc:	80 e0       	ldi	r24, 0x00	; 0
     3ce:	90 e0       	ldi	r25, 0x00	; 0
	prev->next = NULL;}
	else{
	*head = NULL;}

	return retval;
}
     3d0:	df 91       	pop	r29
     3d2:	cf 91       	pop	r28
     3d4:	1f 91       	pop	r17
     3d6:	0f 91       	pop	r16
     3d8:	ff 90       	pop	r15
     3da:	ef 90       	pop	r14
     3dc:	df 90       	pop	r13
     3de:	cf 90       	pop	r12
     3e0:	08 95       	ret

000003e2 <dequeue_top>:

// Here we remove the element of the queue that was added last (first in, last out)
uint32_t dequeue_top(node_t **head){
     3e2:	cf 92       	push	r12
     3e4:	df 92       	push	r13
     3e6:	ef 92       	push	r14
     3e8:	ff 92       	push	r15
     3ea:	0f 93       	push	r16
     3ec:	1f 93       	push	r17
     3ee:	cf 93       	push	r28
     3f0:	df 93       	push	r29
	node_t *oldHead;
	uint32_t retval = 0;
	
	// If the queue we have been given is empty, we return an error
	// (0 is usually not an error, but it is probably the best option)
	if (*head == NULL) return 0;
     3f2:	dc 01       	movw	r26, r24
     3f4:	ed 91       	ld	r30, X+
     3f6:	fc 91       	ld	r31, X
     3f8:	30 97       	sbiw	r30, 0x00	; 0
     3fa:	81 f0       	breq	.+32     	; 0x41c <__LOCK_REGION_LENGTH__+0x1c>
     3fc:	ec 01       	movw	r28, r24
	
	oldHead = *head;
	// We then set the new head to be the second last in the queue
	newHead = oldHead->next;
     3fe:	c4 80       	ldd	r12, Z+4	; 0x04
     400:	d5 80       	ldd	r13, Z+5	; 0x05
	
	// We retrieve the heads value
	retval = oldHead->val;
     402:	e0 80       	ld	r14, Z
     404:	f1 80       	ldd	r15, Z+1	; 0x01
     406:	02 81       	ldd	r16, Z+2	; 0x02
     408:	13 81       	ldd	r17, Z+3	; 0x03
	
	// We free the memory that was used to store the old head
	free(oldHead);
     40a:	cf 01       	movw	r24, r30
     40c:	fc d7       	rcall	.+4088   	; 0x1406 <free>
	
	//And then we overwrite the value of head to be the second last
	*head = newHead;
     40e:	c8 82       	st	Y, r12
     410:	d9 82       	std	Y+1, r13	; 0x01
	
	return retval;
     412:	6e 2d       	mov	r22, r14
     414:	7f 2d       	mov	r23, r15
     416:	80 2f       	mov	r24, r16
     418:	91 2f       	mov	r25, r17
     41a:	04 c0       	rjmp	.+8      	; 0x424 <__LOCK_REGION_LENGTH__+0x24>
	node_t *oldHead;
	uint32_t retval = 0;
	
	// If the queue we have been given is empty, we return an error
	// (0 is usually not an error, but it is probably the best option)
	if (*head == NULL) return 0;
     41c:	60 e0       	ldi	r22, 0x00	; 0
     41e:	70 e0       	ldi	r23, 0x00	; 0
     420:	80 e0       	ldi	r24, 0x00	; 0
     422:	90 e0       	ldi	r25, 0x00	; 0
	//And then we overwrite the value of head to be the second last
	*head = newHead;
	
	return retval;
	
}
     424:	df 91       	pop	r29
     426:	cf 91       	pop	r28
     428:	1f 91       	pop	r17
     42a:	0f 91       	pop	r16
     42c:	ff 90       	pop	r15
     42e:	ef 90       	pop	r14
     430:	df 90       	pop	r13
     432:	cf 90       	pop	r12
     434:	08 95       	ret

00000436 <RTC_init>:
 * \return Initialization status.
 */
int8_t RTC_init()
{

	while (RTC.STATUS > 0) { /* Wait for all register to be synchronized */
     436:	e0 e4       	ldi	r30, 0x40	; 64
     438:	f1 e0       	ldi	r31, 0x01	; 1
     43a:	81 81       	ldd	r24, Z+1	; 0x01
     43c:	81 11       	cpse	r24, r1
     43e:	fd cf       	rjmp	.-6      	; 0x43a <RTC_init+0x4>
	}

	// RTC.CMP = 0x0; /* Compare: 0x0 */

	RTC.CNT = 0x20; /* Counter: 0x20 */
     440:	e0 e4       	ldi	r30, 0x40	; 64
     442:	f1 e0       	ldi	r31, 0x01	; 1
     444:	80 e2       	ldi	r24, 0x20	; 32
     446:	90 e0       	ldi	r25, 0x00	; 0
     448:	80 87       	std	Z+8, r24	; 0x08
     44a:	91 87       	std	Z+9, r25	; 0x09

	RTC.CTRLA = RTC_PRESCALER_DIV1_gc   /* 1 */
     44c:	81 e8       	ldi	r24, 0x81	; 129
     44e:	80 83       	st	Z, r24
	            | 1 << RTC_RTCEN_bp     /* Enable: enabled */
	            | 1 << RTC_RUNSTDBY_bp; /* Run In Standby: enabled */

	RTC.PER = 0x20 / TIMESCALE; /* Period: 0x20 */
     450:	80 e8       	ldi	r24, 0x80	; 128
     452:	9c e0       	ldi	r25, 0x0C	; 12
     454:	82 87       	std	Z+10, r24	; 0x0a
     456:	93 87       	std	Z+11, r25	; 0x0b

	// RTC.CLKSEL = RTC_CLKSEL_INT32K_gc; /* 32KHz Internal Ultra Low Power Oscillator (OSCULP32K) */

	RTC.DBGCTRL = 1 << RTC_DBGRUN_bp; /* Run in debug: enabled */
     458:	81 e0       	ldi	r24, 0x01	; 1
     45a:	85 83       	std	Z+5, r24	; 0x05

	RTC.INTCTRL = 0 << RTC_CMP_bp    /* Compare Match Interrupt enable: disabled */
     45c:	82 83       	std	Z+2, r24	; 0x02
	              | 1 << RTC_OVF_bp; /* Overflow Interrupt enable: enabled */

	while (RTC.PITSTATUS > 0) { /* Wait for all register to be synchronized */
     45e:	81 89       	ldd	r24, Z+17	; 0x11
     460:	81 11       	cpse	r24, r1
     462:	fd cf       	rjmp	.-6      	; 0x45e <RTC_init+0x28>
	}

	RTC.PITCTRLA = RTC_PERIOD_OFF_gc    /* Off */
     464:	81 e0       	ldi	r24, 0x01	; 1
     466:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <__TEXT_REGION_LENGTH__+0x700150>
	// RTC.PITDBGCTRL = 0 << RTC_DBGRUN_bp; /* Run in debug: disabled */

	// RTC.PITINTCTRL = 0 << RTC_PI_bp; /* Periodic Interrupt: disabled */

	return 0;
}
     46a:	80 e0       	ldi	r24, 0x00	; 0
     46c:	08 95       	ret

0000046e <SLPCTRL_init>:

	// SLPCTRL.CTRLA = 0 << SLPCTRL_SEN_bp /* Sleep enable: disabled */
	//		 | SLPCTRL_SMODE_IDLE_gc; /* Idle mode */

	return 0;
}
     46e:	80 e0       	ldi	r24, 0x00	; 0
     470:	08 95       	ret

00000472 <SPI_0_init>:
 * \return Initialization status
 */
int8_t SPI_0_init()
{

	SPI0.CTRLA = 0 << SPI_CLK2X_bp     /* Enable Double Speed: disabled */
     472:	e0 e2       	ldi	r30, 0x20	; 32
     474:	f8 e0       	ldi	r31, 0x08	; 8
     476:	83 e2       	ldi	r24, 0x23	; 35
     478:	80 83       	st	Z, r24
	             | 0 << SPI_DORD_bp    /* Data Order Setting: disabled */
	             | 1 << SPI_ENABLE_bp  /* Enable Module: enabled */
	             | 1 << SPI_MASTER_bp  /* SPI module in master mode */
	             | SPI_PRESC_DIV16_gc; /* System Clock / 16 */

	SPI0.CTRLB = 0 << SPI_BUFEN_bp   /* Buffer Mode Enable: disabled */
     47a:	84 e0       	ldi	r24, 0x04	; 4
     47c:	81 83       	std	Z+1, r24	; 0x01
	//		 | 0 << SPI_RXCIE_bp /* Receive Complete Interrupt Enable: disabled */
	//		 | 0 << SPI_SSIE_bp /* Slave Select Trigger Interrupt Enable: disabled */
	//		 | 0 << SPI_TXCIE_bp; /* Transfer Complete Interrupt Enable: disabled */

	return 0;
}
     47e:	80 e0       	ldi	r24, 0x00	; 0
     480:	08 95       	ret

00000482 <TIMER_0_init>:

	// TCA0.SINGLE.CMP0 = 0x0; /* Compare Register 0: 0x0 */

	// TCA0.SINGLE.CMP1 = 0x0; /* Compare Register 1: 0x0 */

	TCA0.SINGLE.CMP2 = 0x4; /* Compare Register 2: 0x4 */
     482:	e0 e0       	ldi	r30, 0x00	; 0
     484:	fa e0       	ldi	r31, 0x0A	; 10
     486:	84 e0       	ldi	r24, 0x04	; 4
     488:	90 e0       	ldi	r25, 0x00	; 0
     48a:	84 a7       	std	Z+44, r24	; 0x2c
     48c:	95 a7       	std	Z+45, r25	; 0x2d

	// TCA0.SINGLE.CNT = 0x0; /* Count: 0x0 */

	TCA0.SINGLE.CTRLB = 0 << TCA_SINGLE_ALUPD_bp            /* Auto Lock Update: disabled */
     48e:	83 e4       	ldi	r24, 0x43	; 67
     490:	81 83       	std	Z+1, r24	; 0x01
	                    | 0 << TCA_SINGLE_CMP0EN_bp         /* Compare 0 Enable: disabled */
	                    | 0 << TCA_SINGLE_CMP1EN_bp         /* Compare 1 Enable: disabled */
	                    | 1 << TCA_SINGLE_CMP2EN_bp         /* Compare 2 Enable: enabled */
	                    | TCA_SINGLE_WGMODE_SINGLESLOPE_gc; /*  */

	TCA0.SINGLE.CTRLC = 0 << TCA_SINGLE_CMP0OV_bp    /* Compare 0 Waveform Output Value: disabled */
     492:	84 e0       	ldi	r24, 0x04	; 4
     494:	82 83       	std	Z+2, r24	; 0x02
	// TCA0.SINGLE.INTCTRL = 0 << TCA_SINGLE_CMP0_bp /* Compare 0 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP1_bp /* Compare 1 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP2_bp /* Compare 2 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_OVF_bp; /* Overflow Interrupt: disabled */

	TCA0.SINGLE.PER = 0x7; /* Period: 0x7 */
     496:	87 e0       	ldi	r24, 0x07	; 7
     498:	90 e0       	ldi	r25, 0x00	; 0
     49a:	86 a3       	std	Z+38, r24	; 0x26
     49c:	97 a3       	std	Z+39, r25	; 0x27

	// TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV1_gc /* System Clock */
	//		 | 0 << TCA_SINGLE_ENABLE_bp; /* Module Enable: disabled */

	return 0;
}
     49e:	80 e0       	ldi	r24, 0x00	; 0
     4a0:	08 95       	ret

000004a2 <USART_0_init>:
uint8_t USART_0_read()
{
	while (!(USART0.STATUS & USART_RXCIF_bm))
		;
	return USART0.RXDATAL;
}
     4a2:	e0 e0       	ldi	r30, 0x00	; 0
     4a4:	f8 e0       	ldi	r31, 0x08	; 8
     4a6:	87 e4       	ldi	r24, 0x47	; 71
     4a8:	90 e1       	ldi	r25, 0x10	; 16
     4aa:	80 87       	std	Z+8, r24	; 0x08
     4ac:	91 87       	std	Z+9, r25	; 0x09
     4ae:	80 ec       	ldi	r24, 0xC0	; 192
     4b0:	86 83       	std	Z+6, r24	; 0x06
     4b2:	86 e0       	ldi	r24, 0x06	; 6
     4b4:	9e e3       	ldi	r25, 0x3E	; 62
     4b6:	80 93 6d 3e 	sts	0x3E6D, r24	; 0x803e6d <__iob+0x2>
     4ba:	90 93 6e 3e 	sts	0x3E6E, r25	; 0x803e6e <__iob+0x3>
     4be:	80 e0       	ldi	r24, 0x00	; 0
     4c0:	08 95       	ret

000004c2 <USART_0_write>:
 *
 * \return Nothing
 */
void USART_0_write(const uint8_t data)
{
	while (!(USART0.STATUS & USART_DREIF_bm))
     4c2:	e0 e0       	ldi	r30, 0x00	; 0
     4c4:	f8 e0       	ldi	r31, 0x08	; 8
     4c6:	94 81       	ldd	r25, Z+4	; 0x04
     4c8:	95 ff       	sbrs	r25, 5
     4ca:	fd cf       	rjmp	.-6      	; 0x4c6 <USART_0_write+0x4>
		;
	USART0.TXDATAL = data;
     4cc:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <__TEXT_REGION_LENGTH__+0x700802>
     4d0:	08 95       	ret

000004d2 <USART_0_printCHAR>:

#if defined(__GNUC__)

int USART_0_printCHAR(char character, FILE *stream)
{
	USART_0_write(character);
     4d2:	f7 df       	rcall	.-18     	; 0x4c2 <USART_0_write>
	return 0;
}
     4d4:	80 e0       	ldi	r24, 0x00	; 0
     4d6:	90 e0       	ldi	r25, 0x00	; 0
     4d8:	08 95       	ret

000004da <tinyCharge_is_charging>:
_Bool charging;

_Bool tinyCharge_is_charging(){
	return false;
	//return charging;
}
     4da:	80 e0       	ldi	r24, 0x00	; 0
     4dc:	08 95       	ret

000004de <tinyCharge_set_charging>:

void tinyCharge_set_charging(_Bool charging_status){
	charging = charging_status;
     4de:	80 93 62 3e 	sts	0x3E62, r24	; 0x803e62 <charging>
     4e2:	08 95       	ret

000004e4 <tinyCharge_set_transistors>:
}


void tinyCharge_set_transistors(){
	if(charging){
     4e4:	80 91 62 3e 	lds	r24, 0x3E62	; 0x803e62 <charging>
     4e8:	88 23       	and	r24, r24
     4ea:	11 f0       	breq	.+4      	; 0x4f0 <tinyCharge_set_transistors+0xc>
	} else {
		VPORTC.OUT &= ~(1 << pin);
     4ec:	4d 98       	cbi	0x09, 5	; 9
     4ee:	08 95       	ret
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     4f0:	4d 9a       	sbi	0x09, 5	; 9
     4f2:	08 95       	ret

000004f4 <tinyDebugger_send_int>:
	dtostrf(value,1,NUMBER_OF_DECIMALS, number);
	printf("%s:%s;", name, number);
}
void tinyDebugger_send_string(const char* name, char * value){
	printf("%s:%s;", name, value);
}
     4f4:	7f 93       	push	r23
     4f6:	6f 93       	push	r22
     4f8:	9f 93       	push	r25
     4fa:	8f 93       	push	r24
     4fc:	86 e6       	ldi	r24, 0x66	; 102
     4fe:	9f e9       	ldi	r25, 0x9F	; 159
     500:	9f 93       	push	r25
     502:	8f 93       	push	r24
     504:	09 d8       	rcall	.-4078   	; 0xfffff518 <__eeprom_end+0xff7ef518>
     506:	0f 90       	pop	r0
     508:	0f 90       	pop	r0
     50a:	0f 90       	pop	r0
     50c:	0f 90       	pop	r0
     50e:	0f 90       	pop	r0
     510:	0f 90       	pop	r0
     512:	08 95       	ret

00000514 <tinyDebugger_send_float>:
     514:	cf 92       	push	r12
     516:	df 92       	push	r13
     518:	ef 92       	push	r14
     51a:	ff 92       	push	r15
     51c:	0f 93       	push	r16
     51e:	1f 93       	push	r17
     520:	cf 93       	push	r28
     522:	df 93       	push	r29
     524:	cd b7       	in	r28, 0x3d	; 61
     526:	de b7       	in	r29, 0x3e	; 62
     528:	64 97       	sbiw	r28, 0x14	; 20
     52a:	cd bf       	out	0x3d, r28	; 61
     52c:	de bf       	out	0x3e, r29	; 62
     52e:	d8 2e       	mov	r13, r24
     530:	c9 2e       	mov	r12, r25
     532:	cb 01       	movw	r24, r22
     534:	ba 01       	movw	r22, r20
     536:	9e 01       	movw	r18, r28
     538:	2f 5f       	subi	r18, 0xFF	; 255
     53a:	3f 4f       	sbci	r19, 0xFF	; 255
     53c:	79 01       	movw	r14, r18
     53e:	89 01       	movw	r16, r18
     540:	21 e0       	ldi	r18, 0x01	; 1
     542:	41 e0       	ldi	r20, 0x01	; 1
     544:	a9 d6       	rcall	.+3410   	; 0x1298 <dtostrf>
     546:	ff 92       	push	r15
     548:	ef 92       	push	r14
     54a:	cf 92       	push	r12
     54c:	df 92       	push	r13
     54e:	8d e6       	ldi	r24, 0x6D	; 109
     550:	9f e9       	ldi	r25, 0x9F	; 159
     552:	9f 93       	push	r25
     554:	8f 93       	push	r24
     556:	e0 d7       	rcall	.+4032   	; 0x1518 <printf>
     558:	0f 90       	pop	r0
     55a:	0f 90       	pop	r0
     55c:	0f 90       	pop	r0
     55e:	0f 90       	pop	r0
     560:	0f 90       	pop	r0
     562:	0f 90       	pop	r0
     564:	64 96       	adiw	r28, 0x14	; 20
     566:	cd bf       	out	0x3d, r28	; 61
     568:	de bf       	out	0x3e, r29	; 62
     56a:	df 91       	pop	r29
     56c:	cf 91       	pop	r28
     56e:	1f 91       	pop	r17
     570:	0f 91       	pop	r16
     572:	ff 90       	pop	r15
     574:	ef 90       	pop	r14
     576:	df 90       	pop	r13
     578:	cf 90       	pop	r12
     57a:	08 95       	ret

0000057c <tinyDebugger_end_line>:
void tinyDebugger_end_line(){
	printf("\r\n");
     57c:	84 e7       	ldi	r24, 0x74	; 116
     57e:	9f e9       	ldi	r25, 0x9F	; 159
     580:	de d7       	rcall	.+4028   	; 0x153e <puts>
     582:	08 95       	ret

00000584 <tinyPulse_toggle_pulse_mode>:
uint32_t time_of_last_pulse = 0;
uint16_t time_since_last_pulse = 0;
uint16_t ideal_time_between_pulses = 1000/PULSEMODE_FREQUENCY;

void tinyPulse_toggle_pulse_mode(){
	pulse_mode = !pulse_mode;
     584:	90 91 22 3e 	lds	r25, 0x3E22	; 0x803e22 <pulse_mode>
     588:	81 e0       	ldi	r24, 0x01	; 1
     58a:	89 27       	eor	r24, r25
     58c:	80 93 22 3e 	sts	0x3E22, r24	; 0x803e22 <pulse_mode>
     590:	08 95       	ret

00000592 <tinyPulse_update_potential>:
}

double tinyPulse_update_potential(double potential){
     592:	cf 92       	push	r12
     594:	df 92       	push	r13
     596:	ef 92       	push	r14
     598:	ff 92       	push	r15
     59a:	6b 01       	movw	r12, r22
     59c:	7c 01       	movw	r14, r24
	if(pulse_mode){
     59e:	80 91 22 3e 	lds	r24, 0x3E22	; 0x803e22 <pulse_mode>
     5a2:	88 23       	and	r24, r24
     5a4:	21 f1       	breq	.+72     	; 0x5ee <tinyPulse_update_potential+0x5c>
		
		time_since_last_pulse = tinyTime_now() - time_of_last_pulse;
     5a6:	3e d0       	rcall	.+124    	; 0x624 <tinyTime_now>
     5a8:	20 91 1e 3e 	lds	r18, 0x3E1E	; 0x803e1e <time_of_last_pulse>
     5ac:	30 91 1f 3e 	lds	r19, 0x3E1F	; 0x803e1f <time_of_last_pulse+0x1>
     5b0:	62 1b       	sub	r22, r18
     5b2:	73 0b       	sbc	r23, r19
     5b4:	60 93 1c 3e 	sts	0x3E1C, r22	; 0x803e1c <__data_end>
     5b8:	70 93 1d 3e 	sts	0x3E1D, r23	; 0x803e1d <__data_end+0x1>
		
		if(time_since_last_pulse >= ideal_time_between_pulses){
     5bc:	80 91 14 3e 	lds	r24, 0x3E14	; 0x803e14 <ideal_time_between_pulses>
     5c0:	90 91 15 3e 	lds	r25, 0x3E15	; 0x803e15 <ideal_time_between_pulses+0x1>
     5c4:	68 17       	cp	r22, r24
     5c6:	79 07       	cpc	r23, r25
     5c8:	90 f0       	brcs	.+36     	; 0x5ee <tinyPulse_update_potential+0x5c>
			potential += BUTTON_PRESS_REACTION;
     5ca:	20 e0       	ldi	r18, 0x00	; 0
     5cc:	30 e0       	ldi	r19, 0x00	; 0
     5ce:	40 ed       	ldi	r20, 0xD0	; 208
     5d0:	51 e4       	ldi	r21, 0x41	; 65
     5d2:	c7 01       	movw	r24, r14
     5d4:	b6 01       	movw	r22, r12
     5d6:	d6 d3       	rcall	.+1964   	; 0xd84 <__addsf3>
     5d8:	6b 01       	movw	r12, r22
     5da:	7c 01       	movw	r14, r24
			time_of_last_pulse = tinyTime_now();			
     5dc:	23 d0       	rcall	.+70     	; 0x624 <tinyTime_now>
     5de:	60 93 1e 3e 	sts	0x3E1E, r22	; 0x803e1e <time_of_last_pulse>
     5e2:	70 93 1f 3e 	sts	0x3E1F, r23	; 0x803e1f <time_of_last_pulse+0x1>
     5e6:	80 93 20 3e 	sts	0x3E20, r24	; 0x803e20 <time_of_last_pulse+0x2>
     5ea:	90 93 21 3e 	sts	0x3E21, r25	; 0x803e21 <time_of_last_pulse+0x3>
		}
	}
	return potential;
}
     5ee:	c7 01       	movw	r24, r14
     5f0:	b6 01       	movw	r22, r12
     5f2:	ff 90       	pop	r15
     5f4:	ef 90       	pop	r14
     5f6:	df 90       	pop	r13
     5f8:	cf 90       	pop	r12
     5fa:	08 95       	ret

000005fc <tinyTime_counter_increment>:
If the Interrupt Service Routine is clocked by a crystal oscillator
it gives a very precise timer-counter.
*/
void tinyTime_counter_increment(void)
{
	time_counter++;
     5fc:	80 91 23 3e 	lds	r24, 0x3E23	; 0x803e23 <time_counter>
     600:	90 91 24 3e 	lds	r25, 0x3E24	; 0x803e24 <time_counter+0x1>
     604:	a0 91 25 3e 	lds	r26, 0x3E25	; 0x803e25 <time_counter+0x2>
     608:	b0 91 26 3e 	lds	r27, 0x3E26	; 0x803e26 <time_counter+0x3>
     60c:	01 96       	adiw	r24, 0x01	; 1
     60e:	a1 1d       	adc	r26, r1
     610:	b1 1d       	adc	r27, r1
     612:	80 93 23 3e 	sts	0x3E23, r24	; 0x803e23 <time_counter>
     616:	90 93 24 3e 	sts	0x3E24, r25	; 0x803e24 <time_counter+0x1>
     61a:	a0 93 25 3e 	sts	0x3E25, r26	; 0x803e25 <time_counter+0x2>
     61e:	b0 93 26 3e 	sts	0x3E26, r27	; 0x803e26 <time_counter+0x3>
     622:	08 95       	ret

00000624 <tinyTime_now>:
/*
This function is callable by external libraries to give them the counted time so far.
*/
uint32_t tinyTime_now(void)
{
	return time_counter;
     624:	60 91 23 3e 	lds	r22, 0x3E23	; 0x803e23 <time_counter>
     628:	70 91 24 3e 	lds	r23, 0x3E24	; 0x803e24 <time_counter+0x1>
     62c:	80 91 25 3e 	lds	r24, 0x3E25	; 0x803e25 <time_counter+0x2>
     630:	90 91 26 3e 	lds	r25, 0x3E26	; 0x803e26 <time_counter+0x3>
     634:	08 95       	ret

00000636 <main>:


int main(void)
{	
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
     636:	97 dd       	rcall	.-1234   	; 0x166 <atmel_start_init>
	Setting this value will mean that the ADC (Analog to Digital Converter) will read 4.32v as 255, and 0v as 0.
	For some reason, instead of the reference voltage being 4.32v, it is 3.3v. 
	A plausible explanation is that the microchip does not up the voltage, so that if the microchip is only ever 
	supplied with 3.3v, it will output 3.3v as the max.
	*/
	VREF.CTRLA = VREF_ADC0REFSEL_4V34_gc;
     638:	80 e3       	ldi	r24, 0x30	; 48
     63a:	80 93 a0 00 	sts	0x00A0, r24	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
	while (1)
	{
		// We don't want to update the neuron too often because of various reasons. The tinyISR_getflag is set every ms, and so the loop is only run once every ms.  
		if(tinyISR_getflag())
     63e:	4b d3       	rcall	.+1686   	; 0xcd6 <tinyISR_getflag>
     640:	88 23       	and	r24, r24
     642:	e9 f3       	breq	.-6      	; 0x63e <main+0x8>
		{			
			
			if(tinyCharge_is_charging()){
     644:	4a df       	rcall	.-364    	; 0x4da <tinyCharge_is_charging>
     646:	88 23       	and	r24, r24
     648:	11 f0       	breq	.+4      	; 0x64e <main+0x18>
				// Charge loop
				
				// We check the Dendrites in order to detect if we have stopped charging
				tinyDendrite_update_signals();
     64a:	25 d2       	rcall	.+1098   	; 0xa96 <tinyDendrite_update_signals>
     64c:	02 c0       	rjmp	.+4      	; 0x652 <main+0x1c>
				// Update led
				
			}
			else{
				// Main loop				
				tinyButton_update();
     64e:	aa d0       	rcall	.+340    	; 0x7a4 <tinyButton_update>
				
				tinyPotential_update();
     650:	45 d3       	rcall	.+1674   	; 0xcdc <tinyPotential_update>
			}
			
			
			// Switch transistors
			tinyCharge_set_transistors();
     652:	48 df       	rcall	.-368    	; 0x4e4 <tinyCharge_set_transistors>
			
			// Prepare for next cycle
			tinyISR_setflag(false);
     654:	80 e0       	ldi	r24, 0x00	; 0
     656:	3c d3       	rcall	.+1656   	; 0xcd0 <tinyISR_setflag>
			tinyDebugger_send_int("time", tinyTime_now());
     658:	e5 df       	rcall	.-54     	; 0x624 <tinyTime_now>
     65a:	86 e7       	ldi	r24, 0x76	; 118
     65c:	9f e9       	ldi	r25, 0x9F	; 159
     65e:	4a df       	rcall	.-364    	; 0x4f4 <tinyDebugger_send_int>
			tinyDebugger_end_line();
     660:	8d df       	rcall	.-230    	; 0x57c <tinyDebugger_end_line>
     662:	ed cf       	rjmp	.-38     	; 0x63e <main+0x8>

00000664 <set_LED_fire>:



//function to be called upon when firing flag has been raised.
void set_LED_fire(void)
{
     664:	cf 93       	push	r28
	fire_flash_time_counter = tinyTime_now();
     666:	de df       	rcall	.-68     	; 0x624 <tinyTime_now>
     668:	60 93 27 3e 	sts	0x3E27, r22	; 0x803e27 <fire_flash_time_counter>
     66c:	70 93 28 3e 	sts	0x3E28, r23	; 0x803e28 <fire_flash_time_counter+0x1>
     670:	80 93 29 3e 	sts	0x3E29, r24	; 0x803e29 <fire_flash_time_counter+0x2>
     674:	90 93 2a 3e 	sts	0x3E2A, r25	; 0x803e2a <fire_flash_time_counter+0x3>
     678:	c0 e0       	ldi	r28, 0x00	; 0
	for (int i = 0; i < NUMBER_OF_LEDS; i++)
	{
		tinyCCLRGB_setColor(i, MAX_BRIGHTNESS, MAX_BRIGHTNESS, MAX_BRIGHTNESS);//As per the specs, all LEDs should be blue while firing.
     67a:	20 e3       	ldi	r18, 0x30	; 48
     67c:	40 e3       	ldi	r20, 0x30	; 48
     67e:	60 e3       	ldi	r22, 0x30	; 48
     680:	8c 2f       	mov	r24, r28
     682:	fc d0       	rcall	.+504    	; 0x87c <tinyCCLRGB_setColor>
     684:	cf 5f       	subi	r28, 0xFF	; 255

//function to be called upon when firing flag has been raised.
void set_LED_fire(void)
{
	fire_flash_time_counter = tinyTime_now();
	for (int i = 0; i < NUMBER_OF_LEDS; i++)
     686:	c6 30       	cpi	r28, 0x06	; 6
     688:	c1 f7       	brne	.-16     	; 0x67a <set_LED_fire+0x16>
	{
		tinyCCLRGB_setColor(i, MAX_BRIGHTNESS, MAX_BRIGHTNESS, MAX_BRIGHTNESS);//As per the specs, all LEDs should be blue while firing.
	}
}
     68a:	cf 91       	pop	r28
     68c:	08 95       	ret

0000068e <potential_to_RGB_update_LEDs>:



void potential_to_RGB_update_LEDs(double potential)
{
     68e:	8f 92       	push	r8
     690:	9f 92       	push	r9
     692:	af 92       	push	r10
     694:	bf 92       	push	r11
     696:	cf 92       	push	r12
     698:	df 92       	push	r13
     69a:	ef 92       	push	r14
     69c:	ff 92       	push	r15
     69e:	0f 93       	push	r16
     6a0:	1f 93       	push	r17
     6a2:	cf 93       	push	r28
     6a4:	6b 01       	movw	r12, r22
     6a6:	7c 01       	movw	r14, r24
	if ((tinyTime_now() - fire_flash_time_counter) < FIRE_FLASH_TIME)
     6a8:	bd df       	rcall	.-134    	; 0x624 <tinyTime_now>
     6aa:	00 91 27 3e 	lds	r16, 0x3E27	; 0x803e27 <fire_flash_time_counter>
     6ae:	10 91 28 3e 	lds	r17, 0x3E28	; 0x803e28 <fire_flash_time_counter+0x1>
     6b2:	20 91 29 3e 	lds	r18, 0x3E29	; 0x803e29 <fire_flash_time_counter+0x2>
     6b6:	30 91 2a 3e 	lds	r19, 0x3E2A	; 0x803e2a <fire_flash_time_counter+0x3>
     6ba:	dc 01       	movw	r26, r24
     6bc:	cb 01       	movw	r24, r22
     6be:	80 1b       	sub	r24, r16
     6c0:	91 0b       	sbc	r25, r17
     6c2:	a2 0b       	sbc	r26, r18
     6c4:	b3 0b       	sbc	r27, r19
     6c6:	84 36       	cpi	r24, 0x64	; 100
     6c8:	91 05       	cpc	r25, r1
     6ca:	a1 05       	cpc	r26, r1
     6cc:	b1 05       	cpc	r27, r1
     6ce:	50 f4       	brcc	.+20     	; 0x6e4 <potential_to_RGB_update_LEDs+0x56>
     6d0:	c0 e0       	ldi	r28, 0x00	; 0
	{
		for (int i = 0; i < NUMBER_OF_LEDS; i++)
		{
			tinyCCLRGB_setColor(i, MAX_BRIGHTNESS, MAX_BRIGHTNESS, MAX_BRIGHTNESS);
     6d2:	20 e3       	ldi	r18, 0x30	; 48
     6d4:	40 e3       	ldi	r20, 0x30	; 48
     6d6:	60 e3       	ldi	r22, 0x30	; 48
     6d8:	8c 2f       	mov	r24, r28
     6da:	d0 d0       	rcall	.+416    	; 0x87c <tinyCCLRGB_setColor>
     6dc:	cf 5f       	subi	r28, 0xFF	; 255

void potential_to_RGB_update_LEDs(double potential)
{
	if ((tinyTime_now() - fire_flash_time_counter) < FIRE_FLASH_TIME)
	{
		for (int i = 0; i < NUMBER_OF_LEDS; i++)
     6de:	c6 30       	cpi	r28, 0x06	; 6
     6e0:	c1 f7       	brne	.-16     	; 0x6d2 <potential_to_RGB_update_LEDs+0x44>
     6e2:	53 c0       	rjmp	.+166    	; 0x78a <potential_to_RGB_update_LEDs+0xfc>
     6e4:	c0 e0       	ldi	r28, 0x00	; 0
*/
static void potential_to_RGB_set_color(double potential)
{
	for (int i = 0; i < NUMBER_OF_LEDS; i++)
	{
		tinyCCLRGB_setColor(i, 0x0, 0x0, 0x0);//Clear all LED stored values on the MCU before writing again.
     6e6:	20 e0       	ldi	r18, 0x00	; 0
     6e8:	40 e0       	ldi	r20, 0x00	; 0
     6ea:	60 e0       	ldi	r22, 0x00	; 0
     6ec:	8c 2f       	mov	r24, r28
     6ee:	c6 d0       	rcall	.+396    	; 0x87c <tinyCCLRGB_setColor>
     6f0:	cf 5f       	subi	r28, 0xFF	; 255
When firing all lights turn blue for ~100ms, but this needs to be tested.
LEDs are numbered right way on top of PCB, but opposite way on bottom of PCB.
*/
static void potential_to_RGB_set_color(double potential)
{
	for (int i = 0; i < NUMBER_OF_LEDS; i++)
     6f2:	c6 30       	cpi	r28, 0x06	; 6
     6f4:	c1 f7       	brne	.-16     	; 0x6e6 <potential_to_RGB_update_LEDs+0x58>
	{
		tinyCCLRGB_setColor(i, 0x0, 0x0, 0x0);//Clear all LED stored values on the MCU before writing again.
	}
	double absolute_potential = abs(potential);//setting variable for absolute potential so it won't have to be calculated more than once.
     6f6:	c7 01       	movw	r24, r14
     6f8:	b6 01       	movw	r22, r12
     6fa:	27 d4       	rcall	.+2126   	; 0xf4a <__fixsfsi>
     6fc:	9b 01       	movw	r18, r22
     6fe:	77 23       	and	r23, r23
     700:	24 f4       	brge	.+8      	; 0x70a <potential_to_RGB_update_LEDs+0x7c>
     702:	22 27       	eor	r18, r18
     704:	33 27       	eor	r19, r19
     706:	26 1b       	sub	r18, r22
     708:	37 0b       	sbc	r19, r23
     70a:	b9 01       	movw	r22, r18
     70c:	33 0f       	add	r19, r19
     70e:	88 0b       	sbc	r24, r24
     710:	99 0b       	sbc	r25, r25
     712:	53 d4       	rcall	.+2214   	; 0xfba <__floatsisf>
     714:	4b 01       	movw	r8, r22
     716:	5c 01       	movw	r10, r24
	if (absolute_potential < 1)//set the middle lights as white both top side and bottom side.
     718:	20 e0       	ldi	r18, 0x00	; 0
     71a:	30 e0       	ldi	r19, 0x00	; 0
     71c:	40 e8       	ldi	r20, 0x80	; 128
     71e:	5f e3       	ldi	r21, 0x3F	; 63
     720:	9d d3       	rcall	.+1850   	; 0xe5c <__cmpsf2>
     722:	88 23       	and	r24, r24
     724:	34 f4       	brge	.+12     	; 0x732 <potential_to_RGB_update_LEDs+0xa4>
	{
		tinyCCLRGB_setColor(2, MAX_BRIGHTNESS/3, MAX_BRIGHTNESS/3, MAX_BRIGHTNESS/3);
     726:	20 e1       	ldi	r18, 0x10	; 16
     728:	40 e1       	ldi	r20, 0x10	; 16
     72a:	60 e1       	ldi	r22, 0x10	; 16
     72c:	82 e0       	ldi	r24, 0x02	; 2
     72e:	a6 d0       	rcall	.+332    	; 0x87c <tinyCCLRGB_setColor>
     730:	2c c0       	rjmp	.+88     	; 0x78a <potential_to_RGB_update_LEDs+0xfc>
		//tinyCCLRGB_setColor(4, max_brightness/3, max_brightness/3, max_brightness/3);
	}
	else
	{
		uint8_t brightness_intensity = round((absolute_potential/25)*MAX_BRIGHTNESS);//brightness intensity for the LED that shows potential.
     732:	20 e0       	ldi	r18, 0x00	; 0
     734:	30 e0       	ldi	r19, 0x00	; 0
     736:	48 ec       	ldi	r20, 0xC8	; 200
     738:	51 e4       	ldi	r21, 0x41	; 65
     73a:	c5 01       	movw	r24, r10
     73c:	b4 01       	movw	r22, r8
     73e:	93 d3       	rcall	.+1830   	; 0xe66 <__divsf3>
     740:	20 e0       	ldi	r18, 0x00	; 0
     742:	30 e0       	ldi	r19, 0x00	; 0
     744:	40 e4       	ldi	r20, 0x40	; 64
     746:	52 e4       	ldi	r21, 0x42	; 66
     748:	ed d4       	rcall	.+2522   	; 0x1124 <__mulsf3>
     74a:	59 d5       	rcall	.+2738   	; 0x11fe <round>
     74c:	05 d4       	rcall	.+2058   	; 0xf58 <__fixunssfsi>
     74e:	c6 2f       	mov	r28, r22
		if (potential < 0)
     750:	20 e0       	ldi	r18, 0x00	; 0
     752:	30 e0       	ldi	r19, 0x00	; 0
     754:	a9 01       	movw	r20, r18
     756:	c7 01       	movw	r24, r14
     758:	b6 01       	movw	r22, r12
     75a:	80 d3       	rcall	.+1792   	; 0xe5c <__cmpsf2>
     75c:	88 23       	and	r24, r24
     75e:	5c f4       	brge	.+22     	; 0x776 <potential_to_RGB_update_LEDs+0xe8>
		{
			tinyCCLRGB_setColor(0, brightness_intensity, 0x0, 0x0);
     760:	20 e0       	ldi	r18, 0x00	; 0
     762:	40 e0       	ldi	r20, 0x00	; 0
     764:	6c 2f       	mov	r22, r28
     766:	80 e0       	ldi	r24, 0x00	; 0
     768:	89 d0       	rcall	.+274    	; 0x87c <tinyCCLRGB_setColor>
			tinyCCLRGB_setColor(1, brightness_intensity, 0x0, 0x0);//sets lower LEDs red if potential is negative.
     76a:	20 e0       	ldi	r18, 0x00	; 0
     76c:	40 e0       	ldi	r20, 0x00	; 0
     76e:	6c 2f       	mov	r22, r28
     770:	81 e0       	ldi	r24, 0x01	; 1
     772:	84 d0       	rcall	.+264    	; 0x87c <tinyCCLRGB_setColor>
     774:	0a c0       	rjmp	.+20     	; 0x78a <potential_to_RGB_update_LEDs+0xfc>
		} 
		else
		{
			tinyCCLRGB_setColor(3, 0x0, brightness_intensity, 0x0);//sets upper LEDs green if potential is positive.
     776:	20 e0       	ldi	r18, 0x00	; 0
     778:	4c 2f       	mov	r20, r28
     77a:	60 e0       	ldi	r22, 0x00	; 0
     77c:	83 e0       	ldi	r24, 0x03	; 3
     77e:	7e d0       	rcall	.+252    	; 0x87c <tinyCCLRGB_setColor>
			tinyCCLRGB_setColor(4, 0x0, brightness_intensity, 0x0);
     780:	20 e0       	ldi	r18, 0x00	; 0
     782:	4c 2f       	mov	r20, r28
     784:	60 e0       	ldi	r22, 0x00	; 0
     786:	84 e0       	ldi	r24, 0x04	; 4
     788:	79 d0       	rcall	.+242    	; 0x87c <tinyCCLRGB_setColor>
	}
	else
	{
		potential_to_RGB_set_color(potential);
	}
	tinyCCLRGB_uploadColorsToLeds();
     78a:	85 d0       	rcall	.+266    	; 0x896 <tinyCCLRGB_uploadColorsToLeds>
}
     78c:	cf 91       	pop	r28
     78e:	1f 91       	pop	r17
     790:	0f 91       	pop	r16
     792:	ff 90       	pop	r15
     794:	ef 90       	pop	r14
     796:	df 90       	pop	r13
     798:	cf 90       	pop	r12
     79a:	bf 90       	pop	r11
     79c:	af 90       	pop	r10
     79e:	9f 90       	pop	r9
     7a0:	8f 90       	pop	r8
     7a2:	08 95       	ret

000007a4 <tinyButton_update>:
/*
If the button has been let go, we change button_press to true. This only lasts one cycle, before it is set to false again.
If the button is held down for longer than PULSEMODE_BUTTON_PRESS_TIME, we toggle the pulse mode state.
*/
void tinyButton_update(void)
{
     7a4:	0f 93       	push	r16
     7a6:	1f 93       	push	r17
     7a8:	cf 93       	push	r28
     7aa:	df 93       	push	r29
	button_press = false;
     7ac:	10 92 2f 3e 	sts	0x3E2F, r1	; 0x803e2f <button_press>
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTC_get_pin_level(const uint8_t pin)
{
	return VPORTC.IN & (1 << pin);
     7b0:	8a b1       	in	r24, 0x0a	; 10
	_Bool button_is_pushed_down = !BUTTON_PIN_get_level(); // The digital port will be read as low if the button is pushed down.
     7b2:	d1 e0       	ldi	r29, 0x01	; 1
     7b4:	c8 2f       	mov	r28, r24
     7b6:	c4 70       	andi	r28, 0x04	; 4
     7b8:	82 fd       	sbrc	r24, 2
     7ba:	d0 e0       	ldi	r29, 0x00	; 0

	if (button_is_pushed_down && !button_was_pushed_down)
     7bc:	c1 11       	cpse	r28, r1
     7be:	30 c0       	rjmp	.+96     	; 0x820 <tinyButton_update+0x7c>
     7c0:	80 91 30 3e 	lds	r24, 0x3E30	; 0x803e30 <button_was_pushed_down>
     7c4:	81 11       	cpse	r24, r1
     7c6:	0d c0       	rjmp	.+26     	; 0x7e2 <tinyButton_update+0x3e>
	{
		tinyButton_start_time = tinyTime_now();
     7c8:	2d df       	rcall	.-422    	; 0x624 <tinyTime_now>
     7ca:	60 93 2b 3e 	sts	0x3E2B, r22	; 0x803e2b <tinyButton_start_time>
     7ce:	70 93 2c 3e 	sts	0x3E2C, r23	; 0x803e2c <tinyButton_start_time+0x1>
     7d2:	80 93 2d 3e 	sts	0x3E2D, r24	; 0x803e2d <tinyButton_start_time+0x2>
     7d6:	90 93 2e 3e 	sts	0x3E2E, r25	; 0x803e2e <tinyButton_start_time+0x3>
	}
	if (button_is_pushed_down && button_was_pushed_down)
     7da:	80 91 30 3e 	lds	r24, 0x3E30	; 0x803e30 <button_was_pushed_down>
     7de:	88 23       	and	r24, r24
     7e0:	41 f1       	breq	.+80     	; 0x832 <tinyButton_update+0x8e>
	{
		if ((tinyTime_now() - tinyButton_start_time) > PULSEMODE_BUTTON_PRESS_TIME)
     7e2:	20 df       	rcall	.-448    	; 0x624 <tinyTime_now>
     7e4:	00 91 2b 3e 	lds	r16, 0x3E2B	; 0x803e2b <tinyButton_start_time>
     7e8:	10 91 2c 3e 	lds	r17, 0x3E2C	; 0x803e2c <tinyButton_start_time+0x1>
     7ec:	20 91 2d 3e 	lds	r18, 0x3E2D	; 0x803e2d <tinyButton_start_time+0x2>
     7f0:	30 91 2e 3e 	lds	r19, 0x3E2E	; 0x803e2e <tinyButton_start_time+0x3>
     7f4:	60 1b       	sub	r22, r16
     7f6:	71 0b       	sbc	r23, r17
     7f8:	82 0b       	sbc	r24, r18
     7fa:	93 0b       	sbc	r25, r19
     7fc:	dc d3       	rcall	.+1976   	; 0xfb6 <__floatunsisf>
     7fe:	20 e0       	ldi	r18, 0x00	; 0
     800:	30 e0       	ldi	r19, 0x00	; 0
     802:	40 ea       	ldi	r20, 0xA0	; 160
     804:	51 e4       	ldi	r21, 0x41	; 65
     806:	89 d4       	rcall	.+2322   	; 0x111a <__gesf2>
     808:	18 16       	cp	r1, r24
     80a:	54 f4       	brge	.+20     	; 0x820 <tinyButton_update+0x7c>
		{
			tinyPulse_toggle_pulse_mode();
     80c:	bb de       	rcall	.-650    	; 0x584 <tinyPulse_toggle_pulse_mode>
			tinyButton_start_time = tinyTime_now();
     80e:	0a df       	rcall	.-492    	; 0x624 <tinyTime_now>
     810:	60 93 2b 3e 	sts	0x3E2B, r22	; 0x803e2b <tinyButton_start_time>
     814:	70 93 2c 3e 	sts	0x3E2C, r23	; 0x803e2c <tinyButton_start_time+0x1>
     818:	80 93 2d 3e 	sts	0x3E2D, r24	; 0x803e2d <tinyButton_start_time+0x2>
     81c:	90 93 2e 3e 	sts	0x3E2E, r25	; 0x803e2e <tinyButton_start_time+0x3>
		}
	}
	if (!button_is_pushed_down && button_was_pushed_down)
     820:	cc 23       	and	r28, r28
     822:	39 f0       	breq	.+14     	; 0x832 <tinyButton_update+0x8e>
     824:	80 91 30 3e 	lds	r24, 0x3E30	; 0x803e30 <button_was_pushed_down>
     828:	88 23       	and	r24, r24
     82a:	19 f0       	breq	.+6      	; 0x832 <tinyButton_update+0x8e>
	{
		button_press = true;
     82c:	81 e0       	ldi	r24, 0x01	; 1
     82e:	80 93 2f 3e 	sts	0x3E2F, r24	; 0x803e2f <button_press>
	}
	button_was_pushed_down = button_is_pushed_down;
     832:	d0 93 30 3e 	sts	0x3E30, r29	; 0x803e30 <button_was_pushed_down>
}
     836:	df 91       	pop	r29
     838:	cf 91       	pop	r28
     83a:	1f 91       	pop	r17
     83c:	0f 91       	pop	r16
     83e:	08 95       	ret

00000840 <tinyButton_update_potential>:

double tinyButton_update_potential(double potential){
	if(button_press){
     840:	20 91 2f 3e 	lds	r18, 0x3E2F	; 0x803e2f <button_press>
     844:	22 23       	and	r18, r18
     846:	29 f0       	breq	.+10     	; 0x852 <tinyButton_update_potential+0x12>
		potential += BUTTON_PRESS_REACTION;
     848:	20 e0       	ldi	r18, 0x00	; 0
     84a:	30 e0       	ldi	r19, 0x00	; 0
     84c:	40 ed       	ldi	r20, 0xD0	; 208
     84e:	51 e4       	ldi	r21, 0x41	; 65
     850:	99 d2       	rcall	.+1330   	; 0xd84 <__addsf3>
	}
	return potential;
}
     852:	08 95       	ret

00000854 <tinyCCLRGB_SPIWriteByte>:
Function used to send a byte over SPI, which in turn gets
translated to the bit-sequence required by the LEDs over the CCL.
*/
static void tinyCCLRGB_SPIWriteByte(uint8_t byte)
{
	SPI0.INTFLAGS = SPI0_INTFLAGS; // clear the write collision flag to allow writing
     854:	90 91 23 08 	lds	r25, 0x0823	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
     858:	90 93 23 08 	sts	0x0823, r25	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
	TCA0.SINGLE.CNT = 0; // reset TCA counter register to ensure the first rising edge of the PWM is predictable
     85c:	e0 e0       	ldi	r30, 0x00	; 0
     85e:	fa e0       	ldi	r31, 0x0A	; 10
     860:	10 a2       	std	Z+32, r1	; 0x20
     862:	11 a2       	std	Z+33, r1	; 0x21
	
	// start TCA
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 1 << TCA_SPLIT_ENABLE_bp;
     864:	91 e0       	ldi	r25, 0x01	; 1
     866:	90 83       	st	Z, r25
	SPI0_DATA = byte;
     868:	80 93 24 08 	sts	0x0824, r24	; 0x800824 <__TEXT_REGION_LENGTH__+0x700824>

	while((SPI0.INTFLAGS & SPI_RXCIE_bm) == 0){} // wait for transfer to complete
     86c:	e0 e2       	ldi	r30, 0x20	; 32
     86e:	f8 e0       	ldi	r31, 0x08	; 8
     870:	83 81       	ldd	r24, Z+3	; 0x03
     872:	88 23       	and	r24, r24
     874:	ec f7       	brge	.-6      	; 0x870 <tinyCCLRGB_SPIWriteByte+0x1c>
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 0 << TCA_SPLIT_ENABLE_bp; //Stop TCA
     876:	10 92 00 0a 	sts	0x0A00, r1	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
     87a:	08 95       	ret

0000087c <tinyCCLRGB_setColor>:
/*
changes the values in the variables stored in the led-array.
*/
void tinyCCLRGB_setColor(uint8_t led, uint8_t red, uint8_t green, uint8_t blue) 
{
	tinyCCLRGB_colors[led].red = red;
     87c:	90 e0       	ldi	r25, 0x00	; 0
     87e:	fc 01       	movw	r30, r24
     880:	ee 0f       	add	r30, r30
     882:	ff 1f       	adc	r31, r31
     884:	8e 0f       	add	r24, r30
     886:	9f 1f       	adc	r25, r31
     888:	fc 01       	movw	r30, r24
     88a:	ef 5c       	subi	r30, 0xCF	; 207
     88c:	f1 4c       	sbci	r31, 0xC1	; 193
     88e:	60 83       	st	Z, r22
	tinyCCLRGB_colors[led].green = green;
     890:	41 83       	std	Z+1, r20	; 0x01
	tinyCCLRGB_colors[led].blue = blue;
     892:	22 83       	std	Z+2, r18	; 0x02
     894:	08 95       	ret

00000896 <tinyCCLRGB_uploadColorsToLeds>:
/*
function to write the current LED-array on to the LEDs and
effectively update the values stored in the LEDs to the values stored in the MCU.
*/
void tinyCCLRGB_uploadColorsToLeds(void)
{
     896:	0f 93       	push	r16
     898:	1f 93       	push	r17
     89a:	cf 93       	push	r28
     89c:	df 93       	push	r29
     89e:	c1 e3       	ldi	r28, 0x31	; 49
     8a0:	de e3       	ldi	r29, 0x3E	; 62
     8a2:	03 e4       	ldi	r16, 0x43	; 67
     8a4:	1e e3       	ldi	r17, 0x3E	; 62
	for (uint8_t i = 0; i < TINYCCLRGB_LEDCOUNT; i++)
	{
		//For some reason unknown to the writer the data-bus to the LEDs is serialized as GRB
		//which means the 24-bit data-bus will look like [Green[0:7], Red[0:7], Blue[0:7]]
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].green);
     8a6:	89 81       	ldd	r24, Y+1	; 0x01
     8a8:	d5 df       	rcall	.-86     	; 0x854 <tinyCCLRGB_SPIWriteByte>
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].red);
     8aa:	88 81       	ld	r24, Y
     8ac:	d3 df       	rcall	.-90     	; 0x854 <tinyCCLRGB_SPIWriteByte>
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].blue);
     8ae:	8a 81       	ldd	r24, Y+2	; 0x02
     8b0:	d1 df       	rcall	.-94     	; 0x854 <tinyCCLRGB_SPIWriteByte>
     8b2:	23 96       	adiw	r28, 0x03	; 3
function to write the current LED-array on to the LEDs and
effectively update the values stored in the LEDs to the values stored in the MCU.
*/
void tinyCCLRGB_uploadColorsToLeds(void)
{
	for (uint8_t i = 0; i < TINYCCLRGB_LEDCOUNT; i++)
     8b4:	c0 17       	cp	r28, r16
     8b6:	d1 07       	cpc	r29, r17
     8b8:	b1 f7       	brne	.-20     	; 0x8a6 <tinyCCLRGB_uploadColorsToLeds+0x10>
		//which means the 24-bit data-bus will look like [Green[0:7], Red[0:7], Blue[0:7]]
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].green);
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].red);
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].blue);
	}
}
     8ba:	df 91       	pop	r29
     8bc:	cf 91       	pop	r28
     8be:	1f 91       	pop	r17
     8c0:	0f 91       	pop	r16
     8c2:	08 95       	ret

000008c4 <tinyAxon_remove_pulse>:
/*
solution to remove future firing if a inhibitory signal is received
shortly after a excitatory signal.
*/
bool tinyAxon_remove_pulse(void)
{
     8c4:	cf 92       	push	r12
     8c6:	df 92       	push	r13
     8c8:	ef 92       	push	r14
     8ca:	ff 92       	push	r15
	// We want to remove the pulse last added to the queue
	// We also want to return a bool indicating whether or not a pulse actually was removed
	uint32_t now = tinyTime_now();
     8cc:	ab de       	rcall	.-682    	; 0x624 <tinyTime_now>
     8ce:	6b 01       	movw	r12, r22
     8d0:	7c 01       	movw	r14, r24
	uint32_t pulse_time = dequeue_top(&pulse_queue);
     8d2:	84 e4       	ldi	r24, 0x44	; 68
     8d4:	9e e3       	ldi	r25, 0x3E	; 62
     8d6:	85 dd       	rcall	.-1270   	; 0x3e2 <dequeue_top>
	if(pulse_time == 0){ // Here, 0 is regarded as an error
     8d8:	61 15       	cp	r22, r1
     8da:	71 05       	cpc	r23, r1
     8dc:	81 05       	cpc	r24, r1
     8de:	91 05       	cpc	r25, r1
     8e0:	c1 f0       	breq	.+48     	; 0x912 <tinyAxon_remove_pulse+0x4e>
		return false;
	}
	
	// Now we want to check if the pulse is too far away to be affected by the low potential, or close enough that we decide to remove it
	// (When we say that the pulse is too far away, it refers to the biological process of how the potential spreads from Dendrites to axon)
	else if((now + UNDO_PERIOD) < pulse_time){
     8e2:	2c e3       	ldi	r18, 0x3C	; 60
     8e4:	c2 0e       	add	r12, r18
     8e6:	d1 1c       	adc	r13, r1
     8e8:	e1 1c       	adc	r14, r1
     8ea:	f1 1c       	adc	r15, r1
     8ec:	c6 16       	cp	r12, r22
     8ee:	d7 06       	cpc	r13, r23
     8f0:	e8 06       	cpc	r14, r24
     8f2:	f9 06       	cpc	r15, r25
     8f4:	38 f4       	brcc	.+14     	; 0x904 <tinyAxon_remove_pulse+0x40>
		// We decided to remove the pulse
		pulses_in_queue--;
     8f6:	80 91 46 3e 	lds	r24, 0x3E46	; 0x803e46 <pulses_in_queue>
     8fa:	81 50       	subi	r24, 0x01	; 1
     8fc:	80 93 46 3e 	sts	0x3E46, r24	; 0x803e46 <pulses_in_queue>
		return true;
     900:	81 e0       	ldi	r24, 0x01	; 1
     902:	08 c0       	rjmp	.+16     	; 0x914 <tinyAxon_remove_pulse+0x50>
	}
	// Here we have found that there is a pulse queued, but it is old enough to let pass anyway, so now we need to put it back into the queue
	else{
		enqueue(&pulse_queue, pulse_time);
     904:	ab 01       	movw	r20, r22
     906:	bc 01       	movw	r22, r24
     908:	84 e4       	ldi	r24, 0x44	; 68
     90a:	9e e3       	ldi	r25, 0x3E	; 62
     90c:	0e dd       	rcall	.-1508   	; 0x32a <enqueue>
		return false;
     90e:	80 e0       	ldi	r24, 0x00	; 0
     910:	01 c0       	rjmp	.+2      	; 0x914 <tinyAxon_remove_pulse+0x50>
	// We also want to return a bool indicating whether or not a pulse actually was removed
	uint32_t now = tinyTime_now();
	uint32_t pulse_time = dequeue_top(&pulse_queue);
	if(pulse_time == 0){ // Here, 0 is regarded as an error
		//There was no pulse to remove
		return false;
     912:	80 e0       	ldi	r24, 0x00	; 0
	// Here we have found that there is a pulse queued, but it is old enough to let pass anyway, so now we need to put it back into the queue
	else{
		enqueue(&pulse_queue, pulse_time);
		return false;
	}
}
     914:	ff 90       	pop	r15
     916:	ef 90       	pop	r14
     918:	df 90       	pop	r13
     91a:	cf 90       	pop	r12
     91c:	08 95       	ret

0000091e <tinyAxon_update_potential>:
/*
Decides whether or not the axon should fire
If the axon does fire, the potential is reduced
*/
double tinyAxon_update_potential(double potential)
{
     91e:	4f 92       	push	r4
     920:	5f 92       	push	r5
     922:	6f 92       	push	r6
     924:	7f 92       	push	r7
     926:	8f 92       	push	r8
     928:	9f 92       	push	r9
     92a:	af 92       	push	r10
     92c:	bf 92       	push	r11
     92e:	cf 92       	push	r12
     930:	df 92       	push	r13
     932:	ef 92       	push	r14
     934:	ff 92       	push	r15
     936:	cf 93       	push	r28
     938:	df 93       	push	r29
     93a:	6b 01       	movw	r12, r22
     93c:	7c 01       	movw	r14, r24
	int pulse_nr = 0;
	uint32_t now = tinyTime_now();
     93e:	72 de       	rcall	.-796    	; 0x624 <tinyTime_now>
     940:	2b 01       	movw	r4, r22
     942:	3c 01       	movw	r6, r24
	
	//While the neuron has enough potential to fire, we want to fire more
	while (potential > THRESHOLD_POTENTIAL)
     944:	20 e0       	ldi	r18, 0x00	; 0
     946:	30 e0       	ldi	r19, 0x00	; 0
     948:	48 ec       	ldi	r20, 0xC8	; 200
     94a:	51 e4       	ldi	r21, 0x41	; 65
     94c:	c7 01       	movw	r24, r14
     94e:	b6 01       	movw	r22, r12
     950:	e4 d3       	rcall	.+1992   	; 0x111a <__gesf2>
     952:	18 16       	cp	r1, r24
     954:	5c f5       	brge	.+86     	; 0x9ac <tinyAxon_update_potential+0x8e>
     956:	c0 e0       	ldi	r28, 0x00	; 0
     958:	d0 e0       	ldi	r29, 0x00	; 0
/*
Adds an element to the queue
*/
static void tinyAxon_enqueue_pulse(uint32_t new_pulse)
{
	enqueue(&pulse_queue, new_pulse);
     95a:	53 01       	movw	r10, r6
     95c:	42 01       	movw	r8, r4
     95e:	84 e6       	ldi	r24, 0x64	; 100
     960:	88 0e       	add	r8, r24
     962:	91 1c       	adc	r9, r1
     964:	a1 1c       	adc	r10, r1
     966:	b1 1c       	adc	r11, r1
     968:	ae 01       	movw	r20, r28
     96a:	0d 2e       	mov	r0, r29
     96c:	00 0c       	add	r0, r0
     96e:	66 0b       	sbc	r22, r22
     970:	77 0b       	sbc	r23, r23
     972:	48 0d       	add	r20, r8
     974:	59 1d       	adc	r21, r9
     976:	6a 1d       	adc	r22, r10
     978:	7b 1d       	adc	r23, r11
     97a:	84 e4       	ldi	r24, 0x44	; 68
     97c:	9e e3       	ldi	r25, 0x3E	; 62
     97e:	d5 dc       	rcall	.-1622   	; 0x32a <enqueue>
	pulses_in_queue++;
     980:	80 91 46 3e 	lds	r24, 0x3E46	; 0x803e46 <pulses_in_queue>
     984:	8f 5f       	subi	r24, 0xFF	; 255
     986:	80 93 46 3e 	sts	0x3E46, r24	; 0x803e46 <pulses_in_queue>
	{
		tinyAxon_enqueue_pulse(now + TRAVLE_DELAY + FIRE_DELAY*pulse_nr);
		pulse_nr++;
		
		// I want to test reducing the potential by -30 instead of -25 to simulate the hyperpolarization
		potential += POSTFIRE_POTENTIAL_REACTION; // This is usually defined as a negative value, don't be confused by the +=
     98a:	20 e0       	ldi	r18, 0x00	; 0
     98c:	30 e0       	ldi	r19, 0x00	; 0
     98e:	40 ef       	ldi	r20, 0xF0	; 240
     990:	51 e4       	ldi	r21, 0x41	; 65
     992:	c7 01       	movw	r24, r14
     994:	b6 01       	movw	r22, r12
     996:	f5 d1       	rcall	.+1002   	; 0xd82 <__subsf3>
     998:	6b 01       	movw	r12, r22
     99a:	7c 01       	movw	r14, r24
     99c:	e2 96       	adiw	r28, 0x32	; 50
{
	int pulse_nr = 0;
	uint32_t now = tinyTime_now();
	
	//While the neuron has enough potential to fire, we want to fire more
	while (potential > THRESHOLD_POTENTIAL)
     99e:	20 e0       	ldi	r18, 0x00	; 0
     9a0:	30 e0       	ldi	r19, 0x00	; 0
     9a2:	48 ec       	ldi	r20, 0xC8	; 200
     9a4:	51 e4       	ldi	r21, 0x41	; 65
     9a6:	b9 d3       	rcall	.+1906   	; 0x111a <__gesf2>
     9a8:	18 16       	cp	r1, r24
     9aa:	f4 f2       	brlt	.-68     	; 0x968 <tinyAxon_update_potential+0x4a>
		// I want to test reducing the potential by -30 instead of -25 to simulate the hyperpolarization
		potential += POSTFIRE_POTENTIAL_REACTION; // This is usually defined as a negative value, don't be confused by the +=
	}
	
	// If the neuron has a very low potential, we want to remove a pulse from the queue (if there is one)
	if(potential < -THRESHOLD_POTENTIAL && pulses_in_queue > 0) // Perhaps this should be a separate variable? For now, we will just simply use -THRESHOLD_POTENTIAL
     9ac:	20 e0       	ldi	r18, 0x00	; 0
     9ae:	30 e0       	ldi	r19, 0x00	; 0
     9b0:	48 ec       	ldi	r20, 0xC8	; 200
     9b2:	51 ec       	ldi	r21, 0xC1	; 193
     9b4:	c7 01       	movw	r24, r14
     9b6:	b6 01       	movw	r22, r12
     9b8:	51 d2       	rcall	.+1186   	; 0xe5c <__cmpsf2>
     9ba:	88 23       	and	r24, r24
     9bc:	84 f4       	brge	.+32     	; 0x9de <tinyAxon_update_potential+0xc0>
     9be:	80 91 46 3e 	lds	r24, 0x3E46	; 0x803e46 <pulses_in_queue>
     9c2:	88 23       	and	r24, r24
     9c4:	79 f1       	breq	.+94     	; 0xa24 <tinyAxon_update_potential+0x106>
	{
		// The neurons potential is low enough to attempt to remove a queued fire (Fire less)
		if(tinyAxon_remove_pulse())
     9c6:	7e df       	rcall	.-260    	; 0x8c4 <tinyAxon_remove_pulse>
     9c8:	88 23       	and	r24, r24
     9ca:	49 f0       	breq	.+18     	; 0x9de <tinyAxon_update_potential+0xc0>
		{
			// The potential has evened out a bit
			potential += THRESHOLD_POTENTIAL;
     9cc:	20 e0       	ldi	r18, 0x00	; 0
     9ce:	30 e0       	ldi	r19, 0x00	; 0
     9d0:	48 ec       	ldi	r20, 0xC8	; 200
     9d2:	51 e4       	ldi	r21, 0x41	; 65
     9d4:	c7 01       	movw	r24, r14
     9d6:	b6 01       	movw	r22, r12
     9d8:	d5 d1       	rcall	.+938    	; 0xd84 <__addsf3>
     9da:	6b 01       	movw	r12, r22
     9dc:	7c 01       	movw	r14, r24
		}
	}
	
	// If there are pulses in the queue, and the pulse has been scheduled to fire
	if ((pulses_in_queue > 0) && (next_pulse <= now))
     9de:	80 91 46 3e 	lds	r24, 0x3E46	; 0x803e46 <pulses_in_queue>
     9e2:	88 23       	and	r24, r24
     9e4:	f9 f0       	breq	.+62     	; 0xa24 <tinyAxon_update_potential+0x106>
     9e6:	40 91 63 3e 	lds	r20, 0x3E63	; 0x803e63 <next_pulse>
     9ea:	50 91 64 3e 	lds	r21, 0x3E64	; 0x803e64 <next_pulse+0x1>
     9ee:	60 91 65 3e 	lds	r22, 0x3E65	; 0x803e65 <next_pulse+0x2>
     9f2:	70 91 66 3e 	lds	r23, 0x3E66	; 0x803e66 <next_pulse+0x3>
     9f6:	44 16       	cp	r4, r20
     9f8:	55 06       	cpc	r5, r21
     9fa:	66 06       	cpc	r6, r22
     9fc:	77 06       	cpc	r7, r23
     9fe:	90 f0       	brcs	.+36     	; 0xa24 <tinyAxon_update_potential+0x106>
Function to set firing.
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
     a00:	91 e0       	ldi	r25, 0x01	; 1
     a02:	90 93 47 3e 	sts	0x3E47, r25	; 0x803e47 <tinyAxon_should_fire>
	pulses_in_queue--;
     a06:	81 50       	subi	r24, 0x01	; 1
     a08:	80 93 46 3e 	sts	0x3E46, r24	; 0x803e46 <pulses_in_queue>
	next_pulse = dequeue(&pulse_queue);
     a0c:	84 e4       	ldi	r24, 0x44	; 68
     a0e:	9e e3       	ldi	r25, 0x3E	; 62
     a10:	ac dc       	rcall	.-1704   	; 0x36a <dequeue>
     a12:	60 93 63 3e 	sts	0x3E63, r22	; 0x803e63 <next_pulse>
     a16:	70 93 64 3e 	sts	0x3E64, r23	; 0x803e64 <next_pulse+0x1>
     a1a:	80 93 65 3e 	sts	0x3E65, r24	; 0x803e65 <next_pulse+0x2>
     a1e:	90 93 66 3e 	sts	0x3E66, r25	; 0x803e66 <next_pulse+0x3>
	// If there are pulses in the queue, and the pulse has been scheduled to fire
	if ((pulses_in_queue > 0) && (next_pulse <= now))
	{
		// We fire the axon
		tinyAxon_fire_pulse();
		set_LED_fire();
     a22:	20 de       	rcall	.-960    	; 0x664 <set_LED_fire>
The function should set the DAC to fire for two
update cycles once the pulse flag is set high.
*/
static void tinyAxon_update_pulse_transmitter(void)
{
	if (tinyAxon_should_fire)
     a24:	80 91 47 3e 	lds	r24, 0x3E47	; 0x803e47 <tinyAxon_should_fire>
     a28:	88 23       	and	r24, r24
     a2a:	61 f0       	breq	.+24     	; 0xa44 <tinyAxon_update_potential+0x126>
	{
		tinyAxon_should_fire = false;
     a2c:	10 92 47 3e 	sts	0x3E47, r1	; 0x803e47 <tinyAxon_should_fire>
		tinyAxon_has_fired = true;
     a30:	81 e0       	ldi	r24, 0x01	; 1
     a32:	80 93 48 3e 	sts	0x3E48, r24	; 0x803e48 <tinyAxon_has_fired>
*/
static void tinyAxon_start_sending_pulse()
{
	if (NEURONTYPE == EXCITATORY_NEURON)
	{
		DAC_set_output(EXCITATORY_NEURON_OUTPUT);
     a36:	87 ed       	ldi	r24, 0xD7	; 215
     a38:	90 e0       	ldi	r25, 0x00	; 0
     a3a:	d5 db       	rcall	.-2134   	; 0x1e6 <DAC_set_output>
		axonOutputValue=EXCITATORY_NEURON_OUTPUT;
     a3c:	87 ed       	ldi	r24, 0xD7	; 215
     a3e:	80 93 43 3e 	sts	0x3E43, r24	; 0x803e43 <axonOutputValue>
     a42:	0c c0       	rjmp	.+24     	; 0xa5c <tinyAxon_update_potential+0x13e>
		tinyAxon_should_fire = false;
		tinyAxon_has_fired = true;
		
		tinyAxon_start_sending_pulse();
	}
	else if (tinyAxon_has_fired)
     a44:	80 91 48 3e 	lds	r24, 0x3E48	; 0x803e48 <tinyAxon_has_fired>
     a48:	88 23       	and	r24, r24
     a4a:	19 f0       	breq	.+6      	; 0xa52 <tinyAxon_update_potential+0x134>
	{
		tinyAxon_has_fired = false;
     a4c:	10 92 48 3e 	sts	0x3E48, r1	; 0x803e48 <tinyAxon_has_fired>
     a50:	05 c0       	rjmp	.+10     	; 0xa5c <tinyAxon_update_potential+0x13e>
}

static void tinyAxon_stop_sending_pulse()
{
	
	DAC_set_output(NO_SIGNAL_OUTPUT);
     a52:	80 e0       	ldi	r24, 0x00	; 0
     a54:	90 e0       	ldi	r25, 0x00	; 0
     a56:	c7 db       	rcall	.-2162   	; 0x1e6 <DAC_set_output>
	axonOutputValue=NO_SIGNAL_OUTPUT;
     a58:	10 92 43 3e 	sts	0x3E43, r1	; 0x803e43 <axonOutputValue>
	}
	
	// Here we set the actual output of the DAC (Digital to Analog Converter)
	tinyAxon_update_pulse_transmitter();
	
	tinyDebugger_send_int("Axon output", axonOutputValue);
     a5c:	60 91 43 3e 	lds	r22, 0x3E43	; 0x803e43 <axonOutputValue>
     a60:	70 e0       	ldi	r23, 0x00	; 0
     a62:	8b e7       	ldi	r24, 0x7B	; 123
     a64:	9f e9       	ldi	r25, 0x9F	; 159
     a66:	46 dd       	rcall	.-1396   	; 0x4f4 <tinyDebugger_send_int>
	tinyDebugger_send_int("Pulses in queue", pulses_in_queue);
     a68:	60 91 46 3e 	lds	r22, 0x3E46	; 0x803e46 <pulses_in_queue>
     a6c:	70 e0       	ldi	r23, 0x00	; 0
     a6e:	87 e8       	ldi	r24, 0x87	; 135
     a70:	9f e9       	ldi	r25, 0x9F	; 159
     a72:	40 dd       	rcall	.-1408   	; 0x4f4 <tinyDebugger_send_int>
	
	return potential;
}
     a74:	c7 01       	movw	r24, r14
     a76:	b6 01       	movw	r22, r12
     a78:	df 91       	pop	r29
     a7a:	cf 91       	pop	r28
     a7c:	ff 90       	pop	r15
     a7e:	ef 90       	pop	r14
     a80:	df 90       	pop	r13
     a82:	cf 90       	pop	r12
     a84:	bf 90       	pop	r11
     a86:	af 90       	pop	r10
     a88:	9f 90       	pop	r9
     a8a:	8f 90       	pop	r8
     a8c:	7f 90       	pop	r7
     a8e:	6f 90       	pop	r6
     a90:	5f 90       	pop	r5
     a92:	4f 90       	pop	r4
     a94:	08 95       	ret

00000a96 <tinyDendrite_update_signals>:
/*
This function converts the 8 bit value from the ADC into one of the signal types defined in DendriteSignal
We also update the charging state
*/
void tinyDendrite_update_signals(void)
{
     a96:	2f 92       	push	r2
     a98:	3f 92       	push	r3
     a9a:	4f 92       	push	r4
     a9c:	5f 92       	push	r5
     a9e:	6f 92       	push	r6
     aa0:	7f 92       	push	r7
     aa2:	8f 92       	push	r8
     aa4:	9f 92       	push	r9
     aa6:	af 92       	push	r10
     aa8:	bf 92       	push	r11
     aaa:	cf 92       	push	r12
     aac:	df 92       	push	r13
     aae:	ef 92       	push	r14
     ab0:	ff 92       	push	r15
     ab2:	0f 93       	push	r16
     ab4:	1f 93       	push	r17
     ab6:	cf 93       	push	r28
     ab8:	df 93       	push	r29
     aba:	06 e1       	ldi	r16, 0x16	; 22
     abc:	1e e3       	ldi	r17, 0x3E	; 62
     abe:	0f 2e       	mov	r0, r31
     ac0:	f3 e5       	ldi	r31, 0x53	; 83
     ac2:	cf 2e       	mov	r12, r31
     ac4:	fe e3       	ldi	r31, 0x3E	; 62
     ac6:	df 2e       	mov	r13, r31
     ac8:	f0 2d       	mov	r31, r0
     aca:	0f 2e       	mov	r0, r31
     acc:	fd e5       	ldi	r31, 0x5D	; 93
     ace:	ef 2e       	mov	r14, r31
     ad0:	fe e3       	ldi	r31, 0x3E	; 62
     ad2:	ff 2e       	mov	r15, r31
     ad4:	f0 2d       	mov	r31, r0
     ad6:	e6 01       	movw	r28, r12
*/
static void tinyDendrite_read_signals(void)
{
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_values[i] = ADC_get_conversion(Dendrite_ports[i]);
     ad8:	f8 01       	movw	r30, r16
     ada:	81 91       	ld	r24, Z+
     adc:	8f 01       	movw	r16, r30
     ade:	4e db       	rcall	.-2404   	; 0x17c <ADC_get_conversion>
     ae0:	89 93       	st	Y+, r24
     ae2:	99 93       	st	Y+, r25
/*
This function reads the voltage at the Dendrite inputs with the ADC
*/
static void tinyDendrite_read_signals(void)
{
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
     ae4:	ce 15       	cp	r28, r14
     ae6:	df 05       	cpc	r29, r15
     ae8:	b9 f7       	brne	.-18     	; 0xad8 <tinyDendrite_update_signals+0x42>
	{
		tinyDendrite_values[i] = ADC_get_conversion(Dendrite_ports[i]);
	}
	tinyDebugger_send_int("Dendrite1", tinyDendrite_values[0]);
     aea:	c3 e5       	ldi	r28, 0x53	; 83
     aec:	de e3       	ldi	r29, 0x3E	; 62
     aee:	68 81       	ld	r22, Y
     af0:	79 81       	ldd	r23, Y+1	; 0x01
     af2:	87 e9       	ldi	r24, 0x97	; 151
     af4:	9f e9       	ldi	r25, 0x9F	; 159
     af6:	fe dc       	rcall	.-1540   	; 0x4f4 <tinyDebugger_send_int>
	tinyDebugger_send_int("Dendrite2", tinyDendrite_values[1]);
     af8:	6a 81       	ldd	r22, Y+2	; 0x02
     afa:	7b 81       	ldd	r23, Y+3	; 0x03
     afc:	81 ea       	ldi	r24, 0xA1	; 161
     afe:	9f e9       	ldi	r25, 0x9F	; 159
     b00:	f9 dc       	rcall	.-1550   	; 0x4f4 <tinyDebugger_send_int>
	tinyDebugger_send_int("Dendrite3", tinyDendrite_values[2]);
     b02:	6c 81       	ldd	r22, Y+4	; 0x04
     b04:	7d 81       	ldd	r23, Y+5	; 0x05
     b06:	8b ea       	ldi	r24, 0xAB	; 171
     b08:	9f e9       	ldi	r25, 0x9F	; 159
     b0a:	f4 dc       	rcall	.-1560   	; 0x4f4 <tinyDebugger_send_int>
	tinyDebugger_send_int("Dendrite4", tinyDendrite_values[3]);
     b0c:	6e 81       	ldd	r22, Y+6	; 0x06
     b0e:	7f 81       	ldd	r23, Y+7	; 0x07
     b10:	85 eb       	ldi	r24, 0xB5	; 181
     b12:	9f e9       	ldi	r25, 0x9F	; 159
     b14:	ef dc       	rcall	.-1570   	; 0x4f4 <tinyDebugger_send_int>
	tinyDebugger_send_int("Dendrite5", tinyDendrite_values[4]);
     b16:	68 85       	ldd	r22, Y+8	; 0x08
     b18:	79 85       	ldd	r23, Y+9	; 0x09
     b1a:	8f eb       	ldi	r24, 0xBF	; 191
     b1c:	9f e9       	ldi	r25, 0x9F	; 159
     b1e:	ea dc       	rcall	.-1580   	; 0x4f4 <tinyDebugger_send_int>
{
	
	//Read the analog voltage values on each of the Dendrites
	tinyDendrite_read_signals();
	
	tinyCharge_set_charging(false);
     b20:	80 e0       	ldi	r24, 0x00	; 0
     b22:	dd dc       	rcall	.-1606   	; 0x4de <tinyCharge_set_charging>
     b24:	ce e4       	ldi	r28, 0x4E	; 78
     b26:	de e3       	ldi	r29, 0x3E	; 62
     b28:	09 e4       	ldi	r16, 0x49	; 73
     b2a:	1e e3       	ldi	r17, 0x3E	; 62
     b2c:	0f 2e       	mov	r0, r31
     b2e:	f3 e5       	ldi	r31, 0x53	; 83
     b30:	8f 2e       	mov	r8, r31
     b32:	fe e3       	ldi	r31, 0x3E	; 62
     b34:	9f 2e       	mov	r9, r31
     b36:	f0 2d       	mov	r31, r0
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     b38:	66 24       	eor	r6, r6
     b3a:	63 94       	inc	r6
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     b3c:	68 94       	set
     b3e:	22 24       	eor	r2, r2
     b40:	21 f8       	bld	r2, 1
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     b42:	68 94       	set
     b44:	33 24       	eor	r3, r3
     b46:	32 f8       	bld	r3, 2
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     b48:	0f 2e       	mov	r0, r31
     b4a:	f6 e0       	ldi	r31, 0x06	; 6
     b4c:	4f 2e       	mov	r4, r31
     b4e:	f0 2d       	mov	r31, r0
			tinyDendrite_current_signals[i] = CHARGING;
			tinyCharge_set_charging(true);
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     b50:	0f 2e       	mov	r0, r31
     b52:	f5 e0       	ldi	r31, 0x05	; 5
     b54:	7f 2e       	mov	r7, r31
     b56:	f0 2d       	mov	r31, r0
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = CHARGING;
     b58:	0f 2e       	mov	r0, r31
     b5a:	f7 e0       	ldi	r31, 0x07	; 7
     b5c:	5f 2e       	mov	r5, r31
     b5e:	f0 2d       	mov	r31, r0
     b60:	7e 01       	movw	r14, r28
     b62:	58 01       	movw	r10, r16
	
	tinyCharge_set_charging(false);
	
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
     b64:	88 81       	ld	r24, Y
     b66:	f8 01       	movw	r30, r16
     b68:	80 83       	st	Z, r24
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
     b6a:	f6 01       	movw	r30, r12
     b6c:	81 91       	ld	r24, Z+
     b6e:	91 91       	ld	r25, Z+
     b70:	6f 01       	movw	r12, r30
     b72:	89 3e       	cpi	r24, 0xE9	; 233
     b74:	91 05       	cpc	r25, r1
     b76:	20 f0       	brcs	.+8      	; 0xb80 <tinyDendrite_update_signals+0xea>
		{
			tinyDendrite_current_signals[i] = CHARGING;
     b78:	58 82       	st	Y, r5
			tinyCharge_set_charging(true);
     b7a:	86 2d       	mov	r24, r6
     b7c:	b0 dc       	rcall	.-1696   	; 0x4de <tinyCharge_set_charging>
     b7e:	1f c0       	rjmp	.+62     	; 0xbbe <tinyDendrite_update_signals+0x128>
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
     b80:	88 3c       	cpi	r24, 0xC8	; 200
     b82:	91 05       	cpc	r25, r1
     b84:	10 f0       	brcs	.+4      	; 0xb8a <tinyDendrite_update_signals+0xf4>
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     b86:	78 82       	st	Y, r7
     b88:	1a c0       	rjmp	.+52     	; 0xbbe <tinyDendrite_update_signals+0x128>
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
     b8a:	87 3a       	cpi	r24, 0xA7	; 167
     b8c:	91 05       	cpc	r25, r1
     b8e:	10 f0       	brcs	.+4      	; 0xb94 <tinyDendrite_update_signals+0xfe>
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     b90:	48 82       	st	Y, r4
     b92:	15 c0       	rjmp	.+42     	; 0xbbe <tinyDendrite_update_signals+0x128>
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
     b94:	85 38       	cpi	r24, 0x85	; 133
     b96:	91 05       	cpc	r25, r1
     b98:	10 f0       	brcs	.+4      	; 0xb9e <tinyDendrite_update_signals+0x108>
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     b9a:	38 82       	st	Y, r3
     b9c:	10 c0       	rjmp	.+32     	; 0xbbe <tinyDendrite_update_signals+0x128>
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
     b9e:	84 36       	cpi	r24, 0x64	; 100
     ba0:	91 05       	cpc	r25, r1
     ba2:	10 f0       	brcs	.+4      	; 0xba8 <tinyDendrite_update_signals+0x112>
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     ba4:	28 82       	st	Y, r2
     ba6:	0b c0       	rjmp	.+22     	; 0xbbe <tinyDendrite_update_signals+0x128>
		}
		else if (tinyDendrite_values[i] > HIGH_INHIB_THRESHOLD)
     ba8:	83 34       	cpi	r24, 0x43	; 67
     baa:	91 05       	cpc	r25, r1
     bac:	18 f0       	brcs	.+6      	; 0xbb4 <tinyDendrite_update_signals+0x11e>
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
     bae:	83 e0       	ldi	r24, 0x03	; 3
     bb0:	88 83       	st	Y, r24
     bb2:	05 c0       	rjmp	.+10     	; 0xbbe <tinyDendrite_update_signals+0x128>
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
     bb4:	82 97       	sbiw	r24, 0x22	; 34
     bb6:	10 f0       	brcs	.+4      	; 0xbbc <tinyDendrite_update_signals+0x126>
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     bb8:	68 82       	st	Y, r6
     bba:	01 c0       	rjmp	.+2      	; 0xbbe <tinyDendrite_update_signals+0x128>
		}
		else
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     bbc:	18 82       	st	Y, r1
     bbe:	0f 5f       	subi	r16, 0xFF	; 255
     bc0:	1f 4f       	sbci	r17, 0xFF	; 255
		}
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
     bc2:	f7 01       	movw	r30, r14
     bc4:	90 81       	ld	r25, Z
     bc6:	f5 01       	movw	r30, r10
     bc8:	80 81       	ld	r24, Z
     bca:	98 13       	cpse	r25, r24
     bcc:	02 c0       	rjmp	.+4      	; 0xbd2 <tinyDendrite_update_signals+0x13c>
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     bce:	f7 01       	movw	r30, r14
     bd0:	10 82       	st	Z, r1
     bd2:	21 96       	adiw	r28, 0x01	; 1
	//Read the analog voltage values on each of the Dendrites
	tinyDendrite_read_signals();
	
	tinyCharge_set_charging(false);
	
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
     bd4:	c8 15       	cp	r28, r8
     bd6:	d9 05       	cpc	r29, r9
     bd8:	19 f6       	brne	.-122    	; 0xb60 <tinyDendrite_update_signals+0xca>
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
		}
	}
}
     bda:	df 91       	pop	r29
     bdc:	cf 91       	pop	r28
     bde:	1f 91       	pop	r17
     be0:	0f 91       	pop	r16
     be2:	ff 90       	pop	r15
     be4:	ef 90       	pop	r14
     be6:	df 90       	pop	r13
     be8:	cf 90       	pop	r12
     bea:	bf 90       	pop	r11
     bec:	af 90       	pop	r10
     bee:	9f 90       	pop	r9
     bf0:	8f 90       	pop	r8
     bf2:	7f 90       	pop	r7
     bf4:	6f 90       	pop	r6
     bf6:	5f 90       	pop	r5
     bf8:	4f 90       	pop	r4
     bfa:	3f 90       	pop	r3
     bfc:	2f 90       	pop	r2
     bfe:	08 95       	ret

00000c00 <tinyDendrite_get_potential>:
outside. It uses the previously declared functions to return the potential.
*/
int16_t tinyDendrite_get_potential()
{
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
     c00:	4a df       	rcall	.-364    	; 0xa96 <tinyDendrite_update_signals>
     c02:	ee e4       	ldi	r30, 0x4E	; 78
     c04:	fe e3       	ldi	r31, 0x3E	; 62
     c06:	43 e5       	ldi	r20, 0x53	; 83
     c08:	5e e3       	ldi	r21, 0x3E	; 62
	
	int16_t return_potential_val = 0;
     c0a:	20 e0       	ldi	r18, 0x00	; 0
     c0c:	30 e0       	ldi	r19, 0x00	; 0
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		switch(tinyDendrite_current_signals[i])
     c0e:	91 91       	ld	r25, Z+
     c10:	93 30       	cpi	r25, 0x03	; 3
     c12:	a1 f0       	breq	.+40     	; 0xc3c <tinyDendrite_get_potential+0x3c>
     c14:	28 f4       	brcc	.+10     	; 0xc20 <tinyDendrite_get_potential+0x20>
     c16:	91 30       	cpi	r25, 0x01	; 1
     c18:	b9 f0       	breq	.+46     	; 0xc48 <tinyDendrite_get_potential+0x48>
     c1a:	92 30       	cpi	r25, 0x02	; 2
     c1c:	91 f0       	breq	.+36     	; 0xc42 <tinyDendrite_get_potential+0x42>
     c1e:	16 c0       	rjmp	.+44     	; 0xc4c <tinyDendrite_get_potential+0x4c>
     c20:	95 30       	cpi	r25, 0x05	; 5
     c22:	31 f0       	breq	.+12     	; 0xc30 <tinyDendrite_get_potential+0x30>
     c24:	40 f0       	brcs	.+16     	; 0xc36 <tinyDendrite_get_potential+0x36>
     c26:	96 30       	cpi	r25, 0x06	; 6
     c28:	89 f4       	brne	.+34     	; 0xc4c <tinyDendrite_get_potential+0x4c>
		{
			case NO_SIGNAL:
				return_potential_val += NO_SIGNAL_REACTION;
				break;
			case HIGH_EXCITE:
				return_potential_val += HIGH_EXCITE_REACTION;
     c2a:	2c 5c       	subi	r18, 0xCC	; 204
     c2c:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     c2e:	0e c0       	rjmp	.+28     	; 0xc4c <tinyDendrite_get_potential+0x4c>
			case NORMAL_EXCITE:
				return_potential_val += NORMAL_EXCITE_REACTION;
     c30:	26 5e       	subi	r18, 0xE6	; 230
     c32:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     c34:	0b c0       	rjmp	.+22     	; 0xc4c <tinyDendrite_get_potential+0x4c>
			case LOW_EXCITE:
				return_potential_val += LOW_EXCITE_REACTION;
     c36:	2c 5e       	subi	r18, 0xEC	; 236
     c38:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     c3a:	08 c0       	rjmp	.+16     	; 0xc4c <tinyDendrite_get_potential+0x4c>
			case HIGH_INHIB:
				return_potential_val += HIGH_INHIB_REACTION;
     c3c:	22 53       	subi	r18, 0x32	; 50
     c3e:	31 09       	sbc	r19, r1
				break;
     c40:	05 c0       	rjmp	.+10     	; 0xc4c <tinyDendrite_get_potential+0x4c>
			case NORMAL_INHIB:
				return_potential_val += NORMAL_INHIB_REACTION;
     c42:	2a 51       	subi	r18, 0x1A	; 26
     c44:	31 09       	sbc	r19, r1
				break;
     c46:	02 c0       	rjmp	.+4      	; 0xc4c <tinyDendrite_get_potential+0x4c>
			case LOW_INHIB:
				return_potential_val += LOW_INHIB_REACTION;
     c48:	24 51       	subi	r18, 0x14	; 20
     c4a:	31 09       	sbc	r19, r1
{
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
	
	int16_t return_potential_val = 0;
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
     c4c:	e4 17       	cp	r30, r20
     c4e:	f5 07       	cpc	r31, r21
     c50:	f1 f6       	brne	.-68     	; 0xc0e <tinyDendrite_get_potential+0xe>
			default:
				break;
		}
	}
	return return_potential_val;
}
     c52:	c9 01       	movw	r24, r18
     c54:	08 95       	ret

00000c56 <tinyDendrite_update_potential>:

double tinyDendrite_update_potential(double potential){
     c56:	cf 92       	push	r12
     c58:	df 92       	push	r13
     c5a:	ef 92       	push	r14
     c5c:	ff 92       	push	r15
     c5e:	6b 01       	movw	r12, r22
     c60:	7c 01       	movw	r14, r24
	
	uint16_t potential_change = tinyDendrite_get_potential();
     c62:	ce df       	rcall	.-100    	; 0xc00 <tinyDendrite_get_potential>
	potential += potential_change;
	return potential;
     c64:	bc 01       	movw	r22, r24
     c66:	80 e0       	ldi	r24, 0x00	; 0
     c68:	90 e0       	ldi	r25, 0x00	; 0
     c6a:	a5 d1       	rcall	.+842    	; 0xfb6 <__floatunsisf>
     c6c:	a7 01       	movw	r20, r14
     c6e:	96 01       	movw	r18, r12
     c70:	89 d0       	rcall	.+274    	; 0xd84 <__addsf3>
     c72:	ff 90       	pop	r15
     c74:	ef 90       	pop	r14
     c76:	df 90       	pop	r13
     c78:	cf 90       	pop	r12
     c7a:	08 95       	ret

00000c7c <__vector_6>:
This function is called every time the RTC (Real Time Clock) counter overflows.
With the current settings, it will be called every ms.
The RTC clock runs at 1kHz, and the number of cycles before overflow is set with RTC.PER = someHexValue (e.g. 0x20) in src/rtc.c
*/
ISR(RTC_CNT_vect)
{
     c7c:	1f 92       	push	r1
     c7e:	0f 92       	push	r0
     c80:	0f b6       	in	r0, 0x3f	; 63
     c82:	0f 92       	push	r0
     c84:	11 24       	eor	r1, r1
     c86:	2f 93       	push	r18
     c88:	3f 93       	push	r19
     c8a:	4f 93       	push	r20
     c8c:	5f 93       	push	r21
     c8e:	6f 93       	push	r22
     c90:	7f 93       	push	r23
     c92:	8f 93       	push	r24
     c94:	9f 93       	push	r25
     c96:	af 93       	push	r26
     c98:	bf 93       	push	r27
     c9a:	cf 93       	push	r28
     c9c:	ef 93       	push	r30
     c9e:	ff 93       	push	r31
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     ca0:	c1 e0       	ldi	r28, 0x01	; 1
     ca2:	c0 93 5d 3e 	sts	0x3E5D, r28	; 0x803e5d <tinyISR_interrupt_flag>
{
	// Set flag to let main loop run a new cycle
	tinyISR_setflag(true);
	
	// Timer counter incrementation
	tinyTime_counter_increment();
     ca6:	aa dc       	rcall	.-1708   	; 0x5fc <tinyTime_counter_increment>

	/* Overflow interrupt flag has to be cleared manually */
	RTC.INTFLAGS = RTC_OVF_bm;
     ca8:	c0 93 43 01 	sts	0x0143, r28	; 0x800143 <__TEXT_REGION_LENGTH__+0x700143>
}
     cac:	ff 91       	pop	r31
     cae:	ef 91       	pop	r30
     cb0:	cf 91       	pop	r28
     cb2:	bf 91       	pop	r27
     cb4:	af 91       	pop	r26
     cb6:	9f 91       	pop	r25
     cb8:	8f 91       	pop	r24
     cba:	7f 91       	pop	r23
     cbc:	6f 91       	pop	r22
     cbe:	5f 91       	pop	r21
     cc0:	4f 91       	pop	r20
     cc2:	3f 91       	pop	r19
     cc4:	2f 91       	pop	r18
     cc6:	0f 90       	pop	r0
     cc8:	0f be       	out	0x3f, r0	; 63
     cca:	0f 90       	pop	r0
     ccc:	1f 90       	pop	r1
     cce:	18 95       	reti

00000cd0 <tinyISR_setflag>:
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     cd0:	80 93 5d 3e 	sts	0x3E5D, r24	; 0x803e5d <tinyISR_interrupt_flag>
     cd4:	08 95       	ret

00000cd6 <tinyISR_getflag>:
}

_Bool tinyISR_getflag(void)
{
	return tinyISR_interrupt_flag;
}
     cd6:	80 91 5d 3e 	lds	r24, 0x3E5D	; 0x803e5d <tinyISR_interrupt_flag>
     cda:	08 95       	ret

00000cdc <tinyPotential_update>:
The function which will run in the main loop.
This function will run on interrupts by the RTC module.
*/
void tinyPotential_update()
{
	tinyDebugger_send_float("Potential", tinyPotential_potential);
     cdc:	40 91 5e 3e 	lds	r20, 0x3E5E	; 0x803e5e <tinyPotential_potential>
     ce0:	50 91 5f 3e 	lds	r21, 0x3E5F	; 0x803e5f <tinyPotential_potential+0x1>
     ce4:	60 91 60 3e 	lds	r22, 0x3E60	; 0x803e60 <tinyPotential_potential+0x2>
     ce8:	70 91 61 3e 	lds	r23, 0x3E61	; 0x803e61 <tinyPotential_potential+0x3>
     cec:	89 ec       	ldi	r24, 0xC9	; 201
     cee:	9f e9       	ldi	r25, 0x9F	; 159
     cf0:	11 dc       	rcall	.-2014   	; 0x514 <tinyDebugger_send_float>
	// but for simplification, we just assume that each cycle will take one ms. The consequences for a cycle taking longer
	// are negligible. 
	
	uint8_t time_since_last_update = 1;
	tinyPotential_potential *= (exp(-(time_since_last_update/TINYPOTENTIAL_TIME_CONST)));
	if(fabs(tinyPotential_potential)<0.01){
     cf2:	80 91 5e 3e 	lds	r24, 0x3E5E	; 0x803e5e <tinyPotential_potential>
     cf6:	90 91 5f 3e 	lds	r25, 0x3E5F	; 0x803e5f <tinyPotential_potential+0x1>
     cfa:	a0 91 60 3e 	lds	r26, 0x3E60	; 0x803e60 <tinyPotential_potential+0x2>
     cfe:	b0 91 61 3e 	lds	r27, 0x3E61	; 0x803e61 <tinyPotential_potential+0x3>
     d02:	bc 01       	movw	r22, r24
     d04:	cd 01       	movw	r24, r26
     d06:	9f 77       	andi	r25, 0x7F	; 127
     d08:	2a e0       	ldi	r18, 0x0A	; 10
     d0a:	37 ed       	ldi	r19, 0xD7	; 215
     d0c:	43 e2       	ldi	r20, 0x23	; 35
     d0e:	5c e3       	ldi	r21, 0x3C	; 60
     d10:	a5 d0       	rcall	.+330    	; 0xe5c <__cmpsf2>
     d12:	88 23       	and	r24, r24
     d14:	44 f4       	brge	.+16     	; 0xd26 <tinyPotential_update+0x4a>
		tinyPotential_potential=0;
     d16:	10 92 5e 3e 	sts	0x3E5E, r1	; 0x803e5e <tinyPotential_potential>
     d1a:	10 92 5f 3e 	sts	0x3E5F, r1	; 0x803e5f <tinyPotential_potential+0x1>
     d1e:	10 92 60 3e 	sts	0x3E60, r1	; 0x803e60 <tinyPotential_potential+0x2>
     d22:	10 92 61 3e 	sts	0x3E61, r1	; 0x803e61 <tinyPotential_potential+0x3>
	tinyDebugger_send_float("Potential", tinyPotential_potential);
	//Some of the potential in the neuron has decayed away
	tinyPotential_decay();
	
	// Update potential with values from Dendrites
	tinyPotential_potential = tinyDendrite_update_potential(tinyPotential_potential);
     d26:	60 91 5e 3e 	lds	r22, 0x3E5E	; 0x803e5e <tinyPotential_potential>
     d2a:	70 91 5f 3e 	lds	r23, 0x3E5F	; 0x803e5f <tinyPotential_potential+0x1>
     d2e:	80 91 60 3e 	lds	r24, 0x3E60	; 0x803e60 <tinyPotential_potential+0x2>
     d32:	90 91 61 3e 	lds	r25, 0x3E61	; 0x803e61 <tinyPotential_potential+0x3>
     d36:	8f df       	rcall	.-226    	; 0xc56 <tinyDendrite_update_potential>
     d38:	60 93 5e 3e 	sts	0x3E5E, r22	; 0x803e5e <tinyPotential_potential>
     d3c:	70 93 5f 3e 	sts	0x3E5F, r23	; 0x803e5f <tinyPotential_potential+0x1>
     d40:	80 93 60 3e 	sts	0x3E60, r24	; 0x803e60 <tinyPotential_potential+0x2>
     d44:	90 93 61 3e 	sts	0x3E61, r25	; 0x803e61 <tinyPotential_potential+0x3>
	
	// Update potential from button press
	tinyPotential_potential = tinyButton_update_potential(tinyPotential_potential);
     d48:	7b dd       	rcall	.-1290   	; 0x840 <tinyButton_update_potential>
     d4a:	60 93 5e 3e 	sts	0x3E5E, r22	; 0x803e5e <tinyPotential_potential>
     d4e:	70 93 5f 3e 	sts	0x3E5F, r23	; 0x803e5f <tinyPotential_potential+0x1>
     d52:	80 93 60 3e 	sts	0x3E60, r24	; 0x803e60 <tinyPotential_potential+0x2>
     d56:	90 93 61 3e 	sts	0x3E61, r25	; 0x803e61 <tinyPotential_potential+0x3>
	
	// Update potential with values from spontaneous pulse.
	tinyPotential_potential = tinyPulse_update_potential(tinyPotential_potential);
     d5a:	1b dc       	rcall	.-1994   	; 0x592 <tinyPulse_update_potential>
     d5c:	60 93 5e 3e 	sts	0x3E5E, r22	; 0x803e5e <tinyPotential_potential>
     d60:	70 93 5f 3e 	sts	0x3E5F, r23	; 0x803e5f <tinyPotential_potential+0x1>
     d64:	80 93 60 3e 	sts	0x3E60, r24	; 0x803e60 <tinyPotential_potential+0x2>
     d68:	90 93 61 3e 	sts	0x3E61, r25	; 0x803e61 <tinyPotential_potential+0x3>
	
	// Let the axon affect the potential
	// This is also where we decide whether or not the axon should fire
	tinyPotential_potential = tinyAxon_update_potential(tinyPotential_potential);
     d6c:	d8 dd       	rcall	.-1104   	; 0x91e <tinyAxon_update_potential>
     d6e:	60 93 5e 3e 	sts	0x3E5E, r22	; 0x803e5e <tinyPotential_potential>
     d72:	70 93 5f 3e 	sts	0x3E5F, r23	; 0x803e5f <tinyPotential_potential+0x1>
     d76:	80 93 60 3e 	sts	0x3E60, r24	; 0x803e60 <tinyPotential_potential+0x2>
     d7a:	90 93 61 3e 	sts	0x3E61, r25	; 0x803e61 <tinyPotential_potential+0x3>

	//Update the led
	potential_to_RGB_update_LEDs(tinyPotential_potential);
     d7e:	87 dc       	rcall	.-1778   	; 0x68e <potential_to_RGB_update_LEDs>
     d80:	08 95       	ret

00000d82 <__subsf3>:
     d82:	50 58       	subi	r21, 0x80	; 128

00000d84 <__addsf3>:
     d84:	bb 27       	eor	r27, r27
     d86:	aa 27       	eor	r26, r26
     d88:	0e 94 d9 06 	call	0xdb2	; 0xdb2 <__addsf3x>
     d8c:	0c 94 53 08 	jmp	0x10a6	; 0x10a6 <__fp_round>
     d90:	0e 94 45 08 	call	0x108a	; 0x108a <__fp_pscA>
     d94:	38 f0       	brcs	.+14     	; 0xda4 <__addsf3+0x20>
     d96:	0e 94 4c 08 	call	0x1098	; 0x1098 <__fp_pscB>
     d9a:	20 f0       	brcs	.+8      	; 0xda4 <__addsf3+0x20>
     d9c:	39 f4       	brne	.+14     	; 0xdac <__addsf3+0x28>
     d9e:	9f 3f       	cpi	r25, 0xFF	; 255
     da0:	19 f4       	brne	.+6      	; 0xda8 <__addsf3+0x24>
     da2:	26 f4       	brtc	.+8      	; 0xdac <__addsf3+0x28>
     da4:	0c 94 42 08 	jmp	0x1084	; 0x1084 <__fp_nan>
     da8:	0e f4       	brtc	.+2      	; 0xdac <__addsf3+0x28>
     daa:	e0 95       	com	r30
     dac:	e7 fb       	bst	r30, 7
     dae:	0c 94 3c 08 	jmp	0x1078	; 0x1078 <__fp_inf>

00000db2 <__addsf3x>:
     db2:	e9 2f       	mov	r30, r25
     db4:	0e 94 64 08 	call	0x10c8	; 0x10c8 <__fp_split3>
     db8:	58 f3       	brcs	.-42     	; 0xd90 <__addsf3+0xc>
     dba:	ba 17       	cp	r27, r26
     dbc:	62 07       	cpc	r22, r18
     dbe:	73 07       	cpc	r23, r19
     dc0:	84 07       	cpc	r24, r20
     dc2:	95 07       	cpc	r25, r21
     dc4:	20 f0       	brcs	.+8      	; 0xdce <__addsf3x+0x1c>
     dc6:	79 f4       	brne	.+30     	; 0xde6 <__addsf3x+0x34>
     dc8:	a6 f5       	brtc	.+104    	; 0xe32 <__addsf3x+0x80>
     dca:	0c 94 86 08 	jmp	0x110c	; 0x110c <__fp_zero>
     dce:	0e f4       	brtc	.+2      	; 0xdd2 <__addsf3x+0x20>
     dd0:	e0 95       	com	r30
     dd2:	0b 2e       	mov	r0, r27
     dd4:	ba 2f       	mov	r27, r26
     dd6:	a0 2d       	mov	r26, r0
     dd8:	0b 01       	movw	r0, r22
     dda:	b9 01       	movw	r22, r18
     ddc:	90 01       	movw	r18, r0
     dde:	0c 01       	movw	r0, r24
     de0:	ca 01       	movw	r24, r20
     de2:	a0 01       	movw	r20, r0
     de4:	11 24       	eor	r1, r1
     de6:	ff 27       	eor	r31, r31
     de8:	59 1b       	sub	r21, r25
     dea:	99 f0       	breq	.+38     	; 0xe12 <__addsf3x+0x60>
     dec:	59 3f       	cpi	r21, 0xF9	; 249
     dee:	50 f4       	brcc	.+20     	; 0xe04 <__addsf3x+0x52>
     df0:	50 3e       	cpi	r21, 0xE0	; 224
     df2:	68 f1       	brcs	.+90     	; 0xe4e <__addsf3x+0x9c>
     df4:	1a 16       	cp	r1, r26
     df6:	f0 40       	sbci	r31, 0x00	; 0
     df8:	a2 2f       	mov	r26, r18
     dfa:	23 2f       	mov	r18, r19
     dfc:	34 2f       	mov	r19, r20
     dfe:	44 27       	eor	r20, r20
     e00:	58 5f       	subi	r21, 0xF8	; 248
     e02:	f3 cf       	rjmp	.-26     	; 0xdea <__addsf3x+0x38>
     e04:	46 95       	lsr	r20
     e06:	37 95       	ror	r19
     e08:	27 95       	ror	r18
     e0a:	a7 95       	ror	r26
     e0c:	f0 40       	sbci	r31, 0x00	; 0
     e0e:	53 95       	inc	r21
     e10:	c9 f7       	brne	.-14     	; 0xe04 <__addsf3x+0x52>
     e12:	7e f4       	brtc	.+30     	; 0xe32 <__addsf3x+0x80>
     e14:	1f 16       	cp	r1, r31
     e16:	ba 0b       	sbc	r27, r26
     e18:	62 0b       	sbc	r22, r18
     e1a:	73 0b       	sbc	r23, r19
     e1c:	84 0b       	sbc	r24, r20
     e1e:	ba f0       	brmi	.+46     	; 0xe4e <__addsf3x+0x9c>
     e20:	91 50       	subi	r25, 0x01	; 1
     e22:	a1 f0       	breq	.+40     	; 0xe4c <__addsf3x+0x9a>
     e24:	ff 0f       	add	r31, r31
     e26:	bb 1f       	adc	r27, r27
     e28:	66 1f       	adc	r22, r22
     e2a:	77 1f       	adc	r23, r23
     e2c:	88 1f       	adc	r24, r24
     e2e:	c2 f7       	brpl	.-16     	; 0xe20 <__addsf3x+0x6e>
     e30:	0e c0       	rjmp	.+28     	; 0xe4e <__addsf3x+0x9c>
     e32:	ba 0f       	add	r27, r26
     e34:	62 1f       	adc	r22, r18
     e36:	73 1f       	adc	r23, r19
     e38:	84 1f       	adc	r24, r20
     e3a:	48 f4       	brcc	.+18     	; 0xe4e <__addsf3x+0x9c>
     e3c:	87 95       	ror	r24
     e3e:	77 95       	ror	r23
     e40:	67 95       	ror	r22
     e42:	b7 95       	ror	r27
     e44:	f7 95       	ror	r31
     e46:	9e 3f       	cpi	r25, 0xFE	; 254
     e48:	08 f0       	brcs	.+2      	; 0xe4c <__addsf3x+0x9a>
     e4a:	b0 cf       	rjmp	.-160    	; 0xdac <__addsf3+0x28>
     e4c:	93 95       	inc	r25
     e4e:	88 0f       	add	r24, r24
     e50:	08 f0       	brcs	.+2      	; 0xe54 <__addsf3x+0xa2>
     e52:	99 27       	eor	r25, r25
     e54:	ee 0f       	add	r30, r30
     e56:	97 95       	ror	r25
     e58:	87 95       	ror	r24
     e5a:	08 95       	ret

00000e5c <__cmpsf2>:
     e5c:	0e 94 18 08 	call	0x1030	; 0x1030 <__fp_cmp>
     e60:	08 f4       	brcc	.+2      	; 0xe64 <__cmpsf2+0x8>
     e62:	81 e0       	ldi	r24, 0x01	; 1
     e64:	08 95       	ret

00000e66 <__divsf3>:
     e66:	0e 94 47 07 	call	0xe8e	; 0xe8e <__divsf3x>
     e6a:	0c 94 53 08 	jmp	0x10a6	; 0x10a6 <__fp_round>
     e6e:	0e 94 4c 08 	call	0x1098	; 0x1098 <__fp_pscB>
     e72:	58 f0       	brcs	.+22     	; 0xe8a <__divsf3+0x24>
     e74:	0e 94 45 08 	call	0x108a	; 0x108a <__fp_pscA>
     e78:	40 f0       	brcs	.+16     	; 0xe8a <__divsf3+0x24>
     e7a:	29 f4       	brne	.+10     	; 0xe86 <__divsf3+0x20>
     e7c:	5f 3f       	cpi	r21, 0xFF	; 255
     e7e:	29 f0       	breq	.+10     	; 0xe8a <__divsf3+0x24>
     e80:	0c 94 3c 08 	jmp	0x1078	; 0x1078 <__fp_inf>
     e84:	51 11       	cpse	r21, r1
     e86:	0c 94 87 08 	jmp	0x110e	; 0x110e <__fp_szero>
     e8a:	0c 94 42 08 	jmp	0x1084	; 0x1084 <__fp_nan>

00000e8e <__divsf3x>:
     e8e:	0e 94 64 08 	call	0x10c8	; 0x10c8 <__fp_split3>
     e92:	68 f3       	brcs	.-38     	; 0xe6e <__divsf3+0x8>

00000e94 <__divsf3_pse>:
     e94:	99 23       	and	r25, r25
     e96:	b1 f3       	breq	.-20     	; 0xe84 <__divsf3+0x1e>
     e98:	55 23       	and	r21, r21
     e9a:	91 f3       	breq	.-28     	; 0xe80 <__divsf3+0x1a>
     e9c:	95 1b       	sub	r25, r21
     e9e:	55 0b       	sbc	r21, r21
     ea0:	bb 27       	eor	r27, r27
     ea2:	aa 27       	eor	r26, r26
     ea4:	62 17       	cp	r22, r18
     ea6:	73 07       	cpc	r23, r19
     ea8:	84 07       	cpc	r24, r20
     eaa:	38 f0       	brcs	.+14     	; 0xeba <__divsf3_pse+0x26>
     eac:	9f 5f       	subi	r25, 0xFF	; 255
     eae:	5f 4f       	sbci	r21, 0xFF	; 255
     eb0:	22 0f       	add	r18, r18
     eb2:	33 1f       	adc	r19, r19
     eb4:	44 1f       	adc	r20, r20
     eb6:	aa 1f       	adc	r26, r26
     eb8:	a9 f3       	breq	.-22     	; 0xea4 <__divsf3_pse+0x10>
     eba:	35 d0       	rcall	.+106    	; 0xf26 <__divsf3_pse+0x92>
     ebc:	0e 2e       	mov	r0, r30
     ebe:	3a f0       	brmi	.+14     	; 0xece <__divsf3_pse+0x3a>
     ec0:	e0 e8       	ldi	r30, 0x80	; 128
     ec2:	32 d0       	rcall	.+100    	; 0xf28 <__divsf3_pse+0x94>
     ec4:	91 50       	subi	r25, 0x01	; 1
     ec6:	50 40       	sbci	r21, 0x00	; 0
     ec8:	e6 95       	lsr	r30
     eca:	00 1c       	adc	r0, r0
     ecc:	ca f7       	brpl	.-14     	; 0xec0 <__divsf3_pse+0x2c>
     ece:	2b d0       	rcall	.+86     	; 0xf26 <__divsf3_pse+0x92>
     ed0:	fe 2f       	mov	r31, r30
     ed2:	29 d0       	rcall	.+82     	; 0xf26 <__divsf3_pse+0x92>
     ed4:	66 0f       	add	r22, r22
     ed6:	77 1f       	adc	r23, r23
     ed8:	88 1f       	adc	r24, r24
     eda:	bb 1f       	adc	r27, r27
     edc:	26 17       	cp	r18, r22
     ede:	37 07       	cpc	r19, r23
     ee0:	48 07       	cpc	r20, r24
     ee2:	ab 07       	cpc	r26, r27
     ee4:	b0 e8       	ldi	r27, 0x80	; 128
     ee6:	09 f0       	breq	.+2      	; 0xeea <__divsf3_pse+0x56>
     ee8:	bb 0b       	sbc	r27, r27
     eea:	80 2d       	mov	r24, r0
     eec:	bf 01       	movw	r22, r30
     eee:	ff 27       	eor	r31, r31
     ef0:	93 58       	subi	r25, 0x83	; 131
     ef2:	5f 4f       	sbci	r21, 0xFF	; 255
     ef4:	3a f0       	brmi	.+14     	; 0xf04 <__divsf3_pse+0x70>
     ef6:	9e 3f       	cpi	r25, 0xFE	; 254
     ef8:	51 05       	cpc	r21, r1
     efa:	78 f0       	brcs	.+30     	; 0xf1a <__divsf3_pse+0x86>
     efc:	0c 94 3c 08 	jmp	0x1078	; 0x1078 <__fp_inf>
     f00:	0c 94 87 08 	jmp	0x110e	; 0x110e <__fp_szero>
     f04:	5f 3f       	cpi	r21, 0xFF	; 255
     f06:	e4 f3       	brlt	.-8      	; 0xf00 <__divsf3_pse+0x6c>
     f08:	98 3e       	cpi	r25, 0xE8	; 232
     f0a:	d4 f3       	brlt	.-12     	; 0xf00 <__divsf3_pse+0x6c>
     f0c:	86 95       	lsr	r24
     f0e:	77 95       	ror	r23
     f10:	67 95       	ror	r22
     f12:	b7 95       	ror	r27
     f14:	f7 95       	ror	r31
     f16:	9f 5f       	subi	r25, 0xFF	; 255
     f18:	c9 f7       	brne	.-14     	; 0xf0c <__divsf3_pse+0x78>
     f1a:	88 0f       	add	r24, r24
     f1c:	91 1d       	adc	r25, r1
     f1e:	96 95       	lsr	r25
     f20:	87 95       	ror	r24
     f22:	97 f9       	bld	r25, 7
     f24:	08 95       	ret
     f26:	e1 e0       	ldi	r30, 0x01	; 1
     f28:	66 0f       	add	r22, r22
     f2a:	77 1f       	adc	r23, r23
     f2c:	88 1f       	adc	r24, r24
     f2e:	bb 1f       	adc	r27, r27
     f30:	62 17       	cp	r22, r18
     f32:	73 07       	cpc	r23, r19
     f34:	84 07       	cpc	r24, r20
     f36:	ba 07       	cpc	r27, r26
     f38:	20 f0       	brcs	.+8      	; 0xf42 <__divsf3_pse+0xae>
     f3a:	62 1b       	sub	r22, r18
     f3c:	73 0b       	sbc	r23, r19
     f3e:	84 0b       	sbc	r24, r20
     f40:	ba 0b       	sbc	r27, r26
     f42:	ee 1f       	adc	r30, r30
     f44:	88 f7       	brcc	.-30     	; 0xf28 <__divsf3_pse+0x94>
     f46:	e0 95       	com	r30
     f48:	08 95       	ret

00000f4a <__fixsfsi>:
     f4a:	0e 94 ac 07 	call	0xf58	; 0xf58 <__fixunssfsi>
     f4e:	68 94       	set
     f50:	b1 11       	cpse	r27, r1
     f52:	0c 94 87 08 	jmp	0x110e	; 0x110e <__fp_szero>
     f56:	08 95       	ret

00000f58 <__fixunssfsi>:
     f58:	0e 94 6c 08 	call	0x10d8	; 0x10d8 <__fp_splitA>
     f5c:	88 f0       	brcs	.+34     	; 0xf80 <__fixunssfsi+0x28>
     f5e:	9f 57       	subi	r25, 0x7F	; 127
     f60:	98 f0       	brcs	.+38     	; 0xf88 <__fixunssfsi+0x30>
     f62:	b9 2f       	mov	r27, r25
     f64:	99 27       	eor	r25, r25
     f66:	b7 51       	subi	r27, 0x17	; 23
     f68:	b0 f0       	brcs	.+44     	; 0xf96 <__fixunssfsi+0x3e>
     f6a:	e1 f0       	breq	.+56     	; 0xfa4 <__fixunssfsi+0x4c>
     f6c:	66 0f       	add	r22, r22
     f6e:	77 1f       	adc	r23, r23
     f70:	88 1f       	adc	r24, r24
     f72:	99 1f       	adc	r25, r25
     f74:	1a f0       	brmi	.+6      	; 0xf7c <__fixunssfsi+0x24>
     f76:	ba 95       	dec	r27
     f78:	c9 f7       	brne	.-14     	; 0xf6c <__fixunssfsi+0x14>
     f7a:	14 c0       	rjmp	.+40     	; 0xfa4 <__fixunssfsi+0x4c>
     f7c:	b1 30       	cpi	r27, 0x01	; 1
     f7e:	91 f0       	breq	.+36     	; 0xfa4 <__fixunssfsi+0x4c>
     f80:	0e 94 86 08 	call	0x110c	; 0x110c <__fp_zero>
     f84:	b1 e0       	ldi	r27, 0x01	; 1
     f86:	08 95       	ret
     f88:	0c 94 86 08 	jmp	0x110c	; 0x110c <__fp_zero>
     f8c:	67 2f       	mov	r22, r23
     f8e:	78 2f       	mov	r23, r24
     f90:	88 27       	eor	r24, r24
     f92:	b8 5f       	subi	r27, 0xF8	; 248
     f94:	39 f0       	breq	.+14     	; 0xfa4 <__fixunssfsi+0x4c>
     f96:	b9 3f       	cpi	r27, 0xF9	; 249
     f98:	cc f3       	brlt	.-14     	; 0xf8c <__fixunssfsi+0x34>
     f9a:	86 95       	lsr	r24
     f9c:	77 95       	ror	r23
     f9e:	67 95       	ror	r22
     fa0:	b3 95       	inc	r27
     fa2:	d9 f7       	brne	.-10     	; 0xf9a <__fixunssfsi+0x42>
     fa4:	3e f4       	brtc	.+14     	; 0xfb4 <__fixunssfsi+0x5c>
     fa6:	90 95       	com	r25
     fa8:	80 95       	com	r24
     faa:	70 95       	com	r23
     fac:	61 95       	neg	r22
     fae:	7f 4f       	sbci	r23, 0xFF	; 255
     fb0:	8f 4f       	sbci	r24, 0xFF	; 255
     fb2:	9f 4f       	sbci	r25, 0xFF	; 255
     fb4:	08 95       	ret

00000fb6 <__floatunsisf>:
     fb6:	e8 94       	clt
     fb8:	09 c0       	rjmp	.+18     	; 0xfcc <__floatsisf+0x12>

00000fba <__floatsisf>:
     fba:	97 fb       	bst	r25, 7
     fbc:	3e f4       	brtc	.+14     	; 0xfcc <__floatsisf+0x12>
     fbe:	90 95       	com	r25
     fc0:	80 95       	com	r24
     fc2:	70 95       	com	r23
     fc4:	61 95       	neg	r22
     fc6:	7f 4f       	sbci	r23, 0xFF	; 255
     fc8:	8f 4f       	sbci	r24, 0xFF	; 255
     fca:	9f 4f       	sbci	r25, 0xFF	; 255
     fcc:	99 23       	and	r25, r25
     fce:	a9 f0       	breq	.+42     	; 0xffa <__floatsisf+0x40>
     fd0:	f9 2f       	mov	r31, r25
     fd2:	96 e9       	ldi	r25, 0x96	; 150
     fd4:	bb 27       	eor	r27, r27
     fd6:	93 95       	inc	r25
     fd8:	f6 95       	lsr	r31
     fda:	87 95       	ror	r24
     fdc:	77 95       	ror	r23
     fde:	67 95       	ror	r22
     fe0:	b7 95       	ror	r27
     fe2:	f1 11       	cpse	r31, r1
     fe4:	f8 cf       	rjmp	.-16     	; 0xfd6 <__floatsisf+0x1c>
     fe6:	fa f4       	brpl	.+62     	; 0x1026 <__floatsisf+0x6c>
     fe8:	bb 0f       	add	r27, r27
     fea:	11 f4       	brne	.+4      	; 0xff0 <__floatsisf+0x36>
     fec:	60 ff       	sbrs	r22, 0
     fee:	1b c0       	rjmp	.+54     	; 0x1026 <__floatsisf+0x6c>
     ff0:	6f 5f       	subi	r22, 0xFF	; 255
     ff2:	7f 4f       	sbci	r23, 0xFF	; 255
     ff4:	8f 4f       	sbci	r24, 0xFF	; 255
     ff6:	9f 4f       	sbci	r25, 0xFF	; 255
     ff8:	16 c0       	rjmp	.+44     	; 0x1026 <__floatsisf+0x6c>
     ffa:	88 23       	and	r24, r24
     ffc:	11 f0       	breq	.+4      	; 0x1002 <__floatsisf+0x48>
     ffe:	96 e9       	ldi	r25, 0x96	; 150
    1000:	11 c0       	rjmp	.+34     	; 0x1024 <__floatsisf+0x6a>
    1002:	77 23       	and	r23, r23
    1004:	21 f0       	breq	.+8      	; 0x100e <__floatsisf+0x54>
    1006:	9e e8       	ldi	r25, 0x8E	; 142
    1008:	87 2f       	mov	r24, r23
    100a:	76 2f       	mov	r23, r22
    100c:	05 c0       	rjmp	.+10     	; 0x1018 <__floatsisf+0x5e>
    100e:	66 23       	and	r22, r22
    1010:	71 f0       	breq	.+28     	; 0x102e <__floatsisf+0x74>
    1012:	96 e8       	ldi	r25, 0x86	; 134
    1014:	86 2f       	mov	r24, r22
    1016:	70 e0       	ldi	r23, 0x00	; 0
    1018:	60 e0       	ldi	r22, 0x00	; 0
    101a:	2a f0       	brmi	.+10     	; 0x1026 <__floatsisf+0x6c>
    101c:	9a 95       	dec	r25
    101e:	66 0f       	add	r22, r22
    1020:	77 1f       	adc	r23, r23
    1022:	88 1f       	adc	r24, r24
    1024:	da f7       	brpl	.-10     	; 0x101c <__floatsisf+0x62>
    1026:	88 0f       	add	r24, r24
    1028:	96 95       	lsr	r25
    102a:	87 95       	ror	r24
    102c:	97 f9       	bld	r25, 7
    102e:	08 95       	ret

00001030 <__fp_cmp>:
    1030:	99 0f       	add	r25, r25
    1032:	00 08       	sbc	r0, r0
    1034:	55 0f       	add	r21, r21
    1036:	aa 0b       	sbc	r26, r26
    1038:	e0 e8       	ldi	r30, 0x80	; 128
    103a:	fe ef       	ldi	r31, 0xFE	; 254
    103c:	16 16       	cp	r1, r22
    103e:	17 06       	cpc	r1, r23
    1040:	e8 07       	cpc	r30, r24
    1042:	f9 07       	cpc	r31, r25
    1044:	c0 f0       	brcs	.+48     	; 0x1076 <__fp_cmp+0x46>
    1046:	12 16       	cp	r1, r18
    1048:	13 06       	cpc	r1, r19
    104a:	e4 07       	cpc	r30, r20
    104c:	f5 07       	cpc	r31, r21
    104e:	98 f0       	brcs	.+38     	; 0x1076 <__fp_cmp+0x46>
    1050:	62 1b       	sub	r22, r18
    1052:	73 0b       	sbc	r23, r19
    1054:	84 0b       	sbc	r24, r20
    1056:	95 0b       	sbc	r25, r21
    1058:	39 f4       	brne	.+14     	; 0x1068 <__fp_cmp+0x38>
    105a:	0a 26       	eor	r0, r26
    105c:	61 f0       	breq	.+24     	; 0x1076 <__fp_cmp+0x46>
    105e:	23 2b       	or	r18, r19
    1060:	24 2b       	or	r18, r20
    1062:	25 2b       	or	r18, r21
    1064:	21 f4       	brne	.+8      	; 0x106e <__fp_cmp+0x3e>
    1066:	08 95       	ret
    1068:	0a 26       	eor	r0, r26
    106a:	09 f4       	brne	.+2      	; 0x106e <__fp_cmp+0x3e>
    106c:	a1 40       	sbci	r26, 0x01	; 1
    106e:	a6 95       	lsr	r26
    1070:	8f ef       	ldi	r24, 0xFF	; 255
    1072:	81 1d       	adc	r24, r1
    1074:	81 1d       	adc	r24, r1
    1076:	08 95       	ret

00001078 <__fp_inf>:
    1078:	97 f9       	bld	r25, 7
    107a:	9f 67       	ori	r25, 0x7F	; 127
    107c:	80 e8       	ldi	r24, 0x80	; 128
    107e:	70 e0       	ldi	r23, 0x00	; 0
    1080:	60 e0       	ldi	r22, 0x00	; 0
    1082:	08 95       	ret

00001084 <__fp_nan>:
    1084:	9f ef       	ldi	r25, 0xFF	; 255
    1086:	80 ec       	ldi	r24, 0xC0	; 192
    1088:	08 95       	ret

0000108a <__fp_pscA>:
    108a:	00 24       	eor	r0, r0
    108c:	0a 94       	dec	r0
    108e:	16 16       	cp	r1, r22
    1090:	17 06       	cpc	r1, r23
    1092:	18 06       	cpc	r1, r24
    1094:	09 06       	cpc	r0, r25
    1096:	08 95       	ret

00001098 <__fp_pscB>:
    1098:	00 24       	eor	r0, r0
    109a:	0a 94       	dec	r0
    109c:	12 16       	cp	r1, r18
    109e:	13 06       	cpc	r1, r19
    10a0:	14 06       	cpc	r1, r20
    10a2:	05 06       	cpc	r0, r21
    10a4:	08 95       	ret

000010a6 <__fp_round>:
    10a6:	09 2e       	mov	r0, r25
    10a8:	03 94       	inc	r0
    10aa:	00 0c       	add	r0, r0
    10ac:	11 f4       	brne	.+4      	; 0x10b2 <__fp_round+0xc>
    10ae:	88 23       	and	r24, r24
    10b0:	52 f0       	brmi	.+20     	; 0x10c6 <__fp_round+0x20>
    10b2:	bb 0f       	add	r27, r27
    10b4:	40 f4       	brcc	.+16     	; 0x10c6 <__fp_round+0x20>
    10b6:	bf 2b       	or	r27, r31
    10b8:	11 f4       	brne	.+4      	; 0x10be <__fp_round+0x18>
    10ba:	60 ff       	sbrs	r22, 0
    10bc:	04 c0       	rjmp	.+8      	; 0x10c6 <__fp_round+0x20>
    10be:	6f 5f       	subi	r22, 0xFF	; 255
    10c0:	7f 4f       	sbci	r23, 0xFF	; 255
    10c2:	8f 4f       	sbci	r24, 0xFF	; 255
    10c4:	9f 4f       	sbci	r25, 0xFF	; 255
    10c6:	08 95       	ret

000010c8 <__fp_split3>:
    10c8:	57 fd       	sbrc	r21, 7
    10ca:	90 58       	subi	r25, 0x80	; 128
    10cc:	44 0f       	add	r20, r20
    10ce:	55 1f       	adc	r21, r21
    10d0:	59 f0       	breq	.+22     	; 0x10e8 <__fp_splitA+0x10>
    10d2:	5f 3f       	cpi	r21, 0xFF	; 255
    10d4:	71 f0       	breq	.+28     	; 0x10f2 <__fp_splitA+0x1a>
    10d6:	47 95       	ror	r20

000010d8 <__fp_splitA>:
    10d8:	88 0f       	add	r24, r24
    10da:	97 fb       	bst	r25, 7
    10dc:	99 1f       	adc	r25, r25
    10de:	61 f0       	breq	.+24     	; 0x10f8 <__fp_splitA+0x20>
    10e0:	9f 3f       	cpi	r25, 0xFF	; 255
    10e2:	79 f0       	breq	.+30     	; 0x1102 <__fp_splitA+0x2a>
    10e4:	87 95       	ror	r24
    10e6:	08 95       	ret
    10e8:	12 16       	cp	r1, r18
    10ea:	13 06       	cpc	r1, r19
    10ec:	14 06       	cpc	r1, r20
    10ee:	55 1f       	adc	r21, r21
    10f0:	f2 cf       	rjmp	.-28     	; 0x10d6 <__fp_split3+0xe>
    10f2:	46 95       	lsr	r20
    10f4:	f1 df       	rcall	.-30     	; 0x10d8 <__fp_splitA>
    10f6:	08 c0       	rjmp	.+16     	; 0x1108 <__fp_splitA+0x30>
    10f8:	16 16       	cp	r1, r22
    10fa:	17 06       	cpc	r1, r23
    10fc:	18 06       	cpc	r1, r24
    10fe:	99 1f       	adc	r25, r25
    1100:	f1 cf       	rjmp	.-30     	; 0x10e4 <__fp_splitA+0xc>
    1102:	86 95       	lsr	r24
    1104:	71 05       	cpc	r23, r1
    1106:	61 05       	cpc	r22, r1
    1108:	08 94       	sec
    110a:	08 95       	ret

0000110c <__fp_zero>:
    110c:	e8 94       	clt

0000110e <__fp_szero>:
    110e:	bb 27       	eor	r27, r27
    1110:	66 27       	eor	r22, r22
    1112:	77 27       	eor	r23, r23
    1114:	cb 01       	movw	r24, r22
    1116:	97 f9       	bld	r25, 7
    1118:	08 95       	ret

0000111a <__gesf2>:
    111a:	0e 94 18 08 	call	0x1030	; 0x1030 <__fp_cmp>
    111e:	08 f4       	brcc	.+2      	; 0x1122 <__gesf2+0x8>
    1120:	8f ef       	ldi	r24, 0xFF	; 255
    1122:	08 95       	ret

00001124 <__mulsf3>:
    1124:	0e 94 a5 08 	call	0x114a	; 0x114a <__mulsf3x>
    1128:	0c 94 53 08 	jmp	0x10a6	; 0x10a6 <__fp_round>
    112c:	0e 94 45 08 	call	0x108a	; 0x108a <__fp_pscA>
    1130:	38 f0       	brcs	.+14     	; 0x1140 <__mulsf3+0x1c>
    1132:	0e 94 4c 08 	call	0x1098	; 0x1098 <__fp_pscB>
    1136:	20 f0       	brcs	.+8      	; 0x1140 <__mulsf3+0x1c>
    1138:	95 23       	and	r25, r21
    113a:	11 f0       	breq	.+4      	; 0x1140 <__mulsf3+0x1c>
    113c:	0c 94 3c 08 	jmp	0x1078	; 0x1078 <__fp_inf>
    1140:	0c 94 42 08 	jmp	0x1084	; 0x1084 <__fp_nan>
    1144:	11 24       	eor	r1, r1
    1146:	0c 94 87 08 	jmp	0x110e	; 0x110e <__fp_szero>

0000114a <__mulsf3x>:
    114a:	0e 94 64 08 	call	0x10c8	; 0x10c8 <__fp_split3>
    114e:	70 f3       	brcs	.-36     	; 0x112c <__mulsf3+0x8>

00001150 <__mulsf3_pse>:
    1150:	95 9f       	mul	r25, r21
    1152:	c1 f3       	breq	.-16     	; 0x1144 <__mulsf3+0x20>
    1154:	95 0f       	add	r25, r21
    1156:	50 e0       	ldi	r21, 0x00	; 0
    1158:	55 1f       	adc	r21, r21
    115a:	62 9f       	mul	r22, r18
    115c:	f0 01       	movw	r30, r0
    115e:	72 9f       	mul	r23, r18
    1160:	bb 27       	eor	r27, r27
    1162:	f0 0d       	add	r31, r0
    1164:	b1 1d       	adc	r27, r1
    1166:	63 9f       	mul	r22, r19
    1168:	aa 27       	eor	r26, r26
    116a:	f0 0d       	add	r31, r0
    116c:	b1 1d       	adc	r27, r1
    116e:	aa 1f       	adc	r26, r26
    1170:	64 9f       	mul	r22, r20
    1172:	66 27       	eor	r22, r22
    1174:	b0 0d       	add	r27, r0
    1176:	a1 1d       	adc	r26, r1
    1178:	66 1f       	adc	r22, r22
    117a:	82 9f       	mul	r24, r18
    117c:	22 27       	eor	r18, r18
    117e:	b0 0d       	add	r27, r0
    1180:	a1 1d       	adc	r26, r1
    1182:	62 1f       	adc	r22, r18
    1184:	73 9f       	mul	r23, r19
    1186:	b0 0d       	add	r27, r0
    1188:	a1 1d       	adc	r26, r1
    118a:	62 1f       	adc	r22, r18
    118c:	83 9f       	mul	r24, r19
    118e:	a0 0d       	add	r26, r0
    1190:	61 1d       	adc	r22, r1
    1192:	22 1f       	adc	r18, r18
    1194:	74 9f       	mul	r23, r20
    1196:	33 27       	eor	r19, r19
    1198:	a0 0d       	add	r26, r0
    119a:	61 1d       	adc	r22, r1
    119c:	23 1f       	adc	r18, r19
    119e:	84 9f       	mul	r24, r20
    11a0:	60 0d       	add	r22, r0
    11a2:	21 1d       	adc	r18, r1
    11a4:	82 2f       	mov	r24, r18
    11a6:	76 2f       	mov	r23, r22
    11a8:	6a 2f       	mov	r22, r26
    11aa:	11 24       	eor	r1, r1
    11ac:	9f 57       	subi	r25, 0x7F	; 127
    11ae:	50 40       	sbci	r21, 0x00	; 0
    11b0:	9a f0       	brmi	.+38     	; 0x11d8 <__mulsf3_pse+0x88>
    11b2:	f1 f0       	breq	.+60     	; 0x11f0 <__mulsf3_pse+0xa0>
    11b4:	88 23       	and	r24, r24
    11b6:	4a f0       	brmi	.+18     	; 0x11ca <__mulsf3_pse+0x7a>
    11b8:	ee 0f       	add	r30, r30
    11ba:	ff 1f       	adc	r31, r31
    11bc:	bb 1f       	adc	r27, r27
    11be:	66 1f       	adc	r22, r22
    11c0:	77 1f       	adc	r23, r23
    11c2:	88 1f       	adc	r24, r24
    11c4:	91 50       	subi	r25, 0x01	; 1
    11c6:	50 40       	sbci	r21, 0x00	; 0
    11c8:	a9 f7       	brne	.-22     	; 0x11b4 <__mulsf3_pse+0x64>
    11ca:	9e 3f       	cpi	r25, 0xFE	; 254
    11cc:	51 05       	cpc	r21, r1
    11ce:	80 f0       	brcs	.+32     	; 0x11f0 <__mulsf3_pse+0xa0>
    11d0:	0c 94 3c 08 	jmp	0x1078	; 0x1078 <__fp_inf>
    11d4:	0c 94 87 08 	jmp	0x110e	; 0x110e <__fp_szero>
    11d8:	5f 3f       	cpi	r21, 0xFF	; 255
    11da:	e4 f3       	brlt	.-8      	; 0x11d4 <__mulsf3_pse+0x84>
    11dc:	98 3e       	cpi	r25, 0xE8	; 232
    11de:	d4 f3       	brlt	.-12     	; 0x11d4 <__mulsf3_pse+0x84>
    11e0:	86 95       	lsr	r24
    11e2:	77 95       	ror	r23
    11e4:	67 95       	ror	r22
    11e6:	b7 95       	ror	r27
    11e8:	f7 95       	ror	r31
    11ea:	e7 95       	ror	r30
    11ec:	9f 5f       	subi	r25, 0xFF	; 255
    11ee:	c1 f7       	brne	.-16     	; 0x11e0 <__mulsf3_pse+0x90>
    11f0:	fe 2b       	or	r31, r30
    11f2:	88 0f       	add	r24, r24
    11f4:	91 1d       	adc	r25, r1
    11f6:	96 95       	lsr	r25
    11f8:	87 95       	ror	r24
    11fa:	97 f9       	bld	r25, 7
    11fc:	08 95       	ret

000011fe <round>:
    11fe:	0e 94 6c 08 	call	0x10d8	; 0x10d8 <__fp_splitA>
    1202:	e8 f0       	brcs	.+58     	; 0x123e <round+0x40>
    1204:	9e 37       	cpi	r25, 0x7E	; 126
    1206:	e8 f0       	brcs	.+58     	; 0x1242 <round+0x44>
    1208:	96 39       	cpi	r25, 0x96	; 150
    120a:	b8 f4       	brcc	.+46     	; 0x123a <round+0x3c>
    120c:	9e 38       	cpi	r25, 0x8E	; 142
    120e:	48 f4       	brcc	.+18     	; 0x1222 <round+0x24>
    1210:	67 2f       	mov	r22, r23
    1212:	78 2f       	mov	r23, r24
    1214:	88 27       	eor	r24, r24
    1216:	98 5f       	subi	r25, 0xF8	; 248
    1218:	f9 cf       	rjmp	.-14     	; 0x120c <round+0xe>
    121a:	86 95       	lsr	r24
    121c:	77 95       	ror	r23
    121e:	67 95       	ror	r22
    1220:	93 95       	inc	r25
    1222:	95 39       	cpi	r25, 0x95	; 149
    1224:	d0 f3       	brcs	.-12     	; 0x121a <round+0x1c>
    1226:	b6 2f       	mov	r27, r22
    1228:	b1 70       	andi	r27, 0x01	; 1
    122a:	6b 0f       	add	r22, r27
    122c:	71 1d       	adc	r23, r1
    122e:	81 1d       	adc	r24, r1
    1230:	20 f4       	brcc	.+8      	; 0x123a <round+0x3c>
    1232:	87 95       	ror	r24
    1234:	77 95       	ror	r23
    1236:	67 95       	ror	r22
    1238:	93 95       	inc	r25
    123a:	0c 94 23 09 	jmp	0x1246	; 0x1246 <__fp_mintl>
    123e:	0c 94 3e 09 	jmp	0x127c	; 0x127c <__fp_mpack>
    1242:	0c 94 87 08 	jmp	0x110e	; 0x110e <__fp_szero>

00001246 <__fp_mintl>:
    1246:	88 23       	and	r24, r24
    1248:	71 f4       	brne	.+28     	; 0x1266 <__fp_mintl+0x20>
    124a:	77 23       	and	r23, r23
    124c:	21 f0       	breq	.+8      	; 0x1256 <__fp_mintl+0x10>
    124e:	98 50       	subi	r25, 0x08	; 8
    1250:	87 2b       	or	r24, r23
    1252:	76 2f       	mov	r23, r22
    1254:	07 c0       	rjmp	.+14     	; 0x1264 <__fp_mintl+0x1e>
    1256:	66 23       	and	r22, r22
    1258:	11 f4       	brne	.+4      	; 0x125e <__fp_mintl+0x18>
    125a:	99 27       	eor	r25, r25
    125c:	0d c0       	rjmp	.+26     	; 0x1278 <__fp_mintl+0x32>
    125e:	90 51       	subi	r25, 0x10	; 16
    1260:	86 2b       	or	r24, r22
    1262:	70 e0       	ldi	r23, 0x00	; 0
    1264:	60 e0       	ldi	r22, 0x00	; 0
    1266:	2a f0       	brmi	.+10     	; 0x1272 <__fp_mintl+0x2c>
    1268:	9a 95       	dec	r25
    126a:	66 0f       	add	r22, r22
    126c:	77 1f       	adc	r23, r23
    126e:	88 1f       	adc	r24, r24
    1270:	da f7       	brpl	.-10     	; 0x1268 <__fp_mintl+0x22>
    1272:	88 0f       	add	r24, r24
    1274:	96 95       	lsr	r25
    1276:	87 95       	ror	r24
    1278:	97 f9       	bld	r25, 7
    127a:	08 95       	ret

0000127c <__fp_mpack>:
    127c:	9f 3f       	cpi	r25, 0xFF	; 255
    127e:	31 f0       	breq	.+12     	; 0x128c <__fp_mpack_finite+0xc>

00001280 <__fp_mpack_finite>:
    1280:	91 50       	subi	r25, 0x01	; 1
    1282:	20 f4       	brcc	.+8      	; 0x128c <__fp_mpack_finite+0xc>
    1284:	87 95       	ror	r24
    1286:	77 95       	ror	r23
    1288:	67 95       	ror	r22
    128a:	b7 95       	ror	r27
    128c:	88 0f       	add	r24, r24
    128e:	91 1d       	adc	r25, r1
    1290:	96 95       	lsr	r25
    1292:	87 95       	ror	r24
    1294:	97 f9       	bld	r25, 7
    1296:	08 95       	ret

00001298 <dtostrf>:
    1298:	ef 92       	push	r14
    129a:	0f 93       	push	r16
    129c:	1f 93       	push	r17
    129e:	cf 93       	push	r28
    12a0:	df 93       	push	r29
    12a2:	e8 01       	movw	r28, r16
    12a4:	47 fd       	sbrc	r20, 7
    12a6:	02 c0       	rjmp	.+4      	; 0x12ac <dtostrf+0x14>
    12a8:	34 e0       	ldi	r19, 0x04	; 4
    12aa:	01 c0       	rjmp	.+2      	; 0x12ae <dtostrf+0x16>
    12ac:	34 e1       	ldi	r19, 0x14	; 20
    12ae:	04 2e       	mov	r0, r20
    12b0:	00 0c       	add	r0, r0
    12b2:	55 0b       	sbc	r21, r21
    12b4:	57 ff       	sbrs	r21, 7
    12b6:	03 c0       	rjmp	.+6      	; 0x12be <dtostrf+0x26>
    12b8:	51 95       	neg	r21
    12ba:	41 95       	neg	r20
    12bc:	51 09       	sbc	r21, r1
    12be:	e3 2e       	mov	r14, r19
    12c0:	02 2f       	mov	r16, r18
    12c2:	24 2f       	mov	r18, r20
    12c4:	ae 01       	movw	r20, r28
    12c6:	3d d3       	rcall	.+1658   	; 0x1942 <dtoa_prf>
    12c8:	ce 01       	movw	r24, r28
    12ca:	df 91       	pop	r29
    12cc:	cf 91       	pop	r28
    12ce:	1f 91       	pop	r17
    12d0:	0f 91       	pop	r16
    12d2:	ef 90       	pop	r14
    12d4:	08 95       	ret

000012d6 <malloc>:
    12d6:	0f 93       	push	r16
    12d8:	1f 93       	push	r17
    12da:	cf 93       	push	r28
    12dc:	df 93       	push	r29
    12de:	82 30       	cpi	r24, 0x02	; 2
    12e0:	91 05       	cpc	r25, r1
    12e2:	10 f4       	brcc	.+4      	; 0x12e8 <malloc+0x12>
    12e4:	82 e0       	ldi	r24, 0x02	; 2
    12e6:	90 e0       	ldi	r25, 0x00	; 0
    12e8:	e0 91 69 3e 	lds	r30, 0x3E69	; 0x803e69 <__flp>
    12ec:	f0 91 6a 3e 	lds	r31, 0x3E6A	; 0x803e6a <__flp+0x1>
    12f0:	20 e0       	ldi	r18, 0x00	; 0
    12f2:	30 e0       	ldi	r19, 0x00	; 0
    12f4:	a0 e0       	ldi	r26, 0x00	; 0
    12f6:	b0 e0       	ldi	r27, 0x00	; 0
    12f8:	30 97       	sbiw	r30, 0x00	; 0
    12fa:	19 f1       	breq	.+70     	; 0x1342 <malloc+0x6c>
    12fc:	40 81       	ld	r20, Z
    12fe:	51 81       	ldd	r21, Z+1	; 0x01
    1300:	02 81       	ldd	r16, Z+2	; 0x02
    1302:	13 81       	ldd	r17, Z+3	; 0x03
    1304:	48 17       	cp	r20, r24
    1306:	59 07       	cpc	r21, r25
    1308:	c8 f0       	brcs	.+50     	; 0x133c <malloc+0x66>
    130a:	84 17       	cp	r24, r20
    130c:	95 07       	cpc	r25, r21
    130e:	69 f4       	brne	.+26     	; 0x132a <malloc+0x54>
    1310:	10 97       	sbiw	r26, 0x00	; 0
    1312:	31 f0       	breq	.+12     	; 0x1320 <malloc+0x4a>
    1314:	12 96       	adiw	r26, 0x02	; 2
    1316:	0c 93       	st	X, r16
    1318:	12 97       	sbiw	r26, 0x02	; 2
    131a:	13 96       	adiw	r26, 0x03	; 3
    131c:	1c 93       	st	X, r17
    131e:	27 c0       	rjmp	.+78     	; 0x136e <malloc+0x98>
    1320:	00 93 69 3e 	sts	0x3E69, r16	; 0x803e69 <__flp>
    1324:	10 93 6a 3e 	sts	0x3E6A, r17	; 0x803e6a <__flp+0x1>
    1328:	22 c0       	rjmp	.+68     	; 0x136e <malloc+0x98>
    132a:	21 15       	cp	r18, r1
    132c:	31 05       	cpc	r19, r1
    132e:	19 f0       	breq	.+6      	; 0x1336 <malloc+0x60>
    1330:	42 17       	cp	r20, r18
    1332:	53 07       	cpc	r21, r19
    1334:	18 f4       	brcc	.+6      	; 0x133c <malloc+0x66>
    1336:	9a 01       	movw	r18, r20
    1338:	bd 01       	movw	r22, r26
    133a:	ef 01       	movw	r28, r30
    133c:	df 01       	movw	r26, r30
    133e:	f8 01       	movw	r30, r16
    1340:	db cf       	rjmp	.-74     	; 0x12f8 <malloc+0x22>
    1342:	21 15       	cp	r18, r1
    1344:	31 05       	cpc	r19, r1
    1346:	f9 f0       	breq	.+62     	; 0x1386 <malloc+0xb0>
    1348:	28 1b       	sub	r18, r24
    134a:	39 0b       	sbc	r19, r25
    134c:	24 30       	cpi	r18, 0x04	; 4
    134e:	31 05       	cpc	r19, r1
    1350:	80 f4       	brcc	.+32     	; 0x1372 <malloc+0x9c>
    1352:	8a 81       	ldd	r24, Y+2	; 0x02
    1354:	9b 81       	ldd	r25, Y+3	; 0x03
    1356:	61 15       	cp	r22, r1
    1358:	71 05       	cpc	r23, r1
    135a:	21 f0       	breq	.+8      	; 0x1364 <malloc+0x8e>
    135c:	fb 01       	movw	r30, r22
    135e:	82 83       	std	Z+2, r24	; 0x02
    1360:	93 83       	std	Z+3, r25	; 0x03
    1362:	04 c0       	rjmp	.+8      	; 0x136c <malloc+0x96>
    1364:	80 93 69 3e 	sts	0x3E69, r24	; 0x803e69 <__flp>
    1368:	90 93 6a 3e 	sts	0x3E6A, r25	; 0x803e6a <__flp+0x1>
    136c:	fe 01       	movw	r30, r28
    136e:	32 96       	adiw	r30, 0x02	; 2
    1370:	44 c0       	rjmp	.+136    	; 0x13fa <malloc+0x124>
    1372:	fe 01       	movw	r30, r28
    1374:	e2 0f       	add	r30, r18
    1376:	f3 1f       	adc	r31, r19
    1378:	81 93       	st	Z+, r24
    137a:	91 93       	st	Z+, r25
    137c:	22 50       	subi	r18, 0x02	; 2
    137e:	31 09       	sbc	r19, r1
    1380:	28 83       	st	Y, r18
    1382:	39 83       	std	Y+1, r19	; 0x01
    1384:	3a c0       	rjmp	.+116    	; 0x13fa <malloc+0x124>
    1386:	20 91 67 3e 	lds	r18, 0x3E67	; 0x803e67 <__brkval>
    138a:	30 91 68 3e 	lds	r19, 0x3E68	; 0x803e68 <__brkval+0x1>
    138e:	23 2b       	or	r18, r19
    1390:	41 f4       	brne	.+16     	; 0x13a2 <malloc+0xcc>
    1392:	20 91 02 3e 	lds	r18, 0x3E02	; 0x803e02 <__malloc_heap_start>
    1396:	30 91 03 3e 	lds	r19, 0x3E03	; 0x803e03 <__malloc_heap_start+0x1>
    139a:	20 93 67 3e 	sts	0x3E67, r18	; 0x803e67 <__brkval>
    139e:	30 93 68 3e 	sts	0x3E68, r19	; 0x803e68 <__brkval+0x1>
    13a2:	20 91 00 3e 	lds	r18, 0x3E00	; 0x803e00 <__data_start>
    13a6:	30 91 01 3e 	lds	r19, 0x3E01	; 0x803e01 <__data_start+0x1>
    13aa:	21 15       	cp	r18, r1
    13ac:	31 05       	cpc	r19, r1
    13ae:	41 f4       	brne	.+16     	; 0x13c0 <malloc+0xea>
    13b0:	2d b7       	in	r18, 0x3d	; 61
    13b2:	3e b7       	in	r19, 0x3e	; 62
    13b4:	40 91 04 3e 	lds	r20, 0x3E04	; 0x803e04 <__malloc_margin>
    13b8:	50 91 05 3e 	lds	r21, 0x3E05	; 0x803e05 <__malloc_margin+0x1>
    13bc:	24 1b       	sub	r18, r20
    13be:	35 0b       	sbc	r19, r21
    13c0:	e0 91 67 3e 	lds	r30, 0x3E67	; 0x803e67 <__brkval>
    13c4:	f0 91 68 3e 	lds	r31, 0x3E68	; 0x803e68 <__brkval+0x1>
    13c8:	e2 17       	cp	r30, r18
    13ca:	f3 07       	cpc	r31, r19
    13cc:	a0 f4       	brcc	.+40     	; 0x13f6 <malloc+0x120>
    13ce:	2e 1b       	sub	r18, r30
    13d0:	3f 0b       	sbc	r19, r31
    13d2:	28 17       	cp	r18, r24
    13d4:	39 07       	cpc	r19, r25
    13d6:	78 f0       	brcs	.+30     	; 0x13f6 <malloc+0x120>
    13d8:	ac 01       	movw	r20, r24
    13da:	4e 5f       	subi	r20, 0xFE	; 254
    13dc:	5f 4f       	sbci	r21, 0xFF	; 255
    13de:	24 17       	cp	r18, r20
    13e0:	35 07       	cpc	r19, r21
    13e2:	48 f0       	brcs	.+18     	; 0x13f6 <malloc+0x120>
    13e4:	4e 0f       	add	r20, r30
    13e6:	5f 1f       	adc	r21, r31
    13e8:	40 93 67 3e 	sts	0x3E67, r20	; 0x803e67 <__brkval>
    13ec:	50 93 68 3e 	sts	0x3E68, r21	; 0x803e68 <__brkval+0x1>
    13f0:	81 93       	st	Z+, r24
    13f2:	91 93       	st	Z+, r25
    13f4:	02 c0       	rjmp	.+4      	; 0x13fa <malloc+0x124>
    13f6:	e0 e0       	ldi	r30, 0x00	; 0
    13f8:	f0 e0       	ldi	r31, 0x00	; 0
    13fa:	cf 01       	movw	r24, r30
    13fc:	df 91       	pop	r29
    13fe:	cf 91       	pop	r28
    1400:	1f 91       	pop	r17
    1402:	0f 91       	pop	r16
    1404:	08 95       	ret

00001406 <free>:
    1406:	cf 93       	push	r28
    1408:	df 93       	push	r29
    140a:	00 97       	sbiw	r24, 0x00	; 0
    140c:	09 f4       	brne	.+2      	; 0x1410 <free+0xa>
    140e:	81 c0       	rjmp	.+258    	; 0x1512 <free+0x10c>
    1410:	fc 01       	movw	r30, r24
    1412:	32 97       	sbiw	r30, 0x02	; 2
    1414:	12 82       	std	Z+2, r1	; 0x02
    1416:	13 82       	std	Z+3, r1	; 0x03
    1418:	a0 91 69 3e 	lds	r26, 0x3E69	; 0x803e69 <__flp>
    141c:	b0 91 6a 3e 	lds	r27, 0x3E6A	; 0x803e6a <__flp+0x1>
    1420:	10 97       	sbiw	r26, 0x00	; 0
    1422:	81 f4       	brne	.+32     	; 0x1444 <free+0x3e>
    1424:	20 81       	ld	r18, Z
    1426:	31 81       	ldd	r19, Z+1	; 0x01
    1428:	82 0f       	add	r24, r18
    142a:	93 1f       	adc	r25, r19
    142c:	20 91 67 3e 	lds	r18, 0x3E67	; 0x803e67 <__brkval>
    1430:	30 91 68 3e 	lds	r19, 0x3E68	; 0x803e68 <__brkval+0x1>
    1434:	28 17       	cp	r18, r24
    1436:	39 07       	cpc	r19, r25
    1438:	51 f5       	brne	.+84     	; 0x148e <free+0x88>
    143a:	e0 93 67 3e 	sts	0x3E67, r30	; 0x803e67 <__brkval>
    143e:	f0 93 68 3e 	sts	0x3E68, r31	; 0x803e68 <__brkval+0x1>
    1442:	67 c0       	rjmp	.+206    	; 0x1512 <free+0x10c>
    1444:	ed 01       	movw	r28, r26
    1446:	20 e0       	ldi	r18, 0x00	; 0
    1448:	30 e0       	ldi	r19, 0x00	; 0
    144a:	ce 17       	cp	r28, r30
    144c:	df 07       	cpc	r29, r31
    144e:	40 f4       	brcc	.+16     	; 0x1460 <free+0x5a>
    1450:	4a 81       	ldd	r20, Y+2	; 0x02
    1452:	5b 81       	ldd	r21, Y+3	; 0x03
    1454:	9e 01       	movw	r18, r28
    1456:	41 15       	cp	r20, r1
    1458:	51 05       	cpc	r21, r1
    145a:	f1 f0       	breq	.+60     	; 0x1498 <free+0x92>
    145c:	ea 01       	movw	r28, r20
    145e:	f5 cf       	rjmp	.-22     	; 0x144a <free+0x44>
    1460:	c2 83       	std	Z+2, r28	; 0x02
    1462:	d3 83       	std	Z+3, r29	; 0x03
    1464:	40 81       	ld	r20, Z
    1466:	51 81       	ldd	r21, Z+1	; 0x01
    1468:	84 0f       	add	r24, r20
    146a:	95 1f       	adc	r25, r21
    146c:	c8 17       	cp	r28, r24
    146e:	d9 07       	cpc	r29, r25
    1470:	59 f4       	brne	.+22     	; 0x1488 <free+0x82>
    1472:	88 81       	ld	r24, Y
    1474:	99 81       	ldd	r25, Y+1	; 0x01
    1476:	84 0f       	add	r24, r20
    1478:	95 1f       	adc	r25, r21
    147a:	02 96       	adiw	r24, 0x02	; 2
    147c:	80 83       	st	Z, r24
    147e:	91 83       	std	Z+1, r25	; 0x01
    1480:	8a 81       	ldd	r24, Y+2	; 0x02
    1482:	9b 81       	ldd	r25, Y+3	; 0x03
    1484:	82 83       	std	Z+2, r24	; 0x02
    1486:	93 83       	std	Z+3, r25	; 0x03
    1488:	21 15       	cp	r18, r1
    148a:	31 05       	cpc	r19, r1
    148c:	29 f4       	brne	.+10     	; 0x1498 <free+0x92>
    148e:	e0 93 69 3e 	sts	0x3E69, r30	; 0x803e69 <__flp>
    1492:	f0 93 6a 3e 	sts	0x3E6A, r31	; 0x803e6a <__flp+0x1>
    1496:	3d c0       	rjmp	.+122    	; 0x1512 <free+0x10c>
    1498:	e9 01       	movw	r28, r18
    149a:	ea 83       	std	Y+2, r30	; 0x02
    149c:	fb 83       	std	Y+3, r31	; 0x03
    149e:	49 91       	ld	r20, Y+
    14a0:	59 91       	ld	r21, Y+
    14a2:	c4 0f       	add	r28, r20
    14a4:	d5 1f       	adc	r29, r21
    14a6:	ec 17       	cp	r30, r28
    14a8:	fd 07       	cpc	r31, r29
    14aa:	61 f4       	brne	.+24     	; 0x14c4 <free+0xbe>
    14ac:	80 81       	ld	r24, Z
    14ae:	91 81       	ldd	r25, Z+1	; 0x01
    14b0:	84 0f       	add	r24, r20
    14b2:	95 1f       	adc	r25, r21
    14b4:	02 96       	adiw	r24, 0x02	; 2
    14b6:	e9 01       	movw	r28, r18
    14b8:	88 83       	st	Y, r24
    14ba:	99 83       	std	Y+1, r25	; 0x01
    14bc:	82 81       	ldd	r24, Z+2	; 0x02
    14be:	93 81       	ldd	r25, Z+3	; 0x03
    14c0:	8a 83       	std	Y+2, r24	; 0x02
    14c2:	9b 83       	std	Y+3, r25	; 0x03
    14c4:	e0 e0       	ldi	r30, 0x00	; 0
    14c6:	f0 e0       	ldi	r31, 0x00	; 0
    14c8:	12 96       	adiw	r26, 0x02	; 2
    14ca:	8d 91       	ld	r24, X+
    14cc:	9c 91       	ld	r25, X
    14ce:	13 97       	sbiw	r26, 0x03	; 3
    14d0:	00 97       	sbiw	r24, 0x00	; 0
    14d2:	19 f0       	breq	.+6      	; 0x14da <free+0xd4>
    14d4:	fd 01       	movw	r30, r26
    14d6:	dc 01       	movw	r26, r24
    14d8:	f7 cf       	rjmp	.-18     	; 0x14c8 <free+0xc2>
    14da:	8d 91       	ld	r24, X+
    14dc:	9c 91       	ld	r25, X
    14de:	11 97       	sbiw	r26, 0x01	; 1
    14e0:	9d 01       	movw	r18, r26
    14e2:	2e 5f       	subi	r18, 0xFE	; 254
    14e4:	3f 4f       	sbci	r19, 0xFF	; 255
    14e6:	82 0f       	add	r24, r18
    14e8:	93 1f       	adc	r25, r19
    14ea:	20 91 67 3e 	lds	r18, 0x3E67	; 0x803e67 <__brkval>
    14ee:	30 91 68 3e 	lds	r19, 0x3E68	; 0x803e68 <__brkval+0x1>
    14f2:	28 17       	cp	r18, r24
    14f4:	39 07       	cpc	r19, r25
    14f6:	69 f4       	brne	.+26     	; 0x1512 <free+0x10c>
    14f8:	30 97       	sbiw	r30, 0x00	; 0
    14fa:	29 f4       	brne	.+10     	; 0x1506 <free+0x100>
    14fc:	10 92 69 3e 	sts	0x3E69, r1	; 0x803e69 <__flp>
    1500:	10 92 6a 3e 	sts	0x3E6A, r1	; 0x803e6a <__flp+0x1>
    1504:	02 c0       	rjmp	.+4      	; 0x150a <free+0x104>
    1506:	12 82       	std	Z+2, r1	; 0x02
    1508:	13 82       	std	Z+3, r1	; 0x03
    150a:	a0 93 67 3e 	sts	0x3E67, r26	; 0x803e67 <__brkval>
    150e:	b0 93 68 3e 	sts	0x3E68, r27	; 0x803e68 <__brkval+0x1>
    1512:	df 91       	pop	r29
    1514:	cf 91       	pop	r28
    1516:	08 95       	ret

00001518 <printf>:
    1518:	a0 e0       	ldi	r26, 0x00	; 0
    151a:	b0 e0       	ldi	r27, 0x00	; 0
    151c:	e1 e9       	ldi	r30, 0x91	; 145
    151e:	fa e0       	ldi	r31, 0x0A	; 10
    1520:	ff c4       	rjmp	.+2558   	; 0x1f20 <__prologue_saves__+0x20>
    1522:	ae 01       	movw	r20, r28
    1524:	4b 5f       	subi	r20, 0xFB	; 251
    1526:	5f 4f       	sbci	r21, 0xFF	; 255
    1528:	fa 01       	movw	r30, r20
    152a:	61 91       	ld	r22, Z+
    152c:	71 91       	ld	r23, Z+
    152e:	af 01       	movw	r20, r30
    1530:	80 91 6d 3e 	lds	r24, 0x3E6D	; 0x803e6d <__iob+0x2>
    1534:	90 91 6e 3e 	lds	r25, 0x3E6E	; 0x803e6e <__iob+0x3>
    1538:	32 d0       	rcall	.+100    	; 0x159e <vfprintf>
    153a:	e2 e0       	ldi	r30, 0x02	; 2
    153c:	0a c5       	rjmp	.+2580   	; 0x1f52 <__epilogue_restores__+0x20>

0000153e <puts>:
    153e:	0f 93       	push	r16
    1540:	1f 93       	push	r17
    1542:	cf 93       	push	r28
    1544:	df 93       	push	r29
    1546:	e0 91 6d 3e 	lds	r30, 0x3E6D	; 0x803e6d <__iob+0x2>
    154a:	f0 91 6e 3e 	lds	r31, 0x3E6E	; 0x803e6e <__iob+0x3>
    154e:	23 81       	ldd	r18, Z+3	; 0x03
    1550:	21 ff       	sbrs	r18, 1
    1552:	1b c0       	rjmp	.+54     	; 0x158a <puts+0x4c>
    1554:	8c 01       	movw	r16, r24
    1556:	d0 e0       	ldi	r29, 0x00	; 0
    1558:	c0 e0       	ldi	r28, 0x00	; 0
    155a:	f8 01       	movw	r30, r16
    155c:	81 91       	ld	r24, Z+
    155e:	8f 01       	movw	r16, r30
    1560:	60 91 6d 3e 	lds	r22, 0x3E6D	; 0x803e6d <__iob+0x2>
    1564:	70 91 6e 3e 	lds	r23, 0x3E6E	; 0x803e6e <__iob+0x3>
    1568:	db 01       	movw	r26, r22
    156a:	18 96       	adiw	r26, 0x08	; 8
    156c:	ed 91       	ld	r30, X+
    156e:	fc 91       	ld	r31, X
    1570:	19 97       	sbiw	r26, 0x09	; 9
    1572:	88 23       	and	r24, r24
    1574:	31 f0       	breq	.+12     	; 0x1582 <puts+0x44>
    1576:	09 95       	icall
    1578:	89 2b       	or	r24, r25
    157a:	79 f3       	breq	.-34     	; 0x155a <puts+0x1c>
    157c:	df ef       	ldi	r29, 0xFF	; 255
    157e:	cf ef       	ldi	r28, 0xFF	; 255
    1580:	ec cf       	rjmp	.-40     	; 0x155a <puts+0x1c>
    1582:	8a e0       	ldi	r24, 0x0A	; 10
    1584:	09 95       	icall
    1586:	89 2b       	or	r24, r25
    1588:	19 f0       	breq	.+6      	; 0x1590 <puts+0x52>
    158a:	8f ef       	ldi	r24, 0xFF	; 255
    158c:	9f ef       	ldi	r25, 0xFF	; 255
    158e:	02 c0       	rjmp	.+4      	; 0x1594 <puts+0x56>
    1590:	8d 2f       	mov	r24, r29
    1592:	9c 2f       	mov	r25, r28
    1594:	df 91       	pop	r29
    1596:	cf 91       	pop	r28
    1598:	1f 91       	pop	r17
    159a:	0f 91       	pop	r16
    159c:	08 95       	ret

0000159e <vfprintf>:
    159e:	ab e0       	ldi	r26, 0x0B	; 11
    15a0:	b0 e0       	ldi	r27, 0x00	; 0
    15a2:	e4 ed       	ldi	r30, 0xD4	; 212
    15a4:	fa e0       	ldi	r31, 0x0A	; 10
    15a6:	ac c4       	rjmp	.+2392   	; 0x1f00 <__prologue_saves__>
    15a8:	6c 01       	movw	r12, r24
    15aa:	7b 01       	movw	r14, r22
    15ac:	8a 01       	movw	r16, r20
    15ae:	fc 01       	movw	r30, r24
    15b0:	16 82       	std	Z+6, r1	; 0x06
    15b2:	17 82       	std	Z+7, r1	; 0x07
    15b4:	83 81       	ldd	r24, Z+3	; 0x03
    15b6:	81 ff       	sbrs	r24, 1
    15b8:	bf c1       	rjmp	.+894    	; 0x1938 <vfprintf+0x39a>
    15ba:	ce 01       	movw	r24, r28
    15bc:	01 96       	adiw	r24, 0x01	; 1
    15be:	3c 01       	movw	r6, r24
    15c0:	f6 01       	movw	r30, r12
    15c2:	93 81       	ldd	r25, Z+3	; 0x03
    15c4:	f7 01       	movw	r30, r14
    15c6:	93 fd       	sbrc	r25, 3
    15c8:	85 91       	lpm	r24, Z+
    15ca:	93 ff       	sbrs	r25, 3
    15cc:	81 91       	ld	r24, Z+
    15ce:	7f 01       	movw	r14, r30
    15d0:	88 23       	and	r24, r24
    15d2:	09 f4       	brne	.+2      	; 0x15d6 <vfprintf+0x38>
    15d4:	ad c1       	rjmp	.+858    	; 0x1930 <vfprintf+0x392>
    15d6:	85 32       	cpi	r24, 0x25	; 37
    15d8:	39 f4       	brne	.+14     	; 0x15e8 <vfprintf+0x4a>
    15da:	93 fd       	sbrc	r25, 3
    15dc:	85 91       	lpm	r24, Z+
    15de:	93 ff       	sbrs	r25, 3
    15e0:	81 91       	ld	r24, Z+
    15e2:	7f 01       	movw	r14, r30
    15e4:	85 32       	cpi	r24, 0x25	; 37
    15e6:	21 f4       	brne	.+8      	; 0x15f0 <vfprintf+0x52>
    15e8:	b6 01       	movw	r22, r12
    15ea:	90 e0       	ldi	r25, 0x00	; 0
    15ec:	ef d3       	rcall	.+2014   	; 0x1dcc <fputc>
    15ee:	e8 cf       	rjmp	.-48     	; 0x15c0 <vfprintf+0x22>
    15f0:	91 2c       	mov	r9, r1
    15f2:	21 2c       	mov	r2, r1
    15f4:	31 2c       	mov	r3, r1
    15f6:	ff e1       	ldi	r31, 0x1F	; 31
    15f8:	f3 15       	cp	r31, r3
    15fa:	d8 f0       	brcs	.+54     	; 0x1632 <vfprintf+0x94>
    15fc:	8b 32       	cpi	r24, 0x2B	; 43
    15fe:	79 f0       	breq	.+30     	; 0x161e <vfprintf+0x80>
    1600:	38 f4       	brcc	.+14     	; 0x1610 <vfprintf+0x72>
    1602:	80 32       	cpi	r24, 0x20	; 32
    1604:	79 f0       	breq	.+30     	; 0x1624 <vfprintf+0x86>
    1606:	83 32       	cpi	r24, 0x23	; 35
    1608:	a1 f4       	brne	.+40     	; 0x1632 <vfprintf+0x94>
    160a:	23 2d       	mov	r18, r3
    160c:	20 61       	ori	r18, 0x10	; 16
    160e:	1d c0       	rjmp	.+58     	; 0x164a <vfprintf+0xac>
    1610:	8d 32       	cpi	r24, 0x2D	; 45
    1612:	61 f0       	breq	.+24     	; 0x162c <vfprintf+0x8e>
    1614:	80 33       	cpi	r24, 0x30	; 48
    1616:	69 f4       	brne	.+26     	; 0x1632 <vfprintf+0x94>
    1618:	23 2d       	mov	r18, r3
    161a:	21 60       	ori	r18, 0x01	; 1
    161c:	16 c0       	rjmp	.+44     	; 0x164a <vfprintf+0xac>
    161e:	83 2d       	mov	r24, r3
    1620:	82 60       	ori	r24, 0x02	; 2
    1622:	38 2e       	mov	r3, r24
    1624:	e3 2d       	mov	r30, r3
    1626:	e4 60       	ori	r30, 0x04	; 4
    1628:	3e 2e       	mov	r3, r30
    162a:	2a c0       	rjmp	.+84     	; 0x1680 <vfprintf+0xe2>
    162c:	f3 2d       	mov	r31, r3
    162e:	f8 60       	ori	r31, 0x08	; 8
    1630:	1d c0       	rjmp	.+58     	; 0x166c <vfprintf+0xce>
    1632:	37 fc       	sbrc	r3, 7
    1634:	2d c0       	rjmp	.+90     	; 0x1690 <vfprintf+0xf2>
    1636:	20 ed       	ldi	r18, 0xD0	; 208
    1638:	28 0f       	add	r18, r24
    163a:	2a 30       	cpi	r18, 0x0A	; 10
    163c:	40 f0       	brcs	.+16     	; 0x164e <vfprintf+0xb0>
    163e:	8e 32       	cpi	r24, 0x2E	; 46
    1640:	b9 f4       	brne	.+46     	; 0x1670 <vfprintf+0xd2>
    1642:	36 fc       	sbrc	r3, 6
    1644:	75 c1       	rjmp	.+746    	; 0x1930 <vfprintf+0x392>
    1646:	23 2d       	mov	r18, r3
    1648:	20 64       	ori	r18, 0x40	; 64
    164a:	32 2e       	mov	r3, r18
    164c:	19 c0       	rjmp	.+50     	; 0x1680 <vfprintf+0xe2>
    164e:	36 fe       	sbrs	r3, 6
    1650:	06 c0       	rjmp	.+12     	; 0x165e <vfprintf+0xc0>
    1652:	8a e0       	ldi	r24, 0x0A	; 10
    1654:	98 9e       	mul	r9, r24
    1656:	20 0d       	add	r18, r0
    1658:	11 24       	eor	r1, r1
    165a:	92 2e       	mov	r9, r18
    165c:	11 c0       	rjmp	.+34     	; 0x1680 <vfprintf+0xe2>
    165e:	ea e0       	ldi	r30, 0x0A	; 10
    1660:	2e 9e       	mul	r2, r30
    1662:	20 0d       	add	r18, r0
    1664:	11 24       	eor	r1, r1
    1666:	22 2e       	mov	r2, r18
    1668:	f3 2d       	mov	r31, r3
    166a:	f0 62       	ori	r31, 0x20	; 32
    166c:	3f 2e       	mov	r3, r31
    166e:	08 c0       	rjmp	.+16     	; 0x1680 <vfprintf+0xe2>
    1670:	8c 36       	cpi	r24, 0x6C	; 108
    1672:	21 f4       	brne	.+8      	; 0x167c <vfprintf+0xde>
    1674:	83 2d       	mov	r24, r3
    1676:	80 68       	ori	r24, 0x80	; 128
    1678:	38 2e       	mov	r3, r24
    167a:	02 c0       	rjmp	.+4      	; 0x1680 <vfprintf+0xe2>
    167c:	88 36       	cpi	r24, 0x68	; 104
    167e:	41 f4       	brne	.+16     	; 0x1690 <vfprintf+0xf2>
    1680:	f7 01       	movw	r30, r14
    1682:	93 fd       	sbrc	r25, 3
    1684:	85 91       	lpm	r24, Z+
    1686:	93 ff       	sbrs	r25, 3
    1688:	81 91       	ld	r24, Z+
    168a:	7f 01       	movw	r14, r30
    168c:	81 11       	cpse	r24, r1
    168e:	b3 cf       	rjmp	.-154    	; 0x15f6 <vfprintf+0x58>
    1690:	98 2f       	mov	r25, r24
    1692:	9f 7d       	andi	r25, 0xDF	; 223
    1694:	95 54       	subi	r25, 0x45	; 69
    1696:	93 30       	cpi	r25, 0x03	; 3
    1698:	28 f4       	brcc	.+10     	; 0x16a4 <vfprintf+0x106>
    169a:	0c 5f       	subi	r16, 0xFC	; 252
    169c:	1f 4f       	sbci	r17, 0xFF	; 255
    169e:	9f e3       	ldi	r25, 0x3F	; 63
    16a0:	99 83       	std	Y+1, r25	; 0x01
    16a2:	0d c0       	rjmp	.+26     	; 0x16be <vfprintf+0x120>
    16a4:	83 36       	cpi	r24, 0x63	; 99
    16a6:	31 f0       	breq	.+12     	; 0x16b4 <vfprintf+0x116>
    16a8:	83 37       	cpi	r24, 0x73	; 115
    16aa:	71 f0       	breq	.+28     	; 0x16c8 <vfprintf+0x12a>
    16ac:	83 35       	cpi	r24, 0x53	; 83
    16ae:	09 f0       	breq	.+2      	; 0x16b2 <vfprintf+0x114>
    16b0:	55 c0       	rjmp	.+170    	; 0x175c <vfprintf+0x1be>
    16b2:	20 c0       	rjmp	.+64     	; 0x16f4 <vfprintf+0x156>
    16b4:	f8 01       	movw	r30, r16
    16b6:	80 81       	ld	r24, Z
    16b8:	89 83       	std	Y+1, r24	; 0x01
    16ba:	0e 5f       	subi	r16, 0xFE	; 254
    16bc:	1f 4f       	sbci	r17, 0xFF	; 255
    16be:	88 24       	eor	r8, r8
    16c0:	83 94       	inc	r8
    16c2:	91 2c       	mov	r9, r1
    16c4:	53 01       	movw	r10, r6
    16c6:	12 c0       	rjmp	.+36     	; 0x16ec <vfprintf+0x14e>
    16c8:	28 01       	movw	r4, r16
    16ca:	f2 e0       	ldi	r31, 0x02	; 2
    16cc:	4f 0e       	add	r4, r31
    16ce:	51 1c       	adc	r5, r1
    16d0:	f8 01       	movw	r30, r16
    16d2:	a0 80       	ld	r10, Z
    16d4:	b1 80       	ldd	r11, Z+1	; 0x01
    16d6:	36 fe       	sbrs	r3, 6
    16d8:	03 c0       	rjmp	.+6      	; 0x16e0 <vfprintf+0x142>
    16da:	69 2d       	mov	r22, r9
    16dc:	70 e0       	ldi	r23, 0x00	; 0
    16de:	02 c0       	rjmp	.+4      	; 0x16e4 <vfprintf+0x146>
    16e0:	6f ef       	ldi	r22, 0xFF	; 255
    16e2:	7f ef       	ldi	r23, 0xFF	; 255
    16e4:	c5 01       	movw	r24, r10
    16e6:	67 d3       	rcall	.+1742   	; 0x1db6 <strnlen>
    16e8:	4c 01       	movw	r8, r24
    16ea:	82 01       	movw	r16, r4
    16ec:	f3 2d       	mov	r31, r3
    16ee:	ff 77       	andi	r31, 0x7F	; 127
    16f0:	3f 2e       	mov	r3, r31
    16f2:	15 c0       	rjmp	.+42     	; 0x171e <vfprintf+0x180>
    16f4:	28 01       	movw	r4, r16
    16f6:	22 e0       	ldi	r18, 0x02	; 2
    16f8:	42 0e       	add	r4, r18
    16fa:	51 1c       	adc	r5, r1
    16fc:	f8 01       	movw	r30, r16
    16fe:	a0 80       	ld	r10, Z
    1700:	b1 80       	ldd	r11, Z+1	; 0x01
    1702:	36 fe       	sbrs	r3, 6
    1704:	03 c0       	rjmp	.+6      	; 0x170c <vfprintf+0x16e>
    1706:	69 2d       	mov	r22, r9
    1708:	70 e0       	ldi	r23, 0x00	; 0
    170a:	02 c0       	rjmp	.+4      	; 0x1710 <vfprintf+0x172>
    170c:	6f ef       	ldi	r22, 0xFF	; 255
    170e:	7f ef       	ldi	r23, 0xFF	; 255
    1710:	c5 01       	movw	r24, r10
    1712:	46 d3       	rcall	.+1676   	; 0x1da0 <strnlen_P>
    1714:	4c 01       	movw	r8, r24
    1716:	f3 2d       	mov	r31, r3
    1718:	f0 68       	ori	r31, 0x80	; 128
    171a:	3f 2e       	mov	r3, r31
    171c:	82 01       	movw	r16, r4
    171e:	33 fc       	sbrc	r3, 3
    1720:	19 c0       	rjmp	.+50     	; 0x1754 <vfprintf+0x1b6>
    1722:	82 2d       	mov	r24, r2
    1724:	90 e0       	ldi	r25, 0x00	; 0
    1726:	88 16       	cp	r8, r24
    1728:	99 06       	cpc	r9, r25
    172a:	a0 f4       	brcc	.+40     	; 0x1754 <vfprintf+0x1b6>
    172c:	b6 01       	movw	r22, r12
    172e:	80 e2       	ldi	r24, 0x20	; 32
    1730:	90 e0       	ldi	r25, 0x00	; 0
    1732:	4c d3       	rcall	.+1688   	; 0x1dcc <fputc>
    1734:	2a 94       	dec	r2
    1736:	f5 cf       	rjmp	.-22     	; 0x1722 <vfprintf+0x184>
    1738:	f5 01       	movw	r30, r10
    173a:	37 fc       	sbrc	r3, 7
    173c:	85 91       	lpm	r24, Z+
    173e:	37 fe       	sbrs	r3, 7
    1740:	81 91       	ld	r24, Z+
    1742:	5f 01       	movw	r10, r30
    1744:	b6 01       	movw	r22, r12
    1746:	90 e0       	ldi	r25, 0x00	; 0
    1748:	41 d3       	rcall	.+1666   	; 0x1dcc <fputc>
    174a:	21 10       	cpse	r2, r1
    174c:	2a 94       	dec	r2
    174e:	21 e0       	ldi	r18, 0x01	; 1
    1750:	82 1a       	sub	r8, r18
    1752:	91 08       	sbc	r9, r1
    1754:	81 14       	cp	r8, r1
    1756:	91 04       	cpc	r9, r1
    1758:	79 f7       	brne	.-34     	; 0x1738 <vfprintf+0x19a>
    175a:	e1 c0       	rjmp	.+450    	; 0x191e <vfprintf+0x380>
    175c:	84 36       	cpi	r24, 0x64	; 100
    175e:	11 f0       	breq	.+4      	; 0x1764 <vfprintf+0x1c6>
    1760:	89 36       	cpi	r24, 0x69	; 105
    1762:	39 f5       	brne	.+78     	; 0x17b2 <vfprintf+0x214>
    1764:	f8 01       	movw	r30, r16
    1766:	37 fe       	sbrs	r3, 7
    1768:	07 c0       	rjmp	.+14     	; 0x1778 <vfprintf+0x1da>
    176a:	60 81       	ld	r22, Z
    176c:	71 81       	ldd	r23, Z+1	; 0x01
    176e:	82 81       	ldd	r24, Z+2	; 0x02
    1770:	93 81       	ldd	r25, Z+3	; 0x03
    1772:	0c 5f       	subi	r16, 0xFC	; 252
    1774:	1f 4f       	sbci	r17, 0xFF	; 255
    1776:	08 c0       	rjmp	.+16     	; 0x1788 <vfprintf+0x1ea>
    1778:	60 81       	ld	r22, Z
    177a:	71 81       	ldd	r23, Z+1	; 0x01
    177c:	07 2e       	mov	r0, r23
    177e:	00 0c       	add	r0, r0
    1780:	88 0b       	sbc	r24, r24
    1782:	99 0b       	sbc	r25, r25
    1784:	0e 5f       	subi	r16, 0xFE	; 254
    1786:	1f 4f       	sbci	r17, 0xFF	; 255
    1788:	f3 2d       	mov	r31, r3
    178a:	ff 76       	andi	r31, 0x6F	; 111
    178c:	3f 2e       	mov	r3, r31
    178e:	97 ff       	sbrs	r25, 7
    1790:	09 c0       	rjmp	.+18     	; 0x17a4 <vfprintf+0x206>
    1792:	90 95       	com	r25
    1794:	80 95       	com	r24
    1796:	70 95       	com	r23
    1798:	61 95       	neg	r22
    179a:	7f 4f       	sbci	r23, 0xFF	; 255
    179c:	8f 4f       	sbci	r24, 0xFF	; 255
    179e:	9f 4f       	sbci	r25, 0xFF	; 255
    17a0:	f0 68       	ori	r31, 0x80	; 128
    17a2:	3f 2e       	mov	r3, r31
    17a4:	2a e0       	ldi	r18, 0x0A	; 10
    17a6:	30 e0       	ldi	r19, 0x00	; 0
    17a8:	a3 01       	movw	r20, r6
    17aa:	4c d3       	rcall	.+1688   	; 0x1e44 <__ultoa_invert>
    17ac:	88 2e       	mov	r8, r24
    17ae:	86 18       	sub	r8, r6
    17b0:	44 c0       	rjmp	.+136    	; 0x183a <vfprintf+0x29c>
    17b2:	85 37       	cpi	r24, 0x75	; 117
    17b4:	31 f4       	brne	.+12     	; 0x17c2 <vfprintf+0x224>
    17b6:	23 2d       	mov	r18, r3
    17b8:	2f 7e       	andi	r18, 0xEF	; 239
    17ba:	b2 2e       	mov	r11, r18
    17bc:	2a e0       	ldi	r18, 0x0A	; 10
    17be:	30 e0       	ldi	r19, 0x00	; 0
    17c0:	25 c0       	rjmp	.+74     	; 0x180c <vfprintf+0x26e>
    17c2:	93 2d       	mov	r25, r3
    17c4:	99 7f       	andi	r25, 0xF9	; 249
    17c6:	b9 2e       	mov	r11, r25
    17c8:	8f 36       	cpi	r24, 0x6F	; 111
    17ca:	c1 f0       	breq	.+48     	; 0x17fc <vfprintf+0x25e>
    17cc:	18 f4       	brcc	.+6      	; 0x17d4 <vfprintf+0x236>
    17ce:	88 35       	cpi	r24, 0x58	; 88
    17d0:	79 f0       	breq	.+30     	; 0x17f0 <vfprintf+0x252>
    17d2:	ae c0       	rjmp	.+348    	; 0x1930 <vfprintf+0x392>
    17d4:	80 37       	cpi	r24, 0x70	; 112
    17d6:	19 f0       	breq	.+6      	; 0x17de <vfprintf+0x240>
    17d8:	88 37       	cpi	r24, 0x78	; 120
    17da:	21 f0       	breq	.+8      	; 0x17e4 <vfprintf+0x246>
    17dc:	a9 c0       	rjmp	.+338    	; 0x1930 <vfprintf+0x392>
    17de:	e9 2f       	mov	r30, r25
    17e0:	e0 61       	ori	r30, 0x10	; 16
    17e2:	be 2e       	mov	r11, r30
    17e4:	b4 fe       	sbrs	r11, 4
    17e6:	0d c0       	rjmp	.+26     	; 0x1802 <vfprintf+0x264>
    17e8:	fb 2d       	mov	r31, r11
    17ea:	f4 60       	ori	r31, 0x04	; 4
    17ec:	bf 2e       	mov	r11, r31
    17ee:	09 c0       	rjmp	.+18     	; 0x1802 <vfprintf+0x264>
    17f0:	34 fe       	sbrs	r3, 4
    17f2:	0a c0       	rjmp	.+20     	; 0x1808 <vfprintf+0x26a>
    17f4:	29 2f       	mov	r18, r25
    17f6:	26 60       	ori	r18, 0x06	; 6
    17f8:	b2 2e       	mov	r11, r18
    17fa:	06 c0       	rjmp	.+12     	; 0x1808 <vfprintf+0x26a>
    17fc:	28 e0       	ldi	r18, 0x08	; 8
    17fe:	30 e0       	ldi	r19, 0x00	; 0
    1800:	05 c0       	rjmp	.+10     	; 0x180c <vfprintf+0x26e>
    1802:	20 e1       	ldi	r18, 0x10	; 16
    1804:	30 e0       	ldi	r19, 0x00	; 0
    1806:	02 c0       	rjmp	.+4      	; 0x180c <vfprintf+0x26e>
    1808:	20 e1       	ldi	r18, 0x10	; 16
    180a:	32 e0       	ldi	r19, 0x02	; 2
    180c:	f8 01       	movw	r30, r16
    180e:	b7 fe       	sbrs	r11, 7
    1810:	07 c0       	rjmp	.+14     	; 0x1820 <vfprintf+0x282>
    1812:	60 81       	ld	r22, Z
    1814:	71 81       	ldd	r23, Z+1	; 0x01
    1816:	82 81       	ldd	r24, Z+2	; 0x02
    1818:	93 81       	ldd	r25, Z+3	; 0x03
    181a:	0c 5f       	subi	r16, 0xFC	; 252
    181c:	1f 4f       	sbci	r17, 0xFF	; 255
    181e:	06 c0       	rjmp	.+12     	; 0x182c <vfprintf+0x28e>
    1820:	60 81       	ld	r22, Z
    1822:	71 81       	ldd	r23, Z+1	; 0x01
    1824:	80 e0       	ldi	r24, 0x00	; 0
    1826:	90 e0       	ldi	r25, 0x00	; 0
    1828:	0e 5f       	subi	r16, 0xFE	; 254
    182a:	1f 4f       	sbci	r17, 0xFF	; 255
    182c:	a3 01       	movw	r20, r6
    182e:	0a d3       	rcall	.+1556   	; 0x1e44 <__ultoa_invert>
    1830:	88 2e       	mov	r8, r24
    1832:	86 18       	sub	r8, r6
    1834:	fb 2d       	mov	r31, r11
    1836:	ff 77       	andi	r31, 0x7F	; 127
    1838:	3f 2e       	mov	r3, r31
    183a:	36 fe       	sbrs	r3, 6
    183c:	0d c0       	rjmp	.+26     	; 0x1858 <vfprintf+0x2ba>
    183e:	23 2d       	mov	r18, r3
    1840:	2e 7f       	andi	r18, 0xFE	; 254
    1842:	a2 2e       	mov	r10, r18
    1844:	89 14       	cp	r8, r9
    1846:	58 f4       	brcc	.+22     	; 0x185e <vfprintf+0x2c0>
    1848:	34 fe       	sbrs	r3, 4
    184a:	0b c0       	rjmp	.+22     	; 0x1862 <vfprintf+0x2c4>
    184c:	32 fc       	sbrc	r3, 2
    184e:	09 c0       	rjmp	.+18     	; 0x1862 <vfprintf+0x2c4>
    1850:	83 2d       	mov	r24, r3
    1852:	8e 7e       	andi	r24, 0xEE	; 238
    1854:	a8 2e       	mov	r10, r24
    1856:	05 c0       	rjmp	.+10     	; 0x1862 <vfprintf+0x2c4>
    1858:	b8 2c       	mov	r11, r8
    185a:	a3 2c       	mov	r10, r3
    185c:	03 c0       	rjmp	.+6      	; 0x1864 <vfprintf+0x2c6>
    185e:	b8 2c       	mov	r11, r8
    1860:	01 c0       	rjmp	.+2      	; 0x1864 <vfprintf+0x2c6>
    1862:	b9 2c       	mov	r11, r9
    1864:	a4 fe       	sbrs	r10, 4
    1866:	0f c0       	rjmp	.+30     	; 0x1886 <vfprintf+0x2e8>
    1868:	fe 01       	movw	r30, r28
    186a:	e8 0d       	add	r30, r8
    186c:	f1 1d       	adc	r31, r1
    186e:	80 81       	ld	r24, Z
    1870:	80 33       	cpi	r24, 0x30	; 48
    1872:	21 f4       	brne	.+8      	; 0x187c <vfprintf+0x2de>
    1874:	9a 2d       	mov	r25, r10
    1876:	99 7e       	andi	r25, 0xE9	; 233
    1878:	a9 2e       	mov	r10, r25
    187a:	09 c0       	rjmp	.+18     	; 0x188e <vfprintf+0x2f0>
    187c:	a2 fe       	sbrs	r10, 2
    187e:	06 c0       	rjmp	.+12     	; 0x188c <vfprintf+0x2ee>
    1880:	b3 94       	inc	r11
    1882:	b3 94       	inc	r11
    1884:	04 c0       	rjmp	.+8      	; 0x188e <vfprintf+0x2f0>
    1886:	8a 2d       	mov	r24, r10
    1888:	86 78       	andi	r24, 0x86	; 134
    188a:	09 f0       	breq	.+2      	; 0x188e <vfprintf+0x2f0>
    188c:	b3 94       	inc	r11
    188e:	a3 fc       	sbrc	r10, 3
    1890:	10 c0       	rjmp	.+32     	; 0x18b2 <vfprintf+0x314>
    1892:	a0 fe       	sbrs	r10, 0
    1894:	06 c0       	rjmp	.+12     	; 0x18a2 <vfprintf+0x304>
    1896:	b2 14       	cp	r11, r2
    1898:	80 f4       	brcc	.+32     	; 0x18ba <vfprintf+0x31c>
    189a:	28 0c       	add	r2, r8
    189c:	92 2c       	mov	r9, r2
    189e:	9b 18       	sub	r9, r11
    18a0:	0d c0       	rjmp	.+26     	; 0x18bc <vfprintf+0x31e>
    18a2:	b2 14       	cp	r11, r2
    18a4:	58 f4       	brcc	.+22     	; 0x18bc <vfprintf+0x31e>
    18a6:	b6 01       	movw	r22, r12
    18a8:	80 e2       	ldi	r24, 0x20	; 32
    18aa:	90 e0       	ldi	r25, 0x00	; 0
    18ac:	8f d2       	rcall	.+1310   	; 0x1dcc <fputc>
    18ae:	b3 94       	inc	r11
    18b0:	f8 cf       	rjmp	.-16     	; 0x18a2 <vfprintf+0x304>
    18b2:	b2 14       	cp	r11, r2
    18b4:	18 f4       	brcc	.+6      	; 0x18bc <vfprintf+0x31e>
    18b6:	2b 18       	sub	r2, r11
    18b8:	02 c0       	rjmp	.+4      	; 0x18be <vfprintf+0x320>
    18ba:	98 2c       	mov	r9, r8
    18bc:	21 2c       	mov	r2, r1
    18be:	a4 fe       	sbrs	r10, 4
    18c0:	0f c0       	rjmp	.+30     	; 0x18e0 <vfprintf+0x342>
    18c2:	b6 01       	movw	r22, r12
    18c4:	80 e3       	ldi	r24, 0x30	; 48
    18c6:	90 e0       	ldi	r25, 0x00	; 0
    18c8:	81 d2       	rcall	.+1282   	; 0x1dcc <fputc>
    18ca:	a2 fe       	sbrs	r10, 2
    18cc:	16 c0       	rjmp	.+44     	; 0x18fa <vfprintf+0x35c>
    18ce:	a1 fc       	sbrc	r10, 1
    18d0:	03 c0       	rjmp	.+6      	; 0x18d8 <vfprintf+0x33a>
    18d2:	88 e7       	ldi	r24, 0x78	; 120
    18d4:	90 e0       	ldi	r25, 0x00	; 0
    18d6:	02 c0       	rjmp	.+4      	; 0x18dc <vfprintf+0x33e>
    18d8:	88 e5       	ldi	r24, 0x58	; 88
    18da:	90 e0       	ldi	r25, 0x00	; 0
    18dc:	b6 01       	movw	r22, r12
    18de:	0c c0       	rjmp	.+24     	; 0x18f8 <vfprintf+0x35a>
    18e0:	8a 2d       	mov	r24, r10
    18e2:	86 78       	andi	r24, 0x86	; 134
    18e4:	51 f0       	breq	.+20     	; 0x18fa <vfprintf+0x35c>
    18e6:	a1 fe       	sbrs	r10, 1
    18e8:	02 c0       	rjmp	.+4      	; 0x18ee <vfprintf+0x350>
    18ea:	8b e2       	ldi	r24, 0x2B	; 43
    18ec:	01 c0       	rjmp	.+2      	; 0x18f0 <vfprintf+0x352>
    18ee:	80 e2       	ldi	r24, 0x20	; 32
    18f0:	a7 fc       	sbrc	r10, 7
    18f2:	8d e2       	ldi	r24, 0x2D	; 45
    18f4:	b6 01       	movw	r22, r12
    18f6:	90 e0       	ldi	r25, 0x00	; 0
    18f8:	69 d2       	rcall	.+1234   	; 0x1dcc <fputc>
    18fa:	89 14       	cp	r8, r9
    18fc:	30 f4       	brcc	.+12     	; 0x190a <vfprintf+0x36c>
    18fe:	b6 01       	movw	r22, r12
    1900:	80 e3       	ldi	r24, 0x30	; 48
    1902:	90 e0       	ldi	r25, 0x00	; 0
    1904:	63 d2       	rcall	.+1222   	; 0x1dcc <fputc>
    1906:	9a 94       	dec	r9
    1908:	f8 cf       	rjmp	.-16     	; 0x18fa <vfprintf+0x35c>
    190a:	8a 94       	dec	r8
    190c:	f3 01       	movw	r30, r6
    190e:	e8 0d       	add	r30, r8
    1910:	f1 1d       	adc	r31, r1
    1912:	80 81       	ld	r24, Z
    1914:	b6 01       	movw	r22, r12
    1916:	90 e0       	ldi	r25, 0x00	; 0
    1918:	59 d2       	rcall	.+1202   	; 0x1dcc <fputc>
    191a:	81 10       	cpse	r8, r1
    191c:	f6 cf       	rjmp	.-20     	; 0x190a <vfprintf+0x36c>
    191e:	22 20       	and	r2, r2
    1920:	09 f4       	brne	.+2      	; 0x1924 <vfprintf+0x386>
    1922:	4e ce       	rjmp	.-868    	; 0x15c0 <vfprintf+0x22>
    1924:	b6 01       	movw	r22, r12
    1926:	80 e2       	ldi	r24, 0x20	; 32
    1928:	90 e0       	ldi	r25, 0x00	; 0
    192a:	50 d2       	rcall	.+1184   	; 0x1dcc <fputc>
    192c:	2a 94       	dec	r2
    192e:	f7 cf       	rjmp	.-18     	; 0x191e <vfprintf+0x380>
    1930:	f6 01       	movw	r30, r12
    1932:	86 81       	ldd	r24, Z+6	; 0x06
    1934:	97 81       	ldd	r25, Z+7	; 0x07
    1936:	02 c0       	rjmp	.+4      	; 0x193c <vfprintf+0x39e>
    1938:	8f ef       	ldi	r24, 0xFF	; 255
    193a:	9f ef       	ldi	r25, 0xFF	; 255
    193c:	2b 96       	adiw	r28, 0x0b	; 11
    193e:	e2 e1       	ldi	r30, 0x12	; 18
    1940:	f8 c2       	rjmp	.+1520   	; 0x1f32 <__epilogue_restores__>

00001942 <dtoa_prf>:
    1942:	a9 e0       	ldi	r26, 0x09	; 9
    1944:	b0 e0       	ldi	r27, 0x00	; 0
    1946:	e6 ea       	ldi	r30, 0xA6	; 166
    1948:	fc e0       	ldi	r31, 0x0C	; 12
    194a:	e0 c2       	rjmp	.+1472   	; 0x1f0c <__prologue_saves__+0xc>
    194c:	6a 01       	movw	r12, r20
    194e:	12 2f       	mov	r17, r18
    1950:	b0 2e       	mov	r11, r16
    1952:	2b e3       	ldi	r18, 0x3B	; 59
    1954:	20 17       	cp	r18, r16
    1956:	20 f0       	brcs	.+8      	; 0x1960 <dtoa_prf+0x1e>
    1958:	ff 24       	eor	r15, r15
    195a:	f3 94       	inc	r15
    195c:	f0 0e       	add	r15, r16
    195e:	02 c0       	rjmp	.+4      	; 0x1964 <dtoa_prf+0x22>
    1960:	2c e3       	ldi	r18, 0x3C	; 60
    1962:	f2 2e       	mov	r15, r18
    1964:	0f 2d       	mov	r16, r15
    1966:	27 e0       	ldi	r18, 0x07	; 7
    1968:	ae 01       	movw	r20, r28
    196a:	4f 5f       	subi	r20, 0xFF	; 255
    196c:	5f 4f       	sbci	r21, 0xFF	; 255
    196e:	40 d1       	rcall	.+640    	; 0x1bf0 <__ftoa_engine>
    1970:	bc 01       	movw	r22, r24
    1972:	49 81       	ldd	r20, Y+1	; 0x01
    1974:	84 2f       	mov	r24, r20
    1976:	89 70       	andi	r24, 0x09	; 9
    1978:	81 30       	cpi	r24, 0x01	; 1
    197a:	31 f0       	breq	.+12     	; 0x1988 <dtoa_prf+0x46>
    197c:	e1 fc       	sbrc	r14, 1
    197e:	06 c0       	rjmp	.+12     	; 0x198c <dtoa_prf+0x4a>
    1980:	e0 fe       	sbrs	r14, 0
    1982:	06 c0       	rjmp	.+12     	; 0x1990 <dtoa_prf+0x4e>
    1984:	90 e2       	ldi	r25, 0x20	; 32
    1986:	05 c0       	rjmp	.+10     	; 0x1992 <dtoa_prf+0x50>
    1988:	9d e2       	ldi	r25, 0x2D	; 45
    198a:	03 c0       	rjmp	.+6      	; 0x1992 <dtoa_prf+0x50>
    198c:	9b e2       	ldi	r25, 0x2B	; 43
    198e:	01 c0       	rjmp	.+2      	; 0x1992 <dtoa_prf+0x50>
    1990:	90 e0       	ldi	r25, 0x00	; 0
    1992:	5e 2d       	mov	r21, r14
    1994:	50 71       	andi	r21, 0x10	; 16
    1996:	43 ff       	sbrs	r20, 3
    1998:	3c c0       	rjmp	.+120    	; 0x1a12 <dtoa_prf+0xd0>
    199a:	91 11       	cpse	r25, r1
    199c:	02 c0       	rjmp	.+4      	; 0x19a2 <dtoa_prf+0x60>
    199e:	83 e0       	ldi	r24, 0x03	; 3
    19a0:	01 c0       	rjmp	.+2      	; 0x19a4 <dtoa_prf+0x62>
    19a2:	84 e0       	ldi	r24, 0x04	; 4
    19a4:	81 17       	cp	r24, r17
    19a6:	18 f4       	brcc	.+6      	; 0x19ae <dtoa_prf+0x6c>
    19a8:	21 2f       	mov	r18, r17
    19aa:	28 1b       	sub	r18, r24
    19ac:	01 c0       	rjmp	.+2      	; 0x19b0 <dtoa_prf+0x6e>
    19ae:	20 e0       	ldi	r18, 0x00	; 0
    19b0:	51 11       	cpse	r21, r1
    19b2:	0b c0       	rjmp	.+22     	; 0x19ca <dtoa_prf+0x88>
    19b4:	f6 01       	movw	r30, r12
    19b6:	82 2f       	mov	r24, r18
    19b8:	30 e2       	ldi	r19, 0x20	; 32
    19ba:	88 23       	and	r24, r24
    19bc:	19 f0       	breq	.+6      	; 0x19c4 <dtoa_prf+0x82>
    19be:	31 93       	st	Z+, r19
    19c0:	81 50       	subi	r24, 0x01	; 1
    19c2:	fb cf       	rjmp	.-10     	; 0x19ba <dtoa_prf+0x78>
    19c4:	c2 0e       	add	r12, r18
    19c6:	d1 1c       	adc	r13, r1
    19c8:	20 e0       	ldi	r18, 0x00	; 0
    19ca:	99 23       	and	r25, r25
    19cc:	29 f0       	breq	.+10     	; 0x19d8 <dtoa_prf+0x96>
    19ce:	d6 01       	movw	r26, r12
    19d0:	9c 93       	st	X, r25
    19d2:	f6 01       	movw	r30, r12
    19d4:	31 96       	adiw	r30, 0x01	; 1
    19d6:	6f 01       	movw	r12, r30
    19d8:	c6 01       	movw	r24, r12
    19da:	03 96       	adiw	r24, 0x03	; 3
    19dc:	e2 fe       	sbrs	r14, 2
    19de:	0a c0       	rjmp	.+20     	; 0x19f4 <dtoa_prf+0xb2>
    19e0:	3e e4       	ldi	r19, 0x4E	; 78
    19e2:	d6 01       	movw	r26, r12
    19e4:	3c 93       	st	X, r19
    19e6:	41 e4       	ldi	r20, 0x41	; 65
    19e8:	11 96       	adiw	r26, 0x01	; 1
    19ea:	4c 93       	st	X, r20
    19ec:	11 97       	sbiw	r26, 0x01	; 1
    19ee:	12 96       	adiw	r26, 0x02	; 2
    19f0:	3c 93       	st	X, r19
    19f2:	06 c0       	rjmp	.+12     	; 0x1a00 <dtoa_prf+0xbe>
    19f4:	3e e6       	ldi	r19, 0x6E	; 110
    19f6:	f6 01       	movw	r30, r12
    19f8:	30 83       	st	Z, r19
    19fa:	41 e6       	ldi	r20, 0x61	; 97
    19fc:	41 83       	std	Z+1, r20	; 0x01
    19fe:	32 83       	std	Z+2, r19	; 0x02
    1a00:	fc 01       	movw	r30, r24
    1a02:	32 2f       	mov	r19, r18
    1a04:	40 e2       	ldi	r20, 0x20	; 32
    1a06:	33 23       	and	r19, r19
    1a08:	09 f4       	brne	.+2      	; 0x1a0c <dtoa_prf+0xca>
    1a0a:	42 c0       	rjmp	.+132    	; 0x1a90 <dtoa_prf+0x14e>
    1a0c:	41 93       	st	Z+, r20
    1a0e:	31 50       	subi	r19, 0x01	; 1
    1a10:	fa cf       	rjmp	.-12     	; 0x1a06 <dtoa_prf+0xc4>
    1a12:	42 ff       	sbrs	r20, 2
    1a14:	44 c0       	rjmp	.+136    	; 0x1a9e <dtoa_prf+0x15c>
    1a16:	91 11       	cpse	r25, r1
    1a18:	02 c0       	rjmp	.+4      	; 0x1a1e <dtoa_prf+0xdc>
    1a1a:	83 e0       	ldi	r24, 0x03	; 3
    1a1c:	01 c0       	rjmp	.+2      	; 0x1a20 <dtoa_prf+0xde>
    1a1e:	84 e0       	ldi	r24, 0x04	; 4
    1a20:	81 17       	cp	r24, r17
    1a22:	18 f4       	brcc	.+6      	; 0x1a2a <dtoa_prf+0xe8>
    1a24:	21 2f       	mov	r18, r17
    1a26:	28 1b       	sub	r18, r24
    1a28:	01 c0       	rjmp	.+2      	; 0x1a2c <dtoa_prf+0xea>
    1a2a:	20 e0       	ldi	r18, 0x00	; 0
    1a2c:	51 11       	cpse	r21, r1
    1a2e:	0b c0       	rjmp	.+22     	; 0x1a46 <dtoa_prf+0x104>
    1a30:	f6 01       	movw	r30, r12
    1a32:	82 2f       	mov	r24, r18
    1a34:	30 e2       	ldi	r19, 0x20	; 32
    1a36:	88 23       	and	r24, r24
    1a38:	19 f0       	breq	.+6      	; 0x1a40 <dtoa_prf+0xfe>
    1a3a:	31 93       	st	Z+, r19
    1a3c:	81 50       	subi	r24, 0x01	; 1
    1a3e:	fb cf       	rjmp	.-10     	; 0x1a36 <dtoa_prf+0xf4>
    1a40:	c2 0e       	add	r12, r18
    1a42:	d1 1c       	adc	r13, r1
    1a44:	20 e0       	ldi	r18, 0x00	; 0
    1a46:	99 23       	and	r25, r25
    1a48:	29 f0       	breq	.+10     	; 0x1a54 <dtoa_prf+0x112>
    1a4a:	d6 01       	movw	r26, r12
    1a4c:	9c 93       	st	X, r25
    1a4e:	f6 01       	movw	r30, r12
    1a50:	31 96       	adiw	r30, 0x01	; 1
    1a52:	6f 01       	movw	r12, r30
    1a54:	c6 01       	movw	r24, r12
    1a56:	03 96       	adiw	r24, 0x03	; 3
    1a58:	e2 fe       	sbrs	r14, 2
    1a5a:	0b c0       	rjmp	.+22     	; 0x1a72 <dtoa_prf+0x130>
    1a5c:	39 e4       	ldi	r19, 0x49	; 73
    1a5e:	d6 01       	movw	r26, r12
    1a60:	3c 93       	st	X, r19
    1a62:	3e e4       	ldi	r19, 0x4E	; 78
    1a64:	11 96       	adiw	r26, 0x01	; 1
    1a66:	3c 93       	st	X, r19
    1a68:	11 97       	sbiw	r26, 0x01	; 1
    1a6a:	36 e4       	ldi	r19, 0x46	; 70
    1a6c:	12 96       	adiw	r26, 0x02	; 2
    1a6e:	3c 93       	st	X, r19
    1a70:	07 c0       	rjmp	.+14     	; 0x1a80 <dtoa_prf+0x13e>
    1a72:	39 e6       	ldi	r19, 0x69	; 105
    1a74:	f6 01       	movw	r30, r12
    1a76:	30 83       	st	Z, r19
    1a78:	3e e6       	ldi	r19, 0x6E	; 110
    1a7a:	31 83       	std	Z+1, r19	; 0x01
    1a7c:	36 e6       	ldi	r19, 0x66	; 102
    1a7e:	32 83       	std	Z+2, r19	; 0x02
    1a80:	fc 01       	movw	r30, r24
    1a82:	32 2f       	mov	r19, r18
    1a84:	40 e2       	ldi	r20, 0x20	; 32
    1a86:	33 23       	and	r19, r19
    1a88:	19 f0       	breq	.+6      	; 0x1a90 <dtoa_prf+0x14e>
    1a8a:	41 93       	st	Z+, r20
    1a8c:	31 50       	subi	r19, 0x01	; 1
    1a8e:	fb cf       	rjmp	.-10     	; 0x1a86 <dtoa_prf+0x144>
    1a90:	fc 01       	movw	r30, r24
    1a92:	e2 0f       	add	r30, r18
    1a94:	f1 1d       	adc	r31, r1
    1a96:	10 82       	st	Z, r1
    1a98:	8e ef       	ldi	r24, 0xFE	; 254
    1a9a:	9f ef       	ldi	r25, 0xFF	; 255
    1a9c:	a6 c0       	rjmp	.+332    	; 0x1bea <dtoa_prf+0x2a8>
    1a9e:	21 e0       	ldi	r18, 0x01	; 1
    1aa0:	30 e0       	ldi	r19, 0x00	; 0
    1aa2:	91 11       	cpse	r25, r1
    1aa4:	02 c0       	rjmp	.+4      	; 0x1aaa <dtoa_prf+0x168>
    1aa6:	20 e0       	ldi	r18, 0x00	; 0
    1aa8:	30 e0       	ldi	r19, 0x00	; 0
    1aaa:	16 16       	cp	r1, r22
    1aac:	17 06       	cpc	r1, r23
    1aae:	1c f4       	brge	.+6      	; 0x1ab6 <dtoa_prf+0x174>
    1ab0:	fb 01       	movw	r30, r22
    1ab2:	31 96       	adiw	r30, 0x01	; 1
    1ab4:	02 c0       	rjmp	.+4      	; 0x1aba <dtoa_prf+0x178>
    1ab6:	e1 e0       	ldi	r30, 0x01	; 1
    1ab8:	f0 e0       	ldi	r31, 0x00	; 0
    1aba:	2e 0f       	add	r18, r30
    1abc:	3f 1f       	adc	r19, r31
    1abe:	bb 20       	and	r11, r11
    1ac0:	21 f0       	breq	.+8      	; 0x1aca <dtoa_prf+0x188>
    1ac2:	eb 2d       	mov	r30, r11
    1ac4:	f0 e0       	ldi	r31, 0x00	; 0
    1ac6:	31 96       	adiw	r30, 0x01	; 1
    1ac8:	02 c0       	rjmp	.+4      	; 0x1ace <dtoa_prf+0x18c>
    1aca:	e0 e0       	ldi	r30, 0x00	; 0
    1acc:	f0 e0       	ldi	r31, 0x00	; 0
    1ace:	2e 0f       	add	r18, r30
    1ad0:	3f 1f       	adc	r19, r31
    1ad2:	e1 2f       	mov	r30, r17
    1ad4:	f0 e0       	ldi	r31, 0x00	; 0
    1ad6:	2e 17       	cp	r18, r30
    1ad8:	3f 07       	cpc	r19, r31
    1ada:	1c f4       	brge	.+6      	; 0x1ae2 <dtoa_prf+0x1a0>
    1adc:	12 1b       	sub	r17, r18
    1ade:	21 2f       	mov	r18, r17
    1ae0:	01 c0       	rjmp	.+2      	; 0x1ae4 <dtoa_prf+0x1a2>
    1ae2:	20 e0       	ldi	r18, 0x00	; 0
    1ae4:	8e 2d       	mov	r24, r14
    1ae6:	88 71       	andi	r24, 0x18	; 24
    1ae8:	59 f4       	brne	.+22     	; 0x1b00 <dtoa_prf+0x1be>
    1aea:	f6 01       	movw	r30, r12
    1aec:	82 2f       	mov	r24, r18
    1aee:	30 e2       	ldi	r19, 0x20	; 32
    1af0:	88 23       	and	r24, r24
    1af2:	19 f0       	breq	.+6      	; 0x1afa <dtoa_prf+0x1b8>
    1af4:	31 93       	st	Z+, r19
    1af6:	81 50       	subi	r24, 0x01	; 1
    1af8:	fb cf       	rjmp	.-10     	; 0x1af0 <dtoa_prf+0x1ae>
    1afa:	c2 0e       	add	r12, r18
    1afc:	d1 1c       	adc	r13, r1
    1afe:	20 e0       	ldi	r18, 0x00	; 0
    1b00:	99 23       	and	r25, r25
    1b02:	29 f0       	breq	.+10     	; 0x1b0e <dtoa_prf+0x1cc>
    1b04:	d6 01       	movw	r26, r12
    1b06:	9c 93       	st	X, r25
    1b08:	f6 01       	movw	r30, r12
    1b0a:	31 96       	adiw	r30, 0x01	; 1
    1b0c:	6f 01       	movw	r12, r30
    1b0e:	51 11       	cpse	r21, r1
    1b10:	0b c0       	rjmp	.+22     	; 0x1b28 <dtoa_prf+0x1e6>
    1b12:	f6 01       	movw	r30, r12
    1b14:	82 2f       	mov	r24, r18
    1b16:	90 e3       	ldi	r25, 0x30	; 48
    1b18:	88 23       	and	r24, r24
    1b1a:	19 f0       	breq	.+6      	; 0x1b22 <dtoa_prf+0x1e0>
    1b1c:	91 93       	st	Z+, r25
    1b1e:	81 50       	subi	r24, 0x01	; 1
    1b20:	fb cf       	rjmp	.-10     	; 0x1b18 <dtoa_prf+0x1d6>
    1b22:	c2 0e       	add	r12, r18
    1b24:	d1 1c       	adc	r13, r1
    1b26:	20 e0       	ldi	r18, 0x00	; 0
    1b28:	0f 2d       	mov	r16, r15
    1b2a:	06 0f       	add	r16, r22
    1b2c:	9a 81       	ldd	r25, Y+2	; 0x02
    1b2e:	34 2f       	mov	r19, r20
    1b30:	30 71       	andi	r19, 0x10	; 16
    1b32:	44 ff       	sbrs	r20, 4
    1b34:	03 c0       	rjmp	.+6      	; 0x1b3c <dtoa_prf+0x1fa>
    1b36:	91 33       	cpi	r25, 0x31	; 49
    1b38:	09 f4       	brne	.+2      	; 0x1b3c <dtoa_prf+0x1fa>
    1b3a:	01 50       	subi	r16, 0x01	; 1
    1b3c:	10 16       	cp	r1, r16
    1b3e:	24 f4       	brge	.+8      	; 0x1b48 <dtoa_prf+0x206>
    1b40:	09 30       	cpi	r16, 0x09	; 9
    1b42:	18 f0       	brcs	.+6      	; 0x1b4a <dtoa_prf+0x208>
    1b44:	08 e0       	ldi	r16, 0x08	; 8
    1b46:	01 c0       	rjmp	.+2      	; 0x1b4a <dtoa_prf+0x208>
    1b48:	01 e0       	ldi	r16, 0x01	; 1
    1b4a:	ab 01       	movw	r20, r22
    1b4c:	77 ff       	sbrs	r23, 7
    1b4e:	02 c0       	rjmp	.+4      	; 0x1b54 <dtoa_prf+0x212>
    1b50:	40 e0       	ldi	r20, 0x00	; 0
    1b52:	50 e0       	ldi	r21, 0x00	; 0
    1b54:	fb 01       	movw	r30, r22
    1b56:	e4 1b       	sub	r30, r20
    1b58:	f5 0b       	sbc	r31, r21
    1b5a:	a1 e0       	ldi	r26, 0x01	; 1
    1b5c:	b0 e0       	ldi	r27, 0x00	; 0
    1b5e:	ac 0f       	add	r26, r28
    1b60:	bd 1f       	adc	r27, r29
    1b62:	ea 0f       	add	r30, r26
    1b64:	fb 1f       	adc	r31, r27
    1b66:	8e e2       	ldi	r24, 0x2E	; 46
    1b68:	a8 2e       	mov	r10, r24
    1b6a:	4b 01       	movw	r8, r22
    1b6c:	80 1a       	sub	r8, r16
    1b6e:	91 08       	sbc	r9, r1
    1b70:	0b 2d       	mov	r16, r11
    1b72:	10 e0       	ldi	r17, 0x00	; 0
    1b74:	11 95       	neg	r17
    1b76:	01 95       	neg	r16
    1b78:	11 09       	sbc	r17, r1
    1b7a:	4f 3f       	cpi	r20, 0xFF	; 255
    1b7c:	bf ef       	ldi	r27, 0xFF	; 255
    1b7e:	5b 07       	cpc	r21, r27
    1b80:	21 f4       	brne	.+8      	; 0x1b8a <dtoa_prf+0x248>
    1b82:	d6 01       	movw	r26, r12
    1b84:	ac 92       	st	X, r10
    1b86:	11 96       	adiw	r26, 0x01	; 1
    1b88:	6d 01       	movw	r12, r26
    1b8a:	64 17       	cp	r22, r20
    1b8c:	75 07       	cpc	r23, r21
    1b8e:	2c f0       	brlt	.+10     	; 0x1b9a <dtoa_prf+0x258>
    1b90:	84 16       	cp	r8, r20
    1b92:	95 06       	cpc	r9, r21
    1b94:	14 f4       	brge	.+4      	; 0x1b9a <dtoa_prf+0x258>
    1b96:	81 81       	ldd	r24, Z+1	; 0x01
    1b98:	01 c0       	rjmp	.+2      	; 0x1b9c <dtoa_prf+0x25a>
    1b9a:	80 e3       	ldi	r24, 0x30	; 48
    1b9c:	41 50       	subi	r20, 0x01	; 1
    1b9e:	51 09       	sbc	r21, r1
    1ba0:	31 96       	adiw	r30, 0x01	; 1
    1ba2:	d6 01       	movw	r26, r12
    1ba4:	11 96       	adiw	r26, 0x01	; 1
    1ba6:	7d 01       	movw	r14, r26
    1ba8:	40 17       	cp	r20, r16
    1baa:	51 07       	cpc	r21, r17
    1bac:	24 f0       	brlt	.+8      	; 0x1bb6 <dtoa_prf+0x274>
    1bae:	d6 01       	movw	r26, r12
    1bb0:	8c 93       	st	X, r24
    1bb2:	67 01       	movw	r12, r14
    1bb4:	e2 cf       	rjmp	.-60     	; 0x1b7a <dtoa_prf+0x238>
    1bb6:	64 17       	cp	r22, r20
    1bb8:	75 07       	cpc	r23, r21
    1bba:	39 f4       	brne	.+14     	; 0x1bca <dtoa_prf+0x288>
    1bbc:	96 33       	cpi	r25, 0x36	; 54
    1bbe:	20 f4       	brcc	.+8      	; 0x1bc8 <dtoa_prf+0x286>
    1bc0:	95 33       	cpi	r25, 0x35	; 53
    1bc2:	19 f4       	brne	.+6      	; 0x1bca <dtoa_prf+0x288>
    1bc4:	31 11       	cpse	r19, r1
    1bc6:	01 c0       	rjmp	.+2      	; 0x1bca <dtoa_prf+0x288>
    1bc8:	81 e3       	ldi	r24, 0x31	; 49
    1bca:	f6 01       	movw	r30, r12
    1bcc:	80 83       	st	Z, r24
    1bce:	f7 01       	movw	r30, r14
    1bd0:	82 2f       	mov	r24, r18
    1bd2:	90 e2       	ldi	r25, 0x20	; 32
    1bd4:	88 23       	and	r24, r24
    1bd6:	19 f0       	breq	.+6      	; 0x1bde <dtoa_prf+0x29c>
    1bd8:	91 93       	st	Z+, r25
    1bda:	81 50       	subi	r24, 0x01	; 1
    1bdc:	fb cf       	rjmp	.-10     	; 0x1bd4 <dtoa_prf+0x292>
    1bde:	f7 01       	movw	r30, r14
    1be0:	e2 0f       	add	r30, r18
    1be2:	f1 1d       	adc	r31, r1
    1be4:	10 82       	st	Z, r1
    1be6:	80 e0       	ldi	r24, 0x00	; 0
    1be8:	90 e0       	ldi	r25, 0x00	; 0
    1bea:	29 96       	adiw	r28, 0x09	; 9
    1bec:	ec e0       	ldi	r30, 0x0C	; 12
    1bee:	a7 c1       	rjmp	.+846    	; 0x1f3e <__epilogue_restores__+0xc>

00001bf0 <__ftoa_engine>:
    1bf0:	28 30       	cpi	r18, 0x08	; 8
    1bf2:	08 f0       	brcs	.+2      	; 0x1bf6 <__ftoa_engine+0x6>
    1bf4:	27 e0       	ldi	r18, 0x07	; 7
    1bf6:	33 27       	eor	r19, r19
    1bf8:	da 01       	movw	r26, r20
    1bfa:	99 0f       	add	r25, r25
    1bfc:	31 1d       	adc	r19, r1
    1bfe:	87 fd       	sbrc	r24, 7
    1c00:	91 60       	ori	r25, 0x01	; 1
    1c02:	00 96       	adiw	r24, 0x00	; 0
    1c04:	61 05       	cpc	r22, r1
    1c06:	71 05       	cpc	r23, r1
    1c08:	39 f4       	brne	.+14     	; 0x1c18 <__ftoa_engine+0x28>
    1c0a:	32 60       	ori	r19, 0x02	; 2
    1c0c:	2e 5f       	subi	r18, 0xFE	; 254
    1c0e:	3d 93       	st	X+, r19
    1c10:	30 e3       	ldi	r19, 0x30	; 48
    1c12:	2a 95       	dec	r18
    1c14:	e1 f7       	brne	.-8      	; 0x1c0e <__ftoa_engine+0x1e>
    1c16:	08 95       	ret
    1c18:	9f 3f       	cpi	r25, 0xFF	; 255
    1c1a:	30 f0       	brcs	.+12     	; 0x1c28 <__ftoa_engine+0x38>
    1c1c:	80 38       	cpi	r24, 0x80	; 128
    1c1e:	71 05       	cpc	r23, r1
    1c20:	61 05       	cpc	r22, r1
    1c22:	09 f0       	breq	.+2      	; 0x1c26 <__ftoa_engine+0x36>
    1c24:	3c 5f       	subi	r19, 0xFC	; 252
    1c26:	3c 5f       	subi	r19, 0xFC	; 252
    1c28:	3d 93       	st	X+, r19
    1c2a:	91 30       	cpi	r25, 0x01	; 1
    1c2c:	08 f0       	brcs	.+2      	; 0x1c30 <__ftoa_engine+0x40>
    1c2e:	80 68       	ori	r24, 0x80	; 128
    1c30:	91 1d       	adc	r25, r1
    1c32:	df 93       	push	r29
    1c34:	cf 93       	push	r28
    1c36:	1f 93       	push	r17
    1c38:	0f 93       	push	r16
    1c3a:	ff 92       	push	r15
    1c3c:	ef 92       	push	r14
    1c3e:	19 2f       	mov	r17, r25
    1c40:	98 7f       	andi	r25, 0xF8	; 248
    1c42:	96 95       	lsr	r25
    1c44:	e9 2f       	mov	r30, r25
    1c46:	96 95       	lsr	r25
    1c48:	96 95       	lsr	r25
    1c4a:	e9 0f       	add	r30, r25
    1c4c:	ff 27       	eor	r31, r31
    1c4e:	e2 57       	subi	r30, 0x72	; 114
    1c50:	ff 4f       	sbci	r31, 0xFF	; 255
    1c52:	99 27       	eor	r25, r25
    1c54:	33 27       	eor	r19, r19
    1c56:	ee 24       	eor	r14, r14
    1c58:	ff 24       	eor	r15, r15
    1c5a:	a7 01       	movw	r20, r14
    1c5c:	e7 01       	movw	r28, r14
    1c5e:	05 90       	lpm	r0, Z+
    1c60:	08 94       	sec
    1c62:	07 94       	ror	r0
    1c64:	28 f4       	brcc	.+10     	; 0x1c70 <__ftoa_engine+0x80>
    1c66:	36 0f       	add	r19, r22
    1c68:	e7 1e       	adc	r14, r23
    1c6a:	f8 1e       	adc	r15, r24
    1c6c:	49 1f       	adc	r20, r25
    1c6e:	51 1d       	adc	r21, r1
    1c70:	66 0f       	add	r22, r22
    1c72:	77 1f       	adc	r23, r23
    1c74:	88 1f       	adc	r24, r24
    1c76:	99 1f       	adc	r25, r25
    1c78:	06 94       	lsr	r0
    1c7a:	a1 f7       	brne	.-24     	; 0x1c64 <__ftoa_engine+0x74>
    1c7c:	05 90       	lpm	r0, Z+
    1c7e:	07 94       	ror	r0
    1c80:	28 f4       	brcc	.+10     	; 0x1c8c <__ftoa_engine+0x9c>
    1c82:	e7 0e       	add	r14, r23
    1c84:	f8 1e       	adc	r15, r24
    1c86:	49 1f       	adc	r20, r25
    1c88:	56 1f       	adc	r21, r22
    1c8a:	c1 1d       	adc	r28, r1
    1c8c:	77 0f       	add	r23, r23
    1c8e:	88 1f       	adc	r24, r24
    1c90:	99 1f       	adc	r25, r25
    1c92:	66 1f       	adc	r22, r22
    1c94:	06 94       	lsr	r0
    1c96:	a1 f7       	brne	.-24     	; 0x1c80 <__ftoa_engine+0x90>
    1c98:	05 90       	lpm	r0, Z+
    1c9a:	07 94       	ror	r0
    1c9c:	28 f4       	brcc	.+10     	; 0x1ca8 <__ftoa_engine+0xb8>
    1c9e:	f8 0e       	add	r15, r24
    1ca0:	49 1f       	adc	r20, r25
    1ca2:	56 1f       	adc	r21, r22
    1ca4:	c7 1f       	adc	r28, r23
    1ca6:	d1 1d       	adc	r29, r1
    1ca8:	88 0f       	add	r24, r24
    1caa:	99 1f       	adc	r25, r25
    1cac:	66 1f       	adc	r22, r22
    1cae:	77 1f       	adc	r23, r23
    1cb0:	06 94       	lsr	r0
    1cb2:	a1 f7       	brne	.-24     	; 0x1c9c <__ftoa_engine+0xac>
    1cb4:	05 90       	lpm	r0, Z+
    1cb6:	07 94       	ror	r0
    1cb8:	20 f4       	brcc	.+8      	; 0x1cc2 <__ftoa_engine+0xd2>
    1cba:	49 0f       	add	r20, r25
    1cbc:	56 1f       	adc	r21, r22
    1cbe:	c7 1f       	adc	r28, r23
    1cc0:	d8 1f       	adc	r29, r24
    1cc2:	99 0f       	add	r25, r25
    1cc4:	66 1f       	adc	r22, r22
    1cc6:	77 1f       	adc	r23, r23
    1cc8:	88 1f       	adc	r24, r24
    1cca:	06 94       	lsr	r0
    1ccc:	a9 f7       	brne	.-22     	; 0x1cb8 <__ftoa_engine+0xc8>
    1cce:	84 91       	lpm	r24, Z
    1cd0:	10 95       	com	r17
    1cd2:	17 70       	andi	r17, 0x07	; 7
    1cd4:	41 f0       	breq	.+16     	; 0x1ce6 <__ftoa_engine+0xf6>
    1cd6:	d6 95       	lsr	r29
    1cd8:	c7 95       	ror	r28
    1cda:	57 95       	ror	r21
    1cdc:	47 95       	ror	r20
    1cde:	f7 94       	ror	r15
    1ce0:	e7 94       	ror	r14
    1ce2:	1a 95       	dec	r17
    1ce4:	c1 f7       	brne	.-16     	; 0x1cd6 <__ftoa_engine+0xe6>
    1ce6:	e4 e3       	ldi	r30, 0x34	; 52
    1ce8:	f0 e0       	ldi	r31, 0x00	; 0
    1cea:	68 94       	set
    1cec:	15 90       	lpm	r1, Z+
    1cee:	15 91       	lpm	r17, Z+
    1cf0:	35 91       	lpm	r19, Z+
    1cf2:	65 91       	lpm	r22, Z+
    1cf4:	95 91       	lpm	r25, Z+
    1cf6:	05 90       	lpm	r0, Z+
    1cf8:	7f e2       	ldi	r23, 0x2F	; 47
    1cfa:	73 95       	inc	r23
    1cfc:	e1 18       	sub	r14, r1
    1cfe:	f1 0a       	sbc	r15, r17
    1d00:	43 0b       	sbc	r20, r19
    1d02:	56 0b       	sbc	r21, r22
    1d04:	c9 0b       	sbc	r28, r25
    1d06:	d0 09       	sbc	r29, r0
    1d08:	c0 f7       	brcc	.-16     	; 0x1cfa <__ftoa_engine+0x10a>
    1d0a:	e1 0c       	add	r14, r1
    1d0c:	f1 1e       	adc	r15, r17
    1d0e:	43 1f       	adc	r20, r19
    1d10:	56 1f       	adc	r21, r22
    1d12:	c9 1f       	adc	r28, r25
    1d14:	d0 1d       	adc	r29, r0
    1d16:	7e f4       	brtc	.+30     	; 0x1d36 <__ftoa_engine+0x146>
    1d18:	70 33       	cpi	r23, 0x30	; 48
    1d1a:	11 f4       	brne	.+4      	; 0x1d20 <__ftoa_engine+0x130>
    1d1c:	8a 95       	dec	r24
    1d1e:	e6 cf       	rjmp	.-52     	; 0x1cec <__ftoa_engine+0xfc>
    1d20:	e8 94       	clt
    1d22:	01 50       	subi	r16, 0x01	; 1
    1d24:	30 f0       	brcs	.+12     	; 0x1d32 <__ftoa_engine+0x142>
    1d26:	08 0f       	add	r16, r24
    1d28:	0a f4       	brpl	.+2      	; 0x1d2c <__ftoa_engine+0x13c>
    1d2a:	00 27       	eor	r16, r16
    1d2c:	02 17       	cp	r16, r18
    1d2e:	08 f4       	brcc	.+2      	; 0x1d32 <__ftoa_engine+0x142>
    1d30:	20 2f       	mov	r18, r16
    1d32:	23 95       	inc	r18
    1d34:	02 2f       	mov	r16, r18
    1d36:	7a 33       	cpi	r23, 0x3A	; 58
    1d38:	28 f0       	brcs	.+10     	; 0x1d44 <__ftoa_engine+0x154>
    1d3a:	79 e3       	ldi	r23, 0x39	; 57
    1d3c:	7d 93       	st	X+, r23
    1d3e:	2a 95       	dec	r18
    1d40:	e9 f7       	brne	.-6      	; 0x1d3c <__ftoa_engine+0x14c>
    1d42:	10 c0       	rjmp	.+32     	; 0x1d64 <__ftoa_engine+0x174>
    1d44:	7d 93       	st	X+, r23
    1d46:	2a 95       	dec	r18
    1d48:	89 f6       	brne	.-94     	; 0x1cec <__ftoa_engine+0xfc>
    1d4a:	06 94       	lsr	r0
    1d4c:	97 95       	ror	r25
    1d4e:	67 95       	ror	r22
    1d50:	37 95       	ror	r19
    1d52:	17 95       	ror	r17
    1d54:	17 94       	ror	r1
    1d56:	e1 18       	sub	r14, r1
    1d58:	f1 0a       	sbc	r15, r17
    1d5a:	43 0b       	sbc	r20, r19
    1d5c:	56 0b       	sbc	r21, r22
    1d5e:	c9 0b       	sbc	r28, r25
    1d60:	d0 09       	sbc	r29, r0
    1d62:	98 f0       	brcs	.+38     	; 0x1d8a <__ftoa_engine+0x19a>
    1d64:	23 95       	inc	r18
    1d66:	7e 91       	ld	r23, -X
    1d68:	73 95       	inc	r23
    1d6a:	7a 33       	cpi	r23, 0x3A	; 58
    1d6c:	08 f0       	brcs	.+2      	; 0x1d70 <__ftoa_engine+0x180>
    1d6e:	70 e3       	ldi	r23, 0x30	; 48
    1d70:	7c 93       	st	X, r23
    1d72:	20 13       	cpse	r18, r16
    1d74:	b8 f7       	brcc	.-18     	; 0x1d64 <__ftoa_engine+0x174>
    1d76:	7e 91       	ld	r23, -X
    1d78:	70 61       	ori	r23, 0x10	; 16
    1d7a:	7d 93       	st	X+, r23
    1d7c:	30 f0       	brcs	.+12     	; 0x1d8a <__ftoa_engine+0x19a>
    1d7e:	83 95       	inc	r24
    1d80:	71 e3       	ldi	r23, 0x31	; 49
    1d82:	7d 93       	st	X+, r23
    1d84:	70 e3       	ldi	r23, 0x30	; 48
    1d86:	2a 95       	dec	r18
    1d88:	e1 f7       	brne	.-8      	; 0x1d82 <__ftoa_engine+0x192>
    1d8a:	11 24       	eor	r1, r1
    1d8c:	ef 90       	pop	r14
    1d8e:	ff 90       	pop	r15
    1d90:	0f 91       	pop	r16
    1d92:	1f 91       	pop	r17
    1d94:	cf 91       	pop	r28
    1d96:	df 91       	pop	r29
    1d98:	99 27       	eor	r25, r25
    1d9a:	87 fd       	sbrc	r24, 7
    1d9c:	90 95       	com	r25
    1d9e:	08 95       	ret

00001da0 <strnlen_P>:
    1da0:	fc 01       	movw	r30, r24
    1da2:	05 90       	lpm	r0, Z+
    1da4:	61 50       	subi	r22, 0x01	; 1
    1da6:	70 40       	sbci	r23, 0x00	; 0
    1da8:	01 10       	cpse	r0, r1
    1daa:	d8 f7       	brcc	.-10     	; 0x1da2 <strnlen_P+0x2>
    1dac:	80 95       	com	r24
    1dae:	90 95       	com	r25
    1db0:	8e 0f       	add	r24, r30
    1db2:	9f 1f       	adc	r25, r31
    1db4:	08 95       	ret

00001db6 <strnlen>:
    1db6:	fc 01       	movw	r30, r24
    1db8:	61 50       	subi	r22, 0x01	; 1
    1dba:	70 40       	sbci	r23, 0x00	; 0
    1dbc:	01 90       	ld	r0, Z+
    1dbe:	01 10       	cpse	r0, r1
    1dc0:	d8 f7       	brcc	.-10     	; 0x1db8 <strnlen+0x2>
    1dc2:	80 95       	com	r24
    1dc4:	90 95       	com	r25
    1dc6:	8e 0f       	add	r24, r30
    1dc8:	9f 1f       	adc	r25, r31
    1dca:	08 95       	ret

00001dcc <fputc>:
    1dcc:	0f 93       	push	r16
    1dce:	1f 93       	push	r17
    1dd0:	cf 93       	push	r28
    1dd2:	df 93       	push	r29
    1dd4:	fb 01       	movw	r30, r22
    1dd6:	23 81       	ldd	r18, Z+3	; 0x03
    1dd8:	21 fd       	sbrc	r18, 1
    1dda:	03 c0       	rjmp	.+6      	; 0x1de2 <fputc+0x16>
    1ddc:	8f ef       	ldi	r24, 0xFF	; 255
    1dde:	9f ef       	ldi	r25, 0xFF	; 255
    1de0:	2c c0       	rjmp	.+88     	; 0x1e3a <fputc+0x6e>
    1de2:	22 ff       	sbrs	r18, 2
    1de4:	16 c0       	rjmp	.+44     	; 0x1e12 <fputc+0x46>
    1de6:	46 81       	ldd	r20, Z+6	; 0x06
    1de8:	57 81       	ldd	r21, Z+7	; 0x07
    1dea:	24 81       	ldd	r18, Z+4	; 0x04
    1dec:	35 81       	ldd	r19, Z+5	; 0x05
    1dee:	42 17       	cp	r20, r18
    1df0:	53 07       	cpc	r21, r19
    1df2:	44 f4       	brge	.+16     	; 0x1e04 <fputc+0x38>
    1df4:	a0 81       	ld	r26, Z
    1df6:	b1 81       	ldd	r27, Z+1	; 0x01
    1df8:	9d 01       	movw	r18, r26
    1dfa:	2f 5f       	subi	r18, 0xFF	; 255
    1dfc:	3f 4f       	sbci	r19, 0xFF	; 255
    1dfe:	20 83       	st	Z, r18
    1e00:	31 83       	std	Z+1, r19	; 0x01
    1e02:	8c 93       	st	X, r24
    1e04:	26 81       	ldd	r18, Z+6	; 0x06
    1e06:	37 81       	ldd	r19, Z+7	; 0x07
    1e08:	2f 5f       	subi	r18, 0xFF	; 255
    1e0a:	3f 4f       	sbci	r19, 0xFF	; 255
    1e0c:	26 83       	std	Z+6, r18	; 0x06
    1e0e:	37 83       	std	Z+7, r19	; 0x07
    1e10:	14 c0       	rjmp	.+40     	; 0x1e3a <fputc+0x6e>
    1e12:	8b 01       	movw	r16, r22
    1e14:	ec 01       	movw	r28, r24
    1e16:	fb 01       	movw	r30, r22
    1e18:	00 84       	ldd	r0, Z+8	; 0x08
    1e1a:	f1 85       	ldd	r31, Z+9	; 0x09
    1e1c:	e0 2d       	mov	r30, r0
    1e1e:	09 95       	icall
    1e20:	89 2b       	or	r24, r25
    1e22:	e1 f6       	brne	.-72     	; 0x1ddc <fputc+0x10>
    1e24:	d8 01       	movw	r26, r16
    1e26:	16 96       	adiw	r26, 0x06	; 6
    1e28:	8d 91       	ld	r24, X+
    1e2a:	9c 91       	ld	r25, X
    1e2c:	17 97       	sbiw	r26, 0x07	; 7
    1e2e:	01 96       	adiw	r24, 0x01	; 1
    1e30:	16 96       	adiw	r26, 0x06	; 6
    1e32:	8d 93       	st	X+, r24
    1e34:	9c 93       	st	X, r25
    1e36:	17 97       	sbiw	r26, 0x07	; 7
    1e38:	ce 01       	movw	r24, r28
    1e3a:	df 91       	pop	r29
    1e3c:	cf 91       	pop	r28
    1e3e:	1f 91       	pop	r17
    1e40:	0f 91       	pop	r16
    1e42:	08 95       	ret

00001e44 <__ultoa_invert>:
    1e44:	fa 01       	movw	r30, r20
    1e46:	aa 27       	eor	r26, r26
    1e48:	28 30       	cpi	r18, 0x08	; 8
    1e4a:	51 f1       	breq	.+84     	; 0x1ea0 <__ultoa_invert+0x5c>
    1e4c:	20 31       	cpi	r18, 0x10	; 16
    1e4e:	81 f1       	breq	.+96     	; 0x1eb0 <__ultoa_invert+0x6c>
    1e50:	e8 94       	clt
    1e52:	6f 93       	push	r22
    1e54:	6e 7f       	andi	r22, 0xFE	; 254
    1e56:	6e 5f       	subi	r22, 0xFE	; 254
    1e58:	7f 4f       	sbci	r23, 0xFF	; 255
    1e5a:	8f 4f       	sbci	r24, 0xFF	; 255
    1e5c:	9f 4f       	sbci	r25, 0xFF	; 255
    1e5e:	af 4f       	sbci	r26, 0xFF	; 255
    1e60:	b1 e0       	ldi	r27, 0x01	; 1
    1e62:	3e d0       	rcall	.+124    	; 0x1ee0 <__ultoa_invert+0x9c>
    1e64:	b4 e0       	ldi	r27, 0x04	; 4
    1e66:	3c d0       	rcall	.+120    	; 0x1ee0 <__ultoa_invert+0x9c>
    1e68:	67 0f       	add	r22, r23
    1e6a:	78 1f       	adc	r23, r24
    1e6c:	89 1f       	adc	r24, r25
    1e6e:	9a 1f       	adc	r25, r26
    1e70:	a1 1d       	adc	r26, r1
    1e72:	68 0f       	add	r22, r24
    1e74:	79 1f       	adc	r23, r25
    1e76:	8a 1f       	adc	r24, r26
    1e78:	91 1d       	adc	r25, r1
    1e7a:	a1 1d       	adc	r26, r1
    1e7c:	6a 0f       	add	r22, r26
    1e7e:	71 1d       	adc	r23, r1
    1e80:	81 1d       	adc	r24, r1
    1e82:	91 1d       	adc	r25, r1
    1e84:	a1 1d       	adc	r26, r1
    1e86:	20 d0       	rcall	.+64     	; 0x1ec8 <__ultoa_invert+0x84>
    1e88:	09 f4       	brne	.+2      	; 0x1e8c <__ultoa_invert+0x48>
    1e8a:	68 94       	set
    1e8c:	3f 91       	pop	r19
    1e8e:	2a e0       	ldi	r18, 0x0A	; 10
    1e90:	26 9f       	mul	r18, r22
    1e92:	11 24       	eor	r1, r1
    1e94:	30 19       	sub	r19, r0
    1e96:	30 5d       	subi	r19, 0xD0	; 208
    1e98:	31 93       	st	Z+, r19
    1e9a:	de f6       	brtc	.-74     	; 0x1e52 <__ultoa_invert+0xe>
    1e9c:	cf 01       	movw	r24, r30
    1e9e:	08 95       	ret
    1ea0:	46 2f       	mov	r20, r22
    1ea2:	47 70       	andi	r20, 0x07	; 7
    1ea4:	40 5d       	subi	r20, 0xD0	; 208
    1ea6:	41 93       	st	Z+, r20
    1ea8:	b3 e0       	ldi	r27, 0x03	; 3
    1eaa:	0f d0       	rcall	.+30     	; 0x1eca <__ultoa_invert+0x86>
    1eac:	c9 f7       	brne	.-14     	; 0x1ea0 <__ultoa_invert+0x5c>
    1eae:	f6 cf       	rjmp	.-20     	; 0x1e9c <__ultoa_invert+0x58>
    1eb0:	46 2f       	mov	r20, r22
    1eb2:	4f 70       	andi	r20, 0x0F	; 15
    1eb4:	40 5d       	subi	r20, 0xD0	; 208
    1eb6:	4a 33       	cpi	r20, 0x3A	; 58
    1eb8:	18 f0       	brcs	.+6      	; 0x1ec0 <__ultoa_invert+0x7c>
    1eba:	49 5d       	subi	r20, 0xD9	; 217
    1ebc:	31 fd       	sbrc	r19, 1
    1ebe:	40 52       	subi	r20, 0x20	; 32
    1ec0:	41 93       	st	Z+, r20
    1ec2:	02 d0       	rcall	.+4      	; 0x1ec8 <__ultoa_invert+0x84>
    1ec4:	a9 f7       	brne	.-22     	; 0x1eb0 <__ultoa_invert+0x6c>
    1ec6:	ea cf       	rjmp	.-44     	; 0x1e9c <__ultoa_invert+0x58>
    1ec8:	b4 e0       	ldi	r27, 0x04	; 4
    1eca:	a6 95       	lsr	r26
    1ecc:	97 95       	ror	r25
    1ece:	87 95       	ror	r24
    1ed0:	77 95       	ror	r23
    1ed2:	67 95       	ror	r22
    1ed4:	ba 95       	dec	r27
    1ed6:	c9 f7       	brne	.-14     	; 0x1eca <__ultoa_invert+0x86>
    1ed8:	00 97       	sbiw	r24, 0x00	; 0
    1eda:	61 05       	cpc	r22, r1
    1edc:	71 05       	cpc	r23, r1
    1ede:	08 95       	ret
    1ee0:	9b 01       	movw	r18, r22
    1ee2:	ac 01       	movw	r20, r24
    1ee4:	0a 2e       	mov	r0, r26
    1ee6:	06 94       	lsr	r0
    1ee8:	57 95       	ror	r21
    1eea:	47 95       	ror	r20
    1eec:	37 95       	ror	r19
    1eee:	27 95       	ror	r18
    1ef0:	ba 95       	dec	r27
    1ef2:	c9 f7       	brne	.-14     	; 0x1ee6 <__ultoa_invert+0xa2>
    1ef4:	62 0f       	add	r22, r18
    1ef6:	73 1f       	adc	r23, r19
    1ef8:	84 1f       	adc	r24, r20
    1efa:	95 1f       	adc	r25, r21
    1efc:	a0 1d       	adc	r26, r0
    1efe:	08 95       	ret

00001f00 <__prologue_saves__>:
    1f00:	2f 92       	push	r2
    1f02:	3f 92       	push	r3
    1f04:	4f 92       	push	r4
    1f06:	5f 92       	push	r5
    1f08:	6f 92       	push	r6
    1f0a:	7f 92       	push	r7
    1f0c:	8f 92       	push	r8
    1f0e:	9f 92       	push	r9
    1f10:	af 92       	push	r10
    1f12:	bf 92       	push	r11
    1f14:	cf 92       	push	r12
    1f16:	df 92       	push	r13
    1f18:	ef 92       	push	r14
    1f1a:	ff 92       	push	r15
    1f1c:	0f 93       	push	r16
    1f1e:	1f 93       	push	r17
    1f20:	cf 93       	push	r28
    1f22:	df 93       	push	r29
    1f24:	cd b7       	in	r28, 0x3d	; 61
    1f26:	de b7       	in	r29, 0x3e	; 62
    1f28:	ca 1b       	sub	r28, r26
    1f2a:	db 0b       	sbc	r29, r27
    1f2c:	cd bf       	out	0x3d, r28	; 61
    1f2e:	de bf       	out	0x3e, r29	; 62
    1f30:	09 94       	ijmp

00001f32 <__epilogue_restores__>:
    1f32:	2a 88       	ldd	r2, Y+18	; 0x12
    1f34:	39 88       	ldd	r3, Y+17	; 0x11
    1f36:	48 88       	ldd	r4, Y+16	; 0x10
    1f38:	5f 84       	ldd	r5, Y+15	; 0x0f
    1f3a:	6e 84       	ldd	r6, Y+14	; 0x0e
    1f3c:	7d 84       	ldd	r7, Y+13	; 0x0d
    1f3e:	8c 84       	ldd	r8, Y+12	; 0x0c
    1f40:	9b 84       	ldd	r9, Y+11	; 0x0b
    1f42:	aa 84       	ldd	r10, Y+10	; 0x0a
    1f44:	b9 84       	ldd	r11, Y+9	; 0x09
    1f46:	c8 84       	ldd	r12, Y+8	; 0x08
    1f48:	df 80       	ldd	r13, Y+7	; 0x07
    1f4a:	ee 80       	ldd	r14, Y+6	; 0x06
    1f4c:	fd 80       	ldd	r15, Y+5	; 0x05
    1f4e:	0c 81       	ldd	r16, Y+4	; 0x04
    1f50:	1b 81       	ldd	r17, Y+3	; 0x03
    1f52:	aa 81       	ldd	r26, Y+2	; 0x02
    1f54:	b9 81       	ldd	r27, Y+1	; 0x01
    1f56:	ce 0f       	add	r28, r30
    1f58:	d1 1d       	adc	r29, r1
    1f5a:	cd bf       	out	0x3d, r28	; 61
    1f5c:	de bf       	out	0x3e, r29	; 62
    1f5e:	ed 01       	movw	r28, r26
    1f60:	08 95       	ret

00001f62 <_exit>:
    1f62:	f8 94       	cli

00001f64 <__stop_program>:
    1f64:	ff cf       	rjmp	.-2      	; 0x1f64 <__stop_program>
