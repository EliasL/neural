
Building_Brains_V4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000e  00803e00  0000148a  0000151e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000148a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000004f  00803e0e  00803e0e  0000152c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000152c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  0000155c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000420  00000000  00000000  00001598  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00006fe7  00000000  00000000  000019b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002dbc  00000000  00000000  0000899f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000239a  00000000  00000000  0000b75b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000774  00000000  00000000  0000daf8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002cf1  00000000  00000000  0000e26c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001516  00000000  00000000  00010f5d  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000280  00000000  00000000  00012473  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	2d c0       	rjmp	.+90     	; 0x5c <__ctors_end>
       2:	47 c0       	rjmp	.+142    	; 0x92 <__bad_interrupt>
       4:	46 c0       	rjmp	.+140    	; 0x92 <__bad_interrupt>
       6:	45 c0       	rjmp	.+138    	; 0x92 <__bad_interrupt>
       8:	44 c0       	rjmp	.+136    	; 0x92 <__bad_interrupt>
       a:	43 c0       	rjmp	.+134    	; 0x92 <__bad_interrupt>
       c:	4b c5       	rjmp	.+2710   	; 0xaa4 <__vector_6>
       e:	41 c0       	rjmp	.+130    	; 0x92 <__bad_interrupt>
      10:	40 c0       	rjmp	.+128    	; 0x92 <__bad_interrupt>
      12:	3f c0       	rjmp	.+126    	; 0x92 <__bad_interrupt>
      14:	3e c0       	rjmp	.+124    	; 0x92 <__bad_interrupt>
      16:	3d c0       	rjmp	.+122    	; 0x92 <__bad_interrupt>
      18:	3c c0       	rjmp	.+120    	; 0x92 <__bad_interrupt>
      1a:	3b c0       	rjmp	.+118    	; 0x92 <__bad_interrupt>
      1c:	3a c0       	rjmp	.+116    	; 0x92 <__bad_interrupt>
      1e:	39 c0       	rjmp	.+114    	; 0x92 <__bad_interrupt>
      20:	38 c0       	rjmp	.+112    	; 0x92 <__bad_interrupt>
      22:	37 c0       	rjmp	.+110    	; 0x92 <__bad_interrupt>
      24:	36 c0       	rjmp	.+108    	; 0x92 <__bad_interrupt>
      26:	35 c0       	rjmp	.+106    	; 0x92 <__bad_interrupt>
      28:	34 c0       	rjmp	.+104    	; 0x92 <__bad_interrupt>
      2a:	33 c0       	rjmp	.+102    	; 0x92 <__bad_interrupt>
      2c:	32 c0       	rjmp	.+100    	; 0x92 <__bad_interrupt>
      2e:	31 c0       	rjmp	.+98     	; 0x92 <__bad_interrupt>
      30:	30 c0       	rjmp	.+96     	; 0x92 <__bad_interrupt>
      32:	2f c0       	rjmp	.+94     	; 0x92 <__bad_interrupt>
      34:	07 63       	ori	r16, 0x37	; 55
      36:	42 36       	cpi	r20, 0x62	; 98
      38:	b7 9b       	sbis	0x16, 7	; 22
      3a:	d8 a7       	std	Y+40, r29	; 0x28
      3c:	1a 39       	cpi	r17, 0x9A	; 154
      3e:	68 56       	subi	r22, 0x68	; 104
      40:	18 ae       	std	Y+56, r1	; 0x38
      42:	ba ab       	std	Y+50, r27	; 0x32
      44:	55 8c       	ldd	r5, Z+29	; 0x1d
      46:	1d 3c       	cpi	r17, 0xCD	; 205
      48:	b7 cc       	rjmp	.-1682   	; 0xfffff9b8 <__eeprom_end+0xff7ef9b8>
      4a:	57 63       	ori	r21, 0x37	; 55
      4c:	bd 6d       	ori	r27, 0xDD	; 221
      4e:	ed fd       	.word	0xfded	; ????
      50:	75 3e       	cpi	r23, 0xE5	; 229
      52:	f6 17       	cp	r31, r22
      54:	72 31       	cpi	r23, 0x12	; 18
      56:	bf 00       	.word	0x00bf	; ????
      58:	00 00       	nop
      5a:	80 3f       	cpi	r24, 0xF0	; 240

0000005c <__ctors_end>:
      5c:	11 24       	eor	r1, r1
      5e:	1f be       	out	0x3f, r1	; 63
      60:	cf ef       	ldi	r28, 0xFF	; 255
      62:	cd bf       	out	0x3d, r28	; 61
      64:	df e3       	ldi	r29, 0x3F	; 63
      66:	de bf       	out	0x3e, r29	; 62

00000068 <__do_copy_data>:
      68:	1e e3       	ldi	r17, 0x3E	; 62
      6a:	a0 e0       	ldi	r26, 0x00	; 0
      6c:	be e3       	ldi	r27, 0x3E	; 62
      6e:	ea e8       	ldi	r30, 0x8A	; 138
      70:	f4 e1       	ldi	r31, 0x14	; 20
      72:	02 c0       	rjmp	.+4      	; 0x78 <__do_copy_data+0x10>
      74:	05 90       	lpm	r0, Z+
      76:	0d 92       	st	X+, r0
      78:	ae 30       	cpi	r26, 0x0E	; 14
      7a:	b1 07       	cpc	r27, r17
      7c:	d9 f7       	brne	.-10     	; 0x74 <__do_copy_data+0xc>

0000007e <__do_clear_bss>:
      7e:	2e e3       	ldi	r18, 0x3E	; 62
      80:	ae e0       	ldi	r26, 0x0E	; 14
      82:	be e3       	ldi	r27, 0x3E	; 62
      84:	01 c0       	rjmp	.+2      	; 0x88 <.do_clear_bss_start>

00000086 <.do_clear_bss_loop>:
      86:	1d 92       	st	X+, r1

00000088 <.do_clear_bss_start>:
      88:	ad 35       	cpi	r26, 0x5D	; 93
      8a:	b2 07       	cpc	r27, r18
      8c:	e1 f7       	brne	.-8      	; 0x86 <.do_clear_bss_loop>
      8e:	fa d1       	rcall	.+1012   	; 0x484 <main>
      90:	fa c9       	rjmp	.-3084   	; 0xfffff486 <__eeprom_end+0xff7ef486>

00000092 <__bad_interrupt>:
      92:	b6 cf       	rjmp	.-148    	; 0x0 <__vectors>

00000094 <atmel_start_init>:
/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
	system_init();
      94:	b8 d0       	rcall	.+368    	; 0x206 <system_init>
      96:	08 95       	ret

00000098 <ADC_init>:
 * \return Conversion result read from the ADC ADC module
 */
adc_result_t ADC_get_conversion_result(void)
{
	return (ADC0.RES);
}
      98:	85 e0       	ldi	r24, 0x05	; 5
      9a:	80 93 00 06 	sts	0x0600, r24	; 0x800600 <__TEXT_REGION_LENGTH__+0x700600>
      9e:	80 e0       	ldi	r24, 0x00	; 0
      a0:	08 95       	ret

000000a2 <ADC_is_conversion_done>:
      a2:	80 91 0b 06 	lds	r24, 0x060B	; 0x80060b <__TEXT_REGION_LENGTH__+0x70060b>
      a6:	81 70       	andi	r24, 0x01	; 1
      a8:	08 95       	ret

000000aa <ADC_get_conversion>:
 *
 * \return Nothing
 */
void ADC_start_conversion(adc_0_channel_t channel)
{
	ADC0.MUXPOS  = channel;
      aa:	e0 e0       	ldi	r30, 0x00	; 0
      ac:	f6 e0       	ldi	r31, 0x06	; 6
      ae:	86 83       	std	Z+6, r24	; 0x06
	ADC0.COMMAND = ADC_STCONV_bm;
      b0:	81 e0       	ldi	r24, 0x01	; 1
      b2:	80 87       	std	Z+8, r24	; 0x08
adc_result_t ADC_get_conversion(adc_0_channel_t channel)
{
	adc_result_t res;

	ADC_start_conversion(channel);
	while (!ADC_is_conversion_done())
      b4:	f6 df       	rcall	.-20     	; 0xa2 <ADC_is_conversion_done>
      b6:	88 23       	and	r24, r24
      b8:	e9 f3       	breq	.-6      	; 0xb4 <ADC_get_conversion+0xa>
 *
 * \return Conversion result read from the ADC ADC module
 */
adc_result_t ADC_get_conversion_result(void)
{
	return (ADC0.RES);
      ba:	e0 e0       	ldi	r30, 0x00	; 0
      bc:	f6 e0       	ldi	r31, 0x06	; 6
      be:	20 89       	ldd	r18, Z+16	; 0x10
      c0:	31 89       	ldd	r19, Z+17	; 0x11

	ADC_start_conversion(channel);
	while (!ADC_is_conversion_done())
		;
	res = ADC_get_conversion_result();
	ADC0.INTFLAGS |= ADC_RESRDY_bm;
      c2:	93 85       	ldd	r25, Z+11	; 0x0b
      c4:	91 60       	ori	r25, 0x01	; 1
      c6:	93 87       	std	Z+11, r25	; 0x0b
	return res;
}
      c8:	c9 01       	movw	r24, r18
      ca:	08 95       	ret

000000cc <BOD_init>:
	//		 | BOD_VLMCFG_ABOVE_gc; /* Interrupt when supply goes above VLM level */

	// BOD.VLMCTRLA = BOD_VLMLVL_5ABOVE_gc; /* VLM threshold 5% above BOD level */

	return 0;
}
      cc:	80 e0       	ldi	r24, 0x00	; 0
      ce:	08 95       	ret

000000d0 <DIGGSIGG_init>:
	//		 | CCL_EDGEDET_DIS_gc /* Edge detector is disabled */
	//		 | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	//		 | 0 << CCL_ENABLE_bp /* LUT Enable: disabled */
	//		 | 0 << CCL_OUTEN_bp; /* Output Enable: disabled */

	CCL.TRUTH1 = 168; /* Truth 1: 168 */
      d0:	e0 ec       	ldi	r30, 0xC0	; 192
      d2:	f1 e0       	ldi	r31, 0x01	; 1
      d4:	88 ea       	ldi	r24, 0xA8	; 168
      d6:	84 87       	std	Z+12, r24	; 0x0c

	CCL.LUT1CTRLC = CCL_INSEL2_TCA0_gc /* TCA0 WO2 input source */;
      d8:	88 e0       	ldi	r24, 0x08	; 8
      da:	83 87       	std	Z+11, r24	; 0x0b

	CCL.LUT1CTRLB = CCL_INSEL0_SPI0_gc /* SPI0 SCK source */
      dc:	8b eb       	ldi	r24, 0xBB	; 187
      de:	82 87       	std	Z+10, r24	; 0x0a
	                | CCL_INSEL1_SPI0_gc /* SPI0 MOSI input source */;

	CCL.LUT1CTRLA = 0 << CCL_CLKSRC_bp       /* Clock Source Selection: disabled */
      e0:	89 e0       	ldi	r24, 0x09	; 9
      e2:	81 87       	std	Z+9, r24	; 0x09
	                | CCL_EDGEDET_DIS_gc     /* Edge detector is disabled */
	                | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	                | 1 << CCL_ENABLE_bp     /* LUT Enable: enabled */
	                | 1 << CCL_OUTEN_bp;     /* Output Enable: enabled */

	CCL.CTRLA = 1 << CCL_ENABLE_bp      /* Enable: enabled */
      e4:	81 e4       	ldi	r24, 0x41	; 65
      e6:	80 83       	st	Z, r24
	            | 1 << CCL_RUNSTDBY_bp; /* Run in Standby: enabled */

	return 0;
}
      e8:	80 e0       	ldi	r24, 0x00	; 0
      ea:	08 95       	ret

000000ec <CLKCTRL_init>:
 *       on calling convention. The memory model is not visible to the
 *       preprocessor, so it must be defined in the Assembler preprocessor directives.
 */
static inline void ccp_write_io(void *addr, uint8_t value)
{
	protected_write_io(addr, CCP_IOREG_gc, value);
      ec:	47 e0       	ldi	r20, 0x07	; 7
      ee:	68 ed       	ldi	r22, 0xD8	; 216
      f0:	8c e7       	ldi	r24, 0x7C	; 124
      f2:	90 e0       	ldi	r25, 0x00	; 0
      f4:	a2 d0       	rcall	.+324    	; 0x23a <protected_write_io>
      f6:	41 e0       	ldi	r20, 0x01	; 1
      f8:	68 ed       	ldi	r22, 0xD8	; 216
      fa:	81 e6       	ldi	r24, 0x61	; 97
      fc:	90 e0       	ldi	r25, 0x00	; 0
      fe:	9d d0       	rcall	.+314    	; 0x23a <protected_write_io>
	//		 | 0 << CLKCTRL_CLKOUT_bp /* System clock out: disabled */);

	// ccp_write_io((void*)&(CLKCTRL.MCLKLOCK),0 << CLKCTRL_LOCKEN_bp /* lock enable: disabled */);

	return 0;
}
     100:	80 e0       	ldi	r24, 0x00	; 0
     102:	08 95       	ret

00000104 <CPUINT_init>:

	// CPUINT.LVL0PRI = 0x0 << CPUINT_LVL0PRI_gp; /* Interrupt Level Priority: 0x0 */

	// CPUINT.LVL1VEC = 0x0 << CPUINT_LVL1VEC_gp; /* Interrupt Vector with High Priority: 0x0 */

	ENABLE_INTERRUPTS();
     104:	78 94       	sei

	return 0;
}
     106:	80 e0       	ldi	r24, 0x00	; 0
     108:	08 95       	ret

0000010a <DAC_init>:
 *
 * \return Nothing
 */
void DAC_disable()
{
	DAC0.CTRLA &= ~DAC_ENABLE_bm;
     10a:	81 e4       	ldi	r24, 0x41	; 65
     10c:	80 93 80 06 	sts	0x0680, r24	; 0x800680 <__TEXT_REGION_LENGTH__+0x700680>
     110:	80 e0       	ldi	r24, 0x00	; 0
     112:	08 95       	ret

00000114 <DAC_set_output>:
 *
 * \return Nothing
 */
void DAC_set_output(dac_resolution_t value)
{
	DAC0.DATA = value;
     114:	80 93 81 06 	sts	0x0681, r24	; 0x800681 <__TEXT_REGION_LENGTH__+0x700681>
     118:	08 95       	ret

0000011a <mcu_init>:
#ifdef __cplusplus
extern "C" {
#endif

void mcu_init(void)
{
     11a:	e0 e1       	ldi	r30, 0x10	; 16
     11c:	f4 e0       	ldi	r31, 0x04	; 4
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     11e:	80 81       	ld	r24, Z
     120:	88 60       	ori	r24, 0x08	; 8
     122:	81 93       	st	Z+, r24
	 * disables all peripherals to save power. Driver shall enable
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
     124:	e8 31       	cpi	r30, 0x18	; 24
     126:	84 e0       	ldi	r24, 0x04	; 4
     128:	f8 07       	cpc	r31, r24
     12a:	c9 f7       	brne	.-14     	; 0x11e <mcu_init+0x4>
     12c:	e0 e3       	ldi	r30, 0x30	; 48
     12e:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     130:	80 81       	ld	r24, Z
     132:	88 60       	ori	r24, 0x08	; 8
     134:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     136:	e8 33       	cpi	r30, 0x38	; 56
     138:	84 e0       	ldi	r24, 0x04	; 4
     13a:	f8 07       	cpc	r31, r24
     13c:	c9 f7       	brne	.-14     	; 0x130 <mcu_init+0x16>
     13e:	e0 e5       	ldi	r30, 0x50	; 80
     140:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     142:	80 81       	ld	r24, Z
     144:	88 60       	ori	r24, 0x08	; 8
     146:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     148:	e8 35       	cpi	r30, 0x58	; 88
     14a:	84 e0       	ldi	r24, 0x04	; 4
     14c:	f8 07       	cpc	r31, r24
     14e:	c9 f7       	brne	.-14     	; 0x142 <mcu_init+0x28>
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}
}
     150:	08 95       	ret

00000152 <ADC_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     152:	e5 e1       	ldi	r30, 0x15	; 21
     154:	f4 e0       	ldi	r31, 0x04	; 4
     156:	80 81       	ld	r24, Z
     158:	88 7f       	andi	r24, 0xF8	; 248
     15a:	84 60       	ori	r24, 0x04	; 4
     15c:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     15e:	80 81       	ld	r24, Z
     160:	87 7f       	andi	r24, 0xF7	; 247
     162:	80 83       	st	Z, r24
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     164:	e7 e1       	ldi	r30, 0x17	; 23
     166:	f4 e0       	ldi	r31, 0x04	; 4
     168:	80 81       	ld	r24, Z
     16a:	88 7f       	andi	r24, 0xF8	; 248
     16c:	84 60       	ori	r24, 0x04	; 4
     16e:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     170:	80 81       	ld	r24, Z
     172:	87 7f       	andi	r24, 0xF7	; 247
     174:	80 83       	st	Z, r24
 */
static inline void PORTB_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     176:	e4 e3       	ldi	r30, 0x34	; 52
     178:	f4 e0       	ldi	r31, 0x04	; 4
     17a:	80 81       	ld	r24, Z
     17c:	88 7f       	andi	r24, 0xF8	; 248
     17e:	84 60       	ori	r24, 0x04	; 4
     180:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     182:	80 81       	ld	r24, Z
     184:	87 7f       	andi	r24, 0xF7	; 247
     186:	80 83       	st	Z, r24
 */
static inline void PORTB_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     188:	e1 e3       	ldi	r30, 0x31	; 49
     18a:	f4 e0       	ldi	r31, 0x04	; 4
     18c:	80 81       	ld	r24, Z
     18e:	88 7f       	andi	r24, 0xF8	; 248
     190:	84 60       	ori	r24, 0x04	; 4
     192:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     194:	80 81       	ld	r24, Z
     196:	87 7f       	andi	r24, 0xF7	; 247
     198:	80 83       	st	Z, r24
 */
static inline void PORTB_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     19a:	e0 e3       	ldi	r30, 0x30	; 48
     19c:	f4 e0       	ldi	r31, 0x04	; 4
     19e:	80 81       	ld	r24, Z
     1a0:	88 7f       	andi	r24, 0xF8	; 248
     1a2:	84 60       	ori	r24, 0x04	; 4
     1a4:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     1a6:	80 81       	ld	r24, Z
     1a8:	87 7f       	andi	r24, 0xF7	; 247
     1aa:	80 83       	st	Z, r24
	// Disable digital input buffer
	DEN4_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	DEN4_PIN_set_pull_mode(PORT_PULL_OFF);

	ADC_init();
     1ac:	75 df       	rcall	.-278    	; 0x98 <ADC_init>
     1ae:	08 95       	ret

000001b0 <TIMER_0_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     1b0:	25 9a       	sbi	0x04, 5	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     1b2:	2d 98       	cbi	0x05, 5	; 5
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLC |= PORTMUX_TCA02_bm;
     1b4:	e0 e0       	ldi	r30, 0x00	; 0
     1b6:	f2 e0       	ldi	r31, 0x02	; 2
     1b8:	82 81       	ldd	r24, Z+2	; 0x02
     1ba:	84 60       	ori	r24, 0x04	; 4
     1bc:	82 83       	std	Z+2, r24	; 0x02

	TIMER_0_init();
     1be:	eb d0       	rcall	.+470    	; 0x396 <TIMER_0_init>
     1c0:	08 95       	ret

000001c2 <DIGGSIGG_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTC.DIR |= (1 << pin);
     1c2:	41 9a       	sbi	0x08, 1	; 8
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
	} else {
		VPORTC.OUT &= ~(1 << pin);
     1c4:	49 98       	cbi	0x09, 1	; 9
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLA |= PORTMUX_LUT1_bm;
     1c6:	e0 e0       	ldi	r30, 0x00	; 0
     1c8:	f2 e0       	ldi	r31, 0x02	; 2
     1ca:	80 81       	ld	r24, Z
     1cc:	80 62       	ori	r24, 0x20	; 32
     1ce:	80 83       	st	Z, r24

	DIGGSIGG_init();
     1d0:	7f df       	rcall	.-258    	; 0xd0 <DIGGSIGG_init>
     1d2:	08 95       	ret

000001d4 <SPI_0_initialization>:
 */
static inline void PORTA_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
     1d4:	02 98       	cbi	0x00, 2	; 0
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     1d6:	e2 e1       	ldi	r30, 0x12	; 18
     1d8:	f4 e0       	ldi	r31, 0x04	; 4
     1da:	80 81       	ld	r24, Z
     1dc:	87 7f       	andi	r24, 0xF7	; 247
     1de:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     1e0:	01 9a       	sbi	0x00, 1	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     1e2:	09 98       	cbi	0x01, 1	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     1e4:	03 9a       	sbi	0x00, 3	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     1e6:	0b 98       	cbi	0x01, 3	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     1e8:	04 9a       	sbi	0x00, 4	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     1ea:	0c 98       	cbi	0x01, 4	; 1
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	SPI_0_init();
     1ec:	cc d0       	rcall	.+408    	; 0x386 <SPI_0_init>
     1ee:	08 95       	ret

000001f0 <DAC_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     1f0:	e6 e1       	ldi	r30, 0x16	; 22
     1f2:	f4 e0       	ldi	r31, 0x04	; 4
     1f4:	80 81       	ld	r24, Z
     1f6:	88 7f       	andi	r24, 0xF8	; 248
     1f8:	84 60       	ori	r24, 0x04	; 4
     1fa:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     1fc:	80 81       	ld	r24, Z
     1fe:	87 7f       	andi	r24, 0xF7	; 247
     200:	80 83       	st	Z, r24
	// Disable digital input buffer
	AXON_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	AXON_PIN_set_pull_mode(PORT_PULL_OFF);

	DAC_init();
     202:	83 df       	rcall	.-250    	; 0x10a <DAC_init>
     204:	08 95       	ret

00000206 <system_init>:
/**
 * \brief System initialization
 */
void system_init()
{
	mcu_init();
     206:	89 df       	rcall	.-238    	; 0x11a <mcu_init>
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     208:	27 98       	cbi	0x04, 7	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     20a:	e7 e3       	ldi	r30, 0x37	; 55
     20c:	f4 e0       	ldi	r31, 0x04	; 4
     20e:	80 81       	ld	r24, Z
     210:	87 7f       	andi	r24, 0xF7	; 247
     212:	80 83       	st	Z, r24
 */
static inline void PORTC_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
     214:	42 98       	cbi	0x08, 2	; 8
static inline void PORTC_set_pin_pull_mode(const uint8_t pin, const enum port_pull_mode pull_mode)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
     216:	e2 e5       	ldi	r30, 0x52	; 82
     218:	f4 e0       	ldi	r31, 0x04	; 4
     21a:	80 81       	ld	r24, Z
     21c:	88 60       	ori	r24, 0x08	; 8
     21e:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTC.DIR |= (1 << pin);
     220:	45 9a       	sbi	0x08, 5	; 8
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     222:	4d 9a       	sbi	0x09, 5	; 9
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    true);

	CLKCTRL_init();
     224:	63 df       	rcall	.-314    	; 0xec <CLKCTRL_init>

	RTC_init();
     226:	93 d0       	rcall	.+294    	; 0x34e <RTC_init>

	ADC_initialization();
     228:	94 df       	rcall	.-216    	; 0x152 <ADC_initialization>

	TIMER_0_initialization();
     22a:	c2 df       	rcall	.-124    	; 0x1b0 <TIMER_0_initialization>

	DIGGSIGG_initialization();
     22c:	ca df       	rcall	.-108    	; 0x1c2 <DIGGSIGG_initialization>

	SPI_0_initialization();
     22e:	d2 df       	rcall	.-92     	; 0x1d4 <SPI_0_initialization>

	DAC_initialization();
     230:	df df       	rcall	.-66     	; 0x1f0 <DAC_initialization>

	CPUINT_init();
     232:	68 df       	rcall	.-304    	; 0x104 <CPUINT_init>

	SLPCTRL_init();
     234:	a6 d0       	rcall	.+332    	; 0x382 <SLPCTRL_init>

	BOD_init();
     236:	4a df       	rcall	.-364    	; 0xcc <BOD_init>
     238:	08 95       	ret

0000023a <protected_write_io>:
#if defined(__GNUC__)
  
#ifdef RAMPZ
	out     _SFR_IO_ADDR(RAMPZ), r1         // Clear bits 23:16 of Z
#endif
	movw    r30, r24                // Load addr into Z
     23a:	fc 01       	movw	r30, r24
	out     CCP, r22                // Start CCP handshake
     23c:	64 bf       	out	0x34, r22	; 52
	st      Z, r20                  // Write value to I/O register
     23e:	40 83       	st	Z, r20
	ret                             // Return to caller
     240:	08 95       	ret

00000242 <enqueue>:
 */ 
#include <stdio.h>
#include <stdlib.h>
#include "include/queue.h"

void enqueue(node_t **head, uint32_t val) {
     242:	cf 92       	push	r12
     244:	df 92       	push	r13
     246:	ef 92       	push	r14
     248:	ff 92       	push	r15
     24a:	cf 93       	push	r28
     24c:	df 93       	push	r29
     24e:	ec 01       	movw	r28, r24
     250:	6a 01       	movw	r12, r20
     252:	7b 01       	movw	r14, r22
	// remember, head is at the very BACK of the queue (The element that will wait the longest until dequeued)
	
	// we create a new empty node
	node_t *new_node = malloc(sizeof(node_t));
     254:	86 e0       	ldi	r24, 0x06	; 6
     256:	90 e0       	ldi	r25, 0x00	; 0
     258:	f5 d7       	rcall	.+4074   	; 0x1244 <malloc>
	// Not quite sure what happens here, but it seems to be some sort of error handling, except you never know if there has been an error :/
	if (!new_node) return;
     25a:	00 97       	sbiw	r24, 0x00	; 0
     25c:	59 f0       	breq	.+22     	; 0x274 <enqueue+0x32>

	// we configure our node
	new_node->val = val;
     25e:	fc 01       	movw	r30, r24
     260:	c0 82       	st	Z, r12
     262:	d1 82       	std	Z+1, r13	; 0x01
     264:	e2 82       	std	Z+2, r14	; 0x02
     266:	f3 82       	std	Z+3, r15	; 0x03
	new_node->next = *head;
     268:	28 81       	ld	r18, Y
     26a:	39 81       	ldd	r19, Y+1	; 0x01
     26c:	24 83       	std	Z+4, r18	; 0x04
     26e:	35 83       	std	Z+5, r19	; 0x05

	// and lastly, we change the pointer pointing to the previous head node, to point to our new node instead
	*head = new_node;
     270:	88 83       	st	Y, r24
     272:	99 83       	std	Y+1, r25	; 0x01
}
     274:	df 91       	pop	r29
     276:	cf 91       	pop	r28
     278:	ff 90       	pop	r15
     27a:	ef 90       	pop	r14
     27c:	df 90       	pop	r13
     27e:	cf 90       	pop	r12
     280:	08 95       	ret

00000282 <dequeue>:

uint32_t dequeue(node_t **head) {
     282:	cf 92       	push	r12
     284:	df 92       	push	r13
     286:	ef 92       	push	r14
     288:	ff 92       	push	r15
     28a:	0f 93       	push	r16
     28c:	1f 93       	push	r17
     28e:	cf 93       	push	r28
     290:	df 93       	push	r29
	node_t *current, *prev = NULL;
	uint32_t retval = 0;

	// If the queue we have been given is empty, we return an error
	// (0 is usually not an error, but it is probably the best option)
	if (*head == NULL) return 0;
     292:	dc 01       	movw	r26, r24
     294:	ed 91       	ld	r30, X+
     296:	fc 91       	ld	r31, X
     298:	30 97       	sbiw	r30, 0x00	; 0
     29a:	11 f1       	breq	.+68     	; 0x2e0 <dequeue+0x5e>
     29c:	c0 e0       	ldi	r28, 0x00	; 0
     29e:	d0 e0       	ldi	r29, 0x00	; 0
     2a0:	02 c0       	rjmp	.+4      	; 0x2a6 <dequeue+0x24>
     2a2:	ef 01       	movw	r28, r30

	// Now we iterate through the queue until we reach the end
	current = *head;
	while (current->next != NULL) {
		prev = current;
		current = current->next;
     2a4:	f9 01       	movw	r30, r18
	// (0 is usually not an error, but it is probably the best option)
	if (*head == NULL) return 0;

	// Now we iterate through the queue until we reach the end
	current = *head;
	while (current->next != NULL) {
     2a6:	24 81       	ldd	r18, Z+4	; 0x04
     2a8:	35 81       	ldd	r19, Z+5	; 0x05
     2aa:	21 15       	cp	r18, r1
     2ac:	31 05       	cpc	r19, r1
     2ae:	c9 f7       	brne	.-14     	; 0x2a2 <dequeue+0x20>
     2b0:	8c 01       	movw	r16, r24
		prev = current;
		current = current->next;
	}

	// We retrieve the value we needed
	retval = current->val;
     2b2:	c0 80       	ld	r12, Z
     2b4:	d1 80       	ldd	r13, Z+1	; 0x01
     2b6:	e2 80       	ldd	r14, Z+2	; 0x02
     2b8:	f3 80       	ldd	r15, Z+3	; 0x03
	// and remove the last element of the queue from the queue
	free(current);
     2ba:	cf 01       	movw	r24, r30
     2bc:	5b d8       	rcall	.-3914   	; 0xfffff374 <__eeprom_end+0xff7ef374>
	
	// Now we update the previous node so that it becomes the front of the queue
	// In case the queue only had one element, the prev will be null (false)
	if (prev){
     2be:	20 97       	sbiw	r28, 0x00	; 0
     2c0:	39 f0       	breq	.+14     	; 0x2d0 <dequeue+0x4e>
	prev->next = NULL;}
     2c2:	1c 82       	std	Y+4, r1	; 0x04
     2c4:	1d 82       	std	Y+5, r1	; 0x05
	else{
	*head = NULL;}

	return retval;
     2c6:	6c 2d       	mov	r22, r12
     2c8:	7d 2d       	mov	r23, r13
     2ca:	8e 2d       	mov	r24, r14
     2cc:	9f 2d       	mov	r25, r15
     2ce:	0c c0       	rjmp	.+24     	; 0x2e8 <dequeue+0x66>
	// Now we update the previous node so that it becomes the front of the queue
	// In case the queue only had one element, the prev will be null (false)
	if (prev){
	prev->next = NULL;}
	else{
	*head = NULL;}
     2d0:	f8 01       	movw	r30, r16
     2d2:	10 82       	st	Z, r1
     2d4:	11 82       	std	Z+1, r1	; 0x01

	return retval;
     2d6:	6c 2d       	mov	r22, r12
     2d8:	7d 2d       	mov	r23, r13
     2da:	8e 2d       	mov	r24, r14
     2dc:	9f 2d       	mov	r25, r15
     2de:	04 c0       	rjmp	.+8      	; 0x2e8 <dequeue+0x66>
	node_t *current, *prev = NULL;
	uint32_t retval = 0;

	// If the queue we have been given is empty, we return an error
	// (0 is usually not an error, but it is probably the best option)
	if (*head == NULL) return 0;
     2e0:	60 e0       	ldi	r22, 0x00	; 0
     2e2:	70 e0       	ldi	r23, 0x00	; 0
     2e4:	80 e0       	ldi	r24, 0x00	; 0
     2e6:	90 e0       	ldi	r25, 0x00	; 0
	prev->next = NULL;}
	else{
	*head = NULL;}

	return retval;
}
     2e8:	df 91       	pop	r29
     2ea:	cf 91       	pop	r28
     2ec:	1f 91       	pop	r17
     2ee:	0f 91       	pop	r16
     2f0:	ff 90       	pop	r15
     2f2:	ef 90       	pop	r14
     2f4:	df 90       	pop	r13
     2f6:	cf 90       	pop	r12
     2f8:	08 95       	ret

000002fa <dequeue_top>:

// Here we remove the element of the queue that was added last (first in, last out)
uint32_t dequeue_top(node_t **head){
     2fa:	cf 92       	push	r12
     2fc:	df 92       	push	r13
     2fe:	ef 92       	push	r14
     300:	ff 92       	push	r15
     302:	0f 93       	push	r16
     304:	1f 93       	push	r17
     306:	cf 93       	push	r28
     308:	df 93       	push	r29
	node_t *oldHead;
	uint32_t retval = 0;
	
	// If the queue we have been given is empty, we return an error
	// (0 is usually not an error, but it is probably the best option)
	if (*head == NULL) return 0;
     30a:	dc 01       	movw	r26, r24
     30c:	ed 91       	ld	r30, X+
     30e:	fc 91       	ld	r31, X
     310:	30 97       	sbiw	r30, 0x00	; 0
     312:	81 f0       	breq	.+32     	; 0x334 <dequeue_top+0x3a>
     314:	ec 01       	movw	r28, r24
	
	oldHead = *head;
	// We then set the new head to be the second last in the queue
	newHead = oldHead->next;
     316:	c4 80       	ldd	r12, Z+4	; 0x04
     318:	d5 80       	ldd	r13, Z+5	; 0x05
	
	// We retrieve the heads value
	retval = oldHead->val;
     31a:	e0 80       	ld	r14, Z
     31c:	f1 80       	ldd	r15, Z+1	; 0x01
     31e:	02 81       	ldd	r16, Z+2	; 0x02
     320:	13 81       	ldd	r17, Z+3	; 0x03
	
	// We free the memory that was used to store the old head
	free(oldHead);
     322:	cf 01       	movw	r24, r30
     324:	27 d8       	rcall	.-4018   	; 0xfffff374 <__eeprom_end+0xff7ef374>
	
	//And then we overwrite the value of head to be the second last
	*head = newHead;
     326:	c8 82       	st	Y, r12
     328:	d9 82       	std	Y+1, r13	; 0x01
	
	return retval;
     32a:	6e 2d       	mov	r22, r14
     32c:	7f 2d       	mov	r23, r15
     32e:	80 2f       	mov	r24, r16
     330:	91 2f       	mov	r25, r17
     332:	04 c0       	rjmp	.+8      	; 0x33c <dequeue_top+0x42>
	node_t *oldHead;
	uint32_t retval = 0;
	
	// If the queue we have been given is empty, we return an error
	// (0 is usually not an error, but it is probably the best option)
	if (*head == NULL) return 0;
     334:	60 e0       	ldi	r22, 0x00	; 0
     336:	70 e0       	ldi	r23, 0x00	; 0
     338:	80 e0       	ldi	r24, 0x00	; 0
     33a:	90 e0       	ldi	r25, 0x00	; 0
	//And then we overwrite the value of head to be the second last
	*head = newHead;
	
	return retval;
	
}
     33c:	df 91       	pop	r29
     33e:	cf 91       	pop	r28
     340:	1f 91       	pop	r17
     342:	0f 91       	pop	r16
     344:	ff 90       	pop	r15
     346:	ef 90       	pop	r14
     348:	df 90       	pop	r13
     34a:	cf 90       	pop	r12
     34c:	08 95       	ret

0000034e <RTC_init>:
 * \return Initialization status.
 */
int8_t RTC_init()
{

	while (RTC.STATUS > 0) { /* Wait for all register to be synchronized */
     34e:	e0 e4       	ldi	r30, 0x40	; 64
     350:	f1 e0       	ldi	r31, 0x01	; 1
     352:	81 81       	ldd	r24, Z+1	; 0x01
     354:	81 11       	cpse	r24, r1
     356:	fd cf       	rjmp	.-6      	; 0x352 <RTC_init+0x4>
	}

	// RTC.CMP = 0x0; /* Compare: 0x0 */

	RTC.CNT = 0x20; /* Counter: 0x20 */
     358:	e0 e4       	ldi	r30, 0x40	; 64
     35a:	f1 e0       	ldi	r31, 0x01	; 1
     35c:	80 e2       	ldi	r24, 0x20	; 32
     35e:	90 e0       	ldi	r25, 0x00	; 0
     360:	80 87       	std	Z+8, r24	; 0x08
     362:	91 87       	std	Z+9, r25	; 0x09

	RTC.CTRLA = RTC_PRESCALER_DIV1_gc   /* 1 */
     364:	21 e8       	ldi	r18, 0x81	; 129
     366:	20 83       	st	Z, r18
	            | 1 << RTC_RTCEN_bp     /* Enable: enabled */
	            | 1 << RTC_RUNSTDBY_bp; /* Run In Standby: enabled */

	RTC.PER = 0x20 / TIMESCALE; /* Period: 0x20 */
     368:	82 87       	std	Z+10, r24	; 0x0a
     36a:	93 87       	std	Z+11, r25	; 0x0b

	// RTC.CLKSEL = RTC_CLKSEL_INT32K_gc; /* 32KHz Internal Ultra Low Power Oscillator (OSCULP32K) */

	RTC.DBGCTRL = 1 << RTC_DBGRUN_bp; /* Run in debug: enabled */
     36c:	81 e0       	ldi	r24, 0x01	; 1
     36e:	85 83       	std	Z+5, r24	; 0x05

	RTC.INTCTRL = 0 << RTC_CMP_bp    /* Compare Match Interrupt enable: disabled */
     370:	82 83       	std	Z+2, r24	; 0x02
	              | 1 << RTC_OVF_bp; /* Overflow Interrupt enable: enabled */

	while (RTC.PITSTATUS > 0) { /* Wait for all register to be synchronized */
     372:	81 89       	ldd	r24, Z+17	; 0x11
     374:	81 11       	cpse	r24, r1
     376:	fd cf       	rjmp	.-6      	; 0x372 <RTC_init+0x24>
	}

	RTC.PITCTRLA = RTC_PERIOD_OFF_gc    /* Off */
     378:	81 e0       	ldi	r24, 0x01	; 1
     37a:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <__TEXT_REGION_LENGTH__+0x700150>
	// RTC.PITDBGCTRL = 0 << RTC_DBGRUN_bp; /* Run in debug: disabled */

	// RTC.PITINTCTRL = 0 << RTC_PI_bp; /* Periodic Interrupt: disabled */

	return 0;
}
     37e:	80 e0       	ldi	r24, 0x00	; 0
     380:	08 95       	ret

00000382 <SLPCTRL_init>:

	// SLPCTRL.CTRLA = 0 << SLPCTRL_SEN_bp /* Sleep enable: disabled */
	//		 | SLPCTRL_SMODE_IDLE_gc; /* Idle mode */

	return 0;
}
     382:	80 e0       	ldi	r24, 0x00	; 0
     384:	08 95       	ret

00000386 <SPI_0_init>:
 * \return Initialization status
 */
int8_t SPI_0_init()
{

	SPI0.CTRLA = 0 << SPI_CLK2X_bp     /* Enable Double Speed: disabled */
     386:	e0 e2       	ldi	r30, 0x20	; 32
     388:	f8 e0       	ldi	r31, 0x08	; 8
     38a:	83 e2       	ldi	r24, 0x23	; 35
     38c:	80 83       	st	Z, r24
	             | 0 << SPI_DORD_bp    /* Data Order Setting: disabled */
	             | 1 << SPI_ENABLE_bp  /* Enable Module: enabled */
	             | 1 << SPI_MASTER_bp  /* SPI module in master mode */
	             | SPI_PRESC_DIV16_gc; /* System Clock / 16 */

	SPI0.CTRLB = 0 << SPI_BUFEN_bp   /* Buffer Mode Enable: disabled */
     38e:	84 e0       	ldi	r24, 0x04	; 4
     390:	81 83       	std	Z+1, r24	; 0x01
	//		 | 0 << SPI_RXCIE_bp /* Receive Complete Interrupt Enable: disabled */
	//		 | 0 << SPI_SSIE_bp /* Slave Select Trigger Interrupt Enable: disabled */
	//		 | 0 << SPI_TXCIE_bp; /* Transfer Complete Interrupt Enable: disabled */

	return 0;
}
     392:	80 e0       	ldi	r24, 0x00	; 0
     394:	08 95       	ret

00000396 <TIMER_0_init>:

	// TCA0.SINGLE.CMP0 = 0x0; /* Compare Register 0: 0x0 */

	// TCA0.SINGLE.CMP1 = 0x0; /* Compare Register 1: 0x0 */

	TCA0.SINGLE.CMP2 = 0x4; /* Compare Register 2: 0x4 */
     396:	e0 e0       	ldi	r30, 0x00	; 0
     398:	fa e0       	ldi	r31, 0x0A	; 10
     39a:	84 e0       	ldi	r24, 0x04	; 4
     39c:	90 e0       	ldi	r25, 0x00	; 0
     39e:	84 a7       	std	Z+44, r24	; 0x2c
     3a0:	95 a7       	std	Z+45, r25	; 0x2d

	// TCA0.SINGLE.CNT = 0x0; /* Count: 0x0 */

	TCA0.SINGLE.CTRLB = 0 << TCA_SINGLE_ALUPD_bp            /* Auto Lock Update: disabled */
     3a2:	83 e4       	ldi	r24, 0x43	; 67
     3a4:	81 83       	std	Z+1, r24	; 0x01
	                    | 0 << TCA_SINGLE_CMP0EN_bp         /* Compare 0 Enable: disabled */
	                    | 0 << TCA_SINGLE_CMP1EN_bp         /* Compare 1 Enable: disabled */
	                    | 1 << TCA_SINGLE_CMP2EN_bp         /* Compare 2 Enable: enabled */
	                    | TCA_SINGLE_WGMODE_SINGLESLOPE_gc; /*  */

	TCA0.SINGLE.CTRLC = 0 << TCA_SINGLE_CMP0OV_bp    /* Compare 0 Waveform Output Value: disabled */
     3a6:	84 e0       	ldi	r24, 0x04	; 4
     3a8:	82 83       	std	Z+2, r24	; 0x02
	// TCA0.SINGLE.INTCTRL = 0 << TCA_SINGLE_CMP0_bp /* Compare 0 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP1_bp /* Compare 1 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP2_bp /* Compare 2 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_OVF_bp; /* Overflow Interrupt: disabled */

	TCA0.SINGLE.PER = 0x7; /* Period: 0x7 */
     3aa:	87 e0       	ldi	r24, 0x07	; 7
     3ac:	90 e0       	ldi	r25, 0x00	; 0
     3ae:	86 a3       	std	Z+38, r24	; 0x26
     3b0:	97 a3       	std	Z+39, r25	; 0x27

	// TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV1_gc /* System Clock */
	//		 | 0 << TCA_SINGLE_ENABLE_bp; /* Module Enable: disabled */

	return 0;
}
     3b2:	80 e0       	ldi	r24, 0x00	; 0
     3b4:	08 95       	ret

000003b6 <tinyCharge_is_charging>:

_Bool charging;

_Bool tinyCharge_is_charging(){
	return charging;
}
     3b6:	80 91 54 3e 	lds	r24, 0x3E54	; 0x803e54 <charging>
     3ba:	08 95       	ret

000003bc <tinyCharge_set_charging>:

void tinyCharge_set_charging(_Bool charging_status){
	charging = charging_status;
     3bc:	80 93 54 3e 	sts	0x3E54, r24	; 0x803e54 <charging>
     3c0:	08 95       	ret

000003c2 <tinyCharge_set_transistors>:
}


void tinyCharge_set_transistors(){
	if(charging){
     3c2:	80 91 54 3e 	lds	r24, 0x3E54	; 0x803e54 <charging>
     3c6:	88 23       	and	r24, r24
     3c8:	11 f0       	breq	.+4      	; 0x3ce <tinyCharge_set_transistors+0xc>
	} else {
		VPORTC.OUT &= ~(1 << pin);
     3ca:	4d 98       	cbi	0x09, 5	; 9
     3cc:	08 95       	ret
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     3ce:	4d 9a       	sbi	0x09, 5	; 9
     3d0:	08 95       	ret

000003d2 <tinyPulse_toggle_pulse_mode>:
uint32_t time_of_last_pulse = 0;
uint16_t time_since_last_pulse = 0;
uint16_t ideal_time_between_pulses = 1000/PULSEMODE_FREQUENCY;

void tinyPulse_toggle_pulse_mode(){
	pulse_mode = !pulse_mode;
     3d2:	90 91 14 3e 	lds	r25, 0x3E14	; 0x803e14 <pulse_mode>
     3d6:	81 e0       	ldi	r24, 0x01	; 1
     3d8:	89 27       	eor	r24, r25
     3da:	80 93 14 3e 	sts	0x3E14, r24	; 0x803e14 <pulse_mode>
     3de:	08 95       	ret

000003e0 <tinyPulse_update_potential>:
}

double tinyPulse_update_potential(double potential){
     3e0:	cf 92       	push	r12
     3e2:	df 92       	push	r13
     3e4:	ef 92       	push	r14
     3e6:	ff 92       	push	r15
     3e8:	6b 01       	movw	r12, r22
     3ea:	7c 01       	movw	r14, r24
	if(pulse_mode){
     3ec:	80 91 14 3e 	lds	r24, 0x3E14	; 0x803e14 <pulse_mode>
     3f0:	88 23       	and	r24, r24
     3f2:	21 f1       	breq	.+72     	; 0x43c <__LOCK_REGION_LENGTH__+0x3c>
		
		time_since_last_pulse = tinyTime_now() - time_of_last_pulse;
     3f4:	3e d0       	rcall	.+124    	; 0x472 <tinyTime_now>
     3f6:	20 91 10 3e 	lds	r18, 0x3E10	; 0x803e10 <time_of_last_pulse>
     3fa:	30 91 11 3e 	lds	r19, 0x3E11	; 0x803e11 <time_of_last_pulse+0x1>
     3fe:	62 1b       	sub	r22, r18
     400:	73 0b       	sbc	r23, r19
     402:	60 93 0e 3e 	sts	0x3E0E, r22	; 0x803e0e <__data_end>
     406:	70 93 0f 3e 	sts	0x3E0F, r23	; 0x803e0f <__data_end+0x1>
		
		if(time_since_last_pulse >= ideal_time_between_pulses){
     40a:	80 91 06 3e 	lds	r24, 0x3E06	; 0x803e06 <ideal_time_between_pulses>
     40e:	90 91 07 3e 	lds	r25, 0x3E07	; 0x803e07 <ideal_time_between_pulses+0x1>
     412:	68 17       	cp	r22, r24
     414:	79 07       	cpc	r23, r25
     416:	90 f0       	brcs	.+36     	; 0x43c <__LOCK_REGION_LENGTH__+0x3c>
			potential += BUTTON_PRESS_REACTION;
     418:	20 e0       	ldi	r18, 0x00	; 0
     41a:	30 e0       	ldi	r19, 0x00	; 0
     41c:	40 ed       	ldi	r20, 0xD0	; 208
     41e:	51 e4       	ldi	r21, 0x41	; 65
     420:	c7 01       	movw	r24, r14
     422:	b6 01       	movw	r22, r12
     424:	ae d3       	rcall	.+1884   	; 0xb82 <__addsf3>
     426:	6b 01       	movw	r12, r22
     428:	7c 01       	movw	r14, r24
			time_of_last_pulse = tinyTime_now();			
     42a:	23 d0       	rcall	.+70     	; 0x472 <tinyTime_now>
     42c:	60 93 10 3e 	sts	0x3E10, r22	; 0x803e10 <time_of_last_pulse>
     430:	70 93 11 3e 	sts	0x3E11, r23	; 0x803e11 <time_of_last_pulse+0x1>
     434:	80 93 12 3e 	sts	0x3E12, r24	; 0x803e12 <time_of_last_pulse+0x2>
     438:	90 93 13 3e 	sts	0x3E13, r25	; 0x803e13 <time_of_last_pulse+0x3>
		}
	}
	return potential;
}
     43c:	c7 01       	movw	r24, r14
     43e:	b6 01       	movw	r22, r12
     440:	ff 90       	pop	r15
     442:	ef 90       	pop	r14
     444:	df 90       	pop	r13
     446:	cf 90       	pop	r12
     448:	08 95       	ret

0000044a <tinyTime_counter_increment>:
If the Interrupt Service Routine is clocked by a crystal oscillator
it gives a very precise timer-counter.
*/
void tinyTime_counter_increment(void)
{
	time_counter++;
     44a:	80 91 15 3e 	lds	r24, 0x3E15	; 0x803e15 <time_counter>
     44e:	90 91 16 3e 	lds	r25, 0x3E16	; 0x803e16 <time_counter+0x1>
     452:	a0 91 17 3e 	lds	r26, 0x3E17	; 0x803e17 <time_counter+0x2>
     456:	b0 91 18 3e 	lds	r27, 0x3E18	; 0x803e18 <time_counter+0x3>
     45a:	01 96       	adiw	r24, 0x01	; 1
     45c:	a1 1d       	adc	r26, r1
     45e:	b1 1d       	adc	r27, r1
     460:	80 93 15 3e 	sts	0x3E15, r24	; 0x803e15 <time_counter>
     464:	90 93 16 3e 	sts	0x3E16, r25	; 0x803e16 <time_counter+0x1>
     468:	a0 93 17 3e 	sts	0x3E17, r26	; 0x803e17 <time_counter+0x2>
     46c:	b0 93 18 3e 	sts	0x3E18, r27	; 0x803e18 <time_counter+0x3>
     470:	08 95       	ret

00000472 <tinyTime_now>:
/*
This function is callable by external libraries to give them the counted time so far.
*/
uint32_t tinyTime_now(void)
{
	return time_counter;
     472:	60 91 15 3e 	lds	r22, 0x3E15	; 0x803e15 <time_counter>
     476:	70 91 16 3e 	lds	r23, 0x3E16	; 0x803e16 <time_counter+0x1>
     47a:	80 91 17 3e 	lds	r24, 0x3E17	; 0x803e17 <time_counter+0x2>
     47e:	90 91 18 3e 	lds	r25, 0x3E18	; 0x803e18 <time_counter+0x3>
     482:	08 95       	ret

00000484 <main>:

*/


int main(void)
{	
     484:	cf 93       	push	r28
     486:	df 93       	push	r29
     488:	00 d0       	rcall	.+0      	; 0x48a <main+0x6>
     48a:	cd b7       	in	r28, 0x3d	; 61
     48c:	de b7       	in	r29, 0x3e	; 62
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
     48e:	02 de       	rcall	.-1020   	; 0x94 <atmel_start_init>
	Setting this value will mean that the ADC (Analog to Digital Converter) will read 4.32v as 255, and 0v as 0.
	For some reason, instead of the reference voltage being 4.32v, it is 3.3v. 
	A plausible explanation is that the microchip does not up the voltage, so that if the microchip is only ever 
	supplied with 3.3v, it will output 3.3v as the max.
	*/
	VREF.CTRLA = VREF_ADC0REFSEL_4V34_gc;
     490:	80 e3       	ldi	r24, 0x30	; 48
     492:	80 93 a0 00 	sts	0x00A0, r24	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
	
	
	uint32_t current_cycle_time = 1;
	uint32_t previous_cycle_time = 0;
	uint16_t time_passed = 0;
	uint16_t volatile cycles=0;
     496:	19 82       	std	Y+1, r1	; 0x01
     498:	1a 82       	std	Y+2, r1	; 0x02
	*/
	VREF.CTRLA = VREF_ADC0REFSEL_4V34_gc;
	
	
	uint32_t current_cycle_time = 1;
	uint32_t previous_cycle_time = 0;
     49a:	81 2c       	mov	r8, r1
     49c:	91 2c       	mov	r9, r1
     49e:	54 01       	movw	r10, r8
	uint16_t volatile cycles=0;
	
	while (1)
	{
		// We don't want to update the neuron too often because of various reasons. The tinyISR_getflag is set every ms, and so the loop is only run once every ms.  
		if(tinyISR_getflag())
     4a0:	2e d3       	rcall	.+1628   	; 0xafe <tinyISR_getflag>
     4a2:	88 23       	and	r24, r24
     4a4:	e9 f3       	breq	.-6      	; 0x4a0 <main+0x1c>
		{
			// update cycle time
			current_cycle_time = tinyTime_now();
     4a6:	e5 df       	rcall	.-54     	; 0x472 <tinyTime_now>
     4a8:	6b 01       	movw	r12, r22
     4aa:	7c 01       	movw	r14, r24
			
			
			if(tinyCharge_is_charging()){
     4ac:	84 df       	rcall	.-248    	; 0x3b6 <tinyCharge_is_charging>
     4ae:	88 23       	and	r24, r24
     4b0:	11 f0       	breq	.+4      	; 0x4b6 <main+0x32>
				// Charge loop
				
				// We check the Dendrites in order to detect if we have stopped charging
				tinyDendrite_update_signals();
     4b2:	20 d2       	rcall	.+1088   	; 0x8f4 <tinyDendrite_update_signals>
     4b4:	08 c0       	rjmp	.+16     	; 0x4c6 <main+0x42>
				
				
			}
			else{
				// Main loop				
				tinyButton_update();
     4b6:	b2 d0       	rcall	.+356    	; 0x61c <tinyButton_update>
				
				time_passed = current_cycle_time - previous_cycle_time;
				tinyPotential_update(time_passed);
     4b8:	b6 01       	movw	r22, r12
     4ba:	68 19       	sub	r22, r8
     4bc:	79 09       	sbc	r23, r9
     4be:	80 e0       	ldi	r24, 0x00	; 0
     4c0:	90 e0       	ldi	r25, 0x00	; 0
     4c2:	b2 d4       	rcall	.+2404   	; 0xe28 <__floatunsisf>
     4c4:	1f d3       	rcall	.+1598   	; 0xb04 <tinyPotential_update>
			}
			
			
			
			// Switch transistors
			tinyCharge_set_transistors();
     4c6:	7d df       	rcall	.-262    	; 0x3c2 <tinyCharge_set_transistors>
			
			// Prepare for next cycle
			previous_cycle_time = current_cycle_time;
			cycles++;
     4c8:	89 81       	ldd	r24, Y+1	; 0x01
     4ca:	9a 81       	ldd	r25, Y+2	; 0x02
     4cc:	01 96       	adiw	r24, 0x01	; 1
     4ce:	89 83       	std	Y+1, r24	; 0x01
     4d0:	9a 83       	std	Y+2, r25	; 0x02
			tinyISR_setflag(false);
     4d2:	80 e0       	ldi	r24, 0x00	; 0
     4d4:	11 d3       	rcall	.+1570   	; 0xaf8 <tinyISR_setflag>
			
			// Switch transistors
			tinyCharge_set_transistors();
			
			// Prepare for next cycle
			previous_cycle_time = current_cycle_time;
     4d6:	46 01       	movw	r8, r12
     4d8:	57 01       	movw	r10, r14
     4da:	e2 cf       	rjmp	.-60     	; 0x4a0 <main+0x1c>

000004dc <set_LED_fire>:



//function to be called upon when firing flag has been raised.
void set_LED_fire(void)
{
     4dc:	cf 93       	push	r28
	fire_flash_time_counter = tinyTime_now();
     4de:	c9 df       	rcall	.-110    	; 0x472 <tinyTime_now>
     4e0:	60 93 19 3e 	sts	0x3E19, r22	; 0x803e19 <fire_flash_time_counter>
     4e4:	70 93 1a 3e 	sts	0x3E1A, r23	; 0x803e1a <fire_flash_time_counter+0x1>
     4e8:	80 93 1b 3e 	sts	0x3E1B, r24	; 0x803e1b <fire_flash_time_counter+0x2>
     4ec:	90 93 1c 3e 	sts	0x3E1C, r25	; 0x803e1c <fire_flash_time_counter+0x3>
     4f0:	c0 e0       	ldi	r28, 0x00	; 0
	for (int i = 0; i < NUMBER_OF_LEDS; i++)
	{
		tinyCCLRGB_setColor(i, MAX_BRIGHTNESS, MAX_BRIGHTNESS, MAX_BRIGHTNESS);//As per the specs, all LEDs should be blue while firing.
     4f2:	20 e3       	ldi	r18, 0x30	; 48
     4f4:	40 e3       	ldi	r20, 0x30	; 48
     4f6:	60 e3       	ldi	r22, 0x30	; 48
     4f8:	8c 2f       	mov	r24, r28
     4fa:	fb d0       	rcall	.+502    	; 0x6f2 <tinyCCLRGB_setColor>
     4fc:	cf 5f       	subi	r28, 0xFF	; 255

//function to be called upon when firing flag has been raised.
void set_LED_fire(void)
{
	fire_flash_time_counter = tinyTime_now();
	for (int i = 0; i < NUMBER_OF_LEDS; i++)
     4fe:	c6 30       	cpi	r28, 0x06	; 6
     500:	c1 f7       	brne	.-16     	; 0x4f2 <set_LED_fire+0x16>
	{
		tinyCCLRGB_setColor(i, MAX_BRIGHTNESS, MAX_BRIGHTNESS, MAX_BRIGHTNESS);//As per the specs, all LEDs should be blue while firing.
	}
}
     502:	cf 91       	pop	r28
     504:	08 95       	ret

00000506 <potential_to_RGB_update_LEDs>:



void potential_to_RGB_update_LEDs(double potential)
{
     506:	8f 92       	push	r8
     508:	9f 92       	push	r9
     50a:	af 92       	push	r10
     50c:	bf 92       	push	r11
     50e:	cf 92       	push	r12
     510:	df 92       	push	r13
     512:	ef 92       	push	r14
     514:	ff 92       	push	r15
     516:	0f 93       	push	r16
     518:	1f 93       	push	r17
     51a:	cf 93       	push	r28
     51c:	6b 01       	movw	r12, r22
     51e:	7c 01       	movw	r14, r24
	if ((tinyTime_now() - fire_flash_time_counter) < FIRE_FLASH_TIME)
     520:	a8 df       	rcall	.-176    	; 0x472 <tinyTime_now>
     522:	00 91 19 3e 	lds	r16, 0x3E19	; 0x803e19 <fire_flash_time_counter>
     526:	10 91 1a 3e 	lds	r17, 0x3E1A	; 0x803e1a <fire_flash_time_counter+0x1>
     52a:	20 91 1b 3e 	lds	r18, 0x3E1B	; 0x803e1b <fire_flash_time_counter+0x2>
     52e:	30 91 1c 3e 	lds	r19, 0x3E1C	; 0x803e1c <fire_flash_time_counter+0x3>
     532:	dc 01       	movw	r26, r24
     534:	cb 01       	movw	r24, r22
     536:	80 1b       	sub	r24, r16
     538:	91 0b       	sbc	r25, r17
     53a:	a2 0b       	sbc	r26, r18
     53c:	b3 0b       	sbc	r27, r19
     53e:	84 36       	cpi	r24, 0x64	; 100
     540:	91 05       	cpc	r25, r1
     542:	a1 05       	cpc	r26, r1
     544:	b1 05       	cpc	r27, r1
     546:	50 f4       	brcc	.+20     	; 0x55c <potential_to_RGB_update_LEDs+0x56>
     548:	c0 e0       	ldi	r28, 0x00	; 0
	{
		for (int i = 0; i < NUMBER_OF_LEDS; i++)
		{
			tinyCCLRGB_setColor(i, MAX_BRIGHTNESS, MAX_BRIGHTNESS, MAX_BRIGHTNESS);
     54a:	20 e3       	ldi	r18, 0x30	; 48
     54c:	40 e3       	ldi	r20, 0x30	; 48
     54e:	60 e3       	ldi	r22, 0x30	; 48
     550:	8c 2f       	mov	r24, r28
     552:	cf d0       	rcall	.+414    	; 0x6f2 <tinyCCLRGB_setColor>
     554:	cf 5f       	subi	r28, 0xFF	; 255

void potential_to_RGB_update_LEDs(double potential)
{
	if ((tinyTime_now() - fire_flash_time_counter) < FIRE_FLASH_TIME)
	{
		for (int i = 0; i < NUMBER_OF_LEDS; i++)
     556:	c6 30       	cpi	r28, 0x06	; 6
     558:	c1 f7       	brne	.-16     	; 0x54a <potential_to_RGB_update_LEDs+0x44>
     55a:	53 c0       	rjmp	.+166    	; 0x602 <potential_to_RGB_update_LEDs+0xfc>
     55c:	c0 e0       	ldi	r28, 0x00	; 0
*/
static void potential_to_RGB_set_color(double potential)
{
	for (int i = 0; i < NUMBER_OF_LEDS; i++)
	{
		tinyCCLRGB_setColor(i, 0x0, 0x0, 0x0);//Clear all LED stored values on the MCU before writing again.
     55e:	20 e0       	ldi	r18, 0x00	; 0
     560:	40 e0       	ldi	r20, 0x00	; 0
     562:	60 e0       	ldi	r22, 0x00	; 0
     564:	8c 2f       	mov	r24, r28
     566:	c5 d0       	rcall	.+394    	; 0x6f2 <tinyCCLRGB_setColor>
     568:	cf 5f       	subi	r28, 0xFF	; 255
When firing all lights turn blue for ~100ms, but this needs to be tested.
LEDs are numbered right way on top of PCB, but opposite way on bottom of PCB.
*/
static void potential_to_RGB_set_color(double potential)
{
	for (int i = 0; i < NUMBER_OF_LEDS; i++)
     56a:	c6 30       	cpi	r28, 0x06	; 6
     56c:	c1 f7       	brne	.-16     	; 0x55e <potential_to_RGB_update_LEDs+0x58>
	{
		tinyCCLRGB_setColor(i, 0x0, 0x0, 0x0);//Clear all LED stored values on the MCU before writing again.
	}
	double absolute_potential = abs(potential);//setting variable for absolute potential so it won't have to be calculated more than once.
     56e:	c7 01       	movw	r24, r14
     570:	b6 01       	movw	r22, r12
     572:	24 d4       	rcall	.+2120   	; 0xdbc <__fixsfsi>
     574:	9b 01       	movw	r18, r22
     576:	77 23       	and	r23, r23
     578:	24 f4       	brge	.+8      	; 0x582 <potential_to_RGB_update_LEDs+0x7c>
     57a:	22 27       	eor	r18, r18
     57c:	33 27       	eor	r19, r19
     57e:	26 1b       	sub	r18, r22
     580:	37 0b       	sbc	r19, r23
     582:	b9 01       	movw	r22, r18
     584:	33 0f       	add	r19, r19
     586:	88 0b       	sbc	r24, r24
     588:	99 0b       	sbc	r25, r25
     58a:	50 d4       	rcall	.+2208   	; 0xe2c <__floatsisf>
     58c:	4b 01       	movw	r8, r22
     58e:	5c 01       	movw	r10, r24
	if (absolute_potential < 1)//set the middle lights as white both top side and bottom side.
     590:	20 e0       	ldi	r18, 0x00	; 0
     592:	30 e0       	ldi	r19, 0x00	; 0
     594:	40 e8       	ldi	r20, 0x80	; 128
     596:	5f e3       	ldi	r21, 0x3F	; 63
     598:	60 d3       	rcall	.+1728   	; 0xc5a <__cmpsf2>
     59a:	88 23       	and	r24, r24
     59c:	34 f4       	brge	.+12     	; 0x5aa <potential_to_RGB_update_LEDs+0xa4>
	{
		tinyCCLRGB_setColor(2, MAX_BRIGHTNESS/3, MAX_BRIGHTNESS/3, MAX_BRIGHTNESS/3);
     59e:	20 e1       	ldi	r18, 0x10	; 16
     5a0:	40 e1       	ldi	r20, 0x10	; 16
     5a2:	60 e1       	ldi	r22, 0x10	; 16
     5a4:	82 e0       	ldi	r24, 0x02	; 2
     5a6:	a5 d0       	rcall	.+330    	; 0x6f2 <tinyCCLRGB_setColor>
     5a8:	2c c0       	rjmp	.+88     	; 0x602 <potential_to_RGB_update_LEDs+0xfc>
		//tinyCCLRGB_setColor(4, max_brightness/3, max_brightness/3, max_brightness/3);
	}
	else
	{
		uint8_t brightness_intensity = round((absolute_potential/25)*MAX_BRIGHTNESS);//brightness intensity for the LED that shows potential.
     5aa:	20 e0       	ldi	r18, 0x00	; 0
     5ac:	30 e0       	ldi	r19, 0x00	; 0
     5ae:	48 ec       	ldi	r20, 0xC8	; 200
     5b0:	51 e4       	ldi	r21, 0x41	; 65
     5b2:	c5 01       	movw	r24, r10
     5b4:	b4 01       	movw	r22, r8
     5b6:	56 d3       	rcall	.+1708   	; 0xc64 <__divsf3>
     5b8:	20 e0       	ldi	r18, 0x00	; 0
     5ba:	30 e0       	ldi	r19, 0x00	; 0
     5bc:	40 e4       	ldi	r20, 0x40	; 64
     5be:	52 e4       	ldi	r21, 0x42	; 66
     5c0:	87 d5       	rcall	.+2830   	; 0x10d0 <__mulsf3>
     5c2:	f3 d5       	rcall	.+3046   	; 0x11aa <round>
     5c4:	02 d4       	rcall	.+2052   	; 0xdca <__fixunssfsi>
     5c6:	c6 2f       	mov	r28, r22
		if (potential < 0)
     5c8:	20 e0       	ldi	r18, 0x00	; 0
     5ca:	30 e0       	ldi	r19, 0x00	; 0
     5cc:	a9 01       	movw	r20, r18
     5ce:	c7 01       	movw	r24, r14
     5d0:	b6 01       	movw	r22, r12
     5d2:	43 d3       	rcall	.+1670   	; 0xc5a <__cmpsf2>
     5d4:	88 23       	and	r24, r24
     5d6:	5c f4       	brge	.+22     	; 0x5ee <potential_to_RGB_update_LEDs+0xe8>
		{
			tinyCCLRGB_setColor(0, brightness_intensity, 0x0, 0x0);
     5d8:	20 e0       	ldi	r18, 0x00	; 0
     5da:	40 e0       	ldi	r20, 0x00	; 0
     5dc:	6c 2f       	mov	r22, r28
     5de:	80 e0       	ldi	r24, 0x00	; 0
     5e0:	88 d0       	rcall	.+272    	; 0x6f2 <tinyCCLRGB_setColor>
			tinyCCLRGB_setColor(1, brightness_intensity, 0x0, 0x0);//sets lower LEDs red if potential is negative.
     5e2:	20 e0       	ldi	r18, 0x00	; 0
     5e4:	40 e0       	ldi	r20, 0x00	; 0
     5e6:	6c 2f       	mov	r22, r28
     5e8:	81 e0       	ldi	r24, 0x01	; 1
     5ea:	83 d0       	rcall	.+262    	; 0x6f2 <tinyCCLRGB_setColor>
     5ec:	0a c0       	rjmp	.+20     	; 0x602 <potential_to_RGB_update_LEDs+0xfc>
		} 
		else
		{
			tinyCCLRGB_setColor(3, 0x0, brightness_intensity, 0x0);//sets upper LEDs green if potential is positive.
     5ee:	20 e0       	ldi	r18, 0x00	; 0
     5f0:	4c 2f       	mov	r20, r28
     5f2:	60 e0       	ldi	r22, 0x00	; 0
     5f4:	83 e0       	ldi	r24, 0x03	; 3
     5f6:	7d d0       	rcall	.+250    	; 0x6f2 <tinyCCLRGB_setColor>
			tinyCCLRGB_setColor(4, 0x0, brightness_intensity, 0x0);
     5f8:	20 e0       	ldi	r18, 0x00	; 0
     5fa:	4c 2f       	mov	r20, r28
     5fc:	60 e0       	ldi	r22, 0x00	; 0
     5fe:	84 e0       	ldi	r24, 0x04	; 4
     600:	78 d0       	rcall	.+240    	; 0x6f2 <tinyCCLRGB_setColor>
	}
	else
	{
		potential_to_RGB_set_color(potential);
	}
	tinyCCLRGB_uploadColorsToLeds();
     602:	84 d0       	rcall	.+264    	; 0x70c <tinyCCLRGB_uploadColorsToLeds>
}
     604:	cf 91       	pop	r28
     606:	1f 91       	pop	r17
     608:	0f 91       	pop	r16
     60a:	ff 90       	pop	r15
     60c:	ef 90       	pop	r14
     60e:	df 90       	pop	r13
     610:	cf 90       	pop	r12
     612:	bf 90       	pop	r11
     614:	af 90       	pop	r10
     616:	9f 90       	pop	r9
     618:	8f 90       	pop	r8
     61a:	08 95       	ret

0000061c <tinyButton_update>:
/*
If the button has been let go, we change button_press to true. This only lasts one cycle, before it is set to false again.
If the button is held down for longer than PULSEMODE_BUTTON_PRESS_TIME, we toggle the pulse mode state.
*/
void tinyButton_update(void)
{
     61c:	0f 93       	push	r16
     61e:	1f 93       	push	r17
     620:	cf 93       	push	r28
     622:	df 93       	push	r29
	button_press = false;
     624:	10 92 21 3e 	sts	0x3E21, r1	; 0x803e21 <button_press>
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTC_get_pin_level(const uint8_t pin)
{
	return VPORTC.IN & (1 << pin);
     628:	8a b1       	in	r24, 0x0a	; 10
	_Bool button_is_pushed_down = !BUTTON_PIN_get_level(); // The digital port will be read as low if the button is pushed down.
     62a:	d1 e0       	ldi	r29, 0x01	; 1
     62c:	c8 2f       	mov	r28, r24
     62e:	c4 70       	andi	r28, 0x04	; 4
     630:	82 fd       	sbrc	r24, 2
     632:	d0 e0       	ldi	r29, 0x00	; 0

	if (button_is_pushed_down && !button_was_pushed_down)
     634:	c1 11       	cpse	r28, r1
     636:	2f c0       	rjmp	.+94     	; 0x696 <tinyButton_update+0x7a>
     638:	80 91 22 3e 	lds	r24, 0x3E22	; 0x803e22 <button_was_pushed_down>
     63c:	81 11       	cpse	r24, r1
     63e:	0d c0       	rjmp	.+26     	; 0x65a <tinyButton_update+0x3e>
	{
		tinyButton_start_time = tinyTime_now();
     640:	18 df       	rcall	.-464    	; 0x472 <tinyTime_now>
     642:	60 93 1d 3e 	sts	0x3E1D, r22	; 0x803e1d <tinyButton_start_time>
     646:	70 93 1e 3e 	sts	0x3E1E, r23	; 0x803e1e <tinyButton_start_time+0x1>
     64a:	80 93 1f 3e 	sts	0x3E1F, r24	; 0x803e1f <tinyButton_start_time+0x2>
     64e:	90 93 20 3e 	sts	0x3E20, r25	; 0x803e20 <tinyButton_start_time+0x3>
	}
	if (button_is_pushed_down && button_was_pushed_down)
     652:	80 91 22 3e 	lds	r24, 0x3E22	; 0x803e22 <button_was_pushed_down>
     656:	88 23       	and	r24, r24
     658:	39 f1       	breq	.+78     	; 0x6a8 <tinyButton_update+0x8c>
	{
		if ((tinyTime_now() - tinyButton_start_time) > PULSEMODE_BUTTON_PRESS_TIME)
     65a:	0b df       	rcall	.-490    	; 0x472 <tinyTime_now>
     65c:	00 91 1d 3e 	lds	r16, 0x3E1D	; 0x803e1d <tinyButton_start_time>
     660:	10 91 1e 3e 	lds	r17, 0x3E1E	; 0x803e1e <tinyButton_start_time+0x1>
     664:	20 91 1f 3e 	lds	r18, 0x3E1F	; 0x803e1f <tinyButton_start_time+0x2>
     668:	30 91 20 3e 	lds	r19, 0x3E20	; 0x803e20 <tinyButton_start_time+0x3>
     66c:	dc 01       	movw	r26, r24
     66e:	cb 01       	movw	r24, r22
     670:	80 1b       	sub	r24, r16
     672:	91 0b       	sbc	r25, r17
     674:	a2 0b       	sbc	r26, r18
     676:	b3 0b       	sbc	r27, r19
     678:	81 3d       	cpi	r24, 0xD1	; 209
     67a:	97 40       	sbci	r25, 0x07	; 7
     67c:	a1 05       	cpc	r26, r1
     67e:	b1 05       	cpc	r27, r1
     680:	50 f0       	brcs	.+20     	; 0x696 <tinyButton_update+0x7a>
		{
			tinyPulse_toggle_pulse_mode();
     682:	a7 de       	rcall	.-690    	; 0x3d2 <tinyPulse_toggle_pulse_mode>
			tinyButton_start_time = tinyTime_now();
     684:	f6 de       	rcall	.-532    	; 0x472 <tinyTime_now>
     686:	60 93 1d 3e 	sts	0x3E1D, r22	; 0x803e1d <tinyButton_start_time>
     68a:	70 93 1e 3e 	sts	0x3E1E, r23	; 0x803e1e <tinyButton_start_time+0x1>
     68e:	80 93 1f 3e 	sts	0x3E1F, r24	; 0x803e1f <tinyButton_start_time+0x2>
     692:	90 93 20 3e 	sts	0x3E20, r25	; 0x803e20 <tinyButton_start_time+0x3>
		}
	}
	if (!button_is_pushed_down && button_was_pushed_down)
     696:	cc 23       	and	r28, r28
     698:	39 f0       	breq	.+14     	; 0x6a8 <tinyButton_update+0x8c>
     69a:	80 91 22 3e 	lds	r24, 0x3E22	; 0x803e22 <button_was_pushed_down>
     69e:	88 23       	and	r24, r24
     6a0:	19 f0       	breq	.+6      	; 0x6a8 <tinyButton_update+0x8c>
	{
		button_press = true;
     6a2:	81 e0       	ldi	r24, 0x01	; 1
     6a4:	80 93 21 3e 	sts	0x3E21, r24	; 0x803e21 <button_press>
	}
	button_was_pushed_down = button_is_pushed_down;
     6a8:	d0 93 22 3e 	sts	0x3E22, r29	; 0x803e22 <button_was_pushed_down>
}
     6ac:	df 91       	pop	r29
     6ae:	cf 91       	pop	r28
     6b0:	1f 91       	pop	r17
     6b2:	0f 91       	pop	r16
     6b4:	08 95       	ret

000006b6 <tinyButton_update_potential>:

double tinyButton_update_potential(double potential){
	if(button_press){
     6b6:	20 91 21 3e 	lds	r18, 0x3E21	; 0x803e21 <button_press>
     6ba:	22 23       	and	r18, r18
     6bc:	29 f0       	breq	.+10     	; 0x6c8 <tinyButton_update_potential+0x12>
		potential += BUTTON_PRESS_REACTION;
     6be:	20 e0       	ldi	r18, 0x00	; 0
     6c0:	30 e0       	ldi	r19, 0x00	; 0
     6c2:	40 ed       	ldi	r20, 0xD0	; 208
     6c4:	51 e4       	ldi	r21, 0x41	; 65
     6c6:	5d d2       	rcall	.+1210   	; 0xb82 <__addsf3>
	}
	return potential;
}
     6c8:	08 95       	ret

000006ca <tinyCCLRGB_SPIWriteByte>:
Function used to send a byte over SPI, which in turn gets
translated to the bit-sequence required by the LEDs over the CCL.
*/
static void tinyCCLRGB_SPIWriteByte(uint8_t byte)
{
	SPI0.INTFLAGS = SPI0_INTFLAGS; // clear the write collision flag to allow writing
     6ca:	90 91 23 08 	lds	r25, 0x0823	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
     6ce:	90 93 23 08 	sts	0x0823, r25	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
	TCA0.SINGLE.CNT = 0; // reset TCA counter register to ensure the first rising edge of the PWM is predictable
     6d2:	e0 e0       	ldi	r30, 0x00	; 0
     6d4:	fa e0       	ldi	r31, 0x0A	; 10
     6d6:	10 a2       	std	Z+32, r1	; 0x20
     6d8:	11 a2       	std	Z+33, r1	; 0x21
	
	// start TCA
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 1 << TCA_SPLIT_ENABLE_bp;
     6da:	91 e0       	ldi	r25, 0x01	; 1
     6dc:	90 83       	st	Z, r25
	SPI0_DATA = byte;
     6de:	80 93 24 08 	sts	0x0824, r24	; 0x800824 <__TEXT_REGION_LENGTH__+0x700824>

	while((SPI0.INTFLAGS & SPI_RXCIE_bm) == 0){} // wait for transfer to complete
     6e2:	e0 e2       	ldi	r30, 0x20	; 32
     6e4:	f8 e0       	ldi	r31, 0x08	; 8
     6e6:	83 81       	ldd	r24, Z+3	; 0x03
     6e8:	88 23       	and	r24, r24
     6ea:	ec f7       	brge	.-6      	; 0x6e6 <tinyCCLRGB_SPIWriteByte+0x1c>
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 0 << TCA_SPLIT_ENABLE_bp; //Stop TCA
     6ec:	10 92 00 0a 	sts	0x0A00, r1	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
     6f0:	08 95       	ret

000006f2 <tinyCCLRGB_setColor>:
/*
changes the values in the variables stored in the led-array.
*/
void tinyCCLRGB_setColor(uint8_t led, uint8_t red, uint8_t green, uint8_t blue) 
{
	tinyCCLRGB_colors[led].red = red;
     6f2:	90 e0       	ldi	r25, 0x00	; 0
     6f4:	fc 01       	movw	r30, r24
     6f6:	ee 0f       	add	r30, r30
     6f8:	ff 1f       	adc	r31, r31
     6fa:	8e 0f       	add	r24, r30
     6fc:	9f 1f       	adc	r25, r31
     6fe:	fc 01       	movw	r30, r24
     700:	ed 5d       	subi	r30, 0xDD	; 221
     702:	f1 4c       	sbci	r31, 0xC1	; 193
     704:	60 83       	st	Z, r22
	tinyCCLRGB_colors[led].green = green;
     706:	41 83       	std	Z+1, r20	; 0x01
	tinyCCLRGB_colors[led].blue = blue;
     708:	22 83       	std	Z+2, r18	; 0x02
     70a:	08 95       	ret

0000070c <tinyCCLRGB_uploadColorsToLeds>:
/*
function to write the current LED-array on to the LEDs and
effectively update the values stored in the LEDs to the values stored in the MCU.
*/
void tinyCCLRGB_uploadColorsToLeds(void)
{
     70c:	0f 93       	push	r16
     70e:	1f 93       	push	r17
     710:	cf 93       	push	r28
     712:	df 93       	push	r29
     714:	c3 e2       	ldi	r28, 0x23	; 35
     716:	de e3       	ldi	r29, 0x3E	; 62
     718:	05 e3       	ldi	r16, 0x35	; 53
     71a:	1e e3       	ldi	r17, 0x3E	; 62
	for (uint8_t i = 0; i < TINYCCLRGB_LEDCOUNT; i++)
	{
		//For some reason unknown to the writer the data-bus to the LEDs is serialized as GRB
		//which means the 24-bit data-bus will look like [Green[0:7], Red[0:7], Blue[0:7]]
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].green);
     71c:	89 81       	ldd	r24, Y+1	; 0x01
     71e:	d5 df       	rcall	.-86     	; 0x6ca <tinyCCLRGB_SPIWriteByte>
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].red);
     720:	88 81       	ld	r24, Y
     722:	d3 df       	rcall	.-90     	; 0x6ca <tinyCCLRGB_SPIWriteByte>
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].blue);
     724:	8a 81       	ldd	r24, Y+2	; 0x02
     726:	d1 df       	rcall	.-94     	; 0x6ca <tinyCCLRGB_SPIWriteByte>
     728:	23 96       	adiw	r28, 0x03	; 3
function to write the current LED-array on to the LEDs and
effectively update the values stored in the LEDs to the values stored in the MCU.
*/
void tinyCCLRGB_uploadColorsToLeds(void)
{
	for (uint8_t i = 0; i < TINYCCLRGB_LEDCOUNT; i++)
     72a:	c0 17       	cp	r28, r16
     72c:	d1 07       	cpc	r29, r17
     72e:	b1 f7       	brne	.-20     	; 0x71c <tinyCCLRGB_uploadColorsToLeds+0x10>
		//which means the 24-bit data-bus will look like [Green[0:7], Red[0:7], Blue[0:7]]
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].green);
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].red);
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].blue);
	}
}
     730:	df 91       	pop	r29
     732:	cf 91       	pop	r28
     734:	1f 91       	pop	r17
     736:	0f 91       	pop	r16
     738:	08 95       	ret

0000073a <tinyAxon_remove_pulse>:
/*
solution to remove future firing if a inhibitory signal is received
shortly after a excitatory signal.
*/
bool tinyAxon_remove_pulse(void)
{
     73a:	cf 92       	push	r12
     73c:	df 92       	push	r13
     73e:	ef 92       	push	r14
     740:	ff 92       	push	r15
	// We want to remove the pulse last added to the queue
	// We also want to return a bool indicating whether or not a pulse actually was removed
	uint32_t now = tinyTime_now();
     742:	97 de       	rcall	.-722    	; 0x472 <tinyTime_now>
     744:	6b 01       	movw	r12, r22
     746:	7c 01       	movw	r14, r24
	uint32_t pulse_time = dequeue_top(&pulse_queue);
     748:	86 e3       	ldi	r24, 0x36	; 54
     74a:	9e e3       	ldi	r25, 0x3E	; 62
     74c:	d6 dd       	rcall	.-1108   	; 0x2fa <dequeue_top>
	if(pulse_time == 0){ // Here, 0 is regarded as an error
     74e:	61 15       	cp	r22, r1
     750:	71 05       	cpc	r23, r1
     752:	81 05       	cpc	r24, r1
     754:	91 05       	cpc	r25, r1
     756:	c1 f0       	breq	.+48     	; 0x788 <tinyAxon_remove_pulse+0x4e>
		return false;
	}
	
	// Now we want to check if the pulse is too far away to be affected by the low potential, or close enough that we decide to remove it
	// (When we say that the pulse is too far away, it refers to the biological process of how the potential spreads from Dendrites to axon)
	else if((now + UNDO_PERIOD) < pulse_time){
     758:	2c e3       	ldi	r18, 0x3C	; 60
     75a:	c2 0e       	add	r12, r18
     75c:	d1 1c       	adc	r13, r1
     75e:	e1 1c       	adc	r14, r1
     760:	f1 1c       	adc	r15, r1
     762:	c6 16       	cp	r12, r22
     764:	d7 06       	cpc	r13, r23
     766:	e8 06       	cpc	r14, r24
     768:	f9 06       	cpc	r15, r25
     76a:	38 f4       	brcc	.+14     	; 0x77a <tinyAxon_remove_pulse+0x40>
		// We decided to remove the pulse
		pulses_in_queue--;
     76c:	80 91 38 3e 	lds	r24, 0x3E38	; 0x803e38 <pulses_in_queue>
     770:	81 50       	subi	r24, 0x01	; 1
     772:	80 93 38 3e 	sts	0x3E38, r24	; 0x803e38 <pulses_in_queue>
		return true;
     776:	81 e0       	ldi	r24, 0x01	; 1
     778:	08 c0       	rjmp	.+16     	; 0x78a <tinyAxon_remove_pulse+0x50>
	}
	// Here we have found that there is a pulse queued, but it is old enough to let pass anyway, so now we need to put it back into the queue
	else{
		enqueue(&pulse_queue, pulse_time);
     77a:	ab 01       	movw	r20, r22
     77c:	bc 01       	movw	r22, r24
     77e:	86 e3       	ldi	r24, 0x36	; 54
     780:	9e e3       	ldi	r25, 0x3E	; 62
     782:	5f dd       	rcall	.-1346   	; 0x242 <enqueue>
		return false;
     784:	80 e0       	ldi	r24, 0x00	; 0
     786:	01 c0       	rjmp	.+2      	; 0x78a <tinyAxon_remove_pulse+0x50>
	// We also want to return a bool indicating whether or not a pulse actually was removed
	uint32_t now = tinyTime_now();
	uint32_t pulse_time = dequeue_top(&pulse_queue);
	if(pulse_time == 0){ // Here, 0 is regarded as an error
		//There was no pulse to remove
		return false;
     788:	80 e0       	ldi	r24, 0x00	; 0
	// Here we have found that there is a pulse queued, but it is old enough to let pass anyway, so now we need to put it back into the queue
	else{
		enqueue(&pulse_queue, pulse_time);
		return false;
	}
}
     78a:	ff 90       	pop	r15
     78c:	ef 90       	pop	r14
     78e:	df 90       	pop	r13
     790:	cf 90       	pop	r12
     792:	08 95       	ret

00000794 <tinyAxon_update_potential>:
/*
Decides whether or not the axon should fire
If the axon does fire, the potential is reduced
*/
double tinyAxon_update_potential(double potential)
{
     794:	4f 92       	push	r4
     796:	5f 92       	push	r5
     798:	6f 92       	push	r6
     79a:	7f 92       	push	r7
     79c:	8f 92       	push	r8
     79e:	9f 92       	push	r9
     7a0:	af 92       	push	r10
     7a2:	bf 92       	push	r11
     7a4:	cf 92       	push	r12
     7a6:	df 92       	push	r13
     7a8:	ef 92       	push	r14
     7aa:	ff 92       	push	r15
     7ac:	cf 93       	push	r28
     7ae:	df 93       	push	r29
     7b0:	6b 01       	movw	r12, r22
     7b2:	7c 01       	movw	r14, r24
	int pulse_nr = 0;
	uint32_t now = tinyTime_now();
     7b4:	5e de       	rcall	.-836    	; 0x472 <tinyTime_now>
     7b6:	2b 01       	movw	r4, r22
     7b8:	3c 01       	movw	r6, r24
	
	//While the neuron has enough potential to fire, we want to fire more
	while (potential > THRESHOLD_POTENTIAL)
     7ba:	20 e0       	ldi	r18, 0x00	; 0
     7bc:	30 e0       	ldi	r19, 0x00	; 0
     7be:	48 ec       	ldi	r20, 0xC8	; 200
     7c0:	51 e4       	ldi	r21, 0x41	; 65
     7c2:	c7 01       	movw	r24, r14
     7c4:	b6 01       	movw	r22, r12
     7c6:	09 d4       	rcall	.+2066   	; 0xfda <__gesf2>
     7c8:	18 16       	cp	r1, r24
     7ca:	5c f5       	brge	.+86     	; 0x822 <tinyAxon_update_potential+0x8e>
     7cc:	c0 e0       	ldi	r28, 0x00	; 0
     7ce:	d0 e0       	ldi	r29, 0x00	; 0
/*
Adds an element to the queue
*/
static void tinyAxon_enqueue_pulse(uint32_t new_pulse)
{
	enqueue(&pulse_queue, new_pulse);
     7d0:	53 01       	movw	r10, r6
     7d2:	42 01       	movw	r8, r4
     7d4:	84 e6       	ldi	r24, 0x64	; 100
     7d6:	88 0e       	add	r8, r24
     7d8:	91 1c       	adc	r9, r1
     7da:	a1 1c       	adc	r10, r1
     7dc:	b1 1c       	adc	r11, r1
     7de:	ae 01       	movw	r20, r28
     7e0:	0d 2e       	mov	r0, r29
     7e2:	00 0c       	add	r0, r0
     7e4:	66 0b       	sbc	r22, r22
     7e6:	77 0b       	sbc	r23, r23
     7e8:	48 0d       	add	r20, r8
     7ea:	59 1d       	adc	r21, r9
     7ec:	6a 1d       	adc	r22, r10
     7ee:	7b 1d       	adc	r23, r11
     7f0:	86 e3       	ldi	r24, 0x36	; 54
     7f2:	9e e3       	ldi	r25, 0x3E	; 62
     7f4:	26 dd       	rcall	.-1460   	; 0x242 <enqueue>
	pulses_in_queue++;
     7f6:	80 91 38 3e 	lds	r24, 0x3E38	; 0x803e38 <pulses_in_queue>
     7fa:	8f 5f       	subi	r24, 0xFF	; 255
     7fc:	80 93 38 3e 	sts	0x3E38, r24	; 0x803e38 <pulses_in_queue>
	{
		tinyAxon_enqueue_pulse(now + TRAVLE_DELAY + FIRE_DELAY*pulse_nr);
		pulse_nr++;
		
		// I want to test reducing the potential by -30 instead of -25 to simulate the hyperpolarization
		potential += POSTFIRE_POTENTIAL_REACTION; // This is usually defined as a negative value, don't be confused by the +=
     800:	20 e0       	ldi	r18, 0x00	; 0
     802:	30 e0       	ldi	r19, 0x00	; 0
     804:	40 ef       	ldi	r20, 0xF0	; 240
     806:	51 e4       	ldi	r21, 0x41	; 65
     808:	c7 01       	movw	r24, r14
     80a:	b6 01       	movw	r22, r12
     80c:	b9 d1       	rcall	.+882    	; 0xb80 <__subsf3>
     80e:	6b 01       	movw	r12, r22
     810:	7c 01       	movw	r14, r24
     812:	e2 96       	adiw	r28, 0x32	; 50
{
	int pulse_nr = 0;
	uint32_t now = tinyTime_now();
	
	//While the neuron has enough potential to fire, we want to fire more
	while (potential > THRESHOLD_POTENTIAL)
     814:	20 e0       	ldi	r18, 0x00	; 0
     816:	30 e0       	ldi	r19, 0x00	; 0
     818:	48 ec       	ldi	r20, 0xC8	; 200
     81a:	51 e4       	ldi	r21, 0x41	; 65
     81c:	de d3       	rcall	.+1980   	; 0xfda <__gesf2>
     81e:	18 16       	cp	r1, r24
     820:	f4 f2       	brlt	.-68     	; 0x7de <tinyAxon_update_potential+0x4a>
		// I want to test reducing the potential by -30 instead of -25 to simulate the hyperpolarization
		potential += POSTFIRE_POTENTIAL_REACTION; // This is usually defined as a negative value, don't be confused by the +=
	}
	
	// If the neuron has a very low potential, we want to remove a pulse from the queue (if there is one)
	if(potential < -THRESHOLD_POTENTIAL && pulses_in_queue > 0) // Perhaps this should be a separate variable? For now, we will just simply use -THRESHOLD_POTENTIAL
     822:	20 e0       	ldi	r18, 0x00	; 0
     824:	30 e0       	ldi	r19, 0x00	; 0
     826:	48 ec       	ldi	r20, 0xC8	; 200
     828:	51 ec       	ldi	r21, 0xC1	; 193
     82a:	c7 01       	movw	r24, r14
     82c:	b6 01       	movw	r22, r12
     82e:	15 d2       	rcall	.+1066   	; 0xc5a <__cmpsf2>
     830:	88 23       	and	r24, r24
     832:	84 f4       	brge	.+32     	; 0x854 <tinyAxon_update_potential+0xc0>
     834:	80 91 38 3e 	lds	r24, 0x3E38	; 0x803e38 <pulses_in_queue>
     838:	88 23       	and	r24, r24
     83a:	79 f1       	breq	.+94     	; 0x89a <tinyAxon_update_potential+0x106>
	{
		// The neurons potential is low enough to attempt to remove a queued fire (Fire less)
		if(tinyAxon_remove_pulse())
     83c:	7e df       	rcall	.-260    	; 0x73a <tinyAxon_remove_pulse>
     83e:	88 23       	and	r24, r24
     840:	49 f0       	breq	.+18     	; 0x854 <tinyAxon_update_potential+0xc0>
		{
			// The potential has evened out a bit
			potential += THRESHOLD_POTENTIAL;
     842:	20 e0       	ldi	r18, 0x00	; 0
     844:	30 e0       	ldi	r19, 0x00	; 0
     846:	48 ec       	ldi	r20, 0xC8	; 200
     848:	51 e4       	ldi	r21, 0x41	; 65
     84a:	c7 01       	movw	r24, r14
     84c:	b6 01       	movw	r22, r12
     84e:	99 d1       	rcall	.+818    	; 0xb82 <__addsf3>
     850:	6b 01       	movw	r12, r22
     852:	7c 01       	movw	r14, r24
		}
	}
	
	// If there are pulses in the queue, and the pulse has been scheduled to fire
	if ((pulses_in_queue > 0) && (next_pulse <= now))
     854:	80 91 38 3e 	lds	r24, 0x3E38	; 0x803e38 <pulses_in_queue>
     858:	88 23       	and	r24, r24
     85a:	f9 f0       	breq	.+62     	; 0x89a <tinyAxon_update_potential+0x106>
     85c:	40 91 55 3e 	lds	r20, 0x3E55	; 0x803e55 <next_pulse>
     860:	50 91 56 3e 	lds	r21, 0x3E56	; 0x803e56 <next_pulse+0x1>
     864:	60 91 57 3e 	lds	r22, 0x3E57	; 0x803e57 <next_pulse+0x2>
     868:	70 91 58 3e 	lds	r23, 0x3E58	; 0x803e58 <next_pulse+0x3>
     86c:	44 16       	cp	r4, r20
     86e:	55 06       	cpc	r5, r21
     870:	66 06       	cpc	r6, r22
     872:	77 06       	cpc	r7, r23
     874:	90 f0       	brcs	.+36     	; 0x89a <tinyAxon_update_potential+0x106>
Function to set firing.
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
     876:	91 e0       	ldi	r25, 0x01	; 1
     878:	90 93 39 3e 	sts	0x3E39, r25	; 0x803e39 <tinyAxon_should_fire>
	pulses_in_queue--;
     87c:	81 50       	subi	r24, 0x01	; 1
     87e:	80 93 38 3e 	sts	0x3E38, r24	; 0x803e38 <pulses_in_queue>
	next_pulse = dequeue(&pulse_queue);
     882:	86 e3       	ldi	r24, 0x36	; 54
     884:	9e e3       	ldi	r25, 0x3E	; 62
     886:	fd dc       	rcall	.-1542   	; 0x282 <dequeue>
     888:	60 93 55 3e 	sts	0x3E55, r22	; 0x803e55 <next_pulse>
     88c:	70 93 56 3e 	sts	0x3E56, r23	; 0x803e56 <next_pulse+0x1>
     890:	80 93 57 3e 	sts	0x3E57, r24	; 0x803e57 <next_pulse+0x2>
     894:	90 93 58 3e 	sts	0x3E58, r25	; 0x803e58 <next_pulse+0x3>
	// If there are pulses in the queue, and the pulse has been scheduled to fire
	if ((pulses_in_queue > 0) && (next_pulse <= now))
	{
		// We fire the axon
		tinyAxon_fire_pulse();
		set_LED_fire();
     898:	21 de       	rcall	.-958    	; 0x4dc <set_LED_fire>
The function should set the DAC to fire for two
update cycles once the pulse flag is set high.
*/
static void tinyAxon_update_pulse_transmitter(void)
{
	if (tinyAxon_should_fire)
     89a:	80 91 39 3e 	lds	r24, 0x3E39	; 0x803e39 <tinyAxon_should_fire>
     89e:	88 23       	and	r24, r24
     8a0:	61 f0       	breq	.+24     	; 0x8ba <tinyAxon_update_potential+0x126>
	{
		tinyAxon_should_fire = false;
     8a2:	10 92 39 3e 	sts	0x3E39, r1	; 0x803e39 <tinyAxon_should_fire>
		tinyAxon_has_fired = true;
     8a6:	81 e0       	ldi	r24, 0x01	; 1
     8a8:	80 93 3a 3e 	sts	0x3E3A, r24	; 0x803e3a <tinyAxon_has_fired>
*/
static void tinyAxon_start_sending_pulse()
{
	if (NEURONTYPE == EXCITATORY_NEURON)
	{
		DAC_set_output(EXCITATORY_NEURON_OUTPUT);
     8ac:	87 ed       	ldi	r24, 0xD7	; 215
     8ae:	90 e0       	ldi	r25, 0x00	; 0
     8b0:	31 dc       	rcall	.-1950   	; 0x114 <DAC_set_output>
		axonOutputValue=EXCITATORY_NEURON_OUTPUT;
     8b2:	87 ed       	ldi	r24, 0xD7	; 215
     8b4:	80 93 35 3e 	sts	0x3E35, r24	; 0x803e35 <axonOutputValue>
     8b8:	0c c0       	rjmp	.+24     	; 0x8d2 <tinyAxon_update_potential+0x13e>
		tinyAxon_should_fire = false;
		tinyAxon_has_fired = true;
		
		tinyAxon_start_sending_pulse();
	}
	else if (tinyAxon_has_fired)
     8ba:	80 91 3a 3e 	lds	r24, 0x3E3A	; 0x803e3a <tinyAxon_has_fired>
     8be:	88 23       	and	r24, r24
     8c0:	19 f0       	breq	.+6      	; 0x8c8 <tinyAxon_update_potential+0x134>
	{
		tinyAxon_has_fired = false;
     8c2:	10 92 3a 3e 	sts	0x3E3A, r1	; 0x803e3a <tinyAxon_has_fired>
     8c6:	05 c0       	rjmp	.+10     	; 0x8d2 <tinyAxon_update_potential+0x13e>
}

static void tinyAxon_stop_sending_pulse()
{
	
	DAC_set_output(NO_SIGNAL_OUTPUT);
     8c8:	80 e0       	ldi	r24, 0x00	; 0
     8ca:	90 e0       	ldi	r25, 0x00	; 0
     8cc:	23 dc       	rcall	.-1978   	; 0x114 <DAC_set_output>
	axonOutputValue=NO_SIGNAL_OUTPUT;
     8ce:	10 92 35 3e 	sts	0x3E35, r1	; 0x803e35 <axonOutputValue>
	}
	
	// Here we set the actual output of the DAC (Digital to Analog Converter)
	tinyAxon_update_pulse_transmitter();
	return potential;
}
     8d2:	c7 01       	movw	r24, r14
     8d4:	b6 01       	movw	r22, r12
     8d6:	df 91       	pop	r29
     8d8:	cf 91       	pop	r28
     8da:	ff 90       	pop	r15
     8dc:	ef 90       	pop	r14
     8de:	df 90       	pop	r13
     8e0:	cf 90       	pop	r12
     8e2:	bf 90       	pop	r11
     8e4:	af 90       	pop	r10
     8e6:	9f 90       	pop	r9
     8e8:	8f 90       	pop	r8
     8ea:	7f 90       	pop	r7
     8ec:	6f 90       	pop	r6
     8ee:	5f 90       	pop	r5
     8f0:	4f 90       	pop	r4
     8f2:	08 95       	ret

000008f4 <tinyDendrite_update_signals>:
/*
This function converts the 8 bit value from the ADC into one of the signal types defined in DendriteSignal
We also update the charging state
*/
void tinyDendrite_update_signals(void)
{
     8f4:	2f 92       	push	r2
     8f6:	3f 92       	push	r3
     8f8:	4f 92       	push	r4
     8fa:	5f 92       	push	r5
     8fc:	6f 92       	push	r6
     8fe:	7f 92       	push	r7
     900:	8f 92       	push	r8
     902:	9f 92       	push	r9
     904:	af 92       	push	r10
     906:	bf 92       	push	r11
     908:	cf 92       	push	r12
     90a:	df 92       	push	r13
     90c:	ef 92       	push	r14
     90e:	ff 92       	push	r15
     910:	0f 93       	push	r16
     912:	1f 93       	push	r17
     914:	cf 93       	push	r28
     916:	df 93       	push	r29
     918:	08 e0       	ldi	r16, 0x08	; 8
     91a:	1e e3       	ldi	r17, 0x3E	; 62
     91c:	0f 2e       	mov	r0, r31
     91e:	f5 e4       	ldi	r31, 0x45	; 69
     920:	cf 2e       	mov	r12, r31
     922:	fe e3       	ldi	r31, 0x3E	; 62
     924:	df 2e       	mov	r13, r31
     926:	f0 2d       	mov	r31, r0
     928:	0f 2e       	mov	r0, r31
     92a:	ff e4       	ldi	r31, 0x4F	; 79
     92c:	ef 2e       	mov	r14, r31
     92e:	fe e3       	ldi	r31, 0x3E	; 62
     930:	ff 2e       	mov	r15, r31
     932:	f0 2d       	mov	r31, r0
     934:	e6 01       	movw	r28, r12
*/
static void tinyDendrite_read_signals(void)
{
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_values[i] = ADC_get_conversion(Dendrite_ports[i]);
     936:	f8 01       	movw	r30, r16
     938:	81 91       	ld	r24, Z+
     93a:	8f 01       	movw	r16, r30
     93c:	b6 db       	rcall	.-2196   	; 0xaa <ADC_get_conversion>
     93e:	89 93       	st	Y+, r24
     940:	99 93       	st	Y+, r25
/*
This function reads the voltage at the Dendrite inputs with the ADC
*/
static void tinyDendrite_read_signals(void)
{
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
     942:	ce 15       	cp	r28, r14
     944:	df 05       	cpc	r29, r15
     946:	b9 f7       	brne	.-18     	; 0x936 <tinyDendrite_update_signals+0x42>
{
	
	//Read the analog voltage values on each of the Dendrites
	tinyDendrite_read_signals();
	
	tinyCharge_set_charging(false);
     948:	80 e0       	ldi	r24, 0x00	; 0
     94a:	38 dd       	rcall	.-1424   	; 0x3bc <tinyCharge_set_charging>
     94c:	c0 e4       	ldi	r28, 0x40	; 64
     94e:	de e3       	ldi	r29, 0x3E	; 62
     950:	0b e3       	ldi	r16, 0x3B	; 59
     952:	1e e3       	ldi	r17, 0x3E	; 62
     954:	0f 2e       	mov	r0, r31
     956:	f5 e4       	ldi	r31, 0x45	; 69
     958:	8f 2e       	mov	r8, r31
     95a:	fe e3       	ldi	r31, 0x3E	; 62
     95c:	9f 2e       	mov	r9, r31
     95e:	f0 2d       	mov	r31, r0
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     960:	66 24       	eor	r6, r6
     962:	63 94       	inc	r6
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     964:	68 94       	set
     966:	22 24       	eor	r2, r2
     968:	21 f8       	bld	r2, 1
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     96a:	68 94       	set
     96c:	33 24       	eor	r3, r3
     96e:	32 f8       	bld	r3, 2
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     970:	0f 2e       	mov	r0, r31
     972:	f6 e0       	ldi	r31, 0x06	; 6
     974:	4f 2e       	mov	r4, r31
     976:	f0 2d       	mov	r31, r0
			tinyDendrite_current_signals[i] = CHARGING;
			tinyCharge_set_charging(true);
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     978:	0f 2e       	mov	r0, r31
     97a:	f5 e0       	ldi	r31, 0x05	; 5
     97c:	7f 2e       	mov	r7, r31
     97e:	f0 2d       	mov	r31, r0
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = CHARGING;
     980:	0f 2e       	mov	r0, r31
     982:	f7 e0       	ldi	r31, 0x07	; 7
     984:	5f 2e       	mov	r5, r31
     986:	f0 2d       	mov	r31, r0
     988:	7e 01       	movw	r14, r28
     98a:	58 01       	movw	r10, r16
	
	tinyCharge_set_charging(false);
	
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
     98c:	88 81       	ld	r24, Y
     98e:	f8 01       	movw	r30, r16
     990:	80 83       	st	Z, r24
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
     992:	f6 01       	movw	r30, r12
     994:	81 91       	ld	r24, Z+
     996:	91 91       	ld	r25, Z+
     998:	6f 01       	movw	r12, r30
     99a:	89 3e       	cpi	r24, 0xE9	; 233
     99c:	91 05       	cpc	r25, r1
     99e:	20 f0       	brcs	.+8      	; 0x9a8 <tinyDendrite_update_signals+0xb4>
		{
			tinyDendrite_current_signals[i] = CHARGING;
     9a0:	58 82       	st	Y, r5
			tinyCharge_set_charging(true);
     9a2:	86 2d       	mov	r24, r6
     9a4:	0b dd       	rcall	.-1514   	; 0x3bc <tinyCharge_set_charging>
     9a6:	1f c0       	rjmp	.+62     	; 0x9e6 <tinyDendrite_update_signals+0xf2>
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
     9a8:	88 3c       	cpi	r24, 0xC8	; 200
     9aa:	91 05       	cpc	r25, r1
     9ac:	10 f0       	brcs	.+4      	; 0x9b2 <tinyDendrite_update_signals+0xbe>
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     9ae:	78 82       	st	Y, r7
     9b0:	1a c0       	rjmp	.+52     	; 0x9e6 <tinyDendrite_update_signals+0xf2>
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
     9b2:	87 3a       	cpi	r24, 0xA7	; 167
     9b4:	91 05       	cpc	r25, r1
     9b6:	10 f0       	brcs	.+4      	; 0x9bc <tinyDendrite_update_signals+0xc8>
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     9b8:	48 82       	st	Y, r4
     9ba:	15 c0       	rjmp	.+42     	; 0x9e6 <tinyDendrite_update_signals+0xf2>
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
     9bc:	85 38       	cpi	r24, 0x85	; 133
     9be:	91 05       	cpc	r25, r1
     9c0:	10 f0       	brcs	.+4      	; 0x9c6 <tinyDendrite_update_signals+0xd2>
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     9c2:	38 82       	st	Y, r3
     9c4:	10 c0       	rjmp	.+32     	; 0x9e6 <tinyDendrite_update_signals+0xf2>
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
     9c6:	84 36       	cpi	r24, 0x64	; 100
     9c8:	91 05       	cpc	r25, r1
     9ca:	10 f0       	brcs	.+4      	; 0x9d0 <tinyDendrite_update_signals+0xdc>
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     9cc:	28 82       	st	Y, r2
     9ce:	0b c0       	rjmp	.+22     	; 0x9e6 <tinyDendrite_update_signals+0xf2>
		}
		else if (tinyDendrite_values[i] > HIGH_INHIB_THRESHOLD)
     9d0:	83 34       	cpi	r24, 0x43	; 67
     9d2:	91 05       	cpc	r25, r1
     9d4:	18 f0       	brcs	.+6      	; 0x9dc <tinyDendrite_update_signals+0xe8>
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
     9d6:	83 e0       	ldi	r24, 0x03	; 3
     9d8:	88 83       	st	Y, r24
     9da:	05 c0       	rjmp	.+10     	; 0x9e6 <tinyDendrite_update_signals+0xf2>
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
     9dc:	82 97       	sbiw	r24, 0x22	; 34
     9de:	10 f0       	brcs	.+4      	; 0x9e4 <tinyDendrite_update_signals+0xf0>
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     9e0:	68 82       	st	Y, r6
     9e2:	01 c0       	rjmp	.+2      	; 0x9e6 <tinyDendrite_update_signals+0xf2>
		}
		else
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     9e4:	18 82       	st	Y, r1
     9e6:	0f 5f       	subi	r16, 0xFF	; 255
     9e8:	1f 4f       	sbci	r17, 0xFF	; 255
		}
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
     9ea:	f7 01       	movw	r30, r14
     9ec:	90 81       	ld	r25, Z
     9ee:	f5 01       	movw	r30, r10
     9f0:	80 81       	ld	r24, Z
     9f2:	98 13       	cpse	r25, r24
     9f4:	02 c0       	rjmp	.+4      	; 0x9fa <tinyDendrite_update_signals+0x106>
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     9f6:	f7 01       	movw	r30, r14
     9f8:	10 82       	st	Z, r1
     9fa:	21 96       	adiw	r28, 0x01	; 1
	//Read the analog voltage values on each of the Dendrites
	tinyDendrite_read_signals();
	
	tinyCharge_set_charging(false);
	
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
     9fc:	c8 15       	cp	r28, r8
     9fe:	d9 05       	cpc	r29, r9
     a00:	19 f6       	brne	.-122    	; 0x988 <tinyDendrite_update_signals+0x94>
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
		}
	}
}
     a02:	df 91       	pop	r29
     a04:	cf 91       	pop	r28
     a06:	1f 91       	pop	r17
     a08:	0f 91       	pop	r16
     a0a:	ff 90       	pop	r15
     a0c:	ef 90       	pop	r14
     a0e:	df 90       	pop	r13
     a10:	cf 90       	pop	r12
     a12:	bf 90       	pop	r11
     a14:	af 90       	pop	r10
     a16:	9f 90       	pop	r9
     a18:	8f 90       	pop	r8
     a1a:	7f 90       	pop	r7
     a1c:	6f 90       	pop	r6
     a1e:	5f 90       	pop	r5
     a20:	4f 90       	pop	r4
     a22:	3f 90       	pop	r3
     a24:	2f 90       	pop	r2
     a26:	08 95       	ret

00000a28 <tinyDendrite_get_potential>:
outside. It uses the previously declared functions to return the potential.
*/
int16_t tinyDendrite_get_potential()
{
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
     a28:	65 df       	rcall	.-310    	; 0x8f4 <tinyDendrite_update_signals>
     a2a:	e0 e4       	ldi	r30, 0x40	; 64
     a2c:	fe e3       	ldi	r31, 0x3E	; 62
     a2e:	45 e4       	ldi	r20, 0x45	; 69
     a30:	5e e3       	ldi	r21, 0x3E	; 62
	
	int16_t return_potential_val = 0;
     a32:	20 e0       	ldi	r18, 0x00	; 0
     a34:	30 e0       	ldi	r19, 0x00	; 0
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		switch(tinyDendrite_current_signals[i])
     a36:	91 91       	ld	r25, Z+
     a38:	93 30       	cpi	r25, 0x03	; 3
     a3a:	a1 f0       	breq	.+40     	; 0xa64 <tinyDendrite_get_potential+0x3c>
     a3c:	28 f4       	brcc	.+10     	; 0xa48 <tinyDendrite_get_potential+0x20>
     a3e:	91 30       	cpi	r25, 0x01	; 1
     a40:	b9 f0       	breq	.+46     	; 0xa70 <tinyDendrite_get_potential+0x48>
     a42:	92 30       	cpi	r25, 0x02	; 2
     a44:	91 f0       	breq	.+36     	; 0xa6a <tinyDendrite_get_potential+0x42>
     a46:	16 c0       	rjmp	.+44     	; 0xa74 <tinyDendrite_get_potential+0x4c>
     a48:	95 30       	cpi	r25, 0x05	; 5
     a4a:	31 f0       	breq	.+12     	; 0xa58 <tinyDendrite_get_potential+0x30>
     a4c:	40 f0       	brcs	.+16     	; 0xa5e <tinyDendrite_get_potential+0x36>
     a4e:	96 30       	cpi	r25, 0x06	; 6
     a50:	89 f4       	brne	.+34     	; 0xa74 <tinyDendrite_get_potential+0x4c>
		{
			case NO_SIGNAL:
				return_potential_val += NO_SIGNAL_REACTION;
				break;
			case HIGH_EXCITE:
				return_potential_val += HIGH_EXCITE_REACTION;
     a52:	2c 5c       	subi	r18, 0xCC	; 204
     a54:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     a56:	0e c0       	rjmp	.+28     	; 0xa74 <tinyDendrite_get_potential+0x4c>
			case NORMAL_EXCITE:
				return_potential_val += NORMAL_EXCITE_REACTION;
     a58:	26 5e       	subi	r18, 0xE6	; 230
     a5a:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     a5c:	0b c0       	rjmp	.+22     	; 0xa74 <tinyDendrite_get_potential+0x4c>
			case LOW_EXCITE:
				return_potential_val += LOW_EXCITE_REACTION;
     a5e:	2c 5e       	subi	r18, 0xEC	; 236
     a60:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     a62:	08 c0       	rjmp	.+16     	; 0xa74 <tinyDendrite_get_potential+0x4c>
			case HIGH_INHIB:
				return_potential_val += HIGH_INHIB_REACTION;
     a64:	22 53       	subi	r18, 0x32	; 50
     a66:	31 09       	sbc	r19, r1
				break;
     a68:	05 c0       	rjmp	.+10     	; 0xa74 <tinyDendrite_get_potential+0x4c>
			case NORMAL_INHIB:
				return_potential_val += NORMAL_INHIB_REACTION;
     a6a:	2a 51       	subi	r18, 0x1A	; 26
     a6c:	31 09       	sbc	r19, r1
				break;
     a6e:	02 c0       	rjmp	.+4      	; 0xa74 <tinyDendrite_get_potential+0x4c>
			case LOW_INHIB:
				return_potential_val += LOW_INHIB_REACTION;
     a70:	24 51       	subi	r18, 0x14	; 20
     a72:	31 09       	sbc	r19, r1
{
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
	
	int16_t return_potential_val = 0;
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
     a74:	e4 17       	cp	r30, r20
     a76:	f5 07       	cpc	r31, r21
     a78:	f1 f6       	brne	.-68     	; 0xa36 <tinyDendrite_get_potential+0xe>
			default:
				break;
		}
	}
	return return_potential_val;
}
     a7a:	c9 01       	movw	r24, r18
     a7c:	08 95       	ret

00000a7e <tinyDendrite_update_potential>:

double tinyDendrite_update_potential(double potential){
     a7e:	cf 92       	push	r12
     a80:	df 92       	push	r13
     a82:	ef 92       	push	r14
     a84:	ff 92       	push	r15
     a86:	6b 01       	movw	r12, r22
     a88:	7c 01       	movw	r14, r24
	
	uint16_t potential_change = tinyDendrite_get_potential();
     a8a:	ce df       	rcall	.-100    	; 0xa28 <tinyDendrite_get_potential>
	potential += potential_change;
	return potential;
     a8c:	bc 01       	movw	r22, r24
     a8e:	80 e0       	ldi	r24, 0x00	; 0
     a90:	90 e0       	ldi	r25, 0x00	; 0
     a92:	ca d1       	rcall	.+916    	; 0xe28 <__floatunsisf>
     a94:	a7 01       	movw	r20, r14
     a96:	96 01       	movw	r18, r12
     a98:	74 d0       	rcall	.+232    	; 0xb82 <__addsf3>
     a9a:	ff 90       	pop	r15
     a9c:	ef 90       	pop	r14
     a9e:	df 90       	pop	r13
     aa0:	cf 90       	pop	r12
     aa2:	08 95       	ret

00000aa4 <__vector_6>:
This function is called every time the RTC (Real Time Clock) counter overflows.
With the current settings, it will be called every ms.
The RTC clock runs at 1kHz, and the number of cycles before overflow is set with RTC.PER = someHexValue (e.g. 0x20) in src/rtc.c
*/
ISR(RTC_CNT_vect)
{
     aa4:	1f 92       	push	r1
     aa6:	0f 92       	push	r0
     aa8:	0f b6       	in	r0, 0x3f	; 63
     aaa:	0f 92       	push	r0
     aac:	11 24       	eor	r1, r1
     aae:	2f 93       	push	r18
     ab0:	3f 93       	push	r19
     ab2:	4f 93       	push	r20
     ab4:	5f 93       	push	r21
     ab6:	6f 93       	push	r22
     ab8:	7f 93       	push	r23
     aba:	8f 93       	push	r24
     abc:	9f 93       	push	r25
     abe:	af 93       	push	r26
     ac0:	bf 93       	push	r27
     ac2:	cf 93       	push	r28
     ac4:	ef 93       	push	r30
     ac6:	ff 93       	push	r31
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     ac8:	c1 e0       	ldi	r28, 0x01	; 1
     aca:	c0 93 4f 3e 	sts	0x3E4F, r28	; 0x803e4f <tinyISR_interrupt_flag>
{
	// Set flag to let main loop run a new cycle
	tinyISR_setflag(true);
	
	// Timer counter incrementation
	tinyTime_counter_increment();
     ace:	bd dc       	rcall	.-1670   	; 0x44a <tinyTime_counter_increment>

	/* Overflow interrupt flag has to be cleared manually */
	RTC.INTFLAGS = RTC_OVF_bm;
     ad0:	c0 93 43 01 	sts	0x0143, r28	; 0x800143 <__TEXT_REGION_LENGTH__+0x700143>
}
     ad4:	ff 91       	pop	r31
     ad6:	ef 91       	pop	r30
     ad8:	cf 91       	pop	r28
     ada:	bf 91       	pop	r27
     adc:	af 91       	pop	r26
     ade:	9f 91       	pop	r25
     ae0:	8f 91       	pop	r24
     ae2:	7f 91       	pop	r23
     ae4:	6f 91       	pop	r22
     ae6:	5f 91       	pop	r21
     ae8:	4f 91       	pop	r20
     aea:	3f 91       	pop	r19
     aec:	2f 91       	pop	r18
     aee:	0f 90       	pop	r0
     af0:	0f be       	out	0x3f, r0	; 63
     af2:	0f 90       	pop	r0
     af4:	1f 90       	pop	r1
     af6:	18 95       	reti

00000af8 <tinyISR_setflag>:
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     af8:	80 93 4f 3e 	sts	0x3E4F, r24	; 0x803e4f <tinyISR_interrupt_flag>
     afc:	08 95       	ret

00000afe <tinyISR_getflag>:
}

_Bool tinyISR_getflag(void)
{
	return tinyISR_interrupt_flag;
}
     afe:	80 91 4f 3e 	lds	r24, 0x3E4F	; 0x803e4f <tinyISR_interrupt_flag>
     b02:	08 95       	ret

00000b04 <tinyPotential_update>:
/*
Function to decay the potential towards 0
*/
static void tinyPotential_decay(double time_since_last_update)
{
	tinyPotential_potential *= (exp(-(time_since_last_update/TINYPOTENTIAL_TIME_CONST)));
     b04:	20 e0       	ldi	r18, 0x00	; 0
     b06:	30 e0       	ldi	r19, 0x00	; 0
     b08:	48 ec       	ldi	r20, 0xC8	; 200
     b0a:	52 e4       	ldi	r21, 0x42	; 66
     b0c:	ab d0       	rcall	.+342    	; 0xc64 <__divsf3>
     b0e:	90 58       	subi	r25, 0x80	; 128
     b10:	23 d1       	rcall	.+582    	; 0xd58 <exp>
     b12:	20 91 50 3e 	lds	r18, 0x3E50	; 0x803e50 <tinyPotential_potential>
     b16:	30 91 51 3e 	lds	r19, 0x3E51	; 0x803e51 <tinyPotential_potential+0x1>
     b1a:	40 91 52 3e 	lds	r20, 0x3E52	; 0x803e52 <tinyPotential_potential+0x2>
     b1e:	50 91 53 3e 	lds	r21, 0x3E53	; 0x803e53 <tinyPotential_potential+0x3>
     b22:	d6 d2       	rcall	.+1452   	; 0x10d0 <__mulsf3>
     b24:	60 93 50 3e 	sts	0x3E50, r22	; 0x803e50 <tinyPotential_potential>
     b28:	70 93 51 3e 	sts	0x3E51, r23	; 0x803e51 <tinyPotential_potential+0x1>
     b2c:	80 93 52 3e 	sts	0x3E52, r24	; 0x803e52 <tinyPotential_potential+0x2>
     b30:	90 93 53 3e 	sts	0x3E53, r25	; 0x803e53 <tinyPotential_potential+0x3>
{
	//Some of the potential in the neuron has decayed away
	tinyPotential_decay(time_since_last_update);
	
	// Update potential with values from Dendrites
	tinyPotential_potential = tinyDendrite_update_potential(tinyPotential_potential);
     b34:	a4 df       	rcall	.-184    	; 0xa7e <tinyDendrite_update_potential>
     b36:	60 93 50 3e 	sts	0x3E50, r22	; 0x803e50 <tinyPotential_potential>
     b3a:	70 93 51 3e 	sts	0x3E51, r23	; 0x803e51 <tinyPotential_potential+0x1>
     b3e:	80 93 52 3e 	sts	0x3E52, r24	; 0x803e52 <tinyPotential_potential+0x2>
     b42:	90 93 53 3e 	sts	0x3E53, r25	; 0x803e53 <tinyPotential_potential+0x3>
	
	// Update potential from button press
	tinyPotential_potential = tinyButton_update_potential(tinyPotential_potential);
     b46:	b7 dd       	rcall	.-1170   	; 0x6b6 <tinyButton_update_potential>
     b48:	60 93 50 3e 	sts	0x3E50, r22	; 0x803e50 <tinyPotential_potential>
     b4c:	70 93 51 3e 	sts	0x3E51, r23	; 0x803e51 <tinyPotential_potential+0x1>
     b50:	80 93 52 3e 	sts	0x3E52, r24	; 0x803e52 <tinyPotential_potential+0x2>
     b54:	90 93 53 3e 	sts	0x3E53, r25	; 0x803e53 <tinyPotential_potential+0x3>
	
	// Update potential with values from spontaneous pulse.
	tinyPotential_potential = tinyPulse_update_potential(tinyPotential_potential);
     b58:	43 dc       	rcall	.-1914   	; 0x3e0 <tinyPulse_update_potential>
     b5a:	60 93 50 3e 	sts	0x3E50, r22	; 0x803e50 <tinyPotential_potential>
     b5e:	70 93 51 3e 	sts	0x3E51, r23	; 0x803e51 <tinyPotential_potential+0x1>
     b62:	80 93 52 3e 	sts	0x3E52, r24	; 0x803e52 <tinyPotential_potential+0x2>
     b66:	90 93 53 3e 	sts	0x3E53, r25	; 0x803e53 <tinyPotential_potential+0x3>
	
	// Let the axon affect the potential
	// This is also where we decide whether or not the axon should fire
	tinyPotential_potential = tinyAxon_update_potential(tinyPotential_potential);
     b6a:	14 de       	rcall	.-984    	; 0x794 <tinyAxon_update_potential>
     b6c:	60 93 50 3e 	sts	0x3E50, r22	; 0x803e50 <tinyPotential_potential>
     b70:	70 93 51 3e 	sts	0x3E51, r23	; 0x803e51 <tinyPotential_potential+0x1>
     b74:	80 93 52 3e 	sts	0x3E52, r24	; 0x803e52 <tinyPotential_potential+0x2>
     b78:	90 93 53 3e 	sts	0x3E53, r25	; 0x803e53 <tinyPotential_potential+0x3>

	//Update the led
	potential_to_RGB_update_LEDs(tinyPotential_potential);
     b7c:	c4 dc       	rcall	.-1656   	; 0x506 <potential_to_RGB_update_LEDs>
     b7e:	08 95       	ret

00000b80 <__subsf3>:
     b80:	50 58       	subi	r21, 0x80	; 128

00000b82 <__addsf3>:
     b82:	bb 27       	eor	r27, r27
     b84:	aa 27       	eor	r26, r26
     b86:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <__addsf3x>
     b8a:	0c 94 b3 07 	jmp	0xf66	; 0xf66 <__fp_round>
     b8e:	0e 94 a5 07 	call	0xf4a	; 0xf4a <__fp_pscA>
     b92:	38 f0       	brcs	.+14     	; 0xba2 <__addsf3+0x20>
     b94:	0e 94 ac 07 	call	0xf58	; 0xf58 <__fp_pscB>
     b98:	20 f0       	brcs	.+8      	; 0xba2 <__addsf3+0x20>
     b9a:	39 f4       	brne	.+14     	; 0xbaa <__addsf3+0x28>
     b9c:	9f 3f       	cpi	r25, 0xFF	; 255
     b9e:	19 f4       	brne	.+6      	; 0xba6 <__addsf3+0x24>
     ba0:	26 f4       	brtc	.+8      	; 0xbaa <__addsf3+0x28>
     ba2:	0c 94 7b 07 	jmp	0xef6	; 0xef6 <__fp_nan>
     ba6:	0e f4       	brtc	.+2      	; 0xbaa <__addsf3+0x28>
     ba8:	e0 95       	com	r30
     baa:	e7 fb       	bst	r30, 7
     bac:	0c 94 75 07 	jmp	0xeea	; 0xeea <__fp_inf>

00000bb0 <__addsf3x>:
     bb0:	e9 2f       	mov	r30, r25
     bb2:	0e 94 c4 07 	call	0xf88	; 0xf88 <__fp_split3>
     bb6:	58 f3       	brcs	.-42     	; 0xb8e <__addsf3+0xc>
     bb8:	ba 17       	cp	r27, r26
     bba:	62 07       	cpc	r22, r18
     bbc:	73 07       	cpc	r23, r19
     bbe:	84 07       	cpc	r24, r20
     bc0:	95 07       	cpc	r25, r21
     bc2:	20 f0       	brcs	.+8      	; 0xbcc <__addsf3x+0x1c>
     bc4:	79 f4       	brne	.+30     	; 0xbe4 <__addsf3x+0x34>
     bc6:	a6 f5       	brtc	.+104    	; 0xc30 <__addsf3x+0x80>
     bc8:	0c 94 e6 07 	jmp	0xfcc	; 0xfcc <__fp_zero>
     bcc:	0e f4       	brtc	.+2      	; 0xbd0 <__addsf3x+0x20>
     bce:	e0 95       	com	r30
     bd0:	0b 2e       	mov	r0, r27
     bd2:	ba 2f       	mov	r27, r26
     bd4:	a0 2d       	mov	r26, r0
     bd6:	0b 01       	movw	r0, r22
     bd8:	b9 01       	movw	r22, r18
     bda:	90 01       	movw	r18, r0
     bdc:	0c 01       	movw	r0, r24
     bde:	ca 01       	movw	r24, r20
     be0:	a0 01       	movw	r20, r0
     be2:	11 24       	eor	r1, r1
     be4:	ff 27       	eor	r31, r31
     be6:	59 1b       	sub	r21, r25
     be8:	99 f0       	breq	.+38     	; 0xc10 <__addsf3x+0x60>
     bea:	59 3f       	cpi	r21, 0xF9	; 249
     bec:	50 f4       	brcc	.+20     	; 0xc02 <__addsf3x+0x52>
     bee:	50 3e       	cpi	r21, 0xE0	; 224
     bf0:	68 f1       	brcs	.+90     	; 0xc4c <__addsf3x+0x9c>
     bf2:	1a 16       	cp	r1, r26
     bf4:	f0 40       	sbci	r31, 0x00	; 0
     bf6:	a2 2f       	mov	r26, r18
     bf8:	23 2f       	mov	r18, r19
     bfa:	34 2f       	mov	r19, r20
     bfc:	44 27       	eor	r20, r20
     bfe:	58 5f       	subi	r21, 0xF8	; 248
     c00:	f3 cf       	rjmp	.-26     	; 0xbe8 <__addsf3x+0x38>
     c02:	46 95       	lsr	r20
     c04:	37 95       	ror	r19
     c06:	27 95       	ror	r18
     c08:	a7 95       	ror	r26
     c0a:	f0 40       	sbci	r31, 0x00	; 0
     c0c:	53 95       	inc	r21
     c0e:	c9 f7       	brne	.-14     	; 0xc02 <__addsf3x+0x52>
     c10:	7e f4       	brtc	.+30     	; 0xc30 <__addsf3x+0x80>
     c12:	1f 16       	cp	r1, r31
     c14:	ba 0b       	sbc	r27, r26
     c16:	62 0b       	sbc	r22, r18
     c18:	73 0b       	sbc	r23, r19
     c1a:	84 0b       	sbc	r24, r20
     c1c:	ba f0       	brmi	.+46     	; 0xc4c <__addsf3x+0x9c>
     c1e:	91 50       	subi	r25, 0x01	; 1
     c20:	a1 f0       	breq	.+40     	; 0xc4a <__addsf3x+0x9a>
     c22:	ff 0f       	add	r31, r31
     c24:	bb 1f       	adc	r27, r27
     c26:	66 1f       	adc	r22, r22
     c28:	77 1f       	adc	r23, r23
     c2a:	88 1f       	adc	r24, r24
     c2c:	c2 f7       	brpl	.-16     	; 0xc1e <__addsf3x+0x6e>
     c2e:	0e c0       	rjmp	.+28     	; 0xc4c <__addsf3x+0x9c>
     c30:	ba 0f       	add	r27, r26
     c32:	62 1f       	adc	r22, r18
     c34:	73 1f       	adc	r23, r19
     c36:	84 1f       	adc	r24, r20
     c38:	48 f4       	brcc	.+18     	; 0xc4c <__addsf3x+0x9c>
     c3a:	87 95       	ror	r24
     c3c:	77 95       	ror	r23
     c3e:	67 95       	ror	r22
     c40:	b7 95       	ror	r27
     c42:	f7 95       	ror	r31
     c44:	9e 3f       	cpi	r25, 0xFE	; 254
     c46:	08 f0       	brcs	.+2      	; 0xc4a <__addsf3x+0x9a>
     c48:	b0 cf       	rjmp	.-160    	; 0xbaa <__addsf3+0x28>
     c4a:	93 95       	inc	r25
     c4c:	88 0f       	add	r24, r24
     c4e:	08 f0       	brcs	.+2      	; 0xc52 <__addsf3x+0xa2>
     c50:	99 27       	eor	r25, r25
     c52:	ee 0f       	add	r30, r30
     c54:	97 95       	ror	r25
     c56:	87 95       	ror	r24
     c58:	08 95       	ret

00000c5a <__cmpsf2>:
     c5a:	0e 94 51 07 	call	0xea2	; 0xea2 <__fp_cmp>
     c5e:	08 f4       	brcc	.+2      	; 0xc62 <__cmpsf2+0x8>
     c60:	81 e0       	ldi	r24, 0x01	; 1
     c62:	08 95       	ret

00000c64 <__divsf3>:
     c64:	0e 94 46 06 	call	0xc8c	; 0xc8c <__divsf3x>
     c68:	0c 94 b3 07 	jmp	0xf66	; 0xf66 <__fp_round>
     c6c:	0e 94 ac 07 	call	0xf58	; 0xf58 <__fp_pscB>
     c70:	58 f0       	brcs	.+22     	; 0xc88 <__divsf3+0x24>
     c72:	0e 94 a5 07 	call	0xf4a	; 0xf4a <__fp_pscA>
     c76:	40 f0       	brcs	.+16     	; 0xc88 <__divsf3+0x24>
     c78:	29 f4       	brne	.+10     	; 0xc84 <__divsf3+0x20>
     c7a:	5f 3f       	cpi	r21, 0xFF	; 255
     c7c:	29 f0       	breq	.+10     	; 0xc88 <__divsf3+0x24>
     c7e:	0c 94 75 07 	jmp	0xeea	; 0xeea <__fp_inf>
     c82:	51 11       	cpse	r21, r1
     c84:	0c 94 e7 07 	jmp	0xfce	; 0xfce <__fp_szero>
     c88:	0c 94 7b 07 	jmp	0xef6	; 0xef6 <__fp_nan>

00000c8c <__divsf3x>:
     c8c:	0e 94 c4 07 	call	0xf88	; 0xf88 <__fp_split3>
     c90:	68 f3       	brcs	.-38     	; 0xc6c <__divsf3+0x8>

00000c92 <__divsf3_pse>:
     c92:	99 23       	and	r25, r25
     c94:	b1 f3       	breq	.-20     	; 0xc82 <__divsf3+0x1e>
     c96:	55 23       	and	r21, r21
     c98:	91 f3       	breq	.-28     	; 0xc7e <__divsf3+0x1a>
     c9a:	95 1b       	sub	r25, r21
     c9c:	55 0b       	sbc	r21, r21
     c9e:	bb 27       	eor	r27, r27
     ca0:	aa 27       	eor	r26, r26
     ca2:	62 17       	cp	r22, r18
     ca4:	73 07       	cpc	r23, r19
     ca6:	84 07       	cpc	r24, r20
     ca8:	38 f0       	brcs	.+14     	; 0xcb8 <__divsf3_pse+0x26>
     caa:	9f 5f       	subi	r25, 0xFF	; 255
     cac:	5f 4f       	sbci	r21, 0xFF	; 255
     cae:	22 0f       	add	r18, r18
     cb0:	33 1f       	adc	r19, r19
     cb2:	44 1f       	adc	r20, r20
     cb4:	aa 1f       	adc	r26, r26
     cb6:	a9 f3       	breq	.-22     	; 0xca2 <__divsf3_pse+0x10>
     cb8:	35 d0       	rcall	.+106    	; 0xd24 <__divsf3_pse+0x92>
     cba:	0e 2e       	mov	r0, r30
     cbc:	3a f0       	brmi	.+14     	; 0xccc <__divsf3_pse+0x3a>
     cbe:	e0 e8       	ldi	r30, 0x80	; 128
     cc0:	32 d0       	rcall	.+100    	; 0xd26 <__divsf3_pse+0x94>
     cc2:	91 50       	subi	r25, 0x01	; 1
     cc4:	50 40       	sbci	r21, 0x00	; 0
     cc6:	e6 95       	lsr	r30
     cc8:	00 1c       	adc	r0, r0
     cca:	ca f7       	brpl	.-14     	; 0xcbe <__divsf3_pse+0x2c>
     ccc:	2b d0       	rcall	.+86     	; 0xd24 <__divsf3_pse+0x92>
     cce:	fe 2f       	mov	r31, r30
     cd0:	29 d0       	rcall	.+82     	; 0xd24 <__divsf3_pse+0x92>
     cd2:	66 0f       	add	r22, r22
     cd4:	77 1f       	adc	r23, r23
     cd6:	88 1f       	adc	r24, r24
     cd8:	bb 1f       	adc	r27, r27
     cda:	26 17       	cp	r18, r22
     cdc:	37 07       	cpc	r19, r23
     cde:	48 07       	cpc	r20, r24
     ce0:	ab 07       	cpc	r26, r27
     ce2:	b0 e8       	ldi	r27, 0x80	; 128
     ce4:	09 f0       	breq	.+2      	; 0xce8 <__divsf3_pse+0x56>
     ce6:	bb 0b       	sbc	r27, r27
     ce8:	80 2d       	mov	r24, r0
     cea:	bf 01       	movw	r22, r30
     cec:	ff 27       	eor	r31, r31
     cee:	93 58       	subi	r25, 0x83	; 131
     cf0:	5f 4f       	sbci	r21, 0xFF	; 255
     cf2:	3a f0       	brmi	.+14     	; 0xd02 <__divsf3_pse+0x70>
     cf4:	9e 3f       	cpi	r25, 0xFE	; 254
     cf6:	51 05       	cpc	r21, r1
     cf8:	78 f0       	brcs	.+30     	; 0xd18 <__divsf3_pse+0x86>
     cfa:	0c 94 75 07 	jmp	0xeea	; 0xeea <__fp_inf>
     cfe:	0c 94 e7 07 	jmp	0xfce	; 0xfce <__fp_szero>
     d02:	5f 3f       	cpi	r21, 0xFF	; 255
     d04:	e4 f3       	brlt	.-8      	; 0xcfe <__divsf3_pse+0x6c>
     d06:	98 3e       	cpi	r25, 0xE8	; 232
     d08:	d4 f3       	brlt	.-12     	; 0xcfe <__divsf3_pse+0x6c>
     d0a:	86 95       	lsr	r24
     d0c:	77 95       	ror	r23
     d0e:	67 95       	ror	r22
     d10:	b7 95       	ror	r27
     d12:	f7 95       	ror	r31
     d14:	9f 5f       	subi	r25, 0xFF	; 255
     d16:	c9 f7       	brne	.-14     	; 0xd0a <__divsf3_pse+0x78>
     d18:	88 0f       	add	r24, r24
     d1a:	91 1d       	adc	r25, r1
     d1c:	96 95       	lsr	r25
     d1e:	87 95       	ror	r24
     d20:	97 f9       	bld	r25, 7
     d22:	08 95       	ret
     d24:	e1 e0       	ldi	r30, 0x01	; 1
     d26:	66 0f       	add	r22, r22
     d28:	77 1f       	adc	r23, r23
     d2a:	88 1f       	adc	r24, r24
     d2c:	bb 1f       	adc	r27, r27
     d2e:	62 17       	cp	r22, r18
     d30:	73 07       	cpc	r23, r19
     d32:	84 07       	cpc	r24, r20
     d34:	ba 07       	cpc	r27, r26
     d36:	20 f0       	brcs	.+8      	; 0xd40 <__divsf3_pse+0xae>
     d38:	62 1b       	sub	r22, r18
     d3a:	73 0b       	sbc	r23, r19
     d3c:	84 0b       	sbc	r24, r20
     d3e:	ba 0b       	sbc	r27, r26
     d40:	ee 1f       	adc	r30, r30
     d42:	88 f7       	brcc	.-30     	; 0xd26 <__divsf3_pse+0x94>
     d44:	e0 95       	com	r30
     d46:	08 95       	ret
     d48:	29 f4       	brne	.+10     	; 0xd54 <__divsf3_pse+0xc2>
     d4a:	16 f0       	brts	.+4      	; 0xd50 <__divsf3_pse+0xbe>
     d4c:	0c 94 75 07 	jmp	0xeea	; 0xeea <__fp_inf>
     d50:	0c 94 e6 07 	jmp	0xfcc	; 0xfcc <__fp_zero>
     d54:	0c 94 7b 07 	jmp	0xef6	; 0xef6 <__fp_nan>

00000d58 <exp>:
     d58:	0e 94 cc 07 	call	0xf98	; 0xf98 <__fp_splitA>
     d5c:	a8 f3       	brcs	.-22     	; 0xd48 <__divsf3_pse+0xb6>
     d5e:	96 38       	cpi	r25, 0x86	; 134
     d60:	a0 f7       	brcc	.-24     	; 0xd4a <__divsf3_pse+0xb8>
     d62:	07 f8       	bld	r0, 7
     d64:	0f 92       	push	r0
     d66:	e8 94       	clt
     d68:	2b e3       	ldi	r18, 0x3B	; 59
     d6a:	3a ea       	ldi	r19, 0xAA	; 170
     d6c:	48 eb       	ldi	r20, 0xB8	; 184
     d6e:	5f e7       	ldi	r21, 0x7F	; 127
     d70:	0e 94 7e 08 	call	0x10fc	; 0x10fc <__mulsf3_pse>
     d74:	0f 92       	push	r0
     d76:	0f 92       	push	r0
     d78:	0f 92       	push	r0
     d7a:	4d b7       	in	r20, 0x3d	; 61
     d7c:	5e b7       	in	r21, 0x3e	; 62
     d7e:	0f 92       	push	r0
     d80:	0e 94 34 08 	call	0x1068	; 0x1068 <modf>
     d84:	e4 e3       	ldi	r30, 0x34	; 52
     d86:	f0 e0       	ldi	r31, 0x00	; 0
     d88:	0e 94 7e 07 	call	0xefc	; 0xefc <__fp_powser>
     d8c:	4f 91       	pop	r20
     d8e:	5f 91       	pop	r21
     d90:	ef 91       	pop	r30
     d92:	ff 91       	pop	r31
     d94:	e5 95       	asr	r30
     d96:	ee 1f       	adc	r30, r30
     d98:	ff 1f       	adc	r31, r31
     d9a:	49 f0       	breq	.+18     	; 0xdae <exp+0x56>
     d9c:	fe 57       	subi	r31, 0x7E	; 126
     d9e:	e0 68       	ori	r30, 0x80	; 128
     da0:	44 27       	eor	r20, r20
     da2:	ee 0f       	add	r30, r30
     da4:	44 1f       	adc	r20, r20
     da6:	fa 95       	dec	r31
     da8:	e1 f7       	brne	.-8      	; 0xda2 <exp+0x4a>
     daa:	41 95       	neg	r20
     dac:	55 0b       	sbc	r21, r21
     dae:	0e 94 fe 07 	call	0xffc	; 0xffc <ldexp>
     db2:	0f 90       	pop	r0
     db4:	07 fe       	sbrs	r0, 7
     db6:	0c 94 f2 07 	jmp	0xfe4	; 0xfe4 <inverse>
     dba:	08 95       	ret

00000dbc <__fixsfsi>:
     dbc:	0e 94 e5 06 	call	0xdca	; 0xdca <__fixunssfsi>
     dc0:	68 94       	set
     dc2:	b1 11       	cpse	r27, r1
     dc4:	0c 94 e7 07 	jmp	0xfce	; 0xfce <__fp_szero>
     dc8:	08 95       	ret

00000dca <__fixunssfsi>:
     dca:	0e 94 cc 07 	call	0xf98	; 0xf98 <__fp_splitA>
     dce:	88 f0       	brcs	.+34     	; 0xdf2 <__fixunssfsi+0x28>
     dd0:	9f 57       	subi	r25, 0x7F	; 127
     dd2:	98 f0       	brcs	.+38     	; 0xdfa <__fixunssfsi+0x30>
     dd4:	b9 2f       	mov	r27, r25
     dd6:	99 27       	eor	r25, r25
     dd8:	b7 51       	subi	r27, 0x17	; 23
     dda:	b0 f0       	brcs	.+44     	; 0xe08 <__fixunssfsi+0x3e>
     ddc:	e1 f0       	breq	.+56     	; 0xe16 <__fixunssfsi+0x4c>
     dde:	66 0f       	add	r22, r22
     de0:	77 1f       	adc	r23, r23
     de2:	88 1f       	adc	r24, r24
     de4:	99 1f       	adc	r25, r25
     de6:	1a f0       	brmi	.+6      	; 0xdee <__fixunssfsi+0x24>
     de8:	ba 95       	dec	r27
     dea:	c9 f7       	brne	.-14     	; 0xdde <__fixunssfsi+0x14>
     dec:	14 c0       	rjmp	.+40     	; 0xe16 <__fixunssfsi+0x4c>
     dee:	b1 30       	cpi	r27, 0x01	; 1
     df0:	91 f0       	breq	.+36     	; 0xe16 <__fixunssfsi+0x4c>
     df2:	0e 94 e6 07 	call	0xfcc	; 0xfcc <__fp_zero>
     df6:	b1 e0       	ldi	r27, 0x01	; 1
     df8:	08 95       	ret
     dfa:	0c 94 e6 07 	jmp	0xfcc	; 0xfcc <__fp_zero>
     dfe:	67 2f       	mov	r22, r23
     e00:	78 2f       	mov	r23, r24
     e02:	88 27       	eor	r24, r24
     e04:	b8 5f       	subi	r27, 0xF8	; 248
     e06:	39 f0       	breq	.+14     	; 0xe16 <__fixunssfsi+0x4c>
     e08:	b9 3f       	cpi	r27, 0xF9	; 249
     e0a:	cc f3       	brlt	.-14     	; 0xdfe <__fixunssfsi+0x34>
     e0c:	86 95       	lsr	r24
     e0e:	77 95       	ror	r23
     e10:	67 95       	ror	r22
     e12:	b3 95       	inc	r27
     e14:	d9 f7       	brne	.-10     	; 0xe0c <__fixunssfsi+0x42>
     e16:	3e f4       	brtc	.+14     	; 0xe26 <__fixunssfsi+0x5c>
     e18:	90 95       	com	r25
     e1a:	80 95       	com	r24
     e1c:	70 95       	com	r23
     e1e:	61 95       	neg	r22
     e20:	7f 4f       	sbci	r23, 0xFF	; 255
     e22:	8f 4f       	sbci	r24, 0xFF	; 255
     e24:	9f 4f       	sbci	r25, 0xFF	; 255
     e26:	08 95       	ret

00000e28 <__floatunsisf>:
     e28:	e8 94       	clt
     e2a:	09 c0       	rjmp	.+18     	; 0xe3e <__floatsisf+0x12>

00000e2c <__floatsisf>:
     e2c:	97 fb       	bst	r25, 7
     e2e:	3e f4       	brtc	.+14     	; 0xe3e <__floatsisf+0x12>
     e30:	90 95       	com	r25
     e32:	80 95       	com	r24
     e34:	70 95       	com	r23
     e36:	61 95       	neg	r22
     e38:	7f 4f       	sbci	r23, 0xFF	; 255
     e3a:	8f 4f       	sbci	r24, 0xFF	; 255
     e3c:	9f 4f       	sbci	r25, 0xFF	; 255
     e3e:	99 23       	and	r25, r25
     e40:	a9 f0       	breq	.+42     	; 0xe6c <__floatsisf+0x40>
     e42:	f9 2f       	mov	r31, r25
     e44:	96 e9       	ldi	r25, 0x96	; 150
     e46:	bb 27       	eor	r27, r27
     e48:	93 95       	inc	r25
     e4a:	f6 95       	lsr	r31
     e4c:	87 95       	ror	r24
     e4e:	77 95       	ror	r23
     e50:	67 95       	ror	r22
     e52:	b7 95       	ror	r27
     e54:	f1 11       	cpse	r31, r1
     e56:	f8 cf       	rjmp	.-16     	; 0xe48 <__floatsisf+0x1c>
     e58:	fa f4       	brpl	.+62     	; 0xe98 <__floatsisf+0x6c>
     e5a:	bb 0f       	add	r27, r27
     e5c:	11 f4       	brne	.+4      	; 0xe62 <__floatsisf+0x36>
     e5e:	60 ff       	sbrs	r22, 0
     e60:	1b c0       	rjmp	.+54     	; 0xe98 <__floatsisf+0x6c>
     e62:	6f 5f       	subi	r22, 0xFF	; 255
     e64:	7f 4f       	sbci	r23, 0xFF	; 255
     e66:	8f 4f       	sbci	r24, 0xFF	; 255
     e68:	9f 4f       	sbci	r25, 0xFF	; 255
     e6a:	16 c0       	rjmp	.+44     	; 0xe98 <__floatsisf+0x6c>
     e6c:	88 23       	and	r24, r24
     e6e:	11 f0       	breq	.+4      	; 0xe74 <__floatsisf+0x48>
     e70:	96 e9       	ldi	r25, 0x96	; 150
     e72:	11 c0       	rjmp	.+34     	; 0xe96 <__floatsisf+0x6a>
     e74:	77 23       	and	r23, r23
     e76:	21 f0       	breq	.+8      	; 0xe80 <__floatsisf+0x54>
     e78:	9e e8       	ldi	r25, 0x8E	; 142
     e7a:	87 2f       	mov	r24, r23
     e7c:	76 2f       	mov	r23, r22
     e7e:	05 c0       	rjmp	.+10     	; 0xe8a <__floatsisf+0x5e>
     e80:	66 23       	and	r22, r22
     e82:	71 f0       	breq	.+28     	; 0xea0 <__floatsisf+0x74>
     e84:	96 e8       	ldi	r25, 0x86	; 134
     e86:	86 2f       	mov	r24, r22
     e88:	70 e0       	ldi	r23, 0x00	; 0
     e8a:	60 e0       	ldi	r22, 0x00	; 0
     e8c:	2a f0       	brmi	.+10     	; 0xe98 <__floatsisf+0x6c>
     e8e:	9a 95       	dec	r25
     e90:	66 0f       	add	r22, r22
     e92:	77 1f       	adc	r23, r23
     e94:	88 1f       	adc	r24, r24
     e96:	da f7       	brpl	.-10     	; 0xe8e <__floatsisf+0x62>
     e98:	88 0f       	add	r24, r24
     e9a:	96 95       	lsr	r25
     e9c:	87 95       	ror	r24
     e9e:	97 f9       	bld	r25, 7
     ea0:	08 95       	ret

00000ea2 <__fp_cmp>:
     ea2:	99 0f       	add	r25, r25
     ea4:	00 08       	sbc	r0, r0
     ea6:	55 0f       	add	r21, r21
     ea8:	aa 0b       	sbc	r26, r26
     eaa:	e0 e8       	ldi	r30, 0x80	; 128
     eac:	fe ef       	ldi	r31, 0xFE	; 254
     eae:	16 16       	cp	r1, r22
     eb0:	17 06       	cpc	r1, r23
     eb2:	e8 07       	cpc	r30, r24
     eb4:	f9 07       	cpc	r31, r25
     eb6:	c0 f0       	brcs	.+48     	; 0xee8 <__fp_cmp+0x46>
     eb8:	12 16       	cp	r1, r18
     eba:	13 06       	cpc	r1, r19
     ebc:	e4 07       	cpc	r30, r20
     ebe:	f5 07       	cpc	r31, r21
     ec0:	98 f0       	brcs	.+38     	; 0xee8 <__fp_cmp+0x46>
     ec2:	62 1b       	sub	r22, r18
     ec4:	73 0b       	sbc	r23, r19
     ec6:	84 0b       	sbc	r24, r20
     ec8:	95 0b       	sbc	r25, r21
     eca:	39 f4       	brne	.+14     	; 0xeda <__fp_cmp+0x38>
     ecc:	0a 26       	eor	r0, r26
     ece:	61 f0       	breq	.+24     	; 0xee8 <__fp_cmp+0x46>
     ed0:	23 2b       	or	r18, r19
     ed2:	24 2b       	or	r18, r20
     ed4:	25 2b       	or	r18, r21
     ed6:	21 f4       	brne	.+8      	; 0xee0 <__fp_cmp+0x3e>
     ed8:	08 95       	ret
     eda:	0a 26       	eor	r0, r26
     edc:	09 f4       	brne	.+2      	; 0xee0 <__fp_cmp+0x3e>
     ede:	a1 40       	sbci	r26, 0x01	; 1
     ee0:	a6 95       	lsr	r26
     ee2:	8f ef       	ldi	r24, 0xFF	; 255
     ee4:	81 1d       	adc	r24, r1
     ee6:	81 1d       	adc	r24, r1
     ee8:	08 95       	ret

00000eea <__fp_inf>:
     eea:	97 f9       	bld	r25, 7
     eec:	9f 67       	ori	r25, 0x7F	; 127
     eee:	80 e8       	ldi	r24, 0x80	; 128
     ef0:	70 e0       	ldi	r23, 0x00	; 0
     ef2:	60 e0       	ldi	r22, 0x00	; 0
     ef4:	08 95       	ret

00000ef6 <__fp_nan>:
     ef6:	9f ef       	ldi	r25, 0xFF	; 255
     ef8:	80 ec       	ldi	r24, 0xC0	; 192
     efa:	08 95       	ret

00000efc <__fp_powser>:
     efc:	df 93       	push	r29
     efe:	cf 93       	push	r28
     f00:	1f 93       	push	r17
     f02:	0f 93       	push	r16
     f04:	ff 92       	push	r15
     f06:	ef 92       	push	r14
     f08:	df 92       	push	r13
     f0a:	7b 01       	movw	r14, r22
     f0c:	8c 01       	movw	r16, r24
     f0e:	68 94       	set
     f10:	06 c0       	rjmp	.+12     	; 0xf1e <__fp_powser+0x22>
     f12:	da 2e       	mov	r13, r26
     f14:	ef 01       	movw	r28, r30
     f16:	0e 94 7b 08 	call	0x10f6	; 0x10f6 <__mulsf3x>
     f1a:	fe 01       	movw	r30, r28
     f1c:	e8 94       	clt
     f1e:	a5 91       	lpm	r26, Z+
     f20:	25 91       	lpm	r18, Z+
     f22:	35 91       	lpm	r19, Z+
     f24:	45 91       	lpm	r20, Z+
     f26:	55 91       	lpm	r21, Z+
     f28:	a6 f3       	brts	.-24     	; 0xf12 <__fp_powser+0x16>
     f2a:	ef 01       	movw	r28, r30
     f2c:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <__addsf3x>
     f30:	fe 01       	movw	r30, r28
     f32:	97 01       	movw	r18, r14
     f34:	a8 01       	movw	r20, r16
     f36:	da 94       	dec	r13
     f38:	69 f7       	brne	.-38     	; 0xf14 <__fp_powser+0x18>
     f3a:	df 90       	pop	r13
     f3c:	ef 90       	pop	r14
     f3e:	ff 90       	pop	r15
     f40:	0f 91       	pop	r16
     f42:	1f 91       	pop	r17
     f44:	cf 91       	pop	r28
     f46:	df 91       	pop	r29
     f48:	08 95       	ret

00000f4a <__fp_pscA>:
     f4a:	00 24       	eor	r0, r0
     f4c:	0a 94       	dec	r0
     f4e:	16 16       	cp	r1, r22
     f50:	17 06       	cpc	r1, r23
     f52:	18 06       	cpc	r1, r24
     f54:	09 06       	cpc	r0, r25
     f56:	08 95       	ret

00000f58 <__fp_pscB>:
     f58:	00 24       	eor	r0, r0
     f5a:	0a 94       	dec	r0
     f5c:	12 16       	cp	r1, r18
     f5e:	13 06       	cpc	r1, r19
     f60:	14 06       	cpc	r1, r20
     f62:	05 06       	cpc	r0, r21
     f64:	08 95       	ret

00000f66 <__fp_round>:
     f66:	09 2e       	mov	r0, r25
     f68:	03 94       	inc	r0
     f6a:	00 0c       	add	r0, r0
     f6c:	11 f4       	brne	.+4      	; 0xf72 <__fp_round+0xc>
     f6e:	88 23       	and	r24, r24
     f70:	52 f0       	brmi	.+20     	; 0xf86 <__fp_round+0x20>
     f72:	bb 0f       	add	r27, r27
     f74:	40 f4       	brcc	.+16     	; 0xf86 <__fp_round+0x20>
     f76:	bf 2b       	or	r27, r31
     f78:	11 f4       	brne	.+4      	; 0xf7e <__fp_round+0x18>
     f7a:	60 ff       	sbrs	r22, 0
     f7c:	04 c0       	rjmp	.+8      	; 0xf86 <__fp_round+0x20>
     f7e:	6f 5f       	subi	r22, 0xFF	; 255
     f80:	7f 4f       	sbci	r23, 0xFF	; 255
     f82:	8f 4f       	sbci	r24, 0xFF	; 255
     f84:	9f 4f       	sbci	r25, 0xFF	; 255
     f86:	08 95       	ret

00000f88 <__fp_split3>:
     f88:	57 fd       	sbrc	r21, 7
     f8a:	90 58       	subi	r25, 0x80	; 128
     f8c:	44 0f       	add	r20, r20
     f8e:	55 1f       	adc	r21, r21
     f90:	59 f0       	breq	.+22     	; 0xfa8 <__fp_splitA+0x10>
     f92:	5f 3f       	cpi	r21, 0xFF	; 255
     f94:	71 f0       	breq	.+28     	; 0xfb2 <__fp_splitA+0x1a>
     f96:	47 95       	ror	r20

00000f98 <__fp_splitA>:
     f98:	88 0f       	add	r24, r24
     f9a:	97 fb       	bst	r25, 7
     f9c:	99 1f       	adc	r25, r25
     f9e:	61 f0       	breq	.+24     	; 0xfb8 <__fp_splitA+0x20>
     fa0:	9f 3f       	cpi	r25, 0xFF	; 255
     fa2:	79 f0       	breq	.+30     	; 0xfc2 <__fp_splitA+0x2a>
     fa4:	87 95       	ror	r24
     fa6:	08 95       	ret
     fa8:	12 16       	cp	r1, r18
     faa:	13 06       	cpc	r1, r19
     fac:	14 06       	cpc	r1, r20
     fae:	55 1f       	adc	r21, r21
     fb0:	f2 cf       	rjmp	.-28     	; 0xf96 <__fp_split3+0xe>
     fb2:	46 95       	lsr	r20
     fb4:	f1 df       	rcall	.-30     	; 0xf98 <__fp_splitA>
     fb6:	08 c0       	rjmp	.+16     	; 0xfc8 <__fp_splitA+0x30>
     fb8:	16 16       	cp	r1, r22
     fba:	17 06       	cpc	r1, r23
     fbc:	18 06       	cpc	r1, r24
     fbe:	99 1f       	adc	r25, r25
     fc0:	f1 cf       	rjmp	.-30     	; 0xfa4 <__fp_splitA+0xc>
     fc2:	86 95       	lsr	r24
     fc4:	71 05       	cpc	r23, r1
     fc6:	61 05       	cpc	r22, r1
     fc8:	08 94       	sec
     fca:	08 95       	ret

00000fcc <__fp_zero>:
     fcc:	e8 94       	clt

00000fce <__fp_szero>:
     fce:	bb 27       	eor	r27, r27
     fd0:	66 27       	eor	r22, r22
     fd2:	77 27       	eor	r23, r23
     fd4:	cb 01       	movw	r24, r22
     fd6:	97 f9       	bld	r25, 7
     fd8:	08 95       	ret

00000fda <__gesf2>:
     fda:	0e 94 51 07 	call	0xea2	; 0xea2 <__fp_cmp>
     fde:	08 f4       	brcc	.+2      	; 0xfe2 <__gesf2+0x8>
     fe0:	8f ef       	ldi	r24, 0xFF	; 255
     fe2:	08 95       	ret

00000fe4 <inverse>:
     fe4:	9b 01       	movw	r18, r22
     fe6:	ac 01       	movw	r20, r24
     fe8:	60 e0       	ldi	r22, 0x00	; 0
     fea:	70 e0       	ldi	r23, 0x00	; 0
     fec:	80 e8       	ldi	r24, 0x80	; 128
     fee:	9f e3       	ldi	r25, 0x3F	; 63
     ff0:	0c 94 32 06 	jmp	0xc64	; 0xc64 <__divsf3>
     ff4:	0c 94 75 07 	jmp	0xeea	; 0xeea <__fp_inf>
     ff8:	0c 94 14 09 	jmp	0x1228	; 0x1228 <__fp_mpack>

00000ffc <ldexp>:
     ffc:	0e 94 cc 07 	call	0xf98	; 0xf98 <__fp_splitA>
    1000:	d8 f3       	brcs	.-10     	; 0xff8 <inverse+0x14>
    1002:	99 23       	and	r25, r25
    1004:	c9 f3       	breq	.-14     	; 0xff8 <inverse+0x14>
    1006:	94 0f       	add	r25, r20
    1008:	51 1d       	adc	r21, r1
    100a:	a3 f3       	brvs	.-24     	; 0xff4 <inverse+0x10>
    100c:	91 50       	subi	r25, 0x01	; 1
    100e:	50 40       	sbci	r21, 0x00	; 0
    1010:	94 f0       	brlt	.+36     	; 0x1036 <ldexp+0x3a>
    1012:	59 f0       	breq	.+22     	; 0x102a <ldexp+0x2e>
    1014:	88 23       	and	r24, r24
    1016:	32 f0       	brmi	.+12     	; 0x1024 <ldexp+0x28>
    1018:	66 0f       	add	r22, r22
    101a:	77 1f       	adc	r23, r23
    101c:	88 1f       	adc	r24, r24
    101e:	91 50       	subi	r25, 0x01	; 1
    1020:	50 40       	sbci	r21, 0x00	; 0
    1022:	c1 f7       	brne	.-16     	; 0x1014 <ldexp+0x18>
    1024:	9e 3f       	cpi	r25, 0xFE	; 254
    1026:	51 05       	cpc	r21, r1
    1028:	2c f7       	brge	.-54     	; 0xff4 <inverse+0x10>
    102a:	88 0f       	add	r24, r24
    102c:	91 1d       	adc	r25, r1
    102e:	96 95       	lsr	r25
    1030:	87 95       	ror	r24
    1032:	97 f9       	bld	r25, 7
    1034:	08 95       	ret
    1036:	5f 3f       	cpi	r21, 0xFF	; 255
    1038:	ac f0       	brlt	.+42     	; 0x1064 <ldexp+0x68>
    103a:	98 3e       	cpi	r25, 0xE8	; 232
    103c:	9c f0       	brlt	.+38     	; 0x1064 <ldexp+0x68>
    103e:	bb 27       	eor	r27, r27
    1040:	86 95       	lsr	r24
    1042:	77 95       	ror	r23
    1044:	67 95       	ror	r22
    1046:	b7 95       	ror	r27
    1048:	08 f4       	brcc	.+2      	; 0x104c <ldexp+0x50>
    104a:	b1 60       	ori	r27, 0x01	; 1
    104c:	93 95       	inc	r25
    104e:	c1 f7       	brne	.-16     	; 0x1040 <ldexp+0x44>
    1050:	bb 0f       	add	r27, r27
    1052:	58 f7       	brcc	.-42     	; 0x102a <ldexp+0x2e>
    1054:	11 f4       	brne	.+4      	; 0x105a <ldexp+0x5e>
    1056:	60 ff       	sbrs	r22, 0
    1058:	e8 cf       	rjmp	.-48     	; 0x102a <ldexp+0x2e>
    105a:	6f 5f       	subi	r22, 0xFF	; 255
    105c:	7f 4f       	sbci	r23, 0xFF	; 255
    105e:	8f 4f       	sbci	r24, 0xFF	; 255
    1060:	9f 4f       	sbci	r25, 0xFF	; 255
    1062:	e3 cf       	rjmp	.-58     	; 0x102a <ldexp+0x2e>
    1064:	0c 94 e7 07 	jmp	0xfce	; 0xfce <__fp_szero>

00001068 <modf>:
    1068:	fa 01       	movw	r30, r20
    106a:	dc 01       	movw	r26, r24
    106c:	aa 0f       	add	r26, r26
    106e:	bb 1f       	adc	r27, r27
    1070:	9b 01       	movw	r18, r22
    1072:	ac 01       	movw	r20, r24
    1074:	bf 57       	subi	r27, 0x7F	; 127
    1076:	28 f4       	brcc	.+10     	; 0x1082 <modf+0x1a>
    1078:	22 27       	eor	r18, r18
    107a:	33 27       	eor	r19, r19
    107c:	44 27       	eor	r20, r20
    107e:	50 78       	andi	r21, 0x80	; 128
    1080:	20 c0       	rjmp	.+64     	; 0x10c2 <modf+0x5a>
    1082:	b7 51       	subi	r27, 0x17	; 23
    1084:	90 f4       	brcc	.+36     	; 0x10aa <modf+0x42>
    1086:	ab 2f       	mov	r26, r27
    1088:	00 24       	eor	r0, r0
    108a:	46 95       	lsr	r20
    108c:	37 95       	ror	r19
    108e:	27 95       	ror	r18
    1090:	01 1c       	adc	r0, r1
    1092:	a3 95       	inc	r26
    1094:	d2 f3       	brmi	.-12     	; 0x108a <modf+0x22>
    1096:	00 20       	and	r0, r0
    1098:	71 f0       	breq	.+28     	; 0x10b6 <modf+0x4e>
    109a:	22 0f       	add	r18, r18
    109c:	33 1f       	adc	r19, r19
    109e:	44 1f       	adc	r20, r20
    10a0:	b3 95       	inc	r27
    10a2:	da f3       	brmi	.-10     	; 0x109a <modf+0x32>
    10a4:	0e d0       	rcall	.+28     	; 0x10c2 <modf+0x5a>
    10a6:	0c 94 c0 05 	jmp	0xb80	; 0xb80 <__subsf3>
    10aa:	61 30       	cpi	r22, 0x01	; 1
    10ac:	71 05       	cpc	r23, r1
    10ae:	a0 e8       	ldi	r26, 0x80	; 128
    10b0:	8a 07       	cpc	r24, r26
    10b2:	b9 46       	sbci	r27, 0x69	; 105
    10b4:	30 f4       	brcc	.+12     	; 0x10c2 <modf+0x5a>
    10b6:	9b 01       	movw	r18, r22
    10b8:	ac 01       	movw	r20, r24
    10ba:	66 27       	eor	r22, r22
    10bc:	77 27       	eor	r23, r23
    10be:	88 27       	eor	r24, r24
    10c0:	90 78       	andi	r25, 0x80	; 128
    10c2:	30 96       	adiw	r30, 0x00	; 0
    10c4:	21 f0       	breq	.+8      	; 0x10ce <modf+0x66>
    10c6:	20 83       	st	Z, r18
    10c8:	31 83       	std	Z+1, r19	; 0x01
    10ca:	42 83       	std	Z+2, r20	; 0x02
    10cc:	53 83       	std	Z+3, r21	; 0x03
    10ce:	08 95       	ret

000010d0 <__mulsf3>:
    10d0:	0e 94 7b 08 	call	0x10f6	; 0x10f6 <__mulsf3x>
    10d4:	0c 94 b3 07 	jmp	0xf66	; 0xf66 <__fp_round>
    10d8:	0e 94 a5 07 	call	0xf4a	; 0xf4a <__fp_pscA>
    10dc:	38 f0       	brcs	.+14     	; 0x10ec <__mulsf3+0x1c>
    10de:	0e 94 ac 07 	call	0xf58	; 0xf58 <__fp_pscB>
    10e2:	20 f0       	brcs	.+8      	; 0x10ec <__mulsf3+0x1c>
    10e4:	95 23       	and	r25, r21
    10e6:	11 f0       	breq	.+4      	; 0x10ec <__mulsf3+0x1c>
    10e8:	0c 94 75 07 	jmp	0xeea	; 0xeea <__fp_inf>
    10ec:	0c 94 7b 07 	jmp	0xef6	; 0xef6 <__fp_nan>
    10f0:	11 24       	eor	r1, r1
    10f2:	0c 94 e7 07 	jmp	0xfce	; 0xfce <__fp_szero>

000010f6 <__mulsf3x>:
    10f6:	0e 94 c4 07 	call	0xf88	; 0xf88 <__fp_split3>
    10fa:	70 f3       	brcs	.-36     	; 0x10d8 <__mulsf3+0x8>

000010fc <__mulsf3_pse>:
    10fc:	95 9f       	mul	r25, r21
    10fe:	c1 f3       	breq	.-16     	; 0x10f0 <__mulsf3+0x20>
    1100:	95 0f       	add	r25, r21
    1102:	50 e0       	ldi	r21, 0x00	; 0
    1104:	55 1f       	adc	r21, r21
    1106:	62 9f       	mul	r22, r18
    1108:	f0 01       	movw	r30, r0
    110a:	72 9f       	mul	r23, r18
    110c:	bb 27       	eor	r27, r27
    110e:	f0 0d       	add	r31, r0
    1110:	b1 1d       	adc	r27, r1
    1112:	63 9f       	mul	r22, r19
    1114:	aa 27       	eor	r26, r26
    1116:	f0 0d       	add	r31, r0
    1118:	b1 1d       	adc	r27, r1
    111a:	aa 1f       	adc	r26, r26
    111c:	64 9f       	mul	r22, r20
    111e:	66 27       	eor	r22, r22
    1120:	b0 0d       	add	r27, r0
    1122:	a1 1d       	adc	r26, r1
    1124:	66 1f       	adc	r22, r22
    1126:	82 9f       	mul	r24, r18
    1128:	22 27       	eor	r18, r18
    112a:	b0 0d       	add	r27, r0
    112c:	a1 1d       	adc	r26, r1
    112e:	62 1f       	adc	r22, r18
    1130:	73 9f       	mul	r23, r19
    1132:	b0 0d       	add	r27, r0
    1134:	a1 1d       	adc	r26, r1
    1136:	62 1f       	adc	r22, r18
    1138:	83 9f       	mul	r24, r19
    113a:	a0 0d       	add	r26, r0
    113c:	61 1d       	adc	r22, r1
    113e:	22 1f       	adc	r18, r18
    1140:	74 9f       	mul	r23, r20
    1142:	33 27       	eor	r19, r19
    1144:	a0 0d       	add	r26, r0
    1146:	61 1d       	adc	r22, r1
    1148:	23 1f       	adc	r18, r19
    114a:	84 9f       	mul	r24, r20
    114c:	60 0d       	add	r22, r0
    114e:	21 1d       	adc	r18, r1
    1150:	82 2f       	mov	r24, r18
    1152:	76 2f       	mov	r23, r22
    1154:	6a 2f       	mov	r22, r26
    1156:	11 24       	eor	r1, r1
    1158:	9f 57       	subi	r25, 0x7F	; 127
    115a:	50 40       	sbci	r21, 0x00	; 0
    115c:	9a f0       	brmi	.+38     	; 0x1184 <__mulsf3_pse+0x88>
    115e:	f1 f0       	breq	.+60     	; 0x119c <__mulsf3_pse+0xa0>
    1160:	88 23       	and	r24, r24
    1162:	4a f0       	brmi	.+18     	; 0x1176 <__mulsf3_pse+0x7a>
    1164:	ee 0f       	add	r30, r30
    1166:	ff 1f       	adc	r31, r31
    1168:	bb 1f       	adc	r27, r27
    116a:	66 1f       	adc	r22, r22
    116c:	77 1f       	adc	r23, r23
    116e:	88 1f       	adc	r24, r24
    1170:	91 50       	subi	r25, 0x01	; 1
    1172:	50 40       	sbci	r21, 0x00	; 0
    1174:	a9 f7       	brne	.-22     	; 0x1160 <__mulsf3_pse+0x64>
    1176:	9e 3f       	cpi	r25, 0xFE	; 254
    1178:	51 05       	cpc	r21, r1
    117a:	80 f0       	brcs	.+32     	; 0x119c <__mulsf3_pse+0xa0>
    117c:	0c 94 75 07 	jmp	0xeea	; 0xeea <__fp_inf>
    1180:	0c 94 e7 07 	jmp	0xfce	; 0xfce <__fp_szero>
    1184:	5f 3f       	cpi	r21, 0xFF	; 255
    1186:	e4 f3       	brlt	.-8      	; 0x1180 <__mulsf3_pse+0x84>
    1188:	98 3e       	cpi	r25, 0xE8	; 232
    118a:	d4 f3       	brlt	.-12     	; 0x1180 <__mulsf3_pse+0x84>
    118c:	86 95       	lsr	r24
    118e:	77 95       	ror	r23
    1190:	67 95       	ror	r22
    1192:	b7 95       	ror	r27
    1194:	f7 95       	ror	r31
    1196:	e7 95       	ror	r30
    1198:	9f 5f       	subi	r25, 0xFF	; 255
    119a:	c1 f7       	brne	.-16     	; 0x118c <__mulsf3_pse+0x90>
    119c:	fe 2b       	or	r31, r30
    119e:	88 0f       	add	r24, r24
    11a0:	91 1d       	adc	r25, r1
    11a2:	96 95       	lsr	r25
    11a4:	87 95       	ror	r24
    11a6:	97 f9       	bld	r25, 7
    11a8:	08 95       	ret

000011aa <round>:
    11aa:	0e 94 cc 07 	call	0xf98	; 0xf98 <__fp_splitA>
    11ae:	e8 f0       	brcs	.+58     	; 0x11ea <round+0x40>
    11b0:	9e 37       	cpi	r25, 0x7E	; 126
    11b2:	e8 f0       	brcs	.+58     	; 0x11ee <round+0x44>
    11b4:	96 39       	cpi	r25, 0x96	; 150
    11b6:	b8 f4       	brcc	.+46     	; 0x11e6 <round+0x3c>
    11b8:	9e 38       	cpi	r25, 0x8E	; 142
    11ba:	48 f4       	brcc	.+18     	; 0x11ce <round+0x24>
    11bc:	67 2f       	mov	r22, r23
    11be:	78 2f       	mov	r23, r24
    11c0:	88 27       	eor	r24, r24
    11c2:	98 5f       	subi	r25, 0xF8	; 248
    11c4:	f9 cf       	rjmp	.-14     	; 0x11b8 <round+0xe>
    11c6:	86 95       	lsr	r24
    11c8:	77 95       	ror	r23
    11ca:	67 95       	ror	r22
    11cc:	93 95       	inc	r25
    11ce:	95 39       	cpi	r25, 0x95	; 149
    11d0:	d0 f3       	brcs	.-12     	; 0x11c6 <round+0x1c>
    11d2:	b6 2f       	mov	r27, r22
    11d4:	b1 70       	andi	r27, 0x01	; 1
    11d6:	6b 0f       	add	r22, r27
    11d8:	71 1d       	adc	r23, r1
    11da:	81 1d       	adc	r24, r1
    11dc:	20 f4       	brcc	.+8      	; 0x11e6 <round+0x3c>
    11de:	87 95       	ror	r24
    11e0:	77 95       	ror	r23
    11e2:	67 95       	ror	r22
    11e4:	93 95       	inc	r25
    11e6:	0c 94 f9 08 	jmp	0x11f2	; 0x11f2 <__fp_mintl>
    11ea:	0c 94 14 09 	jmp	0x1228	; 0x1228 <__fp_mpack>
    11ee:	0c 94 e7 07 	jmp	0xfce	; 0xfce <__fp_szero>

000011f2 <__fp_mintl>:
    11f2:	88 23       	and	r24, r24
    11f4:	71 f4       	brne	.+28     	; 0x1212 <__fp_mintl+0x20>
    11f6:	77 23       	and	r23, r23
    11f8:	21 f0       	breq	.+8      	; 0x1202 <__fp_mintl+0x10>
    11fa:	98 50       	subi	r25, 0x08	; 8
    11fc:	87 2b       	or	r24, r23
    11fe:	76 2f       	mov	r23, r22
    1200:	07 c0       	rjmp	.+14     	; 0x1210 <__fp_mintl+0x1e>
    1202:	66 23       	and	r22, r22
    1204:	11 f4       	brne	.+4      	; 0x120a <__fp_mintl+0x18>
    1206:	99 27       	eor	r25, r25
    1208:	0d c0       	rjmp	.+26     	; 0x1224 <__fp_mintl+0x32>
    120a:	90 51       	subi	r25, 0x10	; 16
    120c:	86 2b       	or	r24, r22
    120e:	70 e0       	ldi	r23, 0x00	; 0
    1210:	60 e0       	ldi	r22, 0x00	; 0
    1212:	2a f0       	brmi	.+10     	; 0x121e <__fp_mintl+0x2c>
    1214:	9a 95       	dec	r25
    1216:	66 0f       	add	r22, r22
    1218:	77 1f       	adc	r23, r23
    121a:	88 1f       	adc	r24, r24
    121c:	da f7       	brpl	.-10     	; 0x1214 <__fp_mintl+0x22>
    121e:	88 0f       	add	r24, r24
    1220:	96 95       	lsr	r25
    1222:	87 95       	ror	r24
    1224:	97 f9       	bld	r25, 7
    1226:	08 95       	ret

00001228 <__fp_mpack>:
    1228:	9f 3f       	cpi	r25, 0xFF	; 255
    122a:	31 f0       	breq	.+12     	; 0x1238 <__fp_mpack_finite+0xc>

0000122c <__fp_mpack_finite>:
    122c:	91 50       	subi	r25, 0x01	; 1
    122e:	20 f4       	brcc	.+8      	; 0x1238 <__fp_mpack_finite+0xc>
    1230:	87 95       	ror	r24
    1232:	77 95       	ror	r23
    1234:	67 95       	ror	r22
    1236:	b7 95       	ror	r27
    1238:	88 0f       	add	r24, r24
    123a:	91 1d       	adc	r25, r1
    123c:	96 95       	lsr	r25
    123e:	87 95       	ror	r24
    1240:	97 f9       	bld	r25, 7
    1242:	08 95       	ret

00001244 <malloc>:
    1244:	0f 93       	push	r16
    1246:	1f 93       	push	r17
    1248:	cf 93       	push	r28
    124a:	df 93       	push	r29
    124c:	82 30       	cpi	r24, 0x02	; 2
    124e:	91 05       	cpc	r25, r1
    1250:	10 f4       	brcc	.+4      	; 0x1256 <malloc+0x12>
    1252:	82 e0       	ldi	r24, 0x02	; 2
    1254:	90 e0       	ldi	r25, 0x00	; 0
    1256:	e0 91 5b 3e 	lds	r30, 0x3E5B	; 0x803e5b <__flp>
    125a:	f0 91 5c 3e 	lds	r31, 0x3E5C	; 0x803e5c <__flp+0x1>
    125e:	20 e0       	ldi	r18, 0x00	; 0
    1260:	30 e0       	ldi	r19, 0x00	; 0
    1262:	a0 e0       	ldi	r26, 0x00	; 0
    1264:	b0 e0       	ldi	r27, 0x00	; 0
    1266:	30 97       	sbiw	r30, 0x00	; 0
    1268:	19 f1       	breq	.+70     	; 0x12b0 <malloc+0x6c>
    126a:	40 81       	ld	r20, Z
    126c:	51 81       	ldd	r21, Z+1	; 0x01
    126e:	02 81       	ldd	r16, Z+2	; 0x02
    1270:	13 81       	ldd	r17, Z+3	; 0x03
    1272:	48 17       	cp	r20, r24
    1274:	59 07       	cpc	r21, r25
    1276:	c8 f0       	brcs	.+50     	; 0x12aa <malloc+0x66>
    1278:	84 17       	cp	r24, r20
    127a:	95 07       	cpc	r25, r21
    127c:	69 f4       	brne	.+26     	; 0x1298 <malloc+0x54>
    127e:	10 97       	sbiw	r26, 0x00	; 0
    1280:	31 f0       	breq	.+12     	; 0x128e <malloc+0x4a>
    1282:	12 96       	adiw	r26, 0x02	; 2
    1284:	0c 93       	st	X, r16
    1286:	12 97       	sbiw	r26, 0x02	; 2
    1288:	13 96       	adiw	r26, 0x03	; 3
    128a:	1c 93       	st	X, r17
    128c:	27 c0       	rjmp	.+78     	; 0x12dc <malloc+0x98>
    128e:	00 93 5b 3e 	sts	0x3E5B, r16	; 0x803e5b <__flp>
    1292:	10 93 5c 3e 	sts	0x3E5C, r17	; 0x803e5c <__flp+0x1>
    1296:	22 c0       	rjmp	.+68     	; 0x12dc <malloc+0x98>
    1298:	21 15       	cp	r18, r1
    129a:	31 05       	cpc	r19, r1
    129c:	19 f0       	breq	.+6      	; 0x12a4 <malloc+0x60>
    129e:	42 17       	cp	r20, r18
    12a0:	53 07       	cpc	r21, r19
    12a2:	18 f4       	brcc	.+6      	; 0x12aa <malloc+0x66>
    12a4:	9a 01       	movw	r18, r20
    12a6:	bd 01       	movw	r22, r26
    12a8:	ef 01       	movw	r28, r30
    12aa:	df 01       	movw	r26, r30
    12ac:	f8 01       	movw	r30, r16
    12ae:	db cf       	rjmp	.-74     	; 0x1266 <malloc+0x22>
    12b0:	21 15       	cp	r18, r1
    12b2:	31 05       	cpc	r19, r1
    12b4:	f9 f0       	breq	.+62     	; 0x12f4 <malloc+0xb0>
    12b6:	28 1b       	sub	r18, r24
    12b8:	39 0b       	sbc	r19, r25
    12ba:	24 30       	cpi	r18, 0x04	; 4
    12bc:	31 05       	cpc	r19, r1
    12be:	80 f4       	brcc	.+32     	; 0x12e0 <malloc+0x9c>
    12c0:	8a 81       	ldd	r24, Y+2	; 0x02
    12c2:	9b 81       	ldd	r25, Y+3	; 0x03
    12c4:	61 15       	cp	r22, r1
    12c6:	71 05       	cpc	r23, r1
    12c8:	21 f0       	breq	.+8      	; 0x12d2 <malloc+0x8e>
    12ca:	fb 01       	movw	r30, r22
    12cc:	82 83       	std	Z+2, r24	; 0x02
    12ce:	93 83       	std	Z+3, r25	; 0x03
    12d0:	04 c0       	rjmp	.+8      	; 0x12da <malloc+0x96>
    12d2:	80 93 5b 3e 	sts	0x3E5B, r24	; 0x803e5b <__flp>
    12d6:	90 93 5c 3e 	sts	0x3E5C, r25	; 0x803e5c <__flp+0x1>
    12da:	fe 01       	movw	r30, r28
    12dc:	32 96       	adiw	r30, 0x02	; 2
    12de:	44 c0       	rjmp	.+136    	; 0x1368 <malloc+0x124>
    12e0:	fe 01       	movw	r30, r28
    12e2:	e2 0f       	add	r30, r18
    12e4:	f3 1f       	adc	r31, r19
    12e6:	81 93       	st	Z+, r24
    12e8:	91 93       	st	Z+, r25
    12ea:	22 50       	subi	r18, 0x02	; 2
    12ec:	31 09       	sbc	r19, r1
    12ee:	28 83       	st	Y, r18
    12f0:	39 83       	std	Y+1, r19	; 0x01
    12f2:	3a c0       	rjmp	.+116    	; 0x1368 <malloc+0x124>
    12f4:	20 91 59 3e 	lds	r18, 0x3E59	; 0x803e59 <__brkval>
    12f8:	30 91 5a 3e 	lds	r19, 0x3E5A	; 0x803e5a <__brkval+0x1>
    12fc:	23 2b       	or	r18, r19
    12fe:	41 f4       	brne	.+16     	; 0x1310 <malloc+0xcc>
    1300:	20 91 02 3e 	lds	r18, 0x3E02	; 0x803e02 <__malloc_heap_start>
    1304:	30 91 03 3e 	lds	r19, 0x3E03	; 0x803e03 <__malloc_heap_start+0x1>
    1308:	20 93 59 3e 	sts	0x3E59, r18	; 0x803e59 <__brkval>
    130c:	30 93 5a 3e 	sts	0x3E5A, r19	; 0x803e5a <__brkval+0x1>
    1310:	20 91 00 3e 	lds	r18, 0x3E00	; 0x803e00 <__data_start>
    1314:	30 91 01 3e 	lds	r19, 0x3E01	; 0x803e01 <__data_start+0x1>
    1318:	21 15       	cp	r18, r1
    131a:	31 05       	cpc	r19, r1
    131c:	41 f4       	brne	.+16     	; 0x132e <malloc+0xea>
    131e:	2d b7       	in	r18, 0x3d	; 61
    1320:	3e b7       	in	r19, 0x3e	; 62
    1322:	40 91 04 3e 	lds	r20, 0x3E04	; 0x803e04 <__malloc_margin>
    1326:	50 91 05 3e 	lds	r21, 0x3E05	; 0x803e05 <__malloc_margin+0x1>
    132a:	24 1b       	sub	r18, r20
    132c:	35 0b       	sbc	r19, r21
    132e:	e0 91 59 3e 	lds	r30, 0x3E59	; 0x803e59 <__brkval>
    1332:	f0 91 5a 3e 	lds	r31, 0x3E5A	; 0x803e5a <__brkval+0x1>
    1336:	e2 17       	cp	r30, r18
    1338:	f3 07       	cpc	r31, r19
    133a:	a0 f4       	brcc	.+40     	; 0x1364 <malloc+0x120>
    133c:	2e 1b       	sub	r18, r30
    133e:	3f 0b       	sbc	r19, r31
    1340:	28 17       	cp	r18, r24
    1342:	39 07       	cpc	r19, r25
    1344:	78 f0       	brcs	.+30     	; 0x1364 <malloc+0x120>
    1346:	ac 01       	movw	r20, r24
    1348:	4e 5f       	subi	r20, 0xFE	; 254
    134a:	5f 4f       	sbci	r21, 0xFF	; 255
    134c:	24 17       	cp	r18, r20
    134e:	35 07       	cpc	r19, r21
    1350:	48 f0       	brcs	.+18     	; 0x1364 <malloc+0x120>
    1352:	4e 0f       	add	r20, r30
    1354:	5f 1f       	adc	r21, r31
    1356:	40 93 59 3e 	sts	0x3E59, r20	; 0x803e59 <__brkval>
    135a:	50 93 5a 3e 	sts	0x3E5A, r21	; 0x803e5a <__brkval+0x1>
    135e:	81 93       	st	Z+, r24
    1360:	91 93       	st	Z+, r25
    1362:	02 c0       	rjmp	.+4      	; 0x1368 <malloc+0x124>
    1364:	e0 e0       	ldi	r30, 0x00	; 0
    1366:	f0 e0       	ldi	r31, 0x00	; 0
    1368:	cf 01       	movw	r24, r30
    136a:	df 91       	pop	r29
    136c:	cf 91       	pop	r28
    136e:	1f 91       	pop	r17
    1370:	0f 91       	pop	r16
    1372:	08 95       	ret

00001374 <free>:
    1374:	cf 93       	push	r28
    1376:	df 93       	push	r29
    1378:	00 97       	sbiw	r24, 0x00	; 0
    137a:	09 f4       	brne	.+2      	; 0x137e <free+0xa>
    137c:	81 c0       	rjmp	.+258    	; 0x1480 <free+0x10c>
    137e:	fc 01       	movw	r30, r24
    1380:	32 97       	sbiw	r30, 0x02	; 2
    1382:	12 82       	std	Z+2, r1	; 0x02
    1384:	13 82       	std	Z+3, r1	; 0x03
    1386:	a0 91 5b 3e 	lds	r26, 0x3E5B	; 0x803e5b <__flp>
    138a:	b0 91 5c 3e 	lds	r27, 0x3E5C	; 0x803e5c <__flp+0x1>
    138e:	10 97       	sbiw	r26, 0x00	; 0
    1390:	81 f4       	brne	.+32     	; 0x13b2 <free+0x3e>
    1392:	20 81       	ld	r18, Z
    1394:	31 81       	ldd	r19, Z+1	; 0x01
    1396:	82 0f       	add	r24, r18
    1398:	93 1f       	adc	r25, r19
    139a:	20 91 59 3e 	lds	r18, 0x3E59	; 0x803e59 <__brkval>
    139e:	30 91 5a 3e 	lds	r19, 0x3E5A	; 0x803e5a <__brkval+0x1>
    13a2:	28 17       	cp	r18, r24
    13a4:	39 07       	cpc	r19, r25
    13a6:	51 f5       	brne	.+84     	; 0x13fc <free+0x88>
    13a8:	e0 93 59 3e 	sts	0x3E59, r30	; 0x803e59 <__brkval>
    13ac:	f0 93 5a 3e 	sts	0x3E5A, r31	; 0x803e5a <__brkval+0x1>
    13b0:	67 c0       	rjmp	.+206    	; 0x1480 <free+0x10c>
    13b2:	ed 01       	movw	r28, r26
    13b4:	20 e0       	ldi	r18, 0x00	; 0
    13b6:	30 e0       	ldi	r19, 0x00	; 0
    13b8:	ce 17       	cp	r28, r30
    13ba:	df 07       	cpc	r29, r31
    13bc:	40 f4       	brcc	.+16     	; 0x13ce <free+0x5a>
    13be:	4a 81       	ldd	r20, Y+2	; 0x02
    13c0:	5b 81       	ldd	r21, Y+3	; 0x03
    13c2:	9e 01       	movw	r18, r28
    13c4:	41 15       	cp	r20, r1
    13c6:	51 05       	cpc	r21, r1
    13c8:	f1 f0       	breq	.+60     	; 0x1406 <free+0x92>
    13ca:	ea 01       	movw	r28, r20
    13cc:	f5 cf       	rjmp	.-22     	; 0x13b8 <free+0x44>
    13ce:	c2 83       	std	Z+2, r28	; 0x02
    13d0:	d3 83       	std	Z+3, r29	; 0x03
    13d2:	40 81       	ld	r20, Z
    13d4:	51 81       	ldd	r21, Z+1	; 0x01
    13d6:	84 0f       	add	r24, r20
    13d8:	95 1f       	adc	r25, r21
    13da:	c8 17       	cp	r28, r24
    13dc:	d9 07       	cpc	r29, r25
    13de:	59 f4       	brne	.+22     	; 0x13f6 <free+0x82>
    13e0:	88 81       	ld	r24, Y
    13e2:	99 81       	ldd	r25, Y+1	; 0x01
    13e4:	84 0f       	add	r24, r20
    13e6:	95 1f       	adc	r25, r21
    13e8:	02 96       	adiw	r24, 0x02	; 2
    13ea:	80 83       	st	Z, r24
    13ec:	91 83       	std	Z+1, r25	; 0x01
    13ee:	8a 81       	ldd	r24, Y+2	; 0x02
    13f0:	9b 81       	ldd	r25, Y+3	; 0x03
    13f2:	82 83       	std	Z+2, r24	; 0x02
    13f4:	93 83       	std	Z+3, r25	; 0x03
    13f6:	21 15       	cp	r18, r1
    13f8:	31 05       	cpc	r19, r1
    13fa:	29 f4       	brne	.+10     	; 0x1406 <free+0x92>
    13fc:	e0 93 5b 3e 	sts	0x3E5B, r30	; 0x803e5b <__flp>
    1400:	f0 93 5c 3e 	sts	0x3E5C, r31	; 0x803e5c <__flp+0x1>
    1404:	3d c0       	rjmp	.+122    	; 0x1480 <free+0x10c>
    1406:	e9 01       	movw	r28, r18
    1408:	ea 83       	std	Y+2, r30	; 0x02
    140a:	fb 83       	std	Y+3, r31	; 0x03
    140c:	49 91       	ld	r20, Y+
    140e:	59 91       	ld	r21, Y+
    1410:	c4 0f       	add	r28, r20
    1412:	d5 1f       	adc	r29, r21
    1414:	ec 17       	cp	r30, r28
    1416:	fd 07       	cpc	r31, r29
    1418:	61 f4       	brne	.+24     	; 0x1432 <free+0xbe>
    141a:	80 81       	ld	r24, Z
    141c:	91 81       	ldd	r25, Z+1	; 0x01
    141e:	84 0f       	add	r24, r20
    1420:	95 1f       	adc	r25, r21
    1422:	02 96       	adiw	r24, 0x02	; 2
    1424:	e9 01       	movw	r28, r18
    1426:	88 83       	st	Y, r24
    1428:	99 83       	std	Y+1, r25	; 0x01
    142a:	82 81       	ldd	r24, Z+2	; 0x02
    142c:	93 81       	ldd	r25, Z+3	; 0x03
    142e:	8a 83       	std	Y+2, r24	; 0x02
    1430:	9b 83       	std	Y+3, r25	; 0x03
    1432:	e0 e0       	ldi	r30, 0x00	; 0
    1434:	f0 e0       	ldi	r31, 0x00	; 0
    1436:	12 96       	adiw	r26, 0x02	; 2
    1438:	8d 91       	ld	r24, X+
    143a:	9c 91       	ld	r25, X
    143c:	13 97       	sbiw	r26, 0x03	; 3
    143e:	00 97       	sbiw	r24, 0x00	; 0
    1440:	19 f0       	breq	.+6      	; 0x1448 <free+0xd4>
    1442:	fd 01       	movw	r30, r26
    1444:	dc 01       	movw	r26, r24
    1446:	f7 cf       	rjmp	.-18     	; 0x1436 <free+0xc2>
    1448:	8d 91       	ld	r24, X+
    144a:	9c 91       	ld	r25, X
    144c:	11 97       	sbiw	r26, 0x01	; 1
    144e:	9d 01       	movw	r18, r26
    1450:	2e 5f       	subi	r18, 0xFE	; 254
    1452:	3f 4f       	sbci	r19, 0xFF	; 255
    1454:	82 0f       	add	r24, r18
    1456:	93 1f       	adc	r25, r19
    1458:	20 91 59 3e 	lds	r18, 0x3E59	; 0x803e59 <__brkval>
    145c:	30 91 5a 3e 	lds	r19, 0x3E5A	; 0x803e5a <__brkval+0x1>
    1460:	28 17       	cp	r18, r24
    1462:	39 07       	cpc	r19, r25
    1464:	69 f4       	brne	.+26     	; 0x1480 <free+0x10c>
    1466:	30 97       	sbiw	r30, 0x00	; 0
    1468:	29 f4       	brne	.+10     	; 0x1474 <free+0x100>
    146a:	10 92 5b 3e 	sts	0x3E5B, r1	; 0x803e5b <__flp>
    146e:	10 92 5c 3e 	sts	0x3E5C, r1	; 0x803e5c <__flp+0x1>
    1472:	02 c0       	rjmp	.+4      	; 0x1478 <free+0x104>
    1474:	12 82       	std	Z+2, r1	; 0x02
    1476:	13 82       	std	Z+3, r1	; 0x03
    1478:	a0 93 59 3e 	sts	0x3E59, r26	; 0x803e59 <__brkval>
    147c:	b0 93 5a 3e 	sts	0x3E5A, r27	; 0x803e5a <__brkval+0x1>
    1480:	df 91       	pop	r29
    1482:	cf 91       	pop	r28
    1484:	08 95       	ret

00001486 <_exit>:
    1486:	f8 94       	cli

00001488 <__stop_program>:
    1488:	ff cf       	rjmp	.-2      	; 0x1488 <__stop_program>
