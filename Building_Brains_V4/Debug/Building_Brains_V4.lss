
Building_Brains_V4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000016  00803e00  00001648  000016fc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000161c  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000002c  0000961c  0000161c  000016d0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .bss          00000059  00803e16  00803e16  00001712  2**0
                  ALLOC
  4 .comment      00000030  00000000  00000000  00001712  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001744  2**2
                  CONTENTS, READONLY
  6 .debug_aranges 000004c0  00000000  00000000  00001780  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00007a7e  00000000  00000000  00001c40  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00003063  00000000  00000000  000096be  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000274d  00000000  00000000  0000c721  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000007f0  00000000  00000000  0000ee70  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00003001  00000000  00000000  0000f660  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000012a0  00000000  00000000  00012661  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000338  00000000  00000000  00013901  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	3c c0       	rjmp	.+120    	; 0x7a <__ctors_end>
       2:	56 c0       	rjmp	.+172    	; 0xb0 <__bad_interrupt>
       4:	55 c0       	rjmp	.+170    	; 0xb0 <__bad_interrupt>
       6:	54 c0       	rjmp	.+168    	; 0xb0 <__bad_interrupt>
       8:	53 c0       	rjmp	.+166    	; 0xb0 <__bad_interrupt>
       a:	52 c0       	rjmp	.+164    	; 0xb0 <__bad_interrupt>
       c:	9a c6       	rjmp	.+3380   	; 0xd42 <__vector_6>
       e:	50 c0       	rjmp	.+160    	; 0xb0 <__bad_interrupt>
      10:	4f c0       	rjmp	.+158    	; 0xb0 <__bad_interrupt>
      12:	4e c0       	rjmp	.+156    	; 0xb0 <__bad_interrupt>
      14:	4d c0       	rjmp	.+154    	; 0xb0 <__bad_interrupt>
      16:	4c c0       	rjmp	.+152    	; 0xb0 <__bad_interrupt>
      18:	4b c0       	rjmp	.+150    	; 0xb0 <__bad_interrupt>
      1a:	4a c0       	rjmp	.+148    	; 0xb0 <__bad_interrupt>
      1c:	49 c0       	rjmp	.+146    	; 0xb0 <__bad_interrupt>
      1e:	48 c0       	rjmp	.+144    	; 0xb0 <__bad_interrupt>
      20:	47 c0       	rjmp	.+142    	; 0xb0 <__bad_interrupt>
      22:	46 c0       	rjmp	.+140    	; 0xb0 <__bad_interrupt>
      24:	45 c0       	rjmp	.+138    	; 0xb0 <__bad_interrupt>
      26:	44 c0       	rjmp	.+136    	; 0xb0 <__bad_interrupt>
      28:	43 c0       	rjmp	.+134    	; 0xb0 <__bad_interrupt>
      2a:	42 c0       	rjmp	.+132    	; 0xb0 <__bad_interrupt>
      2c:	41 c0       	rjmp	.+130    	; 0xb0 <__bad_interrupt>
      2e:	40 c0       	rjmp	.+128    	; 0xb0 <__bad_interrupt>
      30:	3f c0       	rjmp	.+126    	; 0xb0 <__bad_interrupt>
      32:	3e c0       	rjmp	.+124    	; 0xb0 <__bad_interrupt>
      34:	07 63       	ori	r16, 0x37	; 55
      36:	42 36       	cpi	r20, 0x62	; 98
      38:	b7 9b       	sbis	0x16, 7	; 22
      3a:	d8 a7       	std	Y+40, r29	; 0x28
      3c:	1a 39       	cpi	r17, 0x9A	; 154
      3e:	68 56       	subi	r22, 0x68	; 104
      40:	18 ae       	std	Y+56, r1	; 0x38
      42:	ba ab       	std	Y+50, r27	; 0x32
      44:	55 8c       	ldd	r5, Z+29	; 0x1d
      46:	1d 3c       	cpi	r17, 0xCD	; 205
      48:	b7 cc       	rjmp	.-1682   	; 0xfffff9b8 <__eeprom_end+0xff7ef9b8>
      4a:	57 63       	ori	r21, 0x37	; 55
      4c:	bd 6d       	ori	r27, 0xDD	; 221
      4e:	ed fd       	.word	0xfded	; ????
      50:	75 3e       	cpi	r23, 0xE5	; 229
      52:	f6 17       	cp	r31, r22
      54:	72 31       	cpi	r23, 0x12	; 18
      56:	bf 00       	.word	0x00bf	; ????
      58:	00 00       	nop
      5a:	80 3f       	cpi	r24, 0xF0	; 240
      5c:	05 a8       	ldd	r0, Z+53	; 0x35
      5e:	4c cd       	rjmp	.-1384   	; 0xfffffaf8 <__eeprom_end+0xff7efaf8>
      60:	b2 d4       	rcall	.+2404   	; 0x9c6 <tinyAxon_add_pulse+0x2c>
      62:	4e b9       	out	0x0e, r20	; 14
      64:	38 36       	cpi	r19, 0x68	; 104
      66:	a9 02       	muls	r26, r25
      68:	0c 50       	subi	r16, 0x0C	; 12
      6a:	b9 91       	ld	r27, Y+
      6c:	86 88       	ldd	r8, Z+22	; 0x16
      6e:	08 3c       	cpi	r16, 0xC8	; 200
      70:	a6 aa       	std	Z+54, r10	; 0x36
      72:	aa 2a       	or	r10, r26
      74:	be 00       	.word	0x00be	; ????
      76:	00 00       	nop
      78:	80 3f       	cpi	r24, 0xF0	; 240

0000007a <__ctors_end>:
      7a:	11 24       	eor	r1, r1
      7c:	1f be       	out	0x3f, r1	; 63
      7e:	cf ef       	ldi	r28, 0xFF	; 255
      80:	cd bf       	out	0x3d, r28	; 61
      82:	df e3       	ldi	r29, 0x3F	; 63
      84:	de bf       	out	0x3e, r29	; 62

00000086 <__do_copy_data>:
      86:	1e e3       	ldi	r17, 0x3E	; 62
      88:	a0 e0       	ldi	r26, 0x00	; 0
      8a:	be e3       	ldi	r27, 0x3E	; 62
      8c:	e8 e4       	ldi	r30, 0x48	; 72
      8e:	f6 e1       	ldi	r31, 0x16	; 22
      90:	02 c0       	rjmp	.+4      	; 0x96 <__do_copy_data+0x10>
      92:	05 90       	lpm	r0, Z+
      94:	0d 92       	st	X+, r0
      96:	a6 31       	cpi	r26, 0x16	; 22
      98:	b1 07       	cpc	r27, r17
      9a:	d9 f7       	brne	.-10     	; 0x92 <__do_copy_data+0xc>

0000009c <__do_clear_bss>:
      9c:	2e e3       	ldi	r18, 0x3E	; 62
      9e:	a6 e1       	ldi	r26, 0x16	; 22
      a0:	be e3       	ldi	r27, 0x3E	; 62
      a2:	01 c0       	rjmp	.+2      	; 0xa6 <.do_clear_bss_start>

000000a4 <.do_clear_bss_loop>:
      a4:	1d 92       	st	X+, r1

000000a6 <.do_clear_bss_start>:
      a6:	af 36       	cpi	r26, 0x6F	; 111
      a8:	b2 07       	cpc	r27, r18
      aa:	e1 f7       	brne	.-8      	; 0xa4 <.do_clear_bss_loop>
      ac:	cc d1       	rcall	.+920    	; 0x446 <main>
      ae:	b4 ca       	rjmp	.-2712   	; 0xfffff618 <__eeprom_end+0xff7ef618>

000000b0 <__bad_interrupt>:
      b0:	a7 cf       	rjmp	.-178    	; 0x0 <__vectors>

000000b2 <atmel_start_init>:
/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
	system_init();
      b2:	ce d0       	rcall	.+412    	; 0x250 <system_init>
      b4:	08 95       	ret

000000b6 <ADC_init>:
 * \return Conversion result read from the ADC ADC module
 */
adc_result_t ADC_get_conversion_result(void)
{
	return (ADC0.RES);
}
      b6:	85 e0       	ldi	r24, 0x05	; 5
      b8:	80 93 00 06 	sts	0x0600, r24	; 0x800600 <__TEXT_REGION_LENGTH__+0x700600>
      bc:	80 e0       	ldi	r24, 0x00	; 0
      be:	08 95       	ret

000000c0 <ADC_is_conversion_done>:
      c0:	80 91 0b 06 	lds	r24, 0x060B	; 0x80060b <__TEXT_REGION_LENGTH__+0x70060b>
      c4:	81 70       	andi	r24, 0x01	; 1
      c6:	08 95       	ret

000000c8 <ADC_get_conversion>:
 *
 * \return Nothing
 */
void ADC_start_conversion(adc_0_channel_t channel)
{
	ADC0.MUXPOS  = channel;
      c8:	e0 e0       	ldi	r30, 0x00	; 0
      ca:	f6 e0       	ldi	r31, 0x06	; 6
      cc:	86 83       	std	Z+6, r24	; 0x06
	ADC0.COMMAND = ADC_STCONV_bm;
      ce:	81 e0       	ldi	r24, 0x01	; 1
      d0:	80 87       	std	Z+8, r24	; 0x08
adc_result_t ADC_get_conversion(adc_0_channel_t channel)
{
	adc_result_t res;

	ADC_start_conversion(channel);
	while (!ADC_is_conversion_done())
      d2:	f6 df       	rcall	.-20     	; 0xc0 <ADC_is_conversion_done>
      d4:	88 23       	and	r24, r24
      d6:	e9 f3       	breq	.-6      	; 0xd2 <ADC_get_conversion+0xa>
 *
 * \return Conversion result read from the ADC ADC module
 */
adc_result_t ADC_get_conversion_result(void)
{
	return (ADC0.RES);
      d8:	e0 e0       	ldi	r30, 0x00	; 0
      da:	f6 e0       	ldi	r31, 0x06	; 6
      dc:	20 89       	ldd	r18, Z+16	; 0x10
      de:	31 89       	ldd	r19, Z+17	; 0x11

	ADC_start_conversion(channel);
	while (!ADC_is_conversion_done())
		;
	res = ADC_get_conversion_result();
	ADC0.INTFLAGS |= ADC_RESRDY_bm;
      e0:	93 85       	ldd	r25, Z+11	; 0x0b
      e2:	91 60       	ori	r25, 0x01	; 1
      e4:	93 87       	std	Z+11, r25	; 0x0b
	return res;
}
      e6:	c9 01       	movw	r24, r18
      e8:	08 95       	ret

000000ea <BOD_init>:
	//		 | BOD_VLMCFG_ABOVE_gc; /* Interrupt when supply goes above VLM level */

	// BOD.VLMCTRLA = BOD_VLMLVL_5ABOVE_gc; /* VLM threshold 5% above BOD level */

	return 0;
}
      ea:	80 e0       	ldi	r24, 0x00	; 0
      ec:	08 95       	ret

000000ee <DIGGSIGG_init>:
	//		 | CCL_EDGEDET_DIS_gc /* Edge detector is disabled */
	//		 | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	//		 | 0 << CCL_ENABLE_bp /* LUT Enable: disabled */
	//		 | 0 << CCL_OUTEN_bp; /* Output Enable: disabled */

	CCL.TRUTH1 = 168; /* Truth 1: 168 */
      ee:	e0 ec       	ldi	r30, 0xC0	; 192
      f0:	f1 e0       	ldi	r31, 0x01	; 1
      f2:	88 ea       	ldi	r24, 0xA8	; 168
      f4:	84 87       	std	Z+12, r24	; 0x0c

	CCL.LUT1CTRLC = CCL_INSEL2_TCA0_gc /* TCA0 WO2 input source */;
      f6:	88 e0       	ldi	r24, 0x08	; 8
      f8:	83 87       	std	Z+11, r24	; 0x0b

	CCL.LUT1CTRLB = CCL_INSEL0_SPI0_gc /* SPI0 SCK source */
      fa:	8b eb       	ldi	r24, 0xBB	; 187
      fc:	82 87       	std	Z+10, r24	; 0x0a
	                | CCL_INSEL1_SPI0_gc /* SPI0 MOSI input source */;

	CCL.LUT1CTRLA = 0 << CCL_CLKSRC_bp       /* Clock Source Selection: disabled */
      fe:	89 e0       	ldi	r24, 0x09	; 9
     100:	81 87       	std	Z+9, r24	; 0x09
	                | CCL_EDGEDET_DIS_gc     /* Edge detector is disabled */
	                | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	                | 1 << CCL_ENABLE_bp     /* LUT Enable: enabled */
	                | 1 << CCL_OUTEN_bp;     /* Output Enable: enabled */

	CCL.CTRLA = 1 << CCL_ENABLE_bp      /* Enable: enabled */
     102:	81 e4       	ldi	r24, 0x41	; 65
     104:	80 83       	st	Z, r24
	            | 1 << CCL_RUNSTDBY_bp; /* Run in Standby: enabled */

	return 0;
}
     106:	80 e0       	ldi	r24, 0x00	; 0
     108:	08 95       	ret

0000010a <CLKCTRL_init>:
 *       on calling convention. The memory model is not visible to the
 *       preprocessor, so it must be defined in the Assembler preprocessor directives.
 */
static inline void ccp_write_io(void *addr, uint8_t value)
{
	protected_write_io(addr, CCP_IOREG_gc, value);
     10a:	47 e0       	ldi	r20, 0x07	; 7
     10c:	68 ed       	ldi	r22, 0xD8	; 216
     10e:	8c e7       	ldi	r24, 0x7C	; 124
     110:	90 e0       	ldi	r25, 0x00	; 0
     112:	b9 d0       	rcall	.+370    	; 0x286 <protected_write_io>
     114:	41 e0       	ldi	r20, 0x01	; 1
     116:	68 ed       	ldi	r22, 0xD8	; 216
     118:	81 e6       	ldi	r24, 0x61	; 97
     11a:	90 e0       	ldi	r25, 0x00	; 0
     11c:	b4 d0       	rcall	.+360    	; 0x286 <protected_write_io>
	//		 | 0 << CLKCTRL_CLKOUT_bp /* System clock out: disabled */);

	// ccp_write_io((void*)&(CLKCTRL.MCLKLOCK),0 << CLKCTRL_LOCKEN_bp /* lock enable: disabled */);

	return 0;
}
     11e:	80 e0       	ldi	r24, 0x00	; 0
     120:	08 95       	ret

00000122 <CPUINT_init>:

	// CPUINT.LVL0PRI = 0x0 << CPUINT_LVL0PRI_gp; /* Interrupt Level Priority: 0x0 */

	// CPUINT.LVL1VEC = 0x0 << CPUINT_LVL1VEC_gp; /* Interrupt Vector with High Priority: 0x0 */

	ENABLE_INTERRUPTS();
     122:	78 94       	sei

	return 0;
}
     124:	80 e0       	ldi	r24, 0x00	; 0
     126:	08 95       	ret

00000128 <DAC_init>:
int8_t DAC_init()
{

	// DAC0.DATA = 0x0; /* DATA Register: 0x0 */

	DAC0.CTRLA = 1 << DAC_ENABLE_bp      /* DAC Enable: enabled */
     128:	81 e4       	ldi	r24, 0x41	; 65
     12a:	80 93 80 06 	sts	0x0680, r24	; 0x800680 <__TEXT_REGION_LENGTH__+0x700680>
	             | 1 << DAC_OUTEN_bp     /* Output Buffer Enable: enabled */
	             | 0 << DAC_RUNSTDBY_bp; /* Run in Standby Mode: disabled */

	return 0;
}
     12e:	80 e0       	ldi	r24, 0x00	; 0
     130:	08 95       	ret

00000132 <DAC_enable>:
 *
 * \return Nothing
 */
void DAC_enable()
{
	DAC0.CTRLA |= DAC_ENABLE_bm;
     132:	e0 e8       	ldi	r30, 0x80	; 128
     134:	f6 e0       	ldi	r31, 0x06	; 6
     136:	80 81       	ld	r24, Z
     138:	81 60       	ori	r24, 0x01	; 1
     13a:	80 83       	st	Z, r24
     13c:	08 95       	ret

0000013e <DAC_disable>:
 *
 * \return Nothing
 */
void DAC_disable()
{
	DAC0.CTRLA &= ~DAC_ENABLE_bm;
     13e:	e0 e8       	ldi	r30, 0x80	; 128
     140:	f6 e0       	ldi	r31, 0x06	; 6
     142:	80 81       	ld	r24, Z
     144:	8e 7f       	andi	r24, 0xFE	; 254
     146:	80 83       	st	Z, r24
     148:	08 95       	ret

0000014a <DAC_set_output>:
 *
 * \return Nothing
 */
void DAC_set_output(dac_resolution_t value)
{
	DAC0.DATA = value;
     14a:	80 93 81 06 	sts	0x0681, r24	; 0x800681 <__TEXT_REGION_LENGTH__+0x700681>
     14e:	08 95       	ret

00000150 <mcu_init>:
#ifdef __cplusplus
extern "C" {
#endif

void mcu_init(void)
{
     150:	e0 e1       	ldi	r30, 0x10	; 16
     152:	f4 e0       	ldi	r31, 0x04	; 4
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     154:	80 81       	ld	r24, Z
     156:	88 60       	ori	r24, 0x08	; 8
     158:	81 93       	st	Z+, r24
	 * disables all peripherals to save power. Driver shall enable
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
     15a:	e8 31       	cpi	r30, 0x18	; 24
     15c:	84 e0       	ldi	r24, 0x04	; 4
     15e:	f8 07       	cpc	r31, r24
     160:	c9 f7       	brne	.-14     	; 0x154 <mcu_init+0x4>
     162:	e0 e3       	ldi	r30, 0x30	; 48
     164:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     166:	80 81       	ld	r24, Z
     168:	88 60       	ori	r24, 0x08	; 8
     16a:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     16c:	e8 33       	cpi	r30, 0x38	; 56
     16e:	84 e0       	ldi	r24, 0x04	; 4
     170:	f8 07       	cpc	r31, r24
     172:	c9 f7       	brne	.-14     	; 0x166 <mcu_init+0x16>
     174:	e0 e5       	ldi	r30, 0x50	; 80
     176:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     178:	80 81       	ld	r24, Z
     17a:	88 60       	ori	r24, 0x08	; 8
     17c:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     17e:	e8 35       	cpi	r30, 0x58	; 88
     180:	84 e0       	ldi	r24, 0x04	; 4
     182:	f8 07       	cpc	r31, r24
     184:	c9 f7       	brne	.-14     	; 0x178 <mcu_init+0x28>
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}
}
     186:	08 95       	ret

00000188 <ADC_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     188:	e5 e1       	ldi	r30, 0x15	; 21
     18a:	f4 e0       	ldi	r31, 0x04	; 4
     18c:	80 81       	ld	r24, Z
     18e:	88 7f       	andi	r24, 0xF8	; 248
     190:	84 60       	ori	r24, 0x04	; 4
     192:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     194:	80 81       	ld	r24, Z
     196:	87 7f       	andi	r24, 0xF7	; 247
     198:	80 83       	st	Z, r24
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     19a:	e7 e1       	ldi	r30, 0x17	; 23
     19c:	f4 e0       	ldi	r31, 0x04	; 4
     19e:	80 81       	ld	r24, Z
     1a0:	88 7f       	andi	r24, 0xF8	; 248
     1a2:	84 60       	ori	r24, 0x04	; 4
     1a4:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     1a6:	80 81       	ld	r24, Z
     1a8:	87 7f       	andi	r24, 0xF7	; 247
     1aa:	80 83       	st	Z, r24
 */
static inline void PORTB_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     1ac:	e4 e3       	ldi	r30, 0x34	; 52
     1ae:	f4 e0       	ldi	r31, 0x04	; 4
     1b0:	80 81       	ld	r24, Z
     1b2:	88 7f       	andi	r24, 0xF8	; 248
     1b4:	84 60       	ori	r24, 0x04	; 4
     1b6:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     1b8:	80 81       	ld	r24, Z
     1ba:	87 7f       	andi	r24, 0xF7	; 247
     1bc:	80 83       	st	Z, r24
 */
static inline void PORTB_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     1be:	e1 e3       	ldi	r30, 0x31	; 49
     1c0:	f4 e0       	ldi	r31, 0x04	; 4
     1c2:	80 81       	ld	r24, Z
     1c4:	88 7f       	andi	r24, 0xF8	; 248
     1c6:	84 60       	ori	r24, 0x04	; 4
     1c8:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     1ca:	80 81       	ld	r24, Z
     1cc:	87 7f       	andi	r24, 0xF7	; 247
     1ce:	80 83       	st	Z, r24
 */
static inline void PORTB_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     1d0:	e0 e3       	ldi	r30, 0x30	; 48
     1d2:	f4 e0       	ldi	r31, 0x04	; 4
     1d4:	80 81       	ld	r24, Z
     1d6:	88 7f       	andi	r24, 0xF8	; 248
     1d8:	84 60       	ori	r24, 0x04	; 4
     1da:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     1dc:	80 81       	ld	r24, Z
     1de:	87 7f       	andi	r24, 0xF7	; 247
     1e0:	80 83       	st	Z, r24
	// Disable digital input buffer
	DEN4_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	DEN4_PIN_set_pull_mode(PORT_PULL_OFF);

	ADC_init();
     1e2:	69 df       	rcall	.-302    	; 0xb6 <ADC_init>
     1e4:	08 95       	ret

000001e6 <USART_0_initialization>:
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     1e6:	23 98       	cbi	0x04, 3	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     1e8:	e3 e3       	ldi	r30, 0x33	; 51
     1ea:	f4 e0       	ldi	r31, 0x04	; 4
     1ec:	80 81       	ld	r24, Z
     1ee:	87 7f       	andi	r24, 0xF7	; 247
     1f0:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     1f2:	22 9a       	sbi	0x04, 2	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     1f4:	2a 98       	cbi	0x05, 2	; 5
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	USART_0_init();
     1f6:	81 d0       	rcall	.+258    	; 0x2fa <USART_0_init>
     1f8:	08 95       	ret

000001fa <TIMER_0_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     1fa:	25 9a       	sbi	0x04, 5	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     1fc:	2d 98       	cbi	0x05, 5	; 5
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLC |= PORTMUX_TCA02_bm;
     1fe:	e0 e0       	ldi	r30, 0x00	; 0
     200:	f2 e0       	ldi	r31, 0x02	; 2
     202:	82 81       	ldd	r24, Z+2	; 0x02
     204:	84 60       	ori	r24, 0x04	; 4
     206:	82 83       	std	Z+2, r24	; 0x02

	TIMER_0_init();
     208:	68 d0       	rcall	.+208    	; 0x2da <TIMER_0_init>
     20a:	08 95       	ret

0000020c <DIGGSIGG_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTC.DIR |= (1 << pin);
     20c:	41 9a       	sbi	0x08, 1	; 8
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
	} else {
		VPORTC.OUT &= ~(1 << pin);
     20e:	49 98       	cbi	0x09, 1	; 9
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLA |= PORTMUX_LUT1_bm;
     210:	e0 e0       	ldi	r30, 0x00	; 0
     212:	f2 e0       	ldi	r31, 0x02	; 2
     214:	80 81       	ld	r24, Z
     216:	80 62       	ori	r24, 0x20	; 32
     218:	80 83       	st	Z, r24

	DIGGSIGG_init();
     21a:	69 df       	rcall	.-302    	; 0xee <DIGGSIGG_init>
     21c:	08 95       	ret

0000021e <SPI_0_initialization>:
 */
static inline void PORTA_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
     21e:	02 98       	cbi	0x00, 2	; 0
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     220:	e2 e1       	ldi	r30, 0x12	; 18
     222:	f4 e0       	ldi	r31, 0x04	; 4
     224:	80 81       	ld	r24, Z
     226:	87 7f       	andi	r24, 0xF7	; 247
     228:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     22a:	01 9a       	sbi	0x00, 1	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     22c:	09 98       	cbi	0x01, 1	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     22e:	03 9a       	sbi	0x00, 3	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     230:	0b 98       	cbi	0x01, 3	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     232:	04 9a       	sbi	0x00, 4	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     234:	0c 98       	cbi	0x01, 4	; 1
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	SPI_0_init();
     236:	49 d0       	rcall	.+146    	; 0x2ca <SPI_0_init>
     238:	08 95       	ret

0000023a <DAC_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     23a:	e6 e1       	ldi	r30, 0x16	; 22
     23c:	f4 e0       	ldi	r31, 0x04	; 4
     23e:	80 81       	ld	r24, Z
     240:	88 7f       	andi	r24, 0xF8	; 248
     242:	84 60       	ori	r24, 0x04	; 4
     244:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     246:	80 81       	ld	r24, Z
     248:	87 7f       	andi	r24, 0xF7	; 247
     24a:	80 83       	st	Z, r24
	// Disable digital input buffer
	AXON_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	AXON_PIN_set_pull_mode(PORT_PULL_OFF);

	DAC_init();
     24c:	6d df       	rcall	.-294    	; 0x128 <DAC_init>
     24e:	08 95       	ret

00000250 <system_init>:
/**
 * \brief System initialization
 */
void system_init()
{
	mcu_init();
     250:	7f df       	rcall	.-258    	; 0x150 <mcu_init>
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     252:	27 98       	cbi	0x04, 7	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     254:	e7 e3       	ldi	r30, 0x37	; 55
     256:	f4 e0       	ldi	r31, 0x04	; 4
     258:	80 81       	ld	r24, Z
     25a:	87 7f       	andi	r24, 0xF7	; 247
     25c:	80 83       	st	Z, r24
 */
static inline void PORTC_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
     25e:	42 98       	cbi	0x08, 2	; 8
static inline void PORTC_set_pin_pull_mode(const uint8_t pin, const enum port_pull_mode pull_mode)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
     260:	e2 e5       	ldi	r30, 0x52	; 82
     262:	f4 e0       	ldi	r31, 0x04	; 4
     264:	80 81       	ld	r24, Z
     266:	88 60       	ori	r24, 0x08	; 8
     268:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTC.DIR |= (1 << pin);
     26a:	45 9a       	sbi	0x08, 5	; 8
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     26c:	4d 9a       	sbi	0x09, 5	; 9
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    true);

	CLKCTRL_init();
     26e:	4d df       	rcall	.-358    	; 0x10a <CLKCTRL_init>

	RTC_init();
     270:	0e d0       	rcall	.+28     	; 0x28e <RTC_init>

	ADC_initialization();
     272:	8a df       	rcall	.-236    	; 0x188 <ADC_initialization>

	USART_0_initialization();
     274:	b8 df       	rcall	.-144    	; 0x1e6 <USART_0_initialization>

	TIMER_0_initialization();
     276:	c1 df       	rcall	.-126    	; 0x1fa <TIMER_0_initialization>

	DIGGSIGG_initialization();
     278:	c9 df       	rcall	.-110    	; 0x20c <DIGGSIGG_initialization>

	SPI_0_initialization();
     27a:	d1 df       	rcall	.-94     	; 0x21e <SPI_0_initialization>

	DAC_initialization();
     27c:	de df       	rcall	.-68     	; 0x23a <DAC_initialization>

	CPUINT_init();
     27e:	51 df       	rcall	.-350    	; 0x122 <CPUINT_init>

	SLPCTRL_init();
     280:	22 d0       	rcall	.+68     	; 0x2c6 <SLPCTRL_init>

	BOD_init();
     282:	33 df       	rcall	.-410    	; 0xea <BOD_init>
     284:	08 95       	ret

00000286 <protected_write_io>:
#if defined(__GNUC__)
  
#ifdef RAMPZ
	out     _SFR_IO_ADDR(RAMPZ), r1         // Clear bits 23:16 of Z
#endif
	movw    r30, r24                // Load addr into Z
     286:	fc 01       	movw	r30, r24
	out     CCP, r22                // Start CCP handshake
     288:	64 bf       	out	0x34, r22	; 52
	st      Z, r20                  // Write value to I/O register
     28a:	40 83       	st	Z, r20
	ret                             // Return to caller
     28c:	08 95       	ret

0000028e <RTC_init>:
 * \return Initialization status.
 */
int8_t RTC_init()
{

	while (RTC.STATUS > 0) { /* Wait for all register to be synchronized */
     28e:	e0 e4       	ldi	r30, 0x40	; 64
     290:	f1 e0       	ldi	r31, 0x01	; 1
     292:	81 81       	ldd	r24, Z+1	; 0x01
     294:	81 11       	cpse	r24, r1
     296:	fd cf       	rjmp	.-6      	; 0x292 <RTC_init+0x4>
	}

	// RTC.CMP = 0x0; /* Compare: 0x0 */

	RTC.CNT = 0x20; /* Counter: 0x20 */
     298:	e0 e4       	ldi	r30, 0x40	; 64
     29a:	f1 e0       	ldi	r31, 0x01	; 1
     29c:	80 e2       	ldi	r24, 0x20	; 32
     29e:	90 e0       	ldi	r25, 0x00	; 0
     2a0:	80 87       	std	Z+8, r24	; 0x08
     2a2:	91 87       	std	Z+9, r25	; 0x09

	RTC.CTRLA = RTC_PRESCALER_DIV1_gc   /* 1 */
     2a4:	81 e8       	ldi	r24, 0x81	; 129
     2a6:	80 83       	st	Z, r24
	            | 1 << RTC_RTCEN_bp     /* Enable: enabled */
	            | 1 << RTC_RUNSTDBY_bp; /* Run In Standby: enabled */

	RTC.PER = 0x20 / TIMESCALE; /* Period: 0x20 */
     2a8:	80 e8       	ldi	r24, 0x80	; 128
     2aa:	92 e0       	ldi	r25, 0x02	; 2
     2ac:	82 87       	std	Z+10, r24	; 0x0a
     2ae:	93 87       	std	Z+11, r25	; 0x0b

	// RTC.CLKSEL = RTC_CLKSEL_INT32K_gc; /* 32KHz Internal Ultra Low Power Oscillator (OSCULP32K) */

	RTC.DBGCTRL = 1 << RTC_DBGRUN_bp; /* Run in debug: enabled */
     2b0:	81 e0       	ldi	r24, 0x01	; 1
     2b2:	85 83       	std	Z+5, r24	; 0x05

	RTC.INTCTRL = 0 << RTC_CMP_bp    /* Compare Match Interrupt enable: disabled */
     2b4:	82 83       	std	Z+2, r24	; 0x02
	              | 1 << RTC_OVF_bp; /* Overflow Interrupt enable: enabled */

	while (RTC.PITSTATUS > 0) { /* Wait for all register to be synchronized */
     2b6:	81 89       	ldd	r24, Z+17	; 0x11
     2b8:	81 11       	cpse	r24, r1
     2ba:	fd cf       	rjmp	.-6      	; 0x2b6 <RTC_init+0x28>
	}

	RTC.PITCTRLA = RTC_PERIOD_OFF_gc    /* Off */
     2bc:	81 e0       	ldi	r24, 0x01	; 1
     2be:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <__TEXT_REGION_LENGTH__+0x700150>
	// RTC.PITDBGCTRL = 0 << RTC_DBGRUN_bp; /* Run in debug: disabled */

	// RTC.PITINTCTRL = 0 << RTC_PI_bp; /* Periodic Interrupt: disabled */

	return 0;
}
     2c2:	80 e0       	ldi	r24, 0x00	; 0
     2c4:	08 95       	ret

000002c6 <SLPCTRL_init>:

	// SLPCTRL.CTRLA = 0 << SLPCTRL_SEN_bp /* Sleep enable: disabled */
	//		 | SLPCTRL_SMODE_IDLE_gc; /* Idle mode */

	return 0;
}
     2c6:	80 e0       	ldi	r24, 0x00	; 0
     2c8:	08 95       	ret

000002ca <SPI_0_init>:
 * \return Initialization status
 */
int8_t SPI_0_init()
{

	SPI0.CTRLA = 0 << SPI_CLK2X_bp     /* Enable Double Speed: disabled */
     2ca:	e0 e2       	ldi	r30, 0x20	; 32
     2cc:	f8 e0       	ldi	r31, 0x08	; 8
     2ce:	83 e2       	ldi	r24, 0x23	; 35
     2d0:	80 83       	st	Z, r24
	             | 0 << SPI_DORD_bp    /* Data Order Setting: disabled */
	             | 1 << SPI_ENABLE_bp  /* Enable Module: enabled */
	             | 1 << SPI_MASTER_bp  /* SPI module in master mode */
	             | SPI_PRESC_DIV16_gc; /* System Clock / 16 */

	SPI0.CTRLB = 0 << SPI_BUFEN_bp   /* Buffer Mode Enable: disabled */
     2d2:	84 e0       	ldi	r24, 0x04	; 4
     2d4:	81 83       	std	Z+1, r24	; 0x01
	//		 | 0 << SPI_RXCIE_bp /* Receive Complete Interrupt Enable: disabled */
	//		 | 0 << SPI_SSIE_bp /* Slave Select Trigger Interrupt Enable: disabled */
	//		 | 0 << SPI_TXCIE_bp; /* Transfer Complete Interrupt Enable: disabled */

	return 0;
}
     2d6:	80 e0       	ldi	r24, 0x00	; 0
     2d8:	08 95       	ret

000002da <TIMER_0_init>:

	// TCA0.SINGLE.CMP0 = 0x0; /* Compare Register 0: 0x0 */

	// TCA0.SINGLE.CMP1 = 0x0; /* Compare Register 1: 0x0 */

	TCA0.SINGLE.CMP2 = 0x4; /* Compare Register 2: 0x4 */
     2da:	e0 e0       	ldi	r30, 0x00	; 0
     2dc:	fa e0       	ldi	r31, 0x0A	; 10
     2de:	84 e0       	ldi	r24, 0x04	; 4
     2e0:	90 e0       	ldi	r25, 0x00	; 0
     2e2:	84 a7       	std	Z+44, r24	; 0x2c
     2e4:	95 a7       	std	Z+45, r25	; 0x2d

	// TCA0.SINGLE.CNT = 0x0; /* Count: 0x0 */

	TCA0.SINGLE.CTRLB = 0 << TCA_SINGLE_ALUPD_bp            /* Auto Lock Update: disabled */
     2e6:	83 e4       	ldi	r24, 0x43	; 67
     2e8:	81 83       	std	Z+1, r24	; 0x01
	                    | 0 << TCA_SINGLE_CMP0EN_bp         /* Compare 0 Enable: disabled */
	                    | 0 << TCA_SINGLE_CMP1EN_bp         /* Compare 1 Enable: disabled */
	                    | 1 << TCA_SINGLE_CMP2EN_bp         /* Compare 2 Enable: enabled */
	                    | TCA_SINGLE_WGMODE_SINGLESLOPE_gc; /*  */

	TCA0.SINGLE.CTRLC = 0 << TCA_SINGLE_CMP0OV_bp    /* Compare 0 Waveform Output Value: disabled */
     2ea:	84 e0       	ldi	r24, 0x04	; 4
     2ec:	82 83       	std	Z+2, r24	; 0x02
	// TCA0.SINGLE.INTCTRL = 0 << TCA_SINGLE_CMP0_bp /* Compare 0 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP1_bp /* Compare 1 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP2_bp /* Compare 2 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_OVF_bp; /* Overflow Interrupt: disabled */

	TCA0.SINGLE.PER = 0x7; /* Period: 0x7 */
     2ee:	87 e0       	ldi	r24, 0x07	; 7
     2f0:	90 e0       	ldi	r25, 0x00	; 0
     2f2:	86 a3       	std	Z+38, r24	; 0x26
     2f4:	97 a3       	std	Z+39, r25	; 0x27

	// TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV1_gc /* System Clock */
	//		 | 0 << TCA_SINGLE_ENABLE_bp; /* Module Enable: disabled */

	return 0;
}
     2f6:	80 e0       	ldi	r24, 0x00	; 0
     2f8:	08 95       	ret

000002fa <USART_0_init>:
uint8_t USART_0_read()
{
	while (!(USART0.STATUS & USART_RXCIF_bm))
		;
	return USART0.RXDATAL;
}
     2fa:	e0 e0       	ldi	r30, 0x00	; 0
     2fc:	f8 e0       	ldi	r31, 0x08	; 8
     2fe:	87 e4       	ldi	r24, 0x47	; 71
     300:	90 e1       	ldi	r25, 0x10	; 16
     302:	80 87       	std	Z+8, r24	; 0x08
     304:	91 87       	std	Z+9, r25	; 0x09
     306:	80 ec       	ldi	r24, 0xC0	; 192
     308:	86 83       	std	Z+6, r24	; 0x06
     30a:	80 e0       	ldi	r24, 0x00	; 0
     30c:	9e e3       	ldi	r25, 0x3E	; 62
     30e:	80 93 6b 3e 	sts	0x3E6B, r24	; 0x803e6b <__iob+0x2>
     312:	90 93 6c 3e 	sts	0x3E6C, r25	; 0x803e6c <__iob+0x3>
     316:	80 e0       	ldi	r24, 0x00	; 0
     318:	08 95       	ret

0000031a <USART_0_write>:
 *
 * \return Nothing
 */
void USART_0_write(const uint8_t data)
{
	while (!(USART0.STATUS & USART_DREIF_bm))
     31a:	e0 e0       	ldi	r30, 0x00	; 0
     31c:	f8 e0       	ldi	r31, 0x08	; 8
     31e:	94 81       	ldd	r25, Z+4	; 0x04
     320:	95 ff       	sbrs	r25, 5
     322:	fd cf       	rjmp	.-6      	; 0x31e <USART_0_write+0x4>
		;
	USART0.TXDATAL = data;
     324:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <__TEXT_REGION_LENGTH__+0x700802>
     328:	08 95       	ret

0000032a <USART_0_printCHAR>:

#if defined(__GNUC__)

int USART_0_printCHAR(char character, FILE *stream)
{
	USART_0_write(character);
     32a:	f7 df       	rcall	.-18     	; 0x31a <USART_0_write>
	return 0;
}
     32c:	80 e0       	ldi	r24, 0x00	; 0
     32e:	90 e0       	ldi	r25, 0x00	; 0
     330:	08 95       	ret

00000332 <tinyCharge_is_connected_to_charger>:

_Bool connected_to_charger;

_Bool tinyCharge_is_connected_to_charger(){
	return connected_to_charger;
}
     332:	80 91 5c 3e 	lds	r24, 0x3E5C	; 0x803e5c <connected_to_charger>
     336:	08 95       	ret

00000338 <tinyCharge_is_fully_charged>:
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTB_get_pin_level(const uint8_t pin)
{
	return VPORTB.IN & (1 << pin);
     338:	86 b1       	in	r24, 0x06	; 6

_Bool tinyCharge_is_fully_charged(){
	return CHARGING_STATUS_PIN_get_level();
}
     33a:	88 1f       	adc	r24, r24
     33c:	88 27       	eor	r24, r24
     33e:	88 1f       	adc	r24, r24
     340:	08 95       	ret

00000342 <tinyCharge_switch_mode>:
	}
}

void tinyCharge_switch_mode(){
	
	if(connected_to_charger){
     342:	80 91 5c 3e 	lds	r24, 0x3E5C	; 0x803e5c <connected_to_charger>
     346:	88 23       	and	r24, r24
     348:	49 f0       	breq	.+18     	; 0x35c <tinyCharge_switch_mode+0x1a>
		// Switch from main to charging mode
		
		// Set LED
		tinyLED_set_color(OUT_LED, OFF);
     34a:	60 e0       	ldi	r22, 0x00	; 0
     34c:	80 e0       	ldi	r24, 0x00	; 0
     34e:	0c d1       	rcall	.+536    	; 0x568 <tinyLED_set_color>
		tinyLED_set_color_mode(INN_LED, CHARGING_COLOR, SWING);
     350:	42 e0       	ldi	r20, 0x02	; 2
     352:	61 e0       	ldi	r22, 0x01	; 1
     354:	81 e0       	ldi	r24, 0x01	; 1
     356:	19 d1       	rcall	.+562    	; 0x58a <tinyLED_set_color_mode>
		
		// Disable DAC
		DAC_disable();
     358:	f2 de       	rcall	.-540    	; 0x13e <DAC_disable>
     35a:	08 95       	ret
	}
	else{
		// Switch from charge to main mode
		
		// Set LED
		tinyLED_set_color(OUT_LED, OFF);
     35c:	60 e0       	ldi	r22, 0x00	; 0
     35e:	80 e0       	ldi	r24, 0x00	; 0
     360:	03 d1       	rcall	.+518    	; 0x568 <tinyLED_set_color>
		tinyLED_set_color(INN_LED, OFF);
     362:	60 e0       	ldi	r22, 0x00	; 0
     364:	81 e0       	ldi	r24, 0x01	; 1
     366:	00 d1       	rcall	.+512    	; 0x568 <tinyLED_set_color>
		
		// Enable DAC
		DAC_enable();
     368:	e4 de       	rcall	.-568    	; 0x132 <DAC_enable>
     36a:	08 95       	ret

0000036c <tinyCharge_set_charging_mode>:
_Bool tinyCharge_is_fully_charged(){
	return CHARGING_STATUS_PIN_get_level();
}

void tinyCharge_set_charging_mode(_Bool charging_status){
	if(charging_status != connected_to_charger){
     36c:	90 91 5c 3e 	lds	r25, 0x3E5C	; 0x803e5c <connected_to_charger>
     370:	98 17       	cp	r25, r24
     372:	19 f0       	breq	.+6      	; 0x37a <tinyCharge_set_charging_mode+0xe>
		connected_to_charger = charging_status;
     374:	80 93 5c 3e 	sts	0x3E5C, r24	; 0x803e5c <connected_to_charger>
		tinyCharge_switch_mode();
     378:	e4 df       	rcall	.-56     	; 0x342 <tinyCharge_switch_mode>
     37a:	08 95       	ret

0000037c <tinyCharge_set_transistors>:
	}
}


void tinyCharge_set_transistors(){
	if(connected_to_charger){
     37c:	80 91 5c 3e 	lds	r24, 0x3E5C	; 0x803e5c <connected_to_charger>
     380:	88 23       	and	r24, r24
     382:	11 f0       	breq	.+4      	; 0x388 <tinyCharge_set_transistors+0xc>
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
	} else {
		VPORTC.OUT &= ~(1 << pin);
     384:	4d 98       	cbi	0x09, 5	; 9
     386:	08 95       	ret
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     388:	4d 9a       	sbi	0x09, 5	; 9
     38a:	08 95       	ret

0000038c <tinyDebugger_send_int>:
		char number[20]; // Arbitrary max
		dtostrf(value,1,NUMBER_OF_DECIMALS, number);
		printf("%s:%s;", name, number);
	}
}
void tinyDebugger_send_string(const char* name, char * value){
     38c:	08 95       	ret

0000038e <tinyDebugger_send_uint8>:
     38e:	08 95       	ret

00000390 <tinyDebugger_send_double>:
     390:	08 95       	ret

00000392 <tinyDebugger_end_line>:
	if(DEBUGGING){
		printf("%s:%s;", name, value);
	}
}
void tinyDebugger_end_line(){
     392:	08 95       	ret

00000394 <tinyPulse_toggle_pulse_mode>:
uint32_t time_of_last_pulse = 0;
uint16_t time_since_last_pulse = 0;
uint16_t ideal_time_between_pulses = 1000/PULSEMODE_FREQUENCY;

void tinyPulse_toggle_pulse_mode(){
	pulse_mode = !pulse_mode;
     394:	90 91 1c 3e 	lds	r25, 0x3E1C	; 0x803e1c <pulse_mode>
     398:	81 e0       	ldi	r24, 0x01	; 1
     39a:	89 27       	eor	r24, r25
     39c:	80 93 1c 3e 	sts	0x3E1C, r24	; 0x803e1c <pulse_mode>
     3a0:	08 95       	ret

000003a2 <tinyPulse_update_potential>:
}

double tinyPulse_update_potential(double potential){
     3a2:	cf 92       	push	r12
     3a4:	df 92       	push	r13
     3a6:	ef 92       	push	r14
     3a8:	ff 92       	push	r15
     3aa:	6b 01       	movw	r12, r22
     3ac:	7c 01       	movw	r14, r24
	if(pulse_mode){
     3ae:	80 91 1c 3e 	lds	r24, 0x3E1C	; 0x803e1c <pulse_mode>
     3b2:	88 23       	and	r24, r24
     3b4:	21 f1       	breq	.+72     	; 0x3fe <tinyPulse_update_potential+0x5c>
		
		time_since_last_pulse = tinyTime_now() - time_of_last_pulse;
     3b6:	3e d0       	rcall	.+124    	; 0x434 <tinyTime_now>
     3b8:	20 91 18 3e 	lds	r18, 0x3E18	; 0x803e18 <time_of_last_pulse>
     3bc:	30 91 19 3e 	lds	r19, 0x3E19	; 0x803e19 <time_of_last_pulse+0x1>
     3c0:	62 1b       	sub	r22, r18
     3c2:	73 0b       	sbc	r23, r19
     3c4:	60 93 16 3e 	sts	0x3E16, r22	; 0x803e16 <__data_end>
     3c8:	70 93 17 3e 	sts	0x3E17, r23	; 0x803e17 <__data_end+0x1>
		
		if(time_since_last_pulse >= ideal_time_between_pulses){
     3cc:	80 91 0e 3e 	lds	r24, 0x3E0E	; 0x803e0e <ideal_time_between_pulses>
     3d0:	90 91 0f 3e 	lds	r25, 0x3E0F	; 0x803e0f <ideal_time_between_pulses+0x1>
     3d4:	68 17       	cp	r22, r24
     3d6:	79 07       	cpc	r23, r25
     3d8:	90 f0       	brcs	.+36     	; 0x3fe <tinyPulse_update_potential+0x5c>
			potential += BUTTON_PRESS_REACTION;
     3da:	20 e0       	ldi	r18, 0x00	; 0
     3dc:	30 e0       	ldi	r19, 0x00	; 0
     3de:	40 ed       	ldi	r20, 0xD0	; 208
     3e0:	51 e4       	ldi	r21, 0x41	; 65
     3e2:	c7 01       	movw	r24, r14
     3e4:	b6 01       	movw	r22, r12
     3e6:	61 d5       	rcall	.+2754   	; 0xeaa <__addsf3>
     3e8:	6b 01       	movw	r12, r22
     3ea:	7c 01       	movw	r14, r24
			time_of_last_pulse = tinyTime_now();			
     3ec:	23 d0       	rcall	.+70     	; 0x434 <tinyTime_now>
     3ee:	60 93 18 3e 	sts	0x3E18, r22	; 0x803e18 <time_of_last_pulse>
     3f2:	70 93 19 3e 	sts	0x3E19, r23	; 0x803e19 <time_of_last_pulse+0x1>
     3f6:	80 93 1a 3e 	sts	0x3E1A, r24	; 0x803e1a <time_of_last_pulse+0x2>
     3fa:	90 93 1b 3e 	sts	0x3E1B, r25	; 0x803e1b <time_of_last_pulse+0x3>
		}
	}
	return potential;
}
     3fe:	c7 01       	movw	r24, r14
     400:	b6 01       	movw	r22, r12
     402:	ff 90       	pop	r15
     404:	ef 90       	pop	r14
     406:	df 90       	pop	r13
     408:	cf 90       	pop	r12
     40a:	08 95       	ret

0000040c <tinyTime_counter_increment>:
If the Interrupt Service Routine is clocked by a crystal oscillator
it gives a very precise timer-counter.
*/
void tinyTime_counter_increment(void)
{
	time_counter++;
     40c:	80 91 1d 3e 	lds	r24, 0x3E1D	; 0x803e1d <time_counter>
     410:	90 91 1e 3e 	lds	r25, 0x3E1E	; 0x803e1e <time_counter+0x1>
     414:	a0 91 1f 3e 	lds	r26, 0x3E1F	; 0x803e1f <time_counter+0x2>
     418:	b0 91 20 3e 	lds	r27, 0x3E20	; 0x803e20 <time_counter+0x3>
     41c:	01 96       	adiw	r24, 0x01	; 1
     41e:	a1 1d       	adc	r26, r1
     420:	b1 1d       	adc	r27, r1
     422:	80 93 1d 3e 	sts	0x3E1D, r24	; 0x803e1d <time_counter>
     426:	90 93 1e 3e 	sts	0x3E1E, r25	; 0x803e1e <time_counter+0x1>
     42a:	a0 93 1f 3e 	sts	0x3E1F, r26	; 0x803e1f <time_counter+0x2>
     42e:	b0 93 20 3e 	sts	0x3E20, r27	; 0x803e20 <time_counter+0x3>
     432:	08 95       	ret

00000434 <tinyTime_now>:
/*
This function is callable by external libraries to give them the counted time so far.
*/
uint32_t tinyTime_now(void)
{
	return time_counter;
     434:	60 91 1d 3e 	lds	r22, 0x3E1D	; 0x803e1d <time_counter>
     438:	70 91 1e 3e 	lds	r23, 0x3E1E	; 0x803e1e <time_counter+0x1>
     43c:	80 91 1f 3e 	lds	r24, 0x3E1F	; 0x803e1f <time_counter+0x2>
     440:	90 91 20 3e 	lds	r25, 0x3E20	; 0x803e20 <time_counter+0x3>
     444:	08 95       	ret

00000446 <main>:


int main(void)
{	
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
     446:	35 de       	rcall	.-918    	; 0xb2 <atmel_start_init>
	Setting this value will mean that the ADC (Analog to Digital Converter) will read 4.32v as 255, and 0v as 0.
	For some reason, instead of the reference voltage being 4.32v, it is 3.3v. 
	A plausible explanation is that the microchip does not up the voltage, so that if the microchip is only ever 
	supplied with 3.3v, it will output 3.3v as the max.
	*/
	VREF.CTRLA = VREF_ADC0REFSEL_4V34_gc;
     448:	80 e3       	ldi	r24, 0x30	; 48
     44a:	80 93 a0 00 	sts	0x00A0, r24	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
	

	while (1)
	{
		// We don't want to update the neuron too often because of various reasons. The tinyISR_getflag is set every ms, and so the loop is only run once every ms.  
		if(tinyISR_getflag())
     44e:	a6 d4       	rcall	.+2380   	; 0xd9c <tinyISR_getflag>
     450:	88 23       	and	r24, r24
     452:	e9 f3       	breq	.-6      	; 0x44e <main+0x8>
		{			
			
			if(tinyCharge_is_connected_to_charger()){
     454:	6e df       	rcall	.-292    	; 0x332 <tinyCharge_is_connected_to_charger>
     456:	88 23       	and	r24, r24
     458:	41 f0       	breq	.+16     	; 0x46a <main+0x24>
				// Charge loop
				
				if(tinyCharge_is_fully_charged()){
     45a:	6e df       	rcall	.-292    	; 0x338 <tinyCharge_is_fully_charged>
     45c:	88 23       	and	r24, r24
     45e:	19 f0       	breq	.+6      	; 0x466 <main+0x20>
					tinyLED_set_color(OUT_LED, CHARGING_DONE_COLOR);
     460:	63 e0       	ldi	r22, 0x03	; 3
     462:	80 e0       	ldi	r24, 0x00	; 0
     464:	81 d0       	rcall	.+258    	; 0x568 <tinyLED_set_color>
				}				
				// We check the Dendrites in order to detect if we have stopped charging
				tinyDendrite_update_signals();
     466:	93 d3       	rcall	.+1830   	; 0xb8e <tinyDendrite_update_signals>
     468:	09 c0       	rjmp	.+18     	; 0x47c <main+0x36>
				
			}
			else{
				// Main loop				
				tinyButton_update();
     46a:	12 d0       	rcall	.+36     	; 0x490 <tinyButton_update>
				
				tinyPotential_update();
     46c:	9a d4       	rcall	.+2356   	; 0xda2 <tinyPotential_update>
				
				//Set LED
				if(tinyLED_get_color(OUT_LED) == OFF){
     46e:	80 e0       	ldi	r24, 0x00	; 0
     470:	84 d0       	rcall	.+264    	; 0x57a <tinyLED_get_color>
     472:	81 11       	cpse	r24, r1
     474:	03 c0       	rjmp	.+6      	; 0x47c <main+0x36>
					tinyLED_set_color_mode(OUT_LED, PING_COLOR, PING);
     476:	43 e0       	ldi	r20, 0x03	; 3
     478:	62 e0       	ldi	r22, 0x02	; 2
     47a:	87 d0       	rcall	.+270    	; 0x58a <tinyLED_set_color_mode>
				}
			}
			// Update LED
			tinyLED_update();
     47c:	c6 d0       	rcall	.+396    	; 0x60a <tinyLED_update>
				
			// Switch transistors
			tinyCharge_set_transistors();
     47e:	7e df       	rcall	.-260    	; 0x37c <tinyCharge_set_transistors>
			
			// Prepare for next cycle
			tinyISR_setflag(false);
     480:	80 e0       	ldi	r24, 0x00	; 0
     482:	89 d4       	rcall	.+2322   	; 0xd96 <tinyISR_setflag>
			tinyDebugger_send_int("time", tinyTime_now());
     484:	d7 df       	rcall	.-82     	; 0x434 <tinyTime_now>
     486:	8c e1       	ldi	r24, 0x1C	; 28
     488:	96 e9       	ldi	r25, 0x96	; 150
     48a:	80 df       	rcall	.-256    	; 0x38c <tinyDebugger_send_int>
			tinyDebugger_end_line();
     48c:	82 df       	rcall	.-252    	; 0x392 <tinyDebugger_end_line>
     48e:	df cf       	rjmp	.-66     	; 0x44e <main+0x8>

00000490 <tinyButton_update>:
/*
If the button has been let go, we change button_press to true. This only lasts one cycle, before it is set to false again.
If the button is held down for longer than PULSEMODE_BUTTON_PRESS_TIME, we toggle the pulse mode state.
*/
void tinyButton_update(void)
{
     490:	0f 93       	push	r16
     492:	1f 93       	push	r17
     494:	cf 93       	push	r28
     496:	df 93       	push	r29
	button_press = false;
     498:	10 92 25 3e 	sts	0x3E25, r1	; 0x803e25 <button_press>
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTC_get_pin_level(const uint8_t pin)
{
	return VPORTC.IN & (1 << pin);
     49c:	8a b1       	in	r24, 0x0a	; 10
	_Bool button_is_pushed_down = !BUTTON_PIN_get_level(); // The digital port will be read as low if the button is pushed down.
     49e:	d1 e0       	ldi	r29, 0x01	; 1
     4a0:	c8 2f       	mov	r28, r24
     4a2:	c4 70       	andi	r28, 0x04	; 4
     4a4:	82 fd       	sbrc	r24, 2
     4a6:	d0 e0       	ldi	r29, 0x00	; 0

	if (button_is_pushed_down && !button_was_pushed_down)
     4a8:	c1 11       	cpse	r28, r1
     4aa:	30 c0       	rjmp	.+96     	; 0x50c <tinyButton_update+0x7c>
     4ac:	80 91 26 3e 	lds	r24, 0x3E26	; 0x803e26 <button_was_pushed_down>
     4b0:	81 11       	cpse	r24, r1
     4b2:	0d c0       	rjmp	.+26     	; 0x4ce <tinyButton_update+0x3e>
	{
		tinyButton_start_time = tinyTime_now();
     4b4:	bf df       	rcall	.-130    	; 0x434 <tinyTime_now>
     4b6:	60 93 21 3e 	sts	0x3E21, r22	; 0x803e21 <tinyButton_start_time>
     4ba:	70 93 22 3e 	sts	0x3E22, r23	; 0x803e22 <tinyButton_start_time+0x1>
     4be:	80 93 23 3e 	sts	0x3E23, r24	; 0x803e23 <tinyButton_start_time+0x2>
     4c2:	90 93 24 3e 	sts	0x3E24, r25	; 0x803e24 <tinyButton_start_time+0x3>
	}
	if (button_is_pushed_down && button_was_pushed_down)
     4c6:	80 91 26 3e 	lds	r24, 0x3E26	; 0x803e26 <button_was_pushed_down>
     4ca:	88 23       	and	r24, r24
     4cc:	41 f1       	breq	.+80     	; 0x51e <tinyButton_update+0x8e>
	{
		if ((tinyTime_now() - tinyButton_start_time) > PULSEMODE_BUTTON_PRESS_TIME)
     4ce:	b2 df       	rcall	.-156    	; 0x434 <tinyTime_now>
     4d0:	00 91 21 3e 	lds	r16, 0x3E21	; 0x803e21 <tinyButton_start_time>
     4d4:	10 91 22 3e 	lds	r17, 0x3E22	; 0x803e22 <tinyButton_start_time+0x1>
     4d8:	20 91 23 3e 	lds	r18, 0x3E23	; 0x803e23 <tinyButton_start_time+0x2>
     4dc:	30 91 24 3e 	lds	r19, 0x3E24	; 0x803e24 <tinyButton_start_time+0x3>
     4e0:	60 1b       	sub	r22, r16
     4e2:	71 0b       	sbc	r23, r17
     4e4:	82 0b       	sbc	r24, r18
     4e6:	93 0b       	sbc	r25, r19
     4e8:	2c d6       	rcall	.+3160   	; 0x1142 <__floatunsisf>
     4ea:	20 e0       	ldi	r18, 0x00	; 0
     4ec:	30 e0       	ldi	r19, 0x00	; 0
     4ee:	48 ec       	ldi	r20, 0xC8	; 200
     4f0:	52 e4       	ldi	r21, 0x42	; 66
     4f2:	1f d7       	rcall	.+3646   	; 0x1332 <__gesf2>
     4f4:	18 16       	cp	r1, r24
     4f6:	54 f4       	brge	.+20     	; 0x50c <tinyButton_update+0x7c>
		{
			tinyPulse_toggle_pulse_mode();
     4f8:	4d df       	rcall	.-358    	; 0x394 <tinyPulse_toggle_pulse_mode>
			tinyButton_start_time = tinyTime_now();
     4fa:	9c df       	rcall	.-200    	; 0x434 <tinyTime_now>
     4fc:	60 93 21 3e 	sts	0x3E21, r22	; 0x803e21 <tinyButton_start_time>
     500:	70 93 22 3e 	sts	0x3E22, r23	; 0x803e22 <tinyButton_start_time+0x1>
     504:	80 93 23 3e 	sts	0x3E23, r24	; 0x803e23 <tinyButton_start_time+0x2>
     508:	90 93 24 3e 	sts	0x3E24, r25	; 0x803e24 <tinyButton_start_time+0x3>
		}
	}
	if (!button_is_pushed_down && button_was_pushed_down)
     50c:	cc 23       	and	r28, r28
     50e:	39 f0       	breq	.+14     	; 0x51e <tinyButton_update+0x8e>
     510:	80 91 26 3e 	lds	r24, 0x3E26	; 0x803e26 <button_was_pushed_down>
     514:	88 23       	and	r24, r24
     516:	19 f0       	breq	.+6      	; 0x51e <tinyButton_update+0x8e>
	{
		button_press = true;
     518:	81 e0       	ldi	r24, 0x01	; 1
     51a:	80 93 25 3e 	sts	0x3E25, r24	; 0x803e25 <button_press>
	}
	button_was_pushed_down = button_is_pushed_down;
     51e:	d0 93 26 3e 	sts	0x3E26, r29	; 0x803e26 <button_was_pushed_down>
}
     522:	df 91       	pop	r29
     524:	cf 91       	pop	r28
     526:	1f 91       	pop	r17
     528:	0f 91       	pop	r16
     52a:	08 95       	ret

0000052c <tinyButton_update_potential>:

double tinyButton_update_potential(double potential){
	if(button_press){
     52c:	20 91 25 3e 	lds	r18, 0x3E25	; 0x803e25 <button_press>
     530:	22 23       	and	r18, r18
     532:	29 f0       	breq	.+10     	; 0x53e <tinyButton_update_potential+0x12>
		potential += BUTTON_PRESS_REACTION;
     534:	20 e0       	ldi	r18, 0x00	; 0
     536:	30 e0       	ldi	r19, 0x00	; 0
     538:	40 ed       	ldi	r20, 0xD0	; 208
     53a:	51 e4       	ldi	r21, 0x41	; 65
     53c:	b6 d4       	rcall	.+2412   	; 0xeaa <__addsf3>
	}
	return potential;
}
     53e:	08 95       	ret

00000540 <tinyLED_SPIWriteByte>:
Function used to send a byte over SPI, which in turn gets
translated to the bit-sequence required by the LEDs over the CCL.
*/
static void tinyLED_SPIWriteByte(uint8_t byte)
{
	SPI0.INTFLAGS = SPI0_INTFLAGS; // clear the write collision flag to allow writing
     540:	90 91 23 08 	lds	r25, 0x0823	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
     544:	90 93 23 08 	sts	0x0823, r25	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
	TCA0.SINGLE.CNT = 0; // reset TCA counter register to ensure the first rising edge of the PWM is predictable
     548:	e0 e0       	ldi	r30, 0x00	; 0
     54a:	fa e0       	ldi	r31, 0x0A	; 10
     54c:	10 a2       	std	Z+32, r1	; 0x20
     54e:	11 a2       	std	Z+33, r1	; 0x21
	
	// start TCA
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 1 << TCA_SPLIT_ENABLE_bp;
     550:	91 e0       	ldi	r25, 0x01	; 1
     552:	90 83       	st	Z, r25
	SPI0_DATA = byte;
     554:	80 93 24 08 	sts	0x0824, r24	; 0x800824 <__TEXT_REGION_LENGTH__+0x700824>

	while((SPI0.INTFLAGS & SPI_RXCIE_bm) == 0){} // wait for transfer to complete
     558:	e0 e2       	ldi	r30, 0x20	; 32
     55a:	f8 e0       	ldi	r31, 0x08	; 8
     55c:	83 81       	ldd	r24, Z+3	; 0x03
     55e:	88 23       	and	r24, r24
     560:	ec f7       	brge	.-6      	; 0x55c <tinyLED_SPIWriteByte+0x1c>
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 0 << TCA_SPLIT_ENABLE_bp; //Stop TCA
     562:	10 92 00 0a 	sts	0x0A00, r1	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
     566:	08 95       	ret

00000568 <tinyLED_set_color>:
changes the values in the variables stored in the LED-array.
*/
void tinyLED_set_color_mode(uint8_t LED_id, enum Colors color, enum ColorModes mode)
{
	struct ColorSetting setting = {.color=color, .mode=mode};
	tinyLED_colors[LED_id] = setting;
     568:	e8 2f       	mov	r30, r24
     56a:	f0 e0       	ldi	r31, 0x00	; 0
     56c:	ee 0f       	add	r30, r30
     56e:	ff 1f       	adc	r31, r31
     570:	eb 59       	subi	r30, 0x9B	; 155
     572:	f1 4c       	sbci	r31, 0xC1	; 193
     574:	60 83       	st	Z, r22
     576:	11 82       	std	Z+1, r1	; 0x01
     578:	08 95       	ret

0000057a <tinyLED_get_color>:
	tinyLED_set_color_mode(LED_id, color, STABLE);
}

enum Colors tinyLED_get_color(uint8_t LED_id)
{
	return tinyLED_colors[LED_id].color;
     57a:	e8 2f       	mov	r30, r24
     57c:	f0 e0       	ldi	r31, 0x00	; 0
     57e:	ee 0f       	add	r30, r30
     580:	ff 1f       	adc	r31, r31
     582:	eb 59       	subi	r30, 0x9B	; 155
     584:	f1 4c       	sbci	r31, 0xC1	; 193
}
     586:	80 81       	ld	r24, Z
     588:	08 95       	ret

0000058a <tinyLED_set_color_mode>:
changes the values in the variables stored in the LED-array.
*/
void tinyLED_set_color_mode(uint8_t LED_id, enum Colors color, enum ColorModes mode)
{
	struct ColorSetting setting = {.color=color, .mode=mode};
	tinyLED_colors[LED_id] = setting;
     58a:	90 e0       	ldi	r25, 0x00	; 0
     58c:	fc 01       	movw	r30, r24
     58e:	ee 0f       	add	r30, r30
     590:	ff 1f       	adc	r31, r31
     592:	eb 59       	subi	r30, 0x9B	; 155
     594:	f1 4c       	sbci	r31, 0xC1	; 193
     596:	60 83       	st	Z, r22
     598:	41 83       	std	Z+1, r20	; 0x01
	if (mode == FLASH_ONCE)
     59a:	44 30       	cpi	r20, 0x04	; 4
     59c:	29 f4       	brne	.+10     	; 0x5a8 <tinyLED_set_color_mode+0x1e>
	{
		tinyLED_flash_once_time[LED_id] = 1000*FLASH_TIME;
     59e:	fc 01       	movw	r30, r24
     5a0:	e3 5a       	subi	r30, 0xA3	; 163
     5a2:	f1 4c       	sbci	r31, 0xC1	; 193
     5a4:	2a e0       	ldi	r18, 0x0A	; 10
     5a6:	20 83       	st	Z, r18
     5a8:	08 95       	ret

000005aa <tinyLED_RGB_Color_Compare>:
	}
	return rgb_color;
			
};

_Bool tinyLED_RGB_Color_Compare(struct RGB_Color* a, struct RGB_Color* b){
     5aa:	dc 01       	movw	r26, r24
     5ac:	fb 01       	movw	r30, r22
	for (int i=0; i<NUMBER_OF_LEDS; i++)
	{
		if(!(a[i].red==b[i].red && a[i].green==b[i].green && a[i].blue==b[i].blue)){
     5ae:	9c 91       	ld	r25, X
     5b0:	80 81       	ld	r24, Z
     5b2:	98 13       	cpse	r25, r24
     5b4:	20 c0       	rjmp	.+64     	; 0x5f6 <tinyLED_RGB_Color_Compare+0x4c>
     5b6:	11 96       	adiw	r26, 0x01	; 1
     5b8:	9c 91       	ld	r25, X
     5ba:	11 97       	sbiw	r26, 0x01	; 1
     5bc:	81 81       	ldd	r24, Z+1	; 0x01
     5be:	98 13       	cpse	r25, r24
     5c0:	1c c0       	rjmp	.+56     	; 0x5fa <tinyLED_RGB_Color_Compare+0x50>
     5c2:	12 96       	adiw	r26, 0x02	; 2
     5c4:	9c 91       	ld	r25, X
     5c6:	12 97       	sbiw	r26, 0x02	; 2
     5c8:	82 81       	ldd	r24, Z+2	; 0x02
     5ca:	98 13       	cpse	r25, r24
     5cc:	18 c0       	rjmp	.+48     	; 0x5fe <tinyLED_RGB_Color_Compare+0x54>
     5ce:	13 96       	adiw	r26, 0x03	; 3
     5d0:	9c 91       	ld	r25, X
     5d2:	13 97       	sbiw	r26, 0x03	; 3
     5d4:	83 81       	ldd	r24, Z+3	; 0x03
     5d6:	98 13       	cpse	r25, r24
     5d8:	14 c0       	rjmp	.+40     	; 0x602 <tinyLED_RGB_Color_Compare+0x58>
     5da:	14 96       	adiw	r26, 0x04	; 4
     5dc:	9c 91       	ld	r25, X
     5de:	14 97       	sbiw	r26, 0x04	; 4
     5e0:	84 81       	ldd	r24, Z+4	; 0x04
     5e2:	98 13       	cpse	r25, r24
     5e4:	10 c0       	rjmp	.+32     	; 0x606 <tinyLED_RGB_Color_Compare+0x5c>
     5e6:	81 e0       	ldi	r24, 0x01	; 1
     5e8:	15 96       	adiw	r26, 0x05	; 5
     5ea:	2c 91       	ld	r18, X
     5ec:	95 81       	ldd	r25, Z+5	; 0x05
     5ee:	29 17       	cp	r18, r25
     5f0:	59 f0       	breq	.+22     	; 0x608 <tinyLED_RGB_Color_Compare+0x5e>
     5f2:	80 e0       	ldi	r24, 0x00	; 0
     5f4:	08 95       	ret
			return false;
     5f6:	80 e0       	ldi	r24, 0x00	; 0
     5f8:	08 95       	ret
     5fa:	80 e0       	ldi	r24, 0x00	; 0
     5fc:	08 95       	ret
     5fe:	80 e0       	ldi	r24, 0x00	; 0
     600:	08 95       	ret
     602:	80 e0       	ldi	r24, 0x00	; 0
     604:	08 95       	ret
     606:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	return true;
}
     608:	08 95       	ret

0000060a <tinyLED_update>:
/*
function to write the current LED-array on to the LEDs and
effectively update the values stored in the LEDs to the values stored in the MCU.
*/
void tinyLED_update(void)
{
     60a:	2f 92       	push	r2
     60c:	3f 92       	push	r3
     60e:	4f 92       	push	r4
     610:	5f 92       	push	r5
     612:	6f 92       	push	r6
     614:	7f 92       	push	r7
     616:	8f 92       	push	r8
     618:	9f 92       	push	r9
     61a:	af 92       	push	r10
     61c:	bf 92       	push	r11
     61e:	cf 92       	push	r12
     620:	df 92       	push	r13
     622:	ef 92       	push	r14
     624:	ff 92       	push	r15
     626:	0f 93       	push	r16
     628:	1f 93       	push	r17
     62a:	cf 93       	push	r28
     62c:	df 93       	push	r29
     62e:	cd b7       	in	r28, 0x3d	; 61
     630:	de b7       	in	r29, 0x3e	; 62
     632:	6f 97       	sbiw	r28, 0x1f	; 31
     634:	cd bf       	out	0x3d, r28	; 61
     636:	de bf       	out	0x3e, r29	; 62
			
	uint32_t now = tinyTime_now();
     638:	fd de       	rcall	.-518    	; 0x434 <tinyTime_now>
     63a:	6b 01       	movw	r12, r22
     63c:	7c 01       	movw	r14, r24
	double sinValue = 1+sin((double)now/(100*M_PI/SWING_RATE));
     63e:	81 d5       	rcall	.+2818   	; 0x1142 <__floatunsisf>
     640:	22 ed       	ldi	r18, 0xD2	; 210
     642:	33 e5       	ldi	r19, 0x53	; 83
     644:	4b ef       	ldi	r20, 0xFB	; 251
     646:	51 e4       	ldi	r21, 0x41	; 65
     648:	a1 d4       	rcall	.+2370   	; 0xf8c <__divsf3>
     64a:	5b d7       	rcall	.+3766   	; 0x1502 <sin>
     64c:	20 e0       	ldi	r18, 0x00	; 0
     64e:	30 e0       	ldi	r19, 0x00	; 0
     650:	40 e8       	ldi	r20, 0x80	; 128
     652:	5f e3       	ldi	r21, 0x3F	; 63
     654:	2a d4       	rcall	.+2132   	; 0xeaa <__addsf3>
     656:	69 87       	std	Y+9, r22	; 0x09
     658:	7a 87       	std	Y+10, r23	; 0x0a
     65a:	8b 87       	std	Y+11, r24	; 0x0b
     65c:	9c 87       	std	Y+12, r25	; 0x0c
	_Bool flash_on = now%(uint32_t)(1000/FLASH_RATE)   <   500/FLASH_RATE;
     65e:	c7 01       	movw	r24, r14
     660:	b6 01       	movw	r22, r12
     662:	22 e3       	ldi	r18, 0x32	; 50
     664:	30 e0       	ldi	r19, 0x00	; 0
     666:	40 e0       	ldi	r20, 0x00	; 0
     668:	50 e0       	ldi	r21, 0x00	; 0
     66a:	b4 d7       	rcall	.+3944   	; 0x15d4 <__udivmodsi4>
     66c:	6a d5       	rcall	.+2772   	; 0x1142 <__floatunsisf>
     66e:	20 e0       	ldi	r18, 0x00	; 0
     670:	30 e0       	ldi	r19, 0x00	; 0
     672:	48 ec       	ldi	r20, 0xC8	; 200
     674:	51 e4       	ldi	r21, 0x41	; 65
     676:	85 d4       	rcall	.+2314   	; 0xf82 <__cmpsf2>
     678:	88 1f       	adc	r24, r24
     67a:	88 27       	eor	r24, r24
     67c:	88 1f       	adc	r24, r24
     67e:	8d 87       	std	Y+13, r24	; 0x0d
	_Bool ping_on = now%(uint32_t)(1000/PING_RATE)   <   1000*FLASH_TIME;
     680:	c7 01       	movw	r24, r14
     682:	b6 01       	movw	r22, r12
     684:	24 ef       	ldi	r18, 0xF4	; 244
     686:	31 e0       	ldi	r19, 0x01	; 1
     688:	40 e0       	ldi	r20, 0x00	; 0
     68a:	50 e0       	ldi	r21, 0x00	; 0
     68c:	a3 d7       	rcall	.+3910   	; 0x15d4 <__udivmodsi4>
     68e:	59 d5       	rcall	.+2738   	; 0x1142 <__floatunsisf>
     690:	20 e0       	ldi	r18, 0x00	; 0
     692:	30 e0       	ldi	r19, 0x00	; 0
     694:	40 e2       	ldi	r20, 0x20	; 32
     696:	51 e4       	ldi	r21, 0x41	; 65
     698:	74 d4       	rcall	.+2280   	; 0xf82 <__cmpsf2>
     69a:	88 1f       	adc	r24, r24
     69c:	88 27       	eor	r24, r24
     69e:	88 1f       	adc	r24, r24
     6a0:	0f 2e       	mov	r0, r31
     6a2:	f5 e6       	ldi	r31, 0x65	; 101
     6a4:	2f 2e       	mov	r2, r31
     6a6:	fe e3       	ldi	r31, 0x3E	; 62
     6a8:	3f 2e       	mov	r3, r31
     6aa:	f0 2d       	mov	r31, r0
     6ac:	9e 01       	movw	r18, r28
     6ae:	2f 5f       	subi	r18, 0xFF	; 255
     6b0:	3f 4f       	sbci	r19, 0xFF	; 255
     6b2:	0d e5       	ldi	r16, 0x5D	; 93
     6b4:	1e e3       	ldi	r17, 0x3E	; 62
     6b6:	0f 2e       	mov	r0, r31
     6b8:	f9 e6       	ldi	r31, 0x69	; 105
     6ba:	cf 2e       	mov	r12, r31
     6bc:	fe e3       	ldi	r31, 0x3E	; 62
     6be:	df 2e       	mov	r13, r31
     6c0:	f0 2d       	mov	r31, r0
     6c2:	49 01       	movw	r8, r18
			case SWING:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*sinValue, rgb_colors[i].green*sinValue, rgb_colors[i].blue*sinValue};
				break;
			case PING:
				// PING brightness should always be very low
				rgb_colors[i] = (struct RGB_Color){5*fmin(1,rgb_colors[i].red)*ping_on, 5*fmin(1,rgb_colors[i].green)*ping_on, 5*fmin(1,rgb_colors[i].blue)*ping_on};
     6c4:	48 2e       	mov	r4, r24
     6c6:	51 2c       	mov	r5, r1
     6c8:	61 2c       	mov	r6, r1
     6ca:	71 2c       	mov	r7, r1
     6cc:	2e 87       	std	Y+14, r18	; 0x0e
     6ce:	3f 87       	std	Y+15, r19	; 0x0f
     6d0:	f1 01       	movw	r30, r2
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 0 << TCA_SPLIT_ENABLE_bp; //Stop TCA
}

static struct RGB_Color tinyLED_enum_to_RGB_Color(enum Colors color){
	struct RGB_Color rgb_color;
	switch(color)
     6d2:	80 81       	ld	r24, Z
     6d4:	82 30       	cpi	r24, 0x02	; 2
     6d6:	a1 f0       	breq	.+40     	; 0x700 <tinyLED_update+0xf6>
     6d8:	18 f4       	brcc	.+6      	; 0x6e0 <tinyLED_update+0xd6>
     6da:	81 30       	cpi	r24, 0x01	; 1
     6dc:	31 f0       	breq	.+12     	; 0x6ea <tinyLED_update+0xe0>
     6de:	21 c0       	rjmp	.+66     	; 0x722 <tinyLED_update+0x118>
     6e0:	83 30       	cpi	r24, 0x03	; 3
     6e2:	39 f0       	breq	.+14     	; 0x6f2 <tinyLED_update+0xe8>
     6e4:	84 30       	cpi	r24, 0x04	; 4
     6e6:	99 f0       	breq	.+38     	; 0x70e <tinyLED_update+0x104>
     6e8:	1c c0       	rjmp	.+56     	; 0x722 <tinyLED_update+0x118>
	{
		case OFF:
			rgb_color = (struct RGB_Color){0, 0, 0};
			break;
		case RED:
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 0, 0};
     6ea:	f1 2c       	mov	r15, r1
     6ec:	e1 2c       	mov	r14, r1
     6ee:	69 e1       	ldi	r22, 0x19	; 25
     6f0:	1b c0       	rjmp	.+54     	; 0x728 <tinyLED_update+0x11e>
			break;
		case GREEN:
			rgb_color = (struct RGB_Color){0, 255*LED_BRIGHTNESS, 0};
     6f2:	f1 2c       	mov	r15, r1
     6f4:	0f 2e       	mov	r0, r31
     6f6:	f9 e1       	ldi	r31, 0x19	; 25
     6f8:	ef 2e       	mov	r14, r31
     6fa:	f0 2d       	mov	r31, r0
     6fc:	60 e0       	ldi	r22, 0x00	; 0
     6fe:	14 c0       	rjmp	.+40     	; 0x728 <tinyLED_update+0x11e>
			break;
		case BLUE:
			rgb_color = (struct RGB_Color){0, 0, 255*LED_BRIGHTNESS};
     700:	0f 2e       	mov	r0, r31
     702:	f9 e1       	ldi	r31, 0x19	; 25
     704:	ff 2e       	mov	r15, r31
     706:	f0 2d       	mov	r31, r0
     708:	e1 2c       	mov	r14, r1
     70a:	60 e0       	ldi	r22, 0x00	; 0
     70c:	0d c0       	rjmp	.+26     	; 0x728 <tinyLED_update+0x11e>
			// Should the /3 be there? This requires testing.
			// After testing, findings were that at 0.1 brightness, one would see the three LEDs instead of one white led
			// We try with /2 instead.
			// We find that the best results come from not dividing by anything. At leasts in the lower brightness settings, and that
			// is where we suspect it will be most of the time.
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS};
     70e:	0f 2e       	mov	r0, r31
     710:	f9 e1       	ldi	r31, 0x19	; 25
     712:	ff 2e       	mov	r15, r31
     714:	f0 2d       	mov	r31, r0
     716:	0f 2e       	mov	r0, r31
     718:	f9 e1       	ldi	r31, 0x19	; 25
     71a:	ef 2e       	mov	r14, r31
     71c:	f0 2d       	mov	r31, r0
     71e:	69 e1       	ldi	r22, 0x19	; 25
     720:	03 c0       	rjmp	.+6      	; 0x728 <tinyLED_update+0x11e>
static struct RGB_Color tinyLED_enum_to_RGB_Color(enum Colors color){
	struct RGB_Color rgb_color;
	switch(color)
	{
		case OFF:
			rgb_color = (struct RGB_Color){0, 0, 0};
     722:	f1 2c       	mov	r15, r1
     724:	e1 2c       	mov	r14, r1
     726:	60 e0       	ldi	r22, 0x00	; 0
     728:	8f 82       	std	Y+7, r8	; 0x07
     72a:	98 86       	std	Y+8, r9	; 0x08
	
		
	for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
	{		
		// Convert enum to RGB_Color
		rgb_colors[i] = tinyLED_enum_to_RGB_Color(tinyLED_colors[i].color);
     72c:	d4 01       	movw	r26, r8
     72e:	6c 93       	st	X, r22
     730:	11 96       	adiw	r26, 0x01	; 1
     732:	ec 92       	st	X, r14
     734:	11 97       	sbiw	r26, 0x01	; 1
     736:	12 96       	adiw	r26, 0x02	; 2
     738:	fc 92       	st	X, r15
			
		// Adjust colors according to mode
		switch(tinyLED_colors[i].mode)
     73a:	81 81       	ldd	r24, Z+1	; 0x01
     73c:	82 30       	cpi	r24, 0x02	; 2
     73e:	d1 f0       	breq	.+52     	; 0x774 <tinyLED_update+0x16a>
     740:	18 f4       	brcc	.+6      	; 0x748 <tinyLED_update+0x13e>
     742:	81 30       	cpi	r24, 0x01	; 1
     744:	39 f0       	breq	.+14     	; 0x754 <tinyLED_update+0x14a>
     746:	e0 c0       	rjmp	.+448    	; 0x908 <tinyLED_update+0x2fe>
     748:	83 30       	cpi	r24, 0x03	; 3
     74a:	e1 f1       	breq	.+120    	; 0x7c4 <tinyLED_update+0x1ba>
     74c:	84 30       	cpi	r24, 0x04	; 4
     74e:	09 f4       	brne	.+2      	; 0x752 <tinyLED_update+0x148>
     750:	a7 c0       	rjmp	.+334    	; 0x8a0 <tinyLED_update+0x296>
     752:	da c0       	rjmp	.+436    	; 0x908 <tinyLED_update+0x2fe>
		{
			case STABLE:
				break;
			case FLASH:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*flash_on, rgb_colors[i].green*flash_on, rgb_colors[i].blue*flash_on};
     754:	bd 85       	ldd	r27, Y+13	; 0x0d
     756:	b6 9f       	mul	r27, r22
     758:	60 2d       	mov	r22, r0
     75a:	11 24       	eor	r1, r1
     75c:	ef 81       	ldd	r30, Y+7	; 0x07
     75e:	f8 85       	ldd	r31, Y+8	; 0x08
     760:	60 83       	st	Z, r22
     762:	be 9d       	mul	r27, r14
     764:	e0 2c       	mov	r14, r0
     766:	11 24       	eor	r1, r1
     768:	e1 82       	std	Z+1, r14	; 0x01
     76a:	bf 9d       	mul	r27, r15
     76c:	f0 2c       	mov	r15, r0
     76e:	11 24       	eor	r1, r1
     770:	f2 82       	std	Z+2, r15	; 0x02
				break;
     772:	ca c0       	rjmp	.+404    	; 0x908 <tinyLED_update+0x2fe>
			case SWING:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*sinValue, rgb_colors[i].green*sinValue, rgb_colors[i].blue*sinValue};
     774:	70 e0       	ldi	r23, 0x00	; 0
     776:	80 e0       	ldi	r24, 0x00	; 0
     778:	90 e0       	ldi	r25, 0x00	; 0
     77a:	e5 d4       	rcall	.+2506   	; 0x1146 <__floatsisf>
     77c:	29 85       	ldd	r18, Y+9	; 0x09
     77e:	3a 85       	ldd	r19, Y+10	; 0x0a
     780:	4b 85       	ldd	r20, Y+11	; 0x0b
     782:	5c 85       	ldd	r21, Y+12	; 0x0c
     784:	51 d6       	rcall	.+3234   	; 0x1428 <__mulsf3>
     786:	ae d4       	rcall	.+2396   	; 0x10e4 <__fixunssfsi>
     788:	d4 01       	movw	r26, r8
     78a:	6c 93       	st	X, r22
     78c:	6e 2d       	mov	r22, r14
     78e:	70 e0       	ldi	r23, 0x00	; 0
     790:	80 e0       	ldi	r24, 0x00	; 0
     792:	90 e0       	ldi	r25, 0x00	; 0
     794:	d8 d4       	rcall	.+2480   	; 0x1146 <__floatsisf>
     796:	29 85       	ldd	r18, Y+9	; 0x09
     798:	3a 85       	ldd	r19, Y+10	; 0x0a
     79a:	4b 85       	ldd	r20, Y+11	; 0x0b
     79c:	5c 85       	ldd	r21, Y+12	; 0x0c
     79e:	44 d6       	rcall	.+3208   	; 0x1428 <__mulsf3>
     7a0:	a1 d4       	rcall	.+2370   	; 0x10e4 <__fixunssfsi>
     7a2:	f4 01       	movw	r30, r8
     7a4:	61 83       	std	Z+1, r22	; 0x01
     7a6:	6f 2d       	mov	r22, r15
     7a8:	70 e0       	ldi	r23, 0x00	; 0
     7aa:	80 e0       	ldi	r24, 0x00	; 0
     7ac:	90 e0       	ldi	r25, 0x00	; 0
     7ae:	cb d4       	rcall	.+2454   	; 0x1146 <__floatsisf>
     7b0:	29 85       	ldd	r18, Y+9	; 0x09
     7b2:	3a 85       	ldd	r19, Y+10	; 0x0a
     7b4:	4b 85       	ldd	r20, Y+11	; 0x0b
     7b6:	5c 85       	ldd	r21, Y+12	; 0x0c
     7b8:	37 d6       	rcall	.+3182   	; 0x1428 <__mulsf3>
     7ba:	94 d4       	rcall	.+2344   	; 0x10e4 <__fixunssfsi>
     7bc:	d4 01       	movw	r26, r8
     7be:	12 96       	adiw	r26, 0x02	; 2
     7c0:	6c 93       	st	X, r22
				break;
     7c2:	a2 c0       	rjmp	.+324    	; 0x908 <tinyLED_update+0x2fe>
			case PING:
				// PING brightness should always be very low
				rgb_colors[i] = (struct RGB_Color){5*fmin(1,rgb_colors[i].red)*ping_on, 5*fmin(1,rgb_colors[i].green)*ping_on, 5*fmin(1,rgb_colors[i].blue)*ping_on};
     7c4:	70 e0       	ldi	r23, 0x00	; 0
     7c6:	80 e0       	ldi	r24, 0x00	; 0
     7c8:	90 e0       	ldi	r25, 0x00	; 0
     7ca:	bb d4       	rcall	.+2422   	; 0x1142 <__floatunsisf>
     7cc:	9b 01       	movw	r18, r22
     7ce:	ac 01       	movw	r20, r24
     7d0:	60 e0       	ldi	r22, 0x00	; 0
     7d2:	70 e0       	ldi	r23, 0x00	; 0
     7d4:	80 e8       	ldi	r24, 0x80	; 128
     7d6:	9f e3       	ldi	r25, 0x3F	; 63
     7d8:	f1 d4       	rcall	.+2530   	; 0x11bc <fmin>
     7da:	6c 8b       	std	Y+20, r22	; 0x14
     7dc:	7d 8b       	std	Y+21, r23	; 0x15
     7de:	8e 8b       	std	Y+22, r24	; 0x16
     7e0:	9f 8b       	std	Y+23, r25	; 0x17
     7e2:	c3 01       	movw	r24, r6
     7e4:	b2 01       	movw	r22, r4
     7e6:	af d4       	rcall	.+2398   	; 0x1146 <__floatsisf>
     7e8:	68 8b       	std	Y+16, r22	; 0x10
     7ea:	79 8b       	std	Y+17, r23	; 0x11
     7ec:	8a 8b       	std	Y+18, r24	; 0x12
     7ee:	9b 8b       	std	Y+19, r25	; 0x13
     7f0:	6e 2d       	mov	r22, r14
     7f2:	70 e0       	ldi	r23, 0x00	; 0
     7f4:	80 e0       	ldi	r24, 0x00	; 0
     7f6:	90 e0       	ldi	r25, 0x00	; 0
     7f8:	a4 d4       	rcall	.+2376   	; 0x1142 <__floatunsisf>
     7fa:	9b 01       	movw	r18, r22
     7fc:	ac 01       	movw	r20, r24
     7fe:	60 e0       	ldi	r22, 0x00	; 0
     800:	70 e0       	ldi	r23, 0x00	; 0
     802:	80 e8       	ldi	r24, 0x80	; 128
     804:	9f e3       	ldi	r25, 0x3F	; 63
     806:	da d4       	rcall	.+2484   	; 0x11bc <fmin>
     808:	68 8f       	std	Y+24, r22	; 0x18
     80a:	79 8f       	std	Y+25, r23	; 0x19
     80c:	8a 8f       	std	Y+26, r24	; 0x1a
     80e:	9b 8f       	std	Y+27, r25	; 0x1b
     810:	6f 2d       	mov	r22, r15
     812:	70 e0       	ldi	r23, 0x00	; 0
     814:	80 e0       	ldi	r24, 0x00	; 0
     816:	90 e0       	ldi	r25, 0x00	; 0
     818:	94 d4       	rcall	.+2344   	; 0x1142 <__floatunsisf>
     81a:	9b 01       	movw	r18, r22
     81c:	ac 01       	movw	r20, r24
     81e:	60 e0       	ldi	r22, 0x00	; 0
     820:	70 e0       	ldi	r23, 0x00	; 0
     822:	80 e8       	ldi	r24, 0x80	; 128
     824:	9f e3       	ldi	r25, 0x3F	; 63
     826:	ca d4       	rcall	.+2452   	; 0x11bc <fmin>
     828:	6c 8f       	std	Y+28, r22	; 0x1c
     82a:	7d 8f       	std	Y+29, r23	; 0x1d
     82c:	8e 8f       	std	Y+30, r24	; 0x1e
     82e:	9f 8f       	std	Y+31, r25	; 0x1f
     830:	20 e0       	ldi	r18, 0x00	; 0
     832:	30 e0       	ldi	r19, 0x00	; 0
     834:	40 ea       	ldi	r20, 0xA0	; 160
     836:	50 e4       	ldi	r21, 0x40	; 64
     838:	6c 89       	ldd	r22, Y+20	; 0x14
     83a:	7d 89       	ldd	r23, Y+21	; 0x15
     83c:	8e 89       	ldd	r24, Y+22	; 0x16
     83e:	9f 89       	ldd	r25, Y+23	; 0x17
     840:	f3 d5       	rcall	.+3046   	; 0x1428 <__mulsf3>
     842:	28 89       	ldd	r18, Y+16	; 0x10
     844:	39 89       	ldd	r19, Y+17	; 0x11
     846:	4a 89       	ldd	r20, Y+18	; 0x12
     848:	5b 89       	ldd	r21, Y+19	; 0x13
     84a:	ee d5       	rcall	.+3036   	; 0x1428 <__mulsf3>
     84c:	4b d4       	rcall	.+2198   	; 0x10e4 <__fixunssfsi>
     84e:	ef 81       	ldd	r30, Y+7	; 0x07
     850:	f8 85       	ldd	r31, Y+8	; 0x08
     852:	60 83       	st	Z, r22
     854:	20 e0       	ldi	r18, 0x00	; 0
     856:	30 e0       	ldi	r19, 0x00	; 0
     858:	40 ea       	ldi	r20, 0xA0	; 160
     85a:	50 e4       	ldi	r21, 0x40	; 64
     85c:	68 8d       	ldd	r22, Y+24	; 0x18
     85e:	79 8d       	ldd	r23, Y+25	; 0x19
     860:	8a 8d       	ldd	r24, Y+26	; 0x1a
     862:	9b 8d       	ldd	r25, Y+27	; 0x1b
     864:	e1 d5       	rcall	.+3010   	; 0x1428 <__mulsf3>
     866:	28 89       	ldd	r18, Y+16	; 0x10
     868:	39 89       	ldd	r19, Y+17	; 0x11
     86a:	4a 89       	ldd	r20, Y+18	; 0x12
     86c:	5b 89       	ldd	r21, Y+19	; 0x13
     86e:	dc d5       	rcall	.+3000   	; 0x1428 <__mulsf3>
     870:	39 d4       	rcall	.+2162   	; 0x10e4 <__fixunssfsi>
     872:	af 81       	ldd	r26, Y+7	; 0x07
     874:	b8 85       	ldd	r27, Y+8	; 0x08
     876:	11 96       	adiw	r26, 0x01	; 1
     878:	6c 93       	st	X, r22
     87a:	20 e0       	ldi	r18, 0x00	; 0
     87c:	30 e0       	ldi	r19, 0x00	; 0
     87e:	40 ea       	ldi	r20, 0xA0	; 160
     880:	50 e4       	ldi	r21, 0x40	; 64
     882:	6c 8d       	ldd	r22, Y+28	; 0x1c
     884:	7d 8d       	ldd	r23, Y+29	; 0x1d
     886:	8e 8d       	ldd	r24, Y+30	; 0x1e
     888:	9f 8d       	ldd	r25, Y+31	; 0x1f
     88a:	ce d5       	rcall	.+2972   	; 0x1428 <__mulsf3>
     88c:	28 89       	ldd	r18, Y+16	; 0x10
     88e:	39 89       	ldd	r19, Y+17	; 0x11
     890:	4a 89       	ldd	r20, Y+18	; 0x12
     892:	5b 89       	ldd	r21, Y+19	; 0x13
     894:	c9 d5       	rcall	.+2962   	; 0x1428 <__mulsf3>
     896:	26 d4       	rcall	.+2124   	; 0x10e4 <__fixunssfsi>
     898:	ef 81       	ldd	r30, Y+7	; 0x07
     89a:	f8 85       	ldd	r31, Y+8	; 0x08
     89c:	62 83       	std	Z+2, r22	; 0x02
				break;
     89e:	34 c0       	rjmp	.+104    	; 0x908 <tinyLED_update+0x2fe>
			case FLASH_ONCE:
				if(tinyLED_flash_once_time[i]>0){
     8a0:	d8 01       	movw	r26, r16
     8a2:	bc 90       	ld	r11, X
     8a4:	bb 20       	and	r11, r11
     8a6:	79 f1       	breq	.+94     	; 0x906 <tinyLED_update+0x2fc>
					rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*sinValue, rgb_colors[i].green*sinValue, rgb_colors[i].blue*sinValue};
     8a8:	70 e0       	ldi	r23, 0x00	; 0
     8aa:	80 e0       	ldi	r24, 0x00	; 0
     8ac:	90 e0       	ldi	r25, 0x00	; 0
     8ae:	4b d4       	rcall	.+2198   	; 0x1146 <__floatsisf>
     8b0:	29 85       	ldd	r18, Y+9	; 0x09
     8b2:	3a 85       	ldd	r19, Y+10	; 0x0a
     8b4:	4b 85       	ldd	r20, Y+11	; 0x0b
     8b6:	5c 85       	ldd	r21, Y+12	; 0x0c
     8b8:	b7 d5       	rcall	.+2926   	; 0x1428 <__mulsf3>
     8ba:	14 d4       	rcall	.+2088   	; 0x10e4 <__fixunssfsi>
     8bc:	ef 81       	ldd	r30, Y+7	; 0x07
     8be:	f8 85       	ldd	r31, Y+8	; 0x08
     8c0:	60 83       	st	Z, r22
     8c2:	6e 2d       	mov	r22, r14
     8c4:	70 e0       	ldi	r23, 0x00	; 0
     8c6:	80 e0       	ldi	r24, 0x00	; 0
     8c8:	90 e0       	ldi	r25, 0x00	; 0
     8ca:	3d d4       	rcall	.+2170   	; 0x1146 <__floatsisf>
     8cc:	29 85       	ldd	r18, Y+9	; 0x09
     8ce:	3a 85       	ldd	r19, Y+10	; 0x0a
     8d0:	4b 85       	ldd	r20, Y+11	; 0x0b
     8d2:	5c 85       	ldd	r21, Y+12	; 0x0c
     8d4:	a9 d5       	rcall	.+2898   	; 0x1428 <__mulsf3>
     8d6:	06 d4       	rcall	.+2060   	; 0x10e4 <__fixunssfsi>
     8d8:	af 81       	ldd	r26, Y+7	; 0x07
     8da:	b8 85       	ldd	r27, Y+8	; 0x08
     8dc:	11 96       	adiw	r26, 0x01	; 1
     8de:	6c 93       	st	X, r22
     8e0:	6f 2d       	mov	r22, r15
     8e2:	70 e0       	ldi	r23, 0x00	; 0
     8e4:	80 e0       	ldi	r24, 0x00	; 0
     8e6:	90 e0       	ldi	r25, 0x00	; 0
     8e8:	2e d4       	rcall	.+2140   	; 0x1146 <__floatsisf>
     8ea:	29 85       	ldd	r18, Y+9	; 0x09
     8ec:	3a 85       	ldd	r19, Y+10	; 0x0a
     8ee:	4b 85       	ldd	r20, Y+11	; 0x0b
     8f0:	5c 85       	ldd	r21, Y+12	; 0x0c
     8f2:	9a d5       	rcall	.+2868   	; 0x1428 <__mulsf3>
     8f4:	f7 d3       	rcall	.+2030   	; 0x10e4 <__fixunssfsi>
     8f6:	ef 81       	ldd	r30, Y+7	; 0x07
     8f8:	f8 85       	ldd	r31, Y+8	; 0x08
     8fa:	62 83       	std	Z+2, r22	; 0x02
					tinyLED_flash_once_time[i]--;
     8fc:	8f ef       	ldi	r24, 0xFF	; 255
     8fe:	8b 0d       	add	r24, r11
     900:	d8 01       	movw	r26, r16
     902:	8c 93       	st	X, r24
     904:	01 c0       	rjmp	.+2      	; 0x908 <tinyLED_update+0x2fe>
				}
				else{
					tinyLED_colors[i].color = OFF;
     906:	10 82       	st	Z, r1
     908:	b2 e0       	ldi	r27, 0x02	; 2
     90a:	2b 0e       	add	r2, r27
     90c:	31 1c       	adc	r3, r1
     90e:	e3 e0       	ldi	r30, 0x03	; 3
     910:	8e 0e       	add	r8, r30
     912:	91 1c       	adc	r9, r1
     914:	0f 5f       	subi	r16, 0xFF	; 255
     916:	1f 4f       	sbci	r17, 0xFF	; 255
	_Bool flash_on = now%(uint32_t)(1000/FLASH_RATE)   <   500/FLASH_RATE;
	_Bool ping_on = now%(uint32_t)(1000/PING_RATE)   <   1000*FLASH_TIME;
	struct RGB_Color rgb_colors[NUMBER_OF_LEDS];
	
		
	for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
     918:	2c 14       	cp	r2, r12
     91a:	3d 04       	cpc	r3, r13
     91c:	09 f0       	breq	.+2      	; 0x920 <tinyLED_update+0x316>
     91e:	d8 ce       	rjmp	.-592    	; 0x6d0 <tinyLED_update+0xc6>
     920:	ae 84       	ldd	r10, Y+14	; 0x0e
     922:	bf 84       	ldd	r11, Y+15	; 0x0f
				break;
			default:
				break;
		}
	}
	if(!tinyLED_RGB_Color_Compare(&rgb_colors, &tinyLED_old_colors)){
     924:	6f e5       	ldi	r22, 0x5F	; 95
     926:	7e e3       	ldi	r23, 0x3E	; 62
     928:	ce 01       	movw	r24, r28
     92a:	01 96       	adiw	r24, 0x01	; 1
     92c:	3e de       	rcall	.-900    	; 0x5aa <tinyLED_RGB_Color_Compare>
     92e:	81 11       	cpse	r24, r1
     930:	1e c0       	rjmp	.+60     	; 0x96e <tinyLED_update+0x364>
     932:	0f e5       	ldi	r16, 0x5F	; 95
     934:	1e e3       	ldi	r17, 0x3E	; 62
     936:	7e 01       	movw	r14, r28
     938:	f7 e0       	ldi	r31, 0x07	; 7
     93a:	ef 0e       	add	r14, r31
     93c:	f1 1c       	adc	r15, r1
		for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
		{
			// Write to LEDs
			//For some reason unknown to the writer the data-bus to the LEDs is serialized as GRB
			//which means the 24-bit data-bus will look like [Green[0:7], Red[0:7], Blue[0:7]]
			tinyLED_SPIWriteByte(rgb_colors[i].green);
     93e:	d5 01       	movw	r26, r10
     940:	11 96       	adiw	r26, 0x01	; 1
     942:	8c 91       	ld	r24, X
     944:	fd dd       	rcall	.-1030   	; 0x540 <tinyLED_SPIWriteByte>
			tinyLED_SPIWriteByte(rgb_colors[i].red);
     946:	f5 01       	movw	r30, r10
     948:	80 81       	ld	r24, Z
     94a:	fa dd       	rcall	.-1036   	; 0x540 <tinyLED_SPIWriteByte>
			tinyLED_SPIWriteByte(rgb_colors[i].blue);
     94c:	d5 01       	movw	r26, r10
     94e:	12 96       	adiw	r26, 0x02	; 2
     950:	8c 91       	ld	r24, X
     952:	f6 dd       	rcall	.-1044   	; 0x540 <tinyLED_SPIWriteByte>
			tinyLED_old_colors[i] = rgb_colors[i];
     954:	f5 01       	movw	r30, r10
     956:	81 91       	ld	r24, Z+
     958:	91 91       	ld	r25, Z+
     95a:	a1 91       	ld	r26, Z+
     95c:	5f 01       	movw	r10, r30
     95e:	f8 01       	movw	r30, r16
     960:	81 93       	st	Z+, r24
     962:	91 93       	st	Z+, r25
     964:	a1 93       	st	Z+, r26
     966:	8f 01       	movw	r16, r30
			default:
				break;
		}
	}
	if(!tinyLED_RGB_Color_Compare(&rgb_colors, &tinyLED_old_colors)){
		for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
     968:	ae 14       	cp	r10, r14
     96a:	bf 04       	cpc	r11, r15
     96c:	41 f7       	brne	.-48     	; 0x93e <tinyLED_update+0x334>
			tinyLED_SPIWriteByte(rgb_colors[i].red);
			tinyLED_SPIWriteByte(rgb_colors[i].blue);
			tinyLED_old_colors[i] = rgb_colors[i];
		}
	}
}
     96e:	6f 96       	adiw	r28, 0x1f	; 31
     970:	cd bf       	out	0x3d, r28	; 61
     972:	de bf       	out	0x3e, r29	; 62
     974:	df 91       	pop	r29
     976:	cf 91       	pop	r28
     978:	1f 91       	pop	r17
     97a:	0f 91       	pop	r16
     97c:	ff 90       	pop	r15
     97e:	ef 90       	pop	r14
     980:	df 90       	pop	r13
     982:	cf 90       	pop	r12
     984:	bf 90       	pop	r11
     986:	af 90       	pop	r10
     988:	9f 90       	pop	r9
     98a:	8f 90       	pop	r8
     98c:	7f 90       	pop	r7
     98e:	6f 90       	pop	r6
     990:	5f 90       	pop	r5
     992:	4f 90       	pop	r4
     994:	3f 90       	pop	r3
     996:	2f 90       	pop	r2
     998:	08 95       	ret

0000099a <tinyAxon_add_pulse>:
{
	// We want to check each slot in the pulse_queue, and
	// if we find an empty slot (0), we add a pulse.
	for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
	{
		if(pulse_queue[i] == 0){
     99a:	20 91 28 3e 	lds	r18, 0x3E28	; 0x803e28 <pulse_queue>
     99e:	30 91 29 3e 	lds	r19, 0x3E29	; 0x803e29 <pulse_queue+0x1>
     9a2:	23 2b       	or	r18, r19
     9a4:	51 f0       	breq	.+20     	; 0x9ba <tinyAxon_add_pulse+0x20>
     9a6:	ea e2       	ldi	r30, 0x2A	; 42
     9a8:	fe e3       	ldi	r31, 0x3E	; 62
     9aa:	21 e0       	ldi	r18, 0x01	; 1
     9ac:	30 e0       	ldi	r19, 0x00	; 0
     9ae:	b9 01       	movw	r22, r18
     9b0:	41 91       	ld	r20, Z+
     9b2:	51 91       	ld	r21, Z+
     9b4:	45 2b       	or	r20, r21
     9b6:	81 f4       	brne	.+32     	; 0x9d8 <tinyAxon_add_pulse+0x3e>
     9b8:	02 c0       	rjmp	.+4      	; 0x9be <tinyAxon_add_pulse+0x24>
     9ba:	60 e0       	ldi	r22, 0x00	; 0
     9bc:	70 e0       	ldi	r23, 0x00	; 0
			pulse_queue[i] = new_pulse;
     9be:	66 0f       	add	r22, r22
     9c0:	77 1f       	adc	r23, r23
     9c2:	fb 01       	movw	r30, r22
     9c4:	e8 5d       	subi	r30, 0xD8	; 216
     9c6:	f1 4c       	sbci	r31, 0xC1	; 193
     9c8:	80 83       	st	Z, r24
     9ca:	91 83       	std	Z+1, r25	; 0x01
			pulses_in_queue++;
     9cc:	80 91 3c 3e 	lds	r24, 0x3E3C	; 0x803e3c <pulses_in_queue>
     9d0:	8f 5f       	subi	r24, 0xFF	; 255
     9d2:	80 93 3c 3e 	sts	0x3E3C, r24	; 0x803e3c <pulses_in_queue>
			// We return so we only ever add one
			break;
     9d6:	08 95       	ret
     9d8:	2f 5f       	subi	r18, 0xFF	; 255
     9da:	3f 4f       	sbci	r19, 0xFF	; 255
*/
static void tinyAxon_add_pulse(uint16_t new_pulse)
{
	// We want to check each slot in the pulse_queue, and
	// if we find an empty slot (0), we add a pulse.
	for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
     9dc:	2a 30       	cpi	r18, 0x0A	; 10
     9de:	31 05       	cpc	r19, r1
     9e0:	31 f7       	brne	.-52     	; 0x9ae <tinyAxon_add_pulse+0x14>
     9e2:	08 95       	ret

000009e4 <find_newest_pulse>:
uint8_t find_newest_pulse() {
	uint16_t max;
	uint8_t current_index = 0;
	uint8_t return_index = 0;
	
	max = pulse_queue[current_index];
     9e4:	40 91 28 3e 	lds	r20, 0x3E28	; 0x803e28 <pulse_queue>
     9e8:	50 91 29 3e 	lds	r21, 0x3E29	; 0x803e29 <pulse_queue+0x1>
     9ec:	ea e2       	ldi	r30, 0x2A	; 42
     9ee:	fe e3       	ldi	r31, 0x3E	; 62
	
// This function will be used with pulse_queue to find the newest pulse
uint8_t find_newest_pulse() {
	uint16_t max;
	uint8_t current_index = 0;
	uint8_t return_index = 0;
     9f0:	80 e0       	ldi	r24, 0x00	; 0
	
	max = pulse_queue[current_index];
	
	for (current_index = 1; current_index < MAX_NUMBER_OF_PULSES; current_index++) {
     9f2:	91 e0       	ldi	r25, 0x01	; 1
		if (pulse_queue[current_index] > max) {
     9f4:	21 91       	ld	r18, Z+
     9f6:	31 91       	ld	r19, Z+
     9f8:	42 17       	cp	r20, r18
     9fa:	53 07       	cpc	r21, r19
     9fc:	10 f4       	brcc	.+4      	; 0xa02 <find_newest_pulse+0x1e>
     9fe:	89 2f       	mov	r24, r25
			return_index = current_index;
			max = pulse_queue[current_index];
     a00:	a9 01       	movw	r20, r18
	uint8_t current_index = 0;
	uint8_t return_index = 0;
	
	max = pulse_queue[current_index];
	
	for (current_index = 1; current_index < MAX_NUMBER_OF_PULSES; current_index++) {
     a02:	9f 5f       	subi	r25, 0xFF	; 255
     a04:	9a 30       	cpi	r25, 0x0A	; 10
     a06:	b1 f7       	brne	.-20     	; 0x9f4 <find_newest_pulse+0x10>
			return_index = current_index;
			max = pulse_queue[current_index];
		}
	}
	return return_index;
}
     a08:	08 95       	ret

00000a0a <tinyAxon_remove_pulse>:

/*
If the potential is very low, we want to try to remove a pulse.
*/
bool tinyAxon_remove_pulse(void)
{
     a0a:	cf 93       	push	r28
	// We want to return a bool indicating whether or not a pulse actually was removed.
	if(pulses_in_queue == 0){
     a0c:	c0 91 3c 3e 	lds	r28, 0x3E3C	; 0x803e3c <pulses_in_queue>
     a10:	cc 23       	and	r28, r28
     a12:	81 f0       	breq	.+32     	; 0xa34 <tinyAxon_remove_pulse+0x2a>
		//There was no pulse to remove.
		return false;
	}
	else{
		// If we are to remove a pulse, we want to remove the one that will fire last.
		uint16_t newest_pulse = pulse_queue[find_newest_pulse()];
     a14:	e7 df       	rcall	.-50     	; 0x9e4 <find_newest_pulse>
     a16:	e8 2f       	mov	r30, r24
     a18:	f0 e0       	ldi	r31, 0x00	; 0
     a1a:	ee 0f       	add	r30, r30
     a1c:	ff 1f       	adc	r31, r31
     a1e:	e8 5d       	subi	r30, 0xD8	; 216
     a20:	f1 4c       	sbci	r31, 0xC1	; 193
	
		// Now we want to check if the pulse is too far away to be affected by the low potential, or close enough that we decide to remove it.
		// (When we say that the pulse is too far away, it refers to the biological process of how the potential spreads from Dendrites to axon).
		if(newest_pulse > PULSE_NO_RETURN_TIME){
     a22:	80 81       	ld	r24, Z
     a24:	91 81       	ldd	r25, Z+1	; 0x01
     a26:	cd 97       	sbiw	r24, 0x3d	; 61
     a28:	38 f0       	brcs	.+14     	; 0xa38 <tinyAxon_remove_pulse+0x2e>
			// We decided to remove the pulse
			pulses_in_queue--;
     a2a:	c1 50       	subi	r28, 0x01	; 1
     a2c:	c0 93 3c 3e 	sts	0x3E3C, r28	; 0x803e3c <pulses_in_queue>
			return true;
     a30:	81 e0       	ldi	r24, 0x01	; 1
     a32:	03 c0       	rjmp	.+6      	; 0xa3a <tinyAxon_remove_pulse+0x30>
bool tinyAxon_remove_pulse(void)
{
	// We want to return a bool indicating whether or not a pulse actually was removed.
	if(pulses_in_queue == 0){
		//There was no pulse to remove.
		return false;
     a34:	80 e0       	ldi	r24, 0x00	; 0
     a36:	01 c0       	rjmp	.+2      	; 0xa3a <tinyAxon_remove_pulse+0x30>
			pulses_in_queue--;
			return true;
		}
		// Here we have found that there is a pulse queued, but it is old enough to let pass anyway, so now we need to put it back into the queue.
		else{
			return false;
     a38:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     a3a:	cf 91       	pop	r28
     a3c:	08 95       	ret

00000a3e <tinyAxon_update_potential>:
/*
Decides whether or not the axon should fire
If the axon does fire, the potential is reduced
*/
double tinyAxon_update_potential(double potential)
{	
     a3e:	cf 92       	push	r12
     a40:	df 92       	push	r13
     a42:	ef 92       	push	r14
     a44:	ff 92       	push	r15
     a46:	6b 01       	movw	r12, r22
     a48:	7c 01       	movw	r14, r24
	//While the neuron has enough potential to fire, we want to fire more
	while (potential > THRESHOLD_POTENTIAL)
     a4a:	20 e0       	ldi	r18, 0x00	; 0
     a4c:	30 e0       	ldi	r19, 0x00	; 0
     a4e:	48 ec       	ldi	r20, 0xC8	; 200
     a50:	51 e4       	ldi	r21, 0x41	; 65
     a52:	6f d4       	rcall	.+2270   	; 0x1332 <__gesf2>
     a54:	18 16       	cp	r1, r24
     a56:	84 f5       	brge	.+96     	; 0xab8 <tinyAxon_update_potential+0x7a>
	{
		// We have to check if there are already queued pulses, so that the frequency never exceeds FIRE_DELAY
		if(pulses_in_queue>0){
     a58:	80 91 3c 3e 	lds	r24, 0x3E3C	; 0x803e3c <pulses_in_queue>
     a5c:	88 23       	and	r24, r24
     a5e:	99 f0       	breq	.+38     	; 0xa86 <tinyAxon_update_potential+0x48>
			uint16_t newest_pulse = pulse_queue[find_newest_pulse()];
     a60:	c1 df       	rcall	.-126    	; 0x9e4 <find_newest_pulse>
     a62:	e8 2f       	mov	r30, r24
     a64:	f0 e0       	ldi	r31, 0x00	; 0
     a66:	ee 0f       	add	r30, r30
     a68:	ff 1f       	adc	r31, r31
     a6a:	e8 5d       	subi	r30, 0xD8	; 216
     a6c:	f1 4c       	sbci	r31, 0xC1	; 193
			
			// There is at least one pulse in the queue, and it is so close, that we need to offset the new pulse, so that we keep at least
			// one FIRE_DELAY between each pulse
			if(newest_pulse + FIRE_DELAY > TRAVLE_DELAY){
     a6e:	80 81       	ld	r24, Z
     a70:	91 81       	ldd	r25, Z+1	; 0x01
     a72:	c2 96       	adiw	r24, 0x32	; 50
     a74:	85 36       	cpi	r24, 0x65	; 101
     a76:	91 05       	cpc	r25, r1
     a78:	10 f0       	brcs	.+4      	; 0xa7e <tinyAxon_update_potential+0x40>
				tinyAxon_add_pulse(newest_pulse + FIRE_DELAY);
     a7a:	8f df       	rcall	.-226    	; 0x99a <tinyAxon_add_pulse>
     a7c:	07 c0       	rjmp	.+14     	; 0xa8c <tinyAxon_update_potential+0x4e>
			}
			// There is at least one pulse in the queue, but it's far enough away to ignore
			else{
				tinyAxon_add_pulse(TRAVLE_DELAY);
     a7e:	84 e6       	ldi	r24, 0x64	; 100
     a80:	90 e0       	ldi	r25, 0x00	; 0
     a82:	8b df       	rcall	.-234    	; 0x99a <tinyAxon_add_pulse>
     a84:	03 c0       	rjmp	.+6      	; 0xa8c <tinyAxon_update_potential+0x4e>
			}
		}
		// There are no pulses in the queue, so we add a pulse as normal
		else{
			tinyAxon_add_pulse(TRAVLE_DELAY);		
     a86:	84 e6       	ldi	r24, 0x64	; 100
     a88:	90 e0       	ldi	r25, 0x00	; 0
     a8a:	87 df       	rcall	.-242    	; 0x99a <tinyAxon_add_pulse>
		}
		
		potential += POSTFIRE_POTENTIAL_REACTION; // This is usually defined as a negative value, don't be confused by the +=
     a8c:	20 e0       	ldi	r18, 0x00	; 0
     a8e:	30 e0       	ldi	r19, 0x00	; 0
     a90:	40 ef       	ldi	r20, 0xF0	; 240
     a92:	51 e4       	ldi	r21, 0x41	; 65
     a94:	c7 01       	movw	r24, r14
     a96:	b6 01       	movw	r22, r12
     a98:	07 d2       	rcall	.+1038   	; 0xea8 <__subsf3>
     a9a:	6b 01       	movw	r12, r22
     a9c:	7c 01       	movw	r14, r24
		
		tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
     a9e:	44 e0       	ldi	r20, 0x04	; 4
     aa0:	63 e0       	ldi	r22, 0x03	; 3
     aa2:	81 e0       	ldi	r24, 0x01	; 1
     aa4:	72 dd       	rcall	.-1308   	; 0x58a <tinyLED_set_color_mode>
If the axon does fire, the potential is reduced
*/
double tinyAxon_update_potential(double potential)
{	
	//While the neuron has enough potential to fire, we want to fire more
	while (potential > THRESHOLD_POTENTIAL)
     aa6:	20 e0       	ldi	r18, 0x00	; 0
     aa8:	30 e0       	ldi	r19, 0x00	; 0
     aaa:	48 ec       	ldi	r20, 0xC8	; 200
     aac:	51 e4       	ldi	r21, 0x41	; 65
     aae:	c7 01       	movw	r24, r14
     ab0:	b6 01       	movw	r22, r12
     ab2:	3f d4       	rcall	.+2174   	; 0x1332 <__gesf2>
     ab4:	18 16       	cp	r1, r24
     ab6:	84 f2       	brlt	.-96     	; 0xa58 <tinyAxon_update_potential+0x1a>
		
		tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
	}
	
	// If the neuron has a very low potential, we want to remove a pulse from the queue (if there is one)
	if(potential < -THRESHOLD_POTENTIAL && pulses_in_queue > 0) // Perhaps this should be a separate variable? For now, we will just simply use -THRESHOLD_POTENTIAL
     ab8:	20 e0       	ldi	r18, 0x00	; 0
     aba:	30 e0       	ldi	r19, 0x00	; 0
     abc:	48 ec       	ldi	r20, 0xC8	; 200
     abe:	51 ec       	ldi	r21, 0xC1	; 193
     ac0:	c7 01       	movw	r24, r14
     ac2:	b6 01       	movw	r22, r12
     ac4:	5e d2       	rcall	.+1212   	; 0xf82 <__cmpsf2>
     ac6:	88 23       	and	r24, r24
     ac8:	0c f0       	brlt	.+2      	; 0xacc <tinyAxon_update_potential+0x8e>
     aca:	45 c0       	rjmp	.+138    	; 0xb56 <tinyAxon_update_potential+0x118>
     acc:	80 91 3c 3e 	lds	r24, 0x3E3C	; 0x803e3c <pulses_in_queue>
     ad0:	88 23       	and	r24, r24
     ad2:	01 f1       	breq	.+64     	; 0xb14 <tinyAxon_update_potential+0xd6>
	{
		// The neurons potential is low enough to attempt to remove a queued fire (Fire less)
		if(tinyAxon_remove_pulse())
     ad4:	9a df       	rcall	.-204    	; 0xa0a <tinyAxon_remove_pulse>
     ad6:	88 23       	and	r24, r24
     ad8:	f1 f1       	breq	.+124    	; 0xb56 <tinyAxon_update_potential+0x118>
		{
			// The potential has evened out a bit
			potential += THRESHOLD_POTENTIAL;
     ada:	20 e0       	ldi	r18, 0x00	; 0
     adc:	30 e0       	ldi	r19, 0x00	; 0
     ade:	48 ec       	ldi	r20, 0xC8	; 200
     ae0:	51 e4       	ldi	r21, 0x41	; 65
     ae2:	c7 01       	movw	r24, r14
     ae4:	b6 01       	movw	r22, r12
     ae6:	e1 d1       	rcall	.+962    	; 0xeaa <__addsf3>
     ae8:	6b 01       	movw	r12, r22
     aea:	7c 01       	movw	r14, r24
     aec:	34 c0       	rjmp	.+104    	; 0xb56 <tinyAxon_update_potential+0x118>
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
	{
		for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
		{
			if(pulse_queue[i] != 0){
     aee:	80 81       	ld	r24, Z
     af0:	91 81       	ldd	r25, Z+1	; 0x01
     af2:	00 97       	sbiw	r24, 0x00	; 0
     af4:	39 f0       	breq	.+14     	; 0xb04 <tinyAxon_update_potential+0xc6>
				pulse_queue[i]--;
     af6:	01 97       	sbiw	r24, 0x01	; 1
     af8:	80 83       	st	Z, r24
     afa:	91 83       	std	Z+1, r25	; 0x01
				
				// If the time went from 1 to 0, we fire the axon
				if(pulse_queue[i] == 0){
     afc:	89 2b       	or	r24, r25
     afe:	11 f4       	brne	.+4      	; 0xb04 <tinyAxon_update_potential+0xc6>
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
	pulses_in_queue--;
     b00:	41 50       	subi	r20, 0x01	; 1
Function to set firing.
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
     b02:	51 e0       	ldi	r21, 0x01	; 1
     b04:	32 96       	adiw	r30, 0x02	; 2
	}
	
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
	{
		for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
     b06:	e2 17       	cp	r30, r18
     b08:	f3 07       	cpc	r31, r19
     b0a:	89 f7       	brne	.-30     	; 0xaee <tinyAxon_update_potential+0xb0>
     b0c:	50 93 3d 3e 	sts	0x3E3D, r21	; 0x803e3d <tinyAxon_should_fire>
     b10:	40 93 3c 3e 	sts	0x3E3C, r20	; 0x803e3c <pulses_in_queue>
The function should set the DAC to fire for two
update cycles once the pulse flag is set high.
*/
static void tinyAxon_update_pulse_transmitter(void)
{
	if (tinyAxon_should_fire)
     b14:	80 91 3d 3e 	lds	r24, 0x3E3D	; 0x803e3d <tinyAxon_should_fire>
     b18:	88 23       	and	r24, r24
     b1a:	81 f0       	breq	.+32     	; 0xb3c <tinyAxon_update_potential+0xfe>
	{
		tinyAxon_should_fire = false;
     b1c:	10 92 3d 3e 	sts	0x3E3D, r1	; 0x803e3d <tinyAxon_should_fire>
		tinyAxon_has_fired = true;
     b20:	81 e0       	ldi	r24, 0x01	; 1
     b22:	80 93 3e 3e 	sts	0x3E3E, r24	; 0x803e3e <tinyAxon_has_fired>
*/
static void tinyAxon_start_sending_pulse()
{
	if (NEURONTYPE == EXCITATORY_NEURON)
	{
		DAC_set_output(EXCITATORY_NEURON_OUTPUT);
     b26:	87 ed       	ldi	r24, 0xD7	; 215
     b28:	90 e0       	ldi	r25, 0x00	; 0
     b2a:	0f db       	rcall	.-2530   	; 0x14a <DAC_set_output>
		axonOutputValue=EXCITATORY_NEURON_OUTPUT;
     b2c:	87 ed       	ldi	r24, 0xD7	; 215
     b2e:	80 93 27 3e 	sts	0x3E27, r24	; 0x803e27 <axonOutputValue>
	{
		DAC_set_output(INHIBITORY_NEURON_OUTPUT);
		axonOutputValue=INHIBITORY_NEURON_OUTPUT;
	}
	
	tinyLED_set_color_mode(OUT_LED, WHITE, FLASH_ONCE);
     b32:	44 e0       	ldi	r20, 0x04	; 4
     b34:	64 e0       	ldi	r22, 0x04	; 4
     b36:	80 e0       	ldi	r24, 0x00	; 0
     b38:	28 dd       	rcall	.-1456   	; 0x58a <tinyLED_set_color_mode>
     b3a:	18 c0       	rjmp	.+48     	; 0xb6c <tinyAxon_update_potential+0x12e>
		tinyAxon_should_fire = false;
		tinyAxon_has_fired = true;
		
		tinyAxon_start_sending_pulse();
	}
	else if (tinyAxon_has_fired)
     b3c:	80 91 3e 3e 	lds	r24, 0x3E3E	; 0x803e3e <tinyAxon_has_fired>
     b40:	88 23       	and	r24, r24
     b42:	19 f0       	breq	.+6      	; 0xb4a <tinyAxon_update_potential+0x10c>
	{
		tinyAxon_has_fired = false;
     b44:	10 92 3e 3e 	sts	0x3E3E, r1	; 0x803e3e <tinyAxon_has_fired>
     b48:	11 c0       	rjmp	.+34     	; 0xb6c <tinyAxon_update_potential+0x12e>
	tinyLED_set_color_mode(OUT_LED, WHITE, FLASH_ONCE);
}

static void tinyAxon_stop_sending_pulse()
{
	DAC_set_output(NO_SIGNAL_OUTPUT);
     b4a:	80 e0       	ldi	r24, 0x00	; 0
     b4c:	90 e0       	ldi	r25, 0x00	; 0
     b4e:	fd da       	rcall	.-2566   	; 0x14a <DAC_set_output>
	axonOutputValue=NO_SIGNAL_OUTPUT;
     b50:	10 92 27 3e 	sts	0x3E27, r1	; 0x803e27 <axonOutputValue>
     b54:	0b c0       	rjmp	.+22     	; 0xb6c <tinyAxon_update_potential+0x12e>
			potential += THRESHOLD_POTENTIAL;
		}
	}
	
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
     b56:	40 91 3c 3e 	lds	r20, 0x3E3C	; 0x803e3c <pulses_in_queue>
     b5a:	44 23       	and	r20, r20
     b5c:	d9 f2       	breq	.-74     	; 0xb14 <tinyAxon_update_potential+0xd6>
     b5e:	50 91 3d 3e 	lds	r21, 0x3E3D	; 0x803e3d <tinyAxon_should_fire>
     b62:	e8 e2       	ldi	r30, 0x28	; 40
     b64:	fe e3       	ldi	r31, 0x3E	; 62
     b66:	2c e3       	ldi	r18, 0x3C	; 60
     b68:	3e e3       	ldi	r19, 0x3E	; 62
     b6a:	c1 cf       	rjmp	.-126    	; 0xaee <tinyAxon_update_potential+0xb0>
	}
	
	// Here we set the actual output of the DAC (Digital to Analog Converter)
	tinyAxon_update_pulse_transmitter();
	
	tinyDebugger_send_uint8("Axon", axonOutputValue);
     b6c:	60 91 27 3e 	lds	r22, 0x3E27	; 0x803e27 <axonOutputValue>
     b70:	81 e2       	ldi	r24, 0x21	; 33
     b72:	96 e9       	ldi	r25, 0x96	; 150
     b74:	0c dc       	rcall	.-2024   	; 0x38e <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("Pulses", pulses_in_queue);
     b76:	60 91 3c 3e 	lds	r22, 0x3E3C	; 0x803e3c <pulses_in_queue>
     b7a:	86 e2       	ldi	r24, 0x26	; 38
     b7c:	96 e9       	ldi	r25, 0x96	; 150
     b7e:	07 dc       	rcall	.-2034   	; 0x38e <tinyDebugger_send_uint8>
	
	return potential;
}
     b80:	c7 01       	movw	r24, r14
     b82:	b6 01       	movw	r22, r12
     b84:	ff 90       	pop	r15
     b86:	ef 90       	pop	r14
     b88:	df 90       	pop	r13
     b8a:	cf 90       	pop	r12
     b8c:	08 95       	ret

00000b8e <tinyDendrite_update_signals>:
/*
This function converts the 8 bit value from the ADC into one of the signal types defined in DendriteSignal
We also update the charging state
*/
void tinyDendrite_update_signals(void)
{
     b8e:	8f 92       	push	r8
     b90:	9f 92       	push	r9
     b92:	bf 92       	push	r11
     b94:	cf 92       	push	r12
     b96:	df 92       	push	r13
     b98:	ef 92       	push	r14
     b9a:	ff 92       	push	r15
     b9c:	0f 93       	push	r16
     b9e:	1f 93       	push	r17
     ba0:	cf 93       	push	r28
     ba2:	df 93       	push	r29
     ba4:	0f 2e       	mov	r0, r31
     ba6:	f0 e1       	ldi	r31, 0x10	; 16
     ba8:	ef 2e       	mov	r14, r31
     baa:	fe e3       	ldi	r31, 0x3E	; 62
     bac:	ff 2e       	mov	r15, r31
     bae:	f0 2d       	mov	r31, r0
     bb0:	09 e4       	ldi	r16, 0x49	; 73
     bb2:	1e e3       	ldi	r17, 0x3E	; 62
     bb4:	0f 2e       	mov	r0, r31
     bb6:	f3 e5       	ldi	r31, 0x53	; 83
     bb8:	cf 2e       	mov	r12, r31
     bba:	fe e3       	ldi	r31, 0x3E	; 62
     bbc:	df 2e       	mov	r13, r31
     bbe:	f0 2d       	mov	r31, r0
     bc0:	e8 01       	movw	r28, r16
*/
static void tinyDendrite_read_signals(void)
{
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_values[i] = ADC_get_conversion(Dendrite_ports[i]);
     bc2:	d7 01       	movw	r26, r14
     bc4:	8d 91       	ld	r24, X+
     bc6:	7d 01       	movw	r14, r26
     bc8:	7f da       	rcall	.-2818   	; 0xc8 <ADC_get_conversion>
     bca:	89 93       	st	Y+, r24
     bcc:	99 93       	st	Y+, r25
/*
This function reads the voltage at the Dendrite inputs with the ADC
*/
static void tinyDendrite_read_signals(void)
{
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
     bce:	cc 15       	cp	r28, r12
     bd0:	dd 05       	cpc	r29, r13
     bd2:	b9 f7       	brne	.-18     	; 0xbc2 <tinyDendrite_update_signals+0x34>
	{
		tinyDendrite_values[i] = ADC_get_conversion(Dendrite_ports[i]);
	}
	tinyDebugger_send_int("D1", tinyDendrite_values[0]);
     bd4:	c9 e4       	ldi	r28, 0x49	; 73
     bd6:	de e3       	ldi	r29, 0x3E	; 62
     bd8:	68 81       	ld	r22, Y
     bda:	79 81       	ldd	r23, Y+1	; 0x01
     bdc:	8d e2       	ldi	r24, 0x2D	; 45
     bde:	96 e9       	ldi	r25, 0x96	; 150
     be0:	d5 db       	rcall	.-2134   	; 0x38c <tinyDebugger_send_int>
	tinyDebugger_send_int("D2", tinyDendrite_values[1]);
     be2:	6a 81       	ldd	r22, Y+2	; 0x02
     be4:	7b 81       	ldd	r23, Y+3	; 0x03
     be6:	80 e3       	ldi	r24, 0x30	; 48
     be8:	96 e9       	ldi	r25, 0x96	; 150
     bea:	d0 db       	rcall	.-2144   	; 0x38c <tinyDebugger_send_int>
	tinyDebugger_send_int("D3", tinyDendrite_values[2]);
     bec:	6c 81       	ldd	r22, Y+4	; 0x04
     bee:	7d 81       	ldd	r23, Y+5	; 0x05
     bf0:	83 e3       	ldi	r24, 0x33	; 51
     bf2:	96 e9       	ldi	r25, 0x96	; 150
     bf4:	cb db       	rcall	.-2154   	; 0x38c <tinyDebugger_send_int>
	tinyDebugger_send_int("D4", tinyDendrite_values[3]);
     bf6:	6e 81       	ldd	r22, Y+6	; 0x06
     bf8:	7f 81       	ldd	r23, Y+7	; 0x07
     bfa:	86 e3       	ldi	r24, 0x36	; 54
     bfc:	96 e9       	ldi	r25, 0x96	; 150
     bfe:	c6 db       	rcall	.-2164   	; 0x38c <tinyDebugger_send_int>
	tinyDebugger_send_int("D5", tinyDendrite_values[4]);
     c00:	68 85       	ldd	r22, Y+8	; 0x08
     c02:	79 85       	ldd	r23, Y+9	; 0x09
     c04:	89 e3       	ldi	r24, 0x39	; 57
     c06:	96 e9       	ldi	r25, 0x96	; 150
     c08:	c1 db       	rcall	.-2174   	; 0x38c <tinyDebugger_send_int>
     c0a:	e4 e4       	ldi	r30, 0x44	; 68
     c0c:	fe e3       	ldi	r31, 0x3E	; 62
     c0e:	cf e3       	ldi	r28, 0x3F	; 63
     c10:	de e3       	ldi	r29, 0x3E	; 62
     c12:	49 e4       	ldi	r20, 0x49	; 73
     c14:	5e e3       	ldi	r21, 0x3E	; 62
{
	
	//Read the analog voltage values on each of the Dendrites
	tinyDendrite_read_signals();
	
	_Bool charging = false;
     c16:	80 e0       	ldi	r24, 0x00	; 0
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     c18:	61 e0       	ldi	r22, 0x01	; 1
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
		}
		else if (tinyDendrite_values[i] > HIGH_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
     c1a:	0f 2e       	mov	r0, r31
     c1c:	f3 e0       	ldi	r31, 0x03	; 3
     c1e:	bf 2e       	mov	r11, r31
     c20:	f0 2d       	mov	r31, r0
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     c22:	68 94       	set
     c24:	cc 24       	eor	r12, r12
     c26:	c1 f8       	bld	r12, 1
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     c28:	68 94       	set
     c2a:	dd 24       	eor	r13, r13
     c2c:	d2 f8       	bld	r13, 2
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     c2e:	0f 2e       	mov	r0, r31
     c30:	f6 e0       	ldi	r31, 0x06	; 6
     c32:	ef 2e       	mov	r14, r31
     c34:	f0 2d       	mov	r31, r0
			tinyDendrite_current_signals[i] = CHARGING;
			charging = true;
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     c36:	0f 2e       	mov	r0, r31
     c38:	f5 e0       	ldi	r31, 0x05	; 5
     c3a:	ff 2e       	mov	r15, r31
     c3c:	f0 2d       	mov	r31, r0
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = CHARGING;
     c3e:	77 e0       	ldi	r23, 0x07	; 7
     c40:	4f 01       	movw	r8, r30
	
	_Bool charging = false;
	
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
     c42:	90 81       	ld	r25, Z
     c44:	99 93       	st	Y+, r25
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
     c46:	d8 01       	movw	r26, r16
     c48:	2d 91       	ld	r18, X+
     c4a:	3d 91       	ld	r19, X+
     c4c:	8d 01       	movw	r16, r26
     c4e:	29 3e       	cpi	r18, 0xE9	; 233
     c50:	31 05       	cpc	r19, r1
     c52:	18 f0       	brcs	.+6      	; 0xc5a <tinyDendrite_update_signals+0xcc>
		{
			tinyDendrite_current_signals[i] = CHARGING;
     c54:	70 83       	st	Z, r23
			charging = true;
     c56:	86 2f       	mov	r24, r22
     c58:	1f c0       	rjmp	.+62     	; 0xc98 <tinyDendrite_update_signals+0x10a>
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
     c5a:	28 3c       	cpi	r18, 0xC8	; 200
     c5c:	31 05       	cpc	r19, r1
     c5e:	10 f0       	brcs	.+4      	; 0xc64 <tinyDendrite_update_signals+0xd6>
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     c60:	f0 82       	st	Z, r15
     c62:	1a c0       	rjmp	.+52     	; 0xc98 <tinyDendrite_update_signals+0x10a>
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
     c64:	27 3a       	cpi	r18, 0xA7	; 167
     c66:	31 05       	cpc	r19, r1
     c68:	10 f0       	brcs	.+4      	; 0xc6e <tinyDendrite_update_signals+0xe0>
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     c6a:	e0 82       	st	Z, r14
     c6c:	15 c0       	rjmp	.+42     	; 0xc98 <tinyDendrite_update_signals+0x10a>
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
     c6e:	25 38       	cpi	r18, 0x85	; 133
     c70:	31 05       	cpc	r19, r1
     c72:	10 f0       	brcs	.+4      	; 0xc78 <tinyDendrite_update_signals+0xea>
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     c74:	d0 82       	st	Z, r13
     c76:	10 c0       	rjmp	.+32     	; 0xc98 <tinyDendrite_update_signals+0x10a>
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
     c78:	24 36       	cpi	r18, 0x64	; 100
     c7a:	31 05       	cpc	r19, r1
     c7c:	10 f0       	brcs	.+4      	; 0xc82 <tinyDendrite_update_signals+0xf4>
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     c7e:	c0 82       	st	Z, r12
     c80:	0b c0       	rjmp	.+22     	; 0xc98 <tinyDendrite_update_signals+0x10a>
		}
		else if (tinyDendrite_values[i] > HIGH_INHIB_THRESHOLD)
     c82:	23 34       	cpi	r18, 0x43	; 67
     c84:	31 05       	cpc	r19, r1
     c86:	10 f0       	brcs	.+4      	; 0xc8c <tinyDendrite_update_signals+0xfe>
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
     c88:	b0 82       	st	Z, r11
     c8a:	06 c0       	rjmp	.+12     	; 0xc98 <tinyDendrite_update_signals+0x10a>
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
     c8c:	22 32       	cpi	r18, 0x22	; 34
     c8e:	31 05       	cpc	r19, r1
     c90:	10 f0       	brcs	.+4      	; 0xc96 <tinyDendrite_update_signals+0x108>
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     c92:	60 83       	st	Z, r22
     c94:	01 c0       	rjmp	.+2      	; 0xc98 <tinyDendrite_update_signals+0x10a>
		}
		else
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     c96:	10 82       	st	Z, r1
		}
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
     c98:	d4 01       	movw	r26, r8
     c9a:	2c 91       	ld	r18, X
     c9c:	92 13       	cpse	r25, r18
     c9e:	01 c0       	rjmp	.+2      	; 0xca2 <tinyDendrite_update_signals+0x114>
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     ca0:	1c 92       	st	X, r1
     ca2:	31 96       	adiw	r30, 0x01	; 1
	//Read the analog voltage values on each of the Dendrites
	tinyDendrite_read_signals();
	
	_Bool charging = false;
	
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
     ca4:	e4 17       	cp	r30, r20
     ca6:	f5 07       	cpc	r31, r21
     ca8:	59 f6       	brne	.-106    	; 0xc40 <tinyDendrite_update_signals+0xb2>
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
		}
	}
	tinyCharge_set_charging_mode(charging);
     caa:	60 db       	rcall	.-2368   	; 0x36c <tinyCharge_set_charging_mode>
}
     cac:	df 91       	pop	r29
     cae:	cf 91       	pop	r28
     cb0:	1f 91       	pop	r17
     cb2:	0f 91       	pop	r16
     cb4:	ff 90       	pop	r15
     cb6:	ef 90       	pop	r14
     cb8:	df 90       	pop	r13
     cba:	cf 90       	pop	r12
     cbc:	bf 90       	pop	r11
     cbe:	9f 90       	pop	r9
     cc0:	8f 90       	pop	r8
     cc2:	08 95       	ret

00000cc4 <tinyDendrite_get_potential>:
outside. It uses the previously declared functions to return the potential.
*/
int16_t tinyDendrite_get_potential()
{
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
     cc4:	64 df       	rcall	.-312    	; 0xb8e <tinyDendrite_update_signals>
     cc6:	e4 e4       	ldi	r30, 0x44	; 68
     cc8:	fe e3       	ldi	r31, 0x3E	; 62
     cca:	49 e4       	ldi	r20, 0x49	; 73
     ccc:	5e e3       	ldi	r21, 0x3E	; 62
	
	int16_t return_potential_val = 0;
     cce:	20 e0       	ldi	r18, 0x00	; 0
     cd0:	30 e0       	ldi	r19, 0x00	; 0
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		switch(tinyDendrite_current_signals[i])
     cd2:	91 91       	ld	r25, Z+
     cd4:	93 30       	cpi	r25, 0x03	; 3
     cd6:	a1 f0       	breq	.+40     	; 0xd00 <tinyDendrite_get_potential+0x3c>
     cd8:	28 f4       	brcc	.+10     	; 0xce4 <tinyDendrite_get_potential+0x20>
     cda:	91 30       	cpi	r25, 0x01	; 1
     cdc:	b9 f0       	breq	.+46     	; 0xd0c <tinyDendrite_get_potential+0x48>
     cde:	92 30       	cpi	r25, 0x02	; 2
     ce0:	91 f0       	breq	.+36     	; 0xd06 <tinyDendrite_get_potential+0x42>
     ce2:	16 c0       	rjmp	.+44     	; 0xd10 <tinyDendrite_get_potential+0x4c>
     ce4:	95 30       	cpi	r25, 0x05	; 5
     ce6:	31 f0       	breq	.+12     	; 0xcf4 <tinyDendrite_get_potential+0x30>
     ce8:	40 f0       	brcs	.+16     	; 0xcfa <tinyDendrite_get_potential+0x36>
     cea:	96 30       	cpi	r25, 0x06	; 6
     cec:	89 f4       	brne	.+34     	; 0xd10 <tinyDendrite_get_potential+0x4c>
		{
			case NO_SIGNAL:
				return_potential_val += NO_SIGNAL_REACTION;
				break;
			case HIGH_EXCITE:
				return_potential_val += HIGH_EXCITE_REACTION;
     cee:	2c 5c       	subi	r18, 0xCC	; 204
     cf0:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     cf2:	0e c0       	rjmp	.+28     	; 0xd10 <tinyDendrite_get_potential+0x4c>
			case NORMAL_EXCITE:
				return_potential_val += NORMAL_EXCITE_REACTION;
     cf4:	26 5e       	subi	r18, 0xE6	; 230
     cf6:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     cf8:	0b c0       	rjmp	.+22     	; 0xd10 <tinyDendrite_get_potential+0x4c>
			case LOW_EXCITE:
				return_potential_val += LOW_EXCITE_REACTION;
     cfa:	2c 5e       	subi	r18, 0xEC	; 236
     cfc:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     cfe:	08 c0       	rjmp	.+16     	; 0xd10 <tinyDendrite_get_potential+0x4c>
			case HIGH_INHIB:
				return_potential_val += HIGH_INHIB_REACTION;
     d00:	22 53       	subi	r18, 0x32	; 50
     d02:	31 09       	sbc	r19, r1
				break;
     d04:	05 c0       	rjmp	.+10     	; 0xd10 <tinyDendrite_get_potential+0x4c>
			case NORMAL_INHIB:
				return_potential_val += NORMAL_INHIB_REACTION;
     d06:	2a 51       	subi	r18, 0x1A	; 26
     d08:	31 09       	sbc	r19, r1
				break;
     d0a:	02 c0       	rjmp	.+4      	; 0xd10 <tinyDendrite_get_potential+0x4c>
			case LOW_INHIB:
				return_potential_val += LOW_INHIB_REACTION;
     d0c:	24 51       	subi	r18, 0x14	; 20
     d0e:	31 09       	sbc	r19, r1
{
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
	
	int16_t return_potential_val = 0;
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
     d10:	e4 17       	cp	r30, r20
     d12:	f5 07       	cpc	r31, r21
     d14:	f1 f6       	brne	.-68     	; 0xcd2 <tinyDendrite_get_potential+0xe>
			default:
				break;
		}
	}
	return return_potential_val;
}
     d16:	c9 01       	movw	r24, r18
     d18:	08 95       	ret

00000d1a <tinyDendrite_update_potential>:

double tinyDendrite_update_potential(double potential){
     d1a:	cf 92       	push	r12
     d1c:	df 92       	push	r13
     d1e:	ef 92       	push	r14
     d20:	ff 92       	push	r15
     d22:	6b 01       	movw	r12, r22
     d24:	7c 01       	movw	r14, r24
	
	int16_t potential_change = tinyDendrite_get_potential();
     d26:	ce df       	rcall	.-100    	; 0xcc4 <tinyDendrite_get_potential>
	potential += potential_change;
	return potential;
     d28:	bc 01       	movw	r22, r24
     d2a:	99 0f       	add	r25, r25
     d2c:	88 0b       	sbc	r24, r24
     d2e:	99 0b       	sbc	r25, r25
     d30:	0a d2       	rcall	.+1044   	; 0x1146 <__floatsisf>
     d32:	a7 01       	movw	r20, r14
     d34:	96 01       	movw	r18, r12
     d36:	b9 d0       	rcall	.+370    	; 0xeaa <__addsf3>
     d38:	ff 90       	pop	r15
     d3a:	ef 90       	pop	r14
     d3c:	df 90       	pop	r13
     d3e:	cf 90       	pop	r12
     d40:	08 95       	ret

00000d42 <__vector_6>:
This function is called every time the RTC (Real Time Clock) counter overflows.
With the current settings, it will be called every ms.
The RTC clock runs at 1kHz, and the number of cycles before overflow is set with RTC.PER = someHexValue (e.g. 0x20) in src/rtc.c
*/
ISR(RTC_CNT_vect)
{
     d42:	1f 92       	push	r1
     d44:	0f 92       	push	r0
     d46:	0f b6       	in	r0, 0x3f	; 63
     d48:	0f 92       	push	r0
     d4a:	11 24       	eor	r1, r1
     d4c:	2f 93       	push	r18
     d4e:	3f 93       	push	r19
     d50:	4f 93       	push	r20
     d52:	5f 93       	push	r21
     d54:	6f 93       	push	r22
     d56:	7f 93       	push	r23
     d58:	8f 93       	push	r24
     d5a:	9f 93       	push	r25
     d5c:	af 93       	push	r26
     d5e:	bf 93       	push	r27
     d60:	cf 93       	push	r28
     d62:	ef 93       	push	r30
     d64:	ff 93       	push	r31
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     d66:	c1 e0       	ldi	r28, 0x01	; 1
     d68:	c0 93 53 3e 	sts	0x3E53, r28	; 0x803e53 <tinyISR_interrupt_flag>
{
	// Set flag to let main loop run a new cycle
	tinyISR_setflag(true);
	
	// Timer counter incrementation
	tinyTime_counter_increment();
     d6c:	4f db       	rcall	.-2402   	; 0x40c <tinyTime_counter_increment>

	/* Overflow interrupt flag has to be cleared manually */
	RTC.INTFLAGS = RTC_OVF_bm;
     d6e:	c0 93 43 01 	sts	0x0143, r28	; 0x800143 <__TEXT_REGION_LENGTH__+0x700143>
}
     d72:	ff 91       	pop	r31
     d74:	ef 91       	pop	r30
     d76:	cf 91       	pop	r28
     d78:	bf 91       	pop	r27
     d7a:	af 91       	pop	r26
     d7c:	9f 91       	pop	r25
     d7e:	8f 91       	pop	r24
     d80:	7f 91       	pop	r23
     d82:	6f 91       	pop	r22
     d84:	5f 91       	pop	r21
     d86:	4f 91       	pop	r20
     d88:	3f 91       	pop	r19
     d8a:	2f 91       	pop	r18
     d8c:	0f 90       	pop	r0
     d8e:	0f be       	out	0x3f, r0	; 63
     d90:	0f 90       	pop	r0
     d92:	1f 90       	pop	r1
     d94:	18 95       	reti

00000d96 <tinyISR_setflag>:
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     d96:	80 93 53 3e 	sts	0x3E53, r24	; 0x803e53 <tinyISR_interrupt_flag>
     d9a:	08 95       	ret

00000d9c <tinyISR_getflag>:
}

_Bool tinyISR_getflag(void)
{
	return tinyISR_interrupt_flag;
}
     d9c:	80 91 53 3e 	lds	r24, 0x3E53	; 0x803e53 <tinyISR_interrupt_flag>
     da0:	08 95       	ret

00000da2 <tinyPotential_update>:
/*
The function which will run in the main loop.
This function will run on interrupts by the RTC module.
*/
void tinyPotential_update()
{
     da2:	cf 92       	push	r12
     da4:	df 92       	push	r13
     da6:	ef 92       	push	r14
     da8:	ff 92       	push	r15
Function to decay the potential towards 0
*/
static void tinyPotential_decay()
{
		
	uint8_t time_since_last_update = tinyTime_now() - previous_update_time;
     daa:	44 db       	rcall	.-2424   	; 0x434 <tinyTime_now>
	tinyPotential_potential *= (exp(-((float)time_since_last_update/(float)TINYPOTENTIAL_TIME_CONST)));
     dac:	80 91 54 3e 	lds	r24, 0x3E54	; 0x803e54 <previous_update_time>
     db0:	68 1b       	sub	r22, r24
     db2:	70 e0       	ldi	r23, 0x00	; 0
     db4:	80 e0       	ldi	r24, 0x00	; 0
     db6:	90 e0       	ldi	r25, 0x00	; 0
     db8:	c4 d1       	rcall	.+904    	; 0x1142 <__floatunsisf>
     dba:	20 e0       	ldi	r18, 0x00	; 0
     dbc:	30 e0       	ldi	r19, 0x00	; 0
     dbe:	48 ec       	ldi	r20, 0xC8	; 200
     dc0:	52 e4       	ldi	r21, 0x42	; 66
     dc2:	e4 d0       	rcall	.+456    	; 0xf8c <__divsf3>
     dc4:	90 58       	subi	r25, 0x80	; 128
     dc6:	5c d1       	rcall	.+696    	; 0x1080 <exp>
     dc8:	20 91 58 3e 	lds	r18, 0x3E58	; 0x803e58 <tinyPotential_potential>
     dcc:	30 91 59 3e 	lds	r19, 0x3E59	; 0x803e59 <tinyPotential_potential+0x1>
     dd0:	40 91 5a 3e 	lds	r20, 0x3E5A	; 0x803e5a <tinyPotential_potential+0x2>
     dd4:	50 91 5b 3e 	lds	r21, 0x3E5B	; 0x803e5b <tinyPotential_potential+0x3>
     dd8:	27 d3       	rcall	.+1614   	; 0x1428 <__mulsf3>
     dda:	6b 01       	movw	r12, r22
     ddc:	7c 01       	movw	r14, r24
	if(fabs(tinyPotential_potential)<0.1){
     dde:	9f 77       	andi	r25, 0x7F	; 127
     de0:	2d ec       	ldi	r18, 0xCD	; 205
     de2:	3c ec       	ldi	r19, 0xCC	; 204
     de4:	4c ec       	ldi	r20, 0xCC	; 204
     de6:	5d e3       	ldi	r21, 0x3D	; 61
     de8:	cc d0       	rcall	.+408    	; 0xf82 <__cmpsf2>
     dea:	88 23       	and	r24, r24
     dec:	4c f0       	brlt	.+18     	; 0xe00 <tinyPotential_update+0x5e>
*/
static void tinyPotential_decay()
{
		
	uint8_t time_since_last_update = tinyTime_now() - previous_update_time;
	tinyPotential_potential *= (exp(-((float)time_since_last_update/(float)TINYPOTENTIAL_TIME_CONST)));
     dee:	c0 92 58 3e 	sts	0x3E58, r12	; 0x803e58 <tinyPotential_potential>
     df2:	d0 92 59 3e 	sts	0x3E59, r13	; 0x803e59 <tinyPotential_potential+0x1>
     df6:	e0 92 5a 3e 	sts	0x3E5A, r14	; 0x803e5a <tinyPotential_potential+0x2>
     dfa:	f0 92 5b 3e 	sts	0x3E5B, r15	; 0x803e5b <tinyPotential_potential+0x3>
     dfe:	08 c0       	rjmp	.+16     	; 0xe10 <tinyPotential_update+0x6e>
	if(fabs(tinyPotential_potential)<0.1){
		tinyPotential_potential=0;
     e00:	10 92 58 3e 	sts	0x3E58, r1	; 0x803e58 <tinyPotential_potential>
     e04:	10 92 59 3e 	sts	0x3E59, r1	; 0x803e59 <tinyPotential_potential+0x1>
     e08:	10 92 5a 3e 	sts	0x3E5A, r1	; 0x803e5a <tinyPotential_potential+0x2>
     e0c:	10 92 5b 3e 	sts	0x3E5B, r1	; 0x803e5b <tinyPotential_potential+0x3>
	}
	previous_update_time = tinyTime_now();
     e10:	11 db       	rcall	.-2526   	; 0x434 <tinyTime_now>
     e12:	60 93 54 3e 	sts	0x3E54, r22	; 0x803e54 <previous_update_time>
     e16:	70 93 55 3e 	sts	0x3E55, r23	; 0x803e55 <previous_update_time+0x1>
     e1a:	80 93 56 3e 	sts	0x3E56, r24	; 0x803e56 <previous_update_time+0x2>
     e1e:	90 93 57 3e 	sts	0x3E57, r25	; 0x803e57 <previous_update_time+0x3>
void tinyPotential_update()
{
	//Some of the potential in the neuron has decayed away
	tinyPotential_decay();
	// Update potential with values from Dendrites
	tinyPotential_potential = tinyDendrite_update_potential(tinyPotential_potential);
     e22:	60 91 58 3e 	lds	r22, 0x3E58	; 0x803e58 <tinyPotential_potential>
     e26:	70 91 59 3e 	lds	r23, 0x3E59	; 0x803e59 <tinyPotential_potential+0x1>
     e2a:	80 91 5a 3e 	lds	r24, 0x3E5A	; 0x803e5a <tinyPotential_potential+0x2>
     e2e:	90 91 5b 3e 	lds	r25, 0x3E5B	; 0x803e5b <tinyPotential_potential+0x3>
     e32:	73 df       	rcall	.-282    	; 0xd1a <tinyDendrite_update_potential>
     e34:	ab 01       	movw	r20, r22
     e36:	bc 01       	movw	r22, r24
     e38:	40 93 58 3e 	sts	0x3E58, r20	; 0x803e58 <tinyPotential_potential>
     e3c:	50 93 59 3e 	sts	0x3E59, r21	; 0x803e59 <tinyPotential_potential+0x1>
     e40:	60 93 5a 3e 	sts	0x3E5A, r22	; 0x803e5a <tinyPotential_potential+0x2>
     e44:	70 93 5b 3e 	sts	0x3E5B, r23	; 0x803e5b <tinyPotential_potential+0x3>
	tinyDebugger_send_double("DendP", tinyPotential_potential);
     e48:	8c e3       	ldi	r24, 0x3C	; 60
     e4a:	96 e9       	ldi	r25, 0x96	; 150
     e4c:	a1 da       	rcall	.-2750   	; 0x390 <tinyDebugger_send_double>
	
	// Update potential from button press
	tinyPotential_potential = tinyButton_update_potential(tinyPotential_potential);
     e4e:	60 91 58 3e 	lds	r22, 0x3E58	; 0x803e58 <tinyPotential_potential>
     e52:	70 91 59 3e 	lds	r23, 0x3E59	; 0x803e59 <tinyPotential_potential+0x1>
     e56:	80 91 5a 3e 	lds	r24, 0x3E5A	; 0x803e5a <tinyPotential_potential+0x2>
     e5a:	90 91 5b 3e 	lds	r25, 0x3E5B	; 0x803e5b <tinyPotential_potential+0x3>
     e5e:	66 db       	rcall	.-2356   	; 0x52c <tinyButton_update_potential>
     e60:	60 93 58 3e 	sts	0x3E58, r22	; 0x803e58 <tinyPotential_potential>
     e64:	70 93 59 3e 	sts	0x3E59, r23	; 0x803e59 <tinyPotential_potential+0x1>
     e68:	80 93 5a 3e 	sts	0x3E5A, r24	; 0x803e5a <tinyPotential_potential+0x2>
     e6c:	90 93 5b 3e 	sts	0x3E5B, r25	; 0x803e5b <tinyPotential_potential+0x3>
	
	// Update potential with values from spontaneous pulse.
	tinyPotential_potential = tinyPulse_update_potential(tinyPotential_potential);
     e70:	98 da       	rcall	.-2768   	; 0x3a2 <tinyPulse_update_potential>
     e72:	60 93 58 3e 	sts	0x3E58, r22	; 0x803e58 <tinyPotential_potential>
     e76:	70 93 59 3e 	sts	0x3E59, r23	; 0x803e59 <tinyPotential_potential+0x1>
     e7a:	80 93 5a 3e 	sts	0x3E5A, r24	; 0x803e5a <tinyPotential_potential+0x2>
     e7e:	90 93 5b 3e 	sts	0x3E5B, r25	; 0x803e5b <tinyPotential_potential+0x3>
	
	// Let the axon affect the potential
	// This is also where we decide whether or not the axon should fire
	tinyPotential_potential = tinyAxon_update_potential(tinyPotential_potential);
     e82:	dd dd       	rcall	.-1094   	; 0xa3e <tinyAxon_update_potential>
     e84:	ab 01       	movw	r20, r22
     e86:	bc 01       	movw	r22, r24
     e88:	40 93 58 3e 	sts	0x3E58, r20	; 0x803e58 <tinyPotential_potential>
     e8c:	50 93 59 3e 	sts	0x3E59, r21	; 0x803e59 <tinyPotential_potential+0x1>
     e90:	60 93 5a 3e 	sts	0x3E5A, r22	; 0x803e5a <tinyPotential_potential+0x2>
     e94:	70 93 5b 3e 	sts	0x3E5B, r23	; 0x803e5b <tinyPotential_potential+0x3>
	tinyDebugger_send_double("AxonP", tinyPotential_potential);
     e98:	82 e4       	ldi	r24, 0x42	; 66
     e9a:	96 e9       	ldi	r25, 0x96	; 150
     e9c:	79 da       	rcall	.-2830   	; 0x390 <tinyDebugger_send_double>

	//Update the led
	//potential_to_RGB_update_LEDs(tinyPotential_potential);
}
     e9e:	ff 90       	pop	r15
     ea0:	ef 90       	pop	r14
     ea2:	df 90       	pop	r13
     ea4:	cf 90       	pop	r12
     ea6:	08 95       	ret

00000ea8 <__subsf3>:
     ea8:	50 58       	subi	r21, 0x80	; 128

00000eaa <__addsf3>:
     eaa:	bb 27       	eor	r27, r27
     eac:	aa 27       	eor	r26, r26
     eae:	0e 94 6c 07 	call	0xed8	; 0xed8 <__addsf3x>
     eb2:	0c 94 5f 09 	jmp	0x12be	; 0x12be <__fp_round>
     eb6:	0e 94 51 09 	call	0x12a2	; 0x12a2 <__fp_pscA>
     eba:	38 f0       	brcs	.+14     	; 0xeca <__addsf3+0x20>
     ebc:	0e 94 58 09 	call	0x12b0	; 0x12b0 <__fp_pscB>
     ec0:	20 f0       	brcs	.+8      	; 0xeca <__addsf3+0x20>
     ec2:	39 f4       	brne	.+14     	; 0xed2 <__addsf3+0x28>
     ec4:	9f 3f       	cpi	r25, 0xFF	; 255
     ec6:	19 f4       	brne	.+6      	; 0xece <__addsf3+0x24>
     ec8:	26 f4       	brtc	.+8      	; 0xed2 <__addsf3+0x28>
     eca:	0c 94 27 09 	jmp	0x124e	; 0x124e <__fp_nan>
     ece:	0e f4       	brtc	.+2      	; 0xed2 <__addsf3+0x28>
     ed0:	e0 95       	com	r30
     ed2:	e7 fb       	bst	r30, 7
     ed4:	0c 94 21 09 	jmp	0x1242	; 0x1242 <__fp_inf>

00000ed8 <__addsf3x>:
     ed8:	e9 2f       	mov	r30, r25
     eda:	0e 94 70 09 	call	0x12e0	; 0x12e0 <__fp_split3>
     ede:	58 f3       	brcs	.-42     	; 0xeb6 <__addsf3+0xc>
     ee0:	ba 17       	cp	r27, r26
     ee2:	62 07       	cpc	r22, r18
     ee4:	73 07       	cpc	r23, r19
     ee6:	84 07       	cpc	r24, r20
     ee8:	95 07       	cpc	r25, r21
     eea:	20 f0       	brcs	.+8      	; 0xef4 <__addsf3x+0x1c>
     eec:	79 f4       	brne	.+30     	; 0xf0c <__addsf3x+0x34>
     eee:	a6 f5       	brtc	.+104    	; 0xf58 <__addsf3x+0x80>
     ef0:	0c 94 92 09 	jmp	0x1324	; 0x1324 <__fp_zero>
     ef4:	0e f4       	brtc	.+2      	; 0xef8 <__addsf3x+0x20>
     ef6:	e0 95       	com	r30
     ef8:	0b 2e       	mov	r0, r27
     efa:	ba 2f       	mov	r27, r26
     efc:	a0 2d       	mov	r26, r0
     efe:	0b 01       	movw	r0, r22
     f00:	b9 01       	movw	r22, r18
     f02:	90 01       	movw	r18, r0
     f04:	0c 01       	movw	r0, r24
     f06:	ca 01       	movw	r24, r20
     f08:	a0 01       	movw	r20, r0
     f0a:	11 24       	eor	r1, r1
     f0c:	ff 27       	eor	r31, r31
     f0e:	59 1b       	sub	r21, r25
     f10:	99 f0       	breq	.+38     	; 0xf38 <__addsf3x+0x60>
     f12:	59 3f       	cpi	r21, 0xF9	; 249
     f14:	50 f4       	brcc	.+20     	; 0xf2a <__addsf3x+0x52>
     f16:	50 3e       	cpi	r21, 0xE0	; 224
     f18:	68 f1       	brcs	.+90     	; 0xf74 <__addsf3x+0x9c>
     f1a:	1a 16       	cp	r1, r26
     f1c:	f0 40       	sbci	r31, 0x00	; 0
     f1e:	a2 2f       	mov	r26, r18
     f20:	23 2f       	mov	r18, r19
     f22:	34 2f       	mov	r19, r20
     f24:	44 27       	eor	r20, r20
     f26:	58 5f       	subi	r21, 0xF8	; 248
     f28:	f3 cf       	rjmp	.-26     	; 0xf10 <__addsf3x+0x38>
     f2a:	46 95       	lsr	r20
     f2c:	37 95       	ror	r19
     f2e:	27 95       	ror	r18
     f30:	a7 95       	ror	r26
     f32:	f0 40       	sbci	r31, 0x00	; 0
     f34:	53 95       	inc	r21
     f36:	c9 f7       	brne	.-14     	; 0xf2a <__addsf3x+0x52>
     f38:	7e f4       	brtc	.+30     	; 0xf58 <__addsf3x+0x80>
     f3a:	1f 16       	cp	r1, r31
     f3c:	ba 0b       	sbc	r27, r26
     f3e:	62 0b       	sbc	r22, r18
     f40:	73 0b       	sbc	r23, r19
     f42:	84 0b       	sbc	r24, r20
     f44:	ba f0       	brmi	.+46     	; 0xf74 <__addsf3x+0x9c>
     f46:	91 50       	subi	r25, 0x01	; 1
     f48:	a1 f0       	breq	.+40     	; 0xf72 <__addsf3x+0x9a>
     f4a:	ff 0f       	add	r31, r31
     f4c:	bb 1f       	adc	r27, r27
     f4e:	66 1f       	adc	r22, r22
     f50:	77 1f       	adc	r23, r23
     f52:	88 1f       	adc	r24, r24
     f54:	c2 f7       	brpl	.-16     	; 0xf46 <__addsf3x+0x6e>
     f56:	0e c0       	rjmp	.+28     	; 0xf74 <__addsf3x+0x9c>
     f58:	ba 0f       	add	r27, r26
     f5a:	62 1f       	adc	r22, r18
     f5c:	73 1f       	adc	r23, r19
     f5e:	84 1f       	adc	r24, r20
     f60:	48 f4       	brcc	.+18     	; 0xf74 <__addsf3x+0x9c>
     f62:	87 95       	ror	r24
     f64:	77 95       	ror	r23
     f66:	67 95       	ror	r22
     f68:	b7 95       	ror	r27
     f6a:	f7 95       	ror	r31
     f6c:	9e 3f       	cpi	r25, 0xFE	; 254
     f6e:	08 f0       	brcs	.+2      	; 0xf72 <__addsf3x+0x9a>
     f70:	b0 cf       	rjmp	.-160    	; 0xed2 <__addsf3+0x28>
     f72:	93 95       	inc	r25
     f74:	88 0f       	add	r24, r24
     f76:	08 f0       	brcs	.+2      	; 0xf7a <__addsf3x+0xa2>
     f78:	99 27       	eor	r25, r25
     f7a:	ee 0f       	add	r30, r30
     f7c:	97 95       	ror	r25
     f7e:	87 95       	ror	r24
     f80:	08 95       	ret

00000f82 <__cmpsf2>:
     f82:	0e 94 fd 08 	call	0x11fa	; 0x11fa <__fp_cmp>
     f86:	08 f4       	brcc	.+2      	; 0xf8a <__cmpsf2+0x8>
     f88:	81 e0       	ldi	r24, 0x01	; 1
     f8a:	08 95       	ret

00000f8c <__divsf3>:
     f8c:	0e 94 da 07 	call	0xfb4	; 0xfb4 <__divsf3x>
     f90:	0c 94 5f 09 	jmp	0x12be	; 0x12be <__fp_round>
     f94:	0e 94 58 09 	call	0x12b0	; 0x12b0 <__fp_pscB>
     f98:	58 f0       	brcs	.+22     	; 0xfb0 <__divsf3+0x24>
     f9a:	0e 94 51 09 	call	0x12a2	; 0x12a2 <__fp_pscA>
     f9e:	40 f0       	brcs	.+16     	; 0xfb0 <__divsf3+0x24>
     fa0:	29 f4       	brne	.+10     	; 0xfac <__divsf3+0x20>
     fa2:	5f 3f       	cpi	r21, 0xFF	; 255
     fa4:	29 f0       	breq	.+10     	; 0xfb0 <__divsf3+0x24>
     fa6:	0c 94 21 09 	jmp	0x1242	; 0x1242 <__fp_inf>
     faa:	51 11       	cpse	r21, r1
     fac:	0c 94 93 09 	jmp	0x1326	; 0x1326 <__fp_szero>
     fb0:	0c 94 27 09 	jmp	0x124e	; 0x124e <__fp_nan>

00000fb4 <__divsf3x>:
     fb4:	0e 94 70 09 	call	0x12e0	; 0x12e0 <__fp_split3>
     fb8:	68 f3       	brcs	.-38     	; 0xf94 <__divsf3+0x8>

00000fba <__divsf3_pse>:
     fba:	99 23       	and	r25, r25
     fbc:	b1 f3       	breq	.-20     	; 0xfaa <__divsf3+0x1e>
     fbe:	55 23       	and	r21, r21
     fc0:	91 f3       	breq	.-28     	; 0xfa6 <__divsf3+0x1a>
     fc2:	95 1b       	sub	r25, r21
     fc4:	55 0b       	sbc	r21, r21
     fc6:	bb 27       	eor	r27, r27
     fc8:	aa 27       	eor	r26, r26
     fca:	62 17       	cp	r22, r18
     fcc:	73 07       	cpc	r23, r19
     fce:	84 07       	cpc	r24, r20
     fd0:	38 f0       	brcs	.+14     	; 0xfe0 <__divsf3_pse+0x26>
     fd2:	9f 5f       	subi	r25, 0xFF	; 255
     fd4:	5f 4f       	sbci	r21, 0xFF	; 255
     fd6:	22 0f       	add	r18, r18
     fd8:	33 1f       	adc	r19, r19
     fda:	44 1f       	adc	r20, r20
     fdc:	aa 1f       	adc	r26, r26
     fde:	a9 f3       	breq	.-22     	; 0xfca <__divsf3_pse+0x10>
     fe0:	35 d0       	rcall	.+106    	; 0x104c <__divsf3_pse+0x92>
     fe2:	0e 2e       	mov	r0, r30
     fe4:	3a f0       	brmi	.+14     	; 0xff4 <__divsf3_pse+0x3a>
     fe6:	e0 e8       	ldi	r30, 0x80	; 128
     fe8:	32 d0       	rcall	.+100    	; 0x104e <__divsf3_pse+0x94>
     fea:	91 50       	subi	r25, 0x01	; 1
     fec:	50 40       	sbci	r21, 0x00	; 0
     fee:	e6 95       	lsr	r30
     ff0:	00 1c       	adc	r0, r0
     ff2:	ca f7       	brpl	.-14     	; 0xfe6 <__divsf3_pse+0x2c>
     ff4:	2b d0       	rcall	.+86     	; 0x104c <__divsf3_pse+0x92>
     ff6:	fe 2f       	mov	r31, r30
     ff8:	29 d0       	rcall	.+82     	; 0x104c <__divsf3_pse+0x92>
     ffa:	66 0f       	add	r22, r22
     ffc:	77 1f       	adc	r23, r23
     ffe:	88 1f       	adc	r24, r24
    1000:	bb 1f       	adc	r27, r27
    1002:	26 17       	cp	r18, r22
    1004:	37 07       	cpc	r19, r23
    1006:	48 07       	cpc	r20, r24
    1008:	ab 07       	cpc	r26, r27
    100a:	b0 e8       	ldi	r27, 0x80	; 128
    100c:	09 f0       	breq	.+2      	; 0x1010 <__divsf3_pse+0x56>
    100e:	bb 0b       	sbc	r27, r27
    1010:	80 2d       	mov	r24, r0
    1012:	bf 01       	movw	r22, r30
    1014:	ff 27       	eor	r31, r31
    1016:	93 58       	subi	r25, 0x83	; 131
    1018:	5f 4f       	sbci	r21, 0xFF	; 255
    101a:	3a f0       	brmi	.+14     	; 0x102a <__divsf3_pse+0x70>
    101c:	9e 3f       	cpi	r25, 0xFE	; 254
    101e:	51 05       	cpc	r21, r1
    1020:	78 f0       	brcs	.+30     	; 0x1040 <__divsf3_pse+0x86>
    1022:	0c 94 21 09 	jmp	0x1242	; 0x1242 <__fp_inf>
    1026:	0c 94 93 09 	jmp	0x1326	; 0x1326 <__fp_szero>
    102a:	5f 3f       	cpi	r21, 0xFF	; 255
    102c:	e4 f3       	brlt	.-8      	; 0x1026 <__divsf3_pse+0x6c>
    102e:	98 3e       	cpi	r25, 0xE8	; 232
    1030:	d4 f3       	brlt	.-12     	; 0x1026 <__divsf3_pse+0x6c>
    1032:	86 95       	lsr	r24
    1034:	77 95       	ror	r23
    1036:	67 95       	ror	r22
    1038:	b7 95       	ror	r27
    103a:	f7 95       	ror	r31
    103c:	9f 5f       	subi	r25, 0xFF	; 255
    103e:	c9 f7       	brne	.-14     	; 0x1032 <__divsf3_pse+0x78>
    1040:	88 0f       	add	r24, r24
    1042:	91 1d       	adc	r25, r1
    1044:	96 95       	lsr	r25
    1046:	87 95       	ror	r24
    1048:	97 f9       	bld	r25, 7
    104a:	08 95       	ret
    104c:	e1 e0       	ldi	r30, 0x01	; 1
    104e:	66 0f       	add	r22, r22
    1050:	77 1f       	adc	r23, r23
    1052:	88 1f       	adc	r24, r24
    1054:	bb 1f       	adc	r27, r27
    1056:	62 17       	cp	r22, r18
    1058:	73 07       	cpc	r23, r19
    105a:	84 07       	cpc	r24, r20
    105c:	ba 07       	cpc	r27, r26
    105e:	20 f0       	brcs	.+8      	; 0x1068 <__divsf3_pse+0xae>
    1060:	62 1b       	sub	r22, r18
    1062:	73 0b       	sbc	r23, r19
    1064:	84 0b       	sbc	r24, r20
    1066:	ba 0b       	sbc	r27, r26
    1068:	ee 1f       	adc	r30, r30
    106a:	88 f7       	brcc	.-30     	; 0x104e <__divsf3_pse+0x94>
    106c:	e0 95       	com	r30
    106e:	08 95       	ret
    1070:	29 f4       	brne	.+10     	; 0x107c <__divsf3_pse+0xc2>
    1072:	16 f0       	brts	.+4      	; 0x1078 <__divsf3_pse+0xbe>
    1074:	0c 94 21 09 	jmp	0x1242	; 0x1242 <__fp_inf>
    1078:	0c 94 92 09 	jmp	0x1324	; 0x1324 <__fp_zero>
    107c:	0c 94 27 09 	jmp	0x124e	; 0x124e <__fp_nan>

00001080 <exp>:
    1080:	0e 94 78 09 	call	0x12f0	; 0x12f0 <__fp_splitA>
    1084:	a8 f3       	brcs	.-22     	; 0x1070 <__divsf3_pse+0xb6>
    1086:	96 38       	cpi	r25, 0x86	; 134
    1088:	a0 f7       	brcc	.-24     	; 0x1072 <__divsf3_pse+0xb8>
    108a:	07 f8       	bld	r0, 7
    108c:	0f 92       	push	r0
    108e:	e8 94       	clt
    1090:	2b e3       	ldi	r18, 0x3B	; 59
    1092:	3a ea       	ldi	r19, 0xAA	; 170
    1094:	48 eb       	ldi	r20, 0xB8	; 184
    1096:	5f e7       	ldi	r21, 0x7F	; 127
    1098:	0e 94 2a 0a 	call	0x1454	; 0x1454 <__mulsf3_pse>
    109c:	0f 92       	push	r0
    109e:	0f 92       	push	r0
    10a0:	0f 92       	push	r0
    10a2:	4d b7       	in	r20, 0x3d	; 61
    10a4:	5e b7       	in	r21, 0x3e	; 62
    10a6:	0f 92       	push	r0
    10a8:	0e 94 e0 09 	call	0x13c0	; 0x13c0 <modf>
    10ac:	e4 e3       	ldi	r30, 0x34	; 52
    10ae:	f0 e0       	ldi	r31, 0x00	; 0
    10b0:	0e 94 2a 09 	call	0x1254	; 0x1254 <__fp_powser>
    10b4:	4f 91       	pop	r20
    10b6:	5f 91       	pop	r21
    10b8:	ef 91       	pop	r30
    10ba:	ff 91       	pop	r31
    10bc:	e5 95       	asr	r30
    10be:	ee 1f       	adc	r30, r30
    10c0:	ff 1f       	adc	r31, r31
    10c2:	49 f0       	breq	.+18     	; 0x10d6 <exp+0x56>
    10c4:	fe 57       	subi	r31, 0x7E	; 126
    10c6:	e0 68       	ori	r30, 0x80	; 128
    10c8:	44 27       	eor	r20, r20
    10ca:	ee 0f       	add	r30, r30
    10cc:	44 1f       	adc	r20, r20
    10ce:	fa 95       	dec	r31
    10d0:	e1 f7       	brne	.-8      	; 0x10ca <exp+0x4a>
    10d2:	41 95       	neg	r20
    10d4:	55 0b       	sbc	r21, r21
    10d6:	0e 94 aa 09 	call	0x1354	; 0x1354 <ldexp>
    10da:	0f 90       	pop	r0
    10dc:	07 fe       	sbrs	r0, 7
    10de:	0c 94 9e 09 	jmp	0x133c	; 0x133c <inverse>
    10e2:	08 95       	ret

000010e4 <__fixunssfsi>:
    10e4:	0e 94 78 09 	call	0x12f0	; 0x12f0 <__fp_splitA>
    10e8:	88 f0       	brcs	.+34     	; 0x110c <__fixunssfsi+0x28>
    10ea:	9f 57       	subi	r25, 0x7F	; 127
    10ec:	98 f0       	brcs	.+38     	; 0x1114 <__fixunssfsi+0x30>
    10ee:	b9 2f       	mov	r27, r25
    10f0:	99 27       	eor	r25, r25
    10f2:	b7 51       	subi	r27, 0x17	; 23
    10f4:	b0 f0       	brcs	.+44     	; 0x1122 <__fixunssfsi+0x3e>
    10f6:	e1 f0       	breq	.+56     	; 0x1130 <__fixunssfsi+0x4c>
    10f8:	66 0f       	add	r22, r22
    10fa:	77 1f       	adc	r23, r23
    10fc:	88 1f       	adc	r24, r24
    10fe:	99 1f       	adc	r25, r25
    1100:	1a f0       	brmi	.+6      	; 0x1108 <__fixunssfsi+0x24>
    1102:	ba 95       	dec	r27
    1104:	c9 f7       	brne	.-14     	; 0x10f8 <__fixunssfsi+0x14>
    1106:	14 c0       	rjmp	.+40     	; 0x1130 <__fixunssfsi+0x4c>
    1108:	b1 30       	cpi	r27, 0x01	; 1
    110a:	91 f0       	breq	.+36     	; 0x1130 <__fixunssfsi+0x4c>
    110c:	0e 94 92 09 	call	0x1324	; 0x1324 <__fp_zero>
    1110:	b1 e0       	ldi	r27, 0x01	; 1
    1112:	08 95       	ret
    1114:	0c 94 92 09 	jmp	0x1324	; 0x1324 <__fp_zero>
    1118:	67 2f       	mov	r22, r23
    111a:	78 2f       	mov	r23, r24
    111c:	88 27       	eor	r24, r24
    111e:	b8 5f       	subi	r27, 0xF8	; 248
    1120:	39 f0       	breq	.+14     	; 0x1130 <__fixunssfsi+0x4c>
    1122:	b9 3f       	cpi	r27, 0xF9	; 249
    1124:	cc f3       	brlt	.-14     	; 0x1118 <__fixunssfsi+0x34>
    1126:	86 95       	lsr	r24
    1128:	77 95       	ror	r23
    112a:	67 95       	ror	r22
    112c:	b3 95       	inc	r27
    112e:	d9 f7       	brne	.-10     	; 0x1126 <__fixunssfsi+0x42>
    1130:	3e f4       	brtc	.+14     	; 0x1140 <__fixunssfsi+0x5c>
    1132:	90 95       	com	r25
    1134:	80 95       	com	r24
    1136:	70 95       	com	r23
    1138:	61 95       	neg	r22
    113a:	7f 4f       	sbci	r23, 0xFF	; 255
    113c:	8f 4f       	sbci	r24, 0xFF	; 255
    113e:	9f 4f       	sbci	r25, 0xFF	; 255
    1140:	08 95       	ret

00001142 <__floatunsisf>:
    1142:	e8 94       	clt
    1144:	09 c0       	rjmp	.+18     	; 0x1158 <__floatsisf+0x12>

00001146 <__floatsisf>:
    1146:	97 fb       	bst	r25, 7
    1148:	3e f4       	brtc	.+14     	; 0x1158 <__floatsisf+0x12>
    114a:	90 95       	com	r25
    114c:	80 95       	com	r24
    114e:	70 95       	com	r23
    1150:	61 95       	neg	r22
    1152:	7f 4f       	sbci	r23, 0xFF	; 255
    1154:	8f 4f       	sbci	r24, 0xFF	; 255
    1156:	9f 4f       	sbci	r25, 0xFF	; 255
    1158:	99 23       	and	r25, r25
    115a:	a9 f0       	breq	.+42     	; 0x1186 <__floatsisf+0x40>
    115c:	f9 2f       	mov	r31, r25
    115e:	96 e9       	ldi	r25, 0x96	; 150
    1160:	bb 27       	eor	r27, r27
    1162:	93 95       	inc	r25
    1164:	f6 95       	lsr	r31
    1166:	87 95       	ror	r24
    1168:	77 95       	ror	r23
    116a:	67 95       	ror	r22
    116c:	b7 95       	ror	r27
    116e:	f1 11       	cpse	r31, r1
    1170:	f8 cf       	rjmp	.-16     	; 0x1162 <__floatsisf+0x1c>
    1172:	fa f4       	brpl	.+62     	; 0x11b2 <__floatsisf+0x6c>
    1174:	bb 0f       	add	r27, r27
    1176:	11 f4       	brne	.+4      	; 0x117c <__floatsisf+0x36>
    1178:	60 ff       	sbrs	r22, 0
    117a:	1b c0       	rjmp	.+54     	; 0x11b2 <__floatsisf+0x6c>
    117c:	6f 5f       	subi	r22, 0xFF	; 255
    117e:	7f 4f       	sbci	r23, 0xFF	; 255
    1180:	8f 4f       	sbci	r24, 0xFF	; 255
    1182:	9f 4f       	sbci	r25, 0xFF	; 255
    1184:	16 c0       	rjmp	.+44     	; 0x11b2 <__floatsisf+0x6c>
    1186:	88 23       	and	r24, r24
    1188:	11 f0       	breq	.+4      	; 0x118e <__floatsisf+0x48>
    118a:	96 e9       	ldi	r25, 0x96	; 150
    118c:	11 c0       	rjmp	.+34     	; 0x11b0 <__floatsisf+0x6a>
    118e:	77 23       	and	r23, r23
    1190:	21 f0       	breq	.+8      	; 0x119a <__floatsisf+0x54>
    1192:	9e e8       	ldi	r25, 0x8E	; 142
    1194:	87 2f       	mov	r24, r23
    1196:	76 2f       	mov	r23, r22
    1198:	05 c0       	rjmp	.+10     	; 0x11a4 <__floatsisf+0x5e>
    119a:	66 23       	and	r22, r22
    119c:	71 f0       	breq	.+28     	; 0x11ba <__floatsisf+0x74>
    119e:	96 e8       	ldi	r25, 0x86	; 134
    11a0:	86 2f       	mov	r24, r22
    11a2:	70 e0       	ldi	r23, 0x00	; 0
    11a4:	60 e0       	ldi	r22, 0x00	; 0
    11a6:	2a f0       	brmi	.+10     	; 0x11b2 <__floatsisf+0x6c>
    11a8:	9a 95       	dec	r25
    11aa:	66 0f       	add	r22, r22
    11ac:	77 1f       	adc	r23, r23
    11ae:	88 1f       	adc	r24, r24
    11b0:	da f7       	brpl	.-10     	; 0x11a8 <__floatsisf+0x62>
    11b2:	88 0f       	add	r24, r24
    11b4:	96 95       	lsr	r25
    11b6:	87 95       	ror	r24
    11b8:	97 f9       	bld	r25, 7
    11ba:	08 95       	ret

000011bc <fmin>:
    11bc:	99 0f       	add	r25, r25
    11be:	bb 0b       	sbc	r27, r27
    11c0:	55 0f       	add	r21, r21
    11c2:	aa 0b       	sbc	r26, r26
    11c4:	e0 e8       	ldi	r30, 0x80	; 128
    11c6:	fe ef       	ldi	r31, 0xFE	; 254
    11c8:	16 16       	cp	r1, r22
    11ca:	17 06       	cpc	r1, r23
    11cc:	e8 07       	cpc	r30, r24
    11ce:	f9 07       	cpc	r31, r25
    11d0:	70 f0       	brcs	.+28     	; 0x11ee <fmin+0x32>
    11d2:	12 16       	cp	r1, r18
    11d4:	13 06       	cpc	r1, r19
    11d6:	e4 07       	cpc	r30, r20
    11d8:	f5 07       	cpc	r31, r21
    11da:	60 f0       	brcs	.+24     	; 0x11f4 <fmin+0x38>
    11dc:	ba 17       	cp	r27, r26
    11de:	54 f0       	brlt	.+20     	; 0x11f4 <fmin+0x38>
    11e0:	31 f4       	brne	.+12     	; 0x11ee <fmin+0x32>
    11e2:	26 17       	cp	r18, r22
    11e4:	37 07       	cpc	r19, r23
    11e6:	48 07       	cpc	r20, r24
    11e8:	59 07       	cpc	r21, r25
    11ea:	a7 95       	ror	r26
    11ec:	1b f4       	brvc	.+6      	; 0x11f4 <fmin+0x38>
    11ee:	b9 01       	movw	r22, r18
    11f0:	ca 01       	movw	r24, r20
    11f2:	ba 2f       	mov	r27, r26
    11f4:	b6 95       	lsr	r27
    11f6:	97 95       	ror	r25
    11f8:	08 95       	ret

000011fa <__fp_cmp>:
    11fa:	99 0f       	add	r25, r25
    11fc:	00 08       	sbc	r0, r0
    11fe:	55 0f       	add	r21, r21
    1200:	aa 0b       	sbc	r26, r26
    1202:	e0 e8       	ldi	r30, 0x80	; 128
    1204:	fe ef       	ldi	r31, 0xFE	; 254
    1206:	16 16       	cp	r1, r22
    1208:	17 06       	cpc	r1, r23
    120a:	e8 07       	cpc	r30, r24
    120c:	f9 07       	cpc	r31, r25
    120e:	c0 f0       	brcs	.+48     	; 0x1240 <__fp_cmp+0x46>
    1210:	12 16       	cp	r1, r18
    1212:	13 06       	cpc	r1, r19
    1214:	e4 07       	cpc	r30, r20
    1216:	f5 07       	cpc	r31, r21
    1218:	98 f0       	brcs	.+38     	; 0x1240 <__fp_cmp+0x46>
    121a:	62 1b       	sub	r22, r18
    121c:	73 0b       	sbc	r23, r19
    121e:	84 0b       	sbc	r24, r20
    1220:	95 0b       	sbc	r25, r21
    1222:	39 f4       	brne	.+14     	; 0x1232 <__fp_cmp+0x38>
    1224:	0a 26       	eor	r0, r26
    1226:	61 f0       	breq	.+24     	; 0x1240 <__fp_cmp+0x46>
    1228:	23 2b       	or	r18, r19
    122a:	24 2b       	or	r18, r20
    122c:	25 2b       	or	r18, r21
    122e:	21 f4       	brne	.+8      	; 0x1238 <__fp_cmp+0x3e>
    1230:	08 95       	ret
    1232:	0a 26       	eor	r0, r26
    1234:	09 f4       	brne	.+2      	; 0x1238 <__fp_cmp+0x3e>
    1236:	a1 40       	sbci	r26, 0x01	; 1
    1238:	a6 95       	lsr	r26
    123a:	8f ef       	ldi	r24, 0xFF	; 255
    123c:	81 1d       	adc	r24, r1
    123e:	81 1d       	adc	r24, r1
    1240:	08 95       	ret

00001242 <__fp_inf>:
    1242:	97 f9       	bld	r25, 7
    1244:	9f 67       	ori	r25, 0x7F	; 127
    1246:	80 e8       	ldi	r24, 0x80	; 128
    1248:	70 e0       	ldi	r23, 0x00	; 0
    124a:	60 e0       	ldi	r22, 0x00	; 0
    124c:	08 95       	ret

0000124e <__fp_nan>:
    124e:	9f ef       	ldi	r25, 0xFF	; 255
    1250:	80 ec       	ldi	r24, 0xC0	; 192
    1252:	08 95       	ret

00001254 <__fp_powser>:
    1254:	df 93       	push	r29
    1256:	cf 93       	push	r28
    1258:	1f 93       	push	r17
    125a:	0f 93       	push	r16
    125c:	ff 92       	push	r15
    125e:	ef 92       	push	r14
    1260:	df 92       	push	r13
    1262:	7b 01       	movw	r14, r22
    1264:	8c 01       	movw	r16, r24
    1266:	68 94       	set
    1268:	06 c0       	rjmp	.+12     	; 0x1276 <__fp_powser+0x22>
    126a:	da 2e       	mov	r13, r26
    126c:	ef 01       	movw	r28, r30
    126e:	0e 94 27 0a 	call	0x144e	; 0x144e <__mulsf3x>
    1272:	fe 01       	movw	r30, r28
    1274:	e8 94       	clt
    1276:	a5 91       	lpm	r26, Z+
    1278:	25 91       	lpm	r18, Z+
    127a:	35 91       	lpm	r19, Z+
    127c:	45 91       	lpm	r20, Z+
    127e:	55 91       	lpm	r21, Z+
    1280:	a6 f3       	brts	.-24     	; 0x126a <__fp_powser+0x16>
    1282:	ef 01       	movw	r28, r30
    1284:	0e 94 6c 07 	call	0xed8	; 0xed8 <__addsf3x>
    1288:	fe 01       	movw	r30, r28
    128a:	97 01       	movw	r18, r14
    128c:	a8 01       	movw	r20, r16
    128e:	da 94       	dec	r13
    1290:	69 f7       	brne	.-38     	; 0x126c <__fp_powser+0x18>
    1292:	df 90       	pop	r13
    1294:	ef 90       	pop	r14
    1296:	ff 90       	pop	r15
    1298:	0f 91       	pop	r16
    129a:	1f 91       	pop	r17
    129c:	cf 91       	pop	r28
    129e:	df 91       	pop	r29
    12a0:	08 95       	ret

000012a2 <__fp_pscA>:
    12a2:	00 24       	eor	r0, r0
    12a4:	0a 94       	dec	r0
    12a6:	16 16       	cp	r1, r22
    12a8:	17 06       	cpc	r1, r23
    12aa:	18 06       	cpc	r1, r24
    12ac:	09 06       	cpc	r0, r25
    12ae:	08 95       	ret

000012b0 <__fp_pscB>:
    12b0:	00 24       	eor	r0, r0
    12b2:	0a 94       	dec	r0
    12b4:	12 16       	cp	r1, r18
    12b6:	13 06       	cpc	r1, r19
    12b8:	14 06       	cpc	r1, r20
    12ba:	05 06       	cpc	r0, r21
    12bc:	08 95       	ret

000012be <__fp_round>:
    12be:	09 2e       	mov	r0, r25
    12c0:	03 94       	inc	r0
    12c2:	00 0c       	add	r0, r0
    12c4:	11 f4       	brne	.+4      	; 0x12ca <__fp_round+0xc>
    12c6:	88 23       	and	r24, r24
    12c8:	52 f0       	brmi	.+20     	; 0x12de <__fp_round+0x20>
    12ca:	bb 0f       	add	r27, r27
    12cc:	40 f4       	brcc	.+16     	; 0x12de <__fp_round+0x20>
    12ce:	bf 2b       	or	r27, r31
    12d0:	11 f4       	brne	.+4      	; 0x12d6 <__fp_round+0x18>
    12d2:	60 ff       	sbrs	r22, 0
    12d4:	04 c0       	rjmp	.+8      	; 0x12de <__fp_round+0x20>
    12d6:	6f 5f       	subi	r22, 0xFF	; 255
    12d8:	7f 4f       	sbci	r23, 0xFF	; 255
    12da:	8f 4f       	sbci	r24, 0xFF	; 255
    12dc:	9f 4f       	sbci	r25, 0xFF	; 255
    12de:	08 95       	ret

000012e0 <__fp_split3>:
    12e0:	57 fd       	sbrc	r21, 7
    12e2:	90 58       	subi	r25, 0x80	; 128
    12e4:	44 0f       	add	r20, r20
    12e6:	55 1f       	adc	r21, r21
    12e8:	59 f0       	breq	.+22     	; 0x1300 <__fp_splitA+0x10>
    12ea:	5f 3f       	cpi	r21, 0xFF	; 255
    12ec:	71 f0       	breq	.+28     	; 0x130a <__fp_splitA+0x1a>
    12ee:	47 95       	ror	r20

000012f0 <__fp_splitA>:
    12f0:	88 0f       	add	r24, r24
    12f2:	97 fb       	bst	r25, 7
    12f4:	99 1f       	adc	r25, r25
    12f6:	61 f0       	breq	.+24     	; 0x1310 <__fp_splitA+0x20>
    12f8:	9f 3f       	cpi	r25, 0xFF	; 255
    12fa:	79 f0       	breq	.+30     	; 0x131a <__fp_splitA+0x2a>
    12fc:	87 95       	ror	r24
    12fe:	08 95       	ret
    1300:	12 16       	cp	r1, r18
    1302:	13 06       	cpc	r1, r19
    1304:	14 06       	cpc	r1, r20
    1306:	55 1f       	adc	r21, r21
    1308:	f2 cf       	rjmp	.-28     	; 0x12ee <__fp_split3+0xe>
    130a:	46 95       	lsr	r20
    130c:	f1 df       	rcall	.-30     	; 0x12f0 <__fp_splitA>
    130e:	08 c0       	rjmp	.+16     	; 0x1320 <__fp_splitA+0x30>
    1310:	16 16       	cp	r1, r22
    1312:	17 06       	cpc	r1, r23
    1314:	18 06       	cpc	r1, r24
    1316:	99 1f       	adc	r25, r25
    1318:	f1 cf       	rjmp	.-30     	; 0x12fc <__fp_splitA+0xc>
    131a:	86 95       	lsr	r24
    131c:	71 05       	cpc	r23, r1
    131e:	61 05       	cpc	r22, r1
    1320:	08 94       	sec
    1322:	08 95       	ret

00001324 <__fp_zero>:
    1324:	e8 94       	clt

00001326 <__fp_szero>:
    1326:	bb 27       	eor	r27, r27
    1328:	66 27       	eor	r22, r22
    132a:	77 27       	eor	r23, r23
    132c:	cb 01       	movw	r24, r22
    132e:	97 f9       	bld	r25, 7
    1330:	08 95       	ret

00001332 <__gesf2>:
    1332:	0e 94 fd 08 	call	0x11fa	; 0x11fa <__fp_cmp>
    1336:	08 f4       	brcc	.+2      	; 0x133a <__gesf2+0x8>
    1338:	8f ef       	ldi	r24, 0xFF	; 255
    133a:	08 95       	ret

0000133c <inverse>:
    133c:	9b 01       	movw	r18, r22
    133e:	ac 01       	movw	r20, r24
    1340:	60 e0       	ldi	r22, 0x00	; 0
    1342:	70 e0       	ldi	r23, 0x00	; 0
    1344:	80 e8       	ldi	r24, 0x80	; 128
    1346:	9f e3       	ldi	r25, 0x3F	; 63
    1348:	0c 94 c6 07 	jmp	0xf8c	; 0xf8c <__divsf3>
    134c:	0c 94 21 09 	jmp	0x1242	; 0x1242 <__fp_inf>
    1350:	0c 94 89 0a 	jmp	0x1512	; 0x1512 <__fp_mpack>

00001354 <ldexp>:
    1354:	0e 94 78 09 	call	0x12f0	; 0x12f0 <__fp_splitA>
    1358:	d8 f3       	brcs	.-10     	; 0x1350 <inverse+0x14>
    135a:	99 23       	and	r25, r25
    135c:	c9 f3       	breq	.-14     	; 0x1350 <inverse+0x14>
    135e:	94 0f       	add	r25, r20
    1360:	51 1d       	adc	r21, r1
    1362:	a3 f3       	brvs	.-24     	; 0x134c <inverse+0x10>
    1364:	91 50       	subi	r25, 0x01	; 1
    1366:	50 40       	sbci	r21, 0x00	; 0
    1368:	94 f0       	brlt	.+36     	; 0x138e <ldexp+0x3a>
    136a:	59 f0       	breq	.+22     	; 0x1382 <ldexp+0x2e>
    136c:	88 23       	and	r24, r24
    136e:	32 f0       	brmi	.+12     	; 0x137c <ldexp+0x28>
    1370:	66 0f       	add	r22, r22
    1372:	77 1f       	adc	r23, r23
    1374:	88 1f       	adc	r24, r24
    1376:	91 50       	subi	r25, 0x01	; 1
    1378:	50 40       	sbci	r21, 0x00	; 0
    137a:	c1 f7       	brne	.-16     	; 0x136c <ldexp+0x18>
    137c:	9e 3f       	cpi	r25, 0xFE	; 254
    137e:	51 05       	cpc	r21, r1
    1380:	2c f7       	brge	.-54     	; 0x134c <inverse+0x10>
    1382:	88 0f       	add	r24, r24
    1384:	91 1d       	adc	r25, r1
    1386:	96 95       	lsr	r25
    1388:	87 95       	ror	r24
    138a:	97 f9       	bld	r25, 7
    138c:	08 95       	ret
    138e:	5f 3f       	cpi	r21, 0xFF	; 255
    1390:	ac f0       	brlt	.+42     	; 0x13bc <ldexp+0x68>
    1392:	98 3e       	cpi	r25, 0xE8	; 232
    1394:	9c f0       	brlt	.+38     	; 0x13bc <ldexp+0x68>
    1396:	bb 27       	eor	r27, r27
    1398:	86 95       	lsr	r24
    139a:	77 95       	ror	r23
    139c:	67 95       	ror	r22
    139e:	b7 95       	ror	r27
    13a0:	08 f4       	brcc	.+2      	; 0x13a4 <ldexp+0x50>
    13a2:	b1 60       	ori	r27, 0x01	; 1
    13a4:	93 95       	inc	r25
    13a6:	c1 f7       	brne	.-16     	; 0x1398 <ldexp+0x44>
    13a8:	bb 0f       	add	r27, r27
    13aa:	58 f7       	brcc	.-42     	; 0x1382 <ldexp+0x2e>
    13ac:	11 f4       	brne	.+4      	; 0x13b2 <ldexp+0x5e>
    13ae:	60 ff       	sbrs	r22, 0
    13b0:	e8 cf       	rjmp	.-48     	; 0x1382 <ldexp+0x2e>
    13b2:	6f 5f       	subi	r22, 0xFF	; 255
    13b4:	7f 4f       	sbci	r23, 0xFF	; 255
    13b6:	8f 4f       	sbci	r24, 0xFF	; 255
    13b8:	9f 4f       	sbci	r25, 0xFF	; 255
    13ba:	e3 cf       	rjmp	.-58     	; 0x1382 <ldexp+0x2e>
    13bc:	0c 94 93 09 	jmp	0x1326	; 0x1326 <__fp_szero>

000013c0 <modf>:
    13c0:	fa 01       	movw	r30, r20
    13c2:	dc 01       	movw	r26, r24
    13c4:	aa 0f       	add	r26, r26
    13c6:	bb 1f       	adc	r27, r27
    13c8:	9b 01       	movw	r18, r22
    13ca:	ac 01       	movw	r20, r24
    13cc:	bf 57       	subi	r27, 0x7F	; 127
    13ce:	28 f4       	brcc	.+10     	; 0x13da <modf+0x1a>
    13d0:	22 27       	eor	r18, r18
    13d2:	33 27       	eor	r19, r19
    13d4:	44 27       	eor	r20, r20
    13d6:	50 78       	andi	r21, 0x80	; 128
    13d8:	20 c0       	rjmp	.+64     	; 0x141a <modf+0x5a>
    13da:	b7 51       	subi	r27, 0x17	; 23
    13dc:	90 f4       	brcc	.+36     	; 0x1402 <modf+0x42>
    13de:	ab 2f       	mov	r26, r27
    13e0:	00 24       	eor	r0, r0
    13e2:	46 95       	lsr	r20
    13e4:	37 95       	ror	r19
    13e6:	27 95       	ror	r18
    13e8:	01 1c       	adc	r0, r1
    13ea:	a3 95       	inc	r26
    13ec:	d2 f3       	brmi	.-12     	; 0x13e2 <modf+0x22>
    13ee:	00 20       	and	r0, r0
    13f0:	71 f0       	breq	.+28     	; 0x140e <modf+0x4e>
    13f2:	22 0f       	add	r18, r18
    13f4:	33 1f       	adc	r19, r19
    13f6:	44 1f       	adc	r20, r20
    13f8:	b3 95       	inc	r27
    13fa:	da f3       	brmi	.-10     	; 0x13f2 <modf+0x32>
    13fc:	0e d0       	rcall	.+28     	; 0x141a <modf+0x5a>
    13fe:	0c 94 54 07 	jmp	0xea8	; 0xea8 <__subsf3>
    1402:	61 30       	cpi	r22, 0x01	; 1
    1404:	71 05       	cpc	r23, r1
    1406:	a0 e8       	ldi	r26, 0x80	; 128
    1408:	8a 07       	cpc	r24, r26
    140a:	b9 46       	sbci	r27, 0x69	; 105
    140c:	30 f4       	brcc	.+12     	; 0x141a <modf+0x5a>
    140e:	9b 01       	movw	r18, r22
    1410:	ac 01       	movw	r20, r24
    1412:	66 27       	eor	r22, r22
    1414:	77 27       	eor	r23, r23
    1416:	88 27       	eor	r24, r24
    1418:	90 78       	andi	r25, 0x80	; 128
    141a:	30 96       	adiw	r30, 0x00	; 0
    141c:	21 f0       	breq	.+8      	; 0x1426 <modf+0x66>
    141e:	20 83       	st	Z, r18
    1420:	31 83       	std	Z+1, r19	; 0x01
    1422:	42 83       	std	Z+2, r20	; 0x02
    1424:	53 83       	std	Z+3, r21	; 0x03
    1426:	08 95       	ret

00001428 <__mulsf3>:
    1428:	0e 94 27 0a 	call	0x144e	; 0x144e <__mulsf3x>
    142c:	0c 94 5f 09 	jmp	0x12be	; 0x12be <__fp_round>
    1430:	0e 94 51 09 	call	0x12a2	; 0x12a2 <__fp_pscA>
    1434:	38 f0       	brcs	.+14     	; 0x1444 <__mulsf3+0x1c>
    1436:	0e 94 58 09 	call	0x12b0	; 0x12b0 <__fp_pscB>
    143a:	20 f0       	brcs	.+8      	; 0x1444 <__mulsf3+0x1c>
    143c:	95 23       	and	r25, r21
    143e:	11 f0       	breq	.+4      	; 0x1444 <__mulsf3+0x1c>
    1440:	0c 94 21 09 	jmp	0x1242	; 0x1242 <__fp_inf>
    1444:	0c 94 27 09 	jmp	0x124e	; 0x124e <__fp_nan>
    1448:	11 24       	eor	r1, r1
    144a:	0c 94 93 09 	jmp	0x1326	; 0x1326 <__fp_szero>

0000144e <__mulsf3x>:
    144e:	0e 94 70 09 	call	0x12e0	; 0x12e0 <__fp_split3>
    1452:	70 f3       	brcs	.-36     	; 0x1430 <__mulsf3+0x8>

00001454 <__mulsf3_pse>:
    1454:	95 9f       	mul	r25, r21
    1456:	c1 f3       	breq	.-16     	; 0x1448 <__mulsf3+0x20>
    1458:	95 0f       	add	r25, r21
    145a:	50 e0       	ldi	r21, 0x00	; 0
    145c:	55 1f       	adc	r21, r21
    145e:	62 9f       	mul	r22, r18
    1460:	f0 01       	movw	r30, r0
    1462:	72 9f       	mul	r23, r18
    1464:	bb 27       	eor	r27, r27
    1466:	f0 0d       	add	r31, r0
    1468:	b1 1d       	adc	r27, r1
    146a:	63 9f       	mul	r22, r19
    146c:	aa 27       	eor	r26, r26
    146e:	f0 0d       	add	r31, r0
    1470:	b1 1d       	adc	r27, r1
    1472:	aa 1f       	adc	r26, r26
    1474:	64 9f       	mul	r22, r20
    1476:	66 27       	eor	r22, r22
    1478:	b0 0d       	add	r27, r0
    147a:	a1 1d       	adc	r26, r1
    147c:	66 1f       	adc	r22, r22
    147e:	82 9f       	mul	r24, r18
    1480:	22 27       	eor	r18, r18
    1482:	b0 0d       	add	r27, r0
    1484:	a1 1d       	adc	r26, r1
    1486:	62 1f       	adc	r22, r18
    1488:	73 9f       	mul	r23, r19
    148a:	b0 0d       	add	r27, r0
    148c:	a1 1d       	adc	r26, r1
    148e:	62 1f       	adc	r22, r18
    1490:	83 9f       	mul	r24, r19
    1492:	a0 0d       	add	r26, r0
    1494:	61 1d       	adc	r22, r1
    1496:	22 1f       	adc	r18, r18
    1498:	74 9f       	mul	r23, r20
    149a:	33 27       	eor	r19, r19
    149c:	a0 0d       	add	r26, r0
    149e:	61 1d       	adc	r22, r1
    14a0:	23 1f       	adc	r18, r19
    14a2:	84 9f       	mul	r24, r20
    14a4:	60 0d       	add	r22, r0
    14a6:	21 1d       	adc	r18, r1
    14a8:	82 2f       	mov	r24, r18
    14aa:	76 2f       	mov	r23, r22
    14ac:	6a 2f       	mov	r22, r26
    14ae:	11 24       	eor	r1, r1
    14b0:	9f 57       	subi	r25, 0x7F	; 127
    14b2:	50 40       	sbci	r21, 0x00	; 0
    14b4:	9a f0       	brmi	.+38     	; 0x14dc <__mulsf3_pse+0x88>
    14b6:	f1 f0       	breq	.+60     	; 0x14f4 <__mulsf3_pse+0xa0>
    14b8:	88 23       	and	r24, r24
    14ba:	4a f0       	brmi	.+18     	; 0x14ce <__mulsf3_pse+0x7a>
    14bc:	ee 0f       	add	r30, r30
    14be:	ff 1f       	adc	r31, r31
    14c0:	bb 1f       	adc	r27, r27
    14c2:	66 1f       	adc	r22, r22
    14c4:	77 1f       	adc	r23, r23
    14c6:	88 1f       	adc	r24, r24
    14c8:	91 50       	subi	r25, 0x01	; 1
    14ca:	50 40       	sbci	r21, 0x00	; 0
    14cc:	a9 f7       	brne	.-22     	; 0x14b8 <__mulsf3_pse+0x64>
    14ce:	9e 3f       	cpi	r25, 0xFE	; 254
    14d0:	51 05       	cpc	r21, r1
    14d2:	80 f0       	brcs	.+32     	; 0x14f4 <__mulsf3_pse+0xa0>
    14d4:	0c 94 21 09 	jmp	0x1242	; 0x1242 <__fp_inf>
    14d8:	0c 94 93 09 	jmp	0x1326	; 0x1326 <__fp_szero>
    14dc:	5f 3f       	cpi	r21, 0xFF	; 255
    14de:	e4 f3       	brlt	.-8      	; 0x14d8 <__mulsf3_pse+0x84>
    14e0:	98 3e       	cpi	r25, 0xE8	; 232
    14e2:	d4 f3       	brlt	.-12     	; 0x14d8 <__mulsf3_pse+0x84>
    14e4:	86 95       	lsr	r24
    14e6:	77 95       	ror	r23
    14e8:	67 95       	ror	r22
    14ea:	b7 95       	ror	r27
    14ec:	f7 95       	ror	r31
    14ee:	e7 95       	ror	r30
    14f0:	9f 5f       	subi	r25, 0xFF	; 255
    14f2:	c1 f7       	brne	.-16     	; 0x14e4 <__mulsf3_pse+0x90>
    14f4:	fe 2b       	or	r31, r30
    14f6:	88 0f       	add	r24, r24
    14f8:	91 1d       	adc	r25, r1
    14fa:	96 95       	lsr	r25
    14fc:	87 95       	ror	r24
    14fe:	97 f9       	bld	r25, 7
    1500:	08 95       	ret

00001502 <sin>:
    1502:	9f 93       	push	r25
    1504:	0e 94 99 0a 	call	0x1532	; 0x1532 <__fp_rempio2>
    1508:	0f 90       	pop	r0
    150a:	07 fc       	sbrc	r0, 7
    150c:	ee 5f       	subi	r30, 0xFE	; 254
    150e:	0c 94 c2 0a 	jmp	0x1584	; 0x1584 <__fp_sinus>

00001512 <__fp_mpack>:
    1512:	9f 3f       	cpi	r25, 0xFF	; 255
    1514:	31 f0       	breq	.+12     	; 0x1522 <__fp_mpack_finite+0xc>

00001516 <__fp_mpack_finite>:
    1516:	91 50       	subi	r25, 0x01	; 1
    1518:	20 f4       	brcc	.+8      	; 0x1522 <__fp_mpack_finite+0xc>
    151a:	87 95       	ror	r24
    151c:	77 95       	ror	r23
    151e:	67 95       	ror	r22
    1520:	b7 95       	ror	r27
    1522:	88 0f       	add	r24, r24
    1524:	91 1d       	adc	r25, r1
    1526:	96 95       	lsr	r25
    1528:	87 95       	ror	r24
    152a:	97 f9       	bld	r25, 7
    152c:	08 95       	ret
    152e:	0c 94 27 09 	jmp	0x124e	; 0x124e <__fp_nan>

00001532 <__fp_rempio2>:
    1532:	0e 94 78 09 	call	0x12f0	; 0x12f0 <__fp_splitA>
    1536:	d8 f3       	brcs	.-10     	; 0x152e <__fp_mpack_finite+0x18>
    1538:	e8 94       	clt
    153a:	e0 e0       	ldi	r30, 0x00	; 0
    153c:	bb 27       	eor	r27, r27
    153e:	9f 57       	subi	r25, 0x7F	; 127
    1540:	f0 f0       	brcs	.+60     	; 0x157e <__fp_rempio2+0x4c>
    1542:	2a ed       	ldi	r18, 0xDA	; 218
    1544:	3f e0       	ldi	r19, 0x0F	; 15
    1546:	49 ec       	ldi	r20, 0xC9	; 201
    1548:	06 c0       	rjmp	.+12     	; 0x1556 <__fp_rempio2+0x24>
    154a:	ee 0f       	add	r30, r30
    154c:	bb 0f       	add	r27, r27
    154e:	66 1f       	adc	r22, r22
    1550:	77 1f       	adc	r23, r23
    1552:	88 1f       	adc	r24, r24
    1554:	28 f0       	brcs	.+10     	; 0x1560 <__fp_rempio2+0x2e>
    1556:	b2 3a       	cpi	r27, 0xA2	; 162
    1558:	62 07       	cpc	r22, r18
    155a:	73 07       	cpc	r23, r19
    155c:	84 07       	cpc	r24, r20
    155e:	28 f0       	brcs	.+10     	; 0x156a <__fp_rempio2+0x38>
    1560:	b2 5a       	subi	r27, 0xA2	; 162
    1562:	62 0b       	sbc	r22, r18
    1564:	73 0b       	sbc	r23, r19
    1566:	84 0b       	sbc	r24, r20
    1568:	e3 95       	inc	r30
    156a:	9a 95       	dec	r25
    156c:	72 f7       	brpl	.-36     	; 0x154a <__fp_rempio2+0x18>
    156e:	80 38       	cpi	r24, 0x80	; 128
    1570:	30 f4       	brcc	.+12     	; 0x157e <__fp_rempio2+0x4c>
    1572:	9a 95       	dec	r25
    1574:	bb 0f       	add	r27, r27
    1576:	66 1f       	adc	r22, r22
    1578:	77 1f       	adc	r23, r23
    157a:	88 1f       	adc	r24, r24
    157c:	d2 f7       	brpl	.-12     	; 0x1572 <__fp_rempio2+0x40>
    157e:	90 48       	sbci	r25, 0x80	; 128
    1580:	0c 94 8b 0a 	jmp	0x1516	; 0x1516 <__fp_mpack_finite>

00001584 <__fp_sinus>:
    1584:	ef 93       	push	r30
    1586:	e0 ff       	sbrs	r30, 0
    1588:	07 c0       	rjmp	.+14     	; 0x1598 <__fp_sinus+0x14>
    158a:	a2 ea       	ldi	r26, 0xA2	; 162
    158c:	2a ed       	ldi	r18, 0xDA	; 218
    158e:	3f e0       	ldi	r19, 0x0F	; 15
    1590:	49 ec       	ldi	r20, 0xC9	; 201
    1592:	5f eb       	ldi	r21, 0xBF	; 191
    1594:	0e 94 6c 07 	call	0xed8	; 0xed8 <__addsf3x>
    1598:	0e 94 5f 09 	call	0x12be	; 0x12be <__fp_round>
    159c:	0f 90       	pop	r0
    159e:	03 94       	inc	r0
    15a0:	01 fc       	sbrc	r0, 1
    15a2:	90 58       	subi	r25, 0x80	; 128
    15a4:	ec e5       	ldi	r30, 0x5C	; 92
    15a6:	f0 e0       	ldi	r31, 0x00	; 0
    15a8:	0c 94 d6 0a 	jmp	0x15ac	; 0x15ac <__fp_powsodd>

000015ac <__fp_powsodd>:
    15ac:	9f 93       	push	r25
    15ae:	8f 93       	push	r24
    15b0:	7f 93       	push	r23
    15b2:	6f 93       	push	r22
    15b4:	ff 93       	push	r31
    15b6:	ef 93       	push	r30
    15b8:	9b 01       	movw	r18, r22
    15ba:	ac 01       	movw	r20, r24
    15bc:	0e 94 14 0a 	call	0x1428	; 0x1428 <__mulsf3>
    15c0:	ef 91       	pop	r30
    15c2:	ff 91       	pop	r31
    15c4:	0e 94 2a 09 	call	0x1254	; 0x1254 <__fp_powser>
    15c8:	2f 91       	pop	r18
    15ca:	3f 91       	pop	r19
    15cc:	4f 91       	pop	r20
    15ce:	5f 91       	pop	r21
    15d0:	0c 94 14 0a 	jmp	0x1428	; 0x1428 <__mulsf3>

000015d4 <__udivmodsi4>:
    15d4:	a1 e2       	ldi	r26, 0x21	; 33
    15d6:	1a 2e       	mov	r1, r26
    15d8:	aa 1b       	sub	r26, r26
    15da:	bb 1b       	sub	r27, r27
    15dc:	fd 01       	movw	r30, r26
    15de:	0d c0       	rjmp	.+26     	; 0x15fa <__udivmodsi4_ep>

000015e0 <__udivmodsi4_loop>:
    15e0:	aa 1f       	adc	r26, r26
    15e2:	bb 1f       	adc	r27, r27
    15e4:	ee 1f       	adc	r30, r30
    15e6:	ff 1f       	adc	r31, r31
    15e8:	a2 17       	cp	r26, r18
    15ea:	b3 07       	cpc	r27, r19
    15ec:	e4 07       	cpc	r30, r20
    15ee:	f5 07       	cpc	r31, r21
    15f0:	20 f0       	brcs	.+8      	; 0x15fa <__udivmodsi4_ep>
    15f2:	a2 1b       	sub	r26, r18
    15f4:	b3 0b       	sbc	r27, r19
    15f6:	e4 0b       	sbc	r30, r20
    15f8:	f5 0b       	sbc	r31, r21

000015fa <__udivmodsi4_ep>:
    15fa:	66 1f       	adc	r22, r22
    15fc:	77 1f       	adc	r23, r23
    15fe:	88 1f       	adc	r24, r24
    1600:	99 1f       	adc	r25, r25
    1602:	1a 94       	dec	r1
    1604:	69 f7       	brne	.-38     	; 0x15e0 <__udivmodsi4_loop>
    1606:	60 95       	com	r22
    1608:	70 95       	com	r23
    160a:	80 95       	com	r24
    160c:	90 95       	com	r25
    160e:	9b 01       	movw	r18, r22
    1610:	ac 01       	movw	r20, r24
    1612:	bd 01       	movw	r22, r26
    1614:	cf 01       	movw	r24, r30
    1616:	08 95       	ret

00001618 <_exit>:
    1618:	f8 94       	cli

0000161a <__stop_program>:
    161a:	ff cf       	rjmp	.-2      	; 0x161a <__stop_program>
