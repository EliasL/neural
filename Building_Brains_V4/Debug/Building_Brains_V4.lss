
Building_Brains_V4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000000e  00803e00  00001438  000014cc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001438  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000004f  00803e0e  00803e0e  000014da  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000014da  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  0000150c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000003f0  00000000  00000000  00001548  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00006c6c  00000000  00000000  00001938  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002ca2  00000000  00000000  000085a4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000021b5  00000000  00000000  0000b246  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000718  00000000  00000000  0000d3fc  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002c05  00000000  00000000  0000db14  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001366  00000000  00000000  00010719  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000260  00000000  00000000  00011a7f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	2d c0       	rjmp	.+90     	; 0x5c <__ctors_end>
       2:	47 c0       	rjmp	.+142    	; 0x92 <__bad_interrupt>
       4:	46 c0       	rjmp	.+140    	; 0x92 <__bad_interrupt>
       6:	45 c0       	rjmp	.+138    	; 0x92 <__bad_interrupt>
       8:	44 c0       	rjmp	.+136    	; 0x92 <__bad_interrupt>
       a:	43 c0       	rjmp	.+134    	; 0x92 <__bad_interrupt>
       c:	22 c5       	rjmp	.+2628   	; 0xa52 <__vector_6>
       e:	41 c0       	rjmp	.+130    	; 0x92 <__bad_interrupt>
      10:	40 c0       	rjmp	.+128    	; 0x92 <__bad_interrupt>
      12:	3f c0       	rjmp	.+126    	; 0x92 <__bad_interrupt>
      14:	3e c0       	rjmp	.+124    	; 0x92 <__bad_interrupt>
      16:	3d c0       	rjmp	.+122    	; 0x92 <__bad_interrupt>
      18:	3c c0       	rjmp	.+120    	; 0x92 <__bad_interrupt>
      1a:	3b c0       	rjmp	.+118    	; 0x92 <__bad_interrupt>
      1c:	3a c0       	rjmp	.+116    	; 0x92 <__bad_interrupt>
      1e:	39 c0       	rjmp	.+114    	; 0x92 <__bad_interrupt>
      20:	38 c0       	rjmp	.+112    	; 0x92 <__bad_interrupt>
      22:	37 c0       	rjmp	.+110    	; 0x92 <__bad_interrupt>
      24:	36 c0       	rjmp	.+108    	; 0x92 <__bad_interrupt>
      26:	35 c0       	rjmp	.+106    	; 0x92 <__bad_interrupt>
      28:	34 c0       	rjmp	.+104    	; 0x92 <__bad_interrupt>
      2a:	33 c0       	rjmp	.+102    	; 0x92 <__bad_interrupt>
      2c:	32 c0       	rjmp	.+100    	; 0x92 <__bad_interrupt>
      2e:	31 c0       	rjmp	.+98     	; 0x92 <__bad_interrupt>
      30:	30 c0       	rjmp	.+96     	; 0x92 <__bad_interrupt>
      32:	2f c0       	rjmp	.+94     	; 0x92 <__bad_interrupt>
      34:	07 63       	ori	r16, 0x37	; 55
      36:	42 36       	cpi	r20, 0x62	; 98
      38:	b7 9b       	sbis	0x16, 7	; 22
      3a:	d8 a7       	std	Y+40, r29	; 0x28
      3c:	1a 39       	cpi	r17, 0x9A	; 154
      3e:	68 56       	subi	r22, 0x68	; 104
      40:	18 ae       	std	Y+56, r1	; 0x38
      42:	ba ab       	std	Y+50, r27	; 0x32
      44:	55 8c       	ldd	r5, Z+29	; 0x1d
      46:	1d 3c       	cpi	r17, 0xCD	; 205
      48:	b7 cc       	rjmp	.-1682   	; 0xfffff9b8 <__eeprom_end+0xff7ef9b8>
      4a:	57 63       	ori	r21, 0x37	; 55
      4c:	bd 6d       	ori	r27, 0xDD	; 221
      4e:	ed fd       	.word	0xfded	; ????
      50:	75 3e       	cpi	r23, 0xE5	; 229
      52:	f6 17       	cp	r31, r22
      54:	72 31       	cpi	r23, 0x12	; 18
      56:	bf 00       	.word	0x00bf	; ????
      58:	00 00       	nop
      5a:	80 3f       	cpi	r24, 0xF0	; 240

0000005c <__ctors_end>:
      5c:	11 24       	eor	r1, r1
      5e:	1f be       	out	0x3f, r1	; 63
      60:	cf ef       	ldi	r28, 0xFF	; 255
      62:	cd bf       	out	0x3d, r28	; 61
      64:	df e3       	ldi	r29, 0x3F	; 63
      66:	de bf       	out	0x3e, r29	; 62

00000068 <__do_copy_data>:
      68:	1e e3       	ldi	r17, 0x3E	; 62
      6a:	a0 e0       	ldi	r26, 0x00	; 0
      6c:	be e3       	ldi	r27, 0x3E	; 62
      6e:	e8 e3       	ldi	r30, 0x38	; 56
      70:	f4 e1       	ldi	r31, 0x14	; 20
      72:	02 c0       	rjmp	.+4      	; 0x78 <__do_copy_data+0x10>
      74:	05 90       	lpm	r0, Z+
      76:	0d 92       	st	X+, r0
      78:	ae 30       	cpi	r26, 0x0E	; 14
      7a:	b1 07       	cpc	r27, r17
      7c:	d9 f7       	brne	.-10     	; 0x74 <__do_copy_data+0xc>

0000007e <__do_clear_bss>:
      7e:	2e e3       	ldi	r18, 0x3E	; 62
      80:	ae e0       	ldi	r26, 0x0E	; 14
      82:	be e3       	ldi	r27, 0x3E	; 62
      84:	01 c0       	rjmp	.+2      	; 0x88 <.do_clear_bss_start>

00000086 <.do_clear_bss_loop>:
      86:	1d 92       	st	X+, r1

00000088 <.do_clear_bss_start>:
      88:	ad 35       	cpi	r26, 0x5D	; 93
      8a:	b2 07       	cpc	r27, r18
      8c:	e1 f7       	brne	.-8      	; 0x86 <.do_clear_bss_loop>
      8e:	db d1       	rcall	.+950    	; 0x446 <main>
      90:	d1 c9       	rjmp	.-3166   	; 0xfffff434 <__eeprom_end+0xff7ef434>

00000092 <__bad_interrupt>:
      92:	b6 cf       	rjmp	.-148    	; 0x0 <__vectors>

00000094 <atmel_start_init>:
/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
	system_init();
      94:	ad d0       	rcall	.+346    	; 0x1f0 <system_init>
      96:	08 95       	ret

00000098 <ADC_init>:
 * \return Conversion result read from the ADC ADC module
 */
adc_result_t ADC_get_conversion_result(void)
{
	return (ADC0.RES);
}
      98:	85 e0       	ldi	r24, 0x05	; 5
      9a:	80 93 00 06 	sts	0x0600, r24	; 0x800600 <__TEXT_REGION_LENGTH__+0x700600>
      9e:	80 e0       	ldi	r24, 0x00	; 0
      a0:	08 95       	ret

000000a2 <ADC_is_conversion_done>:
      a2:	80 91 0b 06 	lds	r24, 0x060B	; 0x80060b <__TEXT_REGION_LENGTH__+0x70060b>
      a6:	81 70       	andi	r24, 0x01	; 1
      a8:	08 95       	ret

000000aa <ADC_get_conversion>:
 *
 * \return Nothing
 */
void ADC_start_conversion(adc_0_channel_t channel)
{
	ADC0.MUXPOS  = channel;
      aa:	e0 e0       	ldi	r30, 0x00	; 0
      ac:	f6 e0       	ldi	r31, 0x06	; 6
      ae:	86 83       	std	Z+6, r24	; 0x06
	ADC0.COMMAND = ADC_STCONV_bm;
      b0:	81 e0       	ldi	r24, 0x01	; 1
      b2:	80 87       	std	Z+8, r24	; 0x08
adc_result_t ADC_get_conversion(adc_0_channel_t channel)
{
	adc_result_t res;

	ADC_start_conversion(channel);
	while (!ADC_is_conversion_done())
      b4:	f6 df       	rcall	.-20     	; 0xa2 <ADC_is_conversion_done>
      b6:	88 23       	and	r24, r24
      b8:	e9 f3       	breq	.-6      	; 0xb4 <ADC_get_conversion+0xa>
 *
 * \return Conversion result read from the ADC ADC module
 */
adc_result_t ADC_get_conversion_result(void)
{
	return (ADC0.RES);
      ba:	e0 e0       	ldi	r30, 0x00	; 0
      bc:	f6 e0       	ldi	r31, 0x06	; 6
      be:	20 89       	ldd	r18, Z+16	; 0x10
      c0:	31 89       	ldd	r19, Z+17	; 0x11

	ADC_start_conversion(channel);
	while (!ADC_is_conversion_done())
		;
	res = ADC_get_conversion_result();
	ADC0.INTFLAGS |= ADC_RESRDY_bm;
      c2:	93 85       	ldd	r25, Z+11	; 0x0b
      c4:	91 60       	ori	r25, 0x01	; 1
      c6:	93 87       	std	Z+11, r25	; 0x0b
	return res;
}
      c8:	c9 01       	movw	r24, r18
      ca:	08 95       	ret

000000cc <BOD_init>:
	//		 | BOD_VLMCFG_ABOVE_gc; /* Interrupt when supply goes above VLM level */

	// BOD.VLMCTRLA = BOD_VLMLVL_5ABOVE_gc; /* VLM threshold 5% above BOD level */

	return 0;
}
      cc:	80 e0       	ldi	r24, 0x00	; 0
      ce:	08 95       	ret

000000d0 <DIGGSIGG_init>:
	//		 | CCL_EDGEDET_DIS_gc /* Edge detector is disabled */
	//		 | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	//		 | 0 << CCL_ENABLE_bp /* LUT Enable: disabled */
	//		 | 0 << CCL_OUTEN_bp; /* Output Enable: disabled */

	CCL.TRUTH1 = 168; /* Truth 1: 168 */
      d0:	e0 ec       	ldi	r30, 0xC0	; 192
      d2:	f1 e0       	ldi	r31, 0x01	; 1
      d4:	88 ea       	ldi	r24, 0xA8	; 168
      d6:	84 87       	std	Z+12, r24	; 0x0c

	CCL.LUT1CTRLC = CCL_INSEL2_TCA0_gc /* TCA0 WO2 input source */;
      d8:	88 e0       	ldi	r24, 0x08	; 8
      da:	83 87       	std	Z+11, r24	; 0x0b

	CCL.LUT1CTRLB = CCL_INSEL0_SPI0_gc /* SPI0 SCK source */
      dc:	8b eb       	ldi	r24, 0xBB	; 187
      de:	82 87       	std	Z+10, r24	; 0x0a
	                | CCL_INSEL1_SPI0_gc /* SPI0 MOSI input source */;

	CCL.LUT1CTRLA = 0 << CCL_CLKSRC_bp       /* Clock Source Selection: disabled */
      e0:	89 e0       	ldi	r24, 0x09	; 9
      e2:	81 87       	std	Z+9, r24	; 0x09
	                | CCL_EDGEDET_DIS_gc     /* Edge detector is disabled */
	                | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	                | 1 << CCL_ENABLE_bp     /* LUT Enable: enabled */
	                | 1 << CCL_OUTEN_bp;     /* Output Enable: enabled */

	CCL.CTRLA = 1 << CCL_ENABLE_bp      /* Enable: enabled */
      e4:	81 e4       	ldi	r24, 0x41	; 65
      e6:	80 83       	st	Z, r24
	            | 1 << CCL_RUNSTDBY_bp; /* Run in Standby: enabled */

	return 0;
}
      e8:	80 e0       	ldi	r24, 0x00	; 0
      ea:	08 95       	ret

000000ec <CLKCTRL_init>:
 *       on calling convention. The memory model is not visible to the
 *       preprocessor, so it must be defined in the Assembler preprocessor directives.
 */
static inline void ccp_write_io(void *addr, uint8_t value)
{
	protected_write_io(addr, CCP_IOREG_gc, value);
      ec:	47 e0       	ldi	r20, 0x07	; 7
      ee:	68 ed       	ldi	r22, 0xD8	; 216
      f0:	8c e7       	ldi	r24, 0x7C	; 124
      f2:	90 e0       	ldi	r25, 0x00	; 0
      f4:	91 d0       	rcall	.+290    	; 0x218 <protected_write_io>
      f6:	41 e0       	ldi	r20, 0x01	; 1
      f8:	68 ed       	ldi	r22, 0xD8	; 216
      fa:	81 e6       	ldi	r24, 0x61	; 97
      fc:	90 e0       	ldi	r25, 0x00	; 0
      fe:	8c d0       	rcall	.+280    	; 0x218 <protected_write_io>
	//		 | 0 << CLKCTRL_CLKOUT_bp /* System clock out: disabled */);

	// ccp_write_io((void*)&(CLKCTRL.MCLKLOCK),0 << CLKCTRL_LOCKEN_bp /* lock enable: disabled */);

	return 0;
}
     100:	80 e0       	ldi	r24, 0x00	; 0
     102:	08 95       	ret

00000104 <CPUINT_init>:

	// CPUINT.LVL0PRI = 0x0 << CPUINT_LVL0PRI_gp; /* Interrupt Level Priority: 0x0 */

	// CPUINT.LVL1VEC = 0x0 << CPUINT_LVL1VEC_gp; /* Interrupt Vector with High Priority: 0x0 */

	ENABLE_INTERRUPTS();
     104:	78 94       	sei

	return 0;
}
     106:	80 e0       	ldi	r24, 0x00	; 0
     108:	08 95       	ret

0000010a <DAC_init>:
 *
 * \return Nothing
 */
void DAC_disable()
{
	DAC0.CTRLA &= ~DAC_ENABLE_bm;
     10a:	81 e4       	ldi	r24, 0x41	; 65
     10c:	80 93 80 06 	sts	0x0680, r24	; 0x800680 <__TEXT_REGION_LENGTH__+0x700680>
     110:	80 e0       	ldi	r24, 0x00	; 0
     112:	08 95       	ret

00000114 <DAC_set_output>:
 *
 * \return Nothing
 */
void DAC_set_output(dac_resolution_t value)
{
	DAC0.DATA = value;
     114:	80 93 81 06 	sts	0x0681, r24	; 0x800681 <__TEXT_REGION_LENGTH__+0x700681>
     118:	08 95       	ret

0000011a <mcu_init>:

/* configure pins and initialize registers */
void DAC_initialization(void)
{

	DAC_init();
     11a:	e0 e1       	ldi	r30, 0x10	; 16
     11c:	f4 e0       	ldi	r31, 0x04	; 4
     11e:	80 81       	ld	r24, Z
     120:	88 60       	ori	r24, 0x08	; 8
     122:	81 93       	st	Z+, r24
     124:	e8 31       	cpi	r30, 0x18	; 24
     126:	84 e0       	ldi	r24, 0x04	; 4
     128:	f8 07       	cpc	r31, r24
     12a:	c9 f7       	brne	.-14     	; 0x11e <mcu_init+0x4>
     12c:	e0 e3       	ldi	r30, 0x30	; 48
     12e:	f4 e0       	ldi	r31, 0x04	; 4
     130:	80 81       	ld	r24, Z
     132:	88 60       	ori	r24, 0x08	; 8
     134:	81 93       	st	Z+, r24
     136:	e8 33       	cpi	r30, 0x38	; 56
     138:	84 e0       	ldi	r24, 0x04	; 4
     13a:	f8 07       	cpc	r31, r24
     13c:	c9 f7       	brne	.-14     	; 0x130 <mcu_init+0x16>
     13e:	e0 e5       	ldi	r30, 0x50	; 80
     140:	f4 e0       	ldi	r31, 0x04	; 4
     142:	80 81       	ld	r24, Z
     144:	88 60       	ori	r24, 0x08	; 8
     146:	81 93       	st	Z+, r24
     148:	e8 35       	cpi	r30, 0x58	; 88
     14a:	84 e0       	ldi	r24, 0x04	; 4
     14c:	f8 07       	cpc	r31, r24
     14e:	c9 f7       	brne	.-14     	; 0x142 <mcu_init+0x28>
     150:	08 95       	ret

00000152 <ADC_initialization>:
     152:	e5 e1       	ldi	r30, 0x15	; 21
     154:	f4 e0       	ldi	r31, 0x04	; 4
     156:	80 81       	ld	r24, Z
     158:	88 7f       	andi	r24, 0xF8	; 248
     15a:	84 60       	ori	r24, 0x04	; 4
     15c:	80 83       	st	Z, r24
     15e:	80 81       	ld	r24, Z
     160:	87 7f       	andi	r24, 0xF7	; 247
     162:	80 83       	st	Z, r24
     164:	e7 e1       	ldi	r30, 0x17	; 23
     166:	f4 e0       	ldi	r31, 0x04	; 4
     168:	80 81       	ld	r24, Z
     16a:	88 7f       	andi	r24, 0xF8	; 248
     16c:	84 60       	ori	r24, 0x04	; 4
     16e:	80 83       	st	Z, r24
     170:	80 81       	ld	r24, Z
     172:	87 7f       	andi	r24, 0xF7	; 247
     174:	80 83       	st	Z, r24
     176:	e4 e3       	ldi	r30, 0x34	; 52
     178:	f4 e0       	ldi	r31, 0x04	; 4
     17a:	80 81       	ld	r24, Z
     17c:	88 7f       	andi	r24, 0xF8	; 248
     17e:	84 60       	ori	r24, 0x04	; 4
     180:	80 83       	st	Z, r24
     182:	80 81       	ld	r24, Z
     184:	87 7f       	andi	r24, 0xF7	; 247
     186:	80 83       	st	Z, r24
     188:	e1 e3       	ldi	r30, 0x31	; 49
     18a:	f4 e0       	ldi	r31, 0x04	; 4
     18c:	80 81       	ld	r24, Z
     18e:	88 7f       	andi	r24, 0xF8	; 248
     190:	84 60       	ori	r24, 0x04	; 4
     192:	80 83       	st	Z, r24
     194:	80 81       	ld	r24, Z
     196:	87 7f       	andi	r24, 0xF7	; 247
     198:	80 83       	st	Z, r24
     19a:	e0 e3       	ldi	r30, 0x30	; 48
     19c:	f4 e0       	ldi	r31, 0x04	; 4
     19e:	80 81       	ld	r24, Z
     1a0:	88 7f       	andi	r24, 0xF8	; 248
     1a2:	84 60       	ori	r24, 0x04	; 4
     1a4:	80 83       	st	Z, r24
     1a6:	80 81       	ld	r24, Z
     1a8:	87 7f       	andi	r24, 0xF7	; 247
     1aa:	80 83       	st	Z, r24
     1ac:	75 df       	rcall	.-278    	; 0x98 <ADC_init>
     1ae:	08 95       	ret

000001b0 <TIMER_0_initialization>:
     1b0:	25 9a       	sbi	0x04, 5	; 4
     1b2:	2d 98       	cbi	0x05, 5	; 5
     1b4:	e0 e0       	ldi	r30, 0x00	; 0
     1b6:	f2 e0       	ldi	r31, 0x02	; 2
     1b8:	82 81       	ldd	r24, Z+2	; 0x02
     1ba:	84 60       	ori	r24, 0x04	; 4
     1bc:	82 83       	std	Z+2, r24	; 0x02
     1be:	da d0       	rcall	.+436    	; 0x374 <TIMER_0_init>
     1c0:	08 95       	ret

000001c2 <DIGGSIGG_initialization>:
     1c2:	41 9a       	sbi	0x08, 1	; 8
     1c4:	49 98       	cbi	0x09, 1	; 9
     1c6:	e0 e0       	ldi	r30, 0x00	; 0
     1c8:	f2 e0       	ldi	r31, 0x02	; 2
     1ca:	80 81       	ld	r24, Z
     1cc:	80 62       	ori	r24, 0x20	; 32
     1ce:	80 83       	st	Z, r24
     1d0:	7f df       	rcall	.-258    	; 0xd0 <DIGGSIGG_init>
     1d2:	08 95       	ret

000001d4 <SPI_0_initialization>:
     1d4:	02 98       	cbi	0x00, 2	; 0
     1d6:	e2 e1       	ldi	r30, 0x12	; 18
     1d8:	f4 e0       	ldi	r31, 0x04	; 4
     1da:	80 81       	ld	r24, Z
     1dc:	87 7f       	andi	r24, 0xF7	; 247
     1de:	80 83       	st	Z, r24
     1e0:	01 9a       	sbi	0x00, 1	; 0
     1e2:	09 98       	cbi	0x01, 1	; 1
     1e4:	03 9a       	sbi	0x00, 3	; 0
     1e6:	0b 98       	cbi	0x01, 3	; 1
     1e8:	04 9a       	sbi	0x00, 4	; 0
     1ea:	0c 98       	cbi	0x01, 4	; 1
     1ec:	bb d0       	rcall	.+374    	; 0x364 <SPI_0_init>
     1ee:	08 95       	ret

000001f0 <system_init>:
/**
 * \brief System initialization
 */
void system_init()
{
	mcu_init();
     1f0:	94 df       	rcall	.-216    	; 0x11a <mcu_init>
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     1f2:	27 9a       	sbi	0x04, 7	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     1f4:	2f 98       	cbi	0x05, 7	; 5
 */
static inline void PORTC_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
     1f6:	42 98       	cbi	0x08, 2	; 8
static inline void PORTC_set_pin_pull_mode(const uint8_t pin, const enum port_pull_mode pull_mode)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
     1f8:	e2 e5       	ldi	r30, 0x52	; 82
     1fa:	f4 e0       	ldi	r31, 0x04	; 4
     1fc:	80 81       	ld	r24, Z
     1fe:	88 60       	ori	r24, 0x08	; 8
     200:	80 83       	st	Z, r24
	    // <id> pad_pull_config
	    // <PORT_PULL_OFF"> Off
	    // <PORT_PULL_UP"> Pull-up
	    PORT_PULL_UP);

	CLKCTRL_init();
     202:	74 df       	rcall	.-280    	; 0xec <CLKCTRL_init>

	RTC_init();
     204:	93 d0       	rcall	.+294    	; 0x32c <RTC_init>

	ADC_initialization();
     206:	a5 df       	rcall	.-182    	; 0x152 <ADC_initialization>

	TIMER_0_initialization();
     208:	d3 df       	rcall	.-90     	; 0x1b0 <TIMER_0_initialization>

	DIGGSIGG_initialization();
     20a:	db df       	rcall	.-74     	; 0x1c2 <DIGGSIGG_initialization>

	SPI_0_initialization();
     20c:	e3 df       	rcall	.-58     	; 0x1d4 <SPI_0_initialization>

/* configure pins and initialize registers */
void DAC_initialization(void)
{

	DAC_init();
     20e:	7d df       	rcall	.-262    	; 0x10a <DAC_init>

	SPI_0_initialization();

	DAC_initialization();

	CPUINT_init();
     210:	79 df       	rcall	.-270    	; 0x104 <CPUINT_init>

	SLPCTRL_init();
     212:	a6 d0       	rcall	.+332    	; 0x360 <SLPCTRL_init>

	BOD_init();
     214:	5b df       	rcall	.-330    	; 0xcc <BOD_init>
     216:	08 95       	ret

00000218 <protected_write_io>:
#if defined(__GNUC__)
  
#ifdef RAMPZ
	out     _SFR_IO_ADDR(RAMPZ), r1         // Clear bits 23:16 of Z
#endif
	movw    r30, r24                // Load addr into Z
     218:	fc 01       	movw	r30, r24
	out     CCP, r22                // Start CCP handshake
     21a:	64 bf       	out	0x34, r22	; 52
	st      Z, r20                  // Write value to I/O register
     21c:	40 83       	st	Z, r20
	ret                             // Return to caller
     21e:	08 95       	ret

00000220 <enqueue>:
 */ 
#include <stdio.h>
#include <stdlib.h>
#include "include/queue.h"

void enqueue(node_t **head, uint32_t val) {
     220:	cf 92       	push	r12
     222:	df 92       	push	r13
     224:	ef 92       	push	r14
     226:	ff 92       	push	r15
     228:	cf 93       	push	r28
     22a:	df 93       	push	r29
     22c:	ec 01       	movw	r28, r24
     22e:	6a 01       	movw	r12, r20
     230:	7b 01       	movw	r14, r22
	// remember, head is at the very BACK of the queue (The element that will wait the longest until dequeued)
	
	// we create a new empty node
	node_t *new_node = malloc(sizeof(node_t));
     232:	86 e0       	ldi	r24, 0x06	; 6
     234:	90 e0       	ldi	r25, 0x00	; 0
     236:	dd d7       	rcall	.+4026   	; 0x11f2 <malloc>
	// Not quite sure what happens here, but it seems to be some sort of error handling, except you never know if there has been an error :/
	if (!new_node) return;
     238:	00 97       	sbiw	r24, 0x00	; 0
     23a:	59 f0       	breq	.+22     	; 0x252 <enqueue+0x32>

	// we configure our node
	new_node->val = val;
     23c:	fc 01       	movw	r30, r24
     23e:	c0 82       	st	Z, r12
     240:	d1 82       	std	Z+1, r13	; 0x01
     242:	e2 82       	std	Z+2, r14	; 0x02
     244:	f3 82       	std	Z+3, r15	; 0x03
	new_node->next = *head;
     246:	28 81       	ld	r18, Y
     248:	39 81       	ldd	r19, Y+1	; 0x01
     24a:	24 83       	std	Z+4, r18	; 0x04
     24c:	35 83       	std	Z+5, r19	; 0x05

	// and lastly, we change the pointer pointing to the previous head node, to point to our new node instead
	*head = new_node;
     24e:	88 83       	st	Y, r24
     250:	99 83       	std	Y+1, r25	; 0x01
}
     252:	df 91       	pop	r29
     254:	cf 91       	pop	r28
     256:	ff 90       	pop	r15
     258:	ef 90       	pop	r14
     25a:	df 90       	pop	r13
     25c:	cf 90       	pop	r12
     25e:	08 95       	ret

00000260 <dequeue>:

uint32_t dequeue(node_t **head) {
     260:	cf 92       	push	r12
     262:	df 92       	push	r13
     264:	ef 92       	push	r14
     266:	ff 92       	push	r15
     268:	0f 93       	push	r16
     26a:	1f 93       	push	r17
     26c:	cf 93       	push	r28
     26e:	df 93       	push	r29
	node_t *current, *prev = NULL;
	uint32_t retval = 0;

	// If the queue we have been given is empty, we return an error
	// (0 is usually not an error, but it is probably the best option)
	if (*head == NULL) return 0;
     270:	dc 01       	movw	r26, r24
     272:	ed 91       	ld	r30, X+
     274:	fc 91       	ld	r31, X
     276:	30 97       	sbiw	r30, 0x00	; 0
     278:	11 f1       	breq	.+68     	; 0x2be <dequeue+0x5e>
     27a:	c0 e0       	ldi	r28, 0x00	; 0
     27c:	d0 e0       	ldi	r29, 0x00	; 0
     27e:	02 c0       	rjmp	.+4      	; 0x284 <dequeue+0x24>
     280:	ef 01       	movw	r28, r30

	// Now we iterate through the queue until we reach the end
	current = *head;
	while (current->next != NULL) {
		prev = current;
		current = current->next;
     282:	f9 01       	movw	r30, r18
	// (0 is usually not an error, but it is probably the best option)
	if (*head == NULL) return 0;

	// Now we iterate through the queue until we reach the end
	current = *head;
	while (current->next != NULL) {
     284:	24 81       	ldd	r18, Z+4	; 0x04
     286:	35 81       	ldd	r19, Z+5	; 0x05
     288:	21 15       	cp	r18, r1
     28a:	31 05       	cpc	r19, r1
     28c:	c9 f7       	brne	.-14     	; 0x280 <dequeue+0x20>
     28e:	8c 01       	movw	r16, r24
		prev = current;
		current = current->next;
	}

	// We retrieve the value we needed
	retval = current->val;
     290:	c0 80       	ld	r12, Z
     292:	d1 80       	ldd	r13, Z+1	; 0x01
     294:	e2 80       	ldd	r14, Z+2	; 0x02
     296:	f3 80       	ldd	r15, Z+3	; 0x03
	// and remove the last element of the queue from the queue
	free(current);
     298:	cf 01       	movw	r24, r30
     29a:	43 d8       	rcall	.-3962   	; 0xfffff322 <__eeprom_end+0xff7ef322>
	
	// Now we update the previous node so that it becomes the front of the queue
	// In case the queue only had one element, the prev will be null (false)
	if (prev){
     29c:	20 97       	sbiw	r28, 0x00	; 0
     29e:	39 f0       	breq	.+14     	; 0x2ae <dequeue+0x4e>
	prev->next = NULL;}
     2a0:	1c 82       	std	Y+4, r1	; 0x04
     2a2:	1d 82       	std	Y+5, r1	; 0x05
	else{
	*head = NULL;}

	return retval;
     2a4:	6c 2d       	mov	r22, r12
     2a6:	7d 2d       	mov	r23, r13
     2a8:	8e 2d       	mov	r24, r14
     2aa:	9f 2d       	mov	r25, r15
     2ac:	0c c0       	rjmp	.+24     	; 0x2c6 <dequeue+0x66>
	// Now we update the previous node so that it becomes the front of the queue
	// In case the queue only had one element, the prev will be null (false)
	if (prev){
	prev->next = NULL;}
	else{
	*head = NULL;}
     2ae:	f8 01       	movw	r30, r16
     2b0:	10 82       	st	Z, r1
     2b2:	11 82       	std	Z+1, r1	; 0x01

	return retval;
     2b4:	6c 2d       	mov	r22, r12
     2b6:	7d 2d       	mov	r23, r13
     2b8:	8e 2d       	mov	r24, r14
     2ba:	9f 2d       	mov	r25, r15
     2bc:	04 c0       	rjmp	.+8      	; 0x2c6 <dequeue+0x66>
	node_t *current, *prev = NULL;
	uint32_t retval = 0;

	// If the queue we have been given is empty, we return an error
	// (0 is usually not an error, but it is probably the best option)
	if (*head == NULL) return 0;
     2be:	60 e0       	ldi	r22, 0x00	; 0
     2c0:	70 e0       	ldi	r23, 0x00	; 0
     2c2:	80 e0       	ldi	r24, 0x00	; 0
     2c4:	90 e0       	ldi	r25, 0x00	; 0
	prev->next = NULL;}
	else{
	*head = NULL;}

	return retval;
}
     2c6:	df 91       	pop	r29
     2c8:	cf 91       	pop	r28
     2ca:	1f 91       	pop	r17
     2cc:	0f 91       	pop	r16
     2ce:	ff 90       	pop	r15
     2d0:	ef 90       	pop	r14
     2d2:	df 90       	pop	r13
     2d4:	cf 90       	pop	r12
     2d6:	08 95       	ret

000002d8 <dequeue_top>:

// Here we remove the element of the queue that was added last (first in, last out)
uint32_t dequeue_top(node_t **head){
     2d8:	cf 92       	push	r12
     2da:	df 92       	push	r13
     2dc:	ef 92       	push	r14
     2de:	ff 92       	push	r15
     2e0:	0f 93       	push	r16
     2e2:	1f 93       	push	r17
     2e4:	cf 93       	push	r28
     2e6:	df 93       	push	r29
	node_t *oldHead;
	uint32_t retval = 0;
	
	// If the queue we have been given is empty, we return an error
	// (0 is usually not an error, but it is probably the best option)
	if (*head == NULL) return 0;
     2e8:	dc 01       	movw	r26, r24
     2ea:	ed 91       	ld	r30, X+
     2ec:	fc 91       	ld	r31, X
     2ee:	30 97       	sbiw	r30, 0x00	; 0
     2f0:	81 f0       	breq	.+32     	; 0x312 <dequeue_top+0x3a>
     2f2:	ec 01       	movw	r28, r24
	
	oldHead = *head;
	// We then set the new head to be the second last in the queue
	newHead = oldHead->next;
     2f4:	c4 80       	ldd	r12, Z+4	; 0x04
     2f6:	d5 80       	ldd	r13, Z+5	; 0x05
	
	// We retrieve the heads value
	retval = oldHead->val;
     2f8:	e0 80       	ld	r14, Z
     2fa:	f1 80       	ldd	r15, Z+1	; 0x01
     2fc:	02 81       	ldd	r16, Z+2	; 0x02
     2fe:	13 81       	ldd	r17, Z+3	; 0x03
	
	// We free the memory that was used to store the old head
	free(oldHead);
     300:	cf 01       	movw	r24, r30
     302:	0f d8       	rcall	.-4066   	; 0xfffff322 <__eeprom_end+0xff7ef322>
	
	//And then we overwrite the value of head to be the second last
	*head = newHead;
     304:	c8 82       	st	Y, r12
     306:	d9 82       	std	Y+1, r13	; 0x01
	
	return retval;
     308:	6e 2d       	mov	r22, r14
     30a:	7f 2d       	mov	r23, r15
     30c:	80 2f       	mov	r24, r16
     30e:	91 2f       	mov	r25, r17
     310:	04 c0       	rjmp	.+8      	; 0x31a <dequeue_top+0x42>
	node_t *oldHead;
	uint32_t retval = 0;
	
	// If the queue we have been given is empty, we return an error
	// (0 is usually not an error, but it is probably the best option)
	if (*head == NULL) return 0;
     312:	60 e0       	ldi	r22, 0x00	; 0
     314:	70 e0       	ldi	r23, 0x00	; 0
     316:	80 e0       	ldi	r24, 0x00	; 0
     318:	90 e0       	ldi	r25, 0x00	; 0
	//And then we overwrite the value of head to be the second last
	*head = newHead;
	
	return retval;
	
}
     31a:	df 91       	pop	r29
     31c:	cf 91       	pop	r28
     31e:	1f 91       	pop	r17
     320:	0f 91       	pop	r16
     322:	ff 90       	pop	r15
     324:	ef 90       	pop	r14
     326:	df 90       	pop	r13
     328:	cf 90       	pop	r12
     32a:	08 95       	ret

0000032c <RTC_init>:
 * \return Initialization status.
 */
int8_t RTC_init()
{

	while (RTC.STATUS > 0) { /* Wait for all register to be synchronized */
     32c:	e0 e4       	ldi	r30, 0x40	; 64
     32e:	f1 e0       	ldi	r31, 0x01	; 1
     330:	81 81       	ldd	r24, Z+1	; 0x01
     332:	81 11       	cpse	r24, r1
     334:	fd cf       	rjmp	.-6      	; 0x330 <RTC_init+0x4>
	}

	// RTC.CMP = 0x0; /* Compare: 0x0 */

	RTC.CNT = 0x20; /* Counter: 0x20 */
     336:	e0 e4       	ldi	r30, 0x40	; 64
     338:	f1 e0       	ldi	r31, 0x01	; 1
     33a:	80 e2       	ldi	r24, 0x20	; 32
     33c:	90 e0       	ldi	r25, 0x00	; 0
     33e:	80 87       	std	Z+8, r24	; 0x08
     340:	91 87       	std	Z+9, r25	; 0x09

	RTC.CTRLA = RTC_PRESCALER_DIV1_gc   /* 1 */
     342:	21 e8       	ldi	r18, 0x81	; 129
     344:	20 83       	st	Z, r18
	            | 1 << RTC_RTCEN_bp     /* Enable: enabled */
	            | 1 << RTC_RUNSTDBY_bp; /* Run In Standby: enabled */

	RTC.PER = 0x20; /* Period: 0x20 */
     346:	82 87       	std	Z+10, r24	; 0x0a
     348:	93 87       	std	Z+11, r25	; 0x0b

	// RTC.CLKSEL = RTC_CLKSEL_INT32K_gc; /* 32KHz Internal Ultra Low Power Oscillator (OSCULP32K) */

	RTC.DBGCTRL = 1 << RTC_DBGRUN_bp; /* Run in debug: enabled */
     34a:	81 e0       	ldi	r24, 0x01	; 1
     34c:	85 83       	std	Z+5, r24	; 0x05

	RTC.INTCTRL = 0 << RTC_CMP_bp    /* Compare Match Interrupt enable: disabled */
     34e:	82 83       	std	Z+2, r24	; 0x02
	              | 1 << RTC_OVF_bp; /* Overflow Interrupt enable: enabled */

	while (RTC.PITSTATUS > 0) { /* Wait for all register to be synchronized */
     350:	81 89       	ldd	r24, Z+17	; 0x11
     352:	81 11       	cpse	r24, r1
     354:	fd cf       	rjmp	.-6      	; 0x350 <RTC_init+0x24>
	}

	RTC.PITCTRLA = RTC_PERIOD_OFF_gc    /* Off */
     356:	81 e0       	ldi	r24, 0x01	; 1
     358:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <__TEXT_REGION_LENGTH__+0x700150>
	// RTC.PITDBGCTRL = 0 << RTC_DBGRUN_bp; /* Run in debug: disabled */

	// RTC.PITINTCTRL = 0 << RTC_PI_bp; /* Periodic Interrupt: disabled */

	return 0;
}
     35c:	80 e0       	ldi	r24, 0x00	; 0
     35e:	08 95       	ret

00000360 <SLPCTRL_init>:

	// SLPCTRL.CTRLA = 0 << SLPCTRL_SEN_bp /* Sleep enable: disabled */
	//		 | SLPCTRL_SMODE_IDLE_gc; /* Idle mode */

	return 0;
}
     360:	80 e0       	ldi	r24, 0x00	; 0
     362:	08 95       	ret

00000364 <SPI_0_init>:
 * \return Initialization status
 */
int8_t SPI_0_init()
{

	SPI0.CTRLA = 0 << SPI_CLK2X_bp     /* Enable Double Speed: disabled */
     364:	e0 e2       	ldi	r30, 0x20	; 32
     366:	f8 e0       	ldi	r31, 0x08	; 8
     368:	83 e2       	ldi	r24, 0x23	; 35
     36a:	80 83       	st	Z, r24
	             | 0 << SPI_DORD_bp    /* Data Order Setting: disabled */
	             | 1 << SPI_ENABLE_bp  /* Enable Module: enabled */
	             | 1 << SPI_MASTER_bp  /* SPI module in master mode */
	             | SPI_PRESC_DIV16_gc; /* System Clock / 16 */

	SPI0.CTRLB = 0 << SPI_BUFEN_bp   /* Buffer Mode Enable: disabled */
     36c:	84 e0       	ldi	r24, 0x04	; 4
     36e:	81 83       	std	Z+1, r24	; 0x01
	//		 | 0 << SPI_RXCIE_bp /* Receive Complete Interrupt Enable: disabled */
	//		 | 0 << SPI_SSIE_bp /* Slave Select Trigger Interrupt Enable: disabled */
	//		 | 0 << SPI_TXCIE_bp; /* Transfer Complete Interrupt Enable: disabled */

	return 0;
}
     370:	80 e0       	ldi	r24, 0x00	; 0
     372:	08 95       	ret

00000374 <TIMER_0_init>:

	// TCA0.SINGLE.CMP0 = 0x0; /* Compare Register 0: 0x0 */

	// TCA0.SINGLE.CMP1 = 0x0; /* Compare Register 1: 0x0 */

	TCA0.SINGLE.CMP2 = 0x4; /* Compare Register 2: 0x4 */
     374:	e0 e0       	ldi	r30, 0x00	; 0
     376:	fa e0       	ldi	r31, 0x0A	; 10
     378:	84 e0       	ldi	r24, 0x04	; 4
     37a:	90 e0       	ldi	r25, 0x00	; 0
     37c:	84 a7       	std	Z+44, r24	; 0x2c
     37e:	95 a7       	std	Z+45, r25	; 0x2d

	// TCA0.SINGLE.CNT = 0x0; /* Count: 0x0 */

	TCA0.SINGLE.CTRLB = 0 << TCA_SINGLE_ALUPD_bp            /* Auto Lock Update: disabled */
     380:	83 e4       	ldi	r24, 0x43	; 67
     382:	81 83       	std	Z+1, r24	; 0x01
	                    | 0 << TCA_SINGLE_CMP0EN_bp         /* Compare 0 Enable: disabled */
	                    | 0 << TCA_SINGLE_CMP1EN_bp         /* Compare 1 Enable: disabled */
	                    | 1 << TCA_SINGLE_CMP2EN_bp         /* Compare 2 Enable: enabled */
	                    | TCA_SINGLE_WGMODE_SINGLESLOPE_gc; /*  */

	TCA0.SINGLE.CTRLC = 0 << TCA_SINGLE_CMP0OV_bp    /* Compare 0 Waveform Output Value: disabled */
     384:	84 e0       	ldi	r24, 0x04	; 4
     386:	82 83       	std	Z+2, r24	; 0x02
	// TCA0.SINGLE.INTCTRL = 0 << TCA_SINGLE_CMP0_bp /* Compare 0 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP1_bp /* Compare 1 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP2_bp /* Compare 2 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_OVF_bp; /* Overflow Interrupt: disabled */

	TCA0.SINGLE.PER = 0x7; /* Period: 0x7 */
     388:	87 e0       	ldi	r24, 0x07	; 7
     38a:	90 e0       	ldi	r25, 0x00	; 0
     38c:	86 a3       	std	Z+38, r24	; 0x26
     38e:	97 a3       	std	Z+39, r25	; 0x27

	// TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV1_gc /* System Clock */
	//		 | 0 << TCA_SINGLE_ENABLE_bp; /* Module Enable: disabled */

	return 0;
}
     390:	80 e0       	ldi	r24, 0x00	; 0
     392:	08 95       	ret

00000394 <tinyPulse_toggle_pulse_mode>:
uint32_t time_of_last_pulse = 0;
uint16_t time_since_last_pulse = 0;
uint16_t ideal_time_between_pulses = 1000/PULSEMODE_FREQUENCY;

void tinyPulse_toggle_pulse_mode(){
	pulse_mode = !pulse_mode;
     394:	90 91 14 3e 	lds	r25, 0x3E14	; 0x803e14 <pulse_mode>
     398:	81 e0       	ldi	r24, 0x01	; 1
     39a:	89 27       	eor	r24, r25
     39c:	80 93 14 3e 	sts	0x3E14, r24	; 0x803e14 <pulse_mode>
     3a0:	08 95       	ret

000003a2 <tinyPulse_update_potential>:
}

double tinyPulse_update_potential(double potential){
     3a2:	cf 92       	push	r12
     3a4:	df 92       	push	r13
     3a6:	ef 92       	push	r14
     3a8:	ff 92       	push	r15
     3aa:	6b 01       	movw	r12, r22
     3ac:	7c 01       	movw	r14, r24
	if(pulse_mode){
     3ae:	80 91 14 3e 	lds	r24, 0x3E14	; 0x803e14 <pulse_mode>
     3b2:	88 23       	and	r24, r24
     3b4:	21 f1       	breq	.+72     	; 0x3fe <tinyPulse_update_potential+0x5c>
		
		time_since_last_pulse = tinyTime_now() - time_of_last_pulse;
     3b6:	3e d0       	rcall	.+124    	; 0x434 <tinyTime_now>
     3b8:	20 91 10 3e 	lds	r18, 0x3E10	; 0x803e10 <time_of_last_pulse>
     3bc:	30 91 11 3e 	lds	r19, 0x3E11	; 0x803e11 <time_of_last_pulse+0x1>
     3c0:	62 1b       	sub	r22, r18
     3c2:	73 0b       	sbc	r23, r19
     3c4:	60 93 0e 3e 	sts	0x3E0E, r22	; 0x803e0e <__data_end>
     3c8:	70 93 0f 3e 	sts	0x3E0F, r23	; 0x803e0f <__data_end+0x1>
		
		if(time_since_last_pulse >= ideal_time_between_pulses){
     3cc:	80 91 06 3e 	lds	r24, 0x3E06	; 0x803e06 <ideal_time_between_pulses>
     3d0:	90 91 07 3e 	lds	r25, 0x3E07	; 0x803e07 <ideal_time_between_pulses+0x1>
     3d4:	68 17       	cp	r22, r24
     3d6:	79 07       	cpc	r23, r25
     3d8:	90 f0       	brcs	.+36     	; 0x3fe <tinyPulse_update_potential+0x5c>
			potential += BUTTON_PRESS_REACTION;
     3da:	20 e0       	ldi	r18, 0x00	; 0
     3dc:	30 e0       	ldi	r19, 0x00	; 0
     3de:	40 ed       	ldi	r20, 0xD0	; 208
     3e0:	51 e4       	ldi	r21, 0x41	; 65
     3e2:	c7 01       	movw	r24, r14
     3e4:	b6 01       	movw	r22, r12
     3e6:	a4 d3       	rcall	.+1864   	; 0xb30 <__addsf3>
     3e8:	6b 01       	movw	r12, r22
     3ea:	7c 01       	movw	r14, r24
			time_of_last_pulse = tinyTime_now();			
     3ec:	23 d0       	rcall	.+70     	; 0x434 <tinyTime_now>
     3ee:	60 93 10 3e 	sts	0x3E10, r22	; 0x803e10 <time_of_last_pulse>
     3f2:	70 93 11 3e 	sts	0x3E11, r23	; 0x803e11 <time_of_last_pulse+0x1>
     3f6:	80 93 12 3e 	sts	0x3E12, r24	; 0x803e12 <time_of_last_pulse+0x2>
     3fa:	90 93 13 3e 	sts	0x3E13, r25	; 0x803e13 <time_of_last_pulse+0x3>
		}
	}
	return potential;
}
     3fe:	c7 01       	movw	r24, r14
     400:	b6 01       	movw	r22, r12
     402:	ff 90       	pop	r15
     404:	ef 90       	pop	r14
     406:	df 90       	pop	r13
     408:	cf 90       	pop	r12
     40a:	08 95       	ret

0000040c <tinyTime_counter_increment>:
If the Interrupt Service Routine is clocked by a crystal oscillator
it gives a very precise timer-counter.
*/
void tinyTime_counter_increment(void)
{
	time_counter++;
     40c:	80 91 15 3e 	lds	r24, 0x3E15	; 0x803e15 <time_counter>
     410:	90 91 16 3e 	lds	r25, 0x3E16	; 0x803e16 <time_counter+0x1>
     414:	a0 91 17 3e 	lds	r26, 0x3E17	; 0x803e17 <time_counter+0x2>
     418:	b0 91 18 3e 	lds	r27, 0x3E18	; 0x803e18 <time_counter+0x3>
     41c:	01 96       	adiw	r24, 0x01	; 1
     41e:	a1 1d       	adc	r26, r1
     420:	b1 1d       	adc	r27, r1
     422:	80 93 15 3e 	sts	0x3E15, r24	; 0x803e15 <time_counter>
     426:	90 93 16 3e 	sts	0x3E16, r25	; 0x803e16 <time_counter+0x1>
     42a:	a0 93 17 3e 	sts	0x3E17, r26	; 0x803e17 <time_counter+0x2>
     42e:	b0 93 18 3e 	sts	0x3E18, r27	; 0x803e18 <time_counter+0x3>
     432:	08 95       	ret

00000434 <tinyTime_now>:
/*
This function is callable by external libraries to give them the counted time so far.
*/
uint32_t tinyTime_now(void)
{
	return time_counter;
     434:	60 91 15 3e 	lds	r22, 0x3E15	; 0x803e15 <time_counter>
     438:	70 91 16 3e 	lds	r23, 0x3E16	; 0x803e16 <time_counter+0x1>
     43c:	80 91 17 3e 	lds	r24, 0x3E17	; 0x803e17 <time_counter+0x2>
     440:	90 91 18 3e 	lds	r25, 0x3E18	; 0x803e18 <time_counter+0x3>
     444:	08 95       	ret

00000446 <main>:
#include "tinyButton/tinyButton.h"
#include "settings.h"


int main(void)
{
     446:	cf 93       	push	r28
     448:	df 93       	push	r29
     44a:	00 d0       	rcall	.+0      	; 0x44c <main+0x6>
     44c:	cd b7       	in	r28, 0x3d	; 61
     44e:	de b7       	in	r29, 0x3e	; 62
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
     450:	21 de       	rcall	.-958    	; 0x94 <atmel_start_init>
	Setting this value will mean that the ADC (Analog to Digital Converter) will read 4.32v as 255, and 0v as 0.
	For some reason, instead of the reference voltage being 4.32v, it is 3.3v. 
	A plausible explanation is that the microchip does not up the voltage, so that if the microchip is only ever 
	supplied with 3.3v, it will output 3.3v as the max.
	*/
	VREF.CTRLB = VREF_ADC0REFSEL_4V34_gc;
     452:	80 e3       	ldi	r24, 0x30	; 48
     454:	80 93 a1 00 	sts	0x00A1, r24	; 0x8000a1 <__TEXT_REGION_LENGTH__+0x7000a1>
	
	
	uint32_t current_cycle_time = 1;
	uint32_t previous_cycle_time = 0;
	uint16_t time_passed = 0;
	uint16_t volatile cycles=0;
     458:	19 82       	std	Y+1, r1	; 0x01
     45a:	1a 82       	std	Y+2, r1	; 0x02
	
	tinyDendrite_set_neuron_type(NEURONTYPE);
     45c:	80 e0       	ldi	r24, 0x00	; 0
     45e:	4a d1       	rcall	.+660    	; 0x6f4 <tinyDendrite_set_neuron_type>
	*/
	VREF.CTRLB = VREF_ADC0REFSEL_4V34_gc;
	
	
	uint32_t current_cycle_time = 1;
	uint32_t previous_cycle_time = 0;
     460:	81 2c       	mov	r8, r1
     462:	91 2c       	mov	r9, r1
     464:	54 01       	movw	r10, r8
	
	tinyDendrite_set_neuron_type(NEURONTYPE);
	
	while (1)
	{
		if(tinyISR_getflag())
     466:	22 d3       	rcall	.+1604   	; 0xaac <tinyISR_getflag>
     468:	88 23       	and	r24, r24
     46a:	e9 f3       	breq	.-6      	; 0x466 <main+0x20>
		{
			current_cycle_time = tinyTime_now();
     46c:	e3 df       	rcall	.-58     	; 0x434 <tinyTime_now>
     46e:	6b 01       	movw	r12, r22
     470:	7c 01       	movw	r14, r24
			
			
			
			tinyButton_update();
     472:	b1 d0       	rcall	.+354    	; 0x5d6 <tinyButton_update>
			
			time_passed = current_cycle_time - previous_cycle_time;
			tinyPotential_update(time_passed);
     474:	b6 01       	movw	r22, r12
     476:	68 19       	sub	r22, r8
     478:	79 09       	sbc	r23, r9
     47a:	80 e0       	ldi	r24, 0x00	; 0
     47c:	90 e0       	ldi	r25, 0x00	; 0
     47e:	ab d4       	rcall	.+2390   	; 0xdd6 <__floatunsisf>
     480:	18 d3       	rcall	.+1584   	; 0xab2 <tinyPotential_update>
			
			
			
			previous_cycle_time = current_cycle_time;
			cycles++;
     482:	89 81       	ldd	r24, Y+1	; 0x01
     484:	9a 81       	ldd	r25, Y+2	; 0x02
     486:	01 96       	adiw	r24, 0x01	; 1
     488:	89 83       	std	Y+1, r24	; 0x01
     48a:	9a 83       	std	Y+2, r25	; 0x02
			tinyISR_setflag(false);
     48c:	80 e0       	ldi	r24, 0x00	; 0
     48e:	0b d3       	rcall	.+1558   	; 0xaa6 <tinyISR_setflag>
			time_passed = current_cycle_time - previous_cycle_time;
			tinyPotential_update(time_passed);
			
			
			
			previous_cycle_time = current_cycle_time;
     490:	46 01       	movw	r8, r12
     492:	57 01       	movw	r10, r14
     494:	e8 cf       	rjmp	.-48     	; 0x466 <main+0x20>

00000496 <set_LED_fire>:



//function to be called upon when firing flag has been raised.
void set_LED_fire(void)
{
     496:	cf 93       	push	r28
	fire_flash_time_counter = tinyTime_now();
     498:	cd df       	rcall	.-102    	; 0x434 <tinyTime_now>
     49a:	60 93 19 3e 	sts	0x3E19, r22	; 0x803e19 <fire_flash_time_counter>
     49e:	70 93 1a 3e 	sts	0x3E1A, r23	; 0x803e1a <fire_flash_time_counter+0x1>
     4a2:	80 93 1b 3e 	sts	0x3E1B, r24	; 0x803e1b <fire_flash_time_counter+0x2>
     4a6:	90 93 1c 3e 	sts	0x3E1C, r25	; 0x803e1c <fire_flash_time_counter+0x3>
     4aa:	c0 e0       	ldi	r28, 0x00	; 0
	for (int i = 0; i < NUMBER_OF_LEDS; i++)
	{
		tinyCCLRGB_setColor(i, MAX_BRIGHTNESS, MAX_BRIGHTNESS, MAX_BRIGHTNESS);//As per the specs, all LEDs should be blue while firing.
     4ac:	20 e3       	ldi	r18, 0x30	; 48
     4ae:	40 e3       	ldi	r20, 0x30	; 48
     4b0:	60 e3       	ldi	r22, 0x30	; 48
     4b2:	8c 2f       	mov	r24, r28
     4b4:	fb d0       	rcall	.+502    	; 0x6ac <tinyCCLRGB_setColor>
     4b6:	cf 5f       	subi	r28, 0xFF	; 255

//function to be called upon when firing flag has been raised.
void set_LED_fire(void)
{
	fire_flash_time_counter = tinyTime_now();
	for (int i = 0; i < NUMBER_OF_LEDS; i++)
     4b8:	c6 30       	cpi	r28, 0x06	; 6
     4ba:	c1 f7       	brne	.-16     	; 0x4ac <set_LED_fire+0x16>
	{
		tinyCCLRGB_setColor(i, MAX_BRIGHTNESS, MAX_BRIGHTNESS, MAX_BRIGHTNESS);//As per the specs, all LEDs should be blue while firing.
	}
}
     4bc:	cf 91       	pop	r28
     4be:	08 95       	ret

000004c0 <potential_to_RGB_update_LEDs>:



void potential_to_RGB_update_LEDs(double potential)
{
     4c0:	8f 92       	push	r8
     4c2:	9f 92       	push	r9
     4c4:	af 92       	push	r10
     4c6:	bf 92       	push	r11
     4c8:	cf 92       	push	r12
     4ca:	df 92       	push	r13
     4cc:	ef 92       	push	r14
     4ce:	ff 92       	push	r15
     4d0:	0f 93       	push	r16
     4d2:	1f 93       	push	r17
     4d4:	cf 93       	push	r28
     4d6:	6b 01       	movw	r12, r22
     4d8:	7c 01       	movw	r14, r24
	if ((tinyTime_now() - fire_flash_time_counter) < FIRE_FLASH_TIME)
     4da:	ac df       	rcall	.-168    	; 0x434 <tinyTime_now>
     4dc:	00 91 19 3e 	lds	r16, 0x3E19	; 0x803e19 <fire_flash_time_counter>
     4e0:	10 91 1a 3e 	lds	r17, 0x3E1A	; 0x803e1a <fire_flash_time_counter+0x1>
     4e4:	20 91 1b 3e 	lds	r18, 0x3E1B	; 0x803e1b <fire_flash_time_counter+0x2>
     4e8:	30 91 1c 3e 	lds	r19, 0x3E1C	; 0x803e1c <fire_flash_time_counter+0x3>
     4ec:	dc 01       	movw	r26, r24
     4ee:	cb 01       	movw	r24, r22
     4f0:	80 1b       	sub	r24, r16
     4f2:	91 0b       	sbc	r25, r17
     4f4:	a2 0b       	sbc	r26, r18
     4f6:	b3 0b       	sbc	r27, r19
     4f8:	84 36       	cpi	r24, 0x64	; 100
     4fa:	91 05       	cpc	r25, r1
     4fc:	a1 05       	cpc	r26, r1
     4fe:	b1 05       	cpc	r27, r1
     500:	50 f4       	brcc	.+20     	; 0x516 <potential_to_RGB_update_LEDs+0x56>
     502:	c0 e0       	ldi	r28, 0x00	; 0
	{
		for (int i = 0; i < NUMBER_OF_LEDS; i++)
		{
			tinyCCLRGB_setColor(i, MAX_BRIGHTNESS, MAX_BRIGHTNESS, MAX_BRIGHTNESS);
     504:	20 e3       	ldi	r18, 0x30	; 48
     506:	40 e3       	ldi	r20, 0x30	; 48
     508:	60 e3       	ldi	r22, 0x30	; 48
     50a:	8c 2f       	mov	r24, r28
     50c:	cf d0       	rcall	.+414    	; 0x6ac <tinyCCLRGB_setColor>
     50e:	cf 5f       	subi	r28, 0xFF	; 255

void potential_to_RGB_update_LEDs(double potential)
{
	if ((tinyTime_now() - fire_flash_time_counter) < FIRE_FLASH_TIME)
	{
		for (int i = 0; i < NUMBER_OF_LEDS; i++)
     510:	c6 30       	cpi	r28, 0x06	; 6
     512:	c1 f7       	brne	.-16     	; 0x504 <potential_to_RGB_update_LEDs+0x44>
     514:	53 c0       	rjmp	.+166    	; 0x5bc <potential_to_RGB_update_LEDs+0xfc>
     516:	c0 e0       	ldi	r28, 0x00	; 0
*/
static void potential_to_RGB_set_color(double potential)
{
	for (int i = 0; i < NUMBER_OF_LEDS; i++)
	{
		tinyCCLRGB_setColor(i, 0x0, 0x0, 0x0);//Clear all LED stored values on the MCU before writing again.
     518:	20 e0       	ldi	r18, 0x00	; 0
     51a:	40 e0       	ldi	r20, 0x00	; 0
     51c:	60 e0       	ldi	r22, 0x00	; 0
     51e:	8c 2f       	mov	r24, r28
     520:	c5 d0       	rcall	.+394    	; 0x6ac <tinyCCLRGB_setColor>
     522:	cf 5f       	subi	r28, 0xFF	; 255
When firing all lights turn blue for ~100ms, but this needs to be tested.
LEDs are numbered right way on top of PCB, but opposite way on bottom of PCB.
*/
static void potential_to_RGB_set_color(double potential)
{
	for (int i = 0; i < NUMBER_OF_LEDS; i++)
     524:	c6 30       	cpi	r28, 0x06	; 6
     526:	c1 f7       	brne	.-16     	; 0x518 <potential_to_RGB_update_LEDs+0x58>
	{
		tinyCCLRGB_setColor(i, 0x0, 0x0, 0x0);//Clear all LED stored values on the MCU before writing again.
	}
	double absolute_potential = abs(potential);//setting variable for absolute potential so it won't have to be calculated more than once.
     528:	c7 01       	movw	r24, r14
     52a:	b6 01       	movw	r22, r12
     52c:	1e d4       	rcall	.+2108   	; 0xd6a <__fixsfsi>
     52e:	9b 01       	movw	r18, r22
     530:	77 23       	and	r23, r23
     532:	24 f4       	brge	.+8      	; 0x53c <potential_to_RGB_update_LEDs+0x7c>
     534:	22 27       	eor	r18, r18
     536:	33 27       	eor	r19, r19
     538:	26 1b       	sub	r18, r22
     53a:	37 0b       	sbc	r19, r23
     53c:	b9 01       	movw	r22, r18
     53e:	33 0f       	add	r19, r19
     540:	88 0b       	sbc	r24, r24
     542:	99 0b       	sbc	r25, r25
     544:	4a d4       	rcall	.+2196   	; 0xdda <__floatsisf>
     546:	4b 01       	movw	r8, r22
     548:	5c 01       	movw	r10, r24
	if (absolute_potential < 1)//set the middle lights as white both top side and bottom side.
     54a:	20 e0       	ldi	r18, 0x00	; 0
     54c:	30 e0       	ldi	r19, 0x00	; 0
     54e:	40 e8       	ldi	r20, 0x80	; 128
     550:	5f e3       	ldi	r21, 0x3F	; 63
     552:	5a d3       	rcall	.+1716   	; 0xc08 <__cmpsf2>
     554:	88 23       	and	r24, r24
     556:	34 f4       	brge	.+12     	; 0x564 <potential_to_RGB_update_LEDs+0xa4>
	{
		tinyCCLRGB_setColor(2, MAX_BRIGHTNESS/3, MAX_BRIGHTNESS/3, MAX_BRIGHTNESS/3);
     558:	20 e1       	ldi	r18, 0x10	; 16
     55a:	40 e1       	ldi	r20, 0x10	; 16
     55c:	60 e1       	ldi	r22, 0x10	; 16
     55e:	82 e0       	ldi	r24, 0x02	; 2
     560:	a5 d0       	rcall	.+330    	; 0x6ac <tinyCCLRGB_setColor>
     562:	2c c0       	rjmp	.+88     	; 0x5bc <potential_to_RGB_update_LEDs+0xfc>
		//tinyCCLRGB_setColor(4, max_brightness/3, max_brightness/3, max_brightness/3);
	}
	else
	{
		uint8_t brightness_intensity = round((absolute_potential/25)*MAX_BRIGHTNESS);//brightness intensity for the LED that shows potential.
     564:	20 e0       	ldi	r18, 0x00	; 0
     566:	30 e0       	ldi	r19, 0x00	; 0
     568:	48 ec       	ldi	r20, 0xC8	; 200
     56a:	51 e4       	ldi	r21, 0x41	; 65
     56c:	c5 01       	movw	r24, r10
     56e:	b4 01       	movw	r22, r8
     570:	50 d3       	rcall	.+1696   	; 0xc12 <__divsf3>
     572:	20 e0       	ldi	r18, 0x00	; 0
     574:	30 e0       	ldi	r19, 0x00	; 0
     576:	40 e4       	ldi	r20, 0x40	; 64
     578:	52 e4       	ldi	r21, 0x42	; 66
     57a:	81 d5       	rcall	.+2818   	; 0x107e <__mulsf3>
     57c:	ed d5       	rcall	.+3034   	; 0x1158 <round>
     57e:	fc d3       	rcall	.+2040   	; 0xd78 <__fixunssfsi>
     580:	c6 2f       	mov	r28, r22
		if (potential < 0)
     582:	20 e0       	ldi	r18, 0x00	; 0
     584:	30 e0       	ldi	r19, 0x00	; 0
     586:	a9 01       	movw	r20, r18
     588:	c7 01       	movw	r24, r14
     58a:	b6 01       	movw	r22, r12
     58c:	3d d3       	rcall	.+1658   	; 0xc08 <__cmpsf2>
     58e:	88 23       	and	r24, r24
     590:	5c f4       	brge	.+22     	; 0x5a8 <potential_to_RGB_update_LEDs+0xe8>
		{
			tinyCCLRGB_setColor(0, brightness_intensity, 0x0, 0x0);
     592:	20 e0       	ldi	r18, 0x00	; 0
     594:	40 e0       	ldi	r20, 0x00	; 0
     596:	6c 2f       	mov	r22, r28
     598:	80 e0       	ldi	r24, 0x00	; 0
     59a:	88 d0       	rcall	.+272    	; 0x6ac <tinyCCLRGB_setColor>
			tinyCCLRGB_setColor(1, brightness_intensity, 0x0, 0x0);//sets lower LEDs red if potential is negative.
     59c:	20 e0       	ldi	r18, 0x00	; 0
     59e:	40 e0       	ldi	r20, 0x00	; 0
     5a0:	6c 2f       	mov	r22, r28
     5a2:	81 e0       	ldi	r24, 0x01	; 1
     5a4:	83 d0       	rcall	.+262    	; 0x6ac <tinyCCLRGB_setColor>
     5a6:	0a c0       	rjmp	.+20     	; 0x5bc <potential_to_RGB_update_LEDs+0xfc>
		} 
		else
		{
			tinyCCLRGB_setColor(3, 0x0, brightness_intensity, 0x0);//sets upper LEDs green if potential is positive.
     5a8:	20 e0       	ldi	r18, 0x00	; 0
     5aa:	4c 2f       	mov	r20, r28
     5ac:	60 e0       	ldi	r22, 0x00	; 0
     5ae:	83 e0       	ldi	r24, 0x03	; 3
     5b0:	7d d0       	rcall	.+250    	; 0x6ac <tinyCCLRGB_setColor>
			tinyCCLRGB_setColor(4, 0x0, brightness_intensity, 0x0);
     5b2:	20 e0       	ldi	r18, 0x00	; 0
     5b4:	4c 2f       	mov	r20, r28
     5b6:	60 e0       	ldi	r22, 0x00	; 0
     5b8:	84 e0       	ldi	r24, 0x04	; 4
     5ba:	78 d0       	rcall	.+240    	; 0x6ac <tinyCCLRGB_setColor>
	}
	else
	{
		potential_to_RGB_set_color(potential);
	}
	tinyCCLRGB_uploadColorsToLeds();
     5bc:	84 d0       	rcall	.+264    	; 0x6c6 <tinyCCLRGB_uploadColorsToLeds>
}
     5be:	cf 91       	pop	r28
     5c0:	1f 91       	pop	r17
     5c2:	0f 91       	pop	r16
     5c4:	ff 90       	pop	r15
     5c6:	ef 90       	pop	r14
     5c8:	df 90       	pop	r13
     5ca:	cf 90       	pop	r12
     5cc:	bf 90       	pop	r11
     5ce:	af 90       	pop	r10
     5d0:	9f 90       	pop	r9
     5d2:	8f 90       	pop	r8
     5d4:	08 95       	ret

000005d6 <tinyButton_update>:
/*
If the button has been let go, we change button_press to true. This only lasts one cycle, before it is set to false again.
If the button is held down for longer than PULSEMODE_BUTTON_PRESS_TIME, we toggle the pulse mode state.
*/
void tinyButton_update(void)
{
     5d6:	0f 93       	push	r16
     5d8:	1f 93       	push	r17
     5da:	cf 93       	push	r28
     5dc:	df 93       	push	r29
	button_press = false;
     5de:	10 92 21 3e 	sts	0x3E21, r1	; 0x803e21 <button_press>
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTC_get_pin_level(const uint8_t pin)
{
	return VPORTC.IN & (1 << pin);
     5e2:	8a b1       	in	r24, 0x0a	; 10
	_Bool button_is_pushed_down = !Button_get_level(); // The digital port will be read as low if the button is pushed down.
     5e4:	d1 e0       	ldi	r29, 0x01	; 1
     5e6:	c8 2f       	mov	r28, r24
     5e8:	c4 70       	andi	r28, 0x04	; 4
     5ea:	82 fd       	sbrc	r24, 2
     5ec:	d0 e0       	ldi	r29, 0x00	; 0

	if (button_is_pushed_down && !button_was_pushed_down)
     5ee:	c1 11       	cpse	r28, r1
     5f0:	2f c0       	rjmp	.+94     	; 0x650 <tinyButton_update+0x7a>
     5f2:	80 91 22 3e 	lds	r24, 0x3E22	; 0x803e22 <button_was_pushed_down>
     5f6:	81 11       	cpse	r24, r1
     5f8:	0d c0       	rjmp	.+26     	; 0x614 <tinyButton_update+0x3e>
	{
		tinyButton_start_time = tinyTime_now();
     5fa:	1c df       	rcall	.-456    	; 0x434 <tinyTime_now>
     5fc:	60 93 1d 3e 	sts	0x3E1D, r22	; 0x803e1d <tinyButton_start_time>
     600:	70 93 1e 3e 	sts	0x3E1E, r23	; 0x803e1e <tinyButton_start_time+0x1>
     604:	80 93 1f 3e 	sts	0x3E1F, r24	; 0x803e1f <tinyButton_start_time+0x2>
     608:	90 93 20 3e 	sts	0x3E20, r25	; 0x803e20 <tinyButton_start_time+0x3>
	}
	if (button_is_pushed_down && button_was_pushed_down)
     60c:	80 91 22 3e 	lds	r24, 0x3E22	; 0x803e22 <button_was_pushed_down>
     610:	88 23       	and	r24, r24
     612:	39 f1       	breq	.+78     	; 0x662 <tinyButton_update+0x8c>
	{
		if ((tinyTime_now() - tinyButton_start_time) > PULSEMODE_BUTTON_PRESS_TIME)
     614:	0f df       	rcall	.-482    	; 0x434 <tinyTime_now>
     616:	00 91 1d 3e 	lds	r16, 0x3E1D	; 0x803e1d <tinyButton_start_time>
     61a:	10 91 1e 3e 	lds	r17, 0x3E1E	; 0x803e1e <tinyButton_start_time+0x1>
     61e:	20 91 1f 3e 	lds	r18, 0x3E1F	; 0x803e1f <tinyButton_start_time+0x2>
     622:	30 91 20 3e 	lds	r19, 0x3E20	; 0x803e20 <tinyButton_start_time+0x3>
     626:	dc 01       	movw	r26, r24
     628:	cb 01       	movw	r24, r22
     62a:	80 1b       	sub	r24, r16
     62c:	91 0b       	sbc	r25, r17
     62e:	a2 0b       	sbc	r26, r18
     630:	b3 0b       	sbc	r27, r19
     632:	81 3d       	cpi	r24, 0xD1	; 209
     634:	97 40       	sbci	r25, 0x07	; 7
     636:	a1 05       	cpc	r26, r1
     638:	b1 05       	cpc	r27, r1
     63a:	50 f0       	brcs	.+20     	; 0x650 <tinyButton_update+0x7a>
		{
			tinyPulse_toggle_pulse_mode();
     63c:	ab de       	rcall	.-682    	; 0x394 <tinyPulse_toggle_pulse_mode>
			tinyButton_start_time = tinyTime_now();
     63e:	fa de       	rcall	.-524    	; 0x434 <tinyTime_now>
     640:	60 93 1d 3e 	sts	0x3E1D, r22	; 0x803e1d <tinyButton_start_time>
     644:	70 93 1e 3e 	sts	0x3E1E, r23	; 0x803e1e <tinyButton_start_time+0x1>
     648:	80 93 1f 3e 	sts	0x3E1F, r24	; 0x803e1f <tinyButton_start_time+0x2>
     64c:	90 93 20 3e 	sts	0x3E20, r25	; 0x803e20 <tinyButton_start_time+0x3>
		}
	}
	if (!button_is_pushed_down && button_was_pushed_down)
     650:	cc 23       	and	r28, r28
     652:	39 f0       	breq	.+14     	; 0x662 <tinyButton_update+0x8c>
     654:	80 91 22 3e 	lds	r24, 0x3E22	; 0x803e22 <button_was_pushed_down>
     658:	88 23       	and	r24, r24
     65a:	19 f0       	breq	.+6      	; 0x662 <tinyButton_update+0x8c>
	{
		button_press = true;
     65c:	81 e0       	ldi	r24, 0x01	; 1
     65e:	80 93 21 3e 	sts	0x3E21, r24	; 0x803e21 <button_press>
	}
	button_was_pushed_down = button_is_pushed_down;
     662:	d0 93 22 3e 	sts	0x3E22, r29	; 0x803e22 <button_was_pushed_down>
}
     666:	df 91       	pop	r29
     668:	cf 91       	pop	r28
     66a:	1f 91       	pop	r17
     66c:	0f 91       	pop	r16
     66e:	08 95       	ret

00000670 <tinyButton_update_potential>:

double tinyButton_update_potential(double potential){
	if(button_press){
     670:	20 91 21 3e 	lds	r18, 0x3E21	; 0x803e21 <button_press>
     674:	22 23       	and	r18, r18
     676:	29 f0       	breq	.+10     	; 0x682 <tinyButton_update_potential+0x12>
		potential += BUTTON_PRESS_REACTION;
     678:	20 e0       	ldi	r18, 0x00	; 0
     67a:	30 e0       	ldi	r19, 0x00	; 0
     67c:	40 ed       	ldi	r20, 0xD0	; 208
     67e:	51 e4       	ldi	r21, 0x41	; 65
     680:	57 d2       	rcall	.+1198   	; 0xb30 <__addsf3>
	}
	return potential;
}
     682:	08 95       	ret

00000684 <tinyCCLRGB_SPIWriteByte>:
Function used to send a byte over SPI, which in turn gets
translated to the bit-sequence required by the LEDs over the CCL.
*/
static void tinyCCLRGB_SPIWriteByte(uint8_t byte)
{
	SPI0.INTFLAGS = SPI0_INTFLAGS; // clear the write collision flag to allow writing
     684:	90 91 23 08 	lds	r25, 0x0823	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
     688:	90 93 23 08 	sts	0x0823, r25	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
	TCA0.SINGLE.CNT = 0; // reset TCA counter register to ensure the first rising edge of the PWM is predictable
     68c:	e0 e0       	ldi	r30, 0x00	; 0
     68e:	fa e0       	ldi	r31, 0x0A	; 10
     690:	10 a2       	std	Z+32, r1	; 0x20
     692:	11 a2       	std	Z+33, r1	; 0x21
	
	// start TCA
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 1 << TCA_SPLIT_ENABLE_bp;
     694:	91 e0       	ldi	r25, 0x01	; 1
     696:	90 83       	st	Z, r25
	SPI0_DATA = byte;
     698:	80 93 24 08 	sts	0x0824, r24	; 0x800824 <__TEXT_REGION_LENGTH__+0x700824>

	while((SPI0.INTFLAGS & SPI_RXCIE_bm) == 0){} // wait for transfer to complete
     69c:	e0 e2       	ldi	r30, 0x20	; 32
     69e:	f8 e0       	ldi	r31, 0x08	; 8
     6a0:	83 81       	ldd	r24, Z+3	; 0x03
     6a2:	88 23       	and	r24, r24
     6a4:	ec f7       	brge	.-6      	; 0x6a0 <tinyCCLRGB_SPIWriteByte+0x1c>
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 0 << TCA_SPLIT_ENABLE_bp; //Stop TCA
     6a6:	10 92 00 0a 	sts	0x0A00, r1	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
     6aa:	08 95       	ret

000006ac <tinyCCLRGB_setColor>:
/*
changes the values in the variables stored in the led-array.
*/
void tinyCCLRGB_setColor(uint8_t led, uint8_t red, uint8_t green, uint8_t blue) 
{
	tinyCCLRGB_colors[led].red = red;
     6ac:	90 e0       	ldi	r25, 0x00	; 0
     6ae:	fc 01       	movw	r30, r24
     6b0:	ee 0f       	add	r30, r30
     6b2:	ff 1f       	adc	r31, r31
     6b4:	8e 0f       	add	r24, r30
     6b6:	9f 1f       	adc	r25, r31
     6b8:	fc 01       	movw	r30, r24
     6ba:	ed 5d       	subi	r30, 0xDD	; 221
     6bc:	f1 4c       	sbci	r31, 0xC1	; 193
     6be:	60 83       	st	Z, r22
	tinyCCLRGB_colors[led].green = green;
     6c0:	41 83       	std	Z+1, r20	; 0x01
	tinyCCLRGB_colors[led].blue = blue;
     6c2:	22 83       	std	Z+2, r18	; 0x02
     6c4:	08 95       	ret

000006c6 <tinyCCLRGB_uploadColorsToLeds>:
/*
function to write the current LED-array on to the LEDs and
effectively update the values stored in the LEDs to the values stored in the MCU.
*/
void tinyCCLRGB_uploadColorsToLeds(void)
{
     6c6:	0f 93       	push	r16
     6c8:	1f 93       	push	r17
     6ca:	cf 93       	push	r28
     6cc:	df 93       	push	r29
     6ce:	c3 e2       	ldi	r28, 0x23	; 35
     6d0:	de e3       	ldi	r29, 0x3E	; 62
     6d2:	05 e3       	ldi	r16, 0x35	; 53
     6d4:	1e e3       	ldi	r17, 0x3E	; 62
	for (uint8_t i = 0; i < TINYCCLRGB_LEDCOUNT; i++)
	{
		//For some reason unknown to the writer the data-bus to the LEDs is serialized as GRB
		//which means the 24-bit data-bus will look like [Green[0:7], Red[0:7], Blue[0:7]]
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].green);
     6d6:	89 81       	ldd	r24, Y+1	; 0x01
     6d8:	d5 df       	rcall	.-86     	; 0x684 <tinyCCLRGB_SPIWriteByte>
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].red);
     6da:	88 81       	ld	r24, Y
     6dc:	d3 df       	rcall	.-90     	; 0x684 <tinyCCLRGB_SPIWriteByte>
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].blue);
     6de:	8a 81       	ldd	r24, Y+2	; 0x02
     6e0:	d1 df       	rcall	.-94     	; 0x684 <tinyCCLRGB_SPIWriteByte>
     6e2:	23 96       	adiw	r28, 0x03	; 3
function to write the current LED-array on to the LEDs and
effectively update the values stored in the LEDs to the values stored in the MCU.
*/
void tinyCCLRGB_uploadColorsToLeds(void)
{
	for (uint8_t i = 0; i < TINYCCLRGB_LEDCOUNT; i++)
     6e4:	c0 17       	cp	r28, r16
     6e6:	d1 07       	cpc	r29, r17
     6e8:	b1 f7       	brne	.-20     	; 0x6d6 <tinyCCLRGB_uploadColorsToLeds+0x10>
		//which means the 24-bit data-bus will look like [Green[0:7], Red[0:7], Blue[0:7]]
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].green);
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].red);
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].blue);
	}
}
     6ea:	df 91       	pop	r29
     6ec:	cf 91       	pop	r28
     6ee:	1f 91       	pop	r17
     6f0:	0f 91       	pop	r16
     6f2:	08 95       	ret

000006f4 <tinyDendrite_set_neuron_type>:


//sets neuron type
void tinyDendrite_set_neuron_type(enum NeuronType neuron_type)
{
	this_neurons_type = neuron_type;
     6f4:	91 e0       	ldi	r25, 0x01	; 1
     6f6:	81 11       	cpse	r24, r1
     6f8:	01 c0       	rjmp	.+2      	; 0x6fc <tinyDendrite_set_neuron_type+0x8>
     6fa:	90 e0       	ldi	r25, 0x00	; 0
     6fc:	90 93 39 3e 	sts	0x3E39, r25	; 0x803e39 <this_neurons_type>
     700:	08 95       	ret

00000702 <tinyAxon_remove_pulse>:
/*
solution to remove future firing if a inhibitory signal is received
shortly after a excitatory signal.
*/
bool tinyAxon_remove_pulse(void)
{
     702:	cf 92       	push	r12
     704:	df 92       	push	r13
     706:	ef 92       	push	r14
     708:	ff 92       	push	r15
	// We want to remove the pulse last added to the queue
	// We also want to return a bool indicating whether or not a pulse actually was removed
	uint32_t now = tinyTime_now();
     70a:	94 de       	rcall	.-728    	; 0x434 <tinyTime_now>
     70c:	6b 01       	movw	r12, r22
     70e:	7c 01       	movw	r14, r24
	uint32_t pulse_time = dequeue_top(&pulse_queue);
     710:	86 e3       	ldi	r24, 0x36	; 54
     712:	9e e3       	ldi	r25, 0x3E	; 62
     714:	e1 dd       	rcall	.-1086   	; 0x2d8 <dequeue_top>
	if(pulse_time == 0){ // Here, 0 is regarded as an error
     716:	61 15       	cp	r22, r1
     718:	71 05       	cpc	r23, r1
     71a:	81 05       	cpc	r24, r1
     71c:	91 05       	cpc	r25, r1
     71e:	c1 f0       	breq	.+48     	; 0x750 <tinyAxon_remove_pulse+0x4e>
		return false;
	}
	
	// Now we want to check if the pulse is too far away to be affected by the low potential, or close enough that we decide to remove it
	// (When we say that the pulse is too far away, it refers to the biological process of how the potential spreads from dendrites to axon)
	else if((now + UNDO_PERIOD) < pulse_time){
     720:	2c e3       	ldi	r18, 0x3C	; 60
     722:	c2 0e       	add	r12, r18
     724:	d1 1c       	adc	r13, r1
     726:	e1 1c       	adc	r14, r1
     728:	f1 1c       	adc	r15, r1
     72a:	c6 16       	cp	r12, r22
     72c:	d7 06       	cpc	r13, r23
     72e:	e8 06       	cpc	r14, r24
     730:	f9 06       	cpc	r15, r25
     732:	38 f4       	brcc	.+14     	; 0x742 <tinyAxon_remove_pulse+0x40>
		// We decided to remove the pulse
		pulses_in_queue--;
     734:	80 91 38 3e 	lds	r24, 0x3E38	; 0x803e38 <pulses_in_queue>
     738:	81 50       	subi	r24, 0x01	; 1
     73a:	80 93 38 3e 	sts	0x3E38, r24	; 0x803e38 <pulses_in_queue>
		return true;
     73e:	81 e0       	ldi	r24, 0x01	; 1
     740:	08 c0       	rjmp	.+16     	; 0x752 <tinyAxon_remove_pulse+0x50>
	}
	// Here we have found that there is a pulse queued, but it is old enough to let pass anyway, so now we need to put it back into the queue
	else{
		enqueue(&pulse_queue, pulse_time);
     742:	ab 01       	movw	r20, r22
     744:	bc 01       	movw	r22, r24
     746:	86 e3       	ldi	r24, 0x36	; 54
     748:	9e e3       	ldi	r25, 0x3E	; 62
     74a:	6a dd       	rcall	.-1324   	; 0x220 <enqueue>
		return false;
     74c:	80 e0       	ldi	r24, 0x00	; 0
     74e:	01 c0       	rjmp	.+2      	; 0x752 <tinyAxon_remove_pulse+0x50>
	// We also want to return a bool indicating whether or not a pulse actually was removed
	uint32_t now = tinyTime_now();
	uint32_t pulse_time = dequeue_top(&pulse_queue);
	if(pulse_time == 0){ // Here, 0 is regarded as an error
		//There was no pulse to remove
		return false;
     750:	80 e0       	ldi	r24, 0x00	; 0
	// Here we have found that there is a pulse queued, but it is old enough to let pass anyway, so now we need to put it back into the queue
	else{
		enqueue(&pulse_queue, pulse_time);
		return false;
	}
}
     752:	ff 90       	pop	r15
     754:	ef 90       	pop	r14
     756:	df 90       	pop	r13
     758:	cf 90       	pop	r12
     75a:	08 95       	ret

0000075c <tinyAxon_update_potential>:
/*
Decides whether or not the axon should fire
If the axon does fire, the potential is reduced
*/
double tinyAxon_update_potential(double potential)
{
     75c:	4f 92       	push	r4
     75e:	5f 92       	push	r5
     760:	6f 92       	push	r6
     762:	7f 92       	push	r7
     764:	8f 92       	push	r8
     766:	9f 92       	push	r9
     768:	af 92       	push	r10
     76a:	bf 92       	push	r11
     76c:	cf 92       	push	r12
     76e:	df 92       	push	r13
     770:	ef 92       	push	r14
     772:	ff 92       	push	r15
     774:	cf 93       	push	r28
     776:	df 93       	push	r29
     778:	6b 01       	movw	r12, r22
     77a:	7c 01       	movw	r14, r24
	int pulse_nr = 0;
	uint32_t now = tinyTime_now();
     77c:	5b de       	rcall	.-842    	; 0x434 <tinyTime_now>
     77e:	2b 01       	movw	r4, r22
     780:	3c 01       	movw	r6, r24
	
	//While the neuron has enough potential to fire, we want to fire more
	while (potential > THRESHOLD_POTENTIAL)
     782:	20 e0       	ldi	r18, 0x00	; 0
     784:	30 e0       	ldi	r19, 0x00	; 0
     786:	48 ec       	ldi	r20, 0xC8	; 200
     788:	51 e4       	ldi	r21, 0x41	; 65
     78a:	c7 01       	movw	r24, r14
     78c:	b6 01       	movw	r22, r12
     78e:	fc d3       	rcall	.+2040   	; 0xf88 <__gesf2>
     790:	18 16       	cp	r1, r24
     792:	5c f5       	brge	.+86     	; 0x7ea <tinyAxon_update_potential+0x8e>
     794:	c0 e0       	ldi	r28, 0x00	; 0
     796:	d0 e0       	ldi	r29, 0x00	; 0
/*
Adds an element to the queue
*/
static void tinyAxon_enqueue_pulse(uint32_t new_pulse)
{
	enqueue(&pulse_queue, new_pulse);
     798:	53 01       	movw	r10, r6
     79a:	42 01       	movw	r8, r4
     79c:	84 e6       	ldi	r24, 0x64	; 100
     79e:	88 0e       	add	r8, r24
     7a0:	91 1c       	adc	r9, r1
     7a2:	a1 1c       	adc	r10, r1
     7a4:	b1 1c       	adc	r11, r1
     7a6:	ae 01       	movw	r20, r28
     7a8:	0d 2e       	mov	r0, r29
     7aa:	00 0c       	add	r0, r0
     7ac:	66 0b       	sbc	r22, r22
     7ae:	77 0b       	sbc	r23, r23
     7b0:	48 0d       	add	r20, r8
     7b2:	59 1d       	adc	r21, r9
     7b4:	6a 1d       	adc	r22, r10
     7b6:	7b 1d       	adc	r23, r11
     7b8:	86 e3       	ldi	r24, 0x36	; 54
     7ba:	9e e3       	ldi	r25, 0x3E	; 62
     7bc:	31 dd       	rcall	.-1438   	; 0x220 <enqueue>
	pulses_in_queue++;
     7be:	80 91 38 3e 	lds	r24, 0x3E38	; 0x803e38 <pulses_in_queue>
     7c2:	8f 5f       	subi	r24, 0xFF	; 255
     7c4:	80 93 38 3e 	sts	0x3E38, r24	; 0x803e38 <pulses_in_queue>
	{
		tinyAxon_enqueue_pulse(now + TRAVLE_DELAY + FIRE_DELAY*pulse_nr);
		pulse_nr++;
		
		// I want to test reducing the potential by -30 instead of -25 to simulate the hyperpolarization
		potential += POSTFIRE_POTENTIAL_REACTION; // This is usually defined as a negative value, don't be confused by the +=
     7c8:	20 e0       	ldi	r18, 0x00	; 0
     7ca:	30 e0       	ldi	r19, 0x00	; 0
     7cc:	40 ef       	ldi	r20, 0xF0	; 240
     7ce:	51 e4       	ldi	r21, 0x41	; 65
     7d0:	c7 01       	movw	r24, r14
     7d2:	b6 01       	movw	r22, r12
     7d4:	ac d1       	rcall	.+856    	; 0xb2e <__subsf3>
     7d6:	6b 01       	movw	r12, r22
     7d8:	7c 01       	movw	r14, r24
     7da:	e2 96       	adiw	r28, 0x32	; 50
{
	int pulse_nr = 0;
	uint32_t now = tinyTime_now();
	
	//While the neuron has enough potential to fire, we want to fire more
	while (potential > THRESHOLD_POTENTIAL)
     7dc:	20 e0       	ldi	r18, 0x00	; 0
     7de:	30 e0       	ldi	r19, 0x00	; 0
     7e0:	48 ec       	ldi	r20, 0xC8	; 200
     7e2:	51 e4       	ldi	r21, 0x41	; 65
     7e4:	d1 d3       	rcall	.+1954   	; 0xf88 <__gesf2>
     7e6:	18 16       	cp	r1, r24
     7e8:	f4 f2       	brlt	.-68     	; 0x7a6 <tinyAxon_update_potential+0x4a>
		// I want to test reducing the potential by -30 instead of -25 to simulate the hyperpolarization
		potential += POSTFIRE_POTENTIAL_REACTION; // This is usually defined as a negative value, don't be confused by the +=
	}
	
	// If the neuron has a very low potential, we want to remove a pulse from the queue (if there is one)
	if(potential < -THRESHOLD_POTENTIAL && pulses_in_queue > 0) // Perhaps this should be a separate variable? For now, we will just simply use -THRESHOLD_POTENTIAL
     7ea:	20 e0       	ldi	r18, 0x00	; 0
     7ec:	30 e0       	ldi	r19, 0x00	; 0
     7ee:	48 ec       	ldi	r20, 0xC8	; 200
     7f0:	51 ec       	ldi	r21, 0xC1	; 193
     7f2:	c7 01       	movw	r24, r14
     7f4:	b6 01       	movw	r22, r12
     7f6:	08 d2       	rcall	.+1040   	; 0xc08 <__cmpsf2>
     7f8:	88 23       	and	r24, r24
     7fa:	84 f4       	brge	.+32     	; 0x81c <tinyAxon_update_potential+0xc0>
     7fc:	80 91 38 3e 	lds	r24, 0x3E38	; 0x803e38 <pulses_in_queue>
     800:	88 23       	and	r24, r24
     802:	79 f1       	breq	.+94     	; 0x862 <tinyAxon_update_potential+0x106>
	{
		// The neurons potential is low enough to attempt to remove a queued fire (Fire less)
		if(tinyAxon_remove_pulse())
     804:	7e df       	rcall	.-260    	; 0x702 <tinyAxon_remove_pulse>
     806:	88 23       	and	r24, r24
     808:	49 f0       	breq	.+18     	; 0x81c <tinyAxon_update_potential+0xc0>
		{
			// The potential has evened out a bit
			potential += THRESHOLD_POTENTIAL;
     80a:	20 e0       	ldi	r18, 0x00	; 0
     80c:	30 e0       	ldi	r19, 0x00	; 0
     80e:	48 ec       	ldi	r20, 0xC8	; 200
     810:	51 e4       	ldi	r21, 0x41	; 65
     812:	c7 01       	movw	r24, r14
     814:	b6 01       	movw	r22, r12
     816:	8c d1       	rcall	.+792    	; 0xb30 <__addsf3>
     818:	6b 01       	movw	r12, r22
     81a:	7c 01       	movw	r14, r24
		}
	}
	
	// If there are pulses in the queue, and the pulse has been scheduled to fire
	if ((pulses_in_queue > 0) && (next_pulse <= now))
     81c:	80 91 38 3e 	lds	r24, 0x3E38	; 0x803e38 <pulses_in_queue>
     820:	88 23       	and	r24, r24
     822:	f9 f0       	breq	.+62     	; 0x862 <tinyAxon_update_potential+0x106>
     824:	40 91 55 3e 	lds	r20, 0x3E55	; 0x803e55 <next_pulse>
     828:	50 91 56 3e 	lds	r21, 0x3E56	; 0x803e56 <next_pulse+0x1>
     82c:	60 91 57 3e 	lds	r22, 0x3E57	; 0x803e57 <next_pulse+0x2>
     830:	70 91 58 3e 	lds	r23, 0x3E58	; 0x803e58 <next_pulse+0x3>
     834:	44 16       	cp	r4, r20
     836:	55 06       	cpc	r5, r21
     838:	66 06       	cpc	r6, r22
     83a:	77 06       	cpc	r7, r23
     83c:	90 f0       	brcs	.+36     	; 0x862 <tinyAxon_update_potential+0x106>
Function to set firing.
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
     83e:	91 e0       	ldi	r25, 0x01	; 1
     840:	90 93 3a 3e 	sts	0x3E3A, r25	; 0x803e3a <tinyAxon_should_fire>
	pulses_in_queue--;
     844:	81 50       	subi	r24, 0x01	; 1
     846:	80 93 38 3e 	sts	0x3E38, r24	; 0x803e38 <pulses_in_queue>
	next_pulse = dequeue(&pulse_queue);
     84a:	86 e3       	ldi	r24, 0x36	; 54
     84c:	9e e3       	ldi	r25, 0x3E	; 62
     84e:	08 dd       	rcall	.-1520   	; 0x260 <dequeue>
     850:	60 93 55 3e 	sts	0x3E55, r22	; 0x803e55 <next_pulse>
     854:	70 93 56 3e 	sts	0x3E56, r23	; 0x803e56 <next_pulse+0x1>
     858:	80 93 57 3e 	sts	0x3E57, r24	; 0x803e57 <next_pulse+0x2>
     85c:	90 93 58 3e 	sts	0x3E58, r25	; 0x803e58 <next_pulse+0x3>
	// If there are pulses in the queue, and the pulse has been scheduled to fire
	if ((pulses_in_queue > 0) && (next_pulse <= now))
	{
		// We fire the axon
		tinyAxon_fire_pulse();
		set_LED_fire();
     860:	1a de       	rcall	.-972    	; 0x496 <set_LED_fire>
The function should set the DAC to fire for two
update cycles once the pulse flag is set high.
*/
static void tinyAxon_update_pulse_transmitter(void)
{
	if (tinyAxon_should_fire)
     862:	80 91 3a 3e 	lds	r24, 0x3E3A	; 0x803e3a <tinyAxon_should_fire>
     866:	88 23       	and	r24, r24
     868:	b9 f0       	breq	.+46     	; 0x898 <tinyAxon_update_potential+0x13c>
	{
		tinyAxon_should_fire = false;
     86a:	10 92 3a 3e 	sts	0x3E3A, r1	; 0x803e3a <tinyAxon_should_fire>
		tinyAxon_has_fired = true;
     86e:	81 e0       	ldi	r24, 0x01	; 1
     870:	80 93 3b 3e 	sts	0x3E3B, r24	; 0x803e3b <tinyAxon_has_fired>
Pulse send function.
sends a pulse dependent on the neurons type.
*/
static void tinyAxon_start_sending_pulse()
{
	if (this_neurons_type == EXCITATORY_NEURON)
     874:	80 91 39 3e 	lds	r24, 0x3E39	; 0x803e39 <this_neurons_type>
     878:	81 11       	cpse	r24, r1
     87a:	07 c0       	rjmp	.+14     	; 0x88a <tinyAxon_update_potential+0x12e>
	{
		DAC_set_output(EXCITATORY_NEURON_OUTPUT);
     87c:	87 ed       	ldi	r24, 0xD7	; 215
     87e:	90 e0       	ldi	r25, 0x00	; 0
     880:	49 dc       	rcall	.-1902   	; 0x114 <DAC_set_output>
		axonOutputValue=EXCITATORY_NEURON_OUTPUT;
     882:	87 ed       	ldi	r24, 0xD7	; 215
     884:	80 93 35 3e 	sts	0x3E35, r24	; 0x803e35 <axonOutputValue>
     888:	13 c0       	rjmp	.+38     	; 0x8b0 <tinyAxon_update_potential+0x154>
	}
	else if(this_neurons_type == INHIBITORY_NEURON)
	{
		DAC_set_output(INHIBITORY_NEURON_OUTPUT);
     88a:	84 e7       	ldi	r24, 0x74	; 116
     88c:	90 e0       	ldi	r25, 0x00	; 0
     88e:	42 dc       	rcall	.-1916   	; 0x114 <DAC_set_output>
		axonOutputValue=INHIBITORY_NEURON_OUTPUT;
     890:	84 e7       	ldi	r24, 0x74	; 116
     892:	80 93 35 3e 	sts	0x3E35, r24	; 0x803e35 <axonOutputValue>
     896:	0c c0       	rjmp	.+24     	; 0x8b0 <tinyAxon_update_potential+0x154>
		tinyAxon_should_fire = false;
		tinyAxon_has_fired = true;
		
		tinyAxon_start_sending_pulse();
	}
	else if (tinyAxon_has_fired)
     898:	80 91 3b 3e 	lds	r24, 0x3E3B	; 0x803e3b <tinyAxon_has_fired>
     89c:	88 23       	and	r24, r24
     89e:	19 f0       	breq	.+6      	; 0x8a6 <tinyAxon_update_potential+0x14a>
	{
		tinyAxon_has_fired = false;
     8a0:	10 92 3b 3e 	sts	0x3E3B, r1	; 0x803e3b <tinyAxon_has_fired>
     8a4:	05 c0       	rjmp	.+10     	; 0x8b0 <tinyAxon_update_potential+0x154>
}

static void tinyAxon_stop_sending_pulse()
{
	
	DAC_set_output(NO_SIGNAL_OUTPUT);
     8a6:	80 e0       	ldi	r24, 0x00	; 0
     8a8:	90 e0       	ldi	r25, 0x00	; 0
     8aa:	34 dc       	rcall	.-1944   	; 0x114 <DAC_set_output>
	axonOutputValue=NO_SIGNAL_OUTPUT;
     8ac:	10 92 35 3e 	sts	0x3E35, r1	; 0x803e35 <axonOutputValue>
	}
	
	// Here we set the actual output of the DAC (Digital to Analog Converter)
	tinyAxon_update_pulse_transmitter();
	return potential;
}
     8b0:	c7 01       	movw	r24, r14
     8b2:	b6 01       	movw	r22, r12
     8b4:	df 91       	pop	r29
     8b6:	cf 91       	pop	r28
     8b8:	ff 90       	pop	r15
     8ba:	ef 90       	pop	r14
     8bc:	df 90       	pop	r13
     8be:	cf 90       	pop	r12
     8c0:	bf 90       	pop	r11
     8c2:	af 90       	pop	r10
     8c4:	9f 90       	pop	r9
     8c6:	8f 90       	pop	r8
     8c8:	7f 90       	pop	r7
     8ca:	6f 90       	pop	r6
     8cc:	5f 90       	pop	r5
     8ce:	4f 90       	pop	r4
     8d0:	08 95       	ret

000008d2 <tinyDendrite_get_potential>:
/*
This is the master function of the module that is callable from
outside. It uses the previously declared functions to return the potential.
*/
int16_t tinyDendrite_get_potential()
{
     8d2:	6f 92       	push	r6
     8d4:	7f 92       	push	r7
     8d6:	9f 92       	push	r9
     8d8:	af 92       	push	r10
     8da:	bf 92       	push	r11
     8dc:	cf 92       	push	r12
     8de:	df 92       	push	r13
     8e0:	ef 92       	push	r14
     8e2:	ff 92       	push	r15
     8e4:	0f 93       	push	r16
     8e6:	1f 93       	push	r17
     8e8:	cf 93       	push	r28
     8ea:	df 93       	push	r29
     8ec:	0f 2e       	mov	r0, r31
     8ee:	f8 e0       	ldi	r31, 0x08	; 8
     8f0:	ef 2e       	mov	r14, r31
     8f2:	fe e3       	ldi	r31, 0x3E	; 62
     8f4:	ff 2e       	mov	r15, r31
     8f6:	f0 2d       	mov	r31, r0
     8f8:	06 e4       	ldi	r16, 0x46	; 70
     8fa:	1e e3       	ldi	r17, 0x3E	; 62
     8fc:	0f 2e       	mov	r0, r31
     8fe:	f0 e5       	ldi	r31, 0x50	; 80
     900:	cf 2e       	mov	r12, r31
     902:	fe e3       	ldi	r31, 0x3E	; 62
     904:	df 2e       	mov	r13, r31
     906:	f0 2d       	mov	r31, r0
     908:	e8 01       	movw	r28, r16
*/
static void tinyDendrite_read_signals(void)
{
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_values[i] = ADC_get_conversion(dendrite_ports[i]);
     90a:	f7 01       	movw	r30, r14
     90c:	81 91       	ld	r24, Z+
     90e:	7f 01       	movw	r14, r30
     910:	cc db       	rcall	.-2152   	; 0xaa <ADC_get_conversion>
     912:	89 93       	st	Y+, r24
     914:	99 93       	st	Y+, r25
/*
This function reads the voltage at the dendrite inputs with the ADC
*/
static void tinyDendrite_read_signals(void)
{
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
     916:	cc 15       	cp	r28, r12
     918:	dd 05       	cpc	r29, r13
     91a:	b9 f7       	brne	.-18     	; 0x90a <tinyDendrite_get_potential+0x38>
     91c:	a1 e4       	ldi	r26, 0x41	; 65
     91e:	be e3       	ldi	r27, 0x3E	; 62
     920:	6c e3       	ldi	r22, 0x3C	; 60
     922:	7e e3       	ldi	r23, 0x3E	; 62
     924:	46 e4       	ldi	r20, 0x46	; 70
     926:	5e e3       	ldi	r21, 0x3E	; 62
     928:	fd 01       	movw	r30, r26
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     92a:	99 24       	eor	r9, r9
     92c:	93 94       	inc	r9
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
		}
		else if (tinyDendrite_values[i] > HIGH_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
     92e:	0f 2e       	mov	r0, r31
     930:	f3 e0       	ldi	r31, 0x03	; 3
     932:	af 2e       	mov	r10, r31
     934:	f0 2d       	mov	r31, r0
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     936:	68 94       	set
     938:	bb 24       	eor	r11, r11
     93a:	b1 f8       	bld	r11, 1
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     93c:	68 94       	set
     93e:	cc 24       	eor	r12, r12
     940:	c2 f8       	bld	r12, 2
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     942:	0f 2e       	mov	r0, r31
     944:	f6 e0       	ldi	r31, 0x06	; 6
     946:	df 2e       	mov	r13, r31
     948:	f0 2d       	mov	r31, r0
		{
			tinyDendrite_current_signals[i] = CHARGING;
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     94a:	0f 2e       	mov	r0, r31
     94c:	f5 e0       	ldi	r31, 0x05	; 5
     94e:	ef 2e       	mov	r14, r31
     950:	f0 2d       	mov	r31, r0
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = CHARGING;
     952:	0f 2e       	mov	r0, r31
     954:	f7 e0       	ldi	r31, 0x07	; 7
     956:	ff 2e       	mov	r15, r31
     958:	f0 2d       	mov	r31, r0
     95a:	3f 01       	movw	r6, r30
*/
static void tinyDendrite_update_signals(void)
{
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
     95c:	80 81       	ld	r24, Z
     95e:	eb 01       	movw	r28, r22
     960:	89 93       	st	Y+, r24
     962:	be 01       	movw	r22, r28
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
     964:	e8 01       	movw	r28, r16
     966:	29 91       	ld	r18, Y+
     968:	39 91       	ld	r19, Y+
     96a:	8e 01       	movw	r16, r28
     96c:	29 3e       	cpi	r18, 0xE9	; 233
     96e:	31 05       	cpc	r19, r1
     970:	10 f0       	brcs	.+4      	; 0x976 <tinyDendrite_get_potential+0xa4>
		{
			tinyDendrite_current_signals[i] = CHARGING;
     972:	f0 82       	st	Z, r15
     974:	1f c0       	rjmp	.+62     	; 0x9b4 <tinyDendrite_get_potential+0xe2>
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
     976:	28 3c       	cpi	r18, 0xC8	; 200
     978:	31 05       	cpc	r19, r1
     97a:	10 f0       	brcs	.+4      	; 0x980 <tinyDendrite_get_potential+0xae>
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     97c:	e0 82       	st	Z, r14
     97e:	1a c0       	rjmp	.+52     	; 0x9b4 <tinyDendrite_get_potential+0xe2>
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
     980:	27 3a       	cpi	r18, 0xA7	; 167
     982:	31 05       	cpc	r19, r1
     984:	10 f0       	brcs	.+4      	; 0x98a <tinyDendrite_get_potential+0xb8>
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     986:	d0 82       	st	Z, r13
     988:	15 c0       	rjmp	.+42     	; 0x9b4 <tinyDendrite_get_potential+0xe2>
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
     98a:	25 38       	cpi	r18, 0x85	; 133
     98c:	31 05       	cpc	r19, r1
     98e:	10 f0       	brcs	.+4      	; 0x994 <tinyDendrite_get_potential+0xc2>
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     990:	c0 82       	st	Z, r12
     992:	10 c0       	rjmp	.+32     	; 0x9b4 <tinyDendrite_get_potential+0xe2>
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
     994:	24 36       	cpi	r18, 0x64	; 100
     996:	31 05       	cpc	r19, r1
     998:	10 f0       	brcs	.+4      	; 0x99e <tinyDendrite_get_potential+0xcc>
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     99a:	b0 82       	st	Z, r11
     99c:	0b c0       	rjmp	.+22     	; 0x9b4 <tinyDendrite_get_potential+0xe2>
		}
		else if (tinyDendrite_values[i] > HIGH_INHIB_THRESHOLD)
     99e:	23 34       	cpi	r18, 0x43	; 67
     9a0:	31 05       	cpc	r19, r1
     9a2:	10 f0       	brcs	.+4      	; 0x9a8 <tinyDendrite_get_potential+0xd6>
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
     9a4:	a0 82       	st	Z, r10
     9a6:	06 c0       	rjmp	.+12     	; 0x9b4 <tinyDendrite_get_potential+0xe2>
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
     9a8:	22 32       	cpi	r18, 0x22	; 34
     9aa:	31 05       	cpc	r19, r1
     9ac:	10 f0       	brcs	.+4      	; 0x9b2 <tinyDendrite_get_potential+0xe0>
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     9ae:	90 82       	st	Z, r9
     9b0:	01 c0       	rjmp	.+2      	; 0x9b4 <tinyDendrite_get_potential+0xe2>
		}
		else
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     9b2:	10 82       	st	Z, r1
		}
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
     9b4:	e3 01       	movw	r28, r6
     9b6:	98 81       	ld	r25, Y
     9b8:	89 13       	cpse	r24, r25
     9ba:	01 c0       	rjmp	.+2      	; 0x9be <tinyDendrite_get_potential+0xec>
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     9bc:	18 82       	st	Y, r1
     9be:	31 96       	adiw	r30, 0x01	; 1
/*
This function converts the 8 bit value from the ADC into one of the signal types defined in DendriteSignal
*/
static void tinyDendrite_update_signals(void)
{
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
     9c0:	e4 17       	cp	r30, r20
     9c2:	f5 07       	cpc	r31, r21
     9c4:	51 f6       	brne	.-108    	; 0x95a <tinyDendrite_get_potential+0x88>
     9c6:	20 e0       	ldi	r18, 0x00	; 0
     9c8:	30 e0       	ldi	r19, 0x00	; 0
	tinyDendrite_update_signals();
	
	int16_t return_potential_val = 0;
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		switch(tinyDendrite_current_signals[i])
     9ca:	9d 91       	ld	r25, X+
     9cc:	93 30       	cpi	r25, 0x03	; 3
     9ce:	a1 f0       	breq	.+40     	; 0x9f8 <tinyDendrite_get_potential+0x126>
     9d0:	28 f4       	brcc	.+10     	; 0x9dc <tinyDendrite_get_potential+0x10a>
     9d2:	91 30       	cpi	r25, 0x01	; 1
     9d4:	b9 f0       	breq	.+46     	; 0xa04 <tinyDendrite_get_potential+0x132>
     9d6:	92 30       	cpi	r25, 0x02	; 2
     9d8:	91 f0       	breq	.+36     	; 0x9fe <tinyDendrite_get_potential+0x12c>
     9da:	16 c0       	rjmp	.+44     	; 0xa08 <tinyDendrite_get_potential+0x136>
     9dc:	95 30       	cpi	r25, 0x05	; 5
     9de:	31 f0       	breq	.+12     	; 0x9ec <tinyDendrite_get_potential+0x11a>
     9e0:	40 f0       	brcs	.+16     	; 0x9f2 <tinyDendrite_get_potential+0x120>
     9e2:	96 30       	cpi	r25, 0x06	; 6
     9e4:	89 f4       	brne	.+34     	; 0xa08 <tinyDendrite_get_potential+0x136>
		{
			case NO_SIGNAL:
				return_potential_val += NO_SIGNAL_REACTION;
				break;
			case HIGH_EXCITE:
				return_potential_val += HIGH_EXCITE_REACTION;
     9e6:	2c 5c       	subi	r18, 0xCC	; 204
     9e8:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     9ea:	0e c0       	rjmp	.+28     	; 0xa08 <tinyDendrite_get_potential+0x136>
			case NORMAL_EXCITE:
				return_potential_val += NORMAL_EXCITE_REACTION;
     9ec:	26 5e       	subi	r18, 0xE6	; 230
     9ee:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     9f0:	0b c0       	rjmp	.+22     	; 0xa08 <tinyDendrite_get_potential+0x136>
			case LOW_EXCITE:
				return_potential_val += LOW_EXCITE_REACTION;
     9f2:	2c 5e       	subi	r18, 0xEC	; 236
     9f4:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     9f6:	08 c0       	rjmp	.+16     	; 0xa08 <tinyDendrite_get_potential+0x136>
			case HIGH_INHIB:
				return_potential_val += HIGH_INHIB_REACTION;
     9f8:	22 53       	subi	r18, 0x32	; 50
     9fa:	31 09       	sbc	r19, r1
				break;
     9fc:	05 c0       	rjmp	.+10     	; 0xa08 <tinyDendrite_get_potential+0x136>
			case NORMAL_INHIB:
				return_potential_val += NORMAL_INHIB_REACTION;
     9fe:	2a 51       	subi	r18, 0x1A	; 26
     a00:	31 09       	sbc	r19, r1
				break;
     a02:	02 c0       	rjmp	.+4      	; 0xa08 <tinyDendrite_get_potential+0x136>
			case LOW_INHIB:
				return_potential_val += LOW_INHIB_REACTION;
     a04:	24 51       	subi	r18, 0x14	; 20
     a06:	31 09       	sbc	r19, r1
	tinyDendrite_read_signals();
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
	
	int16_t return_potential_val = 0;
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
     a08:	a4 17       	cp	r26, r20
     a0a:	b5 07       	cpc	r27, r21
     a0c:	f1 f6       	brne	.-68     	; 0x9ca <tinyDendrite_get_potential+0xf8>
			default:
				break;
		}
	}
	return return_potential_val;
}
     a0e:	c9 01       	movw	r24, r18
     a10:	df 91       	pop	r29
     a12:	cf 91       	pop	r28
     a14:	1f 91       	pop	r17
     a16:	0f 91       	pop	r16
     a18:	ff 90       	pop	r15
     a1a:	ef 90       	pop	r14
     a1c:	df 90       	pop	r13
     a1e:	cf 90       	pop	r12
     a20:	bf 90       	pop	r11
     a22:	af 90       	pop	r10
     a24:	9f 90       	pop	r9
     a26:	7f 90       	pop	r7
     a28:	6f 90       	pop	r6
     a2a:	08 95       	ret

00000a2c <tinyDendrite_update_potential>:

double tinyDendrite_update_potential(double potential){
     a2c:	cf 92       	push	r12
     a2e:	df 92       	push	r13
     a30:	ef 92       	push	r14
     a32:	ff 92       	push	r15
     a34:	6b 01       	movw	r12, r22
     a36:	7c 01       	movw	r14, r24
	
	uint16_t potential_change = tinyDendrite_get_potential();
     a38:	4c df       	rcall	.-360    	; 0x8d2 <tinyDendrite_get_potential>
	potential += potential_change;
	return potential;
     a3a:	bc 01       	movw	r22, r24
     a3c:	80 e0       	ldi	r24, 0x00	; 0
     a3e:	90 e0       	ldi	r25, 0x00	; 0
     a40:	ca d1       	rcall	.+916    	; 0xdd6 <__floatunsisf>
     a42:	a7 01       	movw	r20, r14
     a44:	96 01       	movw	r18, r12
     a46:	74 d0       	rcall	.+232    	; 0xb30 <__addsf3>
     a48:	ff 90       	pop	r15
     a4a:	ef 90       	pop	r14
     a4c:	df 90       	pop	r13
     a4e:	cf 90       	pop	r12
     a50:	08 95       	ret

00000a52 <__vector_6>:
This function is called every time the RTC (Real Time Clock) counter overflows.
With the current settings, it will be called every ms.
The RTC clock runs at 1kHz, and the number of cycles before overflow is set with RTC.PER = someHexValue (e.g. 0x20) in src/rtc.c
*/
ISR(RTC_CNT_vect)
{
     a52:	1f 92       	push	r1
     a54:	0f 92       	push	r0
     a56:	0f b6       	in	r0, 0x3f	; 63
     a58:	0f 92       	push	r0
     a5a:	11 24       	eor	r1, r1
     a5c:	2f 93       	push	r18
     a5e:	3f 93       	push	r19
     a60:	4f 93       	push	r20
     a62:	5f 93       	push	r21
     a64:	6f 93       	push	r22
     a66:	7f 93       	push	r23
     a68:	8f 93       	push	r24
     a6a:	9f 93       	push	r25
     a6c:	af 93       	push	r26
     a6e:	bf 93       	push	r27
     a70:	cf 93       	push	r28
     a72:	ef 93       	push	r30
     a74:	ff 93       	push	r31
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     a76:	c1 e0       	ldi	r28, 0x01	; 1
     a78:	c0 93 50 3e 	sts	0x3E50, r28	; 0x803e50 <tinyISR_interrupt_flag>
{
	// Set flag to let main loop run a new cycle
	tinyISR_setflag(true);
	
	// Timer counter incrementation
	tinyTime_counter_increment();
     a7c:	c7 dc       	rcall	.-1650   	; 0x40c <tinyTime_counter_increment>

	/* Overflow interrupt flag has to be cleared manually */
	RTC.INTFLAGS = RTC_OVF_bm;
     a7e:	c0 93 43 01 	sts	0x0143, r28	; 0x800143 <__TEXT_REGION_LENGTH__+0x700143>
}
     a82:	ff 91       	pop	r31
     a84:	ef 91       	pop	r30
     a86:	cf 91       	pop	r28
     a88:	bf 91       	pop	r27
     a8a:	af 91       	pop	r26
     a8c:	9f 91       	pop	r25
     a8e:	8f 91       	pop	r24
     a90:	7f 91       	pop	r23
     a92:	6f 91       	pop	r22
     a94:	5f 91       	pop	r21
     a96:	4f 91       	pop	r20
     a98:	3f 91       	pop	r19
     a9a:	2f 91       	pop	r18
     a9c:	0f 90       	pop	r0
     a9e:	0f be       	out	0x3f, r0	; 63
     aa0:	0f 90       	pop	r0
     aa2:	1f 90       	pop	r1
     aa4:	18 95       	reti

00000aa6 <tinyISR_setflag>:
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     aa6:	80 93 50 3e 	sts	0x3E50, r24	; 0x803e50 <tinyISR_interrupt_flag>
     aaa:	08 95       	ret

00000aac <tinyISR_getflag>:
}

_Bool tinyISR_getflag(void)
{
	return tinyISR_interrupt_flag;
}
     aac:	80 91 50 3e 	lds	r24, 0x3E50	; 0x803e50 <tinyISR_interrupt_flag>
     ab0:	08 95       	ret

00000ab2 <tinyPotential_update>:
/*
Function to decay the potential towards 0
*/
static void tinyPotential_decay(double time_since_last_update)
{
	tinyPotential_potential *= (exp(-(time_since_last_update/TINYPOTENTIAL_TIME_CONST)));
     ab2:	20 e0       	ldi	r18, 0x00	; 0
     ab4:	30 e0       	ldi	r19, 0x00	; 0
     ab6:	48 ec       	ldi	r20, 0xC8	; 200
     ab8:	52 e4       	ldi	r21, 0x42	; 66
     aba:	ab d0       	rcall	.+342    	; 0xc12 <__divsf3>
     abc:	90 58       	subi	r25, 0x80	; 128
     abe:	23 d1       	rcall	.+582    	; 0xd06 <exp>
     ac0:	20 91 51 3e 	lds	r18, 0x3E51	; 0x803e51 <tinyPotential_potential>
     ac4:	30 91 52 3e 	lds	r19, 0x3E52	; 0x803e52 <tinyPotential_potential+0x1>
     ac8:	40 91 53 3e 	lds	r20, 0x3E53	; 0x803e53 <tinyPotential_potential+0x2>
     acc:	50 91 54 3e 	lds	r21, 0x3E54	; 0x803e54 <tinyPotential_potential+0x3>
     ad0:	d6 d2       	rcall	.+1452   	; 0x107e <__mulsf3>
     ad2:	60 93 51 3e 	sts	0x3E51, r22	; 0x803e51 <tinyPotential_potential>
     ad6:	70 93 52 3e 	sts	0x3E52, r23	; 0x803e52 <tinyPotential_potential+0x1>
     ada:	80 93 53 3e 	sts	0x3E53, r24	; 0x803e53 <tinyPotential_potential+0x2>
     ade:	90 93 54 3e 	sts	0x3E54, r25	; 0x803e54 <tinyPotential_potential+0x3>
{
	//Some of the potential in the neuron has decayed away
	tinyPotential_decay(time_since_last_update);
	
	// Update potential with values from dendrites
	tinyPotential_potential = tinyDendrite_update_potential(tinyPotential_potential);
     ae2:	a4 df       	rcall	.-184    	; 0xa2c <tinyDendrite_update_potential>
     ae4:	60 93 51 3e 	sts	0x3E51, r22	; 0x803e51 <tinyPotential_potential>
     ae8:	70 93 52 3e 	sts	0x3E52, r23	; 0x803e52 <tinyPotential_potential+0x1>
     aec:	80 93 53 3e 	sts	0x3E53, r24	; 0x803e53 <tinyPotential_potential+0x2>
     af0:	90 93 54 3e 	sts	0x3E54, r25	; 0x803e54 <tinyPotential_potential+0x3>
	
	// Update potential from button press
	tinyPotential_potential = tinyButton_update_potential(tinyPotential_potential);
     af4:	bd dd       	rcall	.-1158   	; 0x670 <tinyButton_update_potential>
     af6:	60 93 51 3e 	sts	0x3E51, r22	; 0x803e51 <tinyPotential_potential>
     afa:	70 93 52 3e 	sts	0x3E52, r23	; 0x803e52 <tinyPotential_potential+0x1>
     afe:	80 93 53 3e 	sts	0x3E53, r24	; 0x803e53 <tinyPotential_potential+0x2>
     b02:	90 93 54 3e 	sts	0x3E54, r25	; 0x803e54 <tinyPotential_potential+0x3>
	
	// Update potential with values from spontaneous pulse.
	tinyPotential_potential = tinyPulse_update_potential(tinyPotential_potential);
     b06:	4d dc       	rcall	.-1894   	; 0x3a2 <tinyPulse_update_potential>
     b08:	60 93 51 3e 	sts	0x3E51, r22	; 0x803e51 <tinyPotential_potential>
     b0c:	70 93 52 3e 	sts	0x3E52, r23	; 0x803e52 <tinyPotential_potential+0x1>
     b10:	80 93 53 3e 	sts	0x3E53, r24	; 0x803e53 <tinyPotential_potential+0x2>
     b14:	90 93 54 3e 	sts	0x3E54, r25	; 0x803e54 <tinyPotential_potential+0x3>
	
	// Let the axon affect the potential
	// This is also where we decide whether or not the axon should fire
	tinyPotential_potential = tinyAxon_update_potential(tinyPotential_potential);
     b18:	21 de       	rcall	.-958    	; 0x75c <tinyAxon_update_potential>
     b1a:	60 93 51 3e 	sts	0x3E51, r22	; 0x803e51 <tinyPotential_potential>
     b1e:	70 93 52 3e 	sts	0x3E52, r23	; 0x803e52 <tinyPotential_potential+0x1>
     b22:	80 93 53 3e 	sts	0x3E53, r24	; 0x803e53 <tinyPotential_potential+0x2>
     b26:	90 93 54 3e 	sts	0x3E54, r25	; 0x803e54 <tinyPotential_potential+0x3>

	//Update the led
	potential_to_RGB_update_LEDs(tinyPotential_potential);
     b2a:	ca dc       	rcall	.-1644   	; 0x4c0 <potential_to_RGB_update_LEDs>
     b2c:	08 95       	ret

00000b2e <__subsf3>:
     b2e:	50 58       	subi	r21, 0x80	; 128

00000b30 <__addsf3>:
     b30:	bb 27       	eor	r27, r27
     b32:	aa 27       	eor	r26, r26
     b34:	0e 94 af 05 	call	0xb5e	; 0xb5e <__addsf3x>
     b38:	0c 94 8a 07 	jmp	0xf14	; 0xf14 <__fp_round>
     b3c:	0e 94 7c 07 	call	0xef8	; 0xef8 <__fp_pscA>
     b40:	38 f0       	brcs	.+14     	; 0xb50 <__addsf3+0x20>
     b42:	0e 94 83 07 	call	0xf06	; 0xf06 <__fp_pscB>
     b46:	20 f0       	brcs	.+8      	; 0xb50 <__addsf3+0x20>
     b48:	39 f4       	brne	.+14     	; 0xb58 <__addsf3+0x28>
     b4a:	9f 3f       	cpi	r25, 0xFF	; 255
     b4c:	19 f4       	brne	.+6      	; 0xb54 <__addsf3+0x24>
     b4e:	26 f4       	brtc	.+8      	; 0xb58 <__addsf3+0x28>
     b50:	0c 94 52 07 	jmp	0xea4	; 0xea4 <__fp_nan>
     b54:	0e f4       	brtc	.+2      	; 0xb58 <__addsf3+0x28>
     b56:	e0 95       	com	r30
     b58:	e7 fb       	bst	r30, 7
     b5a:	0c 94 4c 07 	jmp	0xe98	; 0xe98 <__fp_inf>

00000b5e <__addsf3x>:
     b5e:	e9 2f       	mov	r30, r25
     b60:	0e 94 9b 07 	call	0xf36	; 0xf36 <__fp_split3>
     b64:	58 f3       	brcs	.-42     	; 0xb3c <__addsf3+0xc>
     b66:	ba 17       	cp	r27, r26
     b68:	62 07       	cpc	r22, r18
     b6a:	73 07       	cpc	r23, r19
     b6c:	84 07       	cpc	r24, r20
     b6e:	95 07       	cpc	r25, r21
     b70:	20 f0       	brcs	.+8      	; 0xb7a <__addsf3x+0x1c>
     b72:	79 f4       	brne	.+30     	; 0xb92 <__addsf3x+0x34>
     b74:	a6 f5       	brtc	.+104    	; 0xbde <__addsf3x+0x80>
     b76:	0c 94 bd 07 	jmp	0xf7a	; 0xf7a <__fp_zero>
     b7a:	0e f4       	brtc	.+2      	; 0xb7e <__addsf3x+0x20>
     b7c:	e0 95       	com	r30
     b7e:	0b 2e       	mov	r0, r27
     b80:	ba 2f       	mov	r27, r26
     b82:	a0 2d       	mov	r26, r0
     b84:	0b 01       	movw	r0, r22
     b86:	b9 01       	movw	r22, r18
     b88:	90 01       	movw	r18, r0
     b8a:	0c 01       	movw	r0, r24
     b8c:	ca 01       	movw	r24, r20
     b8e:	a0 01       	movw	r20, r0
     b90:	11 24       	eor	r1, r1
     b92:	ff 27       	eor	r31, r31
     b94:	59 1b       	sub	r21, r25
     b96:	99 f0       	breq	.+38     	; 0xbbe <__addsf3x+0x60>
     b98:	59 3f       	cpi	r21, 0xF9	; 249
     b9a:	50 f4       	brcc	.+20     	; 0xbb0 <__addsf3x+0x52>
     b9c:	50 3e       	cpi	r21, 0xE0	; 224
     b9e:	68 f1       	brcs	.+90     	; 0xbfa <__addsf3x+0x9c>
     ba0:	1a 16       	cp	r1, r26
     ba2:	f0 40       	sbci	r31, 0x00	; 0
     ba4:	a2 2f       	mov	r26, r18
     ba6:	23 2f       	mov	r18, r19
     ba8:	34 2f       	mov	r19, r20
     baa:	44 27       	eor	r20, r20
     bac:	58 5f       	subi	r21, 0xF8	; 248
     bae:	f3 cf       	rjmp	.-26     	; 0xb96 <__addsf3x+0x38>
     bb0:	46 95       	lsr	r20
     bb2:	37 95       	ror	r19
     bb4:	27 95       	ror	r18
     bb6:	a7 95       	ror	r26
     bb8:	f0 40       	sbci	r31, 0x00	; 0
     bba:	53 95       	inc	r21
     bbc:	c9 f7       	brne	.-14     	; 0xbb0 <__addsf3x+0x52>
     bbe:	7e f4       	brtc	.+30     	; 0xbde <__addsf3x+0x80>
     bc0:	1f 16       	cp	r1, r31
     bc2:	ba 0b       	sbc	r27, r26
     bc4:	62 0b       	sbc	r22, r18
     bc6:	73 0b       	sbc	r23, r19
     bc8:	84 0b       	sbc	r24, r20
     bca:	ba f0       	brmi	.+46     	; 0xbfa <__addsf3x+0x9c>
     bcc:	91 50       	subi	r25, 0x01	; 1
     bce:	a1 f0       	breq	.+40     	; 0xbf8 <__addsf3x+0x9a>
     bd0:	ff 0f       	add	r31, r31
     bd2:	bb 1f       	adc	r27, r27
     bd4:	66 1f       	adc	r22, r22
     bd6:	77 1f       	adc	r23, r23
     bd8:	88 1f       	adc	r24, r24
     bda:	c2 f7       	brpl	.-16     	; 0xbcc <__addsf3x+0x6e>
     bdc:	0e c0       	rjmp	.+28     	; 0xbfa <__addsf3x+0x9c>
     bde:	ba 0f       	add	r27, r26
     be0:	62 1f       	adc	r22, r18
     be2:	73 1f       	adc	r23, r19
     be4:	84 1f       	adc	r24, r20
     be6:	48 f4       	brcc	.+18     	; 0xbfa <__addsf3x+0x9c>
     be8:	87 95       	ror	r24
     bea:	77 95       	ror	r23
     bec:	67 95       	ror	r22
     bee:	b7 95       	ror	r27
     bf0:	f7 95       	ror	r31
     bf2:	9e 3f       	cpi	r25, 0xFE	; 254
     bf4:	08 f0       	brcs	.+2      	; 0xbf8 <__addsf3x+0x9a>
     bf6:	b0 cf       	rjmp	.-160    	; 0xb58 <__addsf3+0x28>
     bf8:	93 95       	inc	r25
     bfa:	88 0f       	add	r24, r24
     bfc:	08 f0       	brcs	.+2      	; 0xc00 <__addsf3x+0xa2>
     bfe:	99 27       	eor	r25, r25
     c00:	ee 0f       	add	r30, r30
     c02:	97 95       	ror	r25
     c04:	87 95       	ror	r24
     c06:	08 95       	ret

00000c08 <__cmpsf2>:
     c08:	0e 94 28 07 	call	0xe50	; 0xe50 <__fp_cmp>
     c0c:	08 f4       	brcc	.+2      	; 0xc10 <__cmpsf2+0x8>
     c0e:	81 e0       	ldi	r24, 0x01	; 1
     c10:	08 95       	ret

00000c12 <__divsf3>:
     c12:	0e 94 1d 06 	call	0xc3a	; 0xc3a <__divsf3x>
     c16:	0c 94 8a 07 	jmp	0xf14	; 0xf14 <__fp_round>
     c1a:	0e 94 83 07 	call	0xf06	; 0xf06 <__fp_pscB>
     c1e:	58 f0       	brcs	.+22     	; 0xc36 <__divsf3+0x24>
     c20:	0e 94 7c 07 	call	0xef8	; 0xef8 <__fp_pscA>
     c24:	40 f0       	brcs	.+16     	; 0xc36 <__divsf3+0x24>
     c26:	29 f4       	brne	.+10     	; 0xc32 <__divsf3+0x20>
     c28:	5f 3f       	cpi	r21, 0xFF	; 255
     c2a:	29 f0       	breq	.+10     	; 0xc36 <__divsf3+0x24>
     c2c:	0c 94 4c 07 	jmp	0xe98	; 0xe98 <__fp_inf>
     c30:	51 11       	cpse	r21, r1
     c32:	0c 94 be 07 	jmp	0xf7c	; 0xf7c <__fp_szero>
     c36:	0c 94 52 07 	jmp	0xea4	; 0xea4 <__fp_nan>

00000c3a <__divsf3x>:
     c3a:	0e 94 9b 07 	call	0xf36	; 0xf36 <__fp_split3>
     c3e:	68 f3       	brcs	.-38     	; 0xc1a <__divsf3+0x8>

00000c40 <__divsf3_pse>:
     c40:	99 23       	and	r25, r25
     c42:	b1 f3       	breq	.-20     	; 0xc30 <__divsf3+0x1e>
     c44:	55 23       	and	r21, r21
     c46:	91 f3       	breq	.-28     	; 0xc2c <__divsf3+0x1a>
     c48:	95 1b       	sub	r25, r21
     c4a:	55 0b       	sbc	r21, r21
     c4c:	bb 27       	eor	r27, r27
     c4e:	aa 27       	eor	r26, r26
     c50:	62 17       	cp	r22, r18
     c52:	73 07       	cpc	r23, r19
     c54:	84 07       	cpc	r24, r20
     c56:	38 f0       	brcs	.+14     	; 0xc66 <__divsf3_pse+0x26>
     c58:	9f 5f       	subi	r25, 0xFF	; 255
     c5a:	5f 4f       	sbci	r21, 0xFF	; 255
     c5c:	22 0f       	add	r18, r18
     c5e:	33 1f       	adc	r19, r19
     c60:	44 1f       	adc	r20, r20
     c62:	aa 1f       	adc	r26, r26
     c64:	a9 f3       	breq	.-22     	; 0xc50 <__divsf3_pse+0x10>
     c66:	35 d0       	rcall	.+106    	; 0xcd2 <__divsf3_pse+0x92>
     c68:	0e 2e       	mov	r0, r30
     c6a:	3a f0       	brmi	.+14     	; 0xc7a <__divsf3_pse+0x3a>
     c6c:	e0 e8       	ldi	r30, 0x80	; 128
     c6e:	32 d0       	rcall	.+100    	; 0xcd4 <__divsf3_pse+0x94>
     c70:	91 50       	subi	r25, 0x01	; 1
     c72:	50 40       	sbci	r21, 0x00	; 0
     c74:	e6 95       	lsr	r30
     c76:	00 1c       	adc	r0, r0
     c78:	ca f7       	brpl	.-14     	; 0xc6c <__divsf3_pse+0x2c>
     c7a:	2b d0       	rcall	.+86     	; 0xcd2 <__divsf3_pse+0x92>
     c7c:	fe 2f       	mov	r31, r30
     c7e:	29 d0       	rcall	.+82     	; 0xcd2 <__divsf3_pse+0x92>
     c80:	66 0f       	add	r22, r22
     c82:	77 1f       	adc	r23, r23
     c84:	88 1f       	adc	r24, r24
     c86:	bb 1f       	adc	r27, r27
     c88:	26 17       	cp	r18, r22
     c8a:	37 07       	cpc	r19, r23
     c8c:	48 07       	cpc	r20, r24
     c8e:	ab 07       	cpc	r26, r27
     c90:	b0 e8       	ldi	r27, 0x80	; 128
     c92:	09 f0       	breq	.+2      	; 0xc96 <__divsf3_pse+0x56>
     c94:	bb 0b       	sbc	r27, r27
     c96:	80 2d       	mov	r24, r0
     c98:	bf 01       	movw	r22, r30
     c9a:	ff 27       	eor	r31, r31
     c9c:	93 58       	subi	r25, 0x83	; 131
     c9e:	5f 4f       	sbci	r21, 0xFF	; 255
     ca0:	3a f0       	brmi	.+14     	; 0xcb0 <__divsf3_pse+0x70>
     ca2:	9e 3f       	cpi	r25, 0xFE	; 254
     ca4:	51 05       	cpc	r21, r1
     ca6:	78 f0       	brcs	.+30     	; 0xcc6 <__divsf3_pse+0x86>
     ca8:	0c 94 4c 07 	jmp	0xe98	; 0xe98 <__fp_inf>
     cac:	0c 94 be 07 	jmp	0xf7c	; 0xf7c <__fp_szero>
     cb0:	5f 3f       	cpi	r21, 0xFF	; 255
     cb2:	e4 f3       	brlt	.-8      	; 0xcac <__divsf3_pse+0x6c>
     cb4:	98 3e       	cpi	r25, 0xE8	; 232
     cb6:	d4 f3       	brlt	.-12     	; 0xcac <__divsf3_pse+0x6c>
     cb8:	86 95       	lsr	r24
     cba:	77 95       	ror	r23
     cbc:	67 95       	ror	r22
     cbe:	b7 95       	ror	r27
     cc0:	f7 95       	ror	r31
     cc2:	9f 5f       	subi	r25, 0xFF	; 255
     cc4:	c9 f7       	brne	.-14     	; 0xcb8 <__divsf3_pse+0x78>
     cc6:	88 0f       	add	r24, r24
     cc8:	91 1d       	adc	r25, r1
     cca:	96 95       	lsr	r25
     ccc:	87 95       	ror	r24
     cce:	97 f9       	bld	r25, 7
     cd0:	08 95       	ret
     cd2:	e1 e0       	ldi	r30, 0x01	; 1
     cd4:	66 0f       	add	r22, r22
     cd6:	77 1f       	adc	r23, r23
     cd8:	88 1f       	adc	r24, r24
     cda:	bb 1f       	adc	r27, r27
     cdc:	62 17       	cp	r22, r18
     cde:	73 07       	cpc	r23, r19
     ce0:	84 07       	cpc	r24, r20
     ce2:	ba 07       	cpc	r27, r26
     ce4:	20 f0       	brcs	.+8      	; 0xcee <__divsf3_pse+0xae>
     ce6:	62 1b       	sub	r22, r18
     ce8:	73 0b       	sbc	r23, r19
     cea:	84 0b       	sbc	r24, r20
     cec:	ba 0b       	sbc	r27, r26
     cee:	ee 1f       	adc	r30, r30
     cf0:	88 f7       	brcc	.-30     	; 0xcd4 <__divsf3_pse+0x94>
     cf2:	e0 95       	com	r30
     cf4:	08 95       	ret
     cf6:	29 f4       	brne	.+10     	; 0xd02 <__divsf3_pse+0xc2>
     cf8:	16 f0       	brts	.+4      	; 0xcfe <__divsf3_pse+0xbe>
     cfa:	0c 94 4c 07 	jmp	0xe98	; 0xe98 <__fp_inf>
     cfe:	0c 94 bd 07 	jmp	0xf7a	; 0xf7a <__fp_zero>
     d02:	0c 94 52 07 	jmp	0xea4	; 0xea4 <__fp_nan>

00000d06 <exp>:
     d06:	0e 94 a3 07 	call	0xf46	; 0xf46 <__fp_splitA>
     d0a:	a8 f3       	brcs	.-22     	; 0xcf6 <__divsf3_pse+0xb6>
     d0c:	96 38       	cpi	r25, 0x86	; 134
     d0e:	a0 f7       	brcc	.-24     	; 0xcf8 <__divsf3_pse+0xb8>
     d10:	07 f8       	bld	r0, 7
     d12:	0f 92       	push	r0
     d14:	e8 94       	clt
     d16:	2b e3       	ldi	r18, 0x3B	; 59
     d18:	3a ea       	ldi	r19, 0xAA	; 170
     d1a:	48 eb       	ldi	r20, 0xB8	; 184
     d1c:	5f e7       	ldi	r21, 0x7F	; 127
     d1e:	0e 94 55 08 	call	0x10aa	; 0x10aa <__mulsf3_pse>
     d22:	0f 92       	push	r0
     d24:	0f 92       	push	r0
     d26:	0f 92       	push	r0
     d28:	4d b7       	in	r20, 0x3d	; 61
     d2a:	5e b7       	in	r21, 0x3e	; 62
     d2c:	0f 92       	push	r0
     d2e:	0e 94 0b 08 	call	0x1016	; 0x1016 <modf>
     d32:	e4 e3       	ldi	r30, 0x34	; 52
     d34:	f0 e0       	ldi	r31, 0x00	; 0
     d36:	0e 94 55 07 	call	0xeaa	; 0xeaa <__fp_powser>
     d3a:	4f 91       	pop	r20
     d3c:	5f 91       	pop	r21
     d3e:	ef 91       	pop	r30
     d40:	ff 91       	pop	r31
     d42:	e5 95       	asr	r30
     d44:	ee 1f       	adc	r30, r30
     d46:	ff 1f       	adc	r31, r31
     d48:	49 f0       	breq	.+18     	; 0xd5c <exp+0x56>
     d4a:	fe 57       	subi	r31, 0x7E	; 126
     d4c:	e0 68       	ori	r30, 0x80	; 128
     d4e:	44 27       	eor	r20, r20
     d50:	ee 0f       	add	r30, r30
     d52:	44 1f       	adc	r20, r20
     d54:	fa 95       	dec	r31
     d56:	e1 f7       	brne	.-8      	; 0xd50 <exp+0x4a>
     d58:	41 95       	neg	r20
     d5a:	55 0b       	sbc	r21, r21
     d5c:	0e 94 d5 07 	call	0xfaa	; 0xfaa <ldexp>
     d60:	0f 90       	pop	r0
     d62:	07 fe       	sbrs	r0, 7
     d64:	0c 94 c9 07 	jmp	0xf92	; 0xf92 <inverse>
     d68:	08 95       	ret

00000d6a <__fixsfsi>:
     d6a:	0e 94 bc 06 	call	0xd78	; 0xd78 <__fixunssfsi>
     d6e:	68 94       	set
     d70:	b1 11       	cpse	r27, r1
     d72:	0c 94 be 07 	jmp	0xf7c	; 0xf7c <__fp_szero>
     d76:	08 95       	ret

00000d78 <__fixunssfsi>:
     d78:	0e 94 a3 07 	call	0xf46	; 0xf46 <__fp_splitA>
     d7c:	88 f0       	brcs	.+34     	; 0xda0 <__fixunssfsi+0x28>
     d7e:	9f 57       	subi	r25, 0x7F	; 127
     d80:	98 f0       	brcs	.+38     	; 0xda8 <__fixunssfsi+0x30>
     d82:	b9 2f       	mov	r27, r25
     d84:	99 27       	eor	r25, r25
     d86:	b7 51       	subi	r27, 0x17	; 23
     d88:	b0 f0       	brcs	.+44     	; 0xdb6 <__fixunssfsi+0x3e>
     d8a:	e1 f0       	breq	.+56     	; 0xdc4 <__fixunssfsi+0x4c>
     d8c:	66 0f       	add	r22, r22
     d8e:	77 1f       	adc	r23, r23
     d90:	88 1f       	adc	r24, r24
     d92:	99 1f       	adc	r25, r25
     d94:	1a f0       	brmi	.+6      	; 0xd9c <__fixunssfsi+0x24>
     d96:	ba 95       	dec	r27
     d98:	c9 f7       	brne	.-14     	; 0xd8c <__fixunssfsi+0x14>
     d9a:	14 c0       	rjmp	.+40     	; 0xdc4 <__fixunssfsi+0x4c>
     d9c:	b1 30       	cpi	r27, 0x01	; 1
     d9e:	91 f0       	breq	.+36     	; 0xdc4 <__fixunssfsi+0x4c>
     da0:	0e 94 bd 07 	call	0xf7a	; 0xf7a <__fp_zero>
     da4:	b1 e0       	ldi	r27, 0x01	; 1
     da6:	08 95       	ret
     da8:	0c 94 bd 07 	jmp	0xf7a	; 0xf7a <__fp_zero>
     dac:	67 2f       	mov	r22, r23
     dae:	78 2f       	mov	r23, r24
     db0:	88 27       	eor	r24, r24
     db2:	b8 5f       	subi	r27, 0xF8	; 248
     db4:	39 f0       	breq	.+14     	; 0xdc4 <__fixunssfsi+0x4c>
     db6:	b9 3f       	cpi	r27, 0xF9	; 249
     db8:	cc f3       	brlt	.-14     	; 0xdac <__fixunssfsi+0x34>
     dba:	86 95       	lsr	r24
     dbc:	77 95       	ror	r23
     dbe:	67 95       	ror	r22
     dc0:	b3 95       	inc	r27
     dc2:	d9 f7       	brne	.-10     	; 0xdba <__fixunssfsi+0x42>
     dc4:	3e f4       	brtc	.+14     	; 0xdd4 <__fixunssfsi+0x5c>
     dc6:	90 95       	com	r25
     dc8:	80 95       	com	r24
     dca:	70 95       	com	r23
     dcc:	61 95       	neg	r22
     dce:	7f 4f       	sbci	r23, 0xFF	; 255
     dd0:	8f 4f       	sbci	r24, 0xFF	; 255
     dd2:	9f 4f       	sbci	r25, 0xFF	; 255
     dd4:	08 95       	ret

00000dd6 <__floatunsisf>:
     dd6:	e8 94       	clt
     dd8:	09 c0       	rjmp	.+18     	; 0xdec <__floatsisf+0x12>

00000dda <__floatsisf>:
     dda:	97 fb       	bst	r25, 7
     ddc:	3e f4       	brtc	.+14     	; 0xdec <__floatsisf+0x12>
     dde:	90 95       	com	r25
     de0:	80 95       	com	r24
     de2:	70 95       	com	r23
     de4:	61 95       	neg	r22
     de6:	7f 4f       	sbci	r23, 0xFF	; 255
     de8:	8f 4f       	sbci	r24, 0xFF	; 255
     dea:	9f 4f       	sbci	r25, 0xFF	; 255
     dec:	99 23       	and	r25, r25
     dee:	a9 f0       	breq	.+42     	; 0xe1a <__floatsisf+0x40>
     df0:	f9 2f       	mov	r31, r25
     df2:	96 e9       	ldi	r25, 0x96	; 150
     df4:	bb 27       	eor	r27, r27
     df6:	93 95       	inc	r25
     df8:	f6 95       	lsr	r31
     dfa:	87 95       	ror	r24
     dfc:	77 95       	ror	r23
     dfe:	67 95       	ror	r22
     e00:	b7 95       	ror	r27
     e02:	f1 11       	cpse	r31, r1
     e04:	f8 cf       	rjmp	.-16     	; 0xdf6 <__floatsisf+0x1c>
     e06:	fa f4       	brpl	.+62     	; 0xe46 <__floatsisf+0x6c>
     e08:	bb 0f       	add	r27, r27
     e0a:	11 f4       	brne	.+4      	; 0xe10 <__floatsisf+0x36>
     e0c:	60 ff       	sbrs	r22, 0
     e0e:	1b c0       	rjmp	.+54     	; 0xe46 <__floatsisf+0x6c>
     e10:	6f 5f       	subi	r22, 0xFF	; 255
     e12:	7f 4f       	sbci	r23, 0xFF	; 255
     e14:	8f 4f       	sbci	r24, 0xFF	; 255
     e16:	9f 4f       	sbci	r25, 0xFF	; 255
     e18:	16 c0       	rjmp	.+44     	; 0xe46 <__floatsisf+0x6c>
     e1a:	88 23       	and	r24, r24
     e1c:	11 f0       	breq	.+4      	; 0xe22 <__floatsisf+0x48>
     e1e:	96 e9       	ldi	r25, 0x96	; 150
     e20:	11 c0       	rjmp	.+34     	; 0xe44 <__floatsisf+0x6a>
     e22:	77 23       	and	r23, r23
     e24:	21 f0       	breq	.+8      	; 0xe2e <__floatsisf+0x54>
     e26:	9e e8       	ldi	r25, 0x8E	; 142
     e28:	87 2f       	mov	r24, r23
     e2a:	76 2f       	mov	r23, r22
     e2c:	05 c0       	rjmp	.+10     	; 0xe38 <__floatsisf+0x5e>
     e2e:	66 23       	and	r22, r22
     e30:	71 f0       	breq	.+28     	; 0xe4e <__floatsisf+0x74>
     e32:	96 e8       	ldi	r25, 0x86	; 134
     e34:	86 2f       	mov	r24, r22
     e36:	70 e0       	ldi	r23, 0x00	; 0
     e38:	60 e0       	ldi	r22, 0x00	; 0
     e3a:	2a f0       	brmi	.+10     	; 0xe46 <__floatsisf+0x6c>
     e3c:	9a 95       	dec	r25
     e3e:	66 0f       	add	r22, r22
     e40:	77 1f       	adc	r23, r23
     e42:	88 1f       	adc	r24, r24
     e44:	da f7       	brpl	.-10     	; 0xe3c <__floatsisf+0x62>
     e46:	88 0f       	add	r24, r24
     e48:	96 95       	lsr	r25
     e4a:	87 95       	ror	r24
     e4c:	97 f9       	bld	r25, 7
     e4e:	08 95       	ret

00000e50 <__fp_cmp>:
     e50:	99 0f       	add	r25, r25
     e52:	00 08       	sbc	r0, r0
     e54:	55 0f       	add	r21, r21
     e56:	aa 0b       	sbc	r26, r26
     e58:	e0 e8       	ldi	r30, 0x80	; 128
     e5a:	fe ef       	ldi	r31, 0xFE	; 254
     e5c:	16 16       	cp	r1, r22
     e5e:	17 06       	cpc	r1, r23
     e60:	e8 07       	cpc	r30, r24
     e62:	f9 07       	cpc	r31, r25
     e64:	c0 f0       	brcs	.+48     	; 0xe96 <__fp_cmp+0x46>
     e66:	12 16       	cp	r1, r18
     e68:	13 06       	cpc	r1, r19
     e6a:	e4 07       	cpc	r30, r20
     e6c:	f5 07       	cpc	r31, r21
     e6e:	98 f0       	brcs	.+38     	; 0xe96 <__fp_cmp+0x46>
     e70:	62 1b       	sub	r22, r18
     e72:	73 0b       	sbc	r23, r19
     e74:	84 0b       	sbc	r24, r20
     e76:	95 0b       	sbc	r25, r21
     e78:	39 f4       	brne	.+14     	; 0xe88 <__fp_cmp+0x38>
     e7a:	0a 26       	eor	r0, r26
     e7c:	61 f0       	breq	.+24     	; 0xe96 <__fp_cmp+0x46>
     e7e:	23 2b       	or	r18, r19
     e80:	24 2b       	or	r18, r20
     e82:	25 2b       	or	r18, r21
     e84:	21 f4       	brne	.+8      	; 0xe8e <__fp_cmp+0x3e>
     e86:	08 95       	ret
     e88:	0a 26       	eor	r0, r26
     e8a:	09 f4       	brne	.+2      	; 0xe8e <__fp_cmp+0x3e>
     e8c:	a1 40       	sbci	r26, 0x01	; 1
     e8e:	a6 95       	lsr	r26
     e90:	8f ef       	ldi	r24, 0xFF	; 255
     e92:	81 1d       	adc	r24, r1
     e94:	81 1d       	adc	r24, r1
     e96:	08 95       	ret

00000e98 <__fp_inf>:
     e98:	97 f9       	bld	r25, 7
     e9a:	9f 67       	ori	r25, 0x7F	; 127
     e9c:	80 e8       	ldi	r24, 0x80	; 128
     e9e:	70 e0       	ldi	r23, 0x00	; 0
     ea0:	60 e0       	ldi	r22, 0x00	; 0
     ea2:	08 95       	ret

00000ea4 <__fp_nan>:
     ea4:	9f ef       	ldi	r25, 0xFF	; 255
     ea6:	80 ec       	ldi	r24, 0xC0	; 192
     ea8:	08 95       	ret

00000eaa <__fp_powser>:
     eaa:	df 93       	push	r29
     eac:	cf 93       	push	r28
     eae:	1f 93       	push	r17
     eb0:	0f 93       	push	r16
     eb2:	ff 92       	push	r15
     eb4:	ef 92       	push	r14
     eb6:	df 92       	push	r13
     eb8:	7b 01       	movw	r14, r22
     eba:	8c 01       	movw	r16, r24
     ebc:	68 94       	set
     ebe:	06 c0       	rjmp	.+12     	; 0xecc <__fp_powser+0x22>
     ec0:	da 2e       	mov	r13, r26
     ec2:	ef 01       	movw	r28, r30
     ec4:	0e 94 52 08 	call	0x10a4	; 0x10a4 <__mulsf3x>
     ec8:	fe 01       	movw	r30, r28
     eca:	e8 94       	clt
     ecc:	a5 91       	lpm	r26, Z+
     ece:	25 91       	lpm	r18, Z+
     ed0:	35 91       	lpm	r19, Z+
     ed2:	45 91       	lpm	r20, Z+
     ed4:	55 91       	lpm	r21, Z+
     ed6:	a6 f3       	brts	.-24     	; 0xec0 <__fp_powser+0x16>
     ed8:	ef 01       	movw	r28, r30
     eda:	0e 94 af 05 	call	0xb5e	; 0xb5e <__addsf3x>
     ede:	fe 01       	movw	r30, r28
     ee0:	97 01       	movw	r18, r14
     ee2:	a8 01       	movw	r20, r16
     ee4:	da 94       	dec	r13
     ee6:	69 f7       	brne	.-38     	; 0xec2 <__fp_powser+0x18>
     ee8:	df 90       	pop	r13
     eea:	ef 90       	pop	r14
     eec:	ff 90       	pop	r15
     eee:	0f 91       	pop	r16
     ef0:	1f 91       	pop	r17
     ef2:	cf 91       	pop	r28
     ef4:	df 91       	pop	r29
     ef6:	08 95       	ret

00000ef8 <__fp_pscA>:
     ef8:	00 24       	eor	r0, r0
     efa:	0a 94       	dec	r0
     efc:	16 16       	cp	r1, r22
     efe:	17 06       	cpc	r1, r23
     f00:	18 06       	cpc	r1, r24
     f02:	09 06       	cpc	r0, r25
     f04:	08 95       	ret

00000f06 <__fp_pscB>:
     f06:	00 24       	eor	r0, r0
     f08:	0a 94       	dec	r0
     f0a:	12 16       	cp	r1, r18
     f0c:	13 06       	cpc	r1, r19
     f0e:	14 06       	cpc	r1, r20
     f10:	05 06       	cpc	r0, r21
     f12:	08 95       	ret

00000f14 <__fp_round>:
     f14:	09 2e       	mov	r0, r25
     f16:	03 94       	inc	r0
     f18:	00 0c       	add	r0, r0
     f1a:	11 f4       	brne	.+4      	; 0xf20 <__fp_round+0xc>
     f1c:	88 23       	and	r24, r24
     f1e:	52 f0       	brmi	.+20     	; 0xf34 <__fp_round+0x20>
     f20:	bb 0f       	add	r27, r27
     f22:	40 f4       	brcc	.+16     	; 0xf34 <__fp_round+0x20>
     f24:	bf 2b       	or	r27, r31
     f26:	11 f4       	brne	.+4      	; 0xf2c <__fp_round+0x18>
     f28:	60 ff       	sbrs	r22, 0
     f2a:	04 c0       	rjmp	.+8      	; 0xf34 <__fp_round+0x20>
     f2c:	6f 5f       	subi	r22, 0xFF	; 255
     f2e:	7f 4f       	sbci	r23, 0xFF	; 255
     f30:	8f 4f       	sbci	r24, 0xFF	; 255
     f32:	9f 4f       	sbci	r25, 0xFF	; 255
     f34:	08 95       	ret

00000f36 <__fp_split3>:
     f36:	57 fd       	sbrc	r21, 7
     f38:	90 58       	subi	r25, 0x80	; 128
     f3a:	44 0f       	add	r20, r20
     f3c:	55 1f       	adc	r21, r21
     f3e:	59 f0       	breq	.+22     	; 0xf56 <__fp_splitA+0x10>
     f40:	5f 3f       	cpi	r21, 0xFF	; 255
     f42:	71 f0       	breq	.+28     	; 0xf60 <__fp_splitA+0x1a>
     f44:	47 95       	ror	r20

00000f46 <__fp_splitA>:
     f46:	88 0f       	add	r24, r24
     f48:	97 fb       	bst	r25, 7
     f4a:	99 1f       	adc	r25, r25
     f4c:	61 f0       	breq	.+24     	; 0xf66 <__fp_splitA+0x20>
     f4e:	9f 3f       	cpi	r25, 0xFF	; 255
     f50:	79 f0       	breq	.+30     	; 0xf70 <__fp_splitA+0x2a>
     f52:	87 95       	ror	r24
     f54:	08 95       	ret
     f56:	12 16       	cp	r1, r18
     f58:	13 06       	cpc	r1, r19
     f5a:	14 06       	cpc	r1, r20
     f5c:	55 1f       	adc	r21, r21
     f5e:	f2 cf       	rjmp	.-28     	; 0xf44 <__fp_split3+0xe>
     f60:	46 95       	lsr	r20
     f62:	f1 df       	rcall	.-30     	; 0xf46 <__fp_splitA>
     f64:	08 c0       	rjmp	.+16     	; 0xf76 <__fp_splitA+0x30>
     f66:	16 16       	cp	r1, r22
     f68:	17 06       	cpc	r1, r23
     f6a:	18 06       	cpc	r1, r24
     f6c:	99 1f       	adc	r25, r25
     f6e:	f1 cf       	rjmp	.-30     	; 0xf52 <__fp_splitA+0xc>
     f70:	86 95       	lsr	r24
     f72:	71 05       	cpc	r23, r1
     f74:	61 05       	cpc	r22, r1
     f76:	08 94       	sec
     f78:	08 95       	ret

00000f7a <__fp_zero>:
     f7a:	e8 94       	clt

00000f7c <__fp_szero>:
     f7c:	bb 27       	eor	r27, r27
     f7e:	66 27       	eor	r22, r22
     f80:	77 27       	eor	r23, r23
     f82:	cb 01       	movw	r24, r22
     f84:	97 f9       	bld	r25, 7
     f86:	08 95       	ret

00000f88 <__gesf2>:
     f88:	0e 94 28 07 	call	0xe50	; 0xe50 <__fp_cmp>
     f8c:	08 f4       	brcc	.+2      	; 0xf90 <__gesf2+0x8>
     f8e:	8f ef       	ldi	r24, 0xFF	; 255
     f90:	08 95       	ret

00000f92 <inverse>:
     f92:	9b 01       	movw	r18, r22
     f94:	ac 01       	movw	r20, r24
     f96:	60 e0       	ldi	r22, 0x00	; 0
     f98:	70 e0       	ldi	r23, 0x00	; 0
     f9a:	80 e8       	ldi	r24, 0x80	; 128
     f9c:	9f e3       	ldi	r25, 0x3F	; 63
     f9e:	0c 94 09 06 	jmp	0xc12	; 0xc12 <__divsf3>
     fa2:	0c 94 4c 07 	jmp	0xe98	; 0xe98 <__fp_inf>
     fa6:	0c 94 eb 08 	jmp	0x11d6	; 0x11d6 <__fp_mpack>

00000faa <ldexp>:
     faa:	0e 94 a3 07 	call	0xf46	; 0xf46 <__fp_splitA>
     fae:	d8 f3       	brcs	.-10     	; 0xfa6 <inverse+0x14>
     fb0:	99 23       	and	r25, r25
     fb2:	c9 f3       	breq	.-14     	; 0xfa6 <inverse+0x14>
     fb4:	94 0f       	add	r25, r20
     fb6:	51 1d       	adc	r21, r1
     fb8:	a3 f3       	brvs	.-24     	; 0xfa2 <inverse+0x10>
     fba:	91 50       	subi	r25, 0x01	; 1
     fbc:	50 40       	sbci	r21, 0x00	; 0
     fbe:	94 f0       	brlt	.+36     	; 0xfe4 <ldexp+0x3a>
     fc0:	59 f0       	breq	.+22     	; 0xfd8 <ldexp+0x2e>
     fc2:	88 23       	and	r24, r24
     fc4:	32 f0       	brmi	.+12     	; 0xfd2 <ldexp+0x28>
     fc6:	66 0f       	add	r22, r22
     fc8:	77 1f       	adc	r23, r23
     fca:	88 1f       	adc	r24, r24
     fcc:	91 50       	subi	r25, 0x01	; 1
     fce:	50 40       	sbci	r21, 0x00	; 0
     fd0:	c1 f7       	brne	.-16     	; 0xfc2 <ldexp+0x18>
     fd2:	9e 3f       	cpi	r25, 0xFE	; 254
     fd4:	51 05       	cpc	r21, r1
     fd6:	2c f7       	brge	.-54     	; 0xfa2 <inverse+0x10>
     fd8:	88 0f       	add	r24, r24
     fda:	91 1d       	adc	r25, r1
     fdc:	96 95       	lsr	r25
     fde:	87 95       	ror	r24
     fe0:	97 f9       	bld	r25, 7
     fe2:	08 95       	ret
     fe4:	5f 3f       	cpi	r21, 0xFF	; 255
     fe6:	ac f0       	brlt	.+42     	; 0x1012 <ldexp+0x68>
     fe8:	98 3e       	cpi	r25, 0xE8	; 232
     fea:	9c f0       	brlt	.+38     	; 0x1012 <ldexp+0x68>
     fec:	bb 27       	eor	r27, r27
     fee:	86 95       	lsr	r24
     ff0:	77 95       	ror	r23
     ff2:	67 95       	ror	r22
     ff4:	b7 95       	ror	r27
     ff6:	08 f4       	brcc	.+2      	; 0xffa <ldexp+0x50>
     ff8:	b1 60       	ori	r27, 0x01	; 1
     ffa:	93 95       	inc	r25
     ffc:	c1 f7       	brne	.-16     	; 0xfee <ldexp+0x44>
     ffe:	bb 0f       	add	r27, r27
    1000:	58 f7       	brcc	.-42     	; 0xfd8 <ldexp+0x2e>
    1002:	11 f4       	brne	.+4      	; 0x1008 <ldexp+0x5e>
    1004:	60 ff       	sbrs	r22, 0
    1006:	e8 cf       	rjmp	.-48     	; 0xfd8 <ldexp+0x2e>
    1008:	6f 5f       	subi	r22, 0xFF	; 255
    100a:	7f 4f       	sbci	r23, 0xFF	; 255
    100c:	8f 4f       	sbci	r24, 0xFF	; 255
    100e:	9f 4f       	sbci	r25, 0xFF	; 255
    1010:	e3 cf       	rjmp	.-58     	; 0xfd8 <ldexp+0x2e>
    1012:	0c 94 be 07 	jmp	0xf7c	; 0xf7c <__fp_szero>

00001016 <modf>:
    1016:	fa 01       	movw	r30, r20
    1018:	dc 01       	movw	r26, r24
    101a:	aa 0f       	add	r26, r26
    101c:	bb 1f       	adc	r27, r27
    101e:	9b 01       	movw	r18, r22
    1020:	ac 01       	movw	r20, r24
    1022:	bf 57       	subi	r27, 0x7F	; 127
    1024:	28 f4       	brcc	.+10     	; 0x1030 <modf+0x1a>
    1026:	22 27       	eor	r18, r18
    1028:	33 27       	eor	r19, r19
    102a:	44 27       	eor	r20, r20
    102c:	50 78       	andi	r21, 0x80	; 128
    102e:	20 c0       	rjmp	.+64     	; 0x1070 <modf+0x5a>
    1030:	b7 51       	subi	r27, 0x17	; 23
    1032:	90 f4       	brcc	.+36     	; 0x1058 <modf+0x42>
    1034:	ab 2f       	mov	r26, r27
    1036:	00 24       	eor	r0, r0
    1038:	46 95       	lsr	r20
    103a:	37 95       	ror	r19
    103c:	27 95       	ror	r18
    103e:	01 1c       	adc	r0, r1
    1040:	a3 95       	inc	r26
    1042:	d2 f3       	brmi	.-12     	; 0x1038 <modf+0x22>
    1044:	00 20       	and	r0, r0
    1046:	71 f0       	breq	.+28     	; 0x1064 <modf+0x4e>
    1048:	22 0f       	add	r18, r18
    104a:	33 1f       	adc	r19, r19
    104c:	44 1f       	adc	r20, r20
    104e:	b3 95       	inc	r27
    1050:	da f3       	brmi	.-10     	; 0x1048 <modf+0x32>
    1052:	0e d0       	rcall	.+28     	; 0x1070 <modf+0x5a>
    1054:	0c 94 97 05 	jmp	0xb2e	; 0xb2e <__subsf3>
    1058:	61 30       	cpi	r22, 0x01	; 1
    105a:	71 05       	cpc	r23, r1
    105c:	a0 e8       	ldi	r26, 0x80	; 128
    105e:	8a 07       	cpc	r24, r26
    1060:	b9 46       	sbci	r27, 0x69	; 105
    1062:	30 f4       	brcc	.+12     	; 0x1070 <modf+0x5a>
    1064:	9b 01       	movw	r18, r22
    1066:	ac 01       	movw	r20, r24
    1068:	66 27       	eor	r22, r22
    106a:	77 27       	eor	r23, r23
    106c:	88 27       	eor	r24, r24
    106e:	90 78       	andi	r25, 0x80	; 128
    1070:	30 96       	adiw	r30, 0x00	; 0
    1072:	21 f0       	breq	.+8      	; 0x107c <modf+0x66>
    1074:	20 83       	st	Z, r18
    1076:	31 83       	std	Z+1, r19	; 0x01
    1078:	42 83       	std	Z+2, r20	; 0x02
    107a:	53 83       	std	Z+3, r21	; 0x03
    107c:	08 95       	ret

0000107e <__mulsf3>:
    107e:	0e 94 52 08 	call	0x10a4	; 0x10a4 <__mulsf3x>
    1082:	0c 94 8a 07 	jmp	0xf14	; 0xf14 <__fp_round>
    1086:	0e 94 7c 07 	call	0xef8	; 0xef8 <__fp_pscA>
    108a:	38 f0       	brcs	.+14     	; 0x109a <__mulsf3+0x1c>
    108c:	0e 94 83 07 	call	0xf06	; 0xf06 <__fp_pscB>
    1090:	20 f0       	brcs	.+8      	; 0x109a <__mulsf3+0x1c>
    1092:	95 23       	and	r25, r21
    1094:	11 f0       	breq	.+4      	; 0x109a <__mulsf3+0x1c>
    1096:	0c 94 4c 07 	jmp	0xe98	; 0xe98 <__fp_inf>
    109a:	0c 94 52 07 	jmp	0xea4	; 0xea4 <__fp_nan>
    109e:	11 24       	eor	r1, r1
    10a0:	0c 94 be 07 	jmp	0xf7c	; 0xf7c <__fp_szero>

000010a4 <__mulsf3x>:
    10a4:	0e 94 9b 07 	call	0xf36	; 0xf36 <__fp_split3>
    10a8:	70 f3       	brcs	.-36     	; 0x1086 <__mulsf3+0x8>

000010aa <__mulsf3_pse>:
    10aa:	95 9f       	mul	r25, r21
    10ac:	c1 f3       	breq	.-16     	; 0x109e <__mulsf3+0x20>
    10ae:	95 0f       	add	r25, r21
    10b0:	50 e0       	ldi	r21, 0x00	; 0
    10b2:	55 1f       	adc	r21, r21
    10b4:	62 9f       	mul	r22, r18
    10b6:	f0 01       	movw	r30, r0
    10b8:	72 9f       	mul	r23, r18
    10ba:	bb 27       	eor	r27, r27
    10bc:	f0 0d       	add	r31, r0
    10be:	b1 1d       	adc	r27, r1
    10c0:	63 9f       	mul	r22, r19
    10c2:	aa 27       	eor	r26, r26
    10c4:	f0 0d       	add	r31, r0
    10c6:	b1 1d       	adc	r27, r1
    10c8:	aa 1f       	adc	r26, r26
    10ca:	64 9f       	mul	r22, r20
    10cc:	66 27       	eor	r22, r22
    10ce:	b0 0d       	add	r27, r0
    10d0:	a1 1d       	adc	r26, r1
    10d2:	66 1f       	adc	r22, r22
    10d4:	82 9f       	mul	r24, r18
    10d6:	22 27       	eor	r18, r18
    10d8:	b0 0d       	add	r27, r0
    10da:	a1 1d       	adc	r26, r1
    10dc:	62 1f       	adc	r22, r18
    10de:	73 9f       	mul	r23, r19
    10e0:	b0 0d       	add	r27, r0
    10e2:	a1 1d       	adc	r26, r1
    10e4:	62 1f       	adc	r22, r18
    10e6:	83 9f       	mul	r24, r19
    10e8:	a0 0d       	add	r26, r0
    10ea:	61 1d       	adc	r22, r1
    10ec:	22 1f       	adc	r18, r18
    10ee:	74 9f       	mul	r23, r20
    10f0:	33 27       	eor	r19, r19
    10f2:	a0 0d       	add	r26, r0
    10f4:	61 1d       	adc	r22, r1
    10f6:	23 1f       	adc	r18, r19
    10f8:	84 9f       	mul	r24, r20
    10fa:	60 0d       	add	r22, r0
    10fc:	21 1d       	adc	r18, r1
    10fe:	82 2f       	mov	r24, r18
    1100:	76 2f       	mov	r23, r22
    1102:	6a 2f       	mov	r22, r26
    1104:	11 24       	eor	r1, r1
    1106:	9f 57       	subi	r25, 0x7F	; 127
    1108:	50 40       	sbci	r21, 0x00	; 0
    110a:	9a f0       	brmi	.+38     	; 0x1132 <__mulsf3_pse+0x88>
    110c:	f1 f0       	breq	.+60     	; 0x114a <__mulsf3_pse+0xa0>
    110e:	88 23       	and	r24, r24
    1110:	4a f0       	brmi	.+18     	; 0x1124 <__mulsf3_pse+0x7a>
    1112:	ee 0f       	add	r30, r30
    1114:	ff 1f       	adc	r31, r31
    1116:	bb 1f       	adc	r27, r27
    1118:	66 1f       	adc	r22, r22
    111a:	77 1f       	adc	r23, r23
    111c:	88 1f       	adc	r24, r24
    111e:	91 50       	subi	r25, 0x01	; 1
    1120:	50 40       	sbci	r21, 0x00	; 0
    1122:	a9 f7       	brne	.-22     	; 0x110e <__mulsf3_pse+0x64>
    1124:	9e 3f       	cpi	r25, 0xFE	; 254
    1126:	51 05       	cpc	r21, r1
    1128:	80 f0       	brcs	.+32     	; 0x114a <__mulsf3_pse+0xa0>
    112a:	0c 94 4c 07 	jmp	0xe98	; 0xe98 <__fp_inf>
    112e:	0c 94 be 07 	jmp	0xf7c	; 0xf7c <__fp_szero>
    1132:	5f 3f       	cpi	r21, 0xFF	; 255
    1134:	e4 f3       	brlt	.-8      	; 0x112e <__mulsf3_pse+0x84>
    1136:	98 3e       	cpi	r25, 0xE8	; 232
    1138:	d4 f3       	brlt	.-12     	; 0x112e <__mulsf3_pse+0x84>
    113a:	86 95       	lsr	r24
    113c:	77 95       	ror	r23
    113e:	67 95       	ror	r22
    1140:	b7 95       	ror	r27
    1142:	f7 95       	ror	r31
    1144:	e7 95       	ror	r30
    1146:	9f 5f       	subi	r25, 0xFF	; 255
    1148:	c1 f7       	brne	.-16     	; 0x113a <__mulsf3_pse+0x90>
    114a:	fe 2b       	or	r31, r30
    114c:	88 0f       	add	r24, r24
    114e:	91 1d       	adc	r25, r1
    1150:	96 95       	lsr	r25
    1152:	87 95       	ror	r24
    1154:	97 f9       	bld	r25, 7
    1156:	08 95       	ret

00001158 <round>:
    1158:	0e 94 a3 07 	call	0xf46	; 0xf46 <__fp_splitA>
    115c:	e8 f0       	brcs	.+58     	; 0x1198 <round+0x40>
    115e:	9e 37       	cpi	r25, 0x7E	; 126
    1160:	e8 f0       	brcs	.+58     	; 0x119c <round+0x44>
    1162:	96 39       	cpi	r25, 0x96	; 150
    1164:	b8 f4       	brcc	.+46     	; 0x1194 <round+0x3c>
    1166:	9e 38       	cpi	r25, 0x8E	; 142
    1168:	48 f4       	brcc	.+18     	; 0x117c <round+0x24>
    116a:	67 2f       	mov	r22, r23
    116c:	78 2f       	mov	r23, r24
    116e:	88 27       	eor	r24, r24
    1170:	98 5f       	subi	r25, 0xF8	; 248
    1172:	f9 cf       	rjmp	.-14     	; 0x1166 <round+0xe>
    1174:	86 95       	lsr	r24
    1176:	77 95       	ror	r23
    1178:	67 95       	ror	r22
    117a:	93 95       	inc	r25
    117c:	95 39       	cpi	r25, 0x95	; 149
    117e:	d0 f3       	brcs	.-12     	; 0x1174 <round+0x1c>
    1180:	b6 2f       	mov	r27, r22
    1182:	b1 70       	andi	r27, 0x01	; 1
    1184:	6b 0f       	add	r22, r27
    1186:	71 1d       	adc	r23, r1
    1188:	81 1d       	adc	r24, r1
    118a:	20 f4       	brcc	.+8      	; 0x1194 <round+0x3c>
    118c:	87 95       	ror	r24
    118e:	77 95       	ror	r23
    1190:	67 95       	ror	r22
    1192:	93 95       	inc	r25
    1194:	0c 94 d0 08 	jmp	0x11a0	; 0x11a0 <__fp_mintl>
    1198:	0c 94 eb 08 	jmp	0x11d6	; 0x11d6 <__fp_mpack>
    119c:	0c 94 be 07 	jmp	0xf7c	; 0xf7c <__fp_szero>

000011a0 <__fp_mintl>:
    11a0:	88 23       	and	r24, r24
    11a2:	71 f4       	brne	.+28     	; 0x11c0 <__fp_mintl+0x20>
    11a4:	77 23       	and	r23, r23
    11a6:	21 f0       	breq	.+8      	; 0x11b0 <__fp_mintl+0x10>
    11a8:	98 50       	subi	r25, 0x08	; 8
    11aa:	87 2b       	or	r24, r23
    11ac:	76 2f       	mov	r23, r22
    11ae:	07 c0       	rjmp	.+14     	; 0x11be <__fp_mintl+0x1e>
    11b0:	66 23       	and	r22, r22
    11b2:	11 f4       	brne	.+4      	; 0x11b8 <__fp_mintl+0x18>
    11b4:	99 27       	eor	r25, r25
    11b6:	0d c0       	rjmp	.+26     	; 0x11d2 <__fp_mintl+0x32>
    11b8:	90 51       	subi	r25, 0x10	; 16
    11ba:	86 2b       	or	r24, r22
    11bc:	70 e0       	ldi	r23, 0x00	; 0
    11be:	60 e0       	ldi	r22, 0x00	; 0
    11c0:	2a f0       	brmi	.+10     	; 0x11cc <__fp_mintl+0x2c>
    11c2:	9a 95       	dec	r25
    11c4:	66 0f       	add	r22, r22
    11c6:	77 1f       	adc	r23, r23
    11c8:	88 1f       	adc	r24, r24
    11ca:	da f7       	brpl	.-10     	; 0x11c2 <__fp_mintl+0x22>
    11cc:	88 0f       	add	r24, r24
    11ce:	96 95       	lsr	r25
    11d0:	87 95       	ror	r24
    11d2:	97 f9       	bld	r25, 7
    11d4:	08 95       	ret

000011d6 <__fp_mpack>:
    11d6:	9f 3f       	cpi	r25, 0xFF	; 255
    11d8:	31 f0       	breq	.+12     	; 0x11e6 <__fp_mpack_finite+0xc>

000011da <__fp_mpack_finite>:
    11da:	91 50       	subi	r25, 0x01	; 1
    11dc:	20 f4       	brcc	.+8      	; 0x11e6 <__fp_mpack_finite+0xc>
    11de:	87 95       	ror	r24
    11e0:	77 95       	ror	r23
    11e2:	67 95       	ror	r22
    11e4:	b7 95       	ror	r27
    11e6:	88 0f       	add	r24, r24
    11e8:	91 1d       	adc	r25, r1
    11ea:	96 95       	lsr	r25
    11ec:	87 95       	ror	r24
    11ee:	97 f9       	bld	r25, 7
    11f0:	08 95       	ret

000011f2 <malloc>:
    11f2:	0f 93       	push	r16
    11f4:	1f 93       	push	r17
    11f6:	cf 93       	push	r28
    11f8:	df 93       	push	r29
    11fa:	82 30       	cpi	r24, 0x02	; 2
    11fc:	91 05       	cpc	r25, r1
    11fe:	10 f4       	brcc	.+4      	; 0x1204 <malloc+0x12>
    1200:	82 e0       	ldi	r24, 0x02	; 2
    1202:	90 e0       	ldi	r25, 0x00	; 0
    1204:	e0 91 5b 3e 	lds	r30, 0x3E5B	; 0x803e5b <__flp>
    1208:	f0 91 5c 3e 	lds	r31, 0x3E5C	; 0x803e5c <__flp+0x1>
    120c:	20 e0       	ldi	r18, 0x00	; 0
    120e:	30 e0       	ldi	r19, 0x00	; 0
    1210:	a0 e0       	ldi	r26, 0x00	; 0
    1212:	b0 e0       	ldi	r27, 0x00	; 0
    1214:	30 97       	sbiw	r30, 0x00	; 0
    1216:	19 f1       	breq	.+70     	; 0x125e <malloc+0x6c>
    1218:	40 81       	ld	r20, Z
    121a:	51 81       	ldd	r21, Z+1	; 0x01
    121c:	02 81       	ldd	r16, Z+2	; 0x02
    121e:	13 81       	ldd	r17, Z+3	; 0x03
    1220:	48 17       	cp	r20, r24
    1222:	59 07       	cpc	r21, r25
    1224:	c8 f0       	brcs	.+50     	; 0x1258 <malloc+0x66>
    1226:	84 17       	cp	r24, r20
    1228:	95 07       	cpc	r25, r21
    122a:	69 f4       	brne	.+26     	; 0x1246 <malloc+0x54>
    122c:	10 97       	sbiw	r26, 0x00	; 0
    122e:	31 f0       	breq	.+12     	; 0x123c <malloc+0x4a>
    1230:	12 96       	adiw	r26, 0x02	; 2
    1232:	0c 93       	st	X, r16
    1234:	12 97       	sbiw	r26, 0x02	; 2
    1236:	13 96       	adiw	r26, 0x03	; 3
    1238:	1c 93       	st	X, r17
    123a:	27 c0       	rjmp	.+78     	; 0x128a <malloc+0x98>
    123c:	00 93 5b 3e 	sts	0x3E5B, r16	; 0x803e5b <__flp>
    1240:	10 93 5c 3e 	sts	0x3E5C, r17	; 0x803e5c <__flp+0x1>
    1244:	22 c0       	rjmp	.+68     	; 0x128a <malloc+0x98>
    1246:	21 15       	cp	r18, r1
    1248:	31 05       	cpc	r19, r1
    124a:	19 f0       	breq	.+6      	; 0x1252 <malloc+0x60>
    124c:	42 17       	cp	r20, r18
    124e:	53 07       	cpc	r21, r19
    1250:	18 f4       	brcc	.+6      	; 0x1258 <malloc+0x66>
    1252:	9a 01       	movw	r18, r20
    1254:	bd 01       	movw	r22, r26
    1256:	ef 01       	movw	r28, r30
    1258:	df 01       	movw	r26, r30
    125a:	f8 01       	movw	r30, r16
    125c:	db cf       	rjmp	.-74     	; 0x1214 <malloc+0x22>
    125e:	21 15       	cp	r18, r1
    1260:	31 05       	cpc	r19, r1
    1262:	f9 f0       	breq	.+62     	; 0x12a2 <malloc+0xb0>
    1264:	28 1b       	sub	r18, r24
    1266:	39 0b       	sbc	r19, r25
    1268:	24 30       	cpi	r18, 0x04	; 4
    126a:	31 05       	cpc	r19, r1
    126c:	80 f4       	brcc	.+32     	; 0x128e <malloc+0x9c>
    126e:	8a 81       	ldd	r24, Y+2	; 0x02
    1270:	9b 81       	ldd	r25, Y+3	; 0x03
    1272:	61 15       	cp	r22, r1
    1274:	71 05       	cpc	r23, r1
    1276:	21 f0       	breq	.+8      	; 0x1280 <malloc+0x8e>
    1278:	fb 01       	movw	r30, r22
    127a:	82 83       	std	Z+2, r24	; 0x02
    127c:	93 83       	std	Z+3, r25	; 0x03
    127e:	04 c0       	rjmp	.+8      	; 0x1288 <malloc+0x96>
    1280:	80 93 5b 3e 	sts	0x3E5B, r24	; 0x803e5b <__flp>
    1284:	90 93 5c 3e 	sts	0x3E5C, r25	; 0x803e5c <__flp+0x1>
    1288:	fe 01       	movw	r30, r28
    128a:	32 96       	adiw	r30, 0x02	; 2
    128c:	44 c0       	rjmp	.+136    	; 0x1316 <malloc+0x124>
    128e:	fe 01       	movw	r30, r28
    1290:	e2 0f       	add	r30, r18
    1292:	f3 1f       	adc	r31, r19
    1294:	81 93       	st	Z+, r24
    1296:	91 93       	st	Z+, r25
    1298:	22 50       	subi	r18, 0x02	; 2
    129a:	31 09       	sbc	r19, r1
    129c:	28 83       	st	Y, r18
    129e:	39 83       	std	Y+1, r19	; 0x01
    12a0:	3a c0       	rjmp	.+116    	; 0x1316 <malloc+0x124>
    12a2:	20 91 59 3e 	lds	r18, 0x3E59	; 0x803e59 <__brkval>
    12a6:	30 91 5a 3e 	lds	r19, 0x3E5A	; 0x803e5a <__brkval+0x1>
    12aa:	23 2b       	or	r18, r19
    12ac:	41 f4       	brne	.+16     	; 0x12be <malloc+0xcc>
    12ae:	20 91 02 3e 	lds	r18, 0x3E02	; 0x803e02 <__malloc_heap_start>
    12b2:	30 91 03 3e 	lds	r19, 0x3E03	; 0x803e03 <__malloc_heap_start+0x1>
    12b6:	20 93 59 3e 	sts	0x3E59, r18	; 0x803e59 <__brkval>
    12ba:	30 93 5a 3e 	sts	0x3E5A, r19	; 0x803e5a <__brkval+0x1>
    12be:	20 91 00 3e 	lds	r18, 0x3E00	; 0x803e00 <__data_start>
    12c2:	30 91 01 3e 	lds	r19, 0x3E01	; 0x803e01 <__data_start+0x1>
    12c6:	21 15       	cp	r18, r1
    12c8:	31 05       	cpc	r19, r1
    12ca:	41 f4       	brne	.+16     	; 0x12dc <malloc+0xea>
    12cc:	2d b7       	in	r18, 0x3d	; 61
    12ce:	3e b7       	in	r19, 0x3e	; 62
    12d0:	40 91 04 3e 	lds	r20, 0x3E04	; 0x803e04 <__malloc_margin>
    12d4:	50 91 05 3e 	lds	r21, 0x3E05	; 0x803e05 <__malloc_margin+0x1>
    12d8:	24 1b       	sub	r18, r20
    12da:	35 0b       	sbc	r19, r21
    12dc:	e0 91 59 3e 	lds	r30, 0x3E59	; 0x803e59 <__brkval>
    12e0:	f0 91 5a 3e 	lds	r31, 0x3E5A	; 0x803e5a <__brkval+0x1>
    12e4:	e2 17       	cp	r30, r18
    12e6:	f3 07       	cpc	r31, r19
    12e8:	a0 f4       	brcc	.+40     	; 0x1312 <malloc+0x120>
    12ea:	2e 1b       	sub	r18, r30
    12ec:	3f 0b       	sbc	r19, r31
    12ee:	28 17       	cp	r18, r24
    12f0:	39 07       	cpc	r19, r25
    12f2:	78 f0       	brcs	.+30     	; 0x1312 <malloc+0x120>
    12f4:	ac 01       	movw	r20, r24
    12f6:	4e 5f       	subi	r20, 0xFE	; 254
    12f8:	5f 4f       	sbci	r21, 0xFF	; 255
    12fa:	24 17       	cp	r18, r20
    12fc:	35 07       	cpc	r19, r21
    12fe:	48 f0       	brcs	.+18     	; 0x1312 <malloc+0x120>
    1300:	4e 0f       	add	r20, r30
    1302:	5f 1f       	adc	r21, r31
    1304:	40 93 59 3e 	sts	0x3E59, r20	; 0x803e59 <__brkval>
    1308:	50 93 5a 3e 	sts	0x3E5A, r21	; 0x803e5a <__brkval+0x1>
    130c:	81 93       	st	Z+, r24
    130e:	91 93       	st	Z+, r25
    1310:	02 c0       	rjmp	.+4      	; 0x1316 <malloc+0x124>
    1312:	e0 e0       	ldi	r30, 0x00	; 0
    1314:	f0 e0       	ldi	r31, 0x00	; 0
    1316:	cf 01       	movw	r24, r30
    1318:	df 91       	pop	r29
    131a:	cf 91       	pop	r28
    131c:	1f 91       	pop	r17
    131e:	0f 91       	pop	r16
    1320:	08 95       	ret

00001322 <free>:
    1322:	cf 93       	push	r28
    1324:	df 93       	push	r29
    1326:	00 97       	sbiw	r24, 0x00	; 0
    1328:	09 f4       	brne	.+2      	; 0x132c <free+0xa>
    132a:	81 c0       	rjmp	.+258    	; 0x142e <free+0x10c>
    132c:	fc 01       	movw	r30, r24
    132e:	32 97       	sbiw	r30, 0x02	; 2
    1330:	12 82       	std	Z+2, r1	; 0x02
    1332:	13 82       	std	Z+3, r1	; 0x03
    1334:	a0 91 5b 3e 	lds	r26, 0x3E5B	; 0x803e5b <__flp>
    1338:	b0 91 5c 3e 	lds	r27, 0x3E5C	; 0x803e5c <__flp+0x1>
    133c:	10 97       	sbiw	r26, 0x00	; 0
    133e:	81 f4       	brne	.+32     	; 0x1360 <free+0x3e>
    1340:	20 81       	ld	r18, Z
    1342:	31 81       	ldd	r19, Z+1	; 0x01
    1344:	82 0f       	add	r24, r18
    1346:	93 1f       	adc	r25, r19
    1348:	20 91 59 3e 	lds	r18, 0x3E59	; 0x803e59 <__brkval>
    134c:	30 91 5a 3e 	lds	r19, 0x3E5A	; 0x803e5a <__brkval+0x1>
    1350:	28 17       	cp	r18, r24
    1352:	39 07       	cpc	r19, r25
    1354:	51 f5       	brne	.+84     	; 0x13aa <free+0x88>
    1356:	e0 93 59 3e 	sts	0x3E59, r30	; 0x803e59 <__brkval>
    135a:	f0 93 5a 3e 	sts	0x3E5A, r31	; 0x803e5a <__brkval+0x1>
    135e:	67 c0       	rjmp	.+206    	; 0x142e <free+0x10c>
    1360:	ed 01       	movw	r28, r26
    1362:	20 e0       	ldi	r18, 0x00	; 0
    1364:	30 e0       	ldi	r19, 0x00	; 0
    1366:	ce 17       	cp	r28, r30
    1368:	df 07       	cpc	r29, r31
    136a:	40 f4       	brcc	.+16     	; 0x137c <free+0x5a>
    136c:	4a 81       	ldd	r20, Y+2	; 0x02
    136e:	5b 81       	ldd	r21, Y+3	; 0x03
    1370:	9e 01       	movw	r18, r28
    1372:	41 15       	cp	r20, r1
    1374:	51 05       	cpc	r21, r1
    1376:	f1 f0       	breq	.+60     	; 0x13b4 <free+0x92>
    1378:	ea 01       	movw	r28, r20
    137a:	f5 cf       	rjmp	.-22     	; 0x1366 <free+0x44>
    137c:	c2 83       	std	Z+2, r28	; 0x02
    137e:	d3 83       	std	Z+3, r29	; 0x03
    1380:	40 81       	ld	r20, Z
    1382:	51 81       	ldd	r21, Z+1	; 0x01
    1384:	84 0f       	add	r24, r20
    1386:	95 1f       	adc	r25, r21
    1388:	c8 17       	cp	r28, r24
    138a:	d9 07       	cpc	r29, r25
    138c:	59 f4       	brne	.+22     	; 0x13a4 <free+0x82>
    138e:	88 81       	ld	r24, Y
    1390:	99 81       	ldd	r25, Y+1	; 0x01
    1392:	84 0f       	add	r24, r20
    1394:	95 1f       	adc	r25, r21
    1396:	02 96       	adiw	r24, 0x02	; 2
    1398:	80 83       	st	Z, r24
    139a:	91 83       	std	Z+1, r25	; 0x01
    139c:	8a 81       	ldd	r24, Y+2	; 0x02
    139e:	9b 81       	ldd	r25, Y+3	; 0x03
    13a0:	82 83       	std	Z+2, r24	; 0x02
    13a2:	93 83       	std	Z+3, r25	; 0x03
    13a4:	21 15       	cp	r18, r1
    13a6:	31 05       	cpc	r19, r1
    13a8:	29 f4       	brne	.+10     	; 0x13b4 <free+0x92>
    13aa:	e0 93 5b 3e 	sts	0x3E5B, r30	; 0x803e5b <__flp>
    13ae:	f0 93 5c 3e 	sts	0x3E5C, r31	; 0x803e5c <__flp+0x1>
    13b2:	3d c0       	rjmp	.+122    	; 0x142e <free+0x10c>
    13b4:	e9 01       	movw	r28, r18
    13b6:	ea 83       	std	Y+2, r30	; 0x02
    13b8:	fb 83       	std	Y+3, r31	; 0x03
    13ba:	49 91       	ld	r20, Y+
    13bc:	59 91       	ld	r21, Y+
    13be:	c4 0f       	add	r28, r20
    13c0:	d5 1f       	adc	r29, r21
    13c2:	ec 17       	cp	r30, r28
    13c4:	fd 07       	cpc	r31, r29
    13c6:	61 f4       	brne	.+24     	; 0x13e0 <free+0xbe>
    13c8:	80 81       	ld	r24, Z
    13ca:	91 81       	ldd	r25, Z+1	; 0x01
    13cc:	84 0f       	add	r24, r20
    13ce:	95 1f       	adc	r25, r21
    13d0:	02 96       	adiw	r24, 0x02	; 2
    13d2:	e9 01       	movw	r28, r18
    13d4:	88 83       	st	Y, r24
    13d6:	99 83       	std	Y+1, r25	; 0x01
    13d8:	82 81       	ldd	r24, Z+2	; 0x02
    13da:	93 81       	ldd	r25, Z+3	; 0x03
    13dc:	8a 83       	std	Y+2, r24	; 0x02
    13de:	9b 83       	std	Y+3, r25	; 0x03
    13e0:	e0 e0       	ldi	r30, 0x00	; 0
    13e2:	f0 e0       	ldi	r31, 0x00	; 0
    13e4:	12 96       	adiw	r26, 0x02	; 2
    13e6:	8d 91       	ld	r24, X+
    13e8:	9c 91       	ld	r25, X
    13ea:	13 97       	sbiw	r26, 0x03	; 3
    13ec:	00 97       	sbiw	r24, 0x00	; 0
    13ee:	19 f0       	breq	.+6      	; 0x13f6 <free+0xd4>
    13f0:	fd 01       	movw	r30, r26
    13f2:	dc 01       	movw	r26, r24
    13f4:	f7 cf       	rjmp	.-18     	; 0x13e4 <free+0xc2>
    13f6:	8d 91       	ld	r24, X+
    13f8:	9c 91       	ld	r25, X
    13fa:	11 97       	sbiw	r26, 0x01	; 1
    13fc:	9d 01       	movw	r18, r26
    13fe:	2e 5f       	subi	r18, 0xFE	; 254
    1400:	3f 4f       	sbci	r19, 0xFF	; 255
    1402:	82 0f       	add	r24, r18
    1404:	93 1f       	adc	r25, r19
    1406:	20 91 59 3e 	lds	r18, 0x3E59	; 0x803e59 <__brkval>
    140a:	30 91 5a 3e 	lds	r19, 0x3E5A	; 0x803e5a <__brkval+0x1>
    140e:	28 17       	cp	r18, r24
    1410:	39 07       	cpc	r19, r25
    1412:	69 f4       	brne	.+26     	; 0x142e <free+0x10c>
    1414:	30 97       	sbiw	r30, 0x00	; 0
    1416:	29 f4       	brne	.+10     	; 0x1422 <free+0x100>
    1418:	10 92 5b 3e 	sts	0x3E5B, r1	; 0x803e5b <__flp>
    141c:	10 92 5c 3e 	sts	0x3E5C, r1	; 0x803e5c <__flp+0x1>
    1420:	02 c0       	rjmp	.+4      	; 0x1426 <free+0x104>
    1422:	12 82       	std	Z+2, r1	; 0x02
    1424:	13 82       	std	Z+3, r1	; 0x03
    1426:	a0 93 59 3e 	sts	0x3E59, r26	; 0x803e59 <__brkval>
    142a:	b0 93 5a 3e 	sts	0x3E5A, r27	; 0x803e5a <__brkval+0x1>
    142e:	df 91       	pop	r29
    1430:	cf 91       	pop	r28
    1432:	08 95       	ret

00001434 <_exit>:
    1434:	f8 94       	cli

00001436 <__stop_program>:
    1436:	ff cf       	rjmp	.-2      	; 0x1436 <__stop_program>
