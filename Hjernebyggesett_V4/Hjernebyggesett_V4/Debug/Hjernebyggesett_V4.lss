
Hjernebyggesett_V4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000016  00803800  00001ad8  00001b8c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001aa6  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000032  00009aa6  00001aa6  00001b5a  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .bss          0000005c  00803816  00803816  00001ba2  2**0
                  ALLOC
  4 .comment      00000030  00000000  00000000  00001ba2  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001bd4  2**2
                  CONTENTS, READONLY
  6 .debug_aranges 00000568  00000000  00000000  00001c18  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00008bf3  00000000  00000000  00002180  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00003726  00000000  00000000  0000ad73  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00002cae  00000000  00000000  0000e499  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  0000095c  00000000  00000000  00011148  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000370d  00000000  00000000  00011aa4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000015bc  00000000  00000000  000151b1  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 000003e8  00000000  00000000  0001676d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 61 00 	jmp	0xc2	; 0xc2 <__ctors_end>
       4:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
       8:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
       c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      10:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      14:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      18:	0c 94 36 05 	jmp	0xa6c	; 0xa6c <__vector_6>
      1c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      20:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      24:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      28:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      2c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      30:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      34:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      38:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      3c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      40:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      44:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      48:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      4c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      50:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      54:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      58:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      5c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      60:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      64:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      68:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      6c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      70:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      74:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      78:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      7c:	07 63       	ori	r16, 0x37	; 55
      7e:	42 36       	cpi	r20, 0x62	; 98
      80:	b7 9b       	sbis	0x16, 7	; 22
      82:	d8 a7       	std	Y+40, r29	; 0x28
      84:	1a 39       	cpi	r17, 0x9A	; 154
      86:	68 56       	subi	r22, 0x68	; 104
      88:	18 ae       	std	Y+56, r1	; 0x38
      8a:	ba ab       	std	Y+50, r27	; 0x32
      8c:	55 8c       	ldd	r5, Z+29	; 0x1d
      8e:	1d 3c       	cpi	r17, 0xCD	; 205
      90:	b7 cc       	rjmp	.-1682   	; 0xfffffa00 <__eeprom_end+0xff7efa00>
      92:	57 63       	ori	r21, 0x37	; 55
      94:	bd 6d       	ori	r27, 0xDD	; 221
      96:	ed fd       	.word	0xfded	; ????
      98:	75 3e       	cpi	r23, 0xE5	; 229
      9a:	f6 17       	cp	r31, r22
      9c:	72 31       	cpi	r23, 0x12	; 18
      9e:	bf 00       	.word	0x00bf	; ????
      a0:	00 00       	nop
      a2:	80 3f       	cpi	r24, 0xF0	; 240
      a4:	05 a8       	ldd	r0, Z+53	; 0x35
      a6:	4c cd       	rjmp	.-1384   	; 0xfffffb40 <__eeprom_end+0xff7efb40>
      a8:	b2 d4       	rcall	.+2404   	; 0xa0e <tinyDendrite_get_potential+0x32>
      aa:	4e b9       	out	0x0e, r20	; 14
      ac:	38 36       	cpi	r19, 0x68	; 104
      ae:	a9 02       	muls	r26, r25
      b0:	0c 50       	subi	r16, 0x0C	; 12
      b2:	b9 91       	ld	r27, Y+
      b4:	86 88       	ldd	r8, Z+22	; 0x16
      b6:	08 3c       	cpi	r16, 0xC8	; 200
      b8:	a6 aa       	std	Z+54, r10	; 0x36
      ba:	aa 2a       	or	r10, r26
      bc:	be 00       	.word	0x00be	; ????
      be:	00 00       	nop
      c0:	80 3f       	cpi	r24, 0xF0	; 240

000000c2 <__ctors_end>:
      c2:	11 24       	eor	r1, r1
      c4:	1f be       	out	0x3f, r1	; 63
      c6:	cf ef       	ldi	r28, 0xFF	; 255
      c8:	cd bf       	out	0x3d, r28	; 61
      ca:	df e3       	ldi	r29, 0x3F	; 63
      cc:	de bf       	out	0x3e, r29	; 62

000000ce <__do_copy_data>:
      ce:	18 e3       	ldi	r17, 0x38	; 56
      d0:	a0 e0       	ldi	r26, 0x00	; 0
      d2:	b8 e3       	ldi	r27, 0x38	; 56
      d4:	e8 ed       	ldi	r30, 0xD8	; 216
      d6:	fa e1       	ldi	r31, 0x1A	; 26
      d8:	02 c0       	rjmp	.+4      	; 0xde <__do_copy_data+0x10>
      da:	05 90       	lpm	r0, Z+
      dc:	0d 92       	st	X+, r0
      de:	a6 31       	cpi	r26, 0x16	; 22
      e0:	b1 07       	cpc	r27, r17
      e2:	d9 f7       	brne	.-10     	; 0xda <__do_copy_data+0xc>

000000e4 <__do_clear_bss>:
      e4:	28 e3       	ldi	r18, 0x38	; 56
      e6:	a6 e1       	ldi	r26, 0x16	; 22
      e8:	b8 e3       	ldi	r27, 0x38	; 56
      ea:	01 c0       	rjmp	.+2      	; 0xee <.do_clear_bss_start>

000000ec <.do_clear_bss_loop>:
      ec:	1d 92       	st	X+, r1

000000ee <.do_clear_bss_start>:
      ee:	a2 37       	cpi	r26, 0x72	; 114
      f0:	b2 07       	cpc	r27, r18
      f2:	e1 f7       	brne	.-8      	; 0xec <.do_clear_bss_loop>
      f4:	0e 94 83 00 	call	0x106	; 0x106 <main>
      f8:	0c 94 51 0d 	jmp	0x1aa2	; 0x1aa2 <_exit>

000000fc <__bad_interrupt>:
      fc:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000100 <atmel_start_init>:
/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
	system_init();
     100:	0e 94 b2 01 	call	0x364	; 0x364 <system_init>
     104:	08 95       	ret

00000106 <main>:

int main(void)
{	
	
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
     106:	0e 94 80 00 	call	0x100	; 0x100 <atmel_start_init>
	Setting this value will mean that the ADC (Analog to Digital Converter) will read 4.32v as 255, and 0v as 0.
	For some reason, instead of the reference voltage being 4.32v, it is 3.3v. 
	A plausible explanation is that the microchip does not up the voltage, so that if the microchip is only ever 
	supplied with 3.3v, it will output 3.3v as the max.
	*/
	VREF.CTRLA |= VREF_DAC0REFSEL_4V34_gc;
     10a:	e0 ea       	ldi	r30, 0xA0	; 160
     10c:	f0 e0       	ldi	r31, 0x00	; 0
     10e:	80 81       	ld	r24, Z
     110:	83 60       	ori	r24, 0x03	; 3
     112:	80 83       	st	Z, r24
	
	//tinyTester_test();
	
	tinySleep_prepare_sleep();
     114:	0e 94 63 09 	call	0x12c6	; 0x12c6 <tinySleep_prepare_sleep>
	
	tinySleep_enter_sleep();
     118:	0e 94 6c 09 	call	0x12d8	; 0x12d8 <tinySleep_enter_sleep>
	
	while (1)
	{
		// We don't want to update the neuron too often because of various reasons. The tinyISR_getflag is set every ms, and so the loop is only run once every ms.  
		if(tinyISR_getflag())
     11c:	0e 94 64 05 	call	0xac8	; 0xac8 <tinyISR_getflag>
     120:	88 23       	and	r24, r24
     122:	e1 f3       	breq	.-8      	; 0x11c <main+0x16>
		{
			//Testing sleep mode
			//tinySleep_enter_sleep();
			tinyCharge_update_charging_mode();
     124:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <tinyCharge_update_charging_mode>
			
			if(tinyCharge_is_connected_to_charger()){
     128:	0e 94 bf 03 	call	0x77e	; 0x77e <tinyCharge_is_connected_to_charger>
     12c:	88 23       	and	r24, r24
     12e:	b9 f0       	breq	.+46     	; 0x15e <main+0x58>
				// Charge loop
				
				if(tinyCharge_is_fully_charged()){
     130:	0e 94 c2 03 	call	0x784	; 0x784 <tinyCharge_is_fully_charged>
     134:	88 23       	and	r24, r24
     136:	49 f0       	breq	.+18     	; 0x14a <main+0x44>
					// When the neuron is connected to a charger, and fully charged:
					tinyLED_set_color(INN_LED, CHARGING_DONE_COLOR);
     138:	64 e0       	ldi	r22, 0x04	; 4
     13a:	80 e0       	ldi	r24, 0x00	; 0
     13c:	0e 94 ab 05 	call	0xb56	; 0xb56 <tinyLED_set_color>
					tinyLED_set_color(OUT_LED, LED_OFF);
     140:	60 e0       	ldi	r22, 0x00	; 0
     142:	81 e0       	ldi	r24, 0x01	; 1
     144:	0e 94 ab 05 	call	0xb56	; 0xb56 <tinyLED_set_color>
     148:	1a c0       	rjmp	.+52     	; 0x17e <main+0x78>
				}
				else{
					// When the neuron is charging and is not fully charged
					tinyLED_set_color_mode(OUT_LED, CHARGING_COLOR, SWING);
     14a:	43 e0       	ldi	r20, 0x03	; 3
     14c:	62 e0       	ldi	r22, 0x02	; 2
     14e:	81 e0       	ldi	r24, 0x01	; 1
     150:	0e 94 83 05 	call	0xb06	; 0xb06 <tinyLED_set_color_mode>
					tinyLED_set_color(INN_LED, LED_OFF);
     154:	60 e0       	ldi	r22, 0x00	; 0
     156:	80 e0       	ldi	r24, 0x00	; 0
     158:	0e 94 ab 05 	call	0xb56	; 0xb56 <tinyLED_set_color>
     15c:	10 c0       	rjmp	.+32     	; 0x17e <main+0x78>
				// Main loop			
				
				// Set LED
				// If the out led is turned LED_OFF, and the ping color is not disabled,
				// we turn on ping mode
				if(tinyLED_get_color(OUT_LED) == LED_OFF && PING_COLOR != LED_OFF){
     15e:	81 e0       	ldi	r24, 0x01	; 1
     160:	0e 94 7b 05 	call	0xaf6	; 0xaf6 <tinyLED_get_color>
					tinyLED_set_color_mode(OUT_LED, PING_COLOR, PING);
				}
				if(tinyLED_get_color(INN_LED) == LED_OFF){
     164:	80 e0       	ldi	r24, 0x00	; 0
     166:	0e 94 7b 05 	call	0xaf6	; 0xaf6 <tinyLED_get_color>
     16a:	81 11       	cpse	r24, r1
     16c:	04 c0       	rjmp	.+8      	; 0x176 <main+0x70>
					// Display potential level with LED
					tinyLED_set_color_mode(INN_LED, CHANGING_COLOR, POTENTIAL);
     16e:	46 e0       	ldi	r20, 0x06	; 6
     170:	61 e0       	ldi	r22, 0x01	; 1
     172:	0e 94 83 05 	call	0xb06	; 0xb06 <tinyLED_set_color_mode>
				}
				
				// Update button	
				tinyButton_update();
     176:	0e 94 59 03 	call	0x6b2	; 0x6b2 <tinyButton_update>
				
				// Update the potential (This is where most of the important stuff happens)
				tinyPotential_update();
     17a:	0e 94 88 08 	call	0x1110	; 0x1110 <tinyPotential_update>
			}
			
			// Update LED
			tinyLED_update();
     17e:	0e 94 df 05 	call	0xbbe	; 0xbbe <tinyLED_update>
				
			// Switch transistors
			tinyCharge_set_transistors();
     182:	0e 94 34 04 	call	0x868	; 0x868 <tinyCharge_set_transistors>
			
			// Prepare for next cycle
			tinyISR_setflag(false);
     186:	80 e0       	ldi	r24, 0x00	; 0
     188:	0e 94 61 05 	call	0xac2	; 0xac2 <tinyISR_setflag>
			tinyDebugger_send_uint32("time", tinyTime_now());
     18c:	0e 94 89 09 	call	0x1312	; 0x1312 <tinyTime_now>
     190:	ab 01       	movw	r20, r22
     192:	bc 01       	movw	r22, r24
     194:	86 ea       	ldi	r24, 0xA6	; 166
     196:	9a e9       	ldi	r25, 0x9A	; 154
     198:	0e 94 3f 04 	call	0x87e	; 0x87e <tinyDebugger_send_uint32>
			tinyDebugger_end_line();
     19c:	0e 94 42 04 	call	0x884	; 0x884 <tinyDebugger_end_line>
     1a0:	bd cf       	rjmp	.-134    	; 0x11c <main+0x16>

000001a2 <ADC_0_init>:
 * \return Conversion result read from the ADC_0 ADC module
 */
adc_result_t ADC_0_get_conversion_result(void)
{
	return (ADC1.RES);
}
     1a2:	e0 e4       	ldi	r30, 0x40	; 64
     1a4:	f6 e0       	ldi	r31, 0x06	; 6
     1a6:	80 e1       	ldi	r24, 0x10	; 16
     1a8:	82 83       	std	Z+2, r24	; 0x02
     1aa:	85 e0       	ldi	r24, 0x05	; 5
     1ac:	80 83       	st	Z, r24
     1ae:	80 e0       	ldi	r24, 0x00	; 0
     1b0:	08 95       	ret

000001b2 <ADC_0_is_conversion_done>:
     1b2:	80 91 4b 06 	lds	r24, 0x064B	; 0x80064b <__TEXT_REGION_LENGTH__+0x70064b>
     1b6:	81 70       	andi	r24, 0x01	; 1
     1b8:	08 95       	ret

000001ba <ADC_0_get_conversion>:
 *
 * \return Nothing
 */
void ADC_0_start_conversion(adc_1_channel_t channel)
{
	ADC1.MUXPOS  = channel;
     1ba:	e0 e4       	ldi	r30, 0x40	; 64
     1bc:	f6 e0       	ldi	r31, 0x06	; 6
     1be:	86 83       	std	Z+6, r24	; 0x06
	ADC1.COMMAND = ADC_STCONV_bm;
     1c0:	81 e0       	ldi	r24, 0x01	; 1
     1c2:	80 87       	std	Z+8, r24	; 0x08
adc_result_t ADC_0_get_conversion(adc_1_channel_t channel)
{
	adc_result_t res;

	ADC_0_start_conversion(channel);
	while (!ADC_0_is_conversion_done())
     1c4:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <ADC_0_is_conversion_done>
     1c8:	88 23       	and	r24, r24
     1ca:	e1 f3       	breq	.-8      	; 0x1c4 <ADC_0_get_conversion+0xa>
 *
 * \return Conversion result read from the ADC_0 ADC module
 */
adc_result_t ADC_0_get_conversion_result(void)
{
	return (ADC1.RES);
     1cc:	e0 e4       	ldi	r30, 0x40	; 64
     1ce:	f6 e0       	ldi	r31, 0x06	; 6
     1d0:	20 89       	ldd	r18, Z+16	; 0x10
     1d2:	31 89       	ldd	r19, Z+17	; 0x11

	ADC_0_start_conversion(channel);
	while (!ADC_0_is_conversion_done())
		;
	res = ADC_0_get_conversion_result();
	ADC1.INTFLAGS |= ADC_RESRDY_bm;
     1d4:	93 85       	ldd	r25, Z+11	; 0x0b
     1d6:	91 60       	ori	r25, 0x01	; 1
     1d8:	93 87       	std	Z+11, r25	; 0x0b
	return res;
}
     1da:	c9 01       	movw	r24, r18
     1dc:	08 95       	ret

000001de <BOD_init>:
	//		 | BOD_VLMCFG_BELOW_gc; /* Interrupt when supply goes below VLM level */

	// BOD.VLMCTRLA = BOD_VLMLVL_5ABOVE_gc; /* VLM threshold 5% above BOD level */

	return 0;
}
     1de:	80 e0       	ldi	r24, 0x00	; 0
     1e0:	08 95       	ret

000001e2 <DIGITAL_GLUE_LOGIC_0_init>:

	// Enable Protected register, peripheral must be disabled (ENABLE=0, in TCD.LUT0CTRLA).

	// CCL.SEQCTRL0 = CCL_SEQSEL_DISABLE_gc /* Sequential logic disabled */;

	CCL.TRUTH0 = 168; /* Truth 0: 168 */
     1e2:	e0 ec       	ldi	r30, 0xC0	; 192
     1e4:	f1 e0       	ldi	r31, 0x01	; 1
     1e6:	28 ea       	ldi	r18, 0xA8	; 168
     1e8:	20 87       	std	Z+8, r18	; 0x08

	CCL.LUT0CTRLC = CCL_INSEL2_TCA0_gc /* TCA0 WO2 input source */;
     1ea:	98 e0       	ldi	r25, 0x08	; 8
     1ec:	97 83       	std	Z+7, r25	; 0x07

	CCL.LUT0CTRLB = CCL_INSEL0_SPI0_gc /* SPI0 SCK source */
     1ee:	8b eb       	ldi	r24, 0xBB	; 187
     1f0:	86 83       	std	Z+6, r24	; 0x06
	                | CCL_INSEL1_SPI0_gc /* SPI0 MOSI input source */;

	CCL.LUT0CTRLA = 0 << CCL_CLKSRC_bp       /* Clock Source Selection: disabled */
     1f2:	39 e0       	ldi	r19, 0x09	; 9
     1f4:	35 83       	std	Z+5, r19	; 0x05
	                | CCL_EDGEDET_DIS_gc     /* Edge detector is disabled */
	                | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	                | 1 << CCL_ENABLE_bp     /* LUT Enable: enabled */
	                | 1 << CCL_OUTEN_bp;     /* Output Enable: enabled */

	CCL.TRUTH1 = 168; /* Truth 1: 168 */
     1f6:	24 87       	std	Z+12, r18	; 0x0c

	CCL.LUT1CTRLC = CCL_INSEL2_TCA0_gc /* TCA0 WO2 input source */;
     1f8:	93 87       	std	Z+11, r25	; 0x0b

	CCL.LUT1CTRLB = CCL_INSEL0_SPI0_gc /* SPI0 SCK source */
     1fa:	82 87       	std	Z+10, r24	; 0x0a
	//		 | CCL_EDGEDET_DIS_gc /* Edge detector is disabled */
	//		 | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	//		 | 0 << CCL_ENABLE_bp /* LUT Enable: disabled */
	//		 | 0 << CCL_OUTEN_bp; /* Output Enable: disabled */

	CCL.CTRLA = 1 << CCL_ENABLE_bp      /* Enable: enabled */
     1fc:	81 e4       	ldi	r24, 0x41	; 65
     1fe:	80 83       	st	Z, r24
	            | 1 << CCL_RUNSTDBY_bp; /* Run in Standby: enabled */

	return 0;
}
     200:	80 e0       	ldi	r24, 0x00	; 0
     202:	08 95       	ret

00000204 <CLKCTRL_init>:
 *       on calling convention. The memory model is not visible to the
 *       preprocessor, so it must be defined in the Assembler preprocessor directives.
 */
static inline void ccp_write_io(void *addr, uint8_t value)
{
	protected_write_io(addr, CCP_IOREG_gc, value);
     204:	47 e0       	ldi	r20, 0x07	; 7
     206:	68 ed       	ldi	r22, 0xD8	; 216
     208:	8c e7       	ldi	r24, 0x7C	; 124
     20a:	90 e0       	ldi	r25, 0x00	; 0
     20c:	0e 94 e1 01 	call	0x3c2	; 0x3c2 <protected_write_io>
     210:	41 e0       	ldi	r20, 0x01	; 1
     212:	68 ed       	ldi	r22, 0xD8	; 216
     214:	81 e6       	ldi	r24, 0x61	; 97
     216:	90 e0       	ldi	r25, 0x00	; 0
     218:	0e 94 e1 01 	call	0x3c2	; 0x3c2 <protected_write_io>
	//		 | 0 << CLKCTRL_CLKOUT_bp /* System clock out: disabled */);

	// ccp_write_io((void*)&(CLKCTRL.MCLKLOCK),0 << CLKCTRL_LOCKEN_bp /* lock enable: disabled */);

	return 0;
}
     21c:	80 e0       	ldi	r24, 0x00	; 0
     21e:	08 95       	ret

00000220 <CPUINT_init>:

	// CPUINT.LVL0PRI = 0x0 << CPUINT_LVL0PRI_gp; /* Interrupt Level Priority: 0x0 */

	// CPUINT.LVL1VEC = 0x0 << CPUINT_LVL1VEC_gp; /* Interrupt Vector with High Priority: 0x0 */

	ENABLE_INTERRUPTS();
     220:	78 94       	sei

	return 0;
}
     222:	80 e0       	ldi	r24, 0x00	; 0
     224:	08 95       	ret

00000226 <DAC_0_init>:
int8_t DAC_0_init()
{

	// DAC0.DATA = 0x0; /* DATA Register: 0x0 */

	DAC0.CTRLA = 1 << DAC_ENABLE_bp      /* DAC Enable: enabled */
     226:	81 e4       	ldi	r24, 0x41	; 65
     228:	80 93 a0 06 	sts	0x06A0, r24	; 0x8006a0 <__TEXT_REGION_LENGTH__+0x7006a0>
	             | 1 << DAC_OUTEN_bp     /* Output Buffer Enable: enabled */
	             | 0 << DAC_RUNSTDBY_bp; /* Run in Standby Mode: disabled */

	return 0;
}
     22c:	80 e0       	ldi	r24, 0x00	; 0
     22e:	08 95       	ret

00000230 <DAC_0_uninit>:
int8_t DAC_0_uninit()
{

	// DAC0.DATA = 0x0; /* DATA Register: 0x0 */

	DAC0.CTRLA = 1 << DAC_ENABLE_bp      /* DAC Enable: enabled */
     230:	81 e0       	ldi	r24, 0x01	; 1
     232:	80 93 a0 06 	sts	0x06A0, r24	; 0x8006a0 <__TEXT_REGION_LENGTH__+0x7006a0>
	| 0 << DAC_OUTEN_bp     /* Output Buffer Enable: disabled */
	| 0 << DAC_RUNSTDBY_bp; /* Run in Standby Mode: disabled */

	return 0;
}
     236:	80 e0       	ldi	r24, 0x00	; 0
     238:	08 95       	ret

0000023a <DAC_0_enable>:
 *
 * \return Nothing
 */
void DAC_0_enable()
{
	DAC0.CTRLA |= DAC_ENABLE_bm;
     23a:	e0 ea       	ldi	r30, 0xA0	; 160
     23c:	f6 e0       	ldi	r31, 0x06	; 6
     23e:	80 81       	ld	r24, Z
     240:	81 60       	ori	r24, 0x01	; 1
     242:	80 83       	st	Z, r24
     244:	08 95       	ret

00000246 <DAC_0_disable>:
 *
 * \return Nothing
 */
void DAC_0_disable()
{
	DAC0.CTRLA &= ~DAC_ENABLE_bm;
     246:	e0 ea       	ldi	r30, 0xA0	; 160
     248:	f6 e0       	ldi	r31, 0x06	; 6
     24a:	80 81       	ld	r24, Z
     24c:	8e 7f       	andi	r24, 0xFE	; 254
     24e:	80 83       	st	Z, r24
     250:	08 95       	ret

00000252 <DAC_0_set_output>:
 *
 * \return Nothing
 */
void DAC_0_set_output(dac_resolution_t value)
{
	DAC0.DATA = value;
     252:	80 93 a1 06 	sts	0x06A1, r24	; 0x8006a1 <__TEXT_REGION_LENGTH__+0x7006a1>
     256:	08 95       	ret

00000258 <mcu_init>:
#ifdef __cplusplus
extern "C" {
#endif

void mcu_init(void)
{
     258:	e0 e1       	ldi	r30, 0x10	; 16
     25a:	f4 e0       	ldi	r31, 0x04	; 4
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     25c:	80 81       	ld	r24, Z
     25e:	88 60       	ori	r24, 0x08	; 8
     260:	81 93       	st	Z+, r24
	 * disables all peripherals to save power. Driver shall enable
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
     262:	e8 31       	cpi	r30, 0x18	; 24
     264:	84 e0       	ldi	r24, 0x04	; 4
     266:	f8 07       	cpc	r31, r24
     268:	c9 f7       	brne	.-14     	; 0x25c <mcu_init+0x4>
     26a:	e0 e3       	ldi	r30, 0x30	; 48
     26c:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     26e:	80 81       	ld	r24, Z
     270:	88 60       	ori	r24, 0x08	; 8
     272:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     274:	e8 33       	cpi	r30, 0x38	; 56
     276:	84 e0       	ldi	r24, 0x04	; 4
     278:	f8 07       	cpc	r31, r24
     27a:	c9 f7       	brne	.-14     	; 0x26e <mcu_init+0x16>
     27c:	e0 e5       	ldi	r30, 0x50	; 80
     27e:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     280:	80 81       	ld	r24, Z
     282:	88 60       	ori	r24, 0x08	; 8
     284:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     286:	e8 35       	cpi	r30, 0x58	; 88
     288:	84 e0       	ldi	r24, 0x04	; 4
     28a:	f8 07       	cpc	r31, r24
     28c:	c9 f7       	brne	.-14     	; 0x280 <mcu_init+0x28>
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}
}
     28e:	08 95       	ret

00000290 <ADC_0_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     290:	e5 e1       	ldi	r30, 0x15	; 21
     292:	f4 e0       	ldi	r31, 0x04	; 4
     294:	80 81       	ld	r24, Z
     296:	88 7f       	andi	r24, 0xF8	; 248
     298:	84 60       	ori	r24, 0x04	; 4
     29a:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     29c:	80 81       	ld	r24, Z
     29e:	87 7f       	andi	r24, 0xF7	; 247
     2a0:	80 83       	st	Z, r24
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     2a2:	e7 e1       	ldi	r30, 0x17	; 23
     2a4:	f4 e0       	ldi	r31, 0x04	; 4
     2a6:	80 81       	ld	r24, Z
     2a8:	88 7f       	andi	r24, 0xF8	; 248
     2aa:	84 60       	ori	r24, 0x04	; 4
     2ac:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2ae:	80 81       	ld	r24, Z
     2b0:	87 7f       	andi	r24, 0xF7	; 247
     2b2:	80 83       	st	Z, r24
 */
static inline void PORTC_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     2b4:	e0 e5       	ldi	r30, 0x50	; 80
     2b6:	f4 e0       	ldi	r31, 0x04	; 4
     2b8:	80 81       	ld	r24, Z
     2ba:	88 7f       	andi	r24, 0xF8	; 248
     2bc:	84 60       	ori	r24, 0x04	; 4
     2be:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2c0:	80 81       	ld	r24, Z
     2c2:	87 7f       	andi	r24, 0xF7	; 247
     2c4:	80 83       	st	Z, r24
 */
static inline void PORTC_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     2c6:	e1 e5       	ldi	r30, 0x51	; 81
     2c8:	f4 e0       	ldi	r31, 0x04	; 4
     2ca:	80 81       	ld	r24, Z
     2cc:	88 7f       	andi	r24, 0xF8	; 248
     2ce:	84 60       	ori	r24, 0x04	; 4
     2d0:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2d2:	80 81       	ld	r24, Z
     2d4:	87 7f       	andi	r24, 0xF7	; 247
     2d6:	80 83       	st	Z, r24
 */
static inline void PORTC_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     2d8:	e3 e5       	ldi	r30, 0x53	; 83
     2da:	f4 e0       	ldi	r31, 0x04	; 4
     2dc:	80 81       	ld	r24, Z
     2de:	88 7f       	andi	r24, 0xF8	; 248
     2e0:	84 60       	ori	r24, 0x04	; 4
     2e2:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2e4:	80 81       	ld	r24, Z
     2e6:	87 7f       	andi	r24, 0xF7	; 247
     2e8:	80 83       	st	Z, r24
	// Disable digital input buffer
	DEN4_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	DEN4_PIN_set_pull_mode(PORT_PULL_OFF);

	ADC_0_init();
     2ea:	0e 94 d1 00 	call	0x1a2	; 0x1a2 <ADC_0_init>
     2ee:	08 95       	ret

000002f0 <USART_0_initialization>:
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     2f0:	23 98       	cbi	0x04, 3	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2f2:	e3 e3       	ldi	r30, 0x33	; 51
     2f4:	f4 e0       	ldi	r31, 0x04	; 4
     2f6:	80 81       	ld	r24, Z
     2f8:	87 7f       	andi	r24, 0xF7	; 247
     2fa:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     2fc:	22 9a       	sbi	0x04, 2	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     2fe:	2a 98       	cbi	0x05, 2	; 5
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	USART_0_init();
     300:	0e 94 19 02 	call	0x432	; 0x432 <USART_0_init>
     304:	08 95       	ret

00000306 <TIMER_0_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     306:	25 9a       	sbi	0x04, 5	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     308:	2d 98       	cbi	0x05, 5	; 5
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLC |= PORTMUX_TCA02_bm;
     30a:	e0 e0       	ldi	r30, 0x00	; 0
     30c:	f2 e0       	ldi	r31, 0x02	; 2
     30e:	82 81       	ldd	r24, Z+2	; 0x02
     310:	84 60       	ori	r24, 0x04	; 4
     312:	82 83       	std	Z+2, r24	; 0x02

	TIMER_0_init();
     314:	0e 94 09 02 	call	0x412	; 0x412 <TIMER_0_init>
     318:	08 95       	ret

0000031a <DIGITAL_GLUE_LOGIC_0_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     31a:	24 9a       	sbi	0x04, 4	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     31c:	2c 98       	cbi	0x05, 4	; 5
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLA |= PORTMUX_LUT0_bm;
     31e:	e0 e0       	ldi	r30, 0x00	; 0
     320:	f2 e0       	ldi	r31, 0x02	; 2
     322:	80 81       	ld	r24, Z
     324:	80 61       	ori	r24, 0x10	; 16
     326:	80 83       	st	Z, r24

	DIGITAL_GLUE_LOGIC_0_init();
     328:	0e 94 f1 00 	call	0x1e2	; 0x1e2 <DIGITAL_GLUE_LOGIC_0_init>
     32c:	08 95       	ret

0000032e <SPI_0_initialization>:
 */
static inline void PORTA_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
     32e:	02 98       	cbi	0x00, 2	; 0
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     330:	e2 e1       	ldi	r30, 0x12	; 18
     332:	f4 e0       	ldi	r31, 0x04	; 4
     334:	80 81       	ld	r24, Z
     336:	87 7f       	andi	r24, 0xF7	; 247
     338:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     33a:	01 9a       	sbi	0x00, 1	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     33c:	09 98       	cbi	0x01, 1	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     33e:	03 9a       	sbi	0x00, 3	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     340:	0b 98       	cbi	0x01, 3	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     342:	04 9a       	sbi	0x00, 4	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     344:	0c 98       	cbi	0x01, 4	; 1
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	SPI_0_init();
     346:	0e 94 01 02 	call	0x402	; 0x402 <SPI_0_init>
     34a:	08 95       	ret

0000034c <DAC_0_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     34c:	e6 e1       	ldi	r30, 0x16	; 22
     34e:	f4 e0       	ldi	r31, 0x04	; 4
     350:	80 81       	ld	r24, Z
     352:	88 7f       	andi	r24, 0xF8	; 248
     354:	84 60       	ori	r24, 0x04	; 4
     356:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     358:	80 81       	ld	r24, Z
     35a:	87 7f       	andi	r24, 0xF7	; 247
     35c:	80 83       	st	Z, r24
	// Disable digital input buffer
	AXON_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	AXON_PIN_set_pull_mode(PORT_PULL_OFF);

	DAC_0_init();
     35e:	0e 94 13 01 	call	0x226	; 0x226 <DAC_0_init>
     362:	08 95       	ret

00000364 <system_init>:
/**
 * \brief System initialization
 */
void system_init()
{
	mcu_init();
     364:	0e 94 2c 01 	call	0x258	; 0x258 <mcu_init>
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     368:	21 9a       	sbi	0x04, 1	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     36a:	29 98       	cbi	0x05, 1	; 5
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     36c:	26 98       	cbi	0x04, 6	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     36e:	e6 e3       	ldi	r30, 0x36	; 54
     370:	f4 e0       	ldi	r31, 0x04	; 4
     372:	80 81       	ld	r24, Z
     374:	87 7f       	andi	r24, 0xF7	; 247
     376:	80 83       	st	Z, r24
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     378:	27 98       	cbi	0x04, 7	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     37a:	e7 e3       	ldi	r30, 0x37	; 55
     37c:	f4 e0       	ldi	r31, 0x04	; 4
     37e:	80 81       	ld	r24, Z
     380:	87 7f       	andi	r24, 0xF7	; 247
     382:	80 83       	st	Z, r24
 */
static inline void PORTC_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
     384:	42 98       	cbi	0x08, 2	; 8
static inline void PORTC_set_pin_pull_mode(const uint8_t pin, const enum port_pull_mode pull_mode)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
     386:	e2 e5       	ldi	r30, 0x52	; 82
     388:	f4 e0       	ldi	r31, 0x04	; 4
     38a:	80 81       	ld	r24, Z
     38c:	88 60       	ori	r24, 0x08	; 8
     38e:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTC.DIR |= (1 << pin);
     390:	45 9a       	sbi	0x08, 5	; 8
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     392:	4d 9a       	sbi	0x09, 5	; 9
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    true);

	CLKCTRL_init();
     394:	0e 94 02 01 	call	0x204	; 0x204 <CLKCTRL_init>

	RTC_0_init();
     398:	0e 94 e5 01 	call	0x3ca	; 0x3ca <RTC_0_init>

	ADC_0_initialization();
     39c:	0e 94 48 01 	call	0x290	; 0x290 <ADC_0_initialization>

	USART_0_initialization();
     3a0:	0e 94 78 01 	call	0x2f0	; 0x2f0 <USART_0_initialization>

	TIMER_0_initialization();
     3a4:	0e 94 83 01 	call	0x306	; 0x306 <TIMER_0_initialization>

	DIGITAL_GLUE_LOGIC_0_initialization();
     3a8:	0e 94 8d 01 	call	0x31a	; 0x31a <DIGITAL_GLUE_LOGIC_0_initialization>

	SPI_0_initialization();
     3ac:	0e 94 97 01 	call	0x32e	; 0x32e <SPI_0_initialization>

	DAC_0_initialization();
     3b0:	0e 94 a6 01 	call	0x34c	; 0x34c <DAC_0_initialization>

	CPUINT_init();
     3b4:	0e 94 10 01 	call	0x220	; 0x220 <CPUINT_init>

	SLPCTRL_init();
     3b8:	0e 94 ff 01 	call	0x3fe	; 0x3fe <SLPCTRL_init>

	BOD_init();
     3bc:	0e 94 ef 00 	call	0x1de	; 0x1de <BOD_init>
     3c0:	08 95       	ret

000003c2 <protected_write_io>:
#if defined(__GNUC__)
  
#ifdef RAMPZ
	out     _SFR_IO_ADDR(RAMPZ), r1         // Clear bits 23:16 of Z
#endif
	movw    r30, r24                // Load addr into Z
     3c2:	fc 01       	movw	r30, r24
	out     CCP, r22                // Start CCP handshake
     3c4:	64 bf       	out	0x34, r22	; 52
	st      Z, r20                  // Write value to I/O register
     3c6:	40 83       	st	Z, r20
	ret                             // Return to caller
     3c8:	08 95       	ret

000003ca <RTC_0_init>:
 * \return Initialization status.
 */
int8_t RTC_0_init()
{

	while (RTC.STATUS > 0) { /* Wait for all register to be synchronized */
     3ca:	e0 e4       	ldi	r30, 0x40	; 64
     3cc:	f1 e0       	ldi	r31, 0x01	; 1
     3ce:	81 81       	ldd	r24, Z+1	; 0x01
     3d0:	81 11       	cpse	r24, r1
     3d2:	fd cf       	rjmp	.-6      	; 0x3ce <RTC_0_init+0x4>
	}

	// RTC.CMP = 0x0; /* Compare: 0x0 */

	RTC.CNT = 0x20; /* Counter: 0x20 */
     3d4:	e0 e4       	ldi	r30, 0x40	; 64
     3d6:	f1 e0       	ldi	r31, 0x01	; 1
     3d8:	80 e2       	ldi	r24, 0x20	; 32
     3da:	90 e0       	ldi	r25, 0x00	; 0
     3dc:	80 87       	std	Z+8, r24	; 0x08
     3de:	91 87       	std	Z+9, r25	; 0x09

	RTC.CTRLA = RTC_PRESCALER_DIV1_gc   /* 1 */
     3e0:	21 e8       	ldi	r18, 0x81	; 129
     3e2:	20 83       	st	Z, r18
	            | 1 << RTC_RTCEN_bp     /* Enable: enabled */
	            | 1 << RTC_RUNSTDBY_bp; /* Run In Standby: enabled */

	RTC.PER = 0x20 / TIMESCALE; /* Period: 0x20 */
     3e4:	82 87       	std	Z+10, r24	; 0x0a
     3e6:	93 87       	std	Z+11, r25	; 0x0b

	// RTC.CLKSEL = RTC_CLKSEL_INT32K_gc; /* 32KHz Internal Ultra Low Power Oscillator (OSCULP32K) */

	RTC.DBGCTRL = 1 << RTC_DBGRUN_bp; /* Run in debug: enabled */
     3e8:	81 e0       	ldi	r24, 0x01	; 1
     3ea:	85 83       	std	Z+5, r24	; 0x05

	RTC.INTCTRL = 0 << RTC_CMP_bp    /* Compare Match Interrupt enable: disabled */
     3ec:	82 83       	std	Z+2, r24	; 0x02
	              | 1 << RTC_OVF_bp; /* Overflow Interrupt enable: enabled */

	while (RTC.PITSTATUS > 0) { /* Wait for all register to be synchronized */
     3ee:	81 89       	ldd	r24, Z+17	; 0x11
     3f0:	81 11       	cpse	r24, r1
     3f2:	fd cf       	rjmp	.-6      	; 0x3ee <RTC_0_init+0x24>
	}

	RTC.PITCTRLA = RTC_PERIOD_OFF_gc    /* Off */
     3f4:	81 e0       	ldi	r24, 0x01	; 1
     3f6:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <__TEXT_REGION_LENGTH__+0x700150>
	// RTC.PITDBGCTRL = 0 << RTC_DBGRUN_bp; /* Run in debug: disabled */

	// RTC.PITINTCTRL = 0 << RTC_PI_bp; /* Periodic Interrupt: disabled */

	return 0;
}
     3fa:	80 e0       	ldi	r24, 0x00	; 0
     3fc:	08 95       	ret

000003fe <SLPCTRL_init>:

	// SLPCTRL.CTRLA = 0 << SLPCTRL_SEN_bp /* Sleep enable: disabled */
	//		 | SLPCTRL_SMODE_IDLE_gc; /* Idle mode */

	return 0;
}
     3fe:	80 e0       	ldi	r24, 0x00	; 0
     400:	08 95       	ret

00000402 <SPI_0_init>:
 * \return Initialization status
 */
int8_t SPI_0_init()
{

	SPI0.CTRLA = 0 << SPI_CLK2X_bp     /* Enable Double Speed: disabled */
     402:	e0 e2       	ldi	r30, 0x20	; 32
     404:	f8 e0       	ldi	r31, 0x08	; 8
     406:	83 e2       	ldi	r24, 0x23	; 35
     408:	80 83       	st	Z, r24
	             | 0 << SPI_DORD_bp    /* Data Order Setting: disabled */
	             | 1 << SPI_ENABLE_bp  /* Enable Module: enabled */
	             | 1 << SPI_MASTER_bp  /* SPI module in master mode */
	             | SPI_PRESC_DIV16_gc; /* System Clock / 16 */

	SPI0.CTRLB = 0 << SPI_BUFEN_bp   /* Buffer Mode Enable: disabled */
     40a:	84 e0       	ldi	r24, 0x04	; 4
     40c:	81 83       	std	Z+1, r24	; 0x01
	//		 | 0 << SPI_RXCIE_bp /* Receive Complete Interrupt Enable: disabled */
	//		 | 0 << SPI_SSIE_bp /* Slave Select Trigger Interrupt Enable: disabled */
	//		 | 0 << SPI_TXCIE_bp; /* Transfer Complete Interrupt Enable: disabled */

	return 0;
}
     40e:	80 e0       	ldi	r24, 0x00	; 0
     410:	08 95       	ret

00000412 <TIMER_0_init>:

	// TCA0.SINGLE.CMP0 = 0x0; /* Compare Register 0: 0x0 */

	// TCA0.SINGLE.CMP1 = 0x0; /* Compare Register 1: 0x0 */

	TCA0.SINGLE.CMP2 = 0x4; /* Compare Register 2: 0x4 */
     412:	e0 e0       	ldi	r30, 0x00	; 0
     414:	fa e0       	ldi	r31, 0x0A	; 10
     416:	84 e0       	ldi	r24, 0x04	; 4
     418:	90 e0       	ldi	r25, 0x00	; 0
     41a:	84 a7       	std	Z+44, r24	; 0x2c
     41c:	95 a7       	std	Z+45, r25	; 0x2d

	// TCA0.SINGLE.CNT = 0x0; /* Count: 0x0 */

	TCA0.SINGLE.CTRLB = 0 << TCA_SINGLE_ALUPD_bp            /* Auto Lock Update: disabled */
     41e:	83 e4       	ldi	r24, 0x43	; 67
     420:	81 83       	std	Z+1, r24	; 0x01
	                    | 0 << TCA_SINGLE_CMP0EN_bp         /* Compare 0 Enable: disabled */
	                    | 0 << TCA_SINGLE_CMP1EN_bp         /* Compare 1 Enable: disabled */
	                    | 1 << TCA_SINGLE_CMP2EN_bp         /* Compare 2 Enable: enabled */
	                    | TCA_SINGLE_WGMODE_SINGLESLOPE_gc; /*  */

	TCA0.SINGLE.CTRLC = 0 << TCA_SINGLE_CMP0OV_bp    /* Compare 0 Waveform Output Value: disabled */
     422:	84 e0       	ldi	r24, 0x04	; 4
     424:	82 83       	std	Z+2, r24	; 0x02
	// TCA0.SINGLE.INTCTRL = 0 << TCA_SINGLE_CMP0_bp /* Compare 0 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP1_bp /* Compare 1 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP2_bp /* Compare 2 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_OVF_bp; /* Overflow Interrupt: disabled */

	TCA0.SINGLE.PER = 0x7; /* Period: 0x7 */
     426:	87 e0       	ldi	r24, 0x07	; 7
     428:	90 e0       	ldi	r25, 0x00	; 0
     42a:	86 a3       	std	Z+38, r24	; 0x26
     42c:	97 a3       	std	Z+39, r25	; 0x27

	// TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV1_gc /* System Clock */
	//		 | 0 << TCA_SINGLE_ENABLE_bp; /* Module Enable: disabled */

	return 0;
}
     42e:	80 e0       	ldi	r24, 0x00	; 0
     430:	08 95       	ret

00000432 <USART_0_init>:
uint8_t USART_0_read()
{
	while (!(USART0.STATUS & USART_RXCIF_bm))
		;
	return USART0.RXDATAL;
}
     432:	e0 e0       	ldi	r30, 0x00	; 0
     434:	f8 e0       	ldi	r31, 0x08	; 8
     436:	8b e5       	ldi	r24, 0x5B	; 91
     438:	91 e0       	ldi	r25, 0x01	; 1
     43a:	80 87       	std	Z+8, r24	; 0x08
     43c:	91 87       	std	Z+9, r25	; 0x09
     43e:	80 ec       	ldi	r24, 0xC0	; 192
     440:	86 83       	std	Z+6, r24	; 0x06
     442:	80 e0       	ldi	r24, 0x00	; 0
     444:	98 e3       	ldi	r25, 0x38	; 56
     446:	80 93 6e 38 	sts	0x386E, r24	; 0x80386e <__iob+0x2>
     44a:	90 93 6f 38 	sts	0x386F, r25	; 0x80386f <__iob+0x3>
     44e:	80 e0       	ldi	r24, 0x00	; 0
     450:	08 95       	ret

00000452 <USART_0_write>:
 *
 * \return Nothing
 */
void USART_0_write(const uint8_t data)
{
	while (!(USART0.STATUS & USART_DREIF_bm))
     452:	e0 e0       	ldi	r30, 0x00	; 0
     454:	f8 e0       	ldi	r31, 0x08	; 8
     456:	94 81       	ldd	r25, Z+4	; 0x04
     458:	95 ff       	sbrs	r25, 5
     45a:	fd cf       	rjmp	.-6      	; 0x456 <USART_0_write+0x4>
		;
	USART0.TXDATAL = data;
     45c:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <__TEXT_REGION_LENGTH__+0x700802>
     460:	08 95       	ret

00000462 <USART_0_printCHAR>:

#if defined(__GNUC__)

int USART_0_printCHAR(char character, FILE *stream)
{
	USART_0_write(character);
     462:	0e 94 29 02 	call	0x452	; 0x452 <USART_0_write>
	return 0;
}
     466:	80 e0       	ldi	r24, 0x00	; 0
     468:	90 e0       	ldi	r25, 0x00	; 0
     46a:	08 95       	ret

0000046c <tinyAxon_add_pulse>:
{
	// We want to check each slot in the pulse_queue, and
	// if we find an empty slot (0), we add a pulse.
	for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
	{
		if(pulse_queue[i] == 0){
     46c:	20 91 16 38 	lds	r18, 0x3816	; 0x803816 <__data_end>
     470:	30 91 17 38 	lds	r19, 0x3817	; 0x803817 <__data_end+0x1>
     474:	23 2b       	or	r18, r19
     476:	51 f0       	breq	.+20     	; 0x48c <tinyAxon_add_pulse+0x20>
     478:	e8 e1       	ldi	r30, 0x18	; 24
     47a:	f8 e3       	ldi	r31, 0x38	; 56
     47c:	21 e0       	ldi	r18, 0x01	; 1
     47e:	30 e0       	ldi	r19, 0x00	; 0
     480:	b9 01       	movw	r22, r18
     482:	41 91       	ld	r20, Z+
     484:	51 91       	ld	r21, Z+
     486:	45 2b       	or	r20, r21
     488:	81 f4       	brne	.+32     	; 0x4aa <tinyAxon_add_pulse+0x3e>
     48a:	02 c0       	rjmp	.+4      	; 0x490 <tinyAxon_add_pulse+0x24>
     48c:	60 e0       	ldi	r22, 0x00	; 0
     48e:	70 e0       	ldi	r23, 0x00	; 0
			pulse_queue[i] = new_pulse;
     490:	66 0f       	add	r22, r22
     492:	77 1f       	adc	r23, r23
     494:	fb 01       	movw	r30, r22
     496:	ea 5e       	subi	r30, 0xEA	; 234
     498:	f7 4c       	sbci	r31, 0xC7	; 199
     49a:	80 83       	st	Z, r24
     49c:	91 83       	std	Z+1, r25	; 0x01
			pulses_in_queue++;
     49e:	80 91 2a 38 	lds	r24, 0x382A	; 0x80382a <pulses_in_queue>
     4a2:	8f 5f       	subi	r24, 0xFF	; 255
     4a4:	80 93 2a 38 	sts	0x382A, r24	; 0x80382a <pulses_in_queue>
			// We return so we only ever add one
			break;
     4a8:	08 95       	ret
     4aa:	2f 5f       	subi	r18, 0xFF	; 255
     4ac:	3f 4f       	sbci	r19, 0xFF	; 255
*/
static void tinyAxon_add_pulse(uint16_t new_pulse)
{
	// We want to check each slot in the pulse_queue, and
	// if we find an empty slot (0), we add a pulse.
	for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
     4ae:	2a 30       	cpi	r18, 0x0A	; 10
     4b0:	31 05       	cpc	r19, r1
     4b2:	31 f7       	brne	.-52     	; 0x480 <tinyAxon_add_pulse+0x14>
     4b4:	08 95       	ret

000004b6 <tinyAxon_is_firing>:
// DAC has no DAC_0_get_output, so we keep track of this here.
uint8_t axonOutputValue = 0;


_Bool tinyAxon_is_firing(){
	return axonOutputValue != NO_SIGNAL_OUTPUT;
     4b6:	81 e0       	ldi	r24, 0x01	; 1
     4b8:	90 91 2b 38 	lds	r25, 0x382B	; 0x80382b <axonOutputValue>
     4bc:	91 11       	cpse	r25, r1
     4be:	01 c0       	rjmp	.+2      	; 0x4c2 <tinyAxon_is_firing+0xc>
     4c0:	80 e0       	ldi	r24, 0x00	; 0
}
     4c2:	08 95       	ret

000004c4 <tinyAxon_get_pulses_in_queue>:
uint8_t pulses_in_queue = 0; //variable to determine how many pulses are in queue.

uint8_t tinyAxon_get_pulses_in_queue()
{
	return pulses_in_queue;
}
     4c4:	80 91 2a 38 	lds	r24, 0x382A	; 0x80382a <pulses_in_queue>
     4c8:	08 95       	ret

000004ca <find_newest_pulse>:
uint8_t find_newest_pulse() {
	uint16_t max;
	uint8_t current_index = 0;
	uint8_t return_index = 0;
	
	max = pulse_queue[current_index];
     4ca:	40 91 16 38 	lds	r20, 0x3816	; 0x803816 <__data_end>
     4ce:	50 91 17 38 	lds	r21, 0x3817	; 0x803817 <__data_end+0x1>
     4d2:	e8 e1       	ldi	r30, 0x18	; 24
     4d4:	f8 e3       	ldi	r31, 0x38	; 56
	
// This function will be used with pulse_queue to find the newest pulse
uint8_t find_newest_pulse() {
	uint16_t max;
	uint8_t current_index = 0;
	uint8_t return_index = 0;
     4d6:	80 e0       	ldi	r24, 0x00	; 0
	
	max = pulse_queue[current_index];
	
	for (current_index = 1; current_index < MAX_NUMBER_OF_PULSES; current_index++) {
     4d8:	91 e0       	ldi	r25, 0x01	; 1
		if (pulse_queue[current_index] > max) {
     4da:	21 91       	ld	r18, Z+
     4dc:	31 91       	ld	r19, Z+
     4de:	42 17       	cp	r20, r18
     4e0:	53 07       	cpc	r21, r19
     4e2:	10 f4       	brcc	.+4      	; 0x4e8 <find_newest_pulse+0x1e>
     4e4:	89 2f       	mov	r24, r25
			return_index = current_index;
			max = pulse_queue[current_index];
     4e6:	a9 01       	movw	r20, r18
	uint8_t current_index = 0;
	uint8_t return_index = 0;
	
	max = pulse_queue[current_index];
	
	for (current_index = 1; current_index < MAX_NUMBER_OF_PULSES; current_index++) {
     4e8:	9f 5f       	subi	r25, 0xFF	; 255
     4ea:	9a 30       	cpi	r25, 0x0A	; 10
     4ec:	b1 f7       	brne	.-20     	; 0x4da <find_newest_pulse+0x10>
			return_index = current_index;
			max = pulse_queue[current_index];
		}
	}
	return return_index;
}
     4ee:	08 95       	ret

000004f0 <tinyAxon_stop_sending_pulse>:
	tinyLED_set_color_mode(OUT_LED, WHITE, FLASH_ONCE);
}

void tinyAxon_stop_sending_pulse()
{
	DAC_0_set_output(NO_SIGNAL_OUTPUT);
     4f0:	80 e0       	ldi	r24, 0x00	; 0
     4f2:	90 e0       	ldi	r25, 0x00	; 0
     4f4:	0e 94 29 01 	call	0x252	; 0x252 <DAC_0_set_output>
	axonOutputValue=NO_SIGNAL_OUTPUT;
     4f8:	10 92 2b 38 	sts	0x382B, r1	; 0x80382b <axonOutputValue>
     4fc:	08 95       	ret

000004fe <tinyAxon_remove_pulse>:

/*
If the potential is very low, we want to try to remove a pulse.
*/
bool tinyAxon_remove_pulse(void)
{
     4fe:	cf 93       	push	r28
	// We want to return a bool indicating whether or not a pulse actually was removed.
	if(pulses_in_queue == 0){
     500:	c0 91 2a 38 	lds	r28, 0x382A	; 0x80382a <pulses_in_queue>
     504:	cc 23       	and	r28, r28
     506:	c1 f0       	breq	.+48     	; 0x538 <tinyAxon_remove_pulse+0x3a>
		//There was no pulse to remove.
		return false;
	}
	else{
		// If we are to remove a pulse, we want to remove the one that will fire last.
		uint8_t pulse_index = find_newest_pulse();
     508:	0e 94 65 02 	call	0x4ca	; 0x4ca <find_newest_pulse>
		uint16_t newest_pulse = pulse_queue[pulse_index];
     50c:	90 e0       	ldi	r25, 0x00	; 0
     50e:	fc 01       	movw	r30, r24
     510:	ee 0f       	add	r30, r30
     512:	ff 1f       	adc	r31, r31
     514:	ea 5e       	subi	r30, 0xEA	; 234
     516:	f7 4c       	sbci	r31, 0xC7	; 199
	
		// Now we want to check if the pulse is too far away to be affected by the low potential, or close enough that we decide to remove it.
		// (When we say that the pulse is too far away, it refers to the biological process of how the potential spreads from Dendrites to axon).
		if(newest_pulse > PULSE_NO_RETURN_TIME){
     518:	20 81       	ld	r18, Z
     51a:	31 81       	ldd	r19, Z+1	; 0x01
     51c:	23 2b       	or	r18, r19
     51e:	71 f0       	breq	.+28     	; 0x53c <tinyAxon_remove_pulse+0x3e>
			// We decided to remove the pulse
			pulse_queue[pulse_index] = 0;
     520:	88 0f       	add	r24, r24
     522:	99 1f       	adc	r25, r25
     524:	fc 01       	movw	r30, r24
     526:	ea 5e       	subi	r30, 0xEA	; 234
     528:	f7 4c       	sbci	r31, 0xC7	; 199
     52a:	10 82       	st	Z, r1
     52c:	11 82       	std	Z+1, r1	; 0x01
			pulses_in_queue--;
     52e:	c1 50       	subi	r28, 0x01	; 1
     530:	c0 93 2a 38 	sts	0x382A, r28	; 0x80382a <pulses_in_queue>
			return true;
     534:	81 e0       	ldi	r24, 0x01	; 1
     536:	03 c0       	rjmp	.+6      	; 0x53e <tinyAxon_remove_pulse+0x40>
bool tinyAxon_remove_pulse(void)
{
	// We want to return a bool indicating whether or not a pulse actually was removed.
	if(pulses_in_queue == 0){
		//There was no pulse to remove.
		return false;
     538:	80 e0       	ldi	r24, 0x00	; 0
     53a:	01 c0       	rjmp	.+2      	; 0x53e <tinyAxon_remove_pulse+0x40>
			pulses_in_queue--;
			return true;
		}
		// Here we have found that there is a pulse queued, but it is old enough to let pass anyway, so now we need to put it back into the queue.
		else{
			return false;
     53c:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     53e:	cf 91       	pop	r28
     540:	08 95       	ret

00000542 <tinyAxon_update_potential>:
/*
Decides whether or not the axon should fire
If the axon does fire, the potential is reduced
*/
double tinyAxon_update_potential(double potential)
{	
     542:	cf 92       	push	r12
     544:	df 92       	push	r13
     546:	ef 92       	push	r14
     548:	ff 92       	push	r15
     54a:	6b 01       	movw	r12, r22
     54c:	7c 01       	movw	r14, r24
	//While the neuron has enough potential to fire, we want to fire more
	while (potential >= THRESHOLD_POTENTIAL)
     54e:	20 e0       	ldi	r18, 0x00	; 0
     550:	30 e0       	ldi	r19, 0x00	; 0
     552:	48 ec       	ldi	r20, 0xC8	; 200
     554:	51 e4       	ldi	r21, 0x41	; 65
     556:	0e 94 de 0b 	call	0x17bc	; 0x17bc <__gesf2>
     55a:	88 23       	and	r24, r24
     55c:	84 f1       	brlt	.+96     	; 0x5be <tinyAxon_update_potential+0x7c>
	{
		// We have to check if there are already queued pulses, so that the frequency never exceeds FIRE_DELAY
		if(pulses_in_queue>0){
     55e:	80 91 2a 38 	lds	r24, 0x382A	; 0x80382a <pulses_in_queue>
     562:	88 23       	and	r24, r24
     564:	b1 f0       	breq	.+44     	; 0x592 <tinyAxon_update_potential+0x50>
			uint16_t newest_pulse = pulse_queue[find_newest_pulse()];
     566:	0e 94 65 02 	call	0x4ca	; 0x4ca <find_newest_pulse>
     56a:	e8 2f       	mov	r30, r24
     56c:	f0 e0       	ldi	r31, 0x00	; 0
     56e:	ee 0f       	add	r30, r30
     570:	ff 1f       	adc	r31, r31
     572:	ea 5e       	subi	r30, 0xEA	; 234
     574:	f7 4c       	sbci	r31, 0xC7	; 199
			
			// There is at least one pulse in the queue, and it is "so close", that we need to offset the new pulse, so that we keep at least
			// one FIRE_DELAY between each pulse
			if(newest_pulse + FIRE_DELAY > TRAVLE_DELAY){
     576:	80 81       	ld	r24, Z
     578:	91 81       	ldd	r25, Z+1	; 0x01
     57a:	0a 96       	adiw	r24, 0x0a	; 10
     57c:	85 36       	cpi	r24, 0x65	; 101
     57e:	91 05       	cpc	r25, r1
     580:	18 f0       	brcs	.+6      	; 0x588 <tinyAxon_update_potential+0x46>
				tinyAxon_add_pulse(newest_pulse + FIRE_DELAY);
     582:	0e 94 36 02 	call	0x46c	; 0x46c <tinyAxon_add_pulse>
     586:	09 c0       	rjmp	.+18     	; 0x59a <tinyAxon_update_potential+0x58>
			}
			// There is at least one pulse in the queue, but it's "far enough away" to ignore
			else{
				tinyAxon_add_pulse(TRAVLE_DELAY);
     588:	84 e6       	ldi	r24, 0x64	; 100
     58a:	90 e0       	ldi	r25, 0x00	; 0
     58c:	0e 94 36 02 	call	0x46c	; 0x46c <tinyAxon_add_pulse>
     590:	04 c0       	rjmp	.+8      	; 0x59a <tinyAxon_update_potential+0x58>
			}
		}
		// There are no pulses in the queue, so we add a pulse as normal
		else{
			tinyAxon_add_pulse(TRAVLE_DELAY);		
     592:	84 e6       	ldi	r24, 0x64	; 100
     594:	90 e0       	ldi	r25, 0x00	; 0
     596:	0e 94 36 02 	call	0x46c	; 0x46c <tinyAxon_add_pulse>
		}
		
		potential += POSTFIRE_POTENTIAL_REACTION; // This is usually defined as a negative value, don't be confused by the +=
     59a:	20 e0       	ldi	r18, 0x00	; 0
     59c:	30 e0       	ldi	r19, 0x00	; 0
     59e:	48 ec       	ldi	r20, 0xC8	; 200
     5a0:	51 e4       	ldi	r21, 0x41	; 65
     5a2:	c7 01       	movw	r24, r14
     5a4:	b6 01       	movw	r22, r12
     5a6:	0e 94 92 09 	call	0x1324	; 0x1324 <__subsf3>
     5aa:	6b 01       	movw	r12, r22
     5ac:	7c 01       	movw	r14, r24
If the axon does fire, the potential is reduced
*/
double tinyAxon_update_potential(double potential)
{	
	//While the neuron has enough potential to fire, we want to fire more
	while (potential >= THRESHOLD_POTENTIAL)
     5ae:	20 e0       	ldi	r18, 0x00	; 0
     5b0:	30 e0       	ldi	r19, 0x00	; 0
     5b2:	48 ec       	ldi	r20, 0xC8	; 200
     5b4:	51 e4       	ldi	r21, 0x41	; 65
     5b6:	0e 94 de 0b 	call	0x17bc	; 0x17bc <__gesf2>
     5ba:	88 23       	and	r24, r24
     5bc:	84 f6       	brge	.-96     	; 0x55e <tinyAxon_update_potential+0x1c>
		// Why the hell is this line here? It shoudln't i think...
		//tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
	}
	
	// If the neuron has a very low potential, we want to remove a pulse from the queue (if there is one)
	if(potential < REMOVE_PULSE_THRESHOLD) // REMOVE_PULSE_THRESHOLD is a negative number
     5be:	20 e0       	ldi	r18, 0x00	; 0
     5c0:	30 e0       	ldi	r19, 0x00	; 0
     5c2:	40 ea       	ldi	r20, 0xA0	; 160
     5c4:	51 ec       	ldi	r21, 0xC1	; 193
     5c6:	c7 01       	movw	r24, r14
     5c8:	b6 01       	movw	r22, r12
     5ca:	0e 94 ff 09 	call	0x13fe	; 0x13fe <__cmpsf2>
     5ce:	88 23       	and	r24, r24
     5d0:	0c f0       	brlt	.+2      	; 0x5d4 <tinyAxon_update_potential+0x92>
     5d2:	46 c0       	rjmp	.+140    	; 0x660 <tinyAxon_update_potential+0x11e>
	{
		if(pulses_in_queue > 0)
     5d4:	80 91 2a 38 	lds	r24, 0x382A	; 0x80382a <pulses_in_queue>
     5d8:	88 23       	and	r24, r24
     5da:	11 f1       	breq	.+68     	; 0x620 <tinyAxon_update_potential+0xde>
		{
			// The neurons potential is low enough to attempt to remove a queued fire (Fire less)
			if(tinyAxon_remove_pulse())
     5dc:	0e 94 7f 02 	call	0x4fe	; 0x4fe <tinyAxon_remove_pulse>
     5e0:	88 23       	and	r24, r24
     5e2:	f1 f1       	breq	.+124    	; 0x660 <tinyAxon_update_potential+0x11e>
			{
				// The potential has evened out a bit
				potential += THRESHOLD_POTENTIAL;
     5e4:	20 e0       	ldi	r18, 0x00	; 0
     5e6:	30 e0       	ldi	r19, 0x00	; 0
     5e8:	48 ec       	ldi	r20, 0xC8	; 200
     5ea:	51 e4       	ldi	r21, 0x41	; 65
     5ec:	c7 01       	movw	r24, r14
     5ee:	b6 01       	movw	r22, r12
     5f0:	0e 94 93 09 	call	0x1326	; 0x1326 <__addsf3>
     5f4:	6b 01       	movw	r12, r22
     5f6:	7c 01       	movw	r14, r24
     5f8:	33 c0       	rjmp	.+102    	; 0x660 <tinyAxon_update_potential+0x11e>
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
	{
		for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
		{
			if(pulse_queue[i] != 0){
     5fa:	80 81       	ld	r24, Z
     5fc:	91 81       	ldd	r25, Z+1	; 0x01
     5fe:	00 97       	sbiw	r24, 0x00	; 0
     600:	39 f0       	breq	.+14     	; 0x610 <tinyAxon_update_potential+0xce>
				pulse_queue[i]--;
     602:	01 97       	sbiw	r24, 0x01	; 1
     604:	80 83       	st	Z, r24
     606:	91 83       	std	Z+1, r25	; 0x01
				
				// If the time went from 1 to 0, we fire the axon
				if(pulse_queue[i] == 0){
     608:	89 2b       	or	r24, r25
     60a:	11 f4       	brne	.+4      	; 0x610 <tinyAxon_update_potential+0xce>
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
	pulses_in_queue--;
     60c:	41 50       	subi	r20, 0x01	; 1
Function to set firing.
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
     60e:	51 e0       	ldi	r21, 0x01	; 1
     610:	32 96       	adiw	r30, 0x02	; 2
	}
	
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
	{
		for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
     612:	e2 17       	cp	r30, r18
     614:	f3 07       	cpc	r31, r19
     616:	89 f7       	brne	.-30     	; 0x5fa <tinyAxon_update_potential+0xb8>
     618:	50 93 2c 38 	sts	0x382C, r21	; 0x80382c <tinyAxon_should_fire>
     61c:	40 93 2a 38 	sts	0x382A, r20	; 0x80382a <pulses_in_queue>
The function should set the DAC to fire for two
update cycles once the pulse flag is set high.
*/
static void tinyAxon_update_pulse_transmitter(void)
{
	if (tinyAxon_should_fire)
     620:	80 91 2c 38 	lds	r24, 0x382C	; 0x80382c <tinyAxon_should_fire>
     624:	88 23       	and	r24, r24
     626:	91 f0       	breq	.+36     	; 0x64c <tinyAxon_update_potential+0x10a>
	{
		tinyAxon_should_fire = false;
     628:	10 92 2c 38 	sts	0x382C, r1	; 0x80382c <tinyAxon_should_fire>
*/
static void tinyAxon_start_sending_pulse()
{
	if (NEURONTYPE == EXCITATORY_NEURON)
	{
		DAC_0_set_output(EXCITATORY_NEURON_OUTPUT);
     62c:	8c ee       	ldi	r24, 0xEC	; 236
     62e:	90 e0       	ldi	r25, 0x00	; 0
     630:	0e 94 29 01 	call	0x252	; 0x252 <DAC_0_set_output>
		axonOutputValue=EXCITATORY_NEURON_OUTPUT;
     634:	8c ee       	ldi	r24, 0xEC	; 236
     636:	80 93 2b 38 	sts	0x382B, r24	; 0x80382b <axonOutputValue>
	{
		DAC_0_set_output(INHIBITORY_NEURON_OUTPUT);
		axonOutputValue=INHIBITORY_NEURON_OUTPUT;
	}
	
	tinyLED_set_color_mode(OUT_LED, WHITE, FLASH_ONCE);
     63a:	45 e0       	ldi	r20, 0x05	; 5
     63c:	66 e0       	ldi	r22, 0x06	; 6
     63e:	81 e0       	ldi	r24, 0x01	; 1
     640:	0e 94 83 05 	call	0xb06	; 0xb06 <tinyLED_set_color_mode>
{
	if (tinyAxon_should_fire)
	{
		tinyAxon_should_fire = false;
		tinyAxon_start_sending_pulse();
		tinyAxon_has_just_fired = true;
     644:	81 e0       	ldi	r24, 0x01	; 1
     646:	80 93 2d 38 	sts	0x382D, r24	; 0x80382d <tinyAxon_has_just_fired>
     64a:	15 c0       	rjmp	.+42     	; 0x676 <tinyAxon_update_potential+0x134>
		
	}
	else if (tinyAxon_has_just_fired)
     64c:	80 91 2d 38 	lds	r24, 0x382D	; 0x80382d <tinyAxon_has_just_fired>
     650:	88 23       	and	r24, r24
     652:	19 f0       	breq	.+6      	; 0x65a <tinyAxon_update_potential+0x118>
	{
		tinyAxon_has_just_fired = false;
     654:	10 92 2d 38 	sts	0x382D, r1	; 0x80382d <tinyAxon_has_just_fired>
     658:	0e c0       	rjmp	.+28     	; 0x676 <tinyAxon_update_potential+0x134>
	}
	else if (!tinyAxon_has_just_fired && !tinyAxon_should_fire)
	{
		tinyAxon_stop_sending_pulse();
     65a:	0e 94 78 02 	call	0x4f0	; 0x4f0 <tinyAxon_stop_sending_pulse>
     65e:	0b c0       	rjmp	.+22     	; 0x676 <tinyAxon_update_potential+0x134>
			}
		}
	}
	
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
     660:	40 91 2a 38 	lds	r20, 0x382A	; 0x80382a <pulses_in_queue>
     664:	44 23       	and	r20, r20
     666:	e1 f2       	breq	.-72     	; 0x620 <tinyAxon_update_potential+0xde>
     668:	50 91 2c 38 	lds	r21, 0x382C	; 0x80382c <tinyAxon_should_fire>
     66c:	e6 e1       	ldi	r30, 0x16	; 22
     66e:	f8 e3       	ldi	r31, 0x38	; 56
     670:	2a e2       	ldi	r18, 0x2A	; 42
     672:	38 e3       	ldi	r19, 0x38	; 56
     674:	c2 cf       	rjmp	.-124    	; 0x5fa <tinyAxon_update_potential+0xb8>
	}
	
	// Here we set the actual output of the DAC (Digital to Analog Converter)
	tinyAxon_update_pulse_transmitter();
	
	tinyDebugger_send_uint8("Axon", axonOutputValue);
     676:	60 91 2b 38 	lds	r22, 0x382B	; 0x80382b <axonOutputValue>
     67a:	8b ea       	ldi	r24, 0xAB	; 171
     67c:	9a e9       	ldi	r25, 0x9A	; 154
     67e:	0e 94 40 04 	call	0x880	; 0x880 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("Pulses", pulses_in_queue);
     682:	60 91 2a 38 	lds	r22, 0x382A	; 0x80382a <pulses_in_queue>
     686:	80 eb       	ldi	r24, 0xB0	; 176
     688:	9a e9       	ldi	r25, 0x9A	; 154
     68a:	0e 94 40 04 	call	0x880	; 0x880 <tinyDebugger_send_uint8>
	
	
	return potential;
}
     68e:	c7 01       	movw	r24, r14
     690:	b6 01       	movw	r22, r12
     692:	ff 90       	pop	r15
     694:	ef 90       	pop	r14
     696:	df 90       	pop	r13
     698:	cf 90       	pop	r12
     69a:	08 95       	ret

0000069c <tinyAxon_check_charge_level>:


_Bool tinyAxon_check_charge_level(void)
{
	// We check the AXON_CHECK_PIN. If it is hight while the axon is not firing, it must be connected to a charger
	return (AXON_CHECK_PIN_get_level() && !tinyAxon_has_just_fired);
     69c:	37 9b       	sbis	0x06, 7	; 6
     69e:	05 c0       	rjmp	.+10     	; 0x6aa <tinyAxon_check_charge_level+0xe>
     6a0:	90 91 2d 38 	lds	r25, 0x382D	; 0x80382d <tinyAxon_has_just_fired>
     6a4:	81 e0       	ldi	r24, 0x01	; 1
     6a6:	89 27       	eor	r24, r25
     6a8:	02 c0       	rjmp	.+4      	; 0x6ae <tinyAxon_check_charge_level+0x12>
     6aa:	80 e0       	ldi	r24, 0x00	; 0
     6ac:	90 e0       	ldi	r25, 0x00	; 0
     6ae:	81 70       	andi	r24, 0x01	; 1
     6b0:	08 95       	ret

000006b2 <tinyButton_update>:
/*
If the button has been let go, we change button_press to true. This only lasts one cycle, before it is set to false again.
If the button is held down for longer than PULSEMODE_BUTTON_PRESS_TIME, we toggle the pulse mode state.
*/
void tinyButton_update(void)
{
     6b2:	0f 93       	push	r16
     6b4:	1f 93       	push	r17
     6b6:	cf 93       	push	r28
     6b8:	df 93       	push	r29
	button_press = false;
     6ba:	10 92 33 38 	sts	0x3833, r1	; 0x803833 <button_press>
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTC_get_pin_level(const uint8_t pin)
{
	return VPORTC.IN & (1 << pin);
     6be:	8a b1       	in	r24, 0x0a	; 10
	_Bool button_is_pushed_down = !BUTTON_PIN_get_level(); // The digital port will be read as low if the button is pushed down.
     6c0:	d1 e0       	ldi	r29, 0x01	; 1
     6c2:	c8 2f       	mov	r28, r24
     6c4:	c4 70       	andi	r28, 0x04	; 4
     6c6:	82 fd       	sbrc	r24, 2
     6c8:	d0 e0       	ldi	r29, 0x00	; 0

	if (button_is_pushed_down && !button_was_pushed_down)
     6ca:	c1 11       	cpse	r28, r1
     6cc:	36 c0       	rjmp	.+108    	; 0x73a <tinyButton_update+0x88>
     6ce:	80 91 34 38 	lds	r24, 0x3834	; 0x803834 <button_was_pushed_down>
     6d2:	81 11       	cpse	r24, r1
     6d4:	0e c0       	rjmp	.+28     	; 0x6f2 <tinyButton_update+0x40>
	{
		tinyButton_start_time = tinyTime_now();
     6d6:	0e 94 89 09 	call	0x1312	; 0x1312 <tinyTime_now>
     6da:	60 93 2e 38 	sts	0x382E, r22	; 0x80382e <tinyButton_start_time>
     6de:	70 93 2f 38 	sts	0x382F, r23	; 0x80382f <tinyButton_start_time+0x1>
     6e2:	80 93 30 38 	sts	0x3830, r24	; 0x803830 <tinyButton_start_time+0x2>
     6e6:	90 93 31 38 	sts	0x3831, r25	; 0x803831 <tinyButton_start_time+0x3>
	}
	if (button_is_pushed_down && button_was_pushed_down)
     6ea:	80 91 34 38 	lds	r24, 0x3834	; 0x803834 <button_was_pushed_down>
     6ee:	88 23       	and	r24, r24
     6f0:	a1 f1       	breq	.+104    	; 0x75a <tinyButton_update+0xa8>
	{
		if ((tinyTime_now() - tinyButton_start_time) > PULSEMODE_BUTTON_PRESS_TIME)
     6f2:	0e 94 89 09 	call	0x1312	; 0x1312 <tinyTime_now>
     6f6:	00 91 2e 38 	lds	r16, 0x382E	; 0x80382e <tinyButton_start_time>
     6fa:	10 91 2f 38 	lds	r17, 0x382F	; 0x80382f <tinyButton_start_time+0x1>
     6fe:	20 91 30 38 	lds	r18, 0x3830	; 0x803830 <tinyButton_start_time+0x2>
     702:	30 91 31 38 	lds	r19, 0x3831	; 0x803831 <tinyButton_start_time+0x3>
     706:	dc 01       	movw	r26, r24
     708:	cb 01       	movw	r24, r22
     70a:	80 1b       	sub	r24, r16
     70c:	91 0b       	sbc	r25, r17
     70e:	a2 0b       	sbc	r26, r18
     710:	b3 0b       	sbc	r27, r19
     712:	81 3d       	cpi	r24, 0xD1	; 209
     714:	97 40       	sbci	r25, 0x07	; 7
     716:	a1 05       	cpc	r26, r1
     718:	b1 05       	cpc	r27, r1
     71a:	78 f0       	brcs	.+30     	; 0x73a <tinyButton_update+0x88>
		{
			tinyPulse_toggle_pulse_mode();
     71c:	0e 94 12 09 	call	0x1224	; 0x1224 <tinyPulse_toggle_pulse_mode>
			tinyButton_start_time = tinyTime_now();
     720:	0e 94 89 09 	call	0x1312	; 0x1312 <tinyTime_now>
     724:	60 93 2e 38 	sts	0x382E, r22	; 0x80382e <tinyButton_start_time>
     728:	70 93 2f 38 	sts	0x382F, r23	; 0x80382f <tinyButton_start_time+0x1>
     72c:	80 93 30 38 	sts	0x3830, r24	; 0x803830 <tinyButton_start_time+0x2>
     730:	90 93 31 38 	sts	0x3831, r25	; 0x803831 <tinyButton_start_time+0x3>
			// We don't want switching to pulse mode to count as a button press, so we ignore the next button press
			ignore_next_button_press = true;
     734:	81 e0       	ldi	r24, 0x01	; 1
     736:	80 93 32 38 	sts	0x3832, r24	; 0x803832 <ignore_next_button_press>
		}
	}
	if (!button_is_pushed_down && button_was_pushed_down)
     73a:	cc 23       	and	r28, r28
     73c:	71 f0       	breq	.+28     	; 0x75a <tinyButton_update+0xa8>
     73e:	80 91 34 38 	lds	r24, 0x3834	; 0x803834 <button_was_pushed_down>
     742:	88 23       	and	r24, r24
     744:	51 f0       	breq	.+20     	; 0x75a <tinyButton_update+0xa8>
	{
		if(!ignore_next_button_press){
     746:	80 91 32 38 	lds	r24, 0x3832	; 0x803832 <ignore_next_button_press>
     74a:	81 11       	cpse	r24, r1
     74c:	04 c0       	rjmp	.+8      	; 0x756 <tinyButton_update+0xa4>
			button_press = true;
     74e:	81 e0       	ldi	r24, 0x01	; 1
     750:	80 93 33 38 	sts	0x3833, r24	; 0x803833 <button_press>
     754:	02 c0       	rjmp	.+4      	; 0x75a <tinyButton_update+0xa8>
		}
		else{
			ignore_next_button_press = false;
     756:	10 92 32 38 	sts	0x3832, r1	; 0x803832 <ignore_next_button_press>
		}
		
	}
	button_was_pushed_down = button_is_pushed_down;
     75a:	d0 93 34 38 	sts	0x3834, r29	; 0x803834 <button_was_pushed_down>
}
     75e:	df 91       	pop	r29
     760:	cf 91       	pop	r28
     762:	1f 91       	pop	r17
     764:	0f 91       	pop	r16
     766:	08 95       	ret

00000768 <tinyButton_update_potential>:

double tinyButton_update_potential(double potential){
	if(button_press){
     768:	20 91 33 38 	lds	r18, 0x3833	; 0x803833 <button_press>
     76c:	22 23       	and	r18, r18
     76e:	31 f0       	breq	.+12     	; 0x77c <tinyButton_update_potential+0x14>
		potential += BUTTON_PRESS_REACTION;
     770:	20 e0       	ldi	r18, 0x00	; 0
     772:	30 e0       	ldi	r19, 0x00	; 0
     774:	40 ed       	ldi	r20, 0xD0	; 208
     776:	51 e4       	ldi	r21, 0x41	; 65
     778:	0e 94 93 09 	call	0x1326	; 0x1326 <__addsf3>
	}
	return potential;
}
     77c:	08 95       	ret

0000077e <tinyCharge_is_connected_to_charger>:
*/
uint8_t charge_counter = 0; 

_Bool tinyCharge_is_connected_to_charger(){
	return connected_to_charger;
}
     77e:	80 91 59 38 	lds	r24, 0x3859	; 0x803859 <connected_to_charger>
     782:	08 95       	ret

00000784 <tinyCharge_is_fully_charged>:
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTB_get_pin_level(const uint8_t pin)
{
	return VPORTB.IN & (1 << pin);
     784:	86 b1       	in	r24, 0x06	; 6

_Bool tinyCharge_is_fully_charged(){
	return CHARGING_STATUS_PIN_get_level();
}
     786:	86 fb       	bst	r24, 6
     788:	88 27       	eor	r24, r24
     78a:	80 f9       	bld	r24, 0
     78c:	08 95       	ret

0000078e <tinyCharge_DAC_dissable>:
void tinyCharge_DAC_dissable(){
	
	// We need some way to disable the DAC to prevent huge current draw when charging (64mA). When there is no code uploaded to the attiny, there is no problem.
	// We're going to try to enable the pin as a dendrite, since they seem to be doing fine. Completely uninitializing the pin probably caused a microchip to be fried.
	
	DAC_0_uninit();
     78e:	0e 94 18 01 	call	0x230	; 0x230 <DAC_0_uninit>
	DAC_0_disable();
     792:	0e 94 23 01 	call	0x246	; 0x246 <DAC_0_disable>
     796:	08 95       	ret

00000798 <tinyCharge_DAC_enable>:
void tinyCharge_DAC_enable(){
	
	// We need some way to disable the DAC to prevent huge current draw when charging (64mA). When there is no code uploaded to the attiny, there is no problem.
	// We're going to try to enable the pin as a dendrite, since they seem to be doing fine. Completely uninitializing the pin probably caused a microchip to be fried.
	
	DAC_0_init();
     798:	0e 94 13 01 	call	0x226	; 0x226 <DAC_0_init>
	DAC_0_enable();
     79c:	0e 94 1d 01 	call	0x23a	; 0x23a <DAC_0_enable>
     7a0:	08 95       	ret

000007a2 <tinyCharge_switch_mode>:
}


void tinyCharge_switch_mode(){
	
	if(connected_to_charger){
     7a2:	80 91 59 38 	lds	r24, 0x3859	; 0x803859 <connected_to_charger>
     7a6:	88 23       	and	r24, r24
     7a8:	89 f0       	breq	.+34     	; 0x7cc <tinyCharge_switch_mode+0x2a>
		// Switch from main to charging mode
		
		// Set LED
		tinyLED_set_color_mode(OUT_LED, CHARGING_COLOR, SWING);
     7aa:	43 e0       	ldi	r20, 0x03	; 3
     7ac:	62 e0       	ldi	r22, 0x02	; 2
     7ae:	81 e0       	ldi	r24, 0x01	; 1
     7b0:	0e 94 83 05 	call	0xb06	; 0xb06 <tinyLED_set_color_mode>
		tinyLED_set_color(INN_LED, LED_OFF);
     7b4:	60 e0       	ldi	r22, 0x00	; 0
     7b6:	80 e0       	ldi	r24, 0x00	; 0
     7b8:	0e 94 ab 05 	call	0xb56	; 0xb56 <tinyLED_set_color>


		// Stop axon from firing
		// (There is a small chance that the neuron is put into charging mode as it is firing. The axon is then never told to stop firing)
		tinyAxon_stop_sending_pulse();
     7bc:	0e 94 78 02 	call	0x4f0	; 0x4f0 <tinyAxon_stop_sending_pulse>

		// disable DAC
		tinyCharge_DAC_dissable();
     7c0:	0e 94 c7 03 	call	0x78e	; 0x78e <tinyCharge_DAC_dissable>
		
		// We also turn off pulse mode, because it's confusing if it suddenly comes on
		// after it has been charging
		tinyPulse_set_pulse_mode(false);
     7c4:	80 e0       	ldi	r24, 0x00	; 0
     7c6:	0e 94 25 09 	call	0x124a	; 0x124a <tinyPulse_set_pulse_mode>
     7ca:	08 95       	ret
	}
	else{
		// Switch from charge to main mode
		
		// Set LED
		tinyLED_set_color(OUT_LED, LED_OFF);
     7cc:	60 e0       	ldi	r22, 0x00	; 0
     7ce:	81 e0       	ldi	r24, 0x01	; 1
     7d0:	0e 94 ab 05 	call	0xb56	; 0xb56 <tinyLED_set_color>
		tinyLED_set_color(INN_LED, LED_OFF);
     7d4:	60 e0       	ldi	r22, 0x00	; 0
     7d6:	80 e0       	ldi	r24, 0x00	; 0
     7d8:	0e 94 ab 05 	call	0xb56	; 0xb56 <tinyLED_set_color>
		
		// enable DAC
		tinyCharge_DAC_enable();
     7dc:	0e 94 cc 03 	call	0x798	; 0x798 <tinyCharge_DAC_enable>
     7e0:	08 95       	ret

000007e2 <tinyCharge_set_charging_mode>:
	}
}

void tinyCharge_set_charging_mode(_Bool charging_status){
	if(charging_status != connected_to_charger){
     7e2:	90 91 59 38 	lds	r25, 0x3859	; 0x803859 <connected_to_charger>
     7e6:	98 17       	cp	r25, r24
     7e8:	21 f0       	breq	.+8      	; 0x7f2 <tinyCharge_set_charging_mode+0x10>
		connected_to_charger = charging_status;
     7ea:	80 93 59 38 	sts	0x3859, r24	; 0x803859 <connected_to_charger>
		tinyCharge_switch_mode();
     7ee:	0e 94 d1 03 	call	0x7a2	; 0x7a2 <tinyCharge_switch_mode>
     7f2:	08 95       	ret

000007f4 <tinyCharge_update_charging_mode>:

/*
Checks if the levels of the dendrites and axon are at charging levels
and updates the mode accordingly
*/
void tinyCharge_update_charging_mode(){
     7f4:	cf 93       	push	r28
	// For complicated reasons, the axon_check_level will be high even when the charger is not connected
	// WHEN the neuron is in charging mode, hence we ignore the axon level when the neuron is in charging mode
	_Bool charging;
	if(connected_to_charger){
     7f6:	80 91 59 38 	lds	r24, 0x3859	; 0x803859 <connected_to_charger>
     7fa:	88 23       	and	r24, r24
     7fc:	21 f0       	breq	.+8      	; 0x806 <tinyCharge_update_charging_mode+0x12>
		charging = tinyDendrite_check_charge_level();
     7fe:	0e 94 63 04 	call	0x8c6	; 0x8c6 <tinyDendrite_check_charge_level>
     802:	c8 2f       	mov	r28, r24
     804:	0b c0       	rjmp	.+22     	; 0x81c <tinyCharge_update_charging_mode+0x28>
	} else{
		charging = tinyDendrite_check_charge_level() || tinyAxon_check_charge_level();
     806:	0e 94 63 04 	call	0x8c6	; 0x8c6 <tinyDendrite_check_charge_level>
     80a:	81 11       	cpse	r24, r1
     80c:	03 c0       	rjmp	.+6      	; 0x814 <tinyCharge_update_charging_mode+0x20>
     80e:	0e 94 4e 03 	call	0x69c	; 0x69c <tinyAxon_check_charge_level>
     812:	02 c0       	rjmp	.+4      	; 0x818 <tinyCharge_update_charging_mode+0x24>
     814:	81 e0       	ldi	r24, 0x01	; 1
     816:	90 e0       	ldi	r25, 0x00	; 0
     818:	c8 2f       	mov	r28, r24
     81a:	c1 70       	andi	r28, 0x01	; 1
	}
	
	// In order to prevent the axon from stimulating itself, we only switch into charging mode when the conditions have been right for several cycles
	if(!connected_to_charger && charging){
     81c:	80 91 59 38 	lds	r24, 0x3859	; 0x803859 <connected_to_charger>
     820:	81 11       	cpse	r24, r1
     822:	0d c0       	rjmp	.+26     	; 0x83e <tinyCharge_update_charging_mode+0x4a>
     824:	cc 23       	and	r28, r28
     826:	d1 f0       	breq	.+52     	; 0x85c <tinyCharge_update_charging_mode+0x68>
		charge_counter++;
     828:	80 91 35 38 	lds	r24, 0x3835	; 0x803835 <charge_counter>
     82c:	8f 5f       	subi	r24, 0xFF	; 255
		if(charge_counter > CYCLES_REQUIRED_FOR_CHARGING_MODE_SWITCH){
     82e:	8b 30       	cpi	r24, 0x0B	; 11
     830:	90 f0       	brcs	.+36     	; 0x856 <tinyCharge_update_charging_mode+0x62>
			charge_counter = 0;
     832:	10 92 35 38 	sts	0x3835, r1	; 0x803835 <charge_counter>
			tinyCharge_set_charging_mode(charging);
     836:	81 e0       	ldi	r24, 0x01	; 1
     838:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <tinyCharge_set_charging_mode>
     83c:	13 c0       	rjmp	.+38     	; 0x864 <tinyCharge_update_charging_mode+0x70>
		}
	}
	else{
		tinyCharge_set_charging_mode(charging);
     83e:	8c 2f       	mov	r24, r28
     840:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <tinyCharge_set_charging_mode>
	}
	
	// We have to prevent charge_counters from accumulating over time
	if(!charging && charge_counter>0){
     844:	c1 11       	cpse	r28, r1
     846:	0e c0       	rjmp	.+28     	; 0x864 <tinyCharge_update_charging_mode+0x70>
     848:	80 91 35 38 	lds	r24, 0x3835	; 0x803835 <charge_counter>
     84c:	88 23       	and	r24, r24
     84e:	51 f0       	breq	.+20     	; 0x864 <tinyCharge_update_charging_mode+0x70>
		charge_counter = 0;
     850:	10 92 35 38 	sts	0x3835, r1	; 0x803835 <charge_counter>
	}
	
}
     854:	07 c0       	rjmp	.+14     	; 0x864 <tinyCharge_update_charging_mode+0x70>
		charging = tinyDendrite_check_charge_level() || tinyAxon_check_charge_level();
	}
	
	// In order to prevent the axon from stimulating itself, we only switch into charging mode when the conditions have been right for several cycles
	if(!connected_to_charger && charging){
		charge_counter++;
     856:	80 93 35 38 	sts	0x3835, r24	; 0x803835 <charge_counter>
     85a:	04 c0       	rjmp	.+8      	; 0x864 <tinyCharge_update_charging_mode+0x70>
			charge_counter = 0;
			tinyCharge_set_charging_mode(charging);
		}
	}
	else{
		tinyCharge_set_charging_mode(charging);
     85c:	8c 2f       	mov	r24, r28
     85e:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <tinyCharge_set_charging_mode>
     862:	f2 cf       	rjmp	.-28     	; 0x848 <tinyCharge_update_charging_mode+0x54>
	// We have to prevent charge_counters from accumulating over time
	if(!charging && charge_counter>0){
		charge_counter = 0;
	}
	
}
     864:	cf 91       	pop	r28
     866:	08 95       	ret

00000868 <tinyCharge_set_transistors>:



void tinyCharge_set_transistors(){
	if(connected_to_charger){
     868:	80 91 59 38 	lds	r24, 0x3859	; 0x803859 <connected_to_charger>
     86c:	88 23       	and	r24, r24
     86e:	19 f0       	breq	.+6      	; 0x876 <tinyCharge_set_transistors+0xe>
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
	} else {
		VPORTC.OUT &= ~(1 << pin);
     870:	4d 98       	cbi	0x09, 5	; 9
 *                  false = Pin level set to "low" state
 */
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
     872:	29 9a       	sbi	0x05, 1	; 5
     874:	08 95       	ret
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     876:	4d 9a       	sbi	0x09, 5	; 9
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     878:	29 98       	cbi	0x05, 1	; 5
     87a:	08 95       	ret

0000087c <tinyDebugger_send_int>:
		char number[20]; // Arbitrary max
		dtostrf(value,1,NUMBER_OF_DECIMALS, number);
		printf("%s:%5s\t", name, number);
	}
}
void tinyDebugger_send_string(const char* name, char * value){
     87c:	08 95       	ret

0000087e <tinyDebugger_send_uint32>:
     87e:	08 95       	ret

00000880 <tinyDebugger_send_uint8>:
     880:	08 95       	ret

00000882 <tinyDebugger_send_double>:
     882:	08 95       	ret

00000884 <tinyDebugger_end_line>:
	if(DEBUGGING){
		printf("%s:%s\t", name, value);
	}
}
void tinyDebugger_end_line(){
     884:	08 95       	ret

00000886 <tinyDendrite_read_signals>:
	}
}

uint8_t tinyDendrite_get_value(uint8_t dendrite_number){
	return tinyDendrite_values[dendrite_number];
}
     886:	ef 92       	push	r14
     888:	ff 92       	push	r15
     88a:	0f 93       	push	r16
     88c:	1f 93       	push	r17
     88e:	cf 93       	push	r28
     890:	df 93       	push	r29
     892:	ce e0       	ldi	r28, 0x0E	; 14
     894:	d8 e3       	ldi	r29, 0x38	; 56
     896:	00 e4       	ldi	r16, 0x40	; 64
     898:	18 e3       	ldi	r17, 0x38	; 56
     89a:	0f 2e       	mov	r0, r31
     89c:	f3 e1       	ldi	r31, 0x13	; 19
     89e:	ef 2e       	mov	r14, r31
     8a0:	f8 e3       	ldi	r31, 0x38	; 56
     8a2:	ff 2e       	mov	r15, r31
     8a4:	f0 2d       	mov	r31, r0
     8a6:	89 91       	ld	r24, Y+
     8a8:	0e 94 dd 00 	call	0x1ba	; 0x1ba <ADC_0_get_conversion>
     8ac:	f8 01       	movw	r30, r16
     8ae:	81 93       	st	Z+, r24
     8b0:	8f 01       	movw	r16, r30
     8b2:	ce 15       	cp	r28, r14
     8b4:	df 05       	cpc	r29, r15
     8b6:	b9 f7       	brne	.-18     	; 0x8a6 <tinyDendrite_read_signals+0x20>
     8b8:	df 91       	pop	r29
     8ba:	cf 91       	pop	r28
     8bc:	1f 91       	pop	r17
     8be:	0f 91       	pop	r16
     8c0:	ff 90       	pop	r15
     8c2:	ef 90       	pop	r14
     8c4:	08 95       	ret

000008c6 <tinyDendrite_check_charge_level>:

_Bool tinyDendrite_check_charge_level(void)
{
     8c6:	cf 93       	push	r28
     8c8:	df 93       	push	r29
	_Bool charging = false;
	
	tinyDendrite_read_signals();
     8ca:	0e 94 43 04 	call	0x886	; 0x886 <tinyDendrite_read_signals>
     8ce:	eb e3       	ldi	r30, 0x3B	; 59
     8d0:	f8 e3       	ldi	r31, 0x38	; 56
     8d2:	c6 e3       	ldi	r28, 0x36	; 54
     8d4:	d8 e3       	ldi	r29, 0x38	; 56
     8d6:	a0 e4       	ldi	r26, 0x40	; 64
     8d8:	b8 e3       	ldi	r27, 0x38	; 56
     8da:	20 e4       	ldi	r18, 0x40	; 64
     8dc:	38 e3       	ldi	r19, 0x38	; 56
	return tinyDendrite_values[dendrite_number];
}

_Bool tinyDendrite_check_charge_level(void)
{
	_Bool charging = false;
     8de:	80 e0       	ldi	r24, 0x00	; 0
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = CHARGING;
     8e0:	47 e0       	ldi	r20, 0x07	; 7
	_Bool charging = false;
	
	tinyDendrite_read_signals();
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
     8e2:	90 81       	ld	r25, Z
     8e4:	99 93       	st	Y+, r25
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
     8e6:	9d 91       	ld	r25, X+
     8e8:	9f 3f       	cpi	r25, 0xFF	; 255
     8ea:	11 f4       	brne	.+4      	; 0x8f0 <tinyDendrite_check_charge_level+0x2a>
		{
			tinyDendrite_current_signals[i] = CHARGING;
     8ec:	40 83       	st	Z, r20
			charging = true;
     8ee:	81 e0       	ldi	r24, 0x01	; 1
     8f0:	31 96       	adiw	r30, 0x01	; 1
_Bool tinyDendrite_check_charge_level(void)
{
	_Bool charging = false;
	
	tinyDendrite_read_signals();
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
     8f2:	e2 17       	cp	r30, r18
     8f4:	f3 07       	cpc	r31, r19
     8f6:	a9 f7       	brne	.-22     	; 0x8e2 <tinyDendrite_check_charge_level+0x1c>
			tinyDendrite_current_signals[i] = CHARGING;
			charging = true;
		}
	}
	return charging;
}
     8f8:	df 91       	pop	r29
     8fa:	cf 91       	pop	r28
     8fc:	08 95       	ret

000008fe <tinyDendrite_update_signals>:

/*
This function converts the 8 bit value from the ADC into one of the signal types defined in DendriteSignal
*/
void tinyDendrite_update_signals(void)
{
     8fe:	af 92       	push	r10
     900:	bf 92       	push	r11
     902:	df 92       	push	r13
     904:	ef 92       	push	r14
     906:	ff 92       	push	r15
     908:	0f 93       	push	r16
     90a:	1f 93       	push	r17
     90c:	cf 93       	push	r28
     90e:	df 93       	push	r29
	
	// This function does not read the dendrite values! Read_signals must be called somewhere prior to this function!
	// As of writing this, the update_charging_mode function in main runs check_charge_level, so 
	// the tinyDendrite_values are updated when update_signals is called later
	
	tinyDebugger_send_uint8("D1", tinyDendrite_values[0]);
     910:	c0 e4       	ldi	r28, 0x40	; 64
     912:	d8 e3       	ldi	r29, 0x38	; 56
     914:	68 81       	ld	r22, Y
     916:	87 eb       	ldi	r24, 0xB7	; 183
     918:	9a e9       	ldi	r25, 0x9A	; 154
     91a:	0e 94 40 04 	call	0x880	; 0x880 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D2", tinyDendrite_values[1]);
     91e:	69 81       	ldd	r22, Y+1	; 0x01
     920:	8a eb       	ldi	r24, 0xBA	; 186
     922:	9a e9       	ldi	r25, 0x9A	; 154
     924:	0e 94 40 04 	call	0x880	; 0x880 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D3", tinyDendrite_values[2]);
     928:	6a 81       	ldd	r22, Y+2	; 0x02
     92a:	8d eb       	ldi	r24, 0xBD	; 189
     92c:	9a e9       	ldi	r25, 0x9A	; 154
     92e:	0e 94 40 04 	call	0x880	; 0x880 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D4", tinyDendrite_values[3]);
     932:	6b 81       	ldd	r22, Y+3	; 0x03
     934:	80 ec       	ldi	r24, 0xC0	; 192
     936:	9a e9       	ldi	r25, 0x9A	; 154
     938:	0e 94 40 04 	call	0x880	; 0x880 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D5", tinyDendrite_values[4]);
     93c:	6c 81       	ldd	r22, Y+4	; 0x04
     93e:	83 ec       	ldi	r24, 0xC3	; 195
     940:	9a e9       	ldi	r25, 0x9A	; 154
     942:	0e 94 40 04 	call	0x880	; 0x880 <tinyDebugger_send_uint8>
     946:	eb e3       	ldi	r30, 0x3B	; 59
     948:	f8 e3       	ldi	r31, 0x38	; 56
     94a:	26 e3       	ldi	r18, 0x36	; 54
     94c:	38 e3       	ldi	r19, 0x38	; 56
     94e:	5e 01       	movw	r10, r28
     950:	40 e4       	ldi	r20, 0x40	; 64
     952:	58 e3       	ldi	r21, 0x38	; 56
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     954:	dd 24       	eor	r13, r13
     956:	d3 94       	inc	r13
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
		}
		else if (tinyDendrite_values[i] > HIGH_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
     958:	0f 2e       	mov	r0, r31
     95a:	f3 e0       	ldi	r31, 0x03	; 3
     95c:	ef 2e       	mov	r14, r31
     95e:	f0 2d       	mov	r31, r0
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     960:	68 94       	set
     962:	ff 24       	eor	r15, r15
     964:	f1 f8       	bld	r15, 1
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     966:	04 e0       	ldi	r16, 0x04	; 4
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     968:	16 e0       	ldi	r17, 0x06	; 6
			// been moved to tinyDendrite_check_charging.
			//charging = true;
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     96a:	65 e0       	ldi	r22, 0x05	; 5
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = CHARGING;
     96c:	77 e0       	ldi	r23, 0x07	; 7
     96e:	df 01       	movw	r26, r30
	tinyDebugger_send_uint8("D4", tinyDendrite_values[3]);
	tinyDebugger_send_uint8("D5", tinyDendrite_values[4]);
	
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
     970:	90 81       	ld	r25, Z
     972:	e9 01       	movw	r28, r18
     974:	99 93       	st	Y+, r25
     976:	9e 01       	movw	r18, r28
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
     978:	e5 01       	movw	r28, r10
     97a:	89 91       	ld	r24, Y+
     97c:	5e 01       	movw	r10, r28
     97e:	8f 3f       	cpi	r24, 0xFF	; 255
     980:	11 f4       	brne	.+4      	; 0x986 <tinyDendrite_update_signals+0x88>
		{
			tinyDendrite_current_signals[i] = CHARGING;
     982:	70 83       	st	Z, r23
     984:	19 c0       	rjmp	.+50     	; 0x9b8 <tinyDendrite_update_signals+0xba>
			// Previously, we used this function to check charging, but this has now
			// been moved to tinyDendrite_check_charging.
			//charging = true;
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
     986:	8b 3d       	cpi	r24, 0xDB	; 219
     988:	10 f0       	brcs	.+4      	; 0x98e <tinyDendrite_update_signals+0x90>
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     98a:	60 83       	st	Z, r22
     98c:	15 c0       	rjmp	.+42     	; 0x9b8 <tinyDendrite_update_signals+0xba>
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
     98e:	86 3b       	cpi	r24, 0xB6	; 182
     990:	10 f0       	brcs	.+4      	; 0x996 <tinyDendrite_update_signals+0x98>
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     992:	10 83       	st	Z, r17
     994:	11 c0       	rjmp	.+34     	; 0x9b8 <tinyDendrite_update_signals+0xba>
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
     996:	82 39       	cpi	r24, 0x92	; 146
     998:	10 f0       	brcs	.+4      	; 0x99e <tinyDendrite_update_signals+0xa0>
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     99a:	00 83       	st	Z, r16
     99c:	0d c0       	rjmp	.+26     	; 0x9b8 <tinyDendrite_update_signals+0xba>
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
     99e:	8e 36       	cpi	r24, 0x6E	; 110
     9a0:	10 f0       	brcs	.+4      	; 0x9a6 <tinyDendrite_update_signals+0xa8>
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     9a2:	f0 82       	st	Z, r15
     9a4:	09 c0       	rjmp	.+18     	; 0x9b8 <tinyDendrite_update_signals+0xba>
		}
		else if (tinyDendrite_values[i] > HIGH_INHIB_THRESHOLD)
     9a6:	8a 34       	cpi	r24, 0x4A	; 74
     9a8:	10 f0       	brcs	.+4      	; 0x9ae <tinyDendrite_update_signals+0xb0>
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
     9aa:	e0 82       	st	Z, r14
     9ac:	05 c0       	rjmp	.+10     	; 0x9b8 <tinyDendrite_update_signals+0xba>
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
     9ae:	85 32       	cpi	r24, 0x25	; 37
     9b0:	10 f0       	brcs	.+4      	; 0x9b6 <tinyDendrite_update_signals+0xb8>
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     9b2:	d0 82       	st	Z, r13
     9b4:	01 c0       	rjmp	.+2      	; 0x9b8 <tinyDendrite_update_signals+0xba>
		}
		else
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     9b6:	10 82       	st	Z, r1
		}
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
     9b8:	8c 91       	ld	r24, X
     9ba:	98 13       	cpse	r25, r24
     9bc:	01 c0       	rjmp	.+2      	; 0x9c0 <tinyDendrite_update_signals+0xc2>
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     9be:	1c 92       	st	X, r1
     9c0:	31 96       	adiw	r30, 0x01	; 1
	tinyDebugger_send_uint8("D2", tinyDendrite_values[1]);
	tinyDebugger_send_uint8("D3", tinyDendrite_values[2]);
	tinyDebugger_send_uint8("D4", tinyDendrite_values[3]);
	tinyDebugger_send_uint8("D5", tinyDendrite_values[4]);
	
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
     9c2:	e4 17       	cp	r30, r20
     9c4:	f5 07       	cpc	r31, r21
     9c6:	99 f6       	brne	.-90     	; 0x96e <tinyDendrite_update_signals+0x70>
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
		}
	}
}
     9c8:	df 91       	pop	r29
     9ca:	cf 91       	pop	r28
     9cc:	1f 91       	pop	r17
     9ce:	0f 91       	pop	r16
     9d0:	ff 90       	pop	r15
     9d2:	ef 90       	pop	r14
     9d4:	df 90       	pop	r13
     9d6:	bf 90       	pop	r11
     9d8:	af 90       	pop	r10
     9da:	08 95       	ret

000009dc <tinyDendrite_get_potential>:
/*
This is the master function of the module that is callable from
outside. It uses the previously declared functions to return the potential.
*/
int16_t tinyDendrite_get_potential()
{
     9dc:	cf 93       	push	r28
     9de:	df 93       	push	r29
	if(tinyAxon_is_firing() && IGNORE_INPUT_WHILE_FIRING){
     9e0:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <tinyAxon_is_firing>
		
		return NO_SIGNAL_REACTION;
	}
	
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
     9e4:	0e 94 7f 04 	call	0x8fe	; 0x8fe <tinyDendrite_update_signals>
     9e8:	eb e3       	ldi	r30, 0x3B	; 59
     9ea:	f8 e3       	ldi	r31, 0x38	; 56
     9ec:	20 e4       	ldi	r18, 0x40	; 64
     9ee:	38 e3       	ldi	r19, 0x38	; 56
	
	int16_t return_potential_val = 0;
     9f0:	c0 e0       	ldi	r28, 0x00	; 0
     9f2:	d0 e0       	ldi	r29, 0x00	; 0
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		switch(tinyDendrite_current_signals[i])
     9f4:	81 91       	ld	r24, Z+
     9f6:	83 30       	cpi	r24, 0x03	; 3
     9f8:	89 f0       	breq	.+34     	; 0xa1c <tinyDendrite_get_potential+0x40>
     9fa:	28 f4       	brcc	.+10     	; 0xa06 <tinyDendrite_get_potential+0x2a>
     9fc:	81 30       	cpi	r24, 0x01	; 1
     9fe:	91 f0       	breq	.+36     	; 0xa24 <tinyDendrite_get_potential+0x48>
     a00:	82 30       	cpi	r24, 0x02	; 2
     a02:	71 f0       	breq	.+28     	; 0xa20 <tinyDendrite_get_potential+0x44>
     a04:	10 c0       	rjmp	.+32     	; 0xa26 <tinyDendrite_get_potential+0x4a>
     a06:	85 30       	cpi	r24, 0x05	; 5
     a08:	29 f0       	breq	.+10     	; 0xa14 <tinyDendrite_get_potential+0x38>
     a0a:	30 f0       	brcs	.+12     	; 0xa18 <tinyDendrite_get_potential+0x3c>
     a0c:	86 30       	cpi	r24, 0x06	; 6
     a0e:	59 f4       	brne	.+22     	; 0xa26 <tinyDendrite_get_potential+0x4a>
		{
			case NO_SIGNAL:
				return_potential_val += NO_SIGNAL_REACTION;
				break;
			case HIGH_EXCITE:
				return_potential_val += HIGH_EXCITE_REACTION;
     a10:	e4 96       	adiw	r28, 0x34	; 52
				//tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
				break;
     a12:	09 c0       	rjmp	.+18     	; 0xa26 <tinyDendrite_get_potential+0x4a>
			case NORMAL_EXCITE:
				return_potential_val += NORMAL_EXCITE_REACTION;
     a14:	69 96       	adiw	r28, 0x19	; 25
				//tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
				break;
     a16:	07 c0       	rjmp	.+14     	; 0xa26 <tinyDendrite_get_potential+0x4a>
			case LOW_EXCITE:
				return_potential_val += LOW_EXCITE_REACTION;
     a18:	64 96       	adiw	r28, 0x14	; 20
				//tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
				break;
     a1a:	05 c0       	rjmp	.+10     	; 0xa26 <tinyDendrite_get_potential+0x4a>
			case HIGH_INHIB:
				return_potential_val += HIGH_INHIB_REACTION;
     a1c:	e2 97       	sbiw	r28, 0x32	; 50
				//tinyLED_set_color_mode(INN_LED, RED, FLASH_ONCE);
				break;
     a1e:	03 c0       	rjmp	.+6      	; 0xa26 <tinyDendrite_get_potential+0x4a>
			case NORMAL_INHIB:
				return_potential_val += NORMAL_INHIB_REACTION;
     a20:	69 97       	sbiw	r28, 0x19	; 25
				//tinyLED_set_color_mode(INN_LED, RED, FLASH_ONCE);
				break;
     a22:	01 c0       	rjmp	.+2      	; 0xa26 <tinyDendrite_get_potential+0x4a>
			case LOW_INHIB:
				return_potential_val += LOW_INHIB_REACTION;
     a24:	64 97       	sbiw	r28, 0x14	; 20
	
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
	
	int16_t return_potential_val = 0;
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
     a26:	e2 17       	cp	r30, r18
     a28:	f3 07       	cpc	r31, r19
     a2a:	21 f7       	brne	.-56     	; 0x9f4 <tinyDendrite_get_potential+0x18>
			default:
				break;
		}
	}
	
	tinyDebugger_send_int("ReturnP", return_potential_val);
     a2c:	be 01       	movw	r22, r28
     a2e:	86 ec       	ldi	r24, 0xC6	; 198
     a30:	9a e9       	ldi	r25, 0x9A	; 154
     a32:	0e 94 3e 04 	call	0x87c	; 0x87c <tinyDebugger_send_int>
	
	
	return return_potential_val;
	
}
     a36:	ce 01       	movw	r24, r28
     a38:	df 91       	pop	r29
     a3a:	cf 91       	pop	r28
     a3c:	08 95       	ret

00000a3e <tinyDendrite_update_potential>:

double tinyDendrite_update_potential(double potential){
     a3e:	cf 92       	push	r12
     a40:	df 92       	push	r13
     a42:	ef 92       	push	r14
     a44:	ff 92       	push	r15
     a46:	6b 01       	movw	r12, r22
     a48:	7c 01       	movw	r14, r24
	
	int16_t potential_change = tinyDendrite_get_potential();
     a4a:	0e 94 ee 04 	call	0x9dc	; 0x9dc <tinyDendrite_get_potential>
	/*
	We DON'T want to signal that we have recived a signal, we want to signal that the potential has changed!
	We could send flashes from here, but instead, I'll try to implement a light mode that is constantly communicating the value of the potential.
	*/
	
	return potential;
     a4e:	bc 01       	movw	r22, r24
     a50:	99 0f       	add	r25, r25
     a52:	88 0b       	sbc	r24, r24
     a54:	99 0b       	sbc	r25, r25
     a56:	0e 94 e8 0a 	call	0x15d0	; 0x15d0 <__floatsisf>
     a5a:	a7 01       	movw	r20, r14
     a5c:	96 01       	movw	r18, r12
     a5e:	0e 94 93 09 	call	0x1326	; 0x1326 <__addsf3>
     a62:	ff 90       	pop	r15
     a64:	ef 90       	pop	r14
     a66:	df 90       	pop	r13
     a68:	cf 90       	pop	r12
     a6a:	08 95       	ret

00000a6c <__vector_6>:
This function is called every time the RTC (Real Time Clock) counter overflows.
With the current settings, it will be called every ms.
The RTC clock runs at 1kHz, and the number of cycles before overflow is set with RTC.PER = someHexValue (e.g. 0x20) in src/rtc.c
*/
ISR(RTC_CNT_vect)
{
     a6c:	1f 92       	push	r1
     a6e:	0f 92       	push	r0
     a70:	0f b6       	in	r0, 0x3f	; 63
     a72:	0f 92       	push	r0
     a74:	11 24       	eor	r1, r1
     a76:	2f 93       	push	r18
     a78:	3f 93       	push	r19
     a7a:	4f 93       	push	r20
     a7c:	5f 93       	push	r21
     a7e:	6f 93       	push	r22
     a80:	7f 93       	push	r23
     a82:	8f 93       	push	r24
     a84:	9f 93       	push	r25
     a86:	af 93       	push	r26
     a88:	bf 93       	push	r27
     a8a:	cf 93       	push	r28
     a8c:	ef 93       	push	r30
     a8e:	ff 93       	push	r31
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     a90:	c1 e0       	ldi	r28, 0x01	; 1
     a92:	c0 93 45 38 	sts	0x3845, r28	; 0x803845 <tinyISR_interrupt_flag>
{
	// Set flag to let main loop run a new cycle
	tinyISR_setflag(true);
	
	// Timer counter incrementation
	tinyTime_counter_increment();
     a96:	0e 94 75 09 	call	0x12ea	; 0x12ea <tinyTime_counter_increment>

	/* Overflow interrupt flag has to be cleared manually */
	RTC.INTFLAGS = RTC_OVF_bm;
     a9a:	c0 93 43 01 	sts	0x0143, r28	; 0x800143 <__TEXT_REGION_LENGTH__+0x700143>
}
     a9e:	ff 91       	pop	r31
     aa0:	ef 91       	pop	r30
     aa2:	cf 91       	pop	r28
     aa4:	bf 91       	pop	r27
     aa6:	af 91       	pop	r26
     aa8:	9f 91       	pop	r25
     aaa:	8f 91       	pop	r24
     aac:	7f 91       	pop	r23
     aae:	6f 91       	pop	r22
     ab0:	5f 91       	pop	r21
     ab2:	4f 91       	pop	r20
     ab4:	3f 91       	pop	r19
     ab6:	2f 91       	pop	r18
     ab8:	0f 90       	pop	r0
     aba:	0f be       	out	0x3f, r0	; 63
     abc:	0f 90       	pop	r0
     abe:	1f 90       	pop	r1
     ac0:	18 95       	reti

00000ac2 <tinyISR_setflag>:
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     ac2:	80 93 45 38 	sts	0x3845, r24	; 0x803845 <tinyISR_interrupt_flag>
     ac6:	08 95       	ret

00000ac8 <tinyISR_getflag>:
}

_Bool tinyISR_getflag(void)
{
	return tinyISR_interrupt_flag;
}
     ac8:	80 91 45 38 	lds	r24, 0x3845	; 0x803845 <tinyISR_interrupt_flag>
     acc:	08 95       	ret

00000ace <tinyLED_SPIWriteByte>:
Function used to send a byte over SPI, which in turn gets
translated to the bit-sequence required by the LEDs over the CCL.
*/
static void tinyLED_SPIWriteByte(uint8_t byte)
{
	SPI0.INTFLAGS = SPI0_INTFLAGS; // clear the write collision flag to allow writing
     ace:	90 91 23 08 	lds	r25, 0x0823	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
     ad2:	90 93 23 08 	sts	0x0823, r25	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
	TCA0.SINGLE.CNT = 0; // reset TCA counter register to ensure the first rising edge of the PWM is predictable
     ad6:	e0 e0       	ldi	r30, 0x00	; 0
     ad8:	fa e0       	ldi	r31, 0x0A	; 10
     ada:	10 a2       	std	Z+32, r1	; 0x20
     adc:	11 a2       	std	Z+33, r1	; 0x21
	
	// start TCA
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 1 << TCA_SPLIT_ENABLE_bp;
     ade:	91 e0       	ldi	r25, 0x01	; 1
     ae0:	90 83       	st	Z, r25
	SPI0_DATA = byte;
     ae2:	80 93 24 08 	sts	0x0824, r24	; 0x800824 <__TEXT_REGION_LENGTH__+0x700824>

	while((SPI0.INTFLAGS & SPI_RXCIE_bm) == 0){} // wait for transfer to complete
     ae6:	e0 e2       	ldi	r30, 0x20	; 32
     ae8:	f8 e0       	ldi	r31, 0x08	; 8
     aea:	83 81       	ldd	r24, Z+3	; 0x03
     aec:	88 23       	and	r24, r24
     aee:	ec f7       	brge	.-6      	; 0xaea <tinyLED_SPIWriteByte+0x1c>
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 0 << TCA_SPLIT_ENABLE_bp; //Stop TCA
     af0:	10 92 00 0a 	sts	0x0A00, r1	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
     af4:	08 95       	ret

00000af6 <tinyLED_get_color>:
	tinyLED_set_color_mode(LED_id, color, STABLE);
}

enum Colors tinyLED_get_color(uint8_t LED_id)
{
	return tinyLED_settings[LED_id].color;
     af6:	e8 2f       	mov	r30, r24
     af8:	f0 e0       	ldi	r31, 0x00	; 0
     afa:	ee 0f       	add	r30, r30
     afc:	ff 1f       	adc	r31, r31
     afe:	ec 59       	subi	r30, 0x9C	; 156
     b00:	f7 4c       	sbci	r31, 0xC7	; 199
}
     b02:	80 81       	ld	r24, Z
     b04:	08 95       	ret

00000b06 <tinyLED_set_color_mode>:
{
	// If we are in pulse mode, we want to stay in pulse mode after we have flashed a light.
	// We do this by storing the previous mode in old settings.
	// However, it can happen that two flashes comes very quickly after one another, that leads
	// to an infinite flash loop, therefore, we only store the settings if it is not flash mode.
	if(tinyLED_settings[LED_id].mode != FLASH_ONCE){
     b06:	90 e0       	ldi	r25, 0x00	; 0
     b08:	fc 01       	movw	r30, r24
     b0a:	ee 0f       	add	r30, r30
     b0c:	ff 1f       	adc	r31, r31
     b0e:	ec 59       	subi	r30, 0x9C	; 156
     b10:	f7 4c       	sbci	r31, 0xC7	; 199
     b12:	51 81       	ldd	r21, Z+1	; 0x01
     b14:	55 30       	cpi	r21, 0x05	; 5
     b16:	61 f0       	breq	.+24     	; 0xb30 <tinyLED_set_color_mode+0x2a>
		// We use two lines to avoid pointer trouble. (I'm not good with pointers)
		tinyLED_old_settings[LED_id].color = tinyLED_settings[LED_id].color;
     b18:	9c 01       	movw	r18, r24
     b1a:	22 0f       	add	r18, r18
     b1c:	33 1f       	adc	r19, r19
     b1e:	f9 01       	movw	r30, r18
     b20:	e8 59       	subi	r30, 0x98	; 152
     b22:	f7 4c       	sbci	r31, 0xC7	; 199
     b24:	d9 01       	movw	r26, r18
     b26:	ac 59       	subi	r26, 0x9C	; 156
     b28:	b7 4c       	sbci	r27, 0xC7	; 199
     b2a:	2c 91       	ld	r18, X
     b2c:	20 83       	st	Z, r18
		tinyLED_old_settings[LED_id].mode = tinyLED_settings[LED_id].mode;
     b2e:	51 83       	std	Z+1, r21	; 0x01
	}
	
	struct ColorSetting new_setting = {.color=color, .mode=mode};
	tinyLED_settings[LED_id] = new_setting;
     b30:	fc 01       	movw	r30, r24
     b32:	ee 0f       	add	r30, r30
     b34:	ff 1f       	adc	r31, r31
     b36:	ec 59       	subi	r30, 0x9C	; 156
     b38:	f7 4c       	sbci	r31, 0xC7	; 199
     b3a:	60 83       	st	Z, r22
     b3c:	41 83       	std	Z+1, r20	; 0x01
	if (mode == FLASH_ONCE)
     b3e:	45 30       	cpi	r20, 0x05	; 5
     b40:	49 f4       	brne	.+18     	; 0xb54 <tinyLED_set_color_mode+0x4e>
	{
		tinyLED_flash_once_time[LED_id] = 1000*FLASH_TIME;
     b42:	88 0f       	add	r24, r24
     b44:	99 1f       	adc	r25, r25
     b46:	fc 01       	movw	r30, r24
     b48:	e6 5a       	subi	r30, 0xA6	; 166
     b4a:	f7 4c       	sbci	r31, 0xC7	; 199
     b4c:	88 ec       	ldi	r24, 0xC8	; 200
     b4e:	90 e0       	ldi	r25, 0x00	; 0
     b50:	80 83       	st	Z, r24
     b52:	91 83       	std	Z+1, r25	; 0x01
     b54:	08 95       	ret

00000b56 <tinyLED_set_color>:
/*
changes the values in the variables stored in the LED-array.
*/
void tinyLED_set_color(uint8_t LED_id, enum Colors color)
{
	tinyLED_set_color_mode(LED_id, color, STABLE);
     b56:	40 e0       	ldi	r20, 0x00	; 0
     b58:	0e 94 83 05 	call	0xb06	; 0xb06 <tinyLED_set_color_mode>
     b5c:	08 95       	ret

00000b5e <tinyLED_RGB_Color_Compare>:
	return rgb_color;
			
};
// This might be cause of strange light behavior?
//Message		expected 'struct RGB_Color *' but argument is of type 'struct RGB_Color (*)[2]'	Hjernebyggesett_V4	C:\Users\Elias Lundheim\Documents\GitHub\neural\Hjernebyggesett_V4\Hjernebyggesett_V4\tinyLED\tinyLED.c	121
_Bool tinyLED_RGB_Color_Compare(struct RGB_Color (*a)[NUMBER_OF_LEDS], struct RGB_Color (*b)[NUMBER_OF_LEDS]){
     b5e:	dc 01       	movw	r26, r24
     b60:	fb 01       	movw	r30, r22
	for (int i=0; i<NUMBER_OF_LEDS; i++)
	{
		if(!((*a)[i].red==(*b)[i].red && (*a)[i].green==(*b)[i].green && (*a)[i].blue==(*b)[i].blue)){
     b62:	9c 91       	ld	r25, X
     b64:	80 81       	ld	r24, Z
     b66:	98 13       	cpse	r25, r24
     b68:	20 c0       	rjmp	.+64     	; 0xbaa <tinyLED_RGB_Color_Compare+0x4c>
     b6a:	11 96       	adiw	r26, 0x01	; 1
     b6c:	9c 91       	ld	r25, X
     b6e:	11 97       	sbiw	r26, 0x01	; 1
     b70:	81 81       	ldd	r24, Z+1	; 0x01
     b72:	98 13       	cpse	r25, r24
     b74:	1c c0       	rjmp	.+56     	; 0xbae <tinyLED_RGB_Color_Compare+0x50>
     b76:	12 96       	adiw	r26, 0x02	; 2
     b78:	9c 91       	ld	r25, X
     b7a:	12 97       	sbiw	r26, 0x02	; 2
     b7c:	82 81       	ldd	r24, Z+2	; 0x02
     b7e:	98 13       	cpse	r25, r24
     b80:	18 c0       	rjmp	.+48     	; 0xbb2 <tinyLED_RGB_Color_Compare+0x54>
     b82:	13 96       	adiw	r26, 0x03	; 3
     b84:	9c 91       	ld	r25, X
     b86:	13 97       	sbiw	r26, 0x03	; 3
     b88:	83 81       	ldd	r24, Z+3	; 0x03
     b8a:	98 13       	cpse	r25, r24
     b8c:	14 c0       	rjmp	.+40     	; 0xbb6 <tinyLED_RGB_Color_Compare+0x58>
     b8e:	14 96       	adiw	r26, 0x04	; 4
     b90:	9c 91       	ld	r25, X
     b92:	14 97       	sbiw	r26, 0x04	; 4
     b94:	84 81       	ldd	r24, Z+4	; 0x04
     b96:	98 13       	cpse	r25, r24
     b98:	10 c0       	rjmp	.+32     	; 0xbba <tinyLED_RGB_Color_Compare+0x5c>
     b9a:	81 e0       	ldi	r24, 0x01	; 1
     b9c:	15 96       	adiw	r26, 0x05	; 5
     b9e:	2c 91       	ld	r18, X
     ba0:	95 81       	ldd	r25, Z+5	; 0x05
     ba2:	29 17       	cp	r18, r25
     ba4:	59 f0       	breq	.+22     	; 0xbbc <tinyLED_RGB_Color_Compare+0x5e>
     ba6:	80 e0       	ldi	r24, 0x00	; 0
     ba8:	08 95       	ret
			return false;
     baa:	80 e0       	ldi	r24, 0x00	; 0
     bac:	08 95       	ret
     bae:	80 e0       	ldi	r24, 0x00	; 0
     bb0:	08 95       	ret
     bb2:	80 e0       	ldi	r24, 0x00	; 0
     bb4:	08 95       	ret
     bb6:	80 e0       	ldi	r24, 0x00	; 0
     bb8:	08 95       	ret
     bba:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	return true;
}
     bbc:	08 95       	ret

00000bbe <tinyLED_update>:
/*
function to write the current LED-array on to the LEDs and
effectively update the values stored in the LEDs to the values stored in the MCU.
*/
void tinyLED_update(void)
{
     bbe:	2f 92       	push	r2
     bc0:	3f 92       	push	r3
     bc2:	4f 92       	push	r4
     bc4:	5f 92       	push	r5
     bc6:	6f 92       	push	r6
     bc8:	7f 92       	push	r7
     bca:	8f 92       	push	r8
     bcc:	9f 92       	push	r9
     bce:	af 92       	push	r10
     bd0:	bf 92       	push	r11
     bd2:	cf 92       	push	r12
     bd4:	df 92       	push	r13
     bd6:	ef 92       	push	r14
     bd8:	ff 92       	push	r15
     bda:	0f 93       	push	r16
     bdc:	1f 93       	push	r17
     bde:	cf 93       	push	r28
     be0:	df 93       	push	r29
     be2:	cd b7       	in	r28, 0x3d	; 61
     be4:	de b7       	in	r29, 0x3e	; 62
     be6:	ab 97       	sbiw	r28, 0x2b	; 43
     be8:	cd bf       	out	0x3d, r28	; 61
     bea:	de bf       	out	0x3e, r29	; 62
			
	uint32_t now = tinyTime_now();
     bec:	0e 94 89 09 	call	0x1312	; 0x1312 <tinyTime_now>
     bf0:	6b 01       	movw	r12, r22
     bf2:	7c 01       	movw	r14, r24
	uint8_t red = 0;
	uint8_t green = 0;
	
	// This is a sin curve, but between 0 and 1 instead of -1 and 1
	double sinValue = 0.5+sin((double)now/(100*M_PI/SWING_RATE))/2;
     bf4:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <__floatunsisf>
     bf8:	23 e6       	ldi	r18, 0x63	; 99
     bfa:	34 e1       	ldi	r19, 0x14	; 20
     bfc:	4d e1       	ldi	r20, 0x1D	; 29
     bfe:	54 e4       	ldi	r21, 0x44	; 68
     c00:	0e 94 04 0a 	call	0x1408	; 0x1408 <__divsf3>
     c04:	0e 94 c6 0c 	call	0x198c	; 0x198c <sin>
     c08:	20 e0       	ldi	r18, 0x00	; 0
     c0a:	30 e0       	ldi	r19, 0x00	; 0
     c0c:	40 e0       	ldi	r20, 0x00	; 0
     c0e:	5f e3       	ldi	r21, 0x3F	; 63
     c10:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <__mulsf3>
     c14:	20 e0       	ldi	r18, 0x00	; 0
     c16:	30 e0       	ldi	r19, 0x00	; 0
     c18:	40 e0       	ldi	r20, 0x00	; 0
     c1a:	5f e3       	ldi	r21, 0x3F	; 63
     c1c:	0e 94 93 09 	call	0x1326	; 0x1326 <__addsf3>
     c20:	68 87       	std	Y+8, r22	; 0x08
     c22:	79 87       	std	Y+9, r23	; 0x09
     c24:	8a 87       	std	Y+10, r24	; 0x0a
     c26:	9b 87       	std	Y+11, r25	; 0x0b
	
	// If FLASH_RATE is one, then that means that the left side of the "<" will just count from 0 to 1000, and flash_on will be true for half of the time
	_Bool flash_on = now%(uint32_t)(1000/FLASH_RATE)  <   500/FLASH_RATE;
     c28:	c7 01       	movw	r24, r14
     c2a:	b6 01       	movw	r22, r12
     c2c:	28 ee       	ldi	r18, 0xE8	; 232
     c2e:	33 e0       	ldi	r19, 0x03	; 3
     c30:	40 e0       	ldi	r20, 0x00	; 0
     c32:	50 e0       	ldi	r21, 0x00	; 0
     c34:	0e 94 2f 0d 	call	0x1a5e	; 0x1a5e <__udivmodsi4>
     c38:	21 e0       	ldi	r18, 0x01	; 1
     c3a:	2f 83       	std	Y+7, r18	; 0x07
     c3c:	64 3f       	cpi	r22, 0xF4	; 244
     c3e:	71 40       	sbci	r23, 0x01	; 1
     c40:	81 05       	cpc	r24, r1
     c42:	91 05       	cpc	r25, r1
     c44:	08 f0       	brcs	.+2      	; 0xc48 <tinyLED_update+0x8a>
     c46:	1f 82       	std	Y+7, r1	; 0x07
	
	// PING_RATE is usually small, so the left side counts to some large number. Since flash_time usually is also quite small,
	// the left side will usually be larger than the right
	_Bool ping_on =  now%(uint32_t)(1000/PING_RATE)   <   1000*FLASH_TIME;
     c48:	c7 01       	movw	r24, r14
     c4a:	b6 01       	movw	r22, r12
     c4c:	20 e1       	ldi	r18, 0x10	; 16
     c4e:	37 e2       	ldi	r19, 0x27	; 39
     c50:	40 e0       	ldi	r20, 0x00	; 0
     c52:	50 e0       	ldi	r21, 0x00	; 0
     c54:	0e 94 2f 0d 	call	0x1a5e	; 0x1a5e <__udivmodsi4>
     c58:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <__floatunsisf>
     c5c:	20 e0       	ldi	r18, 0x00	; 0
     c5e:	30 e0       	ldi	r19, 0x00	; 0
     c60:	48 e4       	ldi	r20, 0x48	; 72
     c62:	53 e4       	ldi	r21, 0x43	; 67
     c64:	0e 94 ff 09 	call	0x13fe	; 0x13fe <__cmpsf2>
     c68:	18 2f       	mov	r17, r24
     c6a:	11 1f       	adc	r17, r17
     c6c:	11 27       	eor	r17, r17
     c6e:	11 1f       	adc	r17, r17
	
	// Find potential 
	double tinyPotential_potental = tinyPotential_get_potential();
     c70:	0e 94 7f 08 	call	0x10fe	; 0x10fe <tinyPotential_get_potential>
     c74:	6c 87       	std	Y+12, r22	; 0x0c
     c76:	7d 87       	std	Y+13, r23	; 0x0d
     c78:	8e 87       	std	Y+14, r24	; 0x0e
     c7a:	9f 87       	std	Y+15, r25	; 0x0f
	uint16_t tinyAxon_pulses_in_queue = tinyAxon_get_pulses_in_queue();
     c7c:	0e 94 62 02 	call	0x4c4	; 0x4c4 <tinyAxon_get_pulses_in_queue>
			
			case POTENTIAL:
				// In this mode, we try to communicate the level of the potential with color and brightness
				
				if(tinyPotential_potental > 0 || tinyAxon_pulses_in_queue > 0){
					green = fmin(255*LED_BRIGHTNESS * (tinyPotential_potental+tinyAxon_pulses_in_queue*THRESHOLD_POTENTIAL)/FULL_BRIGHTNESS_POTENTIAL, 255);
     c80:	48 2f       	mov	r20, r24
     c82:	50 e0       	ldi	r21, 0x00	; 0
     c84:	4e 8f       	std	Y+30, r20	; 0x1e
     c86:	5f 8f       	std	Y+31, r21	; 0x1f
     c88:	59 e1       	ldi	r21, 0x19	; 25
     c8a:	85 9f       	mul	r24, r21
     c8c:	c0 01       	movw	r24, r0
     c8e:	11 24       	eor	r1, r1
     c90:	0f 2e       	mov	r0, r31
     c92:	f4 e6       	ldi	r31, 0x64	; 100
     c94:	2f 2e       	mov	r2, r31
     c96:	f8 e3       	ldi	r31, 0x38	; 56
     c98:	3f 2e       	mov	r3, r31
     c9a:	f0 2d       	mov	r31, r0
     c9c:	de 01       	movw	r26, r28
     c9e:	11 96       	adiw	r26, 0x01	; 1
     ca0:	5d 01       	movw	r10, r26
     ca2:	0f 2e       	mov	r0, r31
     ca4:	f8 e6       	ldi	r31, 0x68	; 104
     ca6:	4f 2e       	mov	r4, r31
     ca8:	f8 e3       	ldi	r31, 0x38	; 56
     caa:	5f 2e       	mov	r5, r31
     cac:	f0 2d       	mov	r31, r0
     cae:	0f 2e       	mov	r0, r31
     cb0:	fa e5       	ldi	r31, 0x5A	; 90
     cb2:	6f 2e       	mov	r6, r31
     cb4:	f8 e3       	ldi	r31, 0x38	; 56
     cb6:	7f 2e       	mov	r7, r31
     cb8:	f0 2d       	mov	r31, r0
     cba:	0f 2e       	mov	r0, r31
     cbc:	f8 e6       	ldi	r31, 0x68	; 104
     cbe:	8f 2e       	mov	r8, r31
     cc0:	f8 e3       	ldi	r31, 0x38	; 56
     cc2:	9f 2e       	mov	r9, r31
     cc4:	f0 2d       	mov	r31, r0
     cc6:	6d 01       	movw	r12, r26
void tinyLED_update(void)
{
			
	uint32_t now = tinyTime_now();
	uint8_t red = 0;
	uint8_t green = 0;
     cc8:	1c 8a       	std	Y+20, r1	; 0x14
*/
void tinyLED_update(void)
{
			
	uint32_t now = tinyTime_now();
	uint8_t red = 0;
     cca:	1d 8a       	std	Y+21, r1	; 0x15
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*sinValue, rgb_colors[i].green*sinValue, rgb_colors[i].blue*sinValue};
				break;
				
			case PING:
				// in the line below, fmin will either return 1 or 0, so each rgb color is either 0 or 255*PING_BRIGHTNESS
				rgb_colors[i] = (struct RGB_Color){255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].red)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].green)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].blue)*ping_on};
     ccc:	21 2f       	mov	r18, r17
     cce:	30 e0       	ldi	r19, 0x00	; 0
     cd0:	40 e0       	ldi	r20, 0x00	; 0
     cd2:	50 e0       	ldi	r21, 0x00	; 0
     cd4:	2e 8b       	std	Y+22, r18	; 0x16
     cd6:	3f 8b       	std	Y+23, r19	; 0x17
     cd8:	48 8f       	std	Y+24, r20	; 0x18
     cda:	59 8f       	std	Y+25, r21	; 0x19
			
			case POTENTIAL:
				// In this mode, we try to communicate the level of the potential with color and brightness
				
				if(tinyPotential_potental > 0 || tinyAxon_pulses_in_queue > 0){
					green = fmin(255*LED_BRIGHTNESS * (tinyPotential_potental+tinyAxon_pulses_in_queue*THRESHOLD_POTENTIAL)/FULL_BRIGHTNESS_POTENTIAL, 255);
     cdc:	9c 01       	movw	r18, r24
     cde:	40 e0       	ldi	r20, 0x00	; 0
     ce0:	50 e0       	ldi	r21, 0x00	; 0
     ce2:	2a 8f       	std	Y+26, r18	; 0x1a
     ce4:	3b 8f       	std	Y+27, r19	; 0x1b
     ce6:	4c 8f       	std	Y+28, r20	; 0x1c
     ce8:	5d 8f       	std	Y+29, r21	; 0x1d
     cea:	f1 01       	movw	r30, r2
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 0 << TCA_SPLIT_ENABLE_bp; //Stop TCA
}

static struct RGB_Color tinyLED_enum_to_RGB_Color(enum Colors color){
	struct RGB_Color rgb_color;
	switch(color)
     cec:	80 81       	ld	r24, Z
     cee:	84 30       	cpi	r24, 0x04	; 4
     cf0:	79 f0       	breq	.+30     	; 0xd10 <tinyLED_update+0x152>
     cf2:	28 f4       	brcc	.+10     	; 0xcfe <tinyLED_update+0x140>
     cf4:	82 30       	cpi	r24, 0x02	; 2
     cf6:	41 f0       	breq	.+16     	; 0xd08 <tinyLED_update+0x14a>
     cf8:	83 30       	cpi	r24, 0x03	; 3
     cfa:	71 f0       	breq	.+28     	; 0xd18 <tinyLED_update+0x15a>
     cfc:	19 c0       	rjmp	.+50     	; 0xd30 <tinyLED_update+0x172>
     cfe:	85 30       	cpi	r24, 0x05	; 5
     d00:	79 f0       	breq	.+30     	; 0xd20 <tinyLED_update+0x162>
     d02:	86 30       	cpi	r24, 0x06	; 6
     d04:	89 f0       	breq	.+34     	; 0xd28 <tinyLED_update+0x16a>
     d06:	14 c0       	rjmp	.+40     	; 0xd30 <tinyLED_update+0x172>
	{
		case LED_OFF:
			rgb_color = (struct RGB_Color){0, 0, 0};
			break;
		case RED:
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 0, 0};
     d08:	10 e0       	ldi	r17, 0x00	; 0
     d0a:	00 e0       	ldi	r16, 0x00	; 0
     d0c:	69 e1       	ldi	r22, 0x19	; 25
     d0e:	13 c0       	rjmp	.+38     	; 0xd36 <tinyLED_update+0x178>
			break;
		case GREEN:
			rgb_color = (struct RGB_Color){0, 255*LED_BRIGHTNESS, 0};
     d10:	10 e0       	ldi	r17, 0x00	; 0
     d12:	09 e1       	ldi	r16, 0x19	; 25
     d14:	60 e0       	ldi	r22, 0x00	; 0
     d16:	0f c0       	rjmp	.+30     	; 0xd36 <tinyLED_update+0x178>
			break;
		case BLUE:
			rgb_color = (struct RGB_Color){0, 0, 255*LED_BRIGHTNESS};
     d18:	19 e1       	ldi	r17, 0x19	; 25
     d1a:	00 e0       	ldi	r16, 0x00	; 0
     d1c:	60 e0       	ldi	r22, 0x00	; 0
     d1e:	0b c0       	rjmp	.+22     	; 0xd36 <tinyLED_update+0x178>
			break;
		case YELLOW:
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS, 0};
     d20:	10 e0       	ldi	r17, 0x00	; 0
     d22:	09 e1       	ldi	r16, 0x19	; 25
     d24:	69 e1       	ldi	r22, 0x19	; 25
     d26:	07 c0       	rjmp	.+14     	; 0xd36 <tinyLED_update+0x178>
			// Should the /3 be there? This requires testing.
			// After testing, findings were that at 0.1 brightness, one would see the three LEDs instead of one white led
			// We try with /2 instead.
			// We find that the best results come from not dividing by anything. At leasts in the lower brightness settings, and that
			// is where we suspect it will be most of the time. When we divide, the LEDs are so weak, that they appear as three lights instead of one.
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS};
     d28:	19 e1       	ldi	r17, 0x19	; 25
     d2a:	09 e1       	ldi	r16, 0x19	; 25
     d2c:	69 e1       	ldi	r22, 0x19	; 25
     d2e:	03 c0       	rjmp	.+6      	; 0xd36 <tinyLED_update+0x178>
static struct RGB_Color tinyLED_enum_to_RGB_Color(enum Colors color){
	struct RGB_Color rgb_color;
	switch(color)
	{
		case LED_OFF:
			rgb_color = (struct RGB_Color){0, 0, 0};
     d30:	10 e0       	ldi	r17, 0x00	; 0
     d32:	00 e0       	ldi	r16, 0x00	; 0
     d34:	60 e0       	ldi	r22, 0x00	; 0
     d36:	76 01       	movw	r14, r12
	
	
	for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
	{		
		// Convert enum to RGB_Color
		rgb_colors[i] = tinyLED_enum_to_RGB_Color(tinyLED_settings[i].color);
     d38:	d6 01       	movw	r26, r12
     d3a:	6c 93       	st	X, r22
     d3c:	11 96       	adiw	r26, 0x01	; 1
     d3e:	0c 93       	st	X, r16
     d40:	11 97       	sbiw	r26, 0x01	; 1
     d42:	12 96       	adiw	r26, 0x02	; 2
     d44:	1c 93       	st	X, r17
		
		// Adjust colors according to mode
		switch(tinyLED_settings[i].mode)
     d46:	81 81       	ldd	r24, Z+1	; 0x01
     d48:	83 30       	cpi	r24, 0x03	; 3
     d4a:	09 f4       	brne	.+2      	; 0xd4e <tinyLED_update+0x190>
     d4c:	52 c0       	rjmp	.+164    	; 0xdf2 <tinyLED_update+0x234>
     d4e:	28 f4       	brcc	.+10     	; 0xd5a <tinyLED_update+0x19c>
     d50:	81 30       	cpi	r24, 0x01	; 1
     d52:	61 f0       	breq	.+24     	; 0xd6c <tinyLED_update+0x1ae>
     d54:	82 30       	cpi	r24, 0x02	; 2
     d56:	d9 f1       	breq	.+118    	; 0xdce <tinyLED_update+0x210>
     d58:	83 c1       	rjmp	.+774    	; 0x1060 <tinyLED_update+0x4a2>
     d5a:	85 30       	cpi	r24, 0x05	; 5
     d5c:	09 f4       	brne	.+2      	; 0xd60 <tinyLED_update+0x1a2>
     d5e:	f7 c0       	rjmp	.+494    	; 0xf4e <tinyLED_update+0x390>
     d60:	08 f4       	brcc	.+2      	; 0xd64 <tinyLED_update+0x1a6>
     d62:	78 c0       	rjmp	.+240    	; 0xe54 <tinyLED_update+0x296>
     d64:	86 30       	cpi	r24, 0x06	; 6
     d66:	09 f4       	brne	.+2      	; 0xd6a <tinyLED_update+0x1ac>
     d68:	19 c1       	rjmp	.+562    	; 0xf9c <tinyLED_update+0x3de>
     d6a:	7a c1       	rjmp	.+756    	; 0x1060 <tinyLED_update+0x4a2>
		{
			case STABLE:
				break;
				
			case WEAK:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*WEAK_BRIGHTNESS, rgb_colors[i].green*WEAK_BRIGHTNESS, rgb_colors[i].blue*WEAK_BRIGHTNESS};
     d6c:	70 e0       	ldi	r23, 0x00	; 0
     d6e:	80 e0       	ldi	r24, 0x00	; 0
     d70:	90 e0       	ldi	r25, 0x00	; 0
     d72:	0e 94 e8 0a 	call	0x15d0	; 0x15d0 <__floatsisf>
     d76:	2d ec       	ldi	r18, 0xCD	; 205
     d78:	3c ec       	ldi	r19, 0xCC	; 204
     d7a:	4c ec       	ldi	r20, 0xCC	; 204
     d7c:	5d e3       	ldi	r21, 0x3D	; 61
     d7e:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <__mulsf3>
     d82:	0e 94 b7 0a 	call	0x156e	; 0x156e <__fixunssfsi>
     d86:	f6 01       	movw	r30, r12
     d88:	60 83       	st	Z, r22
     d8a:	60 2f       	mov	r22, r16
     d8c:	70 e0       	ldi	r23, 0x00	; 0
     d8e:	80 e0       	ldi	r24, 0x00	; 0
     d90:	90 e0       	ldi	r25, 0x00	; 0
     d92:	0e 94 e8 0a 	call	0x15d0	; 0x15d0 <__floatsisf>
     d96:	2d ec       	ldi	r18, 0xCD	; 205
     d98:	3c ec       	ldi	r19, 0xCC	; 204
     d9a:	4c ec       	ldi	r20, 0xCC	; 204
     d9c:	5d e3       	ldi	r21, 0x3D	; 61
     d9e:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <__mulsf3>
     da2:	0e 94 b7 0a 	call	0x156e	; 0x156e <__fixunssfsi>
     da6:	d6 01       	movw	r26, r12
     da8:	11 96       	adiw	r26, 0x01	; 1
     daa:	6c 93       	st	X, r22
     dac:	61 2f       	mov	r22, r17
     dae:	70 e0       	ldi	r23, 0x00	; 0
     db0:	80 e0       	ldi	r24, 0x00	; 0
     db2:	90 e0       	ldi	r25, 0x00	; 0
     db4:	0e 94 e8 0a 	call	0x15d0	; 0x15d0 <__floatsisf>
     db8:	2d ec       	ldi	r18, 0xCD	; 205
     dba:	3c ec       	ldi	r19, 0xCC	; 204
     dbc:	4c ec       	ldi	r20, 0xCC	; 204
     dbe:	5d e3       	ldi	r21, 0x3D	; 61
     dc0:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <__mulsf3>
     dc4:	0e 94 b7 0a 	call	0x156e	; 0x156e <__fixunssfsi>
     dc8:	f6 01       	movw	r30, r12
     dca:	62 83       	std	Z+2, r22	; 0x02
				break;
     dcc:	49 c1       	rjmp	.+658    	; 0x1060 <tinyLED_update+0x4a2>
				
			case FLASH:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*flash_on, rgb_colors[i].green*flash_on, rgb_colors[i].blue*flash_on};
     dce:	ff 81       	ldd	r31, Y+7	; 0x07
     dd0:	f6 9f       	mul	r31, r22
     dd2:	60 2d       	mov	r22, r0
     dd4:	11 24       	eor	r1, r1
     dd6:	d6 01       	movw	r26, r12
     dd8:	6c 93       	st	X, r22
     dda:	f0 9f       	mul	r31, r16
     ddc:	00 2d       	mov	r16, r0
     dde:	11 24       	eor	r1, r1
     de0:	11 96       	adiw	r26, 0x01	; 1
     de2:	0c 93       	st	X, r16
     de4:	11 97       	sbiw	r26, 0x01	; 1
     de6:	f1 9f       	mul	r31, r17
     de8:	10 2d       	mov	r17, r0
     dea:	11 24       	eor	r1, r1
     dec:	12 96       	adiw	r26, 0x02	; 2
     dee:	1c 93       	st	X, r17
				break;
     df0:	37 c1       	rjmp	.+622    	; 0x1060 <tinyLED_update+0x4a2>
				
			case SWING:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*sinValue, rgb_colors[i].green*sinValue, rgb_colors[i].blue*sinValue};
     df2:	70 e0       	ldi	r23, 0x00	; 0
     df4:	80 e0       	ldi	r24, 0x00	; 0
     df6:	90 e0       	ldi	r25, 0x00	; 0
     df8:	0e 94 e8 0a 	call	0x15d0	; 0x15d0 <__floatsisf>
     dfc:	28 85       	ldd	r18, Y+8	; 0x08
     dfe:	39 85       	ldd	r19, Y+9	; 0x09
     e00:	4a 85       	ldd	r20, Y+10	; 0x0a
     e02:	5b 85       	ldd	r21, Y+11	; 0x0b
     e04:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <__mulsf3>
     e08:	0e 94 b7 0a 	call	0x156e	; 0x156e <__fixunssfsi>
     e0c:	f6 01       	movw	r30, r12
     e0e:	60 83       	st	Z, r22
     e10:	60 2f       	mov	r22, r16
     e12:	70 e0       	ldi	r23, 0x00	; 0
     e14:	80 e0       	ldi	r24, 0x00	; 0
     e16:	90 e0       	ldi	r25, 0x00	; 0
     e18:	0e 94 e8 0a 	call	0x15d0	; 0x15d0 <__floatsisf>
     e1c:	28 85       	ldd	r18, Y+8	; 0x08
     e1e:	39 85       	ldd	r19, Y+9	; 0x09
     e20:	4a 85       	ldd	r20, Y+10	; 0x0a
     e22:	5b 85       	ldd	r21, Y+11	; 0x0b
     e24:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <__mulsf3>
     e28:	0e 94 b7 0a 	call	0x156e	; 0x156e <__fixunssfsi>
     e2c:	d6 01       	movw	r26, r12
     e2e:	11 96       	adiw	r26, 0x01	; 1
     e30:	6c 93       	st	X, r22
     e32:	61 2f       	mov	r22, r17
     e34:	70 e0       	ldi	r23, 0x00	; 0
     e36:	80 e0       	ldi	r24, 0x00	; 0
     e38:	90 e0       	ldi	r25, 0x00	; 0
     e3a:	0e 94 e8 0a 	call	0x15d0	; 0x15d0 <__floatsisf>
     e3e:	28 85       	ldd	r18, Y+8	; 0x08
     e40:	39 85       	ldd	r19, Y+9	; 0x09
     e42:	4a 85       	ldd	r20, Y+10	; 0x0a
     e44:	5b 85       	ldd	r21, Y+11	; 0x0b
     e46:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <__mulsf3>
     e4a:	0e 94 b7 0a 	call	0x156e	; 0x156e <__fixunssfsi>
     e4e:	f6 01       	movw	r30, r12
     e50:	62 83       	std	Z+2, r22	; 0x02
				break;
     e52:	06 c1       	rjmp	.+524    	; 0x1060 <tinyLED_update+0x4a2>
				
			case PING:
				// in the line below, fmin will either return 1 or 0, so each rgb color is either 0 or 255*PING_BRIGHTNESS
				rgb_colors[i] = (struct RGB_Color){255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].red)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].green)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].blue)*ping_on};
     e54:	70 e0       	ldi	r23, 0x00	; 0
     e56:	80 e0       	ldi	r24, 0x00	; 0
     e58:	90 e0       	ldi	r25, 0x00	; 0
     e5a:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <__floatunsisf>
     e5e:	9b 01       	movw	r18, r22
     e60:	ac 01       	movw	r20, r24
     e62:	60 e0       	ldi	r22, 0x00	; 0
     e64:	70 e0       	ldi	r23, 0x00	; 0
     e66:	80 e8       	ldi	r24, 0x80	; 128
     e68:	9f e3       	ldi	r25, 0x3F	; 63
     e6a:	0e 94 23 0b 	call	0x1646	; 0x1646 <fmin>
     e6e:	68 a3       	std	Y+32, r22	; 0x20
     e70:	79 a3       	std	Y+33, r23	; 0x21
     e72:	8a a3       	std	Y+34, r24	; 0x22
     e74:	9b a3       	std	Y+35, r25	; 0x23
     e76:	6e 89       	ldd	r22, Y+22	; 0x16
     e78:	7f 89       	ldd	r23, Y+23	; 0x17
     e7a:	88 8d       	ldd	r24, Y+24	; 0x18
     e7c:	99 8d       	ldd	r25, Y+25	; 0x19
     e7e:	0e 94 e8 0a 	call	0x15d0	; 0x15d0 <__floatsisf>
     e82:	68 8b       	std	Y+16, r22	; 0x10
     e84:	79 8b       	std	Y+17, r23	; 0x11
     e86:	8a 8b       	std	Y+18, r24	; 0x12
     e88:	9b 8b       	std	Y+19, r25	; 0x13
     e8a:	60 2f       	mov	r22, r16
     e8c:	70 e0       	ldi	r23, 0x00	; 0
     e8e:	80 e0       	ldi	r24, 0x00	; 0
     e90:	90 e0       	ldi	r25, 0x00	; 0
     e92:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <__floatunsisf>
     e96:	9b 01       	movw	r18, r22
     e98:	ac 01       	movw	r20, r24
     e9a:	60 e0       	ldi	r22, 0x00	; 0
     e9c:	70 e0       	ldi	r23, 0x00	; 0
     e9e:	80 e8       	ldi	r24, 0x80	; 128
     ea0:	9f e3       	ldi	r25, 0x3F	; 63
     ea2:	0e 94 23 0b 	call	0x1646	; 0x1646 <fmin>
     ea6:	6c a3       	std	Y+36, r22	; 0x24
     ea8:	7d a3       	std	Y+37, r23	; 0x25
     eaa:	8e a3       	std	Y+38, r24	; 0x26
     eac:	9f a3       	std	Y+39, r25	; 0x27
     eae:	61 2f       	mov	r22, r17
     eb0:	70 e0       	ldi	r23, 0x00	; 0
     eb2:	80 e0       	ldi	r24, 0x00	; 0
     eb4:	90 e0       	ldi	r25, 0x00	; 0
     eb6:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <__floatunsisf>
     eba:	9b 01       	movw	r18, r22
     ebc:	ac 01       	movw	r20, r24
     ebe:	60 e0       	ldi	r22, 0x00	; 0
     ec0:	70 e0       	ldi	r23, 0x00	; 0
     ec2:	80 e8       	ldi	r24, 0x80	; 128
     ec4:	9f e3       	ldi	r25, 0x3F	; 63
     ec6:	0e 94 23 0b 	call	0x1646	; 0x1646 <fmin>
     eca:	68 a7       	std	Y+40, r22	; 0x28
     ecc:	79 a7       	std	Y+41, r23	; 0x29
     ece:	8a a7       	std	Y+42, r24	; 0x2a
     ed0:	9b a7       	std	Y+43, r25	; 0x2b
     ed2:	23 e3       	ldi	r18, 0x33	; 51
     ed4:	33 e3       	ldi	r19, 0x33	; 51
     ed6:	43 ea       	ldi	r20, 0xA3	; 163
     ed8:	50 e4       	ldi	r21, 0x40	; 64
     eda:	68 a1       	ldd	r22, Y+32	; 0x20
     edc:	79 a1       	ldd	r23, Y+33	; 0x21
     ede:	8a a1       	ldd	r24, Y+34	; 0x22
     ee0:	9b a1       	ldd	r25, Y+35	; 0x23
     ee2:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <__mulsf3>
     ee6:	28 89       	ldd	r18, Y+16	; 0x10
     ee8:	39 89       	ldd	r19, Y+17	; 0x11
     eea:	4a 89       	ldd	r20, Y+18	; 0x12
     eec:	5b 89       	ldd	r21, Y+19	; 0x13
     eee:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <__mulsf3>
     ef2:	0e 94 b7 0a 	call	0x156e	; 0x156e <__fixunssfsi>
     ef6:	d6 01       	movw	r26, r12
     ef8:	6c 93       	st	X, r22
     efa:	23 e3       	ldi	r18, 0x33	; 51
     efc:	33 e3       	ldi	r19, 0x33	; 51
     efe:	43 ea       	ldi	r20, 0xA3	; 163
     f00:	50 e4       	ldi	r21, 0x40	; 64
     f02:	6c a1       	ldd	r22, Y+36	; 0x24
     f04:	7d a1       	ldd	r23, Y+37	; 0x25
     f06:	8e a1       	ldd	r24, Y+38	; 0x26
     f08:	9f a1       	ldd	r25, Y+39	; 0x27
     f0a:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <__mulsf3>
     f0e:	28 89       	ldd	r18, Y+16	; 0x10
     f10:	39 89       	ldd	r19, Y+17	; 0x11
     f12:	4a 89       	ldd	r20, Y+18	; 0x12
     f14:	5b 89       	ldd	r21, Y+19	; 0x13
     f16:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <__mulsf3>
     f1a:	0e 94 b7 0a 	call	0x156e	; 0x156e <__fixunssfsi>
     f1e:	f6 01       	movw	r30, r12
     f20:	61 83       	std	Z+1, r22	; 0x01
     f22:	23 e3       	ldi	r18, 0x33	; 51
     f24:	33 e3       	ldi	r19, 0x33	; 51
     f26:	43 ea       	ldi	r20, 0xA3	; 163
     f28:	50 e4       	ldi	r21, 0x40	; 64
     f2a:	68 a5       	ldd	r22, Y+40	; 0x28
     f2c:	79 a5       	ldd	r23, Y+41	; 0x29
     f2e:	8a a5       	ldd	r24, Y+42	; 0x2a
     f30:	9b a5       	ldd	r25, Y+43	; 0x2b
     f32:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <__mulsf3>
     f36:	28 89       	ldd	r18, Y+16	; 0x10
     f38:	39 89       	ldd	r19, Y+17	; 0x11
     f3a:	4a 89       	ldd	r20, Y+18	; 0x12
     f3c:	5b 89       	ldd	r21, Y+19	; 0x13
     f3e:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <__mulsf3>
     f42:	0e 94 b7 0a 	call	0x156e	; 0x156e <__fixunssfsi>
     f46:	d6 01       	movw	r26, r12
     f48:	12 96       	adiw	r26, 0x02	; 2
     f4a:	6c 93       	st	X, r22
				break;
     f4c:	89 c0       	rjmp	.+274    	; 0x1060 <tinyLED_update+0x4a2>
     f4e:	68 8a       	std	Y+16, r6	; 0x10
     f50:	79 8a       	std	Y+17, r7	; 0x11
				
			case FLASH_ONCE:
				if(tinyLED_flash_once_time[i]>0){
     f52:	d3 01       	movw	r26, r6
     f54:	0d 91       	ld	r16, X+
     f56:	1c 91       	ld	r17, X
     f58:	01 15       	cp	r16, r1
     f5a:	11 05       	cpc	r17, r1
     f5c:	c1 f0       	breq	.+48     	; 0xf8e <tinyLED_update+0x3d0>
					
					// Check if flash is inside off period
					if(tinyLED_flash_once_time[i]>1000*(FLASH_TIME - FLASH_OFF_TIME)){
     f5e:	b8 01       	movw	r22, r16
     f60:	80 e0       	ldi	r24, 0x00	; 0
     f62:	90 e0       	ldi	r25, 0x00	; 0
     f64:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <__floatunsisf>
     f68:	20 e0       	ldi	r18, 0x00	; 0
     f6a:	30 e0       	ldi	r19, 0x00	; 0
     f6c:	4e e3       	ldi	r20, 0x3E	; 62
     f6e:	53 e4       	ldi	r21, 0x43	; 67
     f70:	0e 94 de 0b 	call	0x17bc	; 0x17bc <__gesf2>
     f74:	18 16       	cp	r1, r24
     f76:	24 f4       	brge	.+8      	; 0xf80 <tinyLED_update+0x3c2>
						// This is used to seperate flashes
						rgb_colors[i] = (struct RGB_Color){0, 0, 0};
     f78:	f6 01       	movw	r30, r12
     f7a:	10 82       	st	Z, r1
     f7c:	11 82       	std	Z+1, r1	; 0x01
     f7e:	12 82       	std	Z+2, r1	; 0x02
					} else {
						rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red, rgb_colors[i].green, rgb_colors[i].blue};
					}
					
					tinyLED_flash_once_time[i]--;
     f80:	01 50       	subi	r16, 0x01	; 1
     f82:	11 09       	sbc	r17, r1
     f84:	a8 89       	ldd	r26, Y+16	; 0x10
     f86:	b9 89       	ldd	r27, Y+17	; 0x11
     f88:	0d 93       	st	X+, r16
     f8a:	1c 93       	st	X, r17
     f8c:	69 c0       	rjmp	.+210    	; 0x1060 <tinyLED_update+0x4a2>
				}
				else{
					// Here we return to the previous color and mode
					tinyLED_settings[i].color = tinyLED_old_settings[i].color;
     f8e:	d2 01       	movw	r26, r4
     f90:	8c 91       	ld	r24, X
     f92:	80 83       	st	Z, r24
					tinyLED_settings[i].mode = tinyLED_old_settings[i].mode;
     f94:	11 96       	adiw	r26, 0x01	; 1
     f96:	8c 91       	ld	r24, X
     f98:	81 83       	std	Z+1, r24	; 0x01
     f9a:	62 c0       	rjmp	.+196    	; 0x1060 <tinyLED_update+0x4a2>
				break;
			
			case POTENTIAL:
				// In this mode, we try to communicate the level of the potential with color and brightness
				
				if(tinyPotential_potental > 0 || tinyAxon_pulses_in_queue > 0){
     f9c:	20 e0       	ldi	r18, 0x00	; 0
     f9e:	30 e0       	ldi	r19, 0x00	; 0
     fa0:	a9 01       	movw	r20, r18
     fa2:	6c 85       	ldd	r22, Y+12	; 0x0c
     fa4:	7d 85       	ldd	r23, Y+13	; 0x0d
     fa6:	8e 85       	ldd	r24, Y+14	; 0x0e
     fa8:	9f 85       	ldd	r25, Y+15	; 0x0f
     faa:	0e 94 de 0b 	call	0x17bc	; 0x17bc <__gesf2>
     fae:	18 16       	cp	r1, r24
     fb0:	24 f0       	brlt	.+8      	; 0xfba <tinyLED_update+0x3fc>
     fb2:	ee 8d       	ldd	r30, Y+30	; 0x1e
     fb4:	ff 8d       	ldd	r31, Y+31	; 0x1f
     fb6:	ef 2b       	or	r30, r31
     fb8:	11 f1       	breq	.+68     	; 0xffe <tinyLED_update+0x440>
					green = fmin(255*LED_BRIGHTNESS * (tinyPotential_potental+tinyAxon_pulses_in_queue*THRESHOLD_POTENTIAL)/FULL_BRIGHTNESS_POTENTIAL, 255);
     fba:	6a 8d       	ldd	r22, Y+26	; 0x1a
     fbc:	7b 8d       	ldd	r23, Y+27	; 0x1b
     fbe:	8c 8d       	ldd	r24, Y+28	; 0x1c
     fc0:	9d 8d       	ldd	r25, Y+29	; 0x1d
     fc2:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <__floatunsisf>
     fc6:	2c 85       	ldd	r18, Y+12	; 0x0c
     fc8:	3d 85       	ldd	r19, Y+13	; 0x0d
     fca:	4e 85       	ldd	r20, Y+14	; 0x0e
     fcc:	5f 85       	ldd	r21, Y+15	; 0x0f
     fce:	0e 94 93 09 	call	0x1326	; 0x1326 <__addsf3>
     fd2:	20 e0       	ldi	r18, 0x00	; 0
     fd4:	30 e0       	ldi	r19, 0x00	; 0
     fd6:	4c ec       	ldi	r20, 0xCC	; 204
     fd8:	51 e4       	ldi	r21, 0x41	; 65
     fda:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <__mulsf3>
     fde:	20 e0       	ldi	r18, 0x00	; 0
     fe0:	30 e0       	ldi	r19, 0x00	; 0
     fe2:	48 ec       	ldi	r20, 0xC8	; 200
     fe4:	51 e4       	ldi	r21, 0x41	; 65
     fe6:	0e 94 04 0a 	call	0x1408	; 0x1408 <__divsf3>
     fea:	20 e0       	ldi	r18, 0x00	; 0
     fec:	30 e0       	ldi	r19, 0x00	; 0
     fee:	4f e7       	ldi	r20, 0x7F	; 127
     ff0:	53 e4       	ldi	r21, 0x43	; 67
     ff2:	0e 94 23 0b 	call	0x1646	; 0x1646 <fmin>
     ff6:	0e 94 b7 0a 	call	0x156e	; 0x156e <__fixunssfsi>
     ffa:	6c 8b       	std	Y+20, r22	; 0x14
     ffc:	28 c0       	rjmp	.+80     	; 0x104e <tinyLED_update+0x490>
				}
				else{
					red = fmin(255*LED_BRIGHTNESS * abs(tinyPotential_potental)/FULL_BRIGHTNESS_POTENTIAL, 255);
     ffe:	6c 85       	ldd	r22, Y+12	; 0x0c
    1000:	7d 85       	ldd	r23, Y+13	; 0x0d
    1002:	8e 85       	ldd	r24, Y+14	; 0x0e
    1004:	9f 85       	ldd	r25, Y+15	; 0x0f
    1006:	0e 94 b0 0a 	call	0x1560	; 0x1560 <__fixsfsi>
    100a:	9b 01       	movw	r18, r22
    100c:	77 23       	and	r23, r23
    100e:	24 f4       	brge	.+8      	; 0x1018 <tinyLED_update+0x45a>
    1010:	22 27       	eor	r18, r18
    1012:	33 27       	eor	r19, r19
    1014:	26 1b       	sub	r18, r22
    1016:	37 0b       	sbc	r19, r23
    1018:	b9 01       	movw	r22, r18
    101a:	33 0f       	add	r19, r19
    101c:	88 0b       	sbc	r24, r24
    101e:	99 0b       	sbc	r25, r25
    1020:	0e 94 e8 0a 	call	0x15d0	; 0x15d0 <__floatsisf>
    1024:	20 e0       	ldi	r18, 0x00	; 0
    1026:	30 e0       	ldi	r19, 0x00	; 0
    1028:	4c ec       	ldi	r20, 0xCC	; 204
    102a:	51 e4       	ldi	r21, 0x41	; 65
    102c:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <__mulsf3>
    1030:	20 e0       	ldi	r18, 0x00	; 0
    1032:	30 e0       	ldi	r19, 0x00	; 0
    1034:	48 ec       	ldi	r20, 0xC8	; 200
    1036:	51 e4       	ldi	r21, 0x41	; 65
    1038:	0e 94 04 0a 	call	0x1408	; 0x1408 <__divsf3>
    103c:	20 e0       	ldi	r18, 0x00	; 0
    103e:	30 e0       	ldi	r19, 0x00	; 0
    1040:	4f e7       	ldi	r20, 0x7F	; 127
    1042:	53 e4       	ldi	r21, 0x43	; 67
    1044:	0e 94 23 0b 	call	0x1646	; 0x1646 <fmin>
    1048:	0e 94 b7 0a 	call	0x156e	; 0x156e <__fixunssfsi>
    104c:	6d 8b       	std	Y+21, r22	; 0x15
				}
				
				rgb_colors[i] = (struct RGB_Color){red, green, 0};
    104e:	ed 89       	ldd	r30, Y+21	; 0x15
    1050:	d7 01       	movw	r26, r14
    1052:	ec 93       	st	X, r30
    1054:	fc 89       	ldd	r31, Y+20	; 0x14
    1056:	11 96       	adiw	r26, 0x01	; 1
    1058:	fc 93       	st	X, r31
    105a:	11 97       	sbiw	r26, 0x01	; 1
    105c:	12 96       	adiw	r26, 0x02	; 2
    105e:	1c 92       	st	X, r1
    1060:	22 e0       	ldi	r18, 0x02	; 2
    1062:	22 0e       	add	r2, r18
    1064:	31 1c       	adc	r3, r1
    1066:	33 e0       	ldi	r19, 0x03	; 3
    1068:	c3 0e       	add	r12, r19
    106a:	d1 1c       	adc	r13, r1
    106c:	42 e0       	ldi	r20, 0x02	; 2
    106e:	44 0e       	add	r4, r20
    1070:	51 1c       	adc	r5, r1
    1072:	52 e0       	ldi	r21, 0x02	; 2
    1074:	65 0e       	add	r6, r21
    1076:	71 1c       	adc	r7, r1
	
	// This is where we store all the actual color values we want to send to the LED
	struct RGB_Color rgb_colors[NUMBER_OF_LEDS];
	
	
	for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
    1078:	28 14       	cp	r2, r8
    107a:	39 04       	cpc	r3, r9
    107c:	09 f0       	breq	.+2      	; 0x1080 <tinyLED_update+0x4c2>
    107e:	35 ce       	rjmp	.-918    	; 0xcea <tinyLED_update+0x12c>
				break;
		}
	}
	
	// We only write to the LEDs if there is something to change. (eg. in SWING mode, we update the LEDs almost every cycle)
	if(!tinyLED_RGB_Color_Compare(&rgb_colors, &tinyLED_old_colors)){
    1080:	6e e5       	ldi	r22, 0x5E	; 94
    1082:	78 e3       	ldi	r23, 0x38	; 56
    1084:	ce 01       	movw	r24, r28
    1086:	01 96       	adiw	r24, 0x01	; 1
    1088:	0e 94 af 05 	call	0xb5e	; 0xb5e <tinyLED_RGB_Color_Compare>
    108c:	81 11       	cpse	r24, r1
    108e:	21 c0       	rjmp	.+66     	; 0x10d2 <tinyLED_update+0x514>
    1090:	0e e5       	ldi	r16, 0x5E	; 94
    1092:	18 e3       	ldi	r17, 0x38	; 56
    1094:	7e 01       	movw	r14, r28
    1096:	87 e0       	ldi	r24, 0x07	; 7
    1098:	e8 0e       	add	r14, r24
    109a:	f1 1c       	adc	r15, r1
		for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
		{
			// Write to LEDs
			//For some reason, the data-bus to the LEDs is serialized as GRB
			//which means the 24-bit data-bus will look like [Green[0:7], Red[0:7], Blue[0:7]]
			tinyLED_SPIWriteByte(rgb_colors[i].green);
    109c:	d5 01       	movw	r26, r10
    109e:	11 96       	adiw	r26, 0x01	; 1
    10a0:	8c 91       	ld	r24, X
    10a2:	0e 94 67 05 	call	0xace	; 0xace <tinyLED_SPIWriteByte>
			tinyLED_SPIWriteByte(rgb_colors[i].red);
    10a6:	f5 01       	movw	r30, r10
    10a8:	80 81       	ld	r24, Z
    10aa:	0e 94 67 05 	call	0xace	; 0xace <tinyLED_SPIWriteByte>
			tinyLED_SPIWriteByte(rgb_colors[i].blue);
    10ae:	d5 01       	movw	r26, r10
    10b0:	12 96       	adiw	r26, 0x02	; 2
    10b2:	8c 91       	ld	r24, X
    10b4:	0e 94 67 05 	call	0xace	; 0xace <tinyLED_SPIWriteByte>
			tinyLED_old_colors[i] = rgb_colors[i];
    10b8:	f5 01       	movw	r30, r10
    10ba:	81 91       	ld	r24, Z+
    10bc:	91 91       	ld	r25, Z+
    10be:	a1 91       	ld	r26, Z+
    10c0:	5f 01       	movw	r10, r30
    10c2:	f8 01       	movw	r30, r16
    10c4:	81 93       	st	Z+, r24
    10c6:	91 93       	st	Z+, r25
    10c8:	a1 93       	st	Z+, r26
    10ca:	8f 01       	movw	r16, r30
		}
	}
	
	// We only write to the LEDs if there is something to change. (eg. in SWING mode, we update the LEDs almost every cycle)
	if(!tinyLED_RGB_Color_Compare(&rgb_colors, &tinyLED_old_colors)){
		for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
    10cc:	ae 14       	cp	r10, r14
    10ce:	bf 04       	cpc	r11, r15
    10d0:	29 f7       	brne	.-54     	; 0x109c <tinyLED_update+0x4de>
			tinyLED_SPIWriteByte(rgb_colors[i].red);
			tinyLED_SPIWriteByte(rgb_colors[i].blue);
			tinyLED_old_colors[i] = rgb_colors[i];
		}
	}
}
    10d2:	ab 96       	adiw	r28, 0x2b	; 43
    10d4:	cd bf       	out	0x3d, r28	; 61
    10d6:	de bf       	out	0x3e, r29	; 62
    10d8:	df 91       	pop	r29
    10da:	cf 91       	pop	r28
    10dc:	1f 91       	pop	r17
    10de:	0f 91       	pop	r16
    10e0:	ff 90       	pop	r15
    10e2:	ef 90       	pop	r14
    10e4:	df 90       	pop	r13
    10e6:	cf 90       	pop	r12
    10e8:	bf 90       	pop	r11
    10ea:	af 90       	pop	r10
    10ec:	9f 90       	pop	r9
    10ee:	8f 90       	pop	r8
    10f0:	7f 90       	pop	r7
    10f2:	6f 90       	pop	r6
    10f4:	5f 90       	pop	r5
    10f6:	4f 90       	pop	r4
    10f8:	3f 90       	pop	r3
    10fa:	2f 90       	pop	r2
    10fc:	08 95       	ret

000010fe <tinyPotential_get_potential>:
/*
Sends the potential
*/
double tinyPotential_get_potential()
{
	return tinyPotential_potential;
    10fe:	60 91 4a 38 	lds	r22, 0x384A	; 0x80384a <tinyPotential_potential>
    1102:	70 91 4b 38 	lds	r23, 0x384B	; 0x80384b <tinyPotential_potential+0x1>
    1106:	80 91 4c 38 	lds	r24, 0x384C	; 0x80384c <tinyPotential_potential+0x2>
    110a:	90 91 4d 38 	lds	r25, 0x384D	; 0x80384d <tinyPotential_potential+0x3>
}
    110e:	08 95       	ret

00001110 <tinyPotential_update>:

/*
Update the potential
*/
void tinyPotential_update()
{
    1110:	cf 92       	push	r12
    1112:	df 92       	push	r13
    1114:	ef 92       	push	r14
    1116:	ff 92       	push	r15
Function to decay the potential towards 0
*/
static void tinyPotential_decay()
{
		
	uint8_t time_since_last_update = tinyTime_now() - previous_update_time;
    1118:	0e 94 89 09 	call	0x1312	; 0x1312 <tinyTime_now>
	tinyPotential_potential *= (exp(-((float)time_since_last_update/(float)TINYPOTENTIAL_TIME_CONST)));
    111c:	80 91 46 38 	lds	r24, 0x3846	; 0x803846 <previous_update_time>
    1120:	68 1b       	sub	r22, r24
    1122:	70 e0       	ldi	r23, 0x00	; 0
    1124:	80 e0       	ldi	r24, 0x00	; 0
    1126:	90 e0       	ldi	r25, 0x00	; 0
    1128:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <__floatunsisf>
    112c:	20 e0       	ldi	r18, 0x00	; 0
    112e:	30 e0       	ldi	r19, 0x00	; 0
    1130:	48 ec       	ldi	r20, 0xC8	; 200
    1132:	52 e4       	ldi	r21, 0x42	; 66
    1134:	0e 94 04 0a 	call	0x1408	; 0x1408 <__divsf3>
    1138:	90 58       	subi	r25, 0x80	; 128
    113a:	0e 94 7e 0a 	call	0x14fc	; 0x14fc <exp>
    113e:	20 91 4a 38 	lds	r18, 0x384A	; 0x80384a <tinyPotential_potential>
    1142:	30 91 4b 38 	lds	r19, 0x384B	; 0x80384b <tinyPotential_potential+0x1>
    1146:	40 91 4c 38 	lds	r20, 0x384C	; 0x80384c <tinyPotential_potential+0x2>
    114a:	50 91 4d 38 	lds	r21, 0x384D	; 0x80384d <tinyPotential_potential+0x3>
    114e:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <__mulsf3>
    1152:	6b 01       	movw	r12, r22
    1154:	7c 01       	movw	r14, r24
	if(fabs(tinyPotential_potential)<POLARIZATION_OFFSET){
    1156:	9f 77       	andi	r25, 0x7F	; 127
    1158:	2d ec       	ldi	r18, 0xCD	; 205
    115a:	3c ec       	ldi	r19, 0xCC	; 204
    115c:	4c ec       	ldi	r20, 0xCC	; 204
    115e:	5d e3       	ldi	r21, 0x3D	; 61
    1160:	0e 94 ff 09 	call	0x13fe	; 0x13fe <__cmpsf2>
    1164:	88 23       	and	r24, r24
    1166:	4c f0       	brlt	.+18     	; 0x117a <tinyPotential_update+0x6a>
*/
static void tinyPotential_decay()
{
		
	uint8_t time_since_last_update = tinyTime_now() - previous_update_time;
	tinyPotential_potential *= (exp(-((float)time_since_last_update/(float)TINYPOTENTIAL_TIME_CONST)));
    1168:	c0 92 4a 38 	sts	0x384A, r12	; 0x80384a <tinyPotential_potential>
    116c:	d0 92 4b 38 	sts	0x384B, r13	; 0x80384b <tinyPotential_potential+0x1>
    1170:	e0 92 4c 38 	sts	0x384C, r14	; 0x80384c <tinyPotential_potential+0x2>
    1174:	f0 92 4d 38 	sts	0x384D, r15	; 0x80384d <tinyPotential_potential+0x3>
    1178:	08 c0       	rjmp	.+16     	; 0x118a <tinyPotential_update+0x7a>
	if(fabs(tinyPotential_potential)<POLARIZATION_OFFSET){
		tinyPotential_potential=0;
    117a:	10 92 4a 38 	sts	0x384A, r1	; 0x80384a <tinyPotential_potential>
    117e:	10 92 4b 38 	sts	0x384B, r1	; 0x80384b <tinyPotential_potential+0x1>
    1182:	10 92 4c 38 	sts	0x384C, r1	; 0x80384c <tinyPotential_potential+0x2>
    1186:	10 92 4d 38 	sts	0x384D, r1	; 0x80384d <tinyPotential_potential+0x3>
	}
	previous_update_time = tinyTime_now();
    118a:	0e 94 89 09 	call	0x1312	; 0x1312 <tinyTime_now>
    118e:	60 93 46 38 	sts	0x3846, r22	; 0x803846 <previous_update_time>
    1192:	70 93 47 38 	sts	0x3847, r23	; 0x803847 <previous_update_time+0x1>
    1196:	80 93 48 38 	sts	0x3848, r24	; 0x803848 <previous_update_time+0x2>
    119a:	90 93 49 38 	sts	0x3849, r25	; 0x803849 <previous_update_time+0x3>
void tinyPotential_update()
{
	//Some of the potential in the neuron has decayed away
	tinyPotential_decay();
	// Update potential with values from Dendrites
	tinyPotential_potential = tinyDendrite_update_potential(tinyPotential_potential);
    119e:	60 91 4a 38 	lds	r22, 0x384A	; 0x80384a <tinyPotential_potential>
    11a2:	70 91 4b 38 	lds	r23, 0x384B	; 0x80384b <tinyPotential_potential+0x1>
    11a6:	80 91 4c 38 	lds	r24, 0x384C	; 0x80384c <tinyPotential_potential+0x2>
    11aa:	90 91 4d 38 	lds	r25, 0x384D	; 0x80384d <tinyPotential_potential+0x3>
    11ae:	0e 94 1f 05 	call	0xa3e	; 0xa3e <tinyDendrite_update_potential>
    11b2:	60 93 4a 38 	sts	0x384A, r22	; 0x80384a <tinyPotential_potential>
    11b6:	70 93 4b 38 	sts	0x384B, r23	; 0x80384b <tinyPotential_potential+0x1>
    11ba:	80 93 4c 38 	sts	0x384C, r24	; 0x80384c <tinyPotential_potential+0x2>
    11be:	90 93 4d 38 	sts	0x384D, r25	; 0x80384d <tinyPotential_potential+0x3>
	
	// Update potential from button press
	tinyPotential_potential = tinyButton_update_potential(tinyPotential_potential);
    11c2:	0e 94 b4 03 	call	0x768	; 0x768 <tinyButton_update_potential>
    11c6:	60 93 4a 38 	sts	0x384A, r22	; 0x80384a <tinyPotential_potential>
    11ca:	70 93 4b 38 	sts	0x384B, r23	; 0x80384b <tinyPotential_potential+0x1>
    11ce:	80 93 4c 38 	sts	0x384C, r24	; 0x80384c <tinyPotential_potential+0x2>
    11d2:	90 93 4d 38 	sts	0x384D, r25	; 0x80384d <tinyPotential_potential+0x3>
	
	// Update potential with values from spontaneous pulse.
	tinyPotential_potential = tinyPulse_update_potential(tinyPotential_potential);
    11d6:	0e 94 2b 09 	call	0x1256	; 0x1256 <tinyPulse_update_potential>
    11da:	ab 01       	movw	r20, r22
    11dc:	bc 01       	movw	r22, r24
    11de:	40 93 4a 38 	sts	0x384A, r20	; 0x80384a <tinyPotential_potential>
    11e2:	50 93 4b 38 	sts	0x384B, r21	; 0x80384b <tinyPotential_potential+0x1>
    11e6:	60 93 4c 38 	sts	0x384C, r22	; 0x80384c <tinyPotential_potential+0x2>
    11ea:	70 93 4d 38 	sts	0x384D, r23	; 0x80384d <tinyPotential_potential+0x3>
	
	tinyDebugger_send_double("Potential", tinyPotential_potential);
    11ee:	8e ec       	ldi	r24, 0xCE	; 206
    11f0:	9a e9       	ldi	r25, 0x9A	; 154
    11f2:	0e 94 41 04 	call	0x882	; 0x882 <tinyDebugger_send_double>
	
	
	// Let the axon affect the potential
	// This is also where we decide whether or not the axon should fire
	tinyPotential_potential = tinyAxon_update_potential(tinyPotential_potential);
    11f6:	60 91 4a 38 	lds	r22, 0x384A	; 0x80384a <tinyPotential_potential>
    11fa:	70 91 4b 38 	lds	r23, 0x384B	; 0x80384b <tinyPotential_potential+0x1>
    11fe:	80 91 4c 38 	lds	r24, 0x384C	; 0x80384c <tinyPotential_potential+0x2>
    1202:	90 91 4d 38 	lds	r25, 0x384D	; 0x80384d <tinyPotential_potential+0x3>
    1206:	0e 94 a1 02 	call	0x542	; 0x542 <tinyAxon_update_potential>
    120a:	60 93 4a 38 	sts	0x384A, r22	; 0x80384a <tinyPotential_potential>
    120e:	70 93 4b 38 	sts	0x384B, r23	; 0x80384b <tinyPotential_potential+0x1>
    1212:	80 93 4c 38 	sts	0x384C, r24	; 0x80384c <tinyPotential_potential+0x2>
    1216:	90 93 4d 38 	sts	0x384D, r25	; 0x80384d <tinyPotential_potential+0x3>
}
    121a:	ff 90       	pop	r15
    121c:	ef 90       	pop	r14
    121e:	df 90       	pop	r13
    1220:	cf 90       	pop	r12
    1222:	08 95       	ret

00001224 <tinyPulse_toggle_pulse_mode>:
_Bool tinyPulse_is_in_pulse_mode(){
	return pulse_mode;
}

void tinyPulse_toggle_pulse_mode(){
	pulse_mode = !pulse_mode;
    1224:	90 91 54 38 	lds	r25, 0x3854	; 0x803854 <pulse_mode>
    1228:	81 e0       	ldi	r24, 0x01	; 1
    122a:	89 27       	eor	r24, r25
    122c:	80 93 54 38 	sts	0x3854, r24	; 0x803854 <pulse_mode>
	
	if(tinyPulse_is_in_pulse_mode()){
    1230:	88 23       	and	r24, r24
    1232:	31 f0       	breq	.+12     	; 0x1240 <tinyPulse_toggle_pulse_mode+0x1c>
		tinyLED_set_color_mode(OUT_LED, PULSEMODE_COLOR, WEAK);
    1234:	41 e0       	ldi	r20, 0x01	; 1
    1236:	63 e0       	ldi	r22, 0x03	; 3
    1238:	81 e0       	ldi	r24, 0x01	; 1
    123a:	0e 94 83 05 	call	0xb06	; 0xb06 <tinyLED_set_color_mode>
    123e:	08 95       	ret
		//tinyLED_set_color_mode(INN_LED, PULSEMODE_COLOR, WEAK);
	}
	else{
		tinyLED_set_color(OUT_LED, LED_OFF);
    1240:	60 e0       	ldi	r22, 0x00	; 0
    1242:	81 e0       	ldi	r24, 0x01	; 1
    1244:	0e 94 ab 05 	call	0xb56	; 0xb56 <tinyLED_set_color>
    1248:	08 95       	ret

0000124a <tinyPulse_set_pulse_mode>:
		//tinyLED_set_color(INN_LED, LED_OFF);
	}
}

void tinyPulse_set_pulse_mode(_Bool mode){
	if (pulse_mode != mode)
    124a:	90 91 54 38 	lds	r25, 0x3854	; 0x803854 <pulse_mode>
    124e:	98 13       	cpse	r25, r24
	{
		tinyPulse_toggle_pulse_mode();
    1250:	0e 94 12 09 	call	0x1224	; 0x1224 <tinyPulse_toggle_pulse_mode>
    1254:	08 95       	ret

00001256 <tinyPulse_update_potential>:
	}
}

double tinyPulse_update_potential(double potential){
    1256:	cf 92       	push	r12
    1258:	df 92       	push	r13
    125a:	ef 92       	push	r14
    125c:	ff 92       	push	r15
    125e:	6b 01       	movw	r12, r22
    1260:	7c 01       	movw	r14, r24
	if(pulse_mode){
    1262:	80 91 54 38 	lds	r24, 0x3854	; 0x803854 <pulse_mode>
    1266:	88 23       	and	r24, r24
    1268:	39 f1       	breq	.+78     	; 0x12b8 <tinyPulse_update_potential+0x62>
		
		time_since_last_pulse = tinyTime_now() - time_of_last_pulse;
    126a:	0e 94 89 09 	call	0x1312	; 0x1312 <tinyTime_now>
    126e:	20 91 50 38 	lds	r18, 0x3850	; 0x803850 <time_of_last_pulse>
    1272:	30 91 51 38 	lds	r19, 0x3851	; 0x803851 <time_of_last_pulse+0x1>
    1276:	62 1b       	sub	r22, r18
    1278:	73 0b       	sbc	r23, r19
    127a:	60 93 4e 38 	sts	0x384E, r22	; 0x80384e <time_since_last_pulse>
    127e:	70 93 4f 38 	sts	0x384F, r23	; 0x80384f <time_since_last_pulse+0x1>
		
		if(time_since_last_pulse >= ideal_time_between_pulses){
    1282:	80 91 13 38 	lds	r24, 0x3813	; 0x803813 <ideal_time_between_pulses>
    1286:	90 91 14 38 	lds	r25, 0x3814	; 0x803814 <ideal_time_between_pulses+0x1>
    128a:	68 17       	cp	r22, r24
    128c:	79 07       	cpc	r23, r25
    128e:	a0 f0       	brcs	.+40     	; 0x12b8 <tinyPulse_update_potential+0x62>
			// This isn't actually a button press. You could have a separate variable for this, but it seems unnecessary.
			potential += BUTTON_PRESS_REACTION;
    1290:	20 e0       	ldi	r18, 0x00	; 0
    1292:	30 e0       	ldi	r19, 0x00	; 0
    1294:	40 ed       	ldi	r20, 0xD0	; 208
    1296:	51 e4       	ldi	r21, 0x41	; 65
    1298:	c7 01       	movw	r24, r14
    129a:	b6 01       	movw	r22, r12
    129c:	0e 94 93 09 	call	0x1326	; 0x1326 <__addsf3>
    12a0:	6b 01       	movw	r12, r22
    12a2:	7c 01       	movw	r14, r24
			time_of_last_pulse = tinyTime_now();			
    12a4:	0e 94 89 09 	call	0x1312	; 0x1312 <tinyTime_now>
    12a8:	60 93 50 38 	sts	0x3850, r22	; 0x803850 <time_of_last_pulse>
    12ac:	70 93 51 38 	sts	0x3851, r23	; 0x803851 <time_of_last_pulse+0x1>
    12b0:	80 93 52 38 	sts	0x3852, r24	; 0x803852 <time_of_last_pulse+0x2>
    12b4:	90 93 53 38 	sts	0x3853, r25	; 0x803853 <time_of_last_pulse+0x3>
		}
	}
	return potential;
}
    12b8:	c7 01       	movw	r24, r14
    12ba:	b6 01       	movw	r22, r12
    12bc:	ff 90       	pop	r15
    12be:	ef 90       	pop	r14
    12c0:	df 90       	pop	r13
    12c2:	cf 90       	pop	r12
    12c4:	08 95       	ret

000012c6 <tinySleep_prepare_sleep>:
  PCMSK |= _BV(PCINT3);                   // Use PB3 as interrupt pin
  ADCSRA &= ~_BV(ADEN);                   // ADC off
  */
  
  //set_sleep_mode(SLEEP_MODE_PWR_DOWN);  // Set sleep mode to POWER DOWN mode
  set_sleep_mode(SLEEP_MODE_IDLE);  // Set sleep mode to POWER DOWN mode
    12c6:	e0 e5       	ldi	r30, 0x50	; 80
    12c8:	f0 e0       	ldi	r31, 0x00	; 0
    12ca:	80 81       	ld	r24, Z
    12cc:	89 7f       	andi	r24, 0xF9	; 249
    12ce:	80 83       	st	Z, r24
  sleep_enable();
    12d0:	80 81       	ld	r24, Z
    12d2:	81 60       	ori	r24, 0x01	; 1
    12d4:	80 83       	st	Z, r24
    12d6:	08 95       	ret

000012d8 <tinySleep_enter_sleep>:

void tinySleep_enter_sleep(){

	
  //sleep_bod_disable();
  cli();
    12d8:	f8 94       	cli
  sei();
    12da:	78 94       	sei
  sleep_cpu();
    12dc:	88 95       	sleep
  sleep_disable();
    12de:	e0 e5       	ldi	r30, 0x50	; 80
    12e0:	f0 e0       	ldi	r31, 0x00	; 0
    12e2:	80 81       	ld	r24, Z
    12e4:	8e 7f       	andi	r24, 0xFE	; 254
    12e6:	80 83       	st	Z, r24
    12e8:	08 95       	ret

000012ea <tinyTime_counter_increment>:
If the Interrupt Service Routine is clocked by a crystal oscillator
it gives a very precise timer-counter.
*/
void tinyTime_counter_increment(void)
{
	time_counter++;
    12ea:	80 91 55 38 	lds	r24, 0x3855	; 0x803855 <time_counter>
    12ee:	90 91 56 38 	lds	r25, 0x3856	; 0x803856 <time_counter+0x1>
    12f2:	a0 91 57 38 	lds	r26, 0x3857	; 0x803857 <time_counter+0x2>
    12f6:	b0 91 58 38 	lds	r27, 0x3858	; 0x803858 <time_counter+0x3>
    12fa:	01 96       	adiw	r24, 0x01	; 1
    12fc:	a1 1d       	adc	r26, r1
    12fe:	b1 1d       	adc	r27, r1
    1300:	80 93 55 38 	sts	0x3855, r24	; 0x803855 <time_counter>
    1304:	90 93 56 38 	sts	0x3856, r25	; 0x803856 <time_counter+0x1>
    1308:	a0 93 57 38 	sts	0x3857, r26	; 0x803857 <time_counter+0x2>
    130c:	b0 93 58 38 	sts	0x3858, r27	; 0x803858 <time_counter+0x3>
    1310:	08 95       	ret

00001312 <tinyTime_now>:
/*
This function is callable by external libraries to give them the counted time so far.
*/
uint32_t tinyTime_now(void)
{
	return time_counter;
    1312:	60 91 55 38 	lds	r22, 0x3855	; 0x803855 <time_counter>
    1316:	70 91 56 38 	lds	r23, 0x3856	; 0x803856 <time_counter+0x1>
    131a:	80 91 57 38 	lds	r24, 0x3857	; 0x803857 <time_counter+0x2>
    131e:	90 91 58 38 	lds	r25, 0x3858	; 0x803858 <time_counter+0x3>
    1322:	08 95       	ret

00001324 <__subsf3>:
    1324:	50 58       	subi	r21, 0x80	; 128

00001326 <__addsf3>:
    1326:	bb 27       	eor	r27, r27
    1328:	aa 27       	eor	r26, r26
    132a:	0e 94 aa 09 	call	0x1354	; 0x1354 <__addsf3x>
    132e:	0c 94 a4 0b 	jmp	0x1748	; 0x1748 <__fp_round>
    1332:	0e 94 96 0b 	call	0x172c	; 0x172c <__fp_pscA>
    1336:	38 f0       	brcs	.+14     	; 0x1346 <__addsf3+0x20>
    1338:	0e 94 9d 0b 	call	0x173a	; 0x173a <__fp_pscB>
    133c:	20 f0       	brcs	.+8      	; 0x1346 <__addsf3+0x20>
    133e:	39 f4       	brne	.+14     	; 0x134e <__addsf3+0x28>
    1340:	9f 3f       	cpi	r25, 0xFF	; 255
    1342:	19 f4       	brne	.+6      	; 0x134a <__addsf3+0x24>
    1344:	26 f4       	brtc	.+8      	; 0x134e <__addsf3+0x28>
    1346:	0c 94 6c 0b 	jmp	0x16d8	; 0x16d8 <__fp_nan>
    134a:	0e f4       	brtc	.+2      	; 0x134e <__addsf3+0x28>
    134c:	e0 95       	com	r30
    134e:	e7 fb       	bst	r30, 7
    1350:	0c 94 66 0b 	jmp	0x16cc	; 0x16cc <__fp_inf>

00001354 <__addsf3x>:
    1354:	e9 2f       	mov	r30, r25
    1356:	0e 94 b5 0b 	call	0x176a	; 0x176a <__fp_split3>
    135a:	58 f3       	brcs	.-42     	; 0x1332 <__addsf3+0xc>
    135c:	ba 17       	cp	r27, r26
    135e:	62 07       	cpc	r22, r18
    1360:	73 07       	cpc	r23, r19
    1362:	84 07       	cpc	r24, r20
    1364:	95 07       	cpc	r25, r21
    1366:	20 f0       	brcs	.+8      	; 0x1370 <__addsf3x+0x1c>
    1368:	79 f4       	brne	.+30     	; 0x1388 <__addsf3x+0x34>
    136a:	a6 f5       	brtc	.+104    	; 0x13d4 <__addsf3x+0x80>
    136c:	0c 94 d7 0b 	jmp	0x17ae	; 0x17ae <__fp_zero>
    1370:	0e f4       	brtc	.+2      	; 0x1374 <__addsf3x+0x20>
    1372:	e0 95       	com	r30
    1374:	0b 2e       	mov	r0, r27
    1376:	ba 2f       	mov	r27, r26
    1378:	a0 2d       	mov	r26, r0
    137a:	0b 01       	movw	r0, r22
    137c:	b9 01       	movw	r22, r18
    137e:	90 01       	movw	r18, r0
    1380:	0c 01       	movw	r0, r24
    1382:	ca 01       	movw	r24, r20
    1384:	a0 01       	movw	r20, r0
    1386:	11 24       	eor	r1, r1
    1388:	ff 27       	eor	r31, r31
    138a:	59 1b       	sub	r21, r25
    138c:	99 f0       	breq	.+38     	; 0x13b4 <__addsf3x+0x60>
    138e:	59 3f       	cpi	r21, 0xF9	; 249
    1390:	50 f4       	brcc	.+20     	; 0x13a6 <__addsf3x+0x52>
    1392:	50 3e       	cpi	r21, 0xE0	; 224
    1394:	68 f1       	brcs	.+90     	; 0x13f0 <__addsf3x+0x9c>
    1396:	1a 16       	cp	r1, r26
    1398:	f0 40       	sbci	r31, 0x00	; 0
    139a:	a2 2f       	mov	r26, r18
    139c:	23 2f       	mov	r18, r19
    139e:	34 2f       	mov	r19, r20
    13a0:	44 27       	eor	r20, r20
    13a2:	58 5f       	subi	r21, 0xF8	; 248
    13a4:	f3 cf       	rjmp	.-26     	; 0x138c <__addsf3x+0x38>
    13a6:	46 95       	lsr	r20
    13a8:	37 95       	ror	r19
    13aa:	27 95       	ror	r18
    13ac:	a7 95       	ror	r26
    13ae:	f0 40       	sbci	r31, 0x00	; 0
    13b0:	53 95       	inc	r21
    13b2:	c9 f7       	brne	.-14     	; 0x13a6 <__addsf3x+0x52>
    13b4:	7e f4       	brtc	.+30     	; 0x13d4 <__addsf3x+0x80>
    13b6:	1f 16       	cp	r1, r31
    13b8:	ba 0b       	sbc	r27, r26
    13ba:	62 0b       	sbc	r22, r18
    13bc:	73 0b       	sbc	r23, r19
    13be:	84 0b       	sbc	r24, r20
    13c0:	ba f0       	brmi	.+46     	; 0x13f0 <__addsf3x+0x9c>
    13c2:	91 50       	subi	r25, 0x01	; 1
    13c4:	a1 f0       	breq	.+40     	; 0x13ee <__addsf3x+0x9a>
    13c6:	ff 0f       	add	r31, r31
    13c8:	bb 1f       	adc	r27, r27
    13ca:	66 1f       	adc	r22, r22
    13cc:	77 1f       	adc	r23, r23
    13ce:	88 1f       	adc	r24, r24
    13d0:	c2 f7       	brpl	.-16     	; 0x13c2 <__addsf3x+0x6e>
    13d2:	0e c0       	rjmp	.+28     	; 0x13f0 <__addsf3x+0x9c>
    13d4:	ba 0f       	add	r27, r26
    13d6:	62 1f       	adc	r22, r18
    13d8:	73 1f       	adc	r23, r19
    13da:	84 1f       	adc	r24, r20
    13dc:	48 f4       	brcc	.+18     	; 0x13f0 <__addsf3x+0x9c>
    13de:	87 95       	ror	r24
    13e0:	77 95       	ror	r23
    13e2:	67 95       	ror	r22
    13e4:	b7 95       	ror	r27
    13e6:	f7 95       	ror	r31
    13e8:	9e 3f       	cpi	r25, 0xFE	; 254
    13ea:	08 f0       	brcs	.+2      	; 0x13ee <__addsf3x+0x9a>
    13ec:	b0 cf       	rjmp	.-160    	; 0x134e <__addsf3+0x28>
    13ee:	93 95       	inc	r25
    13f0:	88 0f       	add	r24, r24
    13f2:	08 f0       	brcs	.+2      	; 0x13f6 <__addsf3x+0xa2>
    13f4:	99 27       	eor	r25, r25
    13f6:	ee 0f       	add	r30, r30
    13f8:	97 95       	ror	r25
    13fa:	87 95       	ror	r24
    13fc:	08 95       	ret

000013fe <__cmpsf2>:
    13fe:	0e 94 42 0b 	call	0x1684	; 0x1684 <__fp_cmp>
    1402:	08 f4       	brcc	.+2      	; 0x1406 <__cmpsf2+0x8>
    1404:	81 e0       	ldi	r24, 0x01	; 1
    1406:	08 95       	ret

00001408 <__divsf3>:
    1408:	0e 94 18 0a 	call	0x1430	; 0x1430 <__divsf3x>
    140c:	0c 94 a4 0b 	jmp	0x1748	; 0x1748 <__fp_round>
    1410:	0e 94 9d 0b 	call	0x173a	; 0x173a <__fp_pscB>
    1414:	58 f0       	brcs	.+22     	; 0x142c <__divsf3+0x24>
    1416:	0e 94 96 0b 	call	0x172c	; 0x172c <__fp_pscA>
    141a:	40 f0       	brcs	.+16     	; 0x142c <__divsf3+0x24>
    141c:	29 f4       	brne	.+10     	; 0x1428 <__divsf3+0x20>
    141e:	5f 3f       	cpi	r21, 0xFF	; 255
    1420:	29 f0       	breq	.+10     	; 0x142c <__divsf3+0x24>
    1422:	0c 94 66 0b 	jmp	0x16cc	; 0x16cc <__fp_inf>
    1426:	51 11       	cpse	r21, r1
    1428:	0c 94 d8 0b 	jmp	0x17b0	; 0x17b0 <__fp_szero>
    142c:	0c 94 6c 0b 	jmp	0x16d8	; 0x16d8 <__fp_nan>

00001430 <__divsf3x>:
    1430:	0e 94 b5 0b 	call	0x176a	; 0x176a <__fp_split3>
    1434:	68 f3       	brcs	.-38     	; 0x1410 <__divsf3+0x8>

00001436 <__divsf3_pse>:
    1436:	99 23       	and	r25, r25
    1438:	b1 f3       	breq	.-20     	; 0x1426 <__divsf3+0x1e>
    143a:	55 23       	and	r21, r21
    143c:	91 f3       	breq	.-28     	; 0x1422 <__divsf3+0x1a>
    143e:	95 1b       	sub	r25, r21
    1440:	55 0b       	sbc	r21, r21
    1442:	bb 27       	eor	r27, r27
    1444:	aa 27       	eor	r26, r26
    1446:	62 17       	cp	r22, r18
    1448:	73 07       	cpc	r23, r19
    144a:	84 07       	cpc	r24, r20
    144c:	38 f0       	brcs	.+14     	; 0x145c <__divsf3_pse+0x26>
    144e:	9f 5f       	subi	r25, 0xFF	; 255
    1450:	5f 4f       	sbci	r21, 0xFF	; 255
    1452:	22 0f       	add	r18, r18
    1454:	33 1f       	adc	r19, r19
    1456:	44 1f       	adc	r20, r20
    1458:	aa 1f       	adc	r26, r26
    145a:	a9 f3       	breq	.-22     	; 0x1446 <__divsf3_pse+0x10>
    145c:	35 d0       	rcall	.+106    	; 0x14c8 <__divsf3_pse+0x92>
    145e:	0e 2e       	mov	r0, r30
    1460:	3a f0       	brmi	.+14     	; 0x1470 <__divsf3_pse+0x3a>
    1462:	e0 e8       	ldi	r30, 0x80	; 128
    1464:	32 d0       	rcall	.+100    	; 0x14ca <__divsf3_pse+0x94>
    1466:	91 50       	subi	r25, 0x01	; 1
    1468:	50 40       	sbci	r21, 0x00	; 0
    146a:	e6 95       	lsr	r30
    146c:	00 1c       	adc	r0, r0
    146e:	ca f7       	brpl	.-14     	; 0x1462 <__divsf3_pse+0x2c>
    1470:	2b d0       	rcall	.+86     	; 0x14c8 <__divsf3_pse+0x92>
    1472:	fe 2f       	mov	r31, r30
    1474:	29 d0       	rcall	.+82     	; 0x14c8 <__divsf3_pse+0x92>
    1476:	66 0f       	add	r22, r22
    1478:	77 1f       	adc	r23, r23
    147a:	88 1f       	adc	r24, r24
    147c:	bb 1f       	adc	r27, r27
    147e:	26 17       	cp	r18, r22
    1480:	37 07       	cpc	r19, r23
    1482:	48 07       	cpc	r20, r24
    1484:	ab 07       	cpc	r26, r27
    1486:	b0 e8       	ldi	r27, 0x80	; 128
    1488:	09 f0       	breq	.+2      	; 0x148c <__divsf3_pse+0x56>
    148a:	bb 0b       	sbc	r27, r27
    148c:	80 2d       	mov	r24, r0
    148e:	bf 01       	movw	r22, r30
    1490:	ff 27       	eor	r31, r31
    1492:	93 58       	subi	r25, 0x83	; 131
    1494:	5f 4f       	sbci	r21, 0xFF	; 255
    1496:	3a f0       	brmi	.+14     	; 0x14a6 <__divsf3_pse+0x70>
    1498:	9e 3f       	cpi	r25, 0xFE	; 254
    149a:	51 05       	cpc	r21, r1
    149c:	78 f0       	brcs	.+30     	; 0x14bc <__divsf3_pse+0x86>
    149e:	0c 94 66 0b 	jmp	0x16cc	; 0x16cc <__fp_inf>
    14a2:	0c 94 d8 0b 	jmp	0x17b0	; 0x17b0 <__fp_szero>
    14a6:	5f 3f       	cpi	r21, 0xFF	; 255
    14a8:	e4 f3       	brlt	.-8      	; 0x14a2 <__divsf3_pse+0x6c>
    14aa:	98 3e       	cpi	r25, 0xE8	; 232
    14ac:	d4 f3       	brlt	.-12     	; 0x14a2 <__divsf3_pse+0x6c>
    14ae:	86 95       	lsr	r24
    14b0:	77 95       	ror	r23
    14b2:	67 95       	ror	r22
    14b4:	b7 95       	ror	r27
    14b6:	f7 95       	ror	r31
    14b8:	9f 5f       	subi	r25, 0xFF	; 255
    14ba:	c9 f7       	brne	.-14     	; 0x14ae <__divsf3_pse+0x78>
    14bc:	88 0f       	add	r24, r24
    14be:	91 1d       	adc	r25, r1
    14c0:	96 95       	lsr	r25
    14c2:	87 95       	ror	r24
    14c4:	97 f9       	bld	r25, 7
    14c6:	08 95       	ret
    14c8:	e1 e0       	ldi	r30, 0x01	; 1
    14ca:	66 0f       	add	r22, r22
    14cc:	77 1f       	adc	r23, r23
    14ce:	88 1f       	adc	r24, r24
    14d0:	bb 1f       	adc	r27, r27
    14d2:	62 17       	cp	r22, r18
    14d4:	73 07       	cpc	r23, r19
    14d6:	84 07       	cpc	r24, r20
    14d8:	ba 07       	cpc	r27, r26
    14da:	20 f0       	brcs	.+8      	; 0x14e4 <__divsf3_pse+0xae>
    14dc:	62 1b       	sub	r22, r18
    14de:	73 0b       	sbc	r23, r19
    14e0:	84 0b       	sbc	r24, r20
    14e2:	ba 0b       	sbc	r27, r26
    14e4:	ee 1f       	adc	r30, r30
    14e6:	88 f7       	brcc	.-30     	; 0x14ca <__divsf3_pse+0x94>
    14e8:	e0 95       	com	r30
    14ea:	08 95       	ret
    14ec:	29 f4       	brne	.+10     	; 0x14f8 <__divsf3_pse+0xc2>
    14ee:	16 f0       	brts	.+4      	; 0x14f4 <__divsf3_pse+0xbe>
    14f0:	0c 94 66 0b 	jmp	0x16cc	; 0x16cc <__fp_inf>
    14f4:	0c 94 d7 0b 	jmp	0x17ae	; 0x17ae <__fp_zero>
    14f8:	0c 94 6c 0b 	jmp	0x16d8	; 0x16d8 <__fp_nan>

000014fc <exp>:
    14fc:	0e 94 bd 0b 	call	0x177a	; 0x177a <__fp_splitA>
    1500:	a8 f3       	brcs	.-22     	; 0x14ec <__divsf3_pse+0xb6>
    1502:	96 38       	cpi	r25, 0x86	; 134
    1504:	a0 f7       	brcc	.-24     	; 0x14ee <__divsf3_pse+0xb8>
    1506:	07 f8       	bld	r0, 7
    1508:	0f 92       	push	r0
    150a:	e8 94       	clt
    150c:	2b e3       	ldi	r18, 0x3B	; 59
    150e:	3a ea       	ldi	r19, 0xAA	; 170
    1510:	48 eb       	ldi	r20, 0xB8	; 184
    1512:	5f e7       	ldi	r21, 0x7F	; 127
    1514:	0e 94 6f 0c 	call	0x18de	; 0x18de <__mulsf3_pse>
    1518:	0f 92       	push	r0
    151a:	0f 92       	push	r0
    151c:	0f 92       	push	r0
    151e:	4d b7       	in	r20, 0x3d	; 61
    1520:	5e b7       	in	r21, 0x3e	; 62
    1522:	0f 92       	push	r0
    1524:	0e 94 25 0c 	call	0x184a	; 0x184a <modf>
    1528:	ec e7       	ldi	r30, 0x7C	; 124
    152a:	f0 e0       	ldi	r31, 0x00	; 0
    152c:	0e 94 6f 0b 	call	0x16de	; 0x16de <__fp_powser>
    1530:	4f 91       	pop	r20
    1532:	5f 91       	pop	r21
    1534:	ef 91       	pop	r30
    1536:	ff 91       	pop	r31
    1538:	e5 95       	asr	r30
    153a:	ee 1f       	adc	r30, r30
    153c:	ff 1f       	adc	r31, r31
    153e:	49 f0       	breq	.+18     	; 0x1552 <exp+0x56>
    1540:	fe 57       	subi	r31, 0x7E	; 126
    1542:	e0 68       	ori	r30, 0x80	; 128
    1544:	44 27       	eor	r20, r20
    1546:	ee 0f       	add	r30, r30
    1548:	44 1f       	adc	r20, r20
    154a:	fa 95       	dec	r31
    154c:	e1 f7       	brne	.-8      	; 0x1546 <exp+0x4a>
    154e:	41 95       	neg	r20
    1550:	55 0b       	sbc	r21, r21
    1552:	0e 94 ef 0b 	call	0x17de	; 0x17de <ldexp>
    1556:	0f 90       	pop	r0
    1558:	07 fe       	sbrs	r0, 7
    155a:	0c 94 e3 0b 	jmp	0x17c6	; 0x17c6 <inverse>
    155e:	08 95       	ret

00001560 <__fixsfsi>:
    1560:	0e 94 b7 0a 	call	0x156e	; 0x156e <__fixunssfsi>
    1564:	68 94       	set
    1566:	b1 11       	cpse	r27, r1
    1568:	0c 94 d8 0b 	jmp	0x17b0	; 0x17b0 <__fp_szero>
    156c:	08 95       	ret

0000156e <__fixunssfsi>:
    156e:	0e 94 bd 0b 	call	0x177a	; 0x177a <__fp_splitA>
    1572:	88 f0       	brcs	.+34     	; 0x1596 <__fixunssfsi+0x28>
    1574:	9f 57       	subi	r25, 0x7F	; 127
    1576:	98 f0       	brcs	.+38     	; 0x159e <__fixunssfsi+0x30>
    1578:	b9 2f       	mov	r27, r25
    157a:	99 27       	eor	r25, r25
    157c:	b7 51       	subi	r27, 0x17	; 23
    157e:	b0 f0       	brcs	.+44     	; 0x15ac <__fixunssfsi+0x3e>
    1580:	e1 f0       	breq	.+56     	; 0x15ba <__fixunssfsi+0x4c>
    1582:	66 0f       	add	r22, r22
    1584:	77 1f       	adc	r23, r23
    1586:	88 1f       	adc	r24, r24
    1588:	99 1f       	adc	r25, r25
    158a:	1a f0       	brmi	.+6      	; 0x1592 <__fixunssfsi+0x24>
    158c:	ba 95       	dec	r27
    158e:	c9 f7       	brne	.-14     	; 0x1582 <__fixunssfsi+0x14>
    1590:	14 c0       	rjmp	.+40     	; 0x15ba <__fixunssfsi+0x4c>
    1592:	b1 30       	cpi	r27, 0x01	; 1
    1594:	91 f0       	breq	.+36     	; 0x15ba <__fixunssfsi+0x4c>
    1596:	0e 94 d7 0b 	call	0x17ae	; 0x17ae <__fp_zero>
    159a:	b1 e0       	ldi	r27, 0x01	; 1
    159c:	08 95       	ret
    159e:	0c 94 d7 0b 	jmp	0x17ae	; 0x17ae <__fp_zero>
    15a2:	67 2f       	mov	r22, r23
    15a4:	78 2f       	mov	r23, r24
    15a6:	88 27       	eor	r24, r24
    15a8:	b8 5f       	subi	r27, 0xF8	; 248
    15aa:	39 f0       	breq	.+14     	; 0x15ba <__fixunssfsi+0x4c>
    15ac:	b9 3f       	cpi	r27, 0xF9	; 249
    15ae:	cc f3       	brlt	.-14     	; 0x15a2 <__fixunssfsi+0x34>
    15b0:	86 95       	lsr	r24
    15b2:	77 95       	ror	r23
    15b4:	67 95       	ror	r22
    15b6:	b3 95       	inc	r27
    15b8:	d9 f7       	brne	.-10     	; 0x15b0 <__fixunssfsi+0x42>
    15ba:	3e f4       	brtc	.+14     	; 0x15ca <__fixunssfsi+0x5c>
    15bc:	90 95       	com	r25
    15be:	80 95       	com	r24
    15c0:	70 95       	com	r23
    15c2:	61 95       	neg	r22
    15c4:	7f 4f       	sbci	r23, 0xFF	; 255
    15c6:	8f 4f       	sbci	r24, 0xFF	; 255
    15c8:	9f 4f       	sbci	r25, 0xFF	; 255
    15ca:	08 95       	ret

000015cc <__floatunsisf>:
    15cc:	e8 94       	clt
    15ce:	09 c0       	rjmp	.+18     	; 0x15e2 <__floatsisf+0x12>

000015d0 <__floatsisf>:
    15d0:	97 fb       	bst	r25, 7
    15d2:	3e f4       	brtc	.+14     	; 0x15e2 <__floatsisf+0x12>
    15d4:	90 95       	com	r25
    15d6:	80 95       	com	r24
    15d8:	70 95       	com	r23
    15da:	61 95       	neg	r22
    15dc:	7f 4f       	sbci	r23, 0xFF	; 255
    15de:	8f 4f       	sbci	r24, 0xFF	; 255
    15e0:	9f 4f       	sbci	r25, 0xFF	; 255
    15e2:	99 23       	and	r25, r25
    15e4:	a9 f0       	breq	.+42     	; 0x1610 <__floatsisf+0x40>
    15e6:	f9 2f       	mov	r31, r25
    15e8:	96 e9       	ldi	r25, 0x96	; 150
    15ea:	bb 27       	eor	r27, r27
    15ec:	93 95       	inc	r25
    15ee:	f6 95       	lsr	r31
    15f0:	87 95       	ror	r24
    15f2:	77 95       	ror	r23
    15f4:	67 95       	ror	r22
    15f6:	b7 95       	ror	r27
    15f8:	f1 11       	cpse	r31, r1
    15fa:	f8 cf       	rjmp	.-16     	; 0x15ec <__floatsisf+0x1c>
    15fc:	fa f4       	brpl	.+62     	; 0x163c <__floatsisf+0x6c>
    15fe:	bb 0f       	add	r27, r27
    1600:	11 f4       	brne	.+4      	; 0x1606 <__floatsisf+0x36>
    1602:	60 ff       	sbrs	r22, 0
    1604:	1b c0       	rjmp	.+54     	; 0x163c <__floatsisf+0x6c>
    1606:	6f 5f       	subi	r22, 0xFF	; 255
    1608:	7f 4f       	sbci	r23, 0xFF	; 255
    160a:	8f 4f       	sbci	r24, 0xFF	; 255
    160c:	9f 4f       	sbci	r25, 0xFF	; 255
    160e:	16 c0       	rjmp	.+44     	; 0x163c <__floatsisf+0x6c>
    1610:	88 23       	and	r24, r24
    1612:	11 f0       	breq	.+4      	; 0x1618 <__floatsisf+0x48>
    1614:	96 e9       	ldi	r25, 0x96	; 150
    1616:	11 c0       	rjmp	.+34     	; 0x163a <__floatsisf+0x6a>
    1618:	77 23       	and	r23, r23
    161a:	21 f0       	breq	.+8      	; 0x1624 <__floatsisf+0x54>
    161c:	9e e8       	ldi	r25, 0x8E	; 142
    161e:	87 2f       	mov	r24, r23
    1620:	76 2f       	mov	r23, r22
    1622:	05 c0       	rjmp	.+10     	; 0x162e <__floatsisf+0x5e>
    1624:	66 23       	and	r22, r22
    1626:	71 f0       	breq	.+28     	; 0x1644 <__floatsisf+0x74>
    1628:	96 e8       	ldi	r25, 0x86	; 134
    162a:	86 2f       	mov	r24, r22
    162c:	70 e0       	ldi	r23, 0x00	; 0
    162e:	60 e0       	ldi	r22, 0x00	; 0
    1630:	2a f0       	brmi	.+10     	; 0x163c <__floatsisf+0x6c>
    1632:	9a 95       	dec	r25
    1634:	66 0f       	add	r22, r22
    1636:	77 1f       	adc	r23, r23
    1638:	88 1f       	adc	r24, r24
    163a:	da f7       	brpl	.-10     	; 0x1632 <__floatsisf+0x62>
    163c:	88 0f       	add	r24, r24
    163e:	96 95       	lsr	r25
    1640:	87 95       	ror	r24
    1642:	97 f9       	bld	r25, 7
    1644:	08 95       	ret

00001646 <fmin>:
    1646:	99 0f       	add	r25, r25
    1648:	bb 0b       	sbc	r27, r27
    164a:	55 0f       	add	r21, r21
    164c:	aa 0b       	sbc	r26, r26
    164e:	e0 e8       	ldi	r30, 0x80	; 128
    1650:	fe ef       	ldi	r31, 0xFE	; 254
    1652:	16 16       	cp	r1, r22
    1654:	17 06       	cpc	r1, r23
    1656:	e8 07       	cpc	r30, r24
    1658:	f9 07       	cpc	r31, r25
    165a:	70 f0       	brcs	.+28     	; 0x1678 <fmin+0x32>
    165c:	12 16       	cp	r1, r18
    165e:	13 06       	cpc	r1, r19
    1660:	e4 07       	cpc	r30, r20
    1662:	f5 07       	cpc	r31, r21
    1664:	60 f0       	brcs	.+24     	; 0x167e <fmin+0x38>
    1666:	ba 17       	cp	r27, r26
    1668:	54 f0       	brlt	.+20     	; 0x167e <fmin+0x38>
    166a:	31 f4       	brne	.+12     	; 0x1678 <fmin+0x32>
    166c:	26 17       	cp	r18, r22
    166e:	37 07       	cpc	r19, r23
    1670:	48 07       	cpc	r20, r24
    1672:	59 07       	cpc	r21, r25
    1674:	a7 95       	ror	r26
    1676:	1b f4       	brvc	.+6      	; 0x167e <fmin+0x38>
    1678:	b9 01       	movw	r22, r18
    167a:	ca 01       	movw	r24, r20
    167c:	ba 2f       	mov	r27, r26
    167e:	b6 95       	lsr	r27
    1680:	97 95       	ror	r25
    1682:	08 95       	ret

00001684 <__fp_cmp>:
    1684:	99 0f       	add	r25, r25
    1686:	00 08       	sbc	r0, r0
    1688:	55 0f       	add	r21, r21
    168a:	aa 0b       	sbc	r26, r26
    168c:	e0 e8       	ldi	r30, 0x80	; 128
    168e:	fe ef       	ldi	r31, 0xFE	; 254
    1690:	16 16       	cp	r1, r22
    1692:	17 06       	cpc	r1, r23
    1694:	e8 07       	cpc	r30, r24
    1696:	f9 07       	cpc	r31, r25
    1698:	c0 f0       	brcs	.+48     	; 0x16ca <__fp_cmp+0x46>
    169a:	12 16       	cp	r1, r18
    169c:	13 06       	cpc	r1, r19
    169e:	e4 07       	cpc	r30, r20
    16a0:	f5 07       	cpc	r31, r21
    16a2:	98 f0       	brcs	.+38     	; 0x16ca <__fp_cmp+0x46>
    16a4:	62 1b       	sub	r22, r18
    16a6:	73 0b       	sbc	r23, r19
    16a8:	84 0b       	sbc	r24, r20
    16aa:	95 0b       	sbc	r25, r21
    16ac:	39 f4       	brne	.+14     	; 0x16bc <__fp_cmp+0x38>
    16ae:	0a 26       	eor	r0, r26
    16b0:	61 f0       	breq	.+24     	; 0x16ca <__fp_cmp+0x46>
    16b2:	23 2b       	or	r18, r19
    16b4:	24 2b       	or	r18, r20
    16b6:	25 2b       	or	r18, r21
    16b8:	21 f4       	brne	.+8      	; 0x16c2 <__fp_cmp+0x3e>
    16ba:	08 95       	ret
    16bc:	0a 26       	eor	r0, r26
    16be:	09 f4       	brne	.+2      	; 0x16c2 <__fp_cmp+0x3e>
    16c0:	a1 40       	sbci	r26, 0x01	; 1
    16c2:	a6 95       	lsr	r26
    16c4:	8f ef       	ldi	r24, 0xFF	; 255
    16c6:	81 1d       	adc	r24, r1
    16c8:	81 1d       	adc	r24, r1
    16ca:	08 95       	ret

000016cc <__fp_inf>:
    16cc:	97 f9       	bld	r25, 7
    16ce:	9f 67       	ori	r25, 0x7F	; 127
    16d0:	80 e8       	ldi	r24, 0x80	; 128
    16d2:	70 e0       	ldi	r23, 0x00	; 0
    16d4:	60 e0       	ldi	r22, 0x00	; 0
    16d6:	08 95       	ret

000016d8 <__fp_nan>:
    16d8:	9f ef       	ldi	r25, 0xFF	; 255
    16da:	80 ec       	ldi	r24, 0xC0	; 192
    16dc:	08 95       	ret

000016de <__fp_powser>:
    16de:	df 93       	push	r29
    16e0:	cf 93       	push	r28
    16e2:	1f 93       	push	r17
    16e4:	0f 93       	push	r16
    16e6:	ff 92       	push	r15
    16e8:	ef 92       	push	r14
    16ea:	df 92       	push	r13
    16ec:	7b 01       	movw	r14, r22
    16ee:	8c 01       	movw	r16, r24
    16f0:	68 94       	set
    16f2:	06 c0       	rjmp	.+12     	; 0x1700 <__fp_powser+0x22>
    16f4:	da 2e       	mov	r13, r26
    16f6:	ef 01       	movw	r28, r30
    16f8:	0e 94 6c 0c 	call	0x18d8	; 0x18d8 <__mulsf3x>
    16fc:	fe 01       	movw	r30, r28
    16fe:	e8 94       	clt
    1700:	a5 91       	lpm	r26, Z+
    1702:	25 91       	lpm	r18, Z+
    1704:	35 91       	lpm	r19, Z+
    1706:	45 91       	lpm	r20, Z+
    1708:	55 91       	lpm	r21, Z+
    170a:	a6 f3       	brts	.-24     	; 0x16f4 <__fp_powser+0x16>
    170c:	ef 01       	movw	r28, r30
    170e:	0e 94 aa 09 	call	0x1354	; 0x1354 <__addsf3x>
    1712:	fe 01       	movw	r30, r28
    1714:	97 01       	movw	r18, r14
    1716:	a8 01       	movw	r20, r16
    1718:	da 94       	dec	r13
    171a:	69 f7       	brne	.-38     	; 0x16f6 <__fp_powser+0x18>
    171c:	df 90       	pop	r13
    171e:	ef 90       	pop	r14
    1720:	ff 90       	pop	r15
    1722:	0f 91       	pop	r16
    1724:	1f 91       	pop	r17
    1726:	cf 91       	pop	r28
    1728:	df 91       	pop	r29
    172a:	08 95       	ret

0000172c <__fp_pscA>:
    172c:	00 24       	eor	r0, r0
    172e:	0a 94       	dec	r0
    1730:	16 16       	cp	r1, r22
    1732:	17 06       	cpc	r1, r23
    1734:	18 06       	cpc	r1, r24
    1736:	09 06       	cpc	r0, r25
    1738:	08 95       	ret

0000173a <__fp_pscB>:
    173a:	00 24       	eor	r0, r0
    173c:	0a 94       	dec	r0
    173e:	12 16       	cp	r1, r18
    1740:	13 06       	cpc	r1, r19
    1742:	14 06       	cpc	r1, r20
    1744:	05 06       	cpc	r0, r21
    1746:	08 95       	ret

00001748 <__fp_round>:
    1748:	09 2e       	mov	r0, r25
    174a:	03 94       	inc	r0
    174c:	00 0c       	add	r0, r0
    174e:	11 f4       	brne	.+4      	; 0x1754 <__fp_round+0xc>
    1750:	88 23       	and	r24, r24
    1752:	52 f0       	brmi	.+20     	; 0x1768 <__fp_round+0x20>
    1754:	bb 0f       	add	r27, r27
    1756:	40 f4       	brcc	.+16     	; 0x1768 <__fp_round+0x20>
    1758:	bf 2b       	or	r27, r31
    175a:	11 f4       	brne	.+4      	; 0x1760 <__fp_round+0x18>
    175c:	60 ff       	sbrs	r22, 0
    175e:	04 c0       	rjmp	.+8      	; 0x1768 <__fp_round+0x20>
    1760:	6f 5f       	subi	r22, 0xFF	; 255
    1762:	7f 4f       	sbci	r23, 0xFF	; 255
    1764:	8f 4f       	sbci	r24, 0xFF	; 255
    1766:	9f 4f       	sbci	r25, 0xFF	; 255
    1768:	08 95       	ret

0000176a <__fp_split3>:
    176a:	57 fd       	sbrc	r21, 7
    176c:	90 58       	subi	r25, 0x80	; 128
    176e:	44 0f       	add	r20, r20
    1770:	55 1f       	adc	r21, r21
    1772:	59 f0       	breq	.+22     	; 0x178a <__fp_splitA+0x10>
    1774:	5f 3f       	cpi	r21, 0xFF	; 255
    1776:	71 f0       	breq	.+28     	; 0x1794 <__fp_splitA+0x1a>
    1778:	47 95       	ror	r20

0000177a <__fp_splitA>:
    177a:	88 0f       	add	r24, r24
    177c:	97 fb       	bst	r25, 7
    177e:	99 1f       	adc	r25, r25
    1780:	61 f0       	breq	.+24     	; 0x179a <__fp_splitA+0x20>
    1782:	9f 3f       	cpi	r25, 0xFF	; 255
    1784:	79 f0       	breq	.+30     	; 0x17a4 <__fp_splitA+0x2a>
    1786:	87 95       	ror	r24
    1788:	08 95       	ret
    178a:	12 16       	cp	r1, r18
    178c:	13 06       	cpc	r1, r19
    178e:	14 06       	cpc	r1, r20
    1790:	55 1f       	adc	r21, r21
    1792:	f2 cf       	rjmp	.-28     	; 0x1778 <__fp_split3+0xe>
    1794:	46 95       	lsr	r20
    1796:	f1 df       	rcall	.-30     	; 0x177a <__fp_splitA>
    1798:	08 c0       	rjmp	.+16     	; 0x17aa <__fp_splitA+0x30>
    179a:	16 16       	cp	r1, r22
    179c:	17 06       	cpc	r1, r23
    179e:	18 06       	cpc	r1, r24
    17a0:	99 1f       	adc	r25, r25
    17a2:	f1 cf       	rjmp	.-30     	; 0x1786 <__fp_splitA+0xc>
    17a4:	86 95       	lsr	r24
    17a6:	71 05       	cpc	r23, r1
    17a8:	61 05       	cpc	r22, r1
    17aa:	08 94       	sec
    17ac:	08 95       	ret

000017ae <__fp_zero>:
    17ae:	e8 94       	clt

000017b0 <__fp_szero>:
    17b0:	bb 27       	eor	r27, r27
    17b2:	66 27       	eor	r22, r22
    17b4:	77 27       	eor	r23, r23
    17b6:	cb 01       	movw	r24, r22
    17b8:	97 f9       	bld	r25, 7
    17ba:	08 95       	ret

000017bc <__gesf2>:
    17bc:	0e 94 42 0b 	call	0x1684	; 0x1684 <__fp_cmp>
    17c0:	08 f4       	brcc	.+2      	; 0x17c4 <__gesf2+0x8>
    17c2:	8f ef       	ldi	r24, 0xFF	; 255
    17c4:	08 95       	ret

000017c6 <inverse>:
    17c6:	9b 01       	movw	r18, r22
    17c8:	ac 01       	movw	r20, r24
    17ca:	60 e0       	ldi	r22, 0x00	; 0
    17cc:	70 e0       	ldi	r23, 0x00	; 0
    17ce:	80 e8       	ldi	r24, 0x80	; 128
    17d0:	9f e3       	ldi	r25, 0x3F	; 63
    17d2:	0c 94 04 0a 	jmp	0x1408	; 0x1408 <__divsf3>
    17d6:	0c 94 66 0b 	jmp	0x16cc	; 0x16cc <__fp_inf>
    17da:	0c 94 ce 0c 	jmp	0x199c	; 0x199c <__fp_mpack>

000017de <ldexp>:
    17de:	0e 94 bd 0b 	call	0x177a	; 0x177a <__fp_splitA>
    17e2:	d8 f3       	brcs	.-10     	; 0x17da <inverse+0x14>
    17e4:	99 23       	and	r25, r25
    17e6:	c9 f3       	breq	.-14     	; 0x17da <inverse+0x14>
    17e8:	94 0f       	add	r25, r20
    17ea:	51 1d       	adc	r21, r1
    17ec:	a3 f3       	brvs	.-24     	; 0x17d6 <inverse+0x10>
    17ee:	91 50       	subi	r25, 0x01	; 1
    17f0:	50 40       	sbci	r21, 0x00	; 0
    17f2:	94 f0       	brlt	.+36     	; 0x1818 <ldexp+0x3a>
    17f4:	59 f0       	breq	.+22     	; 0x180c <ldexp+0x2e>
    17f6:	88 23       	and	r24, r24
    17f8:	32 f0       	brmi	.+12     	; 0x1806 <ldexp+0x28>
    17fa:	66 0f       	add	r22, r22
    17fc:	77 1f       	adc	r23, r23
    17fe:	88 1f       	adc	r24, r24
    1800:	91 50       	subi	r25, 0x01	; 1
    1802:	50 40       	sbci	r21, 0x00	; 0
    1804:	c1 f7       	brne	.-16     	; 0x17f6 <ldexp+0x18>
    1806:	9e 3f       	cpi	r25, 0xFE	; 254
    1808:	51 05       	cpc	r21, r1
    180a:	2c f7       	brge	.-54     	; 0x17d6 <inverse+0x10>
    180c:	88 0f       	add	r24, r24
    180e:	91 1d       	adc	r25, r1
    1810:	96 95       	lsr	r25
    1812:	87 95       	ror	r24
    1814:	97 f9       	bld	r25, 7
    1816:	08 95       	ret
    1818:	5f 3f       	cpi	r21, 0xFF	; 255
    181a:	ac f0       	brlt	.+42     	; 0x1846 <ldexp+0x68>
    181c:	98 3e       	cpi	r25, 0xE8	; 232
    181e:	9c f0       	brlt	.+38     	; 0x1846 <ldexp+0x68>
    1820:	bb 27       	eor	r27, r27
    1822:	86 95       	lsr	r24
    1824:	77 95       	ror	r23
    1826:	67 95       	ror	r22
    1828:	b7 95       	ror	r27
    182a:	08 f4       	brcc	.+2      	; 0x182e <ldexp+0x50>
    182c:	b1 60       	ori	r27, 0x01	; 1
    182e:	93 95       	inc	r25
    1830:	c1 f7       	brne	.-16     	; 0x1822 <ldexp+0x44>
    1832:	bb 0f       	add	r27, r27
    1834:	58 f7       	brcc	.-42     	; 0x180c <ldexp+0x2e>
    1836:	11 f4       	brne	.+4      	; 0x183c <ldexp+0x5e>
    1838:	60 ff       	sbrs	r22, 0
    183a:	e8 cf       	rjmp	.-48     	; 0x180c <ldexp+0x2e>
    183c:	6f 5f       	subi	r22, 0xFF	; 255
    183e:	7f 4f       	sbci	r23, 0xFF	; 255
    1840:	8f 4f       	sbci	r24, 0xFF	; 255
    1842:	9f 4f       	sbci	r25, 0xFF	; 255
    1844:	e3 cf       	rjmp	.-58     	; 0x180c <ldexp+0x2e>
    1846:	0c 94 d8 0b 	jmp	0x17b0	; 0x17b0 <__fp_szero>

0000184a <modf>:
    184a:	fa 01       	movw	r30, r20
    184c:	dc 01       	movw	r26, r24
    184e:	aa 0f       	add	r26, r26
    1850:	bb 1f       	adc	r27, r27
    1852:	9b 01       	movw	r18, r22
    1854:	ac 01       	movw	r20, r24
    1856:	bf 57       	subi	r27, 0x7F	; 127
    1858:	28 f4       	brcc	.+10     	; 0x1864 <modf+0x1a>
    185a:	22 27       	eor	r18, r18
    185c:	33 27       	eor	r19, r19
    185e:	44 27       	eor	r20, r20
    1860:	50 78       	andi	r21, 0x80	; 128
    1862:	20 c0       	rjmp	.+64     	; 0x18a4 <modf+0x5a>
    1864:	b7 51       	subi	r27, 0x17	; 23
    1866:	90 f4       	brcc	.+36     	; 0x188c <modf+0x42>
    1868:	ab 2f       	mov	r26, r27
    186a:	00 24       	eor	r0, r0
    186c:	46 95       	lsr	r20
    186e:	37 95       	ror	r19
    1870:	27 95       	ror	r18
    1872:	01 1c       	adc	r0, r1
    1874:	a3 95       	inc	r26
    1876:	d2 f3       	brmi	.-12     	; 0x186c <modf+0x22>
    1878:	00 20       	and	r0, r0
    187a:	71 f0       	breq	.+28     	; 0x1898 <modf+0x4e>
    187c:	22 0f       	add	r18, r18
    187e:	33 1f       	adc	r19, r19
    1880:	44 1f       	adc	r20, r20
    1882:	b3 95       	inc	r27
    1884:	da f3       	brmi	.-10     	; 0x187c <modf+0x32>
    1886:	0e d0       	rcall	.+28     	; 0x18a4 <modf+0x5a>
    1888:	0c 94 92 09 	jmp	0x1324	; 0x1324 <__subsf3>
    188c:	61 30       	cpi	r22, 0x01	; 1
    188e:	71 05       	cpc	r23, r1
    1890:	a0 e8       	ldi	r26, 0x80	; 128
    1892:	8a 07       	cpc	r24, r26
    1894:	b9 46       	sbci	r27, 0x69	; 105
    1896:	30 f4       	brcc	.+12     	; 0x18a4 <modf+0x5a>
    1898:	9b 01       	movw	r18, r22
    189a:	ac 01       	movw	r20, r24
    189c:	66 27       	eor	r22, r22
    189e:	77 27       	eor	r23, r23
    18a0:	88 27       	eor	r24, r24
    18a2:	90 78       	andi	r25, 0x80	; 128
    18a4:	30 96       	adiw	r30, 0x00	; 0
    18a6:	21 f0       	breq	.+8      	; 0x18b0 <modf+0x66>
    18a8:	20 83       	st	Z, r18
    18aa:	31 83       	std	Z+1, r19	; 0x01
    18ac:	42 83       	std	Z+2, r20	; 0x02
    18ae:	53 83       	std	Z+3, r21	; 0x03
    18b0:	08 95       	ret

000018b2 <__mulsf3>:
    18b2:	0e 94 6c 0c 	call	0x18d8	; 0x18d8 <__mulsf3x>
    18b6:	0c 94 a4 0b 	jmp	0x1748	; 0x1748 <__fp_round>
    18ba:	0e 94 96 0b 	call	0x172c	; 0x172c <__fp_pscA>
    18be:	38 f0       	brcs	.+14     	; 0x18ce <__mulsf3+0x1c>
    18c0:	0e 94 9d 0b 	call	0x173a	; 0x173a <__fp_pscB>
    18c4:	20 f0       	brcs	.+8      	; 0x18ce <__mulsf3+0x1c>
    18c6:	95 23       	and	r25, r21
    18c8:	11 f0       	breq	.+4      	; 0x18ce <__mulsf3+0x1c>
    18ca:	0c 94 66 0b 	jmp	0x16cc	; 0x16cc <__fp_inf>
    18ce:	0c 94 6c 0b 	jmp	0x16d8	; 0x16d8 <__fp_nan>
    18d2:	11 24       	eor	r1, r1
    18d4:	0c 94 d8 0b 	jmp	0x17b0	; 0x17b0 <__fp_szero>

000018d8 <__mulsf3x>:
    18d8:	0e 94 b5 0b 	call	0x176a	; 0x176a <__fp_split3>
    18dc:	70 f3       	brcs	.-36     	; 0x18ba <__mulsf3+0x8>

000018de <__mulsf3_pse>:
    18de:	95 9f       	mul	r25, r21
    18e0:	c1 f3       	breq	.-16     	; 0x18d2 <__mulsf3+0x20>
    18e2:	95 0f       	add	r25, r21
    18e4:	50 e0       	ldi	r21, 0x00	; 0
    18e6:	55 1f       	adc	r21, r21
    18e8:	62 9f       	mul	r22, r18
    18ea:	f0 01       	movw	r30, r0
    18ec:	72 9f       	mul	r23, r18
    18ee:	bb 27       	eor	r27, r27
    18f0:	f0 0d       	add	r31, r0
    18f2:	b1 1d       	adc	r27, r1
    18f4:	63 9f       	mul	r22, r19
    18f6:	aa 27       	eor	r26, r26
    18f8:	f0 0d       	add	r31, r0
    18fa:	b1 1d       	adc	r27, r1
    18fc:	aa 1f       	adc	r26, r26
    18fe:	64 9f       	mul	r22, r20
    1900:	66 27       	eor	r22, r22
    1902:	b0 0d       	add	r27, r0
    1904:	a1 1d       	adc	r26, r1
    1906:	66 1f       	adc	r22, r22
    1908:	82 9f       	mul	r24, r18
    190a:	22 27       	eor	r18, r18
    190c:	b0 0d       	add	r27, r0
    190e:	a1 1d       	adc	r26, r1
    1910:	62 1f       	adc	r22, r18
    1912:	73 9f       	mul	r23, r19
    1914:	b0 0d       	add	r27, r0
    1916:	a1 1d       	adc	r26, r1
    1918:	62 1f       	adc	r22, r18
    191a:	83 9f       	mul	r24, r19
    191c:	a0 0d       	add	r26, r0
    191e:	61 1d       	adc	r22, r1
    1920:	22 1f       	adc	r18, r18
    1922:	74 9f       	mul	r23, r20
    1924:	33 27       	eor	r19, r19
    1926:	a0 0d       	add	r26, r0
    1928:	61 1d       	adc	r22, r1
    192a:	23 1f       	adc	r18, r19
    192c:	84 9f       	mul	r24, r20
    192e:	60 0d       	add	r22, r0
    1930:	21 1d       	adc	r18, r1
    1932:	82 2f       	mov	r24, r18
    1934:	76 2f       	mov	r23, r22
    1936:	6a 2f       	mov	r22, r26
    1938:	11 24       	eor	r1, r1
    193a:	9f 57       	subi	r25, 0x7F	; 127
    193c:	50 40       	sbci	r21, 0x00	; 0
    193e:	9a f0       	brmi	.+38     	; 0x1966 <__mulsf3_pse+0x88>
    1940:	f1 f0       	breq	.+60     	; 0x197e <__mulsf3_pse+0xa0>
    1942:	88 23       	and	r24, r24
    1944:	4a f0       	brmi	.+18     	; 0x1958 <__mulsf3_pse+0x7a>
    1946:	ee 0f       	add	r30, r30
    1948:	ff 1f       	adc	r31, r31
    194a:	bb 1f       	adc	r27, r27
    194c:	66 1f       	adc	r22, r22
    194e:	77 1f       	adc	r23, r23
    1950:	88 1f       	adc	r24, r24
    1952:	91 50       	subi	r25, 0x01	; 1
    1954:	50 40       	sbci	r21, 0x00	; 0
    1956:	a9 f7       	brne	.-22     	; 0x1942 <__mulsf3_pse+0x64>
    1958:	9e 3f       	cpi	r25, 0xFE	; 254
    195a:	51 05       	cpc	r21, r1
    195c:	80 f0       	brcs	.+32     	; 0x197e <__mulsf3_pse+0xa0>
    195e:	0c 94 66 0b 	jmp	0x16cc	; 0x16cc <__fp_inf>
    1962:	0c 94 d8 0b 	jmp	0x17b0	; 0x17b0 <__fp_szero>
    1966:	5f 3f       	cpi	r21, 0xFF	; 255
    1968:	e4 f3       	brlt	.-8      	; 0x1962 <__mulsf3_pse+0x84>
    196a:	98 3e       	cpi	r25, 0xE8	; 232
    196c:	d4 f3       	brlt	.-12     	; 0x1962 <__mulsf3_pse+0x84>
    196e:	86 95       	lsr	r24
    1970:	77 95       	ror	r23
    1972:	67 95       	ror	r22
    1974:	b7 95       	ror	r27
    1976:	f7 95       	ror	r31
    1978:	e7 95       	ror	r30
    197a:	9f 5f       	subi	r25, 0xFF	; 255
    197c:	c1 f7       	brne	.-16     	; 0x196e <__mulsf3_pse+0x90>
    197e:	fe 2b       	or	r31, r30
    1980:	88 0f       	add	r24, r24
    1982:	91 1d       	adc	r25, r1
    1984:	96 95       	lsr	r25
    1986:	87 95       	ror	r24
    1988:	97 f9       	bld	r25, 7
    198a:	08 95       	ret

0000198c <sin>:
    198c:	9f 93       	push	r25
    198e:	0e 94 de 0c 	call	0x19bc	; 0x19bc <__fp_rempio2>
    1992:	0f 90       	pop	r0
    1994:	07 fc       	sbrc	r0, 7
    1996:	ee 5f       	subi	r30, 0xFE	; 254
    1998:	0c 94 07 0d 	jmp	0x1a0e	; 0x1a0e <__fp_sinus>

0000199c <__fp_mpack>:
    199c:	9f 3f       	cpi	r25, 0xFF	; 255
    199e:	31 f0       	breq	.+12     	; 0x19ac <__fp_mpack_finite+0xc>

000019a0 <__fp_mpack_finite>:
    19a0:	91 50       	subi	r25, 0x01	; 1
    19a2:	20 f4       	brcc	.+8      	; 0x19ac <__fp_mpack_finite+0xc>
    19a4:	87 95       	ror	r24
    19a6:	77 95       	ror	r23
    19a8:	67 95       	ror	r22
    19aa:	b7 95       	ror	r27
    19ac:	88 0f       	add	r24, r24
    19ae:	91 1d       	adc	r25, r1
    19b0:	96 95       	lsr	r25
    19b2:	87 95       	ror	r24
    19b4:	97 f9       	bld	r25, 7
    19b6:	08 95       	ret
    19b8:	0c 94 6c 0b 	jmp	0x16d8	; 0x16d8 <__fp_nan>

000019bc <__fp_rempio2>:
    19bc:	0e 94 bd 0b 	call	0x177a	; 0x177a <__fp_splitA>
    19c0:	d8 f3       	brcs	.-10     	; 0x19b8 <__fp_mpack_finite+0x18>
    19c2:	e8 94       	clt
    19c4:	e0 e0       	ldi	r30, 0x00	; 0
    19c6:	bb 27       	eor	r27, r27
    19c8:	9f 57       	subi	r25, 0x7F	; 127
    19ca:	f0 f0       	brcs	.+60     	; 0x1a08 <__fp_rempio2+0x4c>
    19cc:	2a ed       	ldi	r18, 0xDA	; 218
    19ce:	3f e0       	ldi	r19, 0x0F	; 15
    19d0:	49 ec       	ldi	r20, 0xC9	; 201
    19d2:	06 c0       	rjmp	.+12     	; 0x19e0 <__fp_rempio2+0x24>
    19d4:	ee 0f       	add	r30, r30
    19d6:	bb 0f       	add	r27, r27
    19d8:	66 1f       	adc	r22, r22
    19da:	77 1f       	adc	r23, r23
    19dc:	88 1f       	adc	r24, r24
    19de:	28 f0       	brcs	.+10     	; 0x19ea <__fp_rempio2+0x2e>
    19e0:	b2 3a       	cpi	r27, 0xA2	; 162
    19e2:	62 07       	cpc	r22, r18
    19e4:	73 07       	cpc	r23, r19
    19e6:	84 07       	cpc	r24, r20
    19e8:	28 f0       	brcs	.+10     	; 0x19f4 <__fp_rempio2+0x38>
    19ea:	b2 5a       	subi	r27, 0xA2	; 162
    19ec:	62 0b       	sbc	r22, r18
    19ee:	73 0b       	sbc	r23, r19
    19f0:	84 0b       	sbc	r24, r20
    19f2:	e3 95       	inc	r30
    19f4:	9a 95       	dec	r25
    19f6:	72 f7       	brpl	.-36     	; 0x19d4 <__fp_rempio2+0x18>
    19f8:	80 38       	cpi	r24, 0x80	; 128
    19fa:	30 f4       	brcc	.+12     	; 0x1a08 <__fp_rempio2+0x4c>
    19fc:	9a 95       	dec	r25
    19fe:	bb 0f       	add	r27, r27
    1a00:	66 1f       	adc	r22, r22
    1a02:	77 1f       	adc	r23, r23
    1a04:	88 1f       	adc	r24, r24
    1a06:	d2 f7       	brpl	.-12     	; 0x19fc <__fp_rempio2+0x40>
    1a08:	90 48       	sbci	r25, 0x80	; 128
    1a0a:	0c 94 d0 0c 	jmp	0x19a0	; 0x19a0 <__fp_mpack_finite>

00001a0e <__fp_sinus>:
    1a0e:	ef 93       	push	r30
    1a10:	e0 ff       	sbrs	r30, 0
    1a12:	07 c0       	rjmp	.+14     	; 0x1a22 <__fp_sinus+0x14>
    1a14:	a2 ea       	ldi	r26, 0xA2	; 162
    1a16:	2a ed       	ldi	r18, 0xDA	; 218
    1a18:	3f e0       	ldi	r19, 0x0F	; 15
    1a1a:	49 ec       	ldi	r20, 0xC9	; 201
    1a1c:	5f eb       	ldi	r21, 0xBF	; 191
    1a1e:	0e 94 aa 09 	call	0x1354	; 0x1354 <__addsf3x>
    1a22:	0e 94 a4 0b 	call	0x1748	; 0x1748 <__fp_round>
    1a26:	0f 90       	pop	r0
    1a28:	03 94       	inc	r0
    1a2a:	01 fc       	sbrc	r0, 1
    1a2c:	90 58       	subi	r25, 0x80	; 128
    1a2e:	e4 ea       	ldi	r30, 0xA4	; 164
    1a30:	f0 e0       	ldi	r31, 0x00	; 0
    1a32:	0c 94 1b 0d 	jmp	0x1a36	; 0x1a36 <__fp_powsodd>

00001a36 <__fp_powsodd>:
    1a36:	9f 93       	push	r25
    1a38:	8f 93       	push	r24
    1a3a:	7f 93       	push	r23
    1a3c:	6f 93       	push	r22
    1a3e:	ff 93       	push	r31
    1a40:	ef 93       	push	r30
    1a42:	9b 01       	movw	r18, r22
    1a44:	ac 01       	movw	r20, r24
    1a46:	0e 94 59 0c 	call	0x18b2	; 0x18b2 <__mulsf3>
    1a4a:	ef 91       	pop	r30
    1a4c:	ff 91       	pop	r31
    1a4e:	0e 94 6f 0b 	call	0x16de	; 0x16de <__fp_powser>
    1a52:	2f 91       	pop	r18
    1a54:	3f 91       	pop	r19
    1a56:	4f 91       	pop	r20
    1a58:	5f 91       	pop	r21
    1a5a:	0c 94 59 0c 	jmp	0x18b2	; 0x18b2 <__mulsf3>

00001a5e <__udivmodsi4>:
    1a5e:	a1 e2       	ldi	r26, 0x21	; 33
    1a60:	1a 2e       	mov	r1, r26
    1a62:	aa 1b       	sub	r26, r26
    1a64:	bb 1b       	sub	r27, r27
    1a66:	fd 01       	movw	r30, r26
    1a68:	0d c0       	rjmp	.+26     	; 0x1a84 <__udivmodsi4_ep>

00001a6a <__udivmodsi4_loop>:
    1a6a:	aa 1f       	adc	r26, r26
    1a6c:	bb 1f       	adc	r27, r27
    1a6e:	ee 1f       	adc	r30, r30
    1a70:	ff 1f       	adc	r31, r31
    1a72:	a2 17       	cp	r26, r18
    1a74:	b3 07       	cpc	r27, r19
    1a76:	e4 07       	cpc	r30, r20
    1a78:	f5 07       	cpc	r31, r21
    1a7a:	20 f0       	brcs	.+8      	; 0x1a84 <__udivmodsi4_ep>
    1a7c:	a2 1b       	sub	r26, r18
    1a7e:	b3 0b       	sbc	r27, r19
    1a80:	e4 0b       	sbc	r30, r20
    1a82:	f5 0b       	sbc	r31, r21

00001a84 <__udivmodsi4_ep>:
    1a84:	66 1f       	adc	r22, r22
    1a86:	77 1f       	adc	r23, r23
    1a88:	88 1f       	adc	r24, r24
    1a8a:	99 1f       	adc	r25, r25
    1a8c:	1a 94       	dec	r1
    1a8e:	69 f7       	brne	.-38     	; 0x1a6a <__udivmodsi4_loop>
    1a90:	60 95       	com	r22
    1a92:	70 95       	com	r23
    1a94:	80 95       	com	r24
    1a96:	90 95       	com	r25
    1a98:	9b 01       	movw	r18, r22
    1a9a:	ac 01       	movw	r20, r24
    1a9c:	bd 01       	movw	r22, r26
    1a9e:	cf 01       	movw	r24, r30
    1aa0:	08 95       	ret

00001aa2 <_exit>:
    1aa2:	f8 94       	cli

00001aa4 <__stop_program>:
    1aa4:	ff cf       	rjmp	.-2      	; 0x1aa4 <__stop_program>
