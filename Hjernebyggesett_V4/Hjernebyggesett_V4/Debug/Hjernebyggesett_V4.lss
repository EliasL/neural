
Hjernebyggesett_V4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000016  00803800  00001b9e  00001c52  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001b6c  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000032  00009b6c  00001b6c  00001c20  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .bss          0000005c  00803816  00803816  00001c68  2**0
                  ALLOC
  4 .comment      00000030  00000000  00000000  00001c68  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001c98  2**2
                  CONTENTS, READONLY
  6 .debug_aranges 00000578  00000000  00000000  00001cd8  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00008d78  00000000  00000000  00002250  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00003731  00000000  00000000  0000afc8  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00002d5e  00000000  00000000  0000e6f9  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  0000099c  00000000  00000000  00011458  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000373e  00000000  00000000  00011df4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000016f0  00000000  00000000  00015532  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 000003f8  00000000  00000000  00016c22  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 61 00 	jmp	0xc2	; 0xc2 <__ctors_end>
       4:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
       8:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
       c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      10:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      14:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      18:	0c 94 7c 05 	jmp	0xaf8	; 0xaf8 <__vector_6>
      1c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      20:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      24:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      28:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      2c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      30:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      34:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      38:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      3c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      40:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      44:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      48:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      4c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      50:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      54:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      58:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      5c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      60:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      64:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      68:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      6c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      70:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      74:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      78:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      7c:	07 63       	ori	r16, 0x37	; 55
      7e:	42 36       	cpi	r20, 0x62	; 98
      80:	b7 9b       	sbis	0x16, 7	; 22
      82:	d8 a7       	std	Y+40, r29	; 0x28
      84:	1a 39       	cpi	r17, 0x9A	; 154
      86:	68 56       	subi	r22, 0x68	; 104
      88:	18 ae       	std	Y+56, r1	; 0x38
      8a:	ba ab       	std	Y+50, r27	; 0x32
      8c:	55 8c       	ldd	r5, Z+29	; 0x1d
      8e:	1d 3c       	cpi	r17, 0xCD	; 205
      90:	b7 cc       	rjmp	.-1682   	; 0xfffffa00 <__eeprom_end+0xff7efa00>
      92:	57 63       	ori	r21, 0x37	; 55
      94:	bd 6d       	ori	r27, 0xDD	; 221
      96:	ed fd       	.word	0xfded	; ????
      98:	75 3e       	cpi	r23, 0xE5	; 229
      9a:	f6 17       	cp	r31, r22
      9c:	72 31       	cpi	r23, 0x12	; 18
      9e:	bf 00       	.word	0x00bf	; ????
      a0:	00 00       	nop
      a2:	80 3f       	cpi	r24, 0xF0	; 240
      a4:	05 a8       	ldd	r0, Z+53	; 0x35
      a6:	4c cd       	rjmp	.-1384   	; 0xfffffb40 <__eeprom_end+0xff7efb40>
      a8:	b2 d4       	rcall	.+2404   	; 0xa0e <tinyDendrite_update_signals+0xd0>
      aa:	4e b9       	out	0x0e, r20	; 14
      ac:	38 36       	cpi	r19, 0x68	; 104
      ae:	a9 02       	muls	r26, r25
      b0:	0c 50       	subi	r16, 0x0C	; 12
      b2:	b9 91       	ld	r27, Y+
      b4:	86 88       	ldd	r8, Z+22	; 0x16
      b6:	08 3c       	cpi	r16, 0xC8	; 200
      b8:	a6 aa       	std	Z+54, r10	; 0x36
      ba:	aa 2a       	or	r10, r26
      bc:	be 00       	.word	0x00be	; ????
      be:	00 00       	nop
      c0:	80 3f       	cpi	r24, 0xF0	; 240

000000c2 <__ctors_end>:
      c2:	11 24       	eor	r1, r1
      c4:	1f be       	out	0x3f, r1	; 63
      c6:	cf ef       	ldi	r28, 0xFF	; 255
      c8:	cd bf       	out	0x3d, r28	; 61
      ca:	df e3       	ldi	r29, 0x3F	; 63
      cc:	de bf       	out	0x3e, r29	; 62

000000ce <__do_copy_data>:
      ce:	18 e3       	ldi	r17, 0x38	; 56
      d0:	a0 e0       	ldi	r26, 0x00	; 0
      d2:	b8 e3       	ldi	r27, 0x38	; 56
      d4:	ee e9       	ldi	r30, 0x9E	; 158
      d6:	fb e1       	ldi	r31, 0x1B	; 27
      d8:	02 c0       	rjmp	.+4      	; 0xde <__do_copy_data+0x10>
      da:	05 90       	lpm	r0, Z+
      dc:	0d 92       	st	X+, r0
      de:	a6 31       	cpi	r26, 0x16	; 22
      e0:	b1 07       	cpc	r27, r17
      e2:	d9 f7       	brne	.-10     	; 0xda <__do_copy_data+0xc>

000000e4 <__do_clear_bss>:
      e4:	28 e3       	ldi	r18, 0x38	; 56
      e6:	a6 e1       	ldi	r26, 0x16	; 22
      e8:	b8 e3       	ldi	r27, 0x38	; 56
      ea:	01 c0       	rjmp	.+2      	; 0xee <.do_clear_bss_start>

000000ec <.do_clear_bss_loop>:
      ec:	1d 92       	st	X+, r1

000000ee <.do_clear_bss_start>:
      ee:	a2 37       	cpi	r26, 0x72	; 114
      f0:	b2 07       	cpc	r27, r18
      f2:	e1 f7       	brne	.-8      	; 0xec <.do_clear_bss_loop>
      f4:	0e 94 83 00 	call	0x106	; 0x106 <main>
      f8:	0c 94 b4 0d 	jmp	0x1b68	; 0x1b68 <_exit>

000000fc <__bad_interrupt>:
      fc:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000100 <atmel_start_init>:
/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
	system_init();
     100:	0e 94 b2 01 	call	0x364	; 0x364 <system_init>
     104:	08 95       	ret

00000106 <main>:

int main(void)
{	
	
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
     106:	0e 94 80 00 	call	0x100	; 0x100 <atmel_start_init>
	Setting this value will mean that the ADC (Analog to Digital Converter) will read 4.32v as 255, and 0v as 0.
	For some reason, instead of the reference voltage being 4.32v, it is 3.3v. 
	A plausible explanation is that the microchip does not up the voltage, so that if the microchip is only ever 
	supplied with 3.3v, it will output 3.3v as the max.
	*/
	VREF.CTRLA |= VREF_DAC0REFSEL_4V34_gc;
     10a:	e0 ea       	ldi	r30, 0xA0	; 160
     10c:	f0 e0       	ldi	r31, 0x00	; 0
     10e:	80 81       	ld	r24, Z
     110:	83 60       	ori	r24, 0x03	; 3
     112:	80 83       	st	Z, r24
	
	//tinyTester_test();
	
	tinySleep_prepare_sleep();
     114:	0e 94 c6 09 	call	0x138c	; 0x138c <tinySleep_prepare_sleep>
	
	tinySleep_enter_sleep();
     118:	0e 94 cf 09 	call	0x139e	; 0x139e <tinySleep_enter_sleep>
	
	while (1)
	{
		// We don't want to update the neuron too often because of various reasons. The tinyISR_getflag is set every ms, and so the loop is only run once every ms.  
		if(tinyISR_getflag())
     11c:	0e 94 aa 05 	call	0xb54	; 0xb54 <tinyISR_getflag>
     120:	88 23       	and	r24, r24
     122:	e1 f3       	breq	.-8      	; 0x11c <main+0x16>
		{
			//Testing sleep mode
			//tinySleep_enter_sleep();
			tinyCharge_update_charging_mode();
     124:	0e 94 1a 04 	call	0x834	; 0x834 <tinyCharge_update_charging_mode>
			
			if(tinyCharge_is_connected_to_charger()){
     128:	0e 94 df 03 	call	0x7be	; 0x7be <tinyCharge_is_connected_to_charger>
     12c:	88 23       	and	r24, r24
     12e:	b9 f0       	breq	.+46     	; 0x15e <main+0x58>
				// Charge loop
				
				if(tinyCharge_is_fully_charged()){
     130:	0e 94 e2 03 	call	0x7c4	; 0x7c4 <tinyCharge_is_fully_charged>
     134:	88 23       	and	r24, r24
     136:	49 f0       	breq	.+18     	; 0x14a <main+0x44>
					// When the neuron is connected to a charger, and fully charged:
					tinyLED_set_color(INN_LED, CHARGING_DONE_COLOR);
     138:	64 e0       	ldi	r22, 0x04	; 4
     13a:	80 e0       	ldi	r24, 0x00	; 0
     13c:	0e 94 0e 06 	call	0xc1c	; 0xc1c <tinyLED_set_color>
					tinyLED_set_color(OUT_LED, LED_OFF);
     140:	60 e0       	ldi	r22, 0x00	; 0
     142:	81 e0       	ldi	r24, 0x01	; 1
     144:	0e 94 0e 06 	call	0xc1c	; 0xc1c <tinyLED_set_color>
     148:	1a c0       	rjmp	.+52     	; 0x17e <main+0x78>
				}
				else{
					// When the neuron is charging and is not fully charged
					tinyLED_set_color_mode(OUT_LED, CHARGING_COLOR, SWING);
     14a:	43 e0       	ldi	r20, 0x03	; 3
     14c:	62 e0       	ldi	r22, 0x02	; 2
     14e:	81 e0       	ldi	r24, 0x01	; 1
     150:	0e 94 c9 05 	call	0xb92	; 0xb92 <tinyLED_set_color_mode>
					tinyLED_set_color(INN_LED, LED_OFF);
     154:	60 e0       	ldi	r22, 0x00	; 0
     156:	80 e0       	ldi	r24, 0x00	; 0
     158:	0e 94 0e 06 	call	0xc1c	; 0xc1c <tinyLED_set_color>
     15c:	10 c0       	rjmp	.+32     	; 0x17e <main+0x78>
				// Main loop			
				
				// Set LED
				// If the out led is turned LED_OFF, and the ping color is not disabled,
				// we turn on ping mode
				if(tinyLED_get_color(OUT_LED) == LED_OFF && PING_COLOR != LED_OFF){
     15e:	81 e0       	ldi	r24, 0x01	; 1
     160:	0e 94 c1 05 	call	0xb82	; 0xb82 <tinyLED_get_color>
					tinyLED_set_color_mode(OUT_LED, PING_COLOR, PING);
				}
				if(tinyLED_get_color(INN_LED) == LED_OFF){
     164:	80 e0       	ldi	r24, 0x00	; 0
     166:	0e 94 c1 05 	call	0xb82	; 0xb82 <tinyLED_get_color>
     16a:	81 11       	cpse	r24, r1
     16c:	04 c0       	rjmp	.+8      	; 0x176 <main+0x70>
					// Display potential level with LED
					tinyLED_set_color_mode(INN_LED, CHANGING_COLOR, POTENTIAL);
     16e:	46 e0       	ldi	r20, 0x06	; 6
     170:	61 e0       	ldi	r22, 0x01	; 1
     172:	0e 94 c9 05 	call	0xb92	; 0xb92 <tinyLED_set_color_mode>
				}
				
				// Update button	
				tinyButton_update();
     176:	0e 94 79 03 	call	0x6f2	; 0x6f2 <tinyButton_update>
				
				// Update the potential (This is where most of the important stuff happens)
				tinyPotential_update();
     17a:	0e 94 eb 08 	call	0x11d6	; 0x11d6 <tinyPotential_update>
			}
			
			// Update LED
			tinyLED_update();
     17e:	0e 94 42 06 	call	0xc84	; 0xc84 <tinyLED_update>
				
			// Switch transistors
			tinyCharge_set_transistors();
     182:	0e 94 54 04 	call	0x8a8	; 0x8a8 <tinyCharge_set_transistors>
			
			// Prepare for next cycle
			tinyISR_setflag(false);
     186:	80 e0       	ldi	r24, 0x00	; 0
     188:	0e 94 a7 05 	call	0xb4e	; 0xb4e <tinyISR_setflag>
			tinyDebugger_send_uint32("time", tinyTime_now());
     18c:	0e 94 ec 09 	call	0x13d8	; 0x13d8 <tinyTime_now>
     190:	ab 01       	movw	r20, r22
     192:	bc 01       	movw	r22, r24
     194:	8c e6       	ldi	r24, 0x6C	; 108
     196:	9b e9       	ldi	r25, 0x9B	; 155
     198:	0e 94 5f 04 	call	0x8be	; 0x8be <tinyDebugger_send_uint32>
			tinyDebugger_end_line();
     19c:	0e 94 62 04 	call	0x8c4	; 0x8c4 <tinyDebugger_end_line>
     1a0:	bd cf       	rjmp	.-134    	; 0x11c <main+0x16>

000001a2 <ADC_0_init>:
 * \return Conversion result read from the ADC_0 ADC module
 */
adc_result_t ADC_0_get_conversion_result(void)
{
	return (ADC1.RES);
}
     1a2:	e0 e4       	ldi	r30, 0x40	; 64
     1a4:	f6 e0       	ldi	r31, 0x06	; 6
     1a6:	80 e1       	ldi	r24, 0x10	; 16
     1a8:	82 83       	std	Z+2, r24	; 0x02
     1aa:	85 e0       	ldi	r24, 0x05	; 5
     1ac:	80 83       	st	Z, r24
     1ae:	80 e0       	ldi	r24, 0x00	; 0
     1b0:	08 95       	ret

000001b2 <ADC_0_is_conversion_done>:
     1b2:	80 91 4b 06 	lds	r24, 0x064B	; 0x80064b <__TEXT_REGION_LENGTH__+0x70064b>
     1b6:	81 70       	andi	r24, 0x01	; 1
     1b8:	08 95       	ret

000001ba <ADC_0_get_conversion>:
 *
 * \return Nothing
 */
void ADC_0_start_conversion(adc_1_channel_t channel)
{
	ADC1.MUXPOS  = channel;
     1ba:	e0 e4       	ldi	r30, 0x40	; 64
     1bc:	f6 e0       	ldi	r31, 0x06	; 6
     1be:	86 83       	std	Z+6, r24	; 0x06
	ADC1.COMMAND = ADC_STCONV_bm;
     1c0:	81 e0       	ldi	r24, 0x01	; 1
     1c2:	80 87       	std	Z+8, r24	; 0x08
adc_result_t ADC_0_get_conversion(adc_1_channel_t channel)
{
	adc_result_t res;

	ADC_0_start_conversion(channel);
	while (!ADC_0_is_conversion_done())
     1c4:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <ADC_0_is_conversion_done>
     1c8:	88 23       	and	r24, r24
     1ca:	e1 f3       	breq	.-8      	; 0x1c4 <ADC_0_get_conversion+0xa>
 *
 * \return Conversion result read from the ADC_0 ADC module
 */
adc_result_t ADC_0_get_conversion_result(void)
{
	return (ADC1.RES);
     1cc:	e0 e4       	ldi	r30, 0x40	; 64
     1ce:	f6 e0       	ldi	r31, 0x06	; 6
     1d0:	20 89       	ldd	r18, Z+16	; 0x10
     1d2:	31 89       	ldd	r19, Z+17	; 0x11

	ADC_0_start_conversion(channel);
	while (!ADC_0_is_conversion_done())
		;
	res = ADC_0_get_conversion_result();
	ADC1.INTFLAGS |= ADC_RESRDY_bm;
     1d4:	93 85       	ldd	r25, Z+11	; 0x0b
     1d6:	91 60       	ori	r25, 0x01	; 1
     1d8:	93 87       	std	Z+11, r25	; 0x0b
	return res;
}
     1da:	c9 01       	movw	r24, r18
     1dc:	08 95       	ret

000001de <BOD_init>:
	//		 | BOD_VLMCFG_BELOW_gc; /* Interrupt when supply goes below VLM level */

	// BOD.VLMCTRLA = BOD_VLMLVL_5ABOVE_gc; /* VLM threshold 5% above BOD level */

	return 0;
}
     1de:	80 e0       	ldi	r24, 0x00	; 0
     1e0:	08 95       	ret

000001e2 <DIGITAL_GLUE_LOGIC_0_init>:

	// Enable Protected register, peripheral must be disabled (ENABLE=0, in TCD.LUT0CTRLA).

	// CCL.SEQCTRL0 = CCL_SEQSEL_DISABLE_gc /* Sequential logic disabled */;

	CCL.TRUTH0 = 168; /* Truth 0: 168 */
     1e2:	e0 ec       	ldi	r30, 0xC0	; 192
     1e4:	f1 e0       	ldi	r31, 0x01	; 1
     1e6:	28 ea       	ldi	r18, 0xA8	; 168
     1e8:	20 87       	std	Z+8, r18	; 0x08

	CCL.LUT0CTRLC = CCL_INSEL2_TCA0_gc /* TCA0 WO2 input source */;
     1ea:	98 e0       	ldi	r25, 0x08	; 8
     1ec:	97 83       	std	Z+7, r25	; 0x07

	CCL.LUT0CTRLB = CCL_INSEL0_SPI0_gc /* SPI0 SCK source */
     1ee:	8b eb       	ldi	r24, 0xBB	; 187
     1f0:	86 83       	std	Z+6, r24	; 0x06
	                | CCL_INSEL1_SPI0_gc /* SPI0 MOSI input source */;

	CCL.LUT0CTRLA = 0 << CCL_CLKSRC_bp       /* Clock Source Selection: disabled */
     1f2:	39 e0       	ldi	r19, 0x09	; 9
     1f4:	35 83       	std	Z+5, r19	; 0x05
	                | CCL_EDGEDET_DIS_gc     /* Edge detector is disabled */
	                | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	                | 1 << CCL_ENABLE_bp     /* LUT Enable: enabled */
	                | 1 << CCL_OUTEN_bp;     /* Output Enable: enabled */

	CCL.TRUTH1 = 168; /* Truth 1: 168 */
     1f6:	24 87       	std	Z+12, r18	; 0x0c

	CCL.LUT1CTRLC = CCL_INSEL2_TCA0_gc /* TCA0 WO2 input source */;
     1f8:	93 87       	std	Z+11, r25	; 0x0b

	CCL.LUT1CTRLB = CCL_INSEL0_SPI0_gc /* SPI0 SCK source */
     1fa:	82 87       	std	Z+10, r24	; 0x0a
	//		 | CCL_EDGEDET_DIS_gc /* Edge detector is disabled */
	//		 | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	//		 | 0 << CCL_ENABLE_bp /* LUT Enable: disabled */
	//		 | 0 << CCL_OUTEN_bp; /* Output Enable: disabled */

	CCL.CTRLA = 1 << CCL_ENABLE_bp      /* Enable: enabled */
     1fc:	81 e4       	ldi	r24, 0x41	; 65
     1fe:	80 83       	st	Z, r24
	            | 1 << CCL_RUNSTDBY_bp; /* Run in Standby: enabled */

	return 0;
}
     200:	80 e0       	ldi	r24, 0x00	; 0
     202:	08 95       	ret

00000204 <CLKCTRL_init>:
 *       on calling convention. The memory model is not visible to the
 *       preprocessor, so it must be defined in the Assembler preprocessor directives.
 */
static inline void ccp_write_io(void *addr, uint8_t value)
{
	protected_write_io(addr, CCP_IOREG_gc, value);
     204:	47 e0       	ldi	r20, 0x07	; 7
     206:	68 ed       	ldi	r22, 0xD8	; 216
     208:	8c e7       	ldi	r24, 0x7C	; 124
     20a:	90 e0       	ldi	r25, 0x00	; 0
     20c:	0e 94 e1 01 	call	0x3c2	; 0x3c2 <protected_write_io>
     210:	41 e0       	ldi	r20, 0x01	; 1
     212:	68 ed       	ldi	r22, 0xD8	; 216
     214:	81 e6       	ldi	r24, 0x61	; 97
     216:	90 e0       	ldi	r25, 0x00	; 0
     218:	0e 94 e1 01 	call	0x3c2	; 0x3c2 <protected_write_io>
	//		 | 0 << CLKCTRL_CLKOUT_bp /* System clock out: disabled */);

	// ccp_write_io((void*)&(CLKCTRL.MCLKLOCK),0 << CLKCTRL_LOCKEN_bp /* lock enable: disabled */);

	return 0;
}
     21c:	80 e0       	ldi	r24, 0x00	; 0
     21e:	08 95       	ret

00000220 <CPUINT_init>:

	// CPUINT.LVL0PRI = 0x0 << CPUINT_LVL0PRI_gp; /* Interrupt Level Priority: 0x0 */

	// CPUINT.LVL1VEC = 0x0 << CPUINT_LVL1VEC_gp; /* Interrupt Vector with High Priority: 0x0 */

	ENABLE_INTERRUPTS();
     220:	78 94       	sei

	return 0;
}
     222:	80 e0       	ldi	r24, 0x00	; 0
     224:	08 95       	ret

00000226 <DAC_0_init>:
int8_t DAC_0_init()
{

	// DAC0.DATA = 0x0; /* DATA Register: 0x0 */

	DAC0.CTRLA = 1 << DAC_ENABLE_bp      /* DAC Enable: enabled */
     226:	81 e4       	ldi	r24, 0x41	; 65
     228:	80 93 a0 06 	sts	0x06A0, r24	; 0x8006a0 <__TEXT_REGION_LENGTH__+0x7006a0>
	             | 1 << DAC_OUTEN_bp     /* Output Buffer Enable: enabled */
	             | 0 << DAC_RUNSTDBY_bp; /* Run in Standby Mode: disabled */

	return 0;
}
     22c:	80 e0       	ldi	r24, 0x00	; 0
     22e:	08 95       	ret

00000230 <DAC_0_uninit>:
int8_t DAC_0_uninit()
{

	// DAC0.DATA = 0x0; /* DATA Register: 0x0 */

	DAC0.CTRLA = 1 << DAC_ENABLE_bp      /* DAC Enable: enabled */
     230:	81 e0       	ldi	r24, 0x01	; 1
     232:	80 93 a0 06 	sts	0x06A0, r24	; 0x8006a0 <__TEXT_REGION_LENGTH__+0x7006a0>
	| 0 << DAC_OUTEN_bp     /* Output Buffer Enable: disabled */
	| 0 << DAC_RUNSTDBY_bp; /* Run in Standby Mode: disabled */

	return 0;
}
     236:	80 e0       	ldi	r24, 0x00	; 0
     238:	08 95       	ret

0000023a <DAC_0_enable>:
 *
 * \return Nothing
 */
void DAC_0_enable()
{
	DAC0.CTRLA |= DAC_ENABLE_bm;
     23a:	e0 ea       	ldi	r30, 0xA0	; 160
     23c:	f6 e0       	ldi	r31, 0x06	; 6
     23e:	80 81       	ld	r24, Z
     240:	81 60       	ori	r24, 0x01	; 1
     242:	80 83       	st	Z, r24
     244:	08 95       	ret

00000246 <DAC_0_disable>:
 *
 * \return Nothing
 */
void DAC_0_disable()
{
	DAC0.CTRLA &= ~DAC_ENABLE_bm;
     246:	e0 ea       	ldi	r30, 0xA0	; 160
     248:	f6 e0       	ldi	r31, 0x06	; 6
     24a:	80 81       	ld	r24, Z
     24c:	8e 7f       	andi	r24, 0xFE	; 254
     24e:	80 83       	st	Z, r24
     250:	08 95       	ret

00000252 <DAC_0_set_output>:
 *
 * \return Nothing
 */
void DAC_0_set_output(dac_resolution_t value)
{
	DAC0.DATA = value;
     252:	80 93 a1 06 	sts	0x06A1, r24	; 0x8006a1 <__TEXT_REGION_LENGTH__+0x7006a1>
     256:	08 95       	ret

00000258 <mcu_init>:
#ifdef __cplusplus
extern "C" {
#endif

void mcu_init(void)
{
     258:	e0 e1       	ldi	r30, 0x10	; 16
     25a:	f4 e0       	ldi	r31, 0x04	; 4
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     25c:	80 81       	ld	r24, Z
     25e:	88 60       	ori	r24, 0x08	; 8
     260:	81 93       	st	Z+, r24
	 * disables all peripherals to save power. Driver shall enable
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
     262:	e8 31       	cpi	r30, 0x18	; 24
     264:	84 e0       	ldi	r24, 0x04	; 4
     266:	f8 07       	cpc	r31, r24
     268:	c9 f7       	brne	.-14     	; 0x25c <mcu_init+0x4>
     26a:	e0 e3       	ldi	r30, 0x30	; 48
     26c:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     26e:	80 81       	ld	r24, Z
     270:	88 60       	ori	r24, 0x08	; 8
     272:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     274:	e8 33       	cpi	r30, 0x38	; 56
     276:	84 e0       	ldi	r24, 0x04	; 4
     278:	f8 07       	cpc	r31, r24
     27a:	c9 f7       	brne	.-14     	; 0x26e <mcu_init+0x16>
     27c:	e0 e5       	ldi	r30, 0x50	; 80
     27e:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     280:	80 81       	ld	r24, Z
     282:	88 60       	ori	r24, 0x08	; 8
     284:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     286:	e8 35       	cpi	r30, 0x58	; 88
     288:	84 e0       	ldi	r24, 0x04	; 4
     28a:	f8 07       	cpc	r31, r24
     28c:	c9 f7       	brne	.-14     	; 0x280 <mcu_init+0x28>
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}
}
     28e:	08 95       	ret

00000290 <ADC_0_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     290:	e5 e1       	ldi	r30, 0x15	; 21
     292:	f4 e0       	ldi	r31, 0x04	; 4
     294:	80 81       	ld	r24, Z
     296:	88 7f       	andi	r24, 0xF8	; 248
     298:	84 60       	ori	r24, 0x04	; 4
     29a:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     29c:	80 81       	ld	r24, Z
     29e:	87 7f       	andi	r24, 0xF7	; 247
     2a0:	80 83       	st	Z, r24
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     2a2:	e7 e1       	ldi	r30, 0x17	; 23
     2a4:	f4 e0       	ldi	r31, 0x04	; 4
     2a6:	80 81       	ld	r24, Z
     2a8:	88 7f       	andi	r24, 0xF8	; 248
     2aa:	84 60       	ori	r24, 0x04	; 4
     2ac:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2ae:	80 81       	ld	r24, Z
     2b0:	87 7f       	andi	r24, 0xF7	; 247
     2b2:	80 83       	st	Z, r24
 */
static inline void PORTC_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     2b4:	e0 e5       	ldi	r30, 0x50	; 80
     2b6:	f4 e0       	ldi	r31, 0x04	; 4
     2b8:	80 81       	ld	r24, Z
     2ba:	88 7f       	andi	r24, 0xF8	; 248
     2bc:	84 60       	ori	r24, 0x04	; 4
     2be:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2c0:	80 81       	ld	r24, Z
     2c2:	87 7f       	andi	r24, 0xF7	; 247
     2c4:	80 83       	st	Z, r24
 */
static inline void PORTC_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     2c6:	e1 e5       	ldi	r30, 0x51	; 81
     2c8:	f4 e0       	ldi	r31, 0x04	; 4
     2ca:	80 81       	ld	r24, Z
     2cc:	88 7f       	andi	r24, 0xF8	; 248
     2ce:	84 60       	ori	r24, 0x04	; 4
     2d0:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2d2:	80 81       	ld	r24, Z
     2d4:	87 7f       	andi	r24, 0xF7	; 247
     2d6:	80 83       	st	Z, r24
 */
static inline void PORTC_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     2d8:	e3 e5       	ldi	r30, 0x53	; 83
     2da:	f4 e0       	ldi	r31, 0x04	; 4
     2dc:	80 81       	ld	r24, Z
     2de:	88 7f       	andi	r24, 0xF8	; 248
     2e0:	84 60       	ori	r24, 0x04	; 4
     2e2:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2e4:	80 81       	ld	r24, Z
     2e6:	87 7f       	andi	r24, 0xF7	; 247
     2e8:	80 83       	st	Z, r24
	// Disable digital input buffer
	DEN4_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	DEN4_PIN_set_pull_mode(PORT_PULL_OFF);

	ADC_0_init();
     2ea:	0e 94 d1 00 	call	0x1a2	; 0x1a2 <ADC_0_init>
     2ee:	08 95       	ret

000002f0 <USART_0_initialization>:
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     2f0:	23 98       	cbi	0x04, 3	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2f2:	e3 e3       	ldi	r30, 0x33	; 51
     2f4:	f4 e0       	ldi	r31, 0x04	; 4
     2f6:	80 81       	ld	r24, Z
     2f8:	87 7f       	andi	r24, 0xF7	; 247
     2fa:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     2fc:	22 9a       	sbi	0x04, 2	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     2fe:	2a 98       	cbi	0x05, 2	; 5
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	USART_0_init();
     300:	0e 94 19 02 	call	0x432	; 0x432 <USART_0_init>
     304:	08 95       	ret

00000306 <TIMER_0_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     306:	25 9a       	sbi	0x04, 5	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     308:	2d 98       	cbi	0x05, 5	; 5
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLC |= PORTMUX_TCA02_bm;
     30a:	e0 e0       	ldi	r30, 0x00	; 0
     30c:	f2 e0       	ldi	r31, 0x02	; 2
     30e:	82 81       	ldd	r24, Z+2	; 0x02
     310:	84 60       	ori	r24, 0x04	; 4
     312:	82 83       	std	Z+2, r24	; 0x02

	TIMER_0_init();
     314:	0e 94 09 02 	call	0x412	; 0x412 <TIMER_0_init>
     318:	08 95       	ret

0000031a <DIGITAL_GLUE_LOGIC_0_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     31a:	24 9a       	sbi	0x04, 4	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     31c:	2c 98       	cbi	0x05, 4	; 5
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLA |= PORTMUX_LUT0_bm;
     31e:	e0 e0       	ldi	r30, 0x00	; 0
     320:	f2 e0       	ldi	r31, 0x02	; 2
     322:	80 81       	ld	r24, Z
     324:	80 61       	ori	r24, 0x10	; 16
     326:	80 83       	st	Z, r24

	DIGITAL_GLUE_LOGIC_0_init();
     328:	0e 94 f1 00 	call	0x1e2	; 0x1e2 <DIGITAL_GLUE_LOGIC_0_init>
     32c:	08 95       	ret

0000032e <SPI_0_initialization>:
 */
static inline void PORTA_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
     32e:	02 98       	cbi	0x00, 2	; 0
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     330:	e2 e1       	ldi	r30, 0x12	; 18
     332:	f4 e0       	ldi	r31, 0x04	; 4
     334:	80 81       	ld	r24, Z
     336:	87 7f       	andi	r24, 0xF7	; 247
     338:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     33a:	01 9a       	sbi	0x00, 1	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     33c:	09 98       	cbi	0x01, 1	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     33e:	03 9a       	sbi	0x00, 3	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     340:	0b 98       	cbi	0x01, 3	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     342:	04 9a       	sbi	0x00, 4	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     344:	0c 98       	cbi	0x01, 4	; 1
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	SPI_0_init();
     346:	0e 94 01 02 	call	0x402	; 0x402 <SPI_0_init>
     34a:	08 95       	ret

0000034c <DAC_0_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     34c:	e6 e1       	ldi	r30, 0x16	; 22
     34e:	f4 e0       	ldi	r31, 0x04	; 4
     350:	80 81       	ld	r24, Z
     352:	88 7f       	andi	r24, 0xF8	; 248
     354:	84 60       	ori	r24, 0x04	; 4
     356:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     358:	80 81       	ld	r24, Z
     35a:	87 7f       	andi	r24, 0xF7	; 247
     35c:	80 83       	st	Z, r24
	// Disable digital input buffer
	AXON_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	AXON_PIN_set_pull_mode(PORT_PULL_OFF);

	DAC_0_init();
     35e:	0e 94 13 01 	call	0x226	; 0x226 <DAC_0_init>
     362:	08 95       	ret

00000364 <system_init>:
/**
 * \brief System initialization
 */
void system_init()
{
	mcu_init();
     364:	0e 94 2c 01 	call	0x258	; 0x258 <mcu_init>
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     368:	21 9a       	sbi	0x04, 1	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     36a:	29 98       	cbi	0x05, 1	; 5
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     36c:	26 98       	cbi	0x04, 6	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     36e:	e6 e3       	ldi	r30, 0x36	; 54
     370:	f4 e0       	ldi	r31, 0x04	; 4
     372:	80 81       	ld	r24, Z
     374:	87 7f       	andi	r24, 0xF7	; 247
     376:	80 83       	st	Z, r24
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     378:	27 98       	cbi	0x04, 7	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     37a:	e7 e3       	ldi	r30, 0x37	; 55
     37c:	f4 e0       	ldi	r31, 0x04	; 4
     37e:	80 81       	ld	r24, Z
     380:	87 7f       	andi	r24, 0xF7	; 247
     382:	80 83       	st	Z, r24
 */
static inline void PORTC_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
     384:	42 98       	cbi	0x08, 2	; 8
static inline void PORTC_set_pin_pull_mode(const uint8_t pin, const enum port_pull_mode pull_mode)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
     386:	e2 e5       	ldi	r30, 0x52	; 82
     388:	f4 e0       	ldi	r31, 0x04	; 4
     38a:	80 81       	ld	r24, Z
     38c:	88 60       	ori	r24, 0x08	; 8
     38e:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTC.DIR |= (1 << pin);
     390:	45 9a       	sbi	0x08, 5	; 8
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     392:	4d 9a       	sbi	0x09, 5	; 9
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    true);

	CLKCTRL_init();
     394:	0e 94 02 01 	call	0x204	; 0x204 <CLKCTRL_init>

	RTC_0_init();
     398:	0e 94 e5 01 	call	0x3ca	; 0x3ca <RTC_0_init>

	ADC_0_initialization();
     39c:	0e 94 48 01 	call	0x290	; 0x290 <ADC_0_initialization>

	USART_0_initialization();
     3a0:	0e 94 78 01 	call	0x2f0	; 0x2f0 <USART_0_initialization>

	TIMER_0_initialization();
     3a4:	0e 94 83 01 	call	0x306	; 0x306 <TIMER_0_initialization>

	DIGITAL_GLUE_LOGIC_0_initialization();
     3a8:	0e 94 8d 01 	call	0x31a	; 0x31a <DIGITAL_GLUE_LOGIC_0_initialization>

	SPI_0_initialization();
     3ac:	0e 94 97 01 	call	0x32e	; 0x32e <SPI_0_initialization>

	DAC_0_initialization();
     3b0:	0e 94 a6 01 	call	0x34c	; 0x34c <DAC_0_initialization>

	CPUINT_init();
     3b4:	0e 94 10 01 	call	0x220	; 0x220 <CPUINT_init>

	SLPCTRL_init();
     3b8:	0e 94 ff 01 	call	0x3fe	; 0x3fe <SLPCTRL_init>

	BOD_init();
     3bc:	0e 94 ef 00 	call	0x1de	; 0x1de <BOD_init>
     3c0:	08 95       	ret

000003c2 <protected_write_io>:
#if defined(__GNUC__)
  
#ifdef RAMPZ
	out     _SFR_IO_ADDR(RAMPZ), r1         // Clear bits 23:16 of Z
#endif
	movw    r30, r24                // Load addr into Z
     3c2:	fc 01       	movw	r30, r24
	out     CCP, r22                // Start CCP handshake
     3c4:	64 bf       	out	0x34, r22	; 52
	st      Z, r20                  // Write value to I/O register
     3c6:	40 83       	st	Z, r20
	ret                             // Return to caller
     3c8:	08 95       	ret

000003ca <RTC_0_init>:
 * \return Initialization status.
 */
int8_t RTC_0_init()
{

	while (RTC.STATUS > 0) { /* Wait for all register to be synchronized */
     3ca:	e0 e4       	ldi	r30, 0x40	; 64
     3cc:	f1 e0       	ldi	r31, 0x01	; 1
     3ce:	81 81       	ldd	r24, Z+1	; 0x01
     3d0:	81 11       	cpse	r24, r1
     3d2:	fd cf       	rjmp	.-6      	; 0x3ce <RTC_0_init+0x4>
	}

	// RTC.CMP = 0x0; /* Compare: 0x0 */

	RTC.CNT = 0x20; /* Counter: 0x20 */
     3d4:	e0 e4       	ldi	r30, 0x40	; 64
     3d6:	f1 e0       	ldi	r31, 0x01	; 1
     3d8:	80 e2       	ldi	r24, 0x20	; 32
     3da:	90 e0       	ldi	r25, 0x00	; 0
     3dc:	80 87       	std	Z+8, r24	; 0x08
     3de:	91 87       	std	Z+9, r25	; 0x09

	RTC.CTRLA = RTC_PRESCALER_DIV1_gc   /* 1 */
     3e0:	21 e8       	ldi	r18, 0x81	; 129
     3e2:	20 83       	st	Z, r18
	            | 1 << RTC_RTCEN_bp     /* Enable: enabled */
	            | 1 << RTC_RUNSTDBY_bp; /* Run In Standby: enabled */

	RTC.PER = 0x20 / TIMESCALE; /* Period: 0x20 */
     3e4:	82 87       	std	Z+10, r24	; 0x0a
     3e6:	93 87       	std	Z+11, r25	; 0x0b

	// RTC.CLKSEL = RTC_CLKSEL_INT32K_gc; /* 32KHz Internal Ultra Low Power Oscillator (OSCULP32K) */

	RTC.DBGCTRL = 1 << RTC_DBGRUN_bp; /* Run in debug: enabled */
     3e8:	81 e0       	ldi	r24, 0x01	; 1
     3ea:	85 83       	std	Z+5, r24	; 0x05

	RTC.INTCTRL = 0 << RTC_CMP_bp    /* Compare Match Interrupt enable: disabled */
     3ec:	82 83       	std	Z+2, r24	; 0x02
	              | 1 << RTC_OVF_bp; /* Overflow Interrupt enable: enabled */

	while (RTC.PITSTATUS > 0) { /* Wait for all register to be synchronized */
     3ee:	81 89       	ldd	r24, Z+17	; 0x11
     3f0:	81 11       	cpse	r24, r1
     3f2:	fd cf       	rjmp	.-6      	; 0x3ee <RTC_0_init+0x24>
	}

	RTC.PITCTRLA = RTC_PERIOD_OFF_gc    /* Off */
     3f4:	81 e0       	ldi	r24, 0x01	; 1
     3f6:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <__TEXT_REGION_LENGTH__+0x700150>
	// RTC.PITDBGCTRL = 0 << RTC_DBGRUN_bp; /* Run in debug: disabled */

	// RTC.PITINTCTRL = 0 << RTC_PI_bp; /* Periodic Interrupt: disabled */

	return 0;
}
     3fa:	80 e0       	ldi	r24, 0x00	; 0
     3fc:	08 95       	ret

000003fe <SLPCTRL_init>:

	// SLPCTRL.CTRLA = 0 << SLPCTRL_SEN_bp /* Sleep enable: disabled */
	//		 | SLPCTRL_SMODE_IDLE_gc; /* Idle mode */

	return 0;
}
     3fe:	80 e0       	ldi	r24, 0x00	; 0
     400:	08 95       	ret

00000402 <SPI_0_init>:
 * \return Initialization status
 */
int8_t SPI_0_init()
{

	SPI0.CTRLA = 0 << SPI_CLK2X_bp     /* Enable Double Speed: disabled */
     402:	e0 e2       	ldi	r30, 0x20	; 32
     404:	f8 e0       	ldi	r31, 0x08	; 8
     406:	83 e2       	ldi	r24, 0x23	; 35
     408:	80 83       	st	Z, r24
	             | 0 << SPI_DORD_bp    /* Data Order Setting: disabled */
	             | 1 << SPI_ENABLE_bp  /* Enable Module: enabled */
	             | 1 << SPI_MASTER_bp  /* SPI module in master mode */
	             | SPI_PRESC_DIV16_gc; /* System Clock / 16 */

	SPI0.CTRLB = 0 << SPI_BUFEN_bp   /* Buffer Mode Enable: disabled */
     40a:	84 e0       	ldi	r24, 0x04	; 4
     40c:	81 83       	std	Z+1, r24	; 0x01
	//		 | 0 << SPI_RXCIE_bp /* Receive Complete Interrupt Enable: disabled */
	//		 | 0 << SPI_SSIE_bp /* Slave Select Trigger Interrupt Enable: disabled */
	//		 | 0 << SPI_TXCIE_bp; /* Transfer Complete Interrupt Enable: disabled */

	return 0;
}
     40e:	80 e0       	ldi	r24, 0x00	; 0
     410:	08 95       	ret

00000412 <TIMER_0_init>:

	// TCA0.SINGLE.CMP0 = 0x0; /* Compare Register 0: 0x0 */

	// TCA0.SINGLE.CMP1 = 0x0; /* Compare Register 1: 0x0 */

	TCA0.SINGLE.CMP2 = 0x4; /* Compare Register 2: 0x4 */
     412:	e0 e0       	ldi	r30, 0x00	; 0
     414:	fa e0       	ldi	r31, 0x0A	; 10
     416:	84 e0       	ldi	r24, 0x04	; 4
     418:	90 e0       	ldi	r25, 0x00	; 0
     41a:	84 a7       	std	Z+44, r24	; 0x2c
     41c:	95 a7       	std	Z+45, r25	; 0x2d

	// TCA0.SINGLE.CNT = 0x0; /* Count: 0x0 */

	TCA0.SINGLE.CTRLB = 0 << TCA_SINGLE_ALUPD_bp            /* Auto Lock Update: disabled */
     41e:	83 e4       	ldi	r24, 0x43	; 67
     420:	81 83       	std	Z+1, r24	; 0x01
	                    | 0 << TCA_SINGLE_CMP0EN_bp         /* Compare 0 Enable: disabled */
	                    | 0 << TCA_SINGLE_CMP1EN_bp         /* Compare 1 Enable: disabled */
	                    | 1 << TCA_SINGLE_CMP2EN_bp         /* Compare 2 Enable: enabled */
	                    | TCA_SINGLE_WGMODE_SINGLESLOPE_gc; /*  */

	TCA0.SINGLE.CTRLC = 0 << TCA_SINGLE_CMP0OV_bp    /* Compare 0 Waveform Output Value: disabled */
     422:	84 e0       	ldi	r24, 0x04	; 4
     424:	82 83       	std	Z+2, r24	; 0x02
	// TCA0.SINGLE.INTCTRL = 0 << TCA_SINGLE_CMP0_bp /* Compare 0 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP1_bp /* Compare 1 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP2_bp /* Compare 2 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_OVF_bp; /* Overflow Interrupt: disabled */

	TCA0.SINGLE.PER = 0x7; /* Period: 0x7 */
     426:	87 e0       	ldi	r24, 0x07	; 7
     428:	90 e0       	ldi	r25, 0x00	; 0
     42a:	86 a3       	std	Z+38, r24	; 0x26
     42c:	97 a3       	std	Z+39, r25	; 0x27

	// TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV1_gc /* System Clock */
	//		 | 0 << TCA_SINGLE_ENABLE_bp; /* Module Enable: disabled */

	return 0;
}
     42e:	80 e0       	ldi	r24, 0x00	; 0
     430:	08 95       	ret

00000432 <USART_0_init>:
uint8_t USART_0_read()
{
	while (!(USART0.STATUS & USART_RXCIF_bm))
		;
	return USART0.RXDATAL;
}
     432:	e0 e0       	ldi	r30, 0x00	; 0
     434:	f8 e0       	ldi	r31, 0x08	; 8
     436:	8b e5       	ldi	r24, 0x5B	; 91
     438:	91 e0       	ldi	r25, 0x01	; 1
     43a:	80 87       	std	Z+8, r24	; 0x08
     43c:	91 87       	std	Z+9, r25	; 0x09
     43e:	80 ec       	ldi	r24, 0xC0	; 192
     440:	86 83       	std	Z+6, r24	; 0x06
     442:	80 e0       	ldi	r24, 0x00	; 0
     444:	98 e3       	ldi	r25, 0x38	; 56
     446:	80 93 6e 38 	sts	0x386E, r24	; 0x80386e <__iob+0x2>
     44a:	90 93 6f 38 	sts	0x386F, r25	; 0x80386f <__iob+0x3>
     44e:	80 e0       	ldi	r24, 0x00	; 0
     450:	08 95       	ret

00000452 <USART_0_write>:
 *
 * \return Nothing
 */
void USART_0_write(const uint8_t data)
{
	while (!(USART0.STATUS & USART_DREIF_bm))
     452:	e0 e0       	ldi	r30, 0x00	; 0
     454:	f8 e0       	ldi	r31, 0x08	; 8
     456:	94 81       	ldd	r25, Z+4	; 0x04
     458:	95 ff       	sbrs	r25, 5
     45a:	fd cf       	rjmp	.-6      	; 0x456 <USART_0_write+0x4>
		;
	USART0.TXDATAL = data;
     45c:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <__TEXT_REGION_LENGTH__+0x700802>
     460:	08 95       	ret

00000462 <USART_0_printCHAR>:

#if defined(__GNUC__)

int USART_0_printCHAR(char character, FILE *stream)
{
	USART_0_write(character);
     462:	0e 94 29 02 	call	0x452	; 0x452 <USART_0_write>
	return 0;
}
     466:	80 e0       	ldi	r24, 0x00	; 0
     468:	90 e0       	ldi	r25, 0x00	; 0
     46a:	08 95       	ret

0000046c <tinyAxon_add_pulse>:
{
	// We want to check each slot in the pulse_queue, and
	// if we find an empty slot (0), we add a pulse.
	for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
	{
		if(pulse_queue[i] == 0){
     46c:	20 91 16 38 	lds	r18, 0x3816	; 0x803816 <__data_end>
     470:	30 91 17 38 	lds	r19, 0x3817	; 0x803817 <__data_end+0x1>
     474:	23 2b       	or	r18, r19
     476:	51 f0       	breq	.+20     	; 0x48c <tinyAxon_add_pulse+0x20>
     478:	e8 e1       	ldi	r30, 0x18	; 24
     47a:	f8 e3       	ldi	r31, 0x38	; 56
     47c:	21 e0       	ldi	r18, 0x01	; 1
     47e:	30 e0       	ldi	r19, 0x00	; 0
     480:	b9 01       	movw	r22, r18
     482:	41 91       	ld	r20, Z+
     484:	51 91       	ld	r21, Z+
     486:	45 2b       	or	r20, r21
     488:	81 f4       	brne	.+32     	; 0x4aa <tinyAxon_add_pulse+0x3e>
     48a:	02 c0       	rjmp	.+4      	; 0x490 <tinyAxon_add_pulse+0x24>
     48c:	60 e0       	ldi	r22, 0x00	; 0
     48e:	70 e0       	ldi	r23, 0x00	; 0
			pulse_queue[i] = new_pulse;
     490:	66 0f       	add	r22, r22
     492:	77 1f       	adc	r23, r23
     494:	fb 01       	movw	r30, r22
     496:	ea 5e       	subi	r30, 0xEA	; 234
     498:	f7 4c       	sbci	r31, 0xC7	; 199
     49a:	80 83       	st	Z, r24
     49c:	91 83       	std	Z+1, r25	; 0x01
			pulses_in_queue++;
     49e:	80 91 2a 38 	lds	r24, 0x382A	; 0x80382a <pulses_in_queue>
     4a2:	8f 5f       	subi	r24, 0xFF	; 255
     4a4:	80 93 2a 38 	sts	0x382A, r24	; 0x80382a <pulses_in_queue>
			// We return so we only ever add one
			break;
     4a8:	08 95       	ret
     4aa:	2f 5f       	subi	r18, 0xFF	; 255
     4ac:	3f 4f       	sbci	r19, 0xFF	; 255
*/
static void tinyAxon_add_pulse(uint16_t new_pulse)
{
	// We want to check each slot in the pulse_queue, and
	// if we find an empty slot (0), we add a pulse.
	for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
     4ae:	2a 30       	cpi	r18, 0x0A	; 10
     4b0:	31 05       	cpc	r19, r1
     4b2:	31 f7       	brne	.-52     	; 0x480 <tinyAxon_add_pulse+0x14>
     4b4:	08 95       	ret

000004b6 <tinyAxon_is_firing>:
// DAC has no DAC_0_get_output, so we keep track of this here.
uint8_t axonOutputValue = 0;


_Bool tinyAxon_is_firing(){
	return axonOutputValue != NO_SIGNAL_OUTPUT;
     4b6:	81 e0       	ldi	r24, 0x01	; 1
     4b8:	90 91 2b 38 	lds	r25, 0x382B	; 0x80382b <axonOutputValue>
     4bc:	91 11       	cpse	r25, r1
     4be:	01 c0       	rjmp	.+2      	; 0x4c2 <tinyAxon_is_firing+0xc>
     4c0:	80 e0       	ldi	r24, 0x00	; 0
}
     4c2:	08 95       	ret

000004c4 <tinyAxon_get_pulses_in_queue>:
uint8_t pulses_in_queue = 0; //variable to determine how many pulses are in queue.

uint8_t tinyAxon_get_pulses_in_queue()
{
	return pulses_in_queue;
}
     4c4:	80 91 2a 38 	lds	r24, 0x382A	; 0x80382a <pulses_in_queue>
     4c8:	08 95       	ret

000004ca <find_newest_pulse>:
uint8_t find_newest_pulse() {
	uint16_t max;
	uint8_t current_index = 0;
	uint8_t return_index = 0;
	
	max = pulse_queue[current_index];
     4ca:	40 91 16 38 	lds	r20, 0x3816	; 0x803816 <__data_end>
     4ce:	50 91 17 38 	lds	r21, 0x3817	; 0x803817 <__data_end+0x1>
     4d2:	e8 e1       	ldi	r30, 0x18	; 24
     4d4:	f8 e3       	ldi	r31, 0x38	; 56
	
// This function will be used with pulse_queue to find the newest pulse
uint8_t find_newest_pulse() {
	uint16_t max;
	uint8_t current_index = 0;
	uint8_t return_index = 0;
     4d6:	80 e0       	ldi	r24, 0x00	; 0
	
	max = pulse_queue[current_index];
	
	for (current_index = 1; current_index < MAX_NUMBER_OF_PULSES; current_index++) {
     4d8:	91 e0       	ldi	r25, 0x01	; 1
		if (pulse_queue[current_index] > max) {
     4da:	21 91       	ld	r18, Z+
     4dc:	31 91       	ld	r19, Z+
     4de:	42 17       	cp	r20, r18
     4e0:	53 07       	cpc	r21, r19
     4e2:	10 f4       	brcc	.+4      	; 0x4e8 <find_newest_pulse+0x1e>
     4e4:	89 2f       	mov	r24, r25
			return_index = current_index;
			max = pulse_queue[current_index];
     4e6:	a9 01       	movw	r20, r18
	uint8_t current_index = 0;
	uint8_t return_index = 0;
	
	max = pulse_queue[current_index];
	
	for (current_index = 1; current_index < MAX_NUMBER_OF_PULSES; current_index++) {
     4e8:	9f 5f       	subi	r25, 0xFF	; 255
     4ea:	9a 30       	cpi	r25, 0x0A	; 10
     4ec:	b1 f7       	brne	.-20     	; 0x4da <find_newest_pulse+0x10>
			return_index = current_index;
			max = pulse_queue[current_index];
		}
	}
	return return_index;
}
     4ee:	08 95       	ret

000004f0 <find_oldest_pulse>:
uint8_t find_oldest_pulse() {
	uint16_t min;
	uint8_t current_index = 0;
	uint8_t return_index = 0;
	
	min = pulse_queue[current_index];
     4f0:	40 91 16 38 	lds	r20, 0x3816	; 0x803816 <__data_end>
     4f4:	50 91 17 38 	lds	r21, 0x3817	; 0x803817 <__data_end+0x1>
     4f8:	e8 e1       	ldi	r30, 0x18	; 24
     4fa:	f8 e3       	ldi	r31, 0x38	; 56


uint8_t find_oldest_pulse() {
	uint16_t min;
	uint8_t current_index = 0;
	uint8_t return_index = 0;
     4fc:	80 e0       	ldi	r24, 0x00	; 0
	
	min = pulse_queue[current_index];
	
	for (current_index = 1; current_index < MAX_NUMBER_OF_PULSES; current_index++) {
     4fe:	91 e0       	ldi	r25, 0x01	; 1
		// We don't count pluses with time=0, they have already bee fired.
		if (pulse_queue[current_index] < min && pulse_queue[current_index] > 0) {
     500:	21 91       	ld	r18, Z+
     502:	31 91       	ld	r19, Z+
     504:	24 17       	cp	r18, r20
     506:	35 07       	cpc	r19, r21
     508:	28 f4       	brcc	.+10     	; 0x514 <find_oldest_pulse+0x24>
     50a:	21 15       	cp	r18, r1
     50c:	31 05       	cpc	r19, r1
     50e:	11 f0       	breq	.+4      	; 0x514 <find_oldest_pulse+0x24>
     510:	89 2f       	mov	r24, r25
			return_index = current_index;
			min = pulse_queue[current_index];
     512:	a9 01       	movw	r20, r18
	uint8_t current_index = 0;
	uint8_t return_index = 0;
	
	min = pulse_queue[current_index];
	
	for (current_index = 1; current_index < MAX_NUMBER_OF_PULSES; current_index++) {
     514:	9f 5f       	subi	r25, 0xFF	; 255
     516:	9a 30       	cpi	r25, 0x0A	; 10
     518:	99 f7       	brne	.-26     	; 0x500 <find_oldest_pulse+0x10>
			return_index = current_index;
			min = pulse_queue[current_index];
		}
	}
	return return_index;
}
     51a:	08 95       	ret

0000051c <tinyAxon_time_until_next_pulse>:

// This function will be used with in the tinyLED to determine how long the light should flash
uint8_t tinyAxon_time_until_next_pulse(){
	return pulse_queue[find_oldest_pulse()];
     51c:	0e 94 78 02 	call	0x4f0	; 0x4f0 <find_oldest_pulse>
     520:	e8 2f       	mov	r30, r24
     522:	f0 e0       	ldi	r31, 0x00	; 0
     524:	ee 0f       	add	r30, r30
     526:	ff 1f       	adc	r31, r31
     528:	ea 5e       	subi	r30, 0xEA	; 234
     52a:	f7 4c       	sbci	r31, 0xC7	; 199
}
     52c:	80 81       	ld	r24, Z
     52e:	08 95       	ret

00000530 <tinyAxon_stop_sending_pulse>:
	tinyLED_set_color_mode(OUT_LED, WHITE, FLASH_ONCE);
}

void tinyAxon_stop_sending_pulse()
{
	DAC_0_set_output(NO_SIGNAL_OUTPUT);
     530:	80 e0       	ldi	r24, 0x00	; 0
     532:	90 e0       	ldi	r25, 0x00	; 0
     534:	0e 94 29 01 	call	0x252	; 0x252 <DAC_0_set_output>
	axonOutputValue=NO_SIGNAL_OUTPUT;
     538:	10 92 2b 38 	sts	0x382B, r1	; 0x80382b <axonOutputValue>
     53c:	08 95       	ret

0000053e <tinyAxon_remove_pulse>:

/*
If the potential is very low, we want to try to remove a pulse.
*/
bool tinyAxon_remove_pulse(void)
{
     53e:	cf 93       	push	r28
	// We want to return a bool indicating whether or not a pulse actually was removed.
	if(pulses_in_queue == 0){
     540:	c0 91 2a 38 	lds	r28, 0x382A	; 0x80382a <pulses_in_queue>
     544:	cc 23       	and	r28, r28
     546:	c1 f0       	breq	.+48     	; 0x578 <tinyAxon_remove_pulse+0x3a>
		//There was no pulse to remove.
		return false;
	}
	else{
		// If we are to remove a pulse, we want to remove the one that will fire last.
		uint8_t pulse_index = find_newest_pulse();
     548:	0e 94 65 02 	call	0x4ca	; 0x4ca <find_newest_pulse>
		uint16_t newest_pulse = pulse_queue[pulse_index];
     54c:	90 e0       	ldi	r25, 0x00	; 0
     54e:	fc 01       	movw	r30, r24
     550:	ee 0f       	add	r30, r30
     552:	ff 1f       	adc	r31, r31
     554:	ea 5e       	subi	r30, 0xEA	; 234
     556:	f7 4c       	sbci	r31, 0xC7	; 199
	
		// Now we want to check if the pulse is too far away to be affected by the low potential, or close enough that we decide to remove it.
		// (When we say that the pulse is too far away, it refers to the biological process of how the potential spreads from Dendrites to axon).
		if(newest_pulse > PULSE_NO_RETURN_TIME){
     558:	20 81       	ld	r18, Z
     55a:	31 81       	ldd	r19, Z+1	; 0x01
     55c:	23 2b       	or	r18, r19
     55e:	71 f0       	breq	.+28     	; 0x57c <tinyAxon_remove_pulse+0x3e>
			// We decided to remove the pulse
			pulse_queue[pulse_index] = 0;
     560:	88 0f       	add	r24, r24
     562:	99 1f       	adc	r25, r25
     564:	fc 01       	movw	r30, r24
     566:	ea 5e       	subi	r30, 0xEA	; 234
     568:	f7 4c       	sbci	r31, 0xC7	; 199
     56a:	10 82       	st	Z, r1
     56c:	11 82       	std	Z+1, r1	; 0x01
			pulses_in_queue--;
     56e:	c1 50       	subi	r28, 0x01	; 1
     570:	c0 93 2a 38 	sts	0x382A, r28	; 0x80382a <pulses_in_queue>
			return true;
     574:	81 e0       	ldi	r24, 0x01	; 1
     576:	03 c0       	rjmp	.+6      	; 0x57e <tinyAxon_remove_pulse+0x40>
bool tinyAxon_remove_pulse(void)
{
	// We want to return a bool indicating whether or not a pulse actually was removed.
	if(pulses_in_queue == 0){
		//There was no pulse to remove.
		return false;
     578:	80 e0       	ldi	r24, 0x00	; 0
     57a:	01 c0       	rjmp	.+2      	; 0x57e <tinyAxon_remove_pulse+0x40>
			pulses_in_queue--;
			return true;
		}
		// Here we have found that there is a pulse queued, but it is old enough to let pass anyway, so now we need to put it back into the queue.
		else{
			return false;
     57c:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     57e:	cf 91       	pop	r28
     580:	08 95       	ret

00000582 <tinyAxon_update_potential>:
/*
Decides whether or not the axon should fire
If the axon does fire, the potential is reduced
*/
double tinyAxon_update_potential(double potential)
{	
     582:	cf 92       	push	r12
     584:	df 92       	push	r13
     586:	ef 92       	push	r14
     588:	ff 92       	push	r15
     58a:	6b 01       	movw	r12, r22
     58c:	7c 01       	movw	r14, r24
	//While the neuron has enough potential to fire, we want to fire more
	while (potential >= THRESHOLD_POTENTIAL)
     58e:	20 e0       	ldi	r18, 0x00	; 0
     590:	30 e0       	ldi	r19, 0x00	; 0
     592:	48 ec       	ldi	r20, 0xC8	; 200
     594:	51 e4       	ldi	r21, 0x41	; 65
     596:	0e 94 41 0c 	call	0x1882	; 0x1882 <__gesf2>
     59a:	88 23       	and	r24, r24
     59c:	84 f1       	brlt	.+96     	; 0x5fe <tinyAxon_update_potential+0x7c>
	{
		// We have to check if there are already queued pulses, so that the frequency never exceeds FIRE_DELAY
		if(pulses_in_queue>0){
     59e:	80 91 2a 38 	lds	r24, 0x382A	; 0x80382a <pulses_in_queue>
     5a2:	88 23       	and	r24, r24
     5a4:	b1 f0       	breq	.+44     	; 0x5d2 <tinyAxon_update_potential+0x50>
			uint16_t newest_pulse = pulse_queue[find_newest_pulse()];
     5a6:	0e 94 65 02 	call	0x4ca	; 0x4ca <find_newest_pulse>
     5aa:	e8 2f       	mov	r30, r24
     5ac:	f0 e0       	ldi	r31, 0x00	; 0
     5ae:	ee 0f       	add	r30, r30
     5b0:	ff 1f       	adc	r31, r31
     5b2:	ea 5e       	subi	r30, 0xEA	; 234
     5b4:	f7 4c       	sbci	r31, 0xC7	; 199
			
			// There is at least one pulse in the queue, and it is "so close", that we need to offset the new pulse, so that we keep at least
			// one FIRE_DELAY between each pulse
			if(newest_pulse + FIRE_DELAY > TRAVLE_DELAY){
     5b6:	80 81       	ld	r24, Z
     5b8:	91 81       	ldd	r25, Z+1	; 0x01
     5ba:	0a 96       	adiw	r24, 0x0a	; 10
     5bc:	85 36       	cpi	r24, 0x65	; 101
     5be:	91 05       	cpc	r25, r1
     5c0:	18 f0       	brcs	.+6      	; 0x5c8 <tinyAxon_update_potential+0x46>
				tinyAxon_add_pulse(newest_pulse + FIRE_DELAY);
     5c2:	0e 94 36 02 	call	0x46c	; 0x46c <tinyAxon_add_pulse>
     5c6:	09 c0       	rjmp	.+18     	; 0x5da <tinyAxon_update_potential+0x58>
			}
			// There is at least one pulse in the queue, but it's "far enough away" to ignore
			else{
				tinyAxon_add_pulse(TRAVLE_DELAY);
     5c8:	84 e6       	ldi	r24, 0x64	; 100
     5ca:	90 e0       	ldi	r25, 0x00	; 0
     5cc:	0e 94 36 02 	call	0x46c	; 0x46c <tinyAxon_add_pulse>
     5d0:	04 c0       	rjmp	.+8      	; 0x5da <tinyAxon_update_potential+0x58>
			}
		}
		// There are no pulses in the queue, so we add a pulse as normal
		else{
			tinyAxon_add_pulse(TRAVLE_DELAY);		
     5d2:	84 e6       	ldi	r24, 0x64	; 100
     5d4:	90 e0       	ldi	r25, 0x00	; 0
     5d6:	0e 94 36 02 	call	0x46c	; 0x46c <tinyAxon_add_pulse>
		}
		
		potential += POSTFIRE_POTENTIAL_REACTION; // This is usually defined as a negative value, don't be confused by the +=
     5da:	20 e0       	ldi	r18, 0x00	; 0
     5dc:	30 e0       	ldi	r19, 0x00	; 0
     5de:	48 ec       	ldi	r20, 0xC8	; 200
     5e0:	51 e4       	ldi	r21, 0x41	; 65
     5e2:	c7 01       	movw	r24, r14
     5e4:	b6 01       	movw	r22, r12
     5e6:	0e 94 f5 09 	call	0x13ea	; 0x13ea <__subsf3>
     5ea:	6b 01       	movw	r12, r22
     5ec:	7c 01       	movw	r14, r24
If the axon does fire, the potential is reduced
*/
double tinyAxon_update_potential(double potential)
{	
	//While the neuron has enough potential to fire, we want to fire more
	while (potential >= THRESHOLD_POTENTIAL)
     5ee:	20 e0       	ldi	r18, 0x00	; 0
     5f0:	30 e0       	ldi	r19, 0x00	; 0
     5f2:	48 ec       	ldi	r20, 0xC8	; 200
     5f4:	51 e4       	ldi	r21, 0x41	; 65
     5f6:	0e 94 41 0c 	call	0x1882	; 0x1882 <__gesf2>
     5fa:	88 23       	and	r24, r24
     5fc:	84 f6       	brge	.-96     	; 0x59e <tinyAxon_update_potential+0x1c>
		// Why the hell is this line here? It shoudln't i think...
		//tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
	}
	
	// If the neuron has a very low potential, we want to remove a pulse from the queue (if there is one)
	if(potential < REMOVE_PULSE_THRESHOLD) // REMOVE_PULSE_THRESHOLD is a negative number
     5fe:	20 e0       	ldi	r18, 0x00	; 0
     600:	30 e0       	ldi	r19, 0x00	; 0
     602:	40 ea       	ldi	r20, 0xA0	; 160
     604:	51 ec       	ldi	r21, 0xC1	; 193
     606:	c7 01       	movw	r24, r14
     608:	b6 01       	movw	r22, r12
     60a:	0e 94 62 0a 	call	0x14c4	; 0x14c4 <__cmpsf2>
     60e:	88 23       	and	r24, r24
     610:	0c f0       	brlt	.+2      	; 0x614 <tinyAxon_update_potential+0x92>
     612:	46 c0       	rjmp	.+140    	; 0x6a0 <tinyAxon_update_potential+0x11e>
	{
		if(pulses_in_queue > 0)
     614:	80 91 2a 38 	lds	r24, 0x382A	; 0x80382a <pulses_in_queue>
     618:	88 23       	and	r24, r24
     61a:	11 f1       	breq	.+68     	; 0x660 <tinyAxon_update_potential+0xde>
		{
			// The neurons potential is low enough to attempt to remove a queued fire (Fire less)
			if(tinyAxon_remove_pulse())
     61c:	0e 94 9f 02 	call	0x53e	; 0x53e <tinyAxon_remove_pulse>
     620:	88 23       	and	r24, r24
     622:	f1 f1       	breq	.+124    	; 0x6a0 <tinyAxon_update_potential+0x11e>
			{
				// The potential has evened out a bit
				potential += THRESHOLD_POTENTIAL;
     624:	20 e0       	ldi	r18, 0x00	; 0
     626:	30 e0       	ldi	r19, 0x00	; 0
     628:	48 ec       	ldi	r20, 0xC8	; 200
     62a:	51 e4       	ldi	r21, 0x41	; 65
     62c:	c7 01       	movw	r24, r14
     62e:	b6 01       	movw	r22, r12
     630:	0e 94 f6 09 	call	0x13ec	; 0x13ec <__addsf3>
     634:	6b 01       	movw	r12, r22
     636:	7c 01       	movw	r14, r24
     638:	33 c0       	rjmp	.+102    	; 0x6a0 <tinyAxon_update_potential+0x11e>
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
	{
		for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
		{
			if(pulse_queue[i] != 0){
     63a:	80 81       	ld	r24, Z
     63c:	91 81       	ldd	r25, Z+1	; 0x01
     63e:	00 97       	sbiw	r24, 0x00	; 0
     640:	39 f0       	breq	.+14     	; 0x650 <tinyAxon_update_potential+0xce>
				pulse_queue[i]--;
     642:	01 97       	sbiw	r24, 0x01	; 1
     644:	80 83       	st	Z, r24
     646:	91 83       	std	Z+1, r25	; 0x01
				
				// If the time went from 1 to 0, we fire the axon
				if(pulse_queue[i] == 0){
     648:	89 2b       	or	r24, r25
     64a:	11 f4       	brne	.+4      	; 0x650 <tinyAxon_update_potential+0xce>
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
	pulses_in_queue--;
     64c:	41 50       	subi	r20, 0x01	; 1
Function to set firing.
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
     64e:	51 e0       	ldi	r21, 0x01	; 1
     650:	32 96       	adiw	r30, 0x02	; 2
	}
	
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
	{
		for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
     652:	e2 17       	cp	r30, r18
     654:	f3 07       	cpc	r31, r19
     656:	89 f7       	brne	.-30     	; 0x63a <tinyAxon_update_potential+0xb8>
     658:	50 93 2c 38 	sts	0x382C, r21	; 0x80382c <tinyAxon_should_fire>
     65c:	40 93 2a 38 	sts	0x382A, r20	; 0x80382a <pulses_in_queue>
The function should set the DAC to fire for two
update cycles once the pulse flag is set high.
*/
static void tinyAxon_update_pulse_transmitter(void)
{
	if (tinyAxon_should_fire)
     660:	80 91 2c 38 	lds	r24, 0x382C	; 0x80382c <tinyAxon_should_fire>
     664:	88 23       	and	r24, r24
     666:	91 f0       	breq	.+36     	; 0x68c <tinyAxon_update_potential+0x10a>
	{
		tinyAxon_should_fire = false;
     668:	10 92 2c 38 	sts	0x382C, r1	; 0x80382c <tinyAxon_should_fire>
*/
static void tinyAxon_start_sending_pulse()
{
	if (NEURONTYPE == EXCITATORY_NEURON)
	{
		DAC_0_set_output(EXCITATORY_NEURON_OUTPUT);
     66c:	8c ee       	ldi	r24, 0xEC	; 236
     66e:	90 e0       	ldi	r25, 0x00	; 0
     670:	0e 94 29 01 	call	0x252	; 0x252 <DAC_0_set_output>
		axonOutputValue=EXCITATORY_NEURON_OUTPUT;
     674:	8c ee       	ldi	r24, 0xEC	; 236
     676:	80 93 2b 38 	sts	0x382B, r24	; 0x80382b <axonOutputValue>
	{
		DAC_0_set_output(INHIBITORY_NEURON_OUTPUT);
		axonOutputValue=INHIBITORY_NEURON_OUTPUT;
	}
	
	tinyLED_set_color_mode(OUT_LED, WHITE, FLASH_ONCE);
     67a:	45 e0       	ldi	r20, 0x05	; 5
     67c:	66 e0       	ldi	r22, 0x06	; 6
     67e:	81 e0       	ldi	r24, 0x01	; 1
     680:	0e 94 c9 05 	call	0xb92	; 0xb92 <tinyLED_set_color_mode>
{
	if (tinyAxon_should_fire)
	{
		tinyAxon_should_fire = false;
		tinyAxon_start_sending_pulse();
		tinyAxon_has_just_fired = true;
     684:	81 e0       	ldi	r24, 0x01	; 1
     686:	80 93 2d 38 	sts	0x382D, r24	; 0x80382d <tinyAxon_has_just_fired>
     68a:	15 c0       	rjmp	.+42     	; 0x6b6 <tinyAxon_update_potential+0x134>
		
	}
	else if (tinyAxon_has_just_fired)
     68c:	80 91 2d 38 	lds	r24, 0x382D	; 0x80382d <tinyAxon_has_just_fired>
     690:	88 23       	and	r24, r24
     692:	19 f0       	breq	.+6      	; 0x69a <tinyAxon_update_potential+0x118>
	{
		tinyAxon_has_just_fired = false;
     694:	10 92 2d 38 	sts	0x382D, r1	; 0x80382d <tinyAxon_has_just_fired>
     698:	0e c0       	rjmp	.+28     	; 0x6b6 <tinyAxon_update_potential+0x134>
	}
	else if (!tinyAxon_has_just_fired && !tinyAxon_should_fire)
	{
		tinyAxon_stop_sending_pulse();
     69a:	0e 94 98 02 	call	0x530	; 0x530 <tinyAxon_stop_sending_pulse>
     69e:	0b c0       	rjmp	.+22     	; 0x6b6 <tinyAxon_update_potential+0x134>
			}
		}
	}
	
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
     6a0:	40 91 2a 38 	lds	r20, 0x382A	; 0x80382a <pulses_in_queue>
     6a4:	44 23       	and	r20, r20
     6a6:	e1 f2       	breq	.-72     	; 0x660 <tinyAxon_update_potential+0xde>
     6a8:	50 91 2c 38 	lds	r21, 0x382C	; 0x80382c <tinyAxon_should_fire>
     6ac:	e6 e1       	ldi	r30, 0x16	; 22
     6ae:	f8 e3       	ldi	r31, 0x38	; 56
     6b0:	2a e2       	ldi	r18, 0x2A	; 42
     6b2:	38 e3       	ldi	r19, 0x38	; 56
     6b4:	c2 cf       	rjmp	.-124    	; 0x63a <tinyAxon_update_potential+0xb8>
	}
	
	// Here we set the actual output of the DAC (Digital to Analog Converter)
	tinyAxon_update_pulse_transmitter();
	
	tinyDebugger_send_uint8("Axon", axonOutputValue);
     6b6:	60 91 2b 38 	lds	r22, 0x382B	; 0x80382b <axonOutputValue>
     6ba:	81 e7       	ldi	r24, 0x71	; 113
     6bc:	9b e9       	ldi	r25, 0x9B	; 155
     6be:	0e 94 60 04 	call	0x8c0	; 0x8c0 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("Pulses", pulses_in_queue);
     6c2:	60 91 2a 38 	lds	r22, 0x382A	; 0x80382a <pulses_in_queue>
     6c6:	86 e7       	ldi	r24, 0x76	; 118
     6c8:	9b e9       	ldi	r25, 0x9B	; 155
     6ca:	0e 94 60 04 	call	0x8c0	; 0x8c0 <tinyDebugger_send_uint8>
	
	
	return potential;
}
     6ce:	c7 01       	movw	r24, r14
     6d0:	b6 01       	movw	r22, r12
     6d2:	ff 90       	pop	r15
     6d4:	ef 90       	pop	r14
     6d6:	df 90       	pop	r13
     6d8:	cf 90       	pop	r12
     6da:	08 95       	ret

000006dc <tinyAxon_check_charge_level>:


_Bool tinyAxon_check_charge_level(void)
{
	// We check the AXON_CHECK_PIN. If it is hight while the axon is not firing, it must be connected to a charger
	return (AXON_CHECK_PIN_get_level() && !tinyAxon_has_just_fired);
     6dc:	37 9b       	sbis	0x06, 7	; 6
     6de:	05 c0       	rjmp	.+10     	; 0x6ea <tinyAxon_check_charge_level+0xe>
     6e0:	90 91 2d 38 	lds	r25, 0x382D	; 0x80382d <tinyAxon_has_just_fired>
     6e4:	81 e0       	ldi	r24, 0x01	; 1
     6e6:	89 27       	eor	r24, r25
     6e8:	02 c0       	rjmp	.+4      	; 0x6ee <tinyAxon_check_charge_level+0x12>
     6ea:	80 e0       	ldi	r24, 0x00	; 0
     6ec:	90 e0       	ldi	r25, 0x00	; 0
     6ee:	81 70       	andi	r24, 0x01	; 1
     6f0:	08 95       	ret

000006f2 <tinyButton_update>:
/*
If the button has been let go, we change button_press to true. This only lasts one cycle, before it is set to false again.
If the button is held down for longer than PULSEMODE_BUTTON_PRESS_TIME, we toggle the pulse mode state.
*/
void tinyButton_update(void)
{
     6f2:	0f 93       	push	r16
     6f4:	1f 93       	push	r17
     6f6:	cf 93       	push	r28
     6f8:	df 93       	push	r29
	button_press = false;
     6fa:	10 92 33 38 	sts	0x3833, r1	; 0x803833 <button_press>
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTC_get_pin_level(const uint8_t pin)
{
	return VPORTC.IN & (1 << pin);
     6fe:	8a b1       	in	r24, 0x0a	; 10
	_Bool button_is_pushed_down = !BUTTON_PIN_get_level(); // The digital port will be read as low if the button is pushed down.
     700:	d1 e0       	ldi	r29, 0x01	; 1
     702:	c8 2f       	mov	r28, r24
     704:	c4 70       	andi	r28, 0x04	; 4
     706:	82 fd       	sbrc	r24, 2
     708:	d0 e0       	ldi	r29, 0x00	; 0

	if (button_is_pushed_down && !button_was_pushed_down)
     70a:	c1 11       	cpse	r28, r1
     70c:	36 c0       	rjmp	.+108    	; 0x77a <tinyButton_update+0x88>
     70e:	80 91 34 38 	lds	r24, 0x3834	; 0x803834 <button_was_pushed_down>
     712:	81 11       	cpse	r24, r1
     714:	0e c0       	rjmp	.+28     	; 0x732 <tinyButton_update+0x40>
	{
		tinyButton_start_time = tinyTime_now();
     716:	0e 94 ec 09 	call	0x13d8	; 0x13d8 <tinyTime_now>
     71a:	60 93 2e 38 	sts	0x382E, r22	; 0x80382e <tinyButton_start_time>
     71e:	70 93 2f 38 	sts	0x382F, r23	; 0x80382f <tinyButton_start_time+0x1>
     722:	80 93 30 38 	sts	0x3830, r24	; 0x803830 <tinyButton_start_time+0x2>
     726:	90 93 31 38 	sts	0x3831, r25	; 0x803831 <tinyButton_start_time+0x3>
	}
	if (button_is_pushed_down && button_was_pushed_down)
     72a:	80 91 34 38 	lds	r24, 0x3834	; 0x803834 <button_was_pushed_down>
     72e:	88 23       	and	r24, r24
     730:	a1 f1       	breq	.+104    	; 0x79a <tinyButton_update+0xa8>
	{
		if ((tinyTime_now() - tinyButton_start_time) > PULSEMODE_BUTTON_PRESS_TIME)
     732:	0e 94 ec 09 	call	0x13d8	; 0x13d8 <tinyTime_now>
     736:	00 91 2e 38 	lds	r16, 0x382E	; 0x80382e <tinyButton_start_time>
     73a:	10 91 2f 38 	lds	r17, 0x382F	; 0x80382f <tinyButton_start_time+0x1>
     73e:	20 91 30 38 	lds	r18, 0x3830	; 0x803830 <tinyButton_start_time+0x2>
     742:	30 91 31 38 	lds	r19, 0x3831	; 0x803831 <tinyButton_start_time+0x3>
     746:	dc 01       	movw	r26, r24
     748:	cb 01       	movw	r24, r22
     74a:	80 1b       	sub	r24, r16
     74c:	91 0b       	sbc	r25, r17
     74e:	a2 0b       	sbc	r26, r18
     750:	b3 0b       	sbc	r27, r19
     752:	81 3d       	cpi	r24, 0xD1	; 209
     754:	97 40       	sbci	r25, 0x07	; 7
     756:	a1 05       	cpc	r26, r1
     758:	b1 05       	cpc	r27, r1
     75a:	78 f0       	brcs	.+30     	; 0x77a <tinyButton_update+0x88>
		{
			tinyPulse_toggle_pulse_mode();
     75c:	0e 94 75 09 	call	0x12ea	; 0x12ea <tinyPulse_toggle_pulse_mode>
			tinyButton_start_time = tinyTime_now();
     760:	0e 94 ec 09 	call	0x13d8	; 0x13d8 <tinyTime_now>
     764:	60 93 2e 38 	sts	0x382E, r22	; 0x80382e <tinyButton_start_time>
     768:	70 93 2f 38 	sts	0x382F, r23	; 0x80382f <tinyButton_start_time+0x1>
     76c:	80 93 30 38 	sts	0x3830, r24	; 0x803830 <tinyButton_start_time+0x2>
     770:	90 93 31 38 	sts	0x3831, r25	; 0x803831 <tinyButton_start_time+0x3>
			// We don't want switching to pulse mode to count as a button press, so we ignore the next button press
			ignore_next_button_press = true;
     774:	81 e0       	ldi	r24, 0x01	; 1
     776:	80 93 32 38 	sts	0x3832, r24	; 0x803832 <ignore_next_button_press>
		}
	}
	if (!button_is_pushed_down && button_was_pushed_down)
     77a:	cc 23       	and	r28, r28
     77c:	71 f0       	breq	.+28     	; 0x79a <tinyButton_update+0xa8>
     77e:	80 91 34 38 	lds	r24, 0x3834	; 0x803834 <button_was_pushed_down>
     782:	88 23       	and	r24, r24
     784:	51 f0       	breq	.+20     	; 0x79a <tinyButton_update+0xa8>
	{
		if(!ignore_next_button_press){
     786:	80 91 32 38 	lds	r24, 0x3832	; 0x803832 <ignore_next_button_press>
     78a:	81 11       	cpse	r24, r1
     78c:	04 c0       	rjmp	.+8      	; 0x796 <tinyButton_update+0xa4>
			button_press = true;
     78e:	81 e0       	ldi	r24, 0x01	; 1
     790:	80 93 33 38 	sts	0x3833, r24	; 0x803833 <button_press>
     794:	02 c0       	rjmp	.+4      	; 0x79a <tinyButton_update+0xa8>
		}
		else{
			ignore_next_button_press = false;
     796:	10 92 32 38 	sts	0x3832, r1	; 0x803832 <ignore_next_button_press>
		}
		
	}
	button_was_pushed_down = button_is_pushed_down;
     79a:	d0 93 34 38 	sts	0x3834, r29	; 0x803834 <button_was_pushed_down>
}
     79e:	df 91       	pop	r29
     7a0:	cf 91       	pop	r28
     7a2:	1f 91       	pop	r17
     7a4:	0f 91       	pop	r16
     7a6:	08 95       	ret

000007a8 <tinyButton_update_potential>:

double tinyButton_update_potential(double potential){
	if(button_press){
     7a8:	20 91 33 38 	lds	r18, 0x3833	; 0x803833 <button_press>
     7ac:	22 23       	and	r18, r18
     7ae:	31 f0       	breq	.+12     	; 0x7bc <tinyButton_update_potential+0x14>
		potential += BUTTON_PRESS_REACTION;
     7b0:	20 e0       	ldi	r18, 0x00	; 0
     7b2:	30 e0       	ldi	r19, 0x00	; 0
     7b4:	40 ed       	ldi	r20, 0xD0	; 208
     7b6:	51 e4       	ldi	r21, 0x41	; 65
     7b8:	0e 94 f6 09 	call	0x13ec	; 0x13ec <__addsf3>
	}
	return potential;
}
     7bc:	08 95       	ret

000007be <tinyCharge_is_connected_to_charger>:
*/
uint8_t charge_counter = 0; 

_Bool tinyCharge_is_connected_to_charger(){
	return connected_to_charger;
}
     7be:	80 91 59 38 	lds	r24, 0x3859	; 0x803859 <connected_to_charger>
     7c2:	08 95       	ret

000007c4 <tinyCharge_is_fully_charged>:
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTB_get_pin_level(const uint8_t pin)
{
	return VPORTB.IN & (1 << pin);
     7c4:	86 b1       	in	r24, 0x06	; 6

_Bool tinyCharge_is_fully_charged(){
	return CHARGING_STATUS_PIN_get_level();
}
     7c6:	86 fb       	bst	r24, 6
     7c8:	88 27       	eor	r24, r24
     7ca:	80 f9       	bld	r24, 0
     7cc:	08 95       	ret

000007ce <tinyCharge_DAC_dissable>:
void tinyCharge_DAC_dissable(){
	
	// We need some way to disable the DAC to prevent huge current draw when charging (64mA). When there is no code uploaded to the attiny, there is no problem.
	// We're going to try to enable the pin as a dendrite, since they seem to be doing fine. Completely uninitializing the pin probably caused a microchip to be fried.
	
	DAC_0_uninit();
     7ce:	0e 94 18 01 	call	0x230	; 0x230 <DAC_0_uninit>
	DAC_0_disable();
     7d2:	0e 94 23 01 	call	0x246	; 0x246 <DAC_0_disable>
     7d6:	08 95       	ret

000007d8 <tinyCharge_DAC_enable>:
void tinyCharge_DAC_enable(){
	
	// We need some way to disable the DAC to prevent huge current draw when charging (64mA). When there is no code uploaded to the attiny, there is no problem.
	// We're going to try to enable the pin as a dendrite, since they seem to be doing fine. Completely uninitializing the pin probably caused a microchip to be fried.
	
	DAC_0_init();
     7d8:	0e 94 13 01 	call	0x226	; 0x226 <DAC_0_init>
	DAC_0_enable();
     7dc:	0e 94 1d 01 	call	0x23a	; 0x23a <DAC_0_enable>
     7e0:	08 95       	ret

000007e2 <tinyCharge_switch_mode>:
}


void tinyCharge_switch_mode(){
	
	if(connected_to_charger){
     7e2:	80 91 59 38 	lds	r24, 0x3859	; 0x803859 <connected_to_charger>
     7e6:	88 23       	and	r24, r24
     7e8:	89 f0       	breq	.+34     	; 0x80c <tinyCharge_switch_mode+0x2a>
		// Switch from main to charging mode
		
		// Set LED
		tinyLED_set_color_mode(OUT_LED, CHARGING_COLOR, SWING);
     7ea:	43 e0       	ldi	r20, 0x03	; 3
     7ec:	62 e0       	ldi	r22, 0x02	; 2
     7ee:	81 e0       	ldi	r24, 0x01	; 1
     7f0:	0e 94 c9 05 	call	0xb92	; 0xb92 <tinyLED_set_color_mode>
		tinyLED_set_color(INN_LED, LED_OFF);
     7f4:	60 e0       	ldi	r22, 0x00	; 0
     7f6:	80 e0       	ldi	r24, 0x00	; 0
     7f8:	0e 94 0e 06 	call	0xc1c	; 0xc1c <tinyLED_set_color>


		// Stop axon from firing
		// (There is a small chance that the neuron is put into charging mode as it is firing. The axon is then never told to stop firing)
		tinyAxon_stop_sending_pulse();
     7fc:	0e 94 98 02 	call	0x530	; 0x530 <tinyAxon_stop_sending_pulse>

		// disable DAC
		tinyCharge_DAC_dissable();
     800:	0e 94 e7 03 	call	0x7ce	; 0x7ce <tinyCharge_DAC_dissable>
		
		// We also turn off pulse mode, because it's confusing if it suddenly comes on
		// after it has been charging
		tinyPulse_set_pulse_mode(false);
     804:	80 e0       	ldi	r24, 0x00	; 0
     806:	0e 94 88 09 	call	0x1310	; 0x1310 <tinyPulse_set_pulse_mode>
     80a:	08 95       	ret
	}
	else{
		// Switch from charge to main mode
		
		// Set LED
		tinyLED_set_color(OUT_LED, LED_OFF);
     80c:	60 e0       	ldi	r22, 0x00	; 0
     80e:	81 e0       	ldi	r24, 0x01	; 1
     810:	0e 94 0e 06 	call	0xc1c	; 0xc1c <tinyLED_set_color>
		tinyLED_set_color(INN_LED, LED_OFF);
     814:	60 e0       	ldi	r22, 0x00	; 0
     816:	80 e0       	ldi	r24, 0x00	; 0
     818:	0e 94 0e 06 	call	0xc1c	; 0xc1c <tinyLED_set_color>
		
		// enable DAC
		tinyCharge_DAC_enable();
     81c:	0e 94 ec 03 	call	0x7d8	; 0x7d8 <tinyCharge_DAC_enable>
     820:	08 95       	ret

00000822 <tinyCharge_set_charging_mode>:
	}
}

void tinyCharge_set_charging_mode(_Bool charging_status){
	if(charging_status != connected_to_charger){
     822:	90 91 59 38 	lds	r25, 0x3859	; 0x803859 <connected_to_charger>
     826:	98 17       	cp	r25, r24
     828:	21 f0       	breq	.+8      	; 0x832 <tinyCharge_set_charging_mode+0x10>
		connected_to_charger = charging_status;
     82a:	80 93 59 38 	sts	0x3859, r24	; 0x803859 <connected_to_charger>
		tinyCharge_switch_mode();
     82e:	0e 94 f1 03 	call	0x7e2	; 0x7e2 <tinyCharge_switch_mode>
     832:	08 95       	ret

00000834 <tinyCharge_update_charging_mode>:

/*
Checks if the levels of the dendrites and axon are at charging levels
and updates the mode accordingly
*/
void tinyCharge_update_charging_mode(){
     834:	cf 93       	push	r28
	// For complicated reasons, the axon_check_level will be high even when the charger is not connected
	// WHEN the neuron is in charging mode, hence we ignore the axon level when the neuron is in charging mode
	_Bool charging;
	if(connected_to_charger){
     836:	80 91 59 38 	lds	r24, 0x3859	; 0x803859 <connected_to_charger>
     83a:	88 23       	and	r24, r24
     83c:	21 f0       	breq	.+8      	; 0x846 <tinyCharge_update_charging_mode+0x12>
		charging = tinyDendrite_check_charge_level();
     83e:	0e 94 83 04 	call	0x906	; 0x906 <tinyDendrite_check_charge_level>
     842:	c8 2f       	mov	r28, r24
     844:	0b c0       	rjmp	.+22     	; 0x85c <tinyCharge_update_charging_mode+0x28>
	} else{
		charging = tinyDendrite_check_charge_level() || tinyAxon_check_charge_level();
     846:	0e 94 83 04 	call	0x906	; 0x906 <tinyDendrite_check_charge_level>
     84a:	81 11       	cpse	r24, r1
     84c:	03 c0       	rjmp	.+6      	; 0x854 <tinyCharge_update_charging_mode+0x20>
     84e:	0e 94 6e 03 	call	0x6dc	; 0x6dc <tinyAxon_check_charge_level>
     852:	02 c0       	rjmp	.+4      	; 0x858 <tinyCharge_update_charging_mode+0x24>
     854:	81 e0       	ldi	r24, 0x01	; 1
     856:	90 e0       	ldi	r25, 0x00	; 0
     858:	c8 2f       	mov	r28, r24
     85a:	c1 70       	andi	r28, 0x01	; 1
	}
	
	// In order to prevent the axon from stimulating itself, we only switch into charging mode when the conditions have been right for several cycles
	if(!connected_to_charger && charging){
     85c:	80 91 59 38 	lds	r24, 0x3859	; 0x803859 <connected_to_charger>
     860:	81 11       	cpse	r24, r1
     862:	0d c0       	rjmp	.+26     	; 0x87e <tinyCharge_update_charging_mode+0x4a>
     864:	cc 23       	and	r28, r28
     866:	d1 f0       	breq	.+52     	; 0x89c <tinyCharge_update_charging_mode+0x68>
		charge_counter++;
     868:	80 91 35 38 	lds	r24, 0x3835	; 0x803835 <charge_counter>
     86c:	8f 5f       	subi	r24, 0xFF	; 255
		if(charge_counter > CYCLES_REQUIRED_FOR_CHARGING_MODE_SWITCH){
     86e:	8b 30       	cpi	r24, 0x0B	; 11
     870:	90 f0       	brcs	.+36     	; 0x896 <tinyCharge_update_charging_mode+0x62>
			charge_counter = 0;
     872:	10 92 35 38 	sts	0x3835, r1	; 0x803835 <charge_counter>
			tinyCharge_set_charging_mode(charging);
     876:	81 e0       	ldi	r24, 0x01	; 1
     878:	0e 94 11 04 	call	0x822	; 0x822 <tinyCharge_set_charging_mode>
     87c:	13 c0       	rjmp	.+38     	; 0x8a4 <tinyCharge_update_charging_mode+0x70>
		}
	}
	else{
		tinyCharge_set_charging_mode(charging);
     87e:	8c 2f       	mov	r24, r28
     880:	0e 94 11 04 	call	0x822	; 0x822 <tinyCharge_set_charging_mode>
	}
	
	// We have to prevent charge_counters from accumulating over time
	if(!charging && charge_counter>0){
     884:	c1 11       	cpse	r28, r1
     886:	0e c0       	rjmp	.+28     	; 0x8a4 <tinyCharge_update_charging_mode+0x70>
     888:	80 91 35 38 	lds	r24, 0x3835	; 0x803835 <charge_counter>
     88c:	88 23       	and	r24, r24
     88e:	51 f0       	breq	.+20     	; 0x8a4 <tinyCharge_update_charging_mode+0x70>
		charge_counter = 0;
     890:	10 92 35 38 	sts	0x3835, r1	; 0x803835 <charge_counter>
	}
	
}
     894:	07 c0       	rjmp	.+14     	; 0x8a4 <tinyCharge_update_charging_mode+0x70>
		charging = tinyDendrite_check_charge_level() || tinyAxon_check_charge_level();
	}
	
	// In order to prevent the axon from stimulating itself, we only switch into charging mode when the conditions have been right for several cycles
	if(!connected_to_charger && charging){
		charge_counter++;
     896:	80 93 35 38 	sts	0x3835, r24	; 0x803835 <charge_counter>
     89a:	04 c0       	rjmp	.+8      	; 0x8a4 <tinyCharge_update_charging_mode+0x70>
			charge_counter = 0;
			tinyCharge_set_charging_mode(charging);
		}
	}
	else{
		tinyCharge_set_charging_mode(charging);
     89c:	8c 2f       	mov	r24, r28
     89e:	0e 94 11 04 	call	0x822	; 0x822 <tinyCharge_set_charging_mode>
     8a2:	f2 cf       	rjmp	.-28     	; 0x888 <tinyCharge_update_charging_mode+0x54>
	// We have to prevent charge_counters from accumulating over time
	if(!charging && charge_counter>0){
		charge_counter = 0;
	}
	
}
     8a4:	cf 91       	pop	r28
     8a6:	08 95       	ret

000008a8 <tinyCharge_set_transistors>:



void tinyCharge_set_transistors(){
	if(connected_to_charger){
     8a8:	80 91 59 38 	lds	r24, 0x3859	; 0x803859 <connected_to_charger>
     8ac:	88 23       	and	r24, r24
     8ae:	19 f0       	breq	.+6      	; 0x8b6 <tinyCharge_set_transistors+0xe>
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
	} else {
		VPORTC.OUT &= ~(1 << pin);
     8b0:	4d 98       	cbi	0x09, 5	; 9
 *                  false = Pin level set to "low" state
 */
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
     8b2:	29 9a       	sbi	0x05, 1	; 5
     8b4:	08 95       	ret
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     8b6:	4d 9a       	sbi	0x09, 5	; 9
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     8b8:	29 98       	cbi	0x05, 1	; 5
     8ba:	08 95       	ret

000008bc <tinyDebugger_send_int>:
		char number[20]; // Arbitrary max
		dtostrf(value,1,NUMBER_OF_DECIMALS, number);
		printf("%s:%5s\t", name, number);
	}
}
void tinyDebugger_send_string(const char* name, char * value){
     8bc:	08 95       	ret

000008be <tinyDebugger_send_uint32>:
     8be:	08 95       	ret

000008c0 <tinyDebugger_send_uint8>:
     8c0:	08 95       	ret

000008c2 <tinyDebugger_send_double>:
     8c2:	08 95       	ret

000008c4 <tinyDebugger_end_line>:
	if(DEBUGGING){
		printf("%s:%s\t", name, value);
	}
}
void tinyDebugger_end_line(){
     8c4:	08 95       	ret

000008c6 <tinyDendrite_read_signals>:
	}
}

uint8_t tinyDendrite_get_value(uint8_t dendrite_number){
	return tinyDendrite_values[dendrite_number];
}
     8c6:	ef 92       	push	r14
     8c8:	ff 92       	push	r15
     8ca:	0f 93       	push	r16
     8cc:	1f 93       	push	r17
     8ce:	cf 93       	push	r28
     8d0:	df 93       	push	r29
     8d2:	ce e0       	ldi	r28, 0x0E	; 14
     8d4:	d8 e3       	ldi	r29, 0x38	; 56
     8d6:	00 e4       	ldi	r16, 0x40	; 64
     8d8:	18 e3       	ldi	r17, 0x38	; 56
     8da:	0f 2e       	mov	r0, r31
     8dc:	f3 e1       	ldi	r31, 0x13	; 19
     8de:	ef 2e       	mov	r14, r31
     8e0:	f8 e3       	ldi	r31, 0x38	; 56
     8e2:	ff 2e       	mov	r15, r31
     8e4:	f0 2d       	mov	r31, r0
     8e6:	89 91       	ld	r24, Y+
     8e8:	0e 94 dd 00 	call	0x1ba	; 0x1ba <ADC_0_get_conversion>
     8ec:	f8 01       	movw	r30, r16
     8ee:	81 93       	st	Z+, r24
     8f0:	8f 01       	movw	r16, r30
     8f2:	ce 15       	cp	r28, r14
     8f4:	df 05       	cpc	r29, r15
     8f6:	b9 f7       	brne	.-18     	; 0x8e6 <tinyDendrite_read_signals+0x20>
     8f8:	df 91       	pop	r29
     8fa:	cf 91       	pop	r28
     8fc:	1f 91       	pop	r17
     8fe:	0f 91       	pop	r16
     900:	ff 90       	pop	r15
     902:	ef 90       	pop	r14
     904:	08 95       	ret

00000906 <tinyDendrite_check_charge_level>:

_Bool tinyDendrite_check_charge_level(void)
{
     906:	cf 93       	push	r28
     908:	df 93       	push	r29
	_Bool charging = false;
	
	tinyDendrite_read_signals();
     90a:	0e 94 63 04 	call	0x8c6	; 0x8c6 <tinyDendrite_read_signals>
     90e:	eb e3       	ldi	r30, 0x3B	; 59
     910:	f8 e3       	ldi	r31, 0x38	; 56
     912:	c6 e3       	ldi	r28, 0x36	; 54
     914:	d8 e3       	ldi	r29, 0x38	; 56
     916:	a0 e4       	ldi	r26, 0x40	; 64
     918:	b8 e3       	ldi	r27, 0x38	; 56
     91a:	20 e4       	ldi	r18, 0x40	; 64
     91c:	38 e3       	ldi	r19, 0x38	; 56
	return tinyDendrite_values[dendrite_number];
}

_Bool tinyDendrite_check_charge_level(void)
{
	_Bool charging = false;
     91e:	80 e0       	ldi	r24, 0x00	; 0
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = CHARGING;
     920:	47 e0       	ldi	r20, 0x07	; 7
	_Bool charging = false;
	
	tinyDendrite_read_signals();
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
     922:	90 81       	ld	r25, Z
     924:	99 93       	st	Y+, r25
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
     926:	9d 91       	ld	r25, X+
     928:	9f 3f       	cpi	r25, 0xFF	; 255
     92a:	11 f4       	brne	.+4      	; 0x930 <tinyDendrite_check_charge_level+0x2a>
		{
			tinyDendrite_current_signals[i] = CHARGING;
     92c:	40 83       	st	Z, r20
			charging = true;
     92e:	81 e0       	ldi	r24, 0x01	; 1
     930:	31 96       	adiw	r30, 0x01	; 1
_Bool tinyDendrite_check_charge_level(void)
{
	_Bool charging = false;
	
	tinyDendrite_read_signals();
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
     932:	e2 17       	cp	r30, r18
     934:	f3 07       	cpc	r31, r19
     936:	a9 f7       	brne	.-22     	; 0x922 <tinyDendrite_check_charge_level+0x1c>
			tinyDendrite_current_signals[i] = CHARGING;
			charging = true;
		}
	}
	return charging;
}
     938:	df 91       	pop	r29
     93a:	cf 91       	pop	r28
     93c:	08 95       	ret

0000093e <tinyDendrite_update_signals>:

/*
This function converts the 8 bit value from the ADC into one of the signal types defined in DendriteSignal
*/
void tinyDendrite_update_signals(void)
{
     93e:	af 92       	push	r10
     940:	bf 92       	push	r11
     942:	df 92       	push	r13
     944:	ef 92       	push	r14
     946:	ff 92       	push	r15
     948:	0f 93       	push	r16
     94a:	1f 93       	push	r17
     94c:	cf 93       	push	r28
     94e:	df 93       	push	r29
	
	// This function does not read the dendrite values! Read_signals must be called somewhere prior to this function!
	// As of writing this, the update_charging_mode function in main runs check_charge_level, so 
	// the tinyDendrite_values are updated when update_signals is called later
	
	tinyDebugger_send_uint8("D1", tinyDendrite_values[0]);
     950:	c0 e4       	ldi	r28, 0x40	; 64
     952:	d8 e3       	ldi	r29, 0x38	; 56
     954:	68 81       	ld	r22, Y
     956:	8d e7       	ldi	r24, 0x7D	; 125
     958:	9b e9       	ldi	r25, 0x9B	; 155
     95a:	0e 94 60 04 	call	0x8c0	; 0x8c0 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D2", tinyDendrite_values[1]);
     95e:	69 81       	ldd	r22, Y+1	; 0x01
     960:	80 e8       	ldi	r24, 0x80	; 128
     962:	9b e9       	ldi	r25, 0x9B	; 155
     964:	0e 94 60 04 	call	0x8c0	; 0x8c0 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D3", tinyDendrite_values[2]);
     968:	6a 81       	ldd	r22, Y+2	; 0x02
     96a:	83 e8       	ldi	r24, 0x83	; 131
     96c:	9b e9       	ldi	r25, 0x9B	; 155
     96e:	0e 94 60 04 	call	0x8c0	; 0x8c0 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D4", tinyDendrite_values[3]);
     972:	6b 81       	ldd	r22, Y+3	; 0x03
     974:	86 e8       	ldi	r24, 0x86	; 134
     976:	9b e9       	ldi	r25, 0x9B	; 155
     978:	0e 94 60 04 	call	0x8c0	; 0x8c0 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D5", tinyDendrite_values[4]);
     97c:	6c 81       	ldd	r22, Y+4	; 0x04
     97e:	89 e8       	ldi	r24, 0x89	; 137
     980:	9b e9       	ldi	r25, 0x9B	; 155
     982:	0e 94 60 04 	call	0x8c0	; 0x8c0 <tinyDebugger_send_uint8>
     986:	eb e3       	ldi	r30, 0x3B	; 59
     988:	f8 e3       	ldi	r31, 0x38	; 56
     98a:	26 e3       	ldi	r18, 0x36	; 54
     98c:	38 e3       	ldi	r19, 0x38	; 56
     98e:	5e 01       	movw	r10, r28
     990:	40 e4       	ldi	r20, 0x40	; 64
     992:	58 e3       	ldi	r21, 0x38	; 56
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     994:	dd 24       	eor	r13, r13
     996:	d3 94       	inc	r13
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
		}
		else if (tinyDendrite_values[i] > HIGH_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
     998:	0f 2e       	mov	r0, r31
     99a:	f3 e0       	ldi	r31, 0x03	; 3
     99c:	ef 2e       	mov	r14, r31
     99e:	f0 2d       	mov	r31, r0
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     9a0:	68 94       	set
     9a2:	ff 24       	eor	r15, r15
     9a4:	f1 f8       	bld	r15, 1
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     9a6:	04 e0       	ldi	r16, 0x04	; 4
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     9a8:	16 e0       	ldi	r17, 0x06	; 6
			// been moved to tinyDendrite_check_charging.
			//charging = true;
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     9aa:	65 e0       	ldi	r22, 0x05	; 5
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = CHARGING;
     9ac:	77 e0       	ldi	r23, 0x07	; 7
     9ae:	df 01       	movw	r26, r30
	tinyDebugger_send_uint8("D4", tinyDendrite_values[3]);
	tinyDebugger_send_uint8("D5", tinyDendrite_values[4]);
	
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
     9b0:	90 81       	ld	r25, Z
     9b2:	e9 01       	movw	r28, r18
     9b4:	99 93       	st	Y+, r25
     9b6:	9e 01       	movw	r18, r28
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
     9b8:	e5 01       	movw	r28, r10
     9ba:	89 91       	ld	r24, Y+
     9bc:	5e 01       	movw	r10, r28
     9be:	8f 3f       	cpi	r24, 0xFF	; 255
     9c0:	11 f4       	brne	.+4      	; 0x9c6 <tinyDendrite_update_signals+0x88>
		{
			tinyDendrite_current_signals[i] = CHARGING;
     9c2:	70 83       	st	Z, r23
     9c4:	19 c0       	rjmp	.+50     	; 0x9f8 <tinyDendrite_update_signals+0xba>
			// Previously, we used this function to check charging, but this has now
			// been moved to tinyDendrite_check_charging.
			//charging = true;
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
     9c6:	8b 3d       	cpi	r24, 0xDB	; 219
     9c8:	10 f0       	brcs	.+4      	; 0x9ce <tinyDendrite_update_signals+0x90>
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     9ca:	60 83       	st	Z, r22
     9cc:	15 c0       	rjmp	.+42     	; 0x9f8 <tinyDendrite_update_signals+0xba>
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
     9ce:	86 3b       	cpi	r24, 0xB6	; 182
     9d0:	10 f0       	brcs	.+4      	; 0x9d6 <tinyDendrite_update_signals+0x98>
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     9d2:	10 83       	st	Z, r17
     9d4:	11 c0       	rjmp	.+34     	; 0x9f8 <tinyDendrite_update_signals+0xba>
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
     9d6:	82 39       	cpi	r24, 0x92	; 146
     9d8:	10 f0       	brcs	.+4      	; 0x9de <tinyDendrite_update_signals+0xa0>
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     9da:	00 83       	st	Z, r16
     9dc:	0d c0       	rjmp	.+26     	; 0x9f8 <tinyDendrite_update_signals+0xba>
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
     9de:	85 36       	cpi	r24, 0x65	; 101
     9e0:	10 f0       	brcs	.+4      	; 0x9e6 <tinyDendrite_update_signals+0xa8>
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     9e2:	f0 82       	st	Z, r15
     9e4:	09 c0       	rjmp	.+18     	; 0x9f8 <tinyDendrite_update_signals+0xba>
		}
		else if (tinyDendrite_values[i] > HIGH_INHIB_THRESHOLD)
     9e6:	8a 34       	cpi	r24, 0x4A	; 74
     9e8:	10 f0       	brcs	.+4      	; 0x9ee <tinyDendrite_update_signals+0xb0>
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
     9ea:	e0 82       	st	Z, r14
     9ec:	05 c0       	rjmp	.+10     	; 0x9f8 <tinyDendrite_update_signals+0xba>
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
     9ee:	85 32       	cpi	r24, 0x25	; 37
     9f0:	10 f0       	brcs	.+4      	; 0x9f6 <tinyDendrite_update_signals+0xb8>
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     9f2:	d0 82       	st	Z, r13
     9f4:	01 c0       	rjmp	.+2      	; 0x9f8 <tinyDendrite_update_signals+0xba>
		}
		else
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     9f6:	10 82       	st	Z, r1
		}
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
     9f8:	8c 91       	ld	r24, X
     9fa:	98 13       	cpse	r25, r24
     9fc:	01 c0       	rjmp	.+2      	; 0xa00 <tinyDendrite_update_signals+0xc2>
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     9fe:	1c 92       	st	X, r1
     a00:	31 96       	adiw	r30, 0x01	; 1
	tinyDebugger_send_uint8("D2", tinyDendrite_values[1]);
	tinyDebugger_send_uint8("D3", tinyDendrite_values[2]);
	tinyDebugger_send_uint8("D4", tinyDendrite_values[3]);
	tinyDebugger_send_uint8("D5", tinyDendrite_values[4]);
	
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
     a02:	e4 17       	cp	r30, r20
     a04:	f5 07       	cpc	r31, r21
     a06:	99 f6       	brne	.-90     	; 0x9ae <tinyDendrite_update_signals+0x70>
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
		}
	}
}
     a08:	df 91       	pop	r29
     a0a:	cf 91       	pop	r28
     a0c:	1f 91       	pop	r17
     a0e:	0f 91       	pop	r16
     a10:	ff 90       	pop	r15
     a12:	ef 90       	pop	r14
     a14:	df 90       	pop	r13
     a16:	bf 90       	pop	r11
     a18:	af 90       	pop	r10
     a1a:	08 95       	ret

00000a1c <tinyDendrite_get_potential>:
/*
This is the master function of the module that is callable from
outside. It uses the previously declared functions to return the potential.
*/
int16_t tinyDendrite_get_potential()
{
     a1c:	ef 92       	push	r14
     a1e:	ff 92       	push	r15
     a20:	0f 93       	push	r16
     a22:	1f 93       	push	r17
     a24:	cf 93       	push	r28
     a26:	df 93       	push	r29
	if(tinyAxon_is_firing() && IGNORE_INPUT_WHILE_FIRING){
     a28:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <tinyAxon_is_firing>
		
		return NO_SIGNAL_REACTION;
	}
	
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
     a2c:	0e 94 9f 04 	call	0x93e	; 0x93e <tinyDendrite_update_signals>
     a30:	cb e3       	ldi	r28, 0x3B	; 59
     a32:	d8 e3       	ldi	r29, 0x38	; 56
     a34:	0f 2e       	mov	r0, r31
     a36:	f0 e4       	ldi	r31, 0x40	; 64
     a38:	ef 2e       	mov	r14, r31
     a3a:	f8 e3       	ldi	r31, 0x38	; 56
     a3c:	ff 2e       	mov	r15, r31
     a3e:	f0 2d       	mov	r31, r0
	
	int16_t return_potential_val = 0;
     a40:	00 e0       	ldi	r16, 0x00	; 0
     a42:	10 e0       	ldi	r17, 0x00	; 0
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		switch(tinyDendrite_current_signals[i])
     a44:	89 91       	ld	r24, Y+
     a46:	83 30       	cpi	r24, 0x03	; 3
     a48:	f1 f0       	breq	.+60     	; 0xa86 <tinyDendrite_get_potential+0x6a>
     a4a:	28 f4       	brcc	.+10     	; 0xa56 <tinyDendrite_get_potential+0x3a>
     a4c:	81 30       	cpi	r24, 0x01	; 1
     a4e:	31 f1       	breq	.+76     	; 0xa9c <tinyDendrite_get_potential+0x80>
     a50:	82 30       	cpi	r24, 0x02	; 2
     a52:	09 f1       	breq	.+66     	; 0xa96 <tinyDendrite_get_potential+0x7a>
     a54:	2a c0       	rjmp	.+84     	; 0xaaa <tinyDendrite_get_potential+0x8e>
     a56:	85 30       	cpi	r24, 0x05	; 5
     a58:	59 f0       	breq	.+22     	; 0xa70 <tinyDendrite_get_potential+0x54>
     a5a:	68 f0       	brcs	.+26     	; 0xa76 <tinyDendrite_get_potential+0x5a>
     a5c:	86 30       	cpi	r24, 0x06	; 6
     a5e:	29 f5       	brne	.+74     	; 0xaaa <tinyDendrite_get_potential+0x8e>
		{
			case NO_SIGNAL:
				return_potential_val += NO_SIGNAL_REACTION;
				break;
			case HIGH_EXCITE:
				return_potential_val += HIGH_EXCITE_REACTION;
     a60:	0c 5c       	subi	r16, 0xCC	; 204
     a62:	1f 4f       	sbci	r17, 0xFF	; 255
				//tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
				tinyLED_set_color_mode(OUT_LED, BLUE, FLASH_ONCE);
     a64:	45 e0       	ldi	r20, 0x05	; 5
     a66:	63 e0       	ldi	r22, 0x03	; 3
     a68:	81 e0       	ldi	r24, 0x01	; 1
     a6a:	0e 94 c9 05 	call	0xb92	; 0xb92 <tinyLED_set_color_mode>
				break;
     a6e:	1d c0       	rjmp	.+58     	; 0xaaa <tinyDendrite_get_potential+0x8e>
			case NORMAL_EXCITE:
				return_potential_val += NORMAL_EXCITE_REACTION;
     a70:	07 5e       	subi	r16, 0xE7	; 231
     a72:	1f 4f       	sbci	r17, 0xFF	; 255
				//tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
				break;
     a74:	1a c0       	rjmp	.+52     	; 0xaaa <tinyDendrite_get_potential+0x8e>
			case LOW_EXCITE:
				return_potential_val += LOW_EXCITE_REACTION;
     a76:	0c 5e       	subi	r16, 0xEC	; 236
     a78:	1f 4f       	sbci	r17, 0xFF	; 255
				//tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
				tinyLED_set_color_mode(OUT_LED, YELLOW, FLASH_ONCE);
     a7a:	45 e0       	ldi	r20, 0x05	; 5
     a7c:	65 e0       	ldi	r22, 0x05	; 5
     a7e:	81 e0       	ldi	r24, 0x01	; 1
     a80:	0e 94 c9 05 	call	0xb92	; 0xb92 <tinyLED_set_color_mode>
				break;
     a84:	12 c0       	rjmp	.+36     	; 0xaaa <tinyDendrite_get_potential+0x8e>
			case HIGH_INHIB:
				return_potential_val += HIGH_INHIB_REACTION;
     a86:	02 53       	subi	r16, 0x32	; 50
     a88:	11 09       	sbc	r17, r1
				//tinyLED_set_color_mode(INN_LED, RED, FLASH_ONCE);
				tinyLED_set_color_mode(OUT_LED, BLUE, FLASH_ONCE);
     a8a:	45 e0       	ldi	r20, 0x05	; 5
     a8c:	63 e0       	ldi	r22, 0x03	; 3
     a8e:	81 e0       	ldi	r24, 0x01	; 1
     a90:	0e 94 c9 05 	call	0xb92	; 0xb92 <tinyLED_set_color_mode>
				break;
     a94:	0a c0       	rjmp	.+20     	; 0xaaa <tinyDendrite_get_potential+0x8e>
			case NORMAL_INHIB:
				return_potential_val += NORMAL_INHIB_REACTION;
     a96:	09 51       	subi	r16, 0x19	; 25
     a98:	11 09       	sbc	r17, r1
				//tinyLED_set_color_mode(INN_LED, RED, FLASH_ONCE);
				break;
     a9a:	07 c0       	rjmp	.+14     	; 0xaaa <tinyDendrite_get_potential+0x8e>
			case LOW_INHIB:
				return_potential_val += LOW_INHIB_REACTION;
     a9c:	04 51       	subi	r16, 0x14	; 20
     a9e:	11 09       	sbc	r17, r1
				//tinyLED_set_color_mode(INN_LED, RED, FLASH_ONCE);
				tinyLED_set_color_mode(OUT_LED, YELLOW, FLASH_ONCE);
     aa0:	45 e0       	ldi	r20, 0x05	; 5
     aa2:	65 e0       	ldi	r22, 0x05	; 5
     aa4:	81 e0       	ldi	r24, 0x01	; 1
     aa6:	0e 94 c9 05 	call	0xb92	; 0xb92 <tinyLED_set_color_mode>
	
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
	
	int16_t return_potential_val = 0;
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
     aaa:	ce 15       	cp	r28, r14
     aac:	df 05       	cpc	r29, r15
     aae:	51 f6       	brne	.-108    	; 0xa44 <tinyDendrite_get_potential+0x28>
			default:
				break;
		}
	}
	
	tinyDebugger_send_int("ReturnP", return_potential_val);
     ab0:	b8 01       	movw	r22, r16
     ab2:	8c e8       	ldi	r24, 0x8C	; 140
     ab4:	9b e9       	ldi	r25, 0x9B	; 155
     ab6:	0e 94 5e 04 	call	0x8bc	; 0x8bc <tinyDebugger_send_int>
	
	
	return return_potential_val;
	
}
     aba:	c8 01       	movw	r24, r16
     abc:	df 91       	pop	r29
     abe:	cf 91       	pop	r28
     ac0:	1f 91       	pop	r17
     ac2:	0f 91       	pop	r16
     ac4:	ff 90       	pop	r15
     ac6:	ef 90       	pop	r14
     ac8:	08 95       	ret

00000aca <tinyDendrite_update_potential>:

double tinyDendrite_update_potential(double potential){
     aca:	cf 92       	push	r12
     acc:	df 92       	push	r13
     ace:	ef 92       	push	r14
     ad0:	ff 92       	push	r15
     ad2:	6b 01       	movw	r12, r22
     ad4:	7c 01       	movw	r14, r24
	
	int16_t potential_change = tinyDendrite_get_potential();
     ad6:	0e 94 0e 05 	call	0xa1c	; 0xa1c <tinyDendrite_get_potential>
	/*
	We DON'T want to signal that we have recived a signal, we want to signal that the potential has changed!
	We could send flashes from here, but instead, I'll try to implement a light mode that is constantly communicating the value of the potential.
	*/
	
	return potential;
     ada:	bc 01       	movw	r22, r24
     adc:	99 0f       	add	r25, r25
     ade:	88 0b       	sbc	r24, r24
     ae0:	99 0b       	sbc	r25, r25
     ae2:	0e 94 4b 0b 	call	0x1696	; 0x1696 <__floatsisf>
     ae6:	a7 01       	movw	r20, r14
     ae8:	96 01       	movw	r18, r12
     aea:	0e 94 f6 09 	call	0x13ec	; 0x13ec <__addsf3>
     aee:	ff 90       	pop	r15
     af0:	ef 90       	pop	r14
     af2:	df 90       	pop	r13
     af4:	cf 90       	pop	r12
     af6:	08 95       	ret

00000af8 <__vector_6>:
This function is called every time the RTC (Real Time Clock) counter overflows.
With the current settings, it will be called every ms.
The RTC clock runs at 1kHz, and the number of cycles before overflow is set with RTC.PER = someHexValue (e.g. 0x20) in src/rtc.c
*/
ISR(RTC_CNT_vect)
{
     af8:	1f 92       	push	r1
     afa:	0f 92       	push	r0
     afc:	0f b6       	in	r0, 0x3f	; 63
     afe:	0f 92       	push	r0
     b00:	11 24       	eor	r1, r1
     b02:	2f 93       	push	r18
     b04:	3f 93       	push	r19
     b06:	4f 93       	push	r20
     b08:	5f 93       	push	r21
     b0a:	6f 93       	push	r22
     b0c:	7f 93       	push	r23
     b0e:	8f 93       	push	r24
     b10:	9f 93       	push	r25
     b12:	af 93       	push	r26
     b14:	bf 93       	push	r27
     b16:	cf 93       	push	r28
     b18:	ef 93       	push	r30
     b1a:	ff 93       	push	r31
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     b1c:	c1 e0       	ldi	r28, 0x01	; 1
     b1e:	c0 93 45 38 	sts	0x3845, r28	; 0x803845 <tinyISR_interrupt_flag>
{
	// Set flag to let main loop run a new cycle
	tinyISR_setflag(true);
	
	// Timer counter incrementation
	tinyTime_counter_increment();
     b22:	0e 94 d8 09 	call	0x13b0	; 0x13b0 <tinyTime_counter_increment>

	/* Overflow interrupt flag has to be cleared manually */
	RTC.INTFLAGS = RTC_OVF_bm;
     b26:	c0 93 43 01 	sts	0x0143, r28	; 0x800143 <__TEXT_REGION_LENGTH__+0x700143>
}
     b2a:	ff 91       	pop	r31
     b2c:	ef 91       	pop	r30
     b2e:	cf 91       	pop	r28
     b30:	bf 91       	pop	r27
     b32:	af 91       	pop	r26
     b34:	9f 91       	pop	r25
     b36:	8f 91       	pop	r24
     b38:	7f 91       	pop	r23
     b3a:	6f 91       	pop	r22
     b3c:	5f 91       	pop	r21
     b3e:	4f 91       	pop	r20
     b40:	3f 91       	pop	r19
     b42:	2f 91       	pop	r18
     b44:	0f 90       	pop	r0
     b46:	0f be       	out	0x3f, r0	; 63
     b48:	0f 90       	pop	r0
     b4a:	1f 90       	pop	r1
     b4c:	18 95       	reti

00000b4e <tinyISR_setflag>:
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     b4e:	80 93 45 38 	sts	0x3845, r24	; 0x803845 <tinyISR_interrupt_flag>
     b52:	08 95       	ret

00000b54 <tinyISR_getflag>:
}

_Bool tinyISR_getflag(void)
{
	return tinyISR_interrupt_flag;
}
     b54:	80 91 45 38 	lds	r24, 0x3845	; 0x803845 <tinyISR_interrupt_flag>
     b58:	08 95       	ret

00000b5a <tinyLED_SPIWriteByte>:
Function used to send a byte over SPI, which in turn gets
translated to the bit-sequence required by the LEDs over the CCL.
*/
static void tinyLED_SPIWriteByte(uint8_t byte)
{
	SPI0.INTFLAGS = SPI0_INTFLAGS; // clear the write collision flag to allow writing
     b5a:	90 91 23 08 	lds	r25, 0x0823	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
     b5e:	90 93 23 08 	sts	0x0823, r25	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
	TCA0.SINGLE.CNT = 0; // reset TCA counter register to ensure the first rising edge of the PWM is predictable
     b62:	e0 e0       	ldi	r30, 0x00	; 0
     b64:	fa e0       	ldi	r31, 0x0A	; 10
     b66:	10 a2       	std	Z+32, r1	; 0x20
     b68:	11 a2       	std	Z+33, r1	; 0x21
	
	// start TCA
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 1 << TCA_SPLIT_ENABLE_bp;
     b6a:	91 e0       	ldi	r25, 0x01	; 1
     b6c:	90 83       	st	Z, r25
	SPI0_DATA = byte;
     b6e:	80 93 24 08 	sts	0x0824, r24	; 0x800824 <__TEXT_REGION_LENGTH__+0x700824>

	while((SPI0.INTFLAGS & SPI_RXCIE_bm) == 0){} // wait for transfer to complete
     b72:	e0 e2       	ldi	r30, 0x20	; 32
     b74:	f8 e0       	ldi	r31, 0x08	; 8
     b76:	83 81       	ldd	r24, Z+3	; 0x03
     b78:	88 23       	and	r24, r24
     b7a:	ec f7       	brge	.-6      	; 0xb76 <tinyLED_SPIWriteByte+0x1c>
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 0 << TCA_SPLIT_ENABLE_bp; //Stop TCA
     b7c:	10 92 00 0a 	sts	0x0A00, r1	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
     b80:	08 95       	ret

00000b82 <tinyLED_get_color>:
	tinyLED_set_color_mode(LED_id, color, STABLE);
}

enum Colors tinyLED_get_color(uint8_t LED_id)
{
	return tinyLED_settings[LED_id].color;
     b82:	e8 2f       	mov	r30, r24
     b84:	f0 e0       	ldi	r31, 0x00	; 0
     b86:	ee 0f       	add	r30, r30
     b88:	ff 1f       	adc	r31, r31
     b8a:	ec 59       	subi	r30, 0x9C	; 156
     b8c:	f7 4c       	sbci	r31, 0xC7	; 199
}
     b8e:	80 81       	ld	r24, Z
     b90:	08 95       	ret

00000b92 <tinyLED_set_color_mode>:

/*
changes the values in the variables stored in the LED-array.
*/
void tinyLED_set_color_mode(uint8_t LED_id, enum Colors color, enum ColorModes mode)
{
     b92:	cf 93       	push	r28
     b94:	df 93       	push	r29
	// If we are in pulse mode, we want to stay in pulse mode after we have flashed a light.
	// We do this by storing the previous mode in old settings.
	// However, it can happen that two flashes comes very quickly after one another, that leads
	// to an infinite flash loop, therefore, we only store the settings if it is not flash mode.
	if(tinyLED_settings[LED_id].mode != FLASH_ONCE){
     b96:	c8 2f       	mov	r28, r24
     b98:	d0 e0       	ldi	r29, 0x00	; 0
     b9a:	fe 01       	movw	r30, r28
     b9c:	ee 0f       	add	r30, r30
     b9e:	ff 1f       	adc	r31, r31
     ba0:	ec 59       	subi	r30, 0x9C	; 156
     ba2:	f7 4c       	sbci	r31, 0xC7	; 199
     ba4:	21 81       	ldd	r18, Z+1	; 0x01
     ba6:	25 30       	cpi	r18, 0x05	; 5
     ba8:	61 f0       	breq	.+24     	; 0xbc2 <tinyLED_set_color_mode+0x30>
		// We use two lines to avoid pointer trouble. (I'm not good with pointers)
		tinyLED_old_settings[LED_id].color = tinyLED_settings[LED_id].color;
     baa:	ce 01       	movw	r24, r28
     bac:	88 0f       	add	r24, r24
     bae:	99 1f       	adc	r25, r25
     bb0:	fc 01       	movw	r30, r24
     bb2:	e8 59       	subi	r30, 0x98	; 152
     bb4:	f7 4c       	sbci	r31, 0xC7	; 199
     bb6:	dc 01       	movw	r26, r24
     bb8:	ac 59       	subi	r26, 0x9C	; 156
     bba:	b7 4c       	sbci	r27, 0xC7	; 199
     bbc:	8c 91       	ld	r24, X
     bbe:	80 83       	st	Z, r24
		tinyLED_old_settings[LED_id].mode = tinyLED_settings[LED_id].mode;
     bc0:	21 83       	std	Z+1, r18	; 0x01
	}
	
	struct ColorSetting new_setting = {.color=color, .mode=mode};
	tinyLED_settings[LED_id] = new_setting;
     bc2:	fe 01       	movw	r30, r28
     bc4:	ee 0f       	add	r30, r30
     bc6:	ff 1f       	adc	r31, r31
     bc8:	ec 59       	subi	r30, 0x9C	; 156
     bca:	f7 4c       	sbci	r31, 0xC7	; 199
     bcc:	60 83       	st	Z, r22
     bce:	41 83       	std	Z+1, r20	; 0x01
	if (mode == FLASH_ONCE)
     bd0:	45 30       	cpi	r20, 0x05	; 5
     bd2:	09 f5       	brne	.+66     	; 0xc16 <tinyLED_set_color_mode+0x84>
	{
		if (tinyAxon_time_until_next_pulse()<1000*FLASH_OFF_TIME)
     bd4:	0e 94 8e 02 	call	0x51c	; 0x51c <tinyAxon_time_until_next_pulse>
     bd8:	68 2f       	mov	r22, r24
     bda:	70 e0       	ldi	r23, 0x00	; 0
     bdc:	80 e0       	ldi	r24, 0x00	; 0
     bde:	90 e0       	ldi	r25, 0x00	; 0
     be0:	0e 94 4b 0b 	call	0x1696	; 0x1696 <__floatsisf>
     be4:	20 e0       	ldi	r18, 0x00	; 0
     be6:	30 e0       	ldi	r19, 0x00	; 0
     be8:	40 e2       	ldi	r20, 0x20	; 32
     bea:	51 e4       	ldi	r21, 0x41	; 65
     bec:	0e 94 62 0a 	call	0x14c4	; 0x14c4 <__cmpsf2>
     bf0:	88 23       	and	r24, r24
     bf2:	4c f4       	brge	.+18     	; 0xc06 <tinyLED_set_color_mode+0x74>
		{
			tinyLED_flash_once_time[LED_id] = 1000*(FLASH_TIME-FLASH_OFF_TIME);
     bf4:	cc 0f       	add	r28, r28
     bf6:	dd 1f       	adc	r29, r29
     bf8:	c6 5a       	subi	r28, 0xA6	; 166
     bfa:	d7 4c       	sbci	r29, 0xC7	; 199
     bfc:	8e eb       	ldi	r24, 0xBE	; 190
     bfe:	90 e0       	ldi	r25, 0x00	; 0
     c00:	88 83       	st	Y, r24
     c02:	99 83       	std	Y+1, r25	; 0x01
     c04:	08 c0       	rjmp	.+16     	; 0xc16 <tinyLED_set_color_mode+0x84>
		} else{
			tinyLED_flash_once_time[LED_id] = 1000*FLASH_TIME;
     c06:	cc 0f       	add	r28, r28
     c08:	dd 1f       	adc	r29, r29
     c0a:	c6 5a       	subi	r28, 0xA6	; 166
     c0c:	d7 4c       	sbci	r29, 0xC7	; 199
     c0e:	88 ec       	ldi	r24, 0xC8	; 200
     c10:	90 e0       	ldi	r25, 0x00	; 0
     c12:	88 83       	st	Y, r24
     c14:	99 83       	std	Y+1, r25	; 0x01
		}
	}
}
     c16:	df 91       	pop	r29
     c18:	cf 91       	pop	r28
     c1a:	08 95       	ret

00000c1c <tinyLED_set_color>:
/*
changes the values in the variables stored in the LED-array.
*/
void tinyLED_set_color(uint8_t LED_id, enum Colors color)
{
	tinyLED_set_color_mode(LED_id, color, STABLE);
     c1c:	40 e0       	ldi	r20, 0x00	; 0
     c1e:	0e 94 c9 05 	call	0xb92	; 0xb92 <tinyLED_set_color_mode>
     c22:	08 95       	ret

00000c24 <tinyLED_RGB_Color_Compare>:
	return rgb_color;
			
};
// This might be cause of strange light behavior?
//Message		expected 'struct RGB_Color *' but argument is of type 'struct RGB_Color (*)[2]'	Hjernebyggesett_V4	C:\Users\Elias Lundheim\Documents\GitHub\neural\Hjernebyggesett_V4\Hjernebyggesett_V4\tinyLED\tinyLED.c	121
_Bool tinyLED_RGB_Color_Compare(struct RGB_Color (*a)[NUMBER_OF_LEDS], struct RGB_Color (*b)[NUMBER_OF_LEDS]){
     c24:	dc 01       	movw	r26, r24
     c26:	fb 01       	movw	r30, r22
	for (int i=0; i<NUMBER_OF_LEDS; i++)
	{
		if(!((*a)[i].red==(*b)[i].red && (*a)[i].green==(*b)[i].green && (*a)[i].blue==(*b)[i].blue)){
     c28:	9c 91       	ld	r25, X
     c2a:	80 81       	ld	r24, Z
     c2c:	98 13       	cpse	r25, r24
     c2e:	20 c0       	rjmp	.+64     	; 0xc70 <tinyLED_RGB_Color_Compare+0x4c>
     c30:	11 96       	adiw	r26, 0x01	; 1
     c32:	9c 91       	ld	r25, X
     c34:	11 97       	sbiw	r26, 0x01	; 1
     c36:	81 81       	ldd	r24, Z+1	; 0x01
     c38:	98 13       	cpse	r25, r24
     c3a:	1c c0       	rjmp	.+56     	; 0xc74 <tinyLED_RGB_Color_Compare+0x50>
     c3c:	12 96       	adiw	r26, 0x02	; 2
     c3e:	9c 91       	ld	r25, X
     c40:	12 97       	sbiw	r26, 0x02	; 2
     c42:	82 81       	ldd	r24, Z+2	; 0x02
     c44:	98 13       	cpse	r25, r24
     c46:	18 c0       	rjmp	.+48     	; 0xc78 <tinyLED_RGB_Color_Compare+0x54>
     c48:	13 96       	adiw	r26, 0x03	; 3
     c4a:	9c 91       	ld	r25, X
     c4c:	13 97       	sbiw	r26, 0x03	; 3
     c4e:	83 81       	ldd	r24, Z+3	; 0x03
     c50:	98 13       	cpse	r25, r24
     c52:	14 c0       	rjmp	.+40     	; 0xc7c <tinyLED_RGB_Color_Compare+0x58>
     c54:	14 96       	adiw	r26, 0x04	; 4
     c56:	9c 91       	ld	r25, X
     c58:	14 97       	sbiw	r26, 0x04	; 4
     c5a:	84 81       	ldd	r24, Z+4	; 0x04
     c5c:	98 13       	cpse	r25, r24
     c5e:	10 c0       	rjmp	.+32     	; 0xc80 <tinyLED_RGB_Color_Compare+0x5c>
     c60:	81 e0       	ldi	r24, 0x01	; 1
     c62:	15 96       	adiw	r26, 0x05	; 5
     c64:	2c 91       	ld	r18, X
     c66:	95 81       	ldd	r25, Z+5	; 0x05
     c68:	29 17       	cp	r18, r25
     c6a:	59 f0       	breq	.+22     	; 0xc82 <tinyLED_RGB_Color_Compare+0x5e>
     c6c:	80 e0       	ldi	r24, 0x00	; 0
     c6e:	08 95       	ret
			return false;
     c70:	80 e0       	ldi	r24, 0x00	; 0
     c72:	08 95       	ret
     c74:	80 e0       	ldi	r24, 0x00	; 0
     c76:	08 95       	ret
     c78:	80 e0       	ldi	r24, 0x00	; 0
     c7a:	08 95       	ret
     c7c:	80 e0       	ldi	r24, 0x00	; 0
     c7e:	08 95       	ret
     c80:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	return true;
}
     c82:	08 95       	ret

00000c84 <tinyLED_update>:
/*
function to write the current LED-array on to the LEDs and
effectively update the values stored in the LEDs to the values stored in the MCU.
*/
void tinyLED_update(void)
{
     c84:	2f 92       	push	r2
     c86:	3f 92       	push	r3
     c88:	4f 92       	push	r4
     c8a:	5f 92       	push	r5
     c8c:	6f 92       	push	r6
     c8e:	7f 92       	push	r7
     c90:	8f 92       	push	r8
     c92:	9f 92       	push	r9
     c94:	af 92       	push	r10
     c96:	bf 92       	push	r11
     c98:	cf 92       	push	r12
     c9a:	df 92       	push	r13
     c9c:	ef 92       	push	r14
     c9e:	ff 92       	push	r15
     ca0:	0f 93       	push	r16
     ca2:	1f 93       	push	r17
     ca4:	cf 93       	push	r28
     ca6:	df 93       	push	r29
     ca8:	cd b7       	in	r28, 0x3d	; 61
     caa:	de b7       	in	r29, 0x3e	; 62
     cac:	ab 97       	sbiw	r28, 0x2b	; 43
     cae:	cd bf       	out	0x3d, r28	; 61
     cb0:	de bf       	out	0x3e, r29	; 62
			
	uint32_t now = tinyTime_now();
     cb2:	0e 94 ec 09 	call	0x13d8	; 0x13d8 <tinyTime_now>
     cb6:	6b 01       	movw	r12, r22
     cb8:	7c 01       	movw	r14, r24
	uint8_t red = 0;
	uint8_t green = 0;
	
	// This is a sin curve, but between 0 and 1 instead of -1 and 1
	double sinValue = 0.5+sin((double)now/(100*M_PI/SWING_RATE))/2;
     cba:	0e 94 49 0b 	call	0x1692	; 0x1692 <__floatunsisf>
     cbe:	23 e6       	ldi	r18, 0x63	; 99
     cc0:	34 e1       	ldi	r19, 0x14	; 20
     cc2:	4d e1       	ldi	r20, 0x1D	; 29
     cc4:	54 e4       	ldi	r21, 0x44	; 68
     cc6:	0e 94 67 0a 	call	0x14ce	; 0x14ce <__divsf3>
     cca:	0e 94 29 0d 	call	0x1a52	; 0x1a52 <sin>
     cce:	20 e0       	ldi	r18, 0x00	; 0
     cd0:	30 e0       	ldi	r19, 0x00	; 0
     cd2:	40 e0       	ldi	r20, 0x00	; 0
     cd4:	5f e3       	ldi	r21, 0x3F	; 63
     cd6:	0e 94 bc 0c 	call	0x1978	; 0x1978 <__mulsf3>
     cda:	20 e0       	ldi	r18, 0x00	; 0
     cdc:	30 e0       	ldi	r19, 0x00	; 0
     cde:	40 e0       	ldi	r20, 0x00	; 0
     ce0:	5f e3       	ldi	r21, 0x3F	; 63
     ce2:	0e 94 f6 09 	call	0x13ec	; 0x13ec <__addsf3>
     ce6:	68 87       	std	Y+8, r22	; 0x08
     ce8:	79 87       	std	Y+9, r23	; 0x09
     cea:	8a 87       	std	Y+10, r24	; 0x0a
     cec:	9b 87       	std	Y+11, r25	; 0x0b
	
	// If FLASH_RATE is one, then that means that the left side of the "<" will just count from 0 to 1000, and flash_on will be true for half of the time
	_Bool flash_on = now%(uint32_t)(1000/FLASH_RATE)  <   500/FLASH_RATE;
     cee:	c7 01       	movw	r24, r14
     cf0:	b6 01       	movw	r22, r12
     cf2:	28 ee       	ldi	r18, 0xE8	; 232
     cf4:	33 e0       	ldi	r19, 0x03	; 3
     cf6:	40 e0       	ldi	r20, 0x00	; 0
     cf8:	50 e0       	ldi	r21, 0x00	; 0
     cfa:	0e 94 92 0d 	call	0x1b24	; 0x1b24 <__udivmodsi4>
     cfe:	21 e0       	ldi	r18, 0x01	; 1
     d00:	2f 83       	std	Y+7, r18	; 0x07
     d02:	64 3f       	cpi	r22, 0xF4	; 244
     d04:	71 40       	sbci	r23, 0x01	; 1
     d06:	81 05       	cpc	r24, r1
     d08:	91 05       	cpc	r25, r1
     d0a:	08 f0       	brcs	.+2      	; 0xd0e <tinyLED_update+0x8a>
     d0c:	1f 82       	std	Y+7, r1	; 0x07
	
	// PING_RATE is usually small, so the left side counts to some large number. Since flash_time usually is also quite small,
	// the left side will usually be larger than the right
	_Bool ping_on =  now%(uint32_t)(1000/PING_RATE)   <   1000*FLASH_TIME;
     d0e:	c7 01       	movw	r24, r14
     d10:	b6 01       	movw	r22, r12
     d12:	20 e1       	ldi	r18, 0x10	; 16
     d14:	37 e2       	ldi	r19, 0x27	; 39
     d16:	40 e0       	ldi	r20, 0x00	; 0
     d18:	50 e0       	ldi	r21, 0x00	; 0
     d1a:	0e 94 92 0d 	call	0x1b24	; 0x1b24 <__udivmodsi4>
     d1e:	0e 94 49 0b 	call	0x1692	; 0x1692 <__floatunsisf>
     d22:	20 e0       	ldi	r18, 0x00	; 0
     d24:	30 e0       	ldi	r19, 0x00	; 0
     d26:	48 e4       	ldi	r20, 0x48	; 72
     d28:	53 e4       	ldi	r21, 0x43	; 67
     d2a:	0e 94 62 0a 	call	0x14c4	; 0x14c4 <__cmpsf2>
     d2e:	18 2f       	mov	r17, r24
     d30:	11 1f       	adc	r17, r17
     d32:	11 27       	eor	r17, r17
     d34:	11 1f       	adc	r17, r17
	
	// Find potential 
	double tinyPotential_potental = tinyPotential_get_potential();
     d36:	0e 94 e2 08 	call	0x11c4	; 0x11c4 <tinyPotential_get_potential>
     d3a:	6c 87       	std	Y+12, r22	; 0x0c
     d3c:	7d 87       	std	Y+13, r23	; 0x0d
     d3e:	8e 87       	std	Y+14, r24	; 0x0e
     d40:	9f 87       	std	Y+15, r25	; 0x0f
	uint16_t tinyAxon_pulses_in_queue = tinyAxon_get_pulses_in_queue();
     d42:	0e 94 62 02 	call	0x4c4	; 0x4c4 <tinyAxon_get_pulses_in_queue>
			
			case POTENTIAL:
				// In this mode, we try to communicate the level of the potential with color and brightness
				
				if(tinyPotential_potental > 0 || tinyAxon_pulses_in_queue > 0){
					green = fmin(255*LED_BRIGHTNESS * (tinyPotential_potental+tinyAxon_pulses_in_queue*THRESHOLD_POTENTIAL)/FULL_BRIGHTNESS_POTENTIAL, 255);
     d46:	48 2f       	mov	r20, r24
     d48:	50 e0       	ldi	r21, 0x00	; 0
     d4a:	4e 8f       	std	Y+30, r20	; 0x1e
     d4c:	5f 8f       	std	Y+31, r21	; 0x1f
     d4e:	59 e1       	ldi	r21, 0x19	; 25
     d50:	85 9f       	mul	r24, r21
     d52:	c0 01       	movw	r24, r0
     d54:	11 24       	eor	r1, r1
     d56:	0f 2e       	mov	r0, r31
     d58:	f4 e6       	ldi	r31, 0x64	; 100
     d5a:	2f 2e       	mov	r2, r31
     d5c:	f8 e3       	ldi	r31, 0x38	; 56
     d5e:	3f 2e       	mov	r3, r31
     d60:	f0 2d       	mov	r31, r0
     d62:	de 01       	movw	r26, r28
     d64:	11 96       	adiw	r26, 0x01	; 1
     d66:	5d 01       	movw	r10, r26
     d68:	0f 2e       	mov	r0, r31
     d6a:	f8 e6       	ldi	r31, 0x68	; 104
     d6c:	4f 2e       	mov	r4, r31
     d6e:	f8 e3       	ldi	r31, 0x38	; 56
     d70:	5f 2e       	mov	r5, r31
     d72:	f0 2d       	mov	r31, r0
     d74:	0f 2e       	mov	r0, r31
     d76:	fa e5       	ldi	r31, 0x5A	; 90
     d78:	6f 2e       	mov	r6, r31
     d7a:	f8 e3       	ldi	r31, 0x38	; 56
     d7c:	7f 2e       	mov	r7, r31
     d7e:	f0 2d       	mov	r31, r0
     d80:	0f 2e       	mov	r0, r31
     d82:	f8 e6       	ldi	r31, 0x68	; 104
     d84:	8f 2e       	mov	r8, r31
     d86:	f8 e3       	ldi	r31, 0x38	; 56
     d88:	9f 2e       	mov	r9, r31
     d8a:	f0 2d       	mov	r31, r0
     d8c:	6d 01       	movw	r12, r26
void tinyLED_update(void)
{
			
	uint32_t now = tinyTime_now();
	uint8_t red = 0;
	uint8_t green = 0;
     d8e:	1c 8a       	std	Y+20, r1	; 0x14
*/
void tinyLED_update(void)
{
			
	uint32_t now = tinyTime_now();
	uint8_t red = 0;
     d90:	1d 8a       	std	Y+21, r1	; 0x15
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*sinValue, rgb_colors[i].green*sinValue, rgb_colors[i].blue*sinValue};
				break;
				
			case PING:
				// in the line below, fmin will either return 1 or 0, so each rgb color is either 0 or 255*PING_BRIGHTNESS
				rgb_colors[i] = (struct RGB_Color){255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].red)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].green)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].blue)*ping_on};
     d92:	21 2f       	mov	r18, r17
     d94:	30 e0       	ldi	r19, 0x00	; 0
     d96:	40 e0       	ldi	r20, 0x00	; 0
     d98:	50 e0       	ldi	r21, 0x00	; 0
     d9a:	2e 8b       	std	Y+22, r18	; 0x16
     d9c:	3f 8b       	std	Y+23, r19	; 0x17
     d9e:	48 8f       	std	Y+24, r20	; 0x18
     da0:	59 8f       	std	Y+25, r21	; 0x19
			
			case POTENTIAL:
				// In this mode, we try to communicate the level of the potential with color and brightness
				
				if(tinyPotential_potental > 0 || tinyAxon_pulses_in_queue > 0){
					green = fmin(255*LED_BRIGHTNESS * (tinyPotential_potental+tinyAxon_pulses_in_queue*THRESHOLD_POTENTIAL)/FULL_BRIGHTNESS_POTENTIAL, 255);
     da2:	9c 01       	movw	r18, r24
     da4:	40 e0       	ldi	r20, 0x00	; 0
     da6:	50 e0       	ldi	r21, 0x00	; 0
     da8:	2a 8f       	std	Y+26, r18	; 0x1a
     daa:	3b 8f       	std	Y+27, r19	; 0x1b
     dac:	4c 8f       	std	Y+28, r20	; 0x1c
     dae:	5d 8f       	std	Y+29, r21	; 0x1d
     db0:	f1 01       	movw	r30, r2
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 0 << TCA_SPLIT_ENABLE_bp; //Stop TCA
}

static struct RGB_Color tinyLED_enum_to_RGB_Color(enum Colors color){
	struct RGB_Color rgb_color;
	switch(color)
     db2:	80 81       	ld	r24, Z
     db4:	84 30       	cpi	r24, 0x04	; 4
     db6:	79 f0       	breq	.+30     	; 0xdd6 <tinyLED_update+0x152>
     db8:	28 f4       	brcc	.+10     	; 0xdc4 <tinyLED_update+0x140>
     dba:	82 30       	cpi	r24, 0x02	; 2
     dbc:	41 f0       	breq	.+16     	; 0xdce <tinyLED_update+0x14a>
     dbe:	83 30       	cpi	r24, 0x03	; 3
     dc0:	71 f0       	breq	.+28     	; 0xdde <tinyLED_update+0x15a>
     dc2:	19 c0       	rjmp	.+50     	; 0xdf6 <tinyLED_update+0x172>
     dc4:	85 30       	cpi	r24, 0x05	; 5
     dc6:	79 f0       	breq	.+30     	; 0xde6 <tinyLED_update+0x162>
     dc8:	86 30       	cpi	r24, 0x06	; 6
     dca:	89 f0       	breq	.+34     	; 0xdee <tinyLED_update+0x16a>
     dcc:	14 c0       	rjmp	.+40     	; 0xdf6 <tinyLED_update+0x172>
	{
		case LED_OFF:
			rgb_color = (struct RGB_Color){0, 0, 0};
			break;
		case RED:
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 0, 0};
     dce:	10 e0       	ldi	r17, 0x00	; 0
     dd0:	00 e0       	ldi	r16, 0x00	; 0
     dd2:	69 e1       	ldi	r22, 0x19	; 25
     dd4:	13 c0       	rjmp	.+38     	; 0xdfc <tinyLED_update+0x178>
			break;
		case GREEN:
			rgb_color = (struct RGB_Color){0, 255*LED_BRIGHTNESS, 0};
     dd6:	10 e0       	ldi	r17, 0x00	; 0
     dd8:	09 e1       	ldi	r16, 0x19	; 25
     dda:	60 e0       	ldi	r22, 0x00	; 0
     ddc:	0f c0       	rjmp	.+30     	; 0xdfc <tinyLED_update+0x178>
			break;
		case BLUE:
			rgb_color = (struct RGB_Color){0, 0, 255*LED_BRIGHTNESS};
     dde:	19 e1       	ldi	r17, 0x19	; 25
     de0:	00 e0       	ldi	r16, 0x00	; 0
     de2:	60 e0       	ldi	r22, 0x00	; 0
     de4:	0b c0       	rjmp	.+22     	; 0xdfc <tinyLED_update+0x178>
			break;
		case YELLOW:
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS, 0};
     de6:	10 e0       	ldi	r17, 0x00	; 0
     de8:	09 e1       	ldi	r16, 0x19	; 25
     dea:	69 e1       	ldi	r22, 0x19	; 25
     dec:	07 c0       	rjmp	.+14     	; 0xdfc <tinyLED_update+0x178>
			// Should the /3 be there? This requires testing.
			// After testing, findings were that at 0.1 brightness, one would see the three LEDs instead of one white led
			// We try with /2 instead.
			// We find that the best results come from not dividing by anything. At leasts in the lower brightness settings, and that
			// is where we suspect it will be most of the time. When we divide, the LEDs are so weak, that they appear as three lights instead of one.
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS};
     dee:	19 e1       	ldi	r17, 0x19	; 25
     df0:	09 e1       	ldi	r16, 0x19	; 25
     df2:	69 e1       	ldi	r22, 0x19	; 25
     df4:	03 c0       	rjmp	.+6      	; 0xdfc <tinyLED_update+0x178>
static struct RGB_Color tinyLED_enum_to_RGB_Color(enum Colors color){
	struct RGB_Color rgb_color;
	switch(color)
	{
		case LED_OFF:
			rgb_color = (struct RGB_Color){0, 0, 0};
     df6:	10 e0       	ldi	r17, 0x00	; 0
     df8:	00 e0       	ldi	r16, 0x00	; 0
     dfa:	60 e0       	ldi	r22, 0x00	; 0
     dfc:	76 01       	movw	r14, r12
	
	
	for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
	{		
		// Convert enum to RGB_Color
		rgb_colors[i] = tinyLED_enum_to_RGB_Color(tinyLED_settings[i].color);
     dfe:	d6 01       	movw	r26, r12
     e00:	6c 93       	st	X, r22
     e02:	11 96       	adiw	r26, 0x01	; 1
     e04:	0c 93       	st	X, r16
     e06:	11 97       	sbiw	r26, 0x01	; 1
     e08:	12 96       	adiw	r26, 0x02	; 2
     e0a:	1c 93       	st	X, r17
		
		// Adjust colors according to mode
		switch(tinyLED_settings[i].mode)
     e0c:	81 81       	ldd	r24, Z+1	; 0x01
     e0e:	83 30       	cpi	r24, 0x03	; 3
     e10:	09 f4       	brne	.+2      	; 0xe14 <tinyLED_update+0x190>
     e12:	52 c0       	rjmp	.+164    	; 0xeb8 <tinyLED_update+0x234>
     e14:	28 f4       	brcc	.+10     	; 0xe20 <tinyLED_update+0x19c>
     e16:	81 30       	cpi	r24, 0x01	; 1
     e18:	61 f0       	breq	.+24     	; 0xe32 <tinyLED_update+0x1ae>
     e1a:	82 30       	cpi	r24, 0x02	; 2
     e1c:	d9 f1       	breq	.+118    	; 0xe94 <tinyLED_update+0x210>
     e1e:	83 c1       	rjmp	.+774    	; 0x1126 <tinyLED_update+0x4a2>
     e20:	85 30       	cpi	r24, 0x05	; 5
     e22:	09 f4       	brne	.+2      	; 0xe26 <tinyLED_update+0x1a2>
     e24:	f7 c0       	rjmp	.+494    	; 0x1014 <tinyLED_update+0x390>
     e26:	08 f4       	brcc	.+2      	; 0xe2a <tinyLED_update+0x1a6>
     e28:	78 c0       	rjmp	.+240    	; 0xf1a <tinyLED_update+0x296>
     e2a:	86 30       	cpi	r24, 0x06	; 6
     e2c:	09 f4       	brne	.+2      	; 0xe30 <tinyLED_update+0x1ac>
     e2e:	19 c1       	rjmp	.+562    	; 0x1062 <tinyLED_update+0x3de>
     e30:	7a c1       	rjmp	.+756    	; 0x1126 <tinyLED_update+0x4a2>
		{
			case STABLE:
				break;
				
			case WEAK:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*WEAK_BRIGHTNESS, rgb_colors[i].green*WEAK_BRIGHTNESS, rgb_colors[i].blue*WEAK_BRIGHTNESS};
     e32:	70 e0       	ldi	r23, 0x00	; 0
     e34:	80 e0       	ldi	r24, 0x00	; 0
     e36:	90 e0       	ldi	r25, 0x00	; 0
     e38:	0e 94 4b 0b 	call	0x1696	; 0x1696 <__floatsisf>
     e3c:	2d ec       	ldi	r18, 0xCD	; 205
     e3e:	3c ec       	ldi	r19, 0xCC	; 204
     e40:	4c ec       	ldi	r20, 0xCC	; 204
     e42:	5d e3       	ldi	r21, 0x3D	; 61
     e44:	0e 94 bc 0c 	call	0x1978	; 0x1978 <__mulsf3>
     e48:	0e 94 1a 0b 	call	0x1634	; 0x1634 <__fixunssfsi>
     e4c:	f6 01       	movw	r30, r12
     e4e:	60 83       	st	Z, r22
     e50:	60 2f       	mov	r22, r16
     e52:	70 e0       	ldi	r23, 0x00	; 0
     e54:	80 e0       	ldi	r24, 0x00	; 0
     e56:	90 e0       	ldi	r25, 0x00	; 0
     e58:	0e 94 4b 0b 	call	0x1696	; 0x1696 <__floatsisf>
     e5c:	2d ec       	ldi	r18, 0xCD	; 205
     e5e:	3c ec       	ldi	r19, 0xCC	; 204
     e60:	4c ec       	ldi	r20, 0xCC	; 204
     e62:	5d e3       	ldi	r21, 0x3D	; 61
     e64:	0e 94 bc 0c 	call	0x1978	; 0x1978 <__mulsf3>
     e68:	0e 94 1a 0b 	call	0x1634	; 0x1634 <__fixunssfsi>
     e6c:	d6 01       	movw	r26, r12
     e6e:	11 96       	adiw	r26, 0x01	; 1
     e70:	6c 93       	st	X, r22
     e72:	61 2f       	mov	r22, r17
     e74:	70 e0       	ldi	r23, 0x00	; 0
     e76:	80 e0       	ldi	r24, 0x00	; 0
     e78:	90 e0       	ldi	r25, 0x00	; 0
     e7a:	0e 94 4b 0b 	call	0x1696	; 0x1696 <__floatsisf>
     e7e:	2d ec       	ldi	r18, 0xCD	; 205
     e80:	3c ec       	ldi	r19, 0xCC	; 204
     e82:	4c ec       	ldi	r20, 0xCC	; 204
     e84:	5d e3       	ldi	r21, 0x3D	; 61
     e86:	0e 94 bc 0c 	call	0x1978	; 0x1978 <__mulsf3>
     e8a:	0e 94 1a 0b 	call	0x1634	; 0x1634 <__fixunssfsi>
     e8e:	f6 01       	movw	r30, r12
     e90:	62 83       	std	Z+2, r22	; 0x02
				break;
     e92:	49 c1       	rjmp	.+658    	; 0x1126 <tinyLED_update+0x4a2>
				
			case FLASH:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*flash_on, rgb_colors[i].green*flash_on, rgb_colors[i].blue*flash_on};
     e94:	ff 81       	ldd	r31, Y+7	; 0x07
     e96:	f6 9f       	mul	r31, r22
     e98:	60 2d       	mov	r22, r0
     e9a:	11 24       	eor	r1, r1
     e9c:	d6 01       	movw	r26, r12
     e9e:	6c 93       	st	X, r22
     ea0:	f0 9f       	mul	r31, r16
     ea2:	00 2d       	mov	r16, r0
     ea4:	11 24       	eor	r1, r1
     ea6:	11 96       	adiw	r26, 0x01	; 1
     ea8:	0c 93       	st	X, r16
     eaa:	11 97       	sbiw	r26, 0x01	; 1
     eac:	f1 9f       	mul	r31, r17
     eae:	10 2d       	mov	r17, r0
     eb0:	11 24       	eor	r1, r1
     eb2:	12 96       	adiw	r26, 0x02	; 2
     eb4:	1c 93       	st	X, r17
				break;
     eb6:	37 c1       	rjmp	.+622    	; 0x1126 <tinyLED_update+0x4a2>
				
			case SWING:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*sinValue, rgb_colors[i].green*sinValue, rgb_colors[i].blue*sinValue};
     eb8:	70 e0       	ldi	r23, 0x00	; 0
     eba:	80 e0       	ldi	r24, 0x00	; 0
     ebc:	90 e0       	ldi	r25, 0x00	; 0
     ebe:	0e 94 4b 0b 	call	0x1696	; 0x1696 <__floatsisf>
     ec2:	28 85       	ldd	r18, Y+8	; 0x08
     ec4:	39 85       	ldd	r19, Y+9	; 0x09
     ec6:	4a 85       	ldd	r20, Y+10	; 0x0a
     ec8:	5b 85       	ldd	r21, Y+11	; 0x0b
     eca:	0e 94 bc 0c 	call	0x1978	; 0x1978 <__mulsf3>
     ece:	0e 94 1a 0b 	call	0x1634	; 0x1634 <__fixunssfsi>
     ed2:	f6 01       	movw	r30, r12
     ed4:	60 83       	st	Z, r22
     ed6:	60 2f       	mov	r22, r16
     ed8:	70 e0       	ldi	r23, 0x00	; 0
     eda:	80 e0       	ldi	r24, 0x00	; 0
     edc:	90 e0       	ldi	r25, 0x00	; 0
     ede:	0e 94 4b 0b 	call	0x1696	; 0x1696 <__floatsisf>
     ee2:	28 85       	ldd	r18, Y+8	; 0x08
     ee4:	39 85       	ldd	r19, Y+9	; 0x09
     ee6:	4a 85       	ldd	r20, Y+10	; 0x0a
     ee8:	5b 85       	ldd	r21, Y+11	; 0x0b
     eea:	0e 94 bc 0c 	call	0x1978	; 0x1978 <__mulsf3>
     eee:	0e 94 1a 0b 	call	0x1634	; 0x1634 <__fixunssfsi>
     ef2:	d6 01       	movw	r26, r12
     ef4:	11 96       	adiw	r26, 0x01	; 1
     ef6:	6c 93       	st	X, r22
     ef8:	61 2f       	mov	r22, r17
     efa:	70 e0       	ldi	r23, 0x00	; 0
     efc:	80 e0       	ldi	r24, 0x00	; 0
     efe:	90 e0       	ldi	r25, 0x00	; 0
     f00:	0e 94 4b 0b 	call	0x1696	; 0x1696 <__floatsisf>
     f04:	28 85       	ldd	r18, Y+8	; 0x08
     f06:	39 85       	ldd	r19, Y+9	; 0x09
     f08:	4a 85       	ldd	r20, Y+10	; 0x0a
     f0a:	5b 85       	ldd	r21, Y+11	; 0x0b
     f0c:	0e 94 bc 0c 	call	0x1978	; 0x1978 <__mulsf3>
     f10:	0e 94 1a 0b 	call	0x1634	; 0x1634 <__fixunssfsi>
     f14:	f6 01       	movw	r30, r12
     f16:	62 83       	std	Z+2, r22	; 0x02
				break;
     f18:	06 c1       	rjmp	.+524    	; 0x1126 <tinyLED_update+0x4a2>
				
			case PING:
				// in the line below, fmin will either return 1 or 0, so each rgb color is either 0 or 255*PING_BRIGHTNESS
				rgb_colors[i] = (struct RGB_Color){255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].red)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].green)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].blue)*ping_on};
     f1a:	70 e0       	ldi	r23, 0x00	; 0
     f1c:	80 e0       	ldi	r24, 0x00	; 0
     f1e:	90 e0       	ldi	r25, 0x00	; 0
     f20:	0e 94 49 0b 	call	0x1692	; 0x1692 <__floatunsisf>
     f24:	9b 01       	movw	r18, r22
     f26:	ac 01       	movw	r20, r24
     f28:	60 e0       	ldi	r22, 0x00	; 0
     f2a:	70 e0       	ldi	r23, 0x00	; 0
     f2c:	80 e8       	ldi	r24, 0x80	; 128
     f2e:	9f e3       	ldi	r25, 0x3F	; 63
     f30:	0e 94 86 0b 	call	0x170c	; 0x170c <fmin>
     f34:	68 a3       	std	Y+32, r22	; 0x20
     f36:	79 a3       	std	Y+33, r23	; 0x21
     f38:	8a a3       	std	Y+34, r24	; 0x22
     f3a:	9b a3       	std	Y+35, r25	; 0x23
     f3c:	6e 89       	ldd	r22, Y+22	; 0x16
     f3e:	7f 89       	ldd	r23, Y+23	; 0x17
     f40:	88 8d       	ldd	r24, Y+24	; 0x18
     f42:	99 8d       	ldd	r25, Y+25	; 0x19
     f44:	0e 94 4b 0b 	call	0x1696	; 0x1696 <__floatsisf>
     f48:	68 8b       	std	Y+16, r22	; 0x10
     f4a:	79 8b       	std	Y+17, r23	; 0x11
     f4c:	8a 8b       	std	Y+18, r24	; 0x12
     f4e:	9b 8b       	std	Y+19, r25	; 0x13
     f50:	60 2f       	mov	r22, r16
     f52:	70 e0       	ldi	r23, 0x00	; 0
     f54:	80 e0       	ldi	r24, 0x00	; 0
     f56:	90 e0       	ldi	r25, 0x00	; 0
     f58:	0e 94 49 0b 	call	0x1692	; 0x1692 <__floatunsisf>
     f5c:	9b 01       	movw	r18, r22
     f5e:	ac 01       	movw	r20, r24
     f60:	60 e0       	ldi	r22, 0x00	; 0
     f62:	70 e0       	ldi	r23, 0x00	; 0
     f64:	80 e8       	ldi	r24, 0x80	; 128
     f66:	9f e3       	ldi	r25, 0x3F	; 63
     f68:	0e 94 86 0b 	call	0x170c	; 0x170c <fmin>
     f6c:	6c a3       	std	Y+36, r22	; 0x24
     f6e:	7d a3       	std	Y+37, r23	; 0x25
     f70:	8e a3       	std	Y+38, r24	; 0x26
     f72:	9f a3       	std	Y+39, r25	; 0x27
     f74:	61 2f       	mov	r22, r17
     f76:	70 e0       	ldi	r23, 0x00	; 0
     f78:	80 e0       	ldi	r24, 0x00	; 0
     f7a:	90 e0       	ldi	r25, 0x00	; 0
     f7c:	0e 94 49 0b 	call	0x1692	; 0x1692 <__floatunsisf>
     f80:	9b 01       	movw	r18, r22
     f82:	ac 01       	movw	r20, r24
     f84:	60 e0       	ldi	r22, 0x00	; 0
     f86:	70 e0       	ldi	r23, 0x00	; 0
     f88:	80 e8       	ldi	r24, 0x80	; 128
     f8a:	9f e3       	ldi	r25, 0x3F	; 63
     f8c:	0e 94 86 0b 	call	0x170c	; 0x170c <fmin>
     f90:	68 a7       	std	Y+40, r22	; 0x28
     f92:	79 a7       	std	Y+41, r23	; 0x29
     f94:	8a a7       	std	Y+42, r24	; 0x2a
     f96:	9b a7       	std	Y+43, r25	; 0x2b
     f98:	23 e3       	ldi	r18, 0x33	; 51
     f9a:	33 e3       	ldi	r19, 0x33	; 51
     f9c:	43 ea       	ldi	r20, 0xA3	; 163
     f9e:	50 e4       	ldi	r21, 0x40	; 64
     fa0:	68 a1       	ldd	r22, Y+32	; 0x20
     fa2:	79 a1       	ldd	r23, Y+33	; 0x21
     fa4:	8a a1       	ldd	r24, Y+34	; 0x22
     fa6:	9b a1       	ldd	r25, Y+35	; 0x23
     fa8:	0e 94 bc 0c 	call	0x1978	; 0x1978 <__mulsf3>
     fac:	28 89       	ldd	r18, Y+16	; 0x10
     fae:	39 89       	ldd	r19, Y+17	; 0x11
     fb0:	4a 89       	ldd	r20, Y+18	; 0x12
     fb2:	5b 89       	ldd	r21, Y+19	; 0x13
     fb4:	0e 94 bc 0c 	call	0x1978	; 0x1978 <__mulsf3>
     fb8:	0e 94 1a 0b 	call	0x1634	; 0x1634 <__fixunssfsi>
     fbc:	d6 01       	movw	r26, r12
     fbe:	6c 93       	st	X, r22
     fc0:	23 e3       	ldi	r18, 0x33	; 51
     fc2:	33 e3       	ldi	r19, 0x33	; 51
     fc4:	43 ea       	ldi	r20, 0xA3	; 163
     fc6:	50 e4       	ldi	r21, 0x40	; 64
     fc8:	6c a1       	ldd	r22, Y+36	; 0x24
     fca:	7d a1       	ldd	r23, Y+37	; 0x25
     fcc:	8e a1       	ldd	r24, Y+38	; 0x26
     fce:	9f a1       	ldd	r25, Y+39	; 0x27
     fd0:	0e 94 bc 0c 	call	0x1978	; 0x1978 <__mulsf3>
     fd4:	28 89       	ldd	r18, Y+16	; 0x10
     fd6:	39 89       	ldd	r19, Y+17	; 0x11
     fd8:	4a 89       	ldd	r20, Y+18	; 0x12
     fda:	5b 89       	ldd	r21, Y+19	; 0x13
     fdc:	0e 94 bc 0c 	call	0x1978	; 0x1978 <__mulsf3>
     fe0:	0e 94 1a 0b 	call	0x1634	; 0x1634 <__fixunssfsi>
     fe4:	f6 01       	movw	r30, r12
     fe6:	61 83       	std	Z+1, r22	; 0x01
     fe8:	23 e3       	ldi	r18, 0x33	; 51
     fea:	33 e3       	ldi	r19, 0x33	; 51
     fec:	43 ea       	ldi	r20, 0xA3	; 163
     fee:	50 e4       	ldi	r21, 0x40	; 64
     ff0:	68 a5       	ldd	r22, Y+40	; 0x28
     ff2:	79 a5       	ldd	r23, Y+41	; 0x29
     ff4:	8a a5       	ldd	r24, Y+42	; 0x2a
     ff6:	9b a5       	ldd	r25, Y+43	; 0x2b
     ff8:	0e 94 bc 0c 	call	0x1978	; 0x1978 <__mulsf3>
     ffc:	28 89       	ldd	r18, Y+16	; 0x10
     ffe:	39 89       	ldd	r19, Y+17	; 0x11
    1000:	4a 89       	ldd	r20, Y+18	; 0x12
    1002:	5b 89       	ldd	r21, Y+19	; 0x13
    1004:	0e 94 bc 0c 	call	0x1978	; 0x1978 <__mulsf3>
    1008:	0e 94 1a 0b 	call	0x1634	; 0x1634 <__fixunssfsi>
    100c:	d6 01       	movw	r26, r12
    100e:	12 96       	adiw	r26, 0x02	; 2
    1010:	6c 93       	st	X, r22
				break;
    1012:	89 c0       	rjmp	.+274    	; 0x1126 <tinyLED_update+0x4a2>
    1014:	68 8a       	std	Y+16, r6	; 0x10
    1016:	79 8a       	std	Y+17, r7	; 0x11
				
			case FLASH_ONCE:
				if(tinyLED_flash_once_time[i]>0){
    1018:	d3 01       	movw	r26, r6
    101a:	0d 91       	ld	r16, X+
    101c:	1c 91       	ld	r17, X
    101e:	01 15       	cp	r16, r1
    1020:	11 05       	cpc	r17, r1
    1022:	c1 f0       	breq	.+48     	; 0x1054 <tinyLED_update+0x3d0>
					
					// Check if flash is inside off period
					if(tinyLED_flash_once_time[i]>1000*(FLASH_TIME - FLASH_OFF_TIME)){
    1024:	b8 01       	movw	r22, r16
    1026:	80 e0       	ldi	r24, 0x00	; 0
    1028:	90 e0       	ldi	r25, 0x00	; 0
    102a:	0e 94 49 0b 	call	0x1692	; 0x1692 <__floatunsisf>
    102e:	20 e0       	ldi	r18, 0x00	; 0
    1030:	30 e0       	ldi	r19, 0x00	; 0
    1032:	4e e3       	ldi	r20, 0x3E	; 62
    1034:	53 e4       	ldi	r21, 0x43	; 67
    1036:	0e 94 41 0c 	call	0x1882	; 0x1882 <__gesf2>
    103a:	18 16       	cp	r1, r24
    103c:	24 f4       	brge	.+8      	; 0x1046 <tinyLED_update+0x3c2>
						// This is used to seperate flashes
						rgb_colors[i] = (struct RGB_Color){0, 0, 0};
    103e:	f6 01       	movw	r30, r12
    1040:	10 82       	st	Z, r1
    1042:	11 82       	std	Z+1, r1	; 0x01
    1044:	12 82       	std	Z+2, r1	; 0x02
					} else {
						rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red, rgb_colors[i].green, rgb_colors[i].blue};
					}
					
					tinyLED_flash_once_time[i]--;
    1046:	01 50       	subi	r16, 0x01	; 1
    1048:	11 09       	sbc	r17, r1
    104a:	a8 89       	ldd	r26, Y+16	; 0x10
    104c:	b9 89       	ldd	r27, Y+17	; 0x11
    104e:	0d 93       	st	X+, r16
    1050:	1c 93       	st	X, r17
    1052:	69 c0       	rjmp	.+210    	; 0x1126 <tinyLED_update+0x4a2>
				}
				else{
					// Here we return to the previous color and mode
					tinyLED_settings[i].color = tinyLED_old_settings[i].color;
    1054:	d2 01       	movw	r26, r4
    1056:	8c 91       	ld	r24, X
    1058:	80 83       	st	Z, r24
					tinyLED_settings[i].mode = tinyLED_old_settings[i].mode;
    105a:	11 96       	adiw	r26, 0x01	; 1
    105c:	8c 91       	ld	r24, X
    105e:	81 83       	std	Z+1, r24	; 0x01
    1060:	62 c0       	rjmp	.+196    	; 0x1126 <tinyLED_update+0x4a2>
				break;
			
			case POTENTIAL:
				// In this mode, we try to communicate the level of the potential with color and brightness
				
				if(tinyPotential_potental > 0 || tinyAxon_pulses_in_queue > 0){
    1062:	20 e0       	ldi	r18, 0x00	; 0
    1064:	30 e0       	ldi	r19, 0x00	; 0
    1066:	a9 01       	movw	r20, r18
    1068:	6c 85       	ldd	r22, Y+12	; 0x0c
    106a:	7d 85       	ldd	r23, Y+13	; 0x0d
    106c:	8e 85       	ldd	r24, Y+14	; 0x0e
    106e:	9f 85       	ldd	r25, Y+15	; 0x0f
    1070:	0e 94 41 0c 	call	0x1882	; 0x1882 <__gesf2>
    1074:	18 16       	cp	r1, r24
    1076:	24 f0       	brlt	.+8      	; 0x1080 <tinyLED_update+0x3fc>
    1078:	ee 8d       	ldd	r30, Y+30	; 0x1e
    107a:	ff 8d       	ldd	r31, Y+31	; 0x1f
    107c:	ef 2b       	or	r30, r31
    107e:	11 f1       	breq	.+68     	; 0x10c4 <tinyLED_update+0x440>
					green = fmin(255*LED_BRIGHTNESS * (tinyPotential_potental+tinyAxon_pulses_in_queue*THRESHOLD_POTENTIAL)/FULL_BRIGHTNESS_POTENTIAL, 255);
    1080:	6a 8d       	ldd	r22, Y+26	; 0x1a
    1082:	7b 8d       	ldd	r23, Y+27	; 0x1b
    1084:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1086:	9d 8d       	ldd	r25, Y+29	; 0x1d
    1088:	0e 94 49 0b 	call	0x1692	; 0x1692 <__floatunsisf>
    108c:	2c 85       	ldd	r18, Y+12	; 0x0c
    108e:	3d 85       	ldd	r19, Y+13	; 0x0d
    1090:	4e 85       	ldd	r20, Y+14	; 0x0e
    1092:	5f 85       	ldd	r21, Y+15	; 0x0f
    1094:	0e 94 f6 09 	call	0x13ec	; 0x13ec <__addsf3>
    1098:	20 e0       	ldi	r18, 0x00	; 0
    109a:	30 e0       	ldi	r19, 0x00	; 0
    109c:	4c ec       	ldi	r20, 0xCC	; 204
    109e:	51 e4       	ldi	r21, 0x41	; 65
    10a0:	0e 94 bc 0c 	call	0x1978	; 0x1978 <__mulsf3>
    10a4:	20 e0       	ldi	r18, 0x00	; 0
    10a6:	30 e0       	ldi	r19, 0x00	; 0
    10a8:	48 ec       	ldi	r20, 0xC8	; 200
    10aa:	51 e4       	ldi	r21, 0x41	; 65
    10ac:	0e 94 67 0a 	call	0x14ce	; 0x14ce <__divsf3>
    10b0:	20 e0       	ldi	r18, 0x00	; 0
    10b2:	30 e0       	ldi	r19, 0x00	; 0
    10b4:	4f e7       	ldi	r20, 0x7F	; 127
    10b6:	53 e4       	ldi	r21, 0x43	; 67
    10b8:	0e 94 86 0b 	call	0x170c	; 0x170c <fmin>
    10bc:	0e 94 1a 0b 	call	0x1634	; 0x1634 <__fixunssfsi>
    10c0:	6c 8b       	std	Y+20, r22	; 0x14
    10c2:	28 c0       	rjmp	.+80     	; 0x1114 <tinyLED_update+0x490>
				}
				else{
					red = fmin(255*LED_BRIGHTNESS * abs(tinyPotential_potental)/FULL_BRIGHTNESS_POTENTIAL, 255);
    10c4:	6c 85       	ldd	r22, Y+12	; 0x0c
    10c6:	7d 85       	ldd	r23, Y+13	; 0x0d
    10c8:	8e 85       	ldd	r24, Y+14	; 0x0e
    10ca:	9f 85       	ldd	r25, Y+15	; 0x0f
    10cc:	0e 94 13 0b 	call	0x1626	; 0x1626 <__fixsfsi>
    10d0:	9b 01       	movw	r18, r22
    10d2:	77 23       	and	r23, r23
    10d4:	24 f4       	brge	.+8      	; 0x10de <tinyLED_update+0x45a>
    10d6:	22 27       	eor	r18, r18
    10d8:	33 27       	eor	r19, r19
    10da:	26 1b       	sub	r18, r22
    10dc:	37 0b       	sbc	r19, r23
    10de:	b9 01       	movw	r22, r18
    10e0:	33 0f       	add	r19, r19
    10e2:	88 0b       	sbc	r24, r24
    10e4:	99 0b       	sbc	r25, r25
    10e6:	0e 94 4b 0b 	call	0x1696	; 0x1696 <__floatsisf>
    10ea:	20 e0       	ldi	r18, 0x00	; 0
    10ec:	30 e0       	ldi	r19, 0x00	; 0
    10ee:	4c ec       	ldi	r20, 0xCC	; 204
    10f0:	51 e4       	ldi	r21, 0x41	; 65
    10f2:	0e 94 bc 0c 	call	0x1978	; 0x1978 <__mulsf3>
    10f6:	20 e0       	ldi	r18, 0x00	; 0
    10f8:	30 e0       	ldi	r19, 0x00	; 0
    10fa:	48 ec       	ldi	r20, 0xC8	; 200
    10fc:	51 e4       	ldi	r21, 0x41	; 65
    10fe:	0e 94 67 0a 	call	0x14ce	; 0x14ce <__divsf3>
    1102:	20 e0       	ldi	r18, 0x00	; 0
    1104:	30 e0       	ldi	r19, 0x00	; 0
    1106:	4f e7       	ldi	r20, 0x7F	; 127
    1108:	53 e4       	ldi	r21, 0x43	; 67
    110a:	0e 94 86 0b 	call	0x170c	; 0x170c <fmin>
    110e:	0e 94 1a 0b 	call	0x1634	; 0x1634 <__fixunssfsi>
    1112:	6d 8b       	std	Y+21, r22	; 0x15
				}
				
				rgb_colors[i] = (struct RGB_Color){red, green, 0};
    1114:	ed 89       	ldd	r30, Y+21	; 0x15
    1116:	d7 01       	movw	r26, r14
    1118:	ec 93       	st	X, r30
    111a:	fc 89       	ldd	r31, Y+20	; 0x14
    111c:	11 96       	adiw	r26, 0x01	; 1
    111e:	fc 93       	st	X, r31
    1120:	11 97       	sbiw	r26, 0x01	; 1
    1122:	12 96       	adiw	r26, 0x02	; 2
    1124:	1c 92       	st	X, r1
    1126:	22 e0       	ldi	r18, 0x02	; 2
    1128:	22 0e       	add	r2, r18
    112a:	31 1c       	adc	r3, r1
    112c:	33 e0       	ldi	r19, 0x03	; 3
    112e:	c3 0e       	add	r12, r19
    1130:	d1 1c       	adc	r13, r1
    1132:	42 e0       	ldi	r20, 0x02	; 2
    1134:	44 0e       	add	r4, r20
    1136:	51 1c       	adc	r5, r1
    1138:	52 e0       	ldi	r21, 0x02	; 2
    113a:	65 0e       	add	r6, r21
    113c:	71 1c       	adc	r7, r1
	
	// This is where we store all the actual color values we want to send to the LED
	struct RGB_Color rgb_colors[NUMBER_OF_LEDS];
	
	
	for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
    113e:	28 14       	cp	r2, r8
    1140:	39 04       	cpc	r3, r9
    1142:	09 f0       	breq	.+2      	; 0x1146 <tinyLED_update+0x4c2>
    1144:	35 ce       	rjmp	.-918    	; 0xdb0 <tinyLED_update+0x12c>
				break;
		}
	}
	
	// We only write to the LEDs if there is something to change. (eg. in SWING mode, we update the LEDs almost every cycle)
	if(!tinyLED_RGB_Color_Compare(&rgb_colors, &tinyLED_old_colors)){
    1146:	6e e5       	ldi	r22, 0x5E	; 94
    1148:	78 e3       	ldi	r23, 0x38	; 56
    114a:	ce 01       	movw	r24, r28
    114c:	01 96       	adiw	r24, 0x01	; 1
    114e:	0e 94 12 06 	call	0xc24	; 0xc24 <tinyLED_RGB_Color_Compare>
    1152:	81 11       	cpse	r24, r1
    1154:	21 c0       	rjmp	.+66     	; 0x1198 <tinyLED_update+0x514>
    1156:	0e e5       	ldi	r16, 0x5E	; 94
    1158:	18 e3       	ldi	r17, 0x38	; 56
    115a:	7e 01       	movw	r14, r28
    115c:	87 e0       	ldi	r24, 0x07	; 7
    115e:	e8 0e       	add	r14, r24
    1160:	f1 1c       	adc	r15, r1
		for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
		{
			// Write to LEDs
			//For some reason, the data-bus to the LEDs is serialized as GRB
			//which means the 24-bit data-bus will look like [Green[0:7], Red[0:7], Blue[0:7]]
			tinyLED_SPIWriteByte(rgb_colors[i].green);
    1162:	d5 01       	movw	r26, r10
    1164:	11 96       	adiw	r26, 0x01	; 1
    1166:	8c 91       	ld	r24, X
    1168:	0e 94 ad 05 	call	0xb5a	; 0xb5a <tinyLED_SPIWriteByte>
			tinyLED_SPIWriteByte(rgb_colors[i].red);
    116c:	f5 01       	movw	r30, r10
    116e:	80 81       	ld	r24, Z
    1170:	0e 94 ad 05 	call	0xb5a	; 0xb5a <tinyLED_SPIWriteByte>
			tinyLED_SPIWriteByte(rgb_colors[i].blue);
    1174:	d5 01       	movw	r26, r10
    1176:	12 96       	adiw	r26, 0x02	; 2
    1178:	8c 91       	ld	r24, X
    117a:	0e 94 ad 05 	call	0xb5a	; 0xb5a <tinyLED_SPIWriteByte>
			tinyLED_old_colors[i] = rgb_colors[i];
    117e:	f5 01       	movw	r30, r10
    1180:	81 91       	ld	r24, Z+
    1182:	91 91       	ld	r25, Z+
    1184:	a1 91       	ld	r26, Z+
    1186:	5f 01       	movw	r10, r30
    1188:	f8 01       	movw	r30, r16
    118a:	81 93       	st	Z+, r24
    118c:	91 93       	st	Z+, r25
    118e:	a1 93       	st	Z+, r26
    1190:	8f 01       	movw	r16, r30
		}
	}
	
	// We only write to the LEDs if there is something to change. (eg. in SWING mode, we update the LEDs almost every cycle)
	if(!tinyLED_RGB_Color_Compare(&rgb_colors, &tinyLED_old_colors)){
		for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
    1192:	ae 14       	cp	r10, r14
    1194:	bf 04       	cpc	r11, r15
    1196:	29 f7       	brne	.-54     	; 0x1162 <tinyLED_update+0x4de>
			tinyLED_SPIWriteByte(rgb_colors[i].red);
			tinyLED_SPIWriteByte(rgb_colors[i].blue);
			tinyLED_old_colors[i] = rgb_colors[i];
		}
	}
}
    1198:	ab 96       	adiw	r28, 0x2b	; 43
    119a:	cd bf       	out	0x3d, r28	; 61
    119c:	de bf       	out	0x3e, r29	; 62
    119e:	df 91       	pop	r29
    11a0:	cf 91       	pop	r28
    11a2:	1f 91       	pop	r17
    11a4:	0f 91       	pop	r16
    11a6:	ff 90       	pop	r15
    11a8:	ef 90       	pop	r14
    11aa:	df 90       	pop	r13
    11ac:	cf 90       	pop	r12
    11ae:	bf 90       	pop	r11
    11b0:	af 90       	pop	r10
    11b2:	9f 90       	pop	r9
    11b4:	8f 90       	pop	r8
    11b6:	7f 90       	pop	r7
    11b8:	6f 90       	pop	r6
    11ba:	5f 90       	pop	r5
    11bc:	4f 90       	pop	r4
    11be:	3f 90       	pop	r3
    11c0:	2f 90       	pop	r2
    11c2:	08 95       	ret

000011c4 <tinyPotential_get_potential>:
/*
Sends the potential
*/
double tinyPotential_get_potential()
{
	return tinyPotential_potential;
    11c4:	60 91 4a 38 	lds	r22, 0x384A	; 0x80384a <tinyPotential_potential>
    11c8:	70 91 4b 38 	lds	r23, 0x384B	; 0x80384b <tinyPotential_potential+0x1>
    11cc:	80 91 4c 38 	lds	r24, 0x384C	; 0x80384c <tinyPotential_potential+0x2>
    11d0:	90 91 4d 38 	lds	r25, 0x384D	; 0x80384d <tinyPotential_potential+0x3>
}
    11d4:	08 95       	ret

000011d6 <tinyPotential_update>:

/*
Update the potential
*/
void tinyPotential_update()
{
    11d6:	cf 92       	push	r12
    11d8:	df 92       	push	r13
    11da:	ef 92       	push	r14
    11dc:	ff 92       	push	r15
Function to decay the potential towards 0
*/
static void tinyPotential_decay()
{
		
	uint8_t time_since_last_update = tinyTime_now() - previous_update_time;
    11de:	0e 94 ec 09 	call	0x13d8	; 0x13d8 <tinyTime_now>
	tinyPotential_potential *= (exp(-((float)time_since_last_update/(float)TINYPOTENTIAL_TIME_CONST)));
    11e2:	80 91 46 38 	lds	r24, 0x3846	; 0x803846 <previous_update_time>
    11e6:	68 1b       	sub	r22, r24
    11e8:	70 e0       	ldi	r23, 0x00	; 0
    11ea:	80 e0       	ldi	r24, 0x00	; 0
    11ec:	90 e0       	ldi	r25, 0x00	; 0
    11ee:	0e 94 49 0b 	call	0x1692	; 0x1692 <__floatunsisf>
    11f2:	20 e0       	ldi	r18, 0x00	; 0
    11f4:	30 e0       	ldi	r19, 0x00	; 0
    11f6:	48 ec       	ldi	r20, 0xC8	; 200
    11f8:	52 e4       	ldi	r21, 0x42	; 66
    11fa:	0e 94 67 0a 	call	0x14ce	; 0x14ce <__divsf3>
    11fe:	90 58       	subi	r25, 0x80	; 128
    1200:	0e 94 e1 0a 	call	0x15c2	; 0x15c2 <exp>
    1204:	20 91 4a 38 	lds	r18, 0x384A	; 0x80384a <tinyPotential_potential>
    1208:	30 91 4b 38 	lds	r19, 0x384B	; 0x80384b <tinyPotential_potential+0x1>
    120c:	40 91 4c 38 	lds	r20, 0x384C	; 0x80384c <tinyPotential_potential+0x2>
    1210:	50 91 4d 38 	lds	r21, 0x384D	; 0x80384d <tinyPotential_potential+0x3>
    1214:	0e 94 bc 0c 	call	0x1978	; 0x1978 <__mulsf3>
    1218:	6b 01       	movw	r12, r22
    121a:	7c 01       	movw	r14, r24
	if(fabs(tinyPotential_potential)<POLARIZATION_OFFSET){
    121c:	9f 77       	andi	r25, 0x7F	; 127
    121e:	2d ec       	ldi	r18, 0xCD	; 205
    1220:	3c ec       	ldi	r19, 0xCC	; 204
    1222:	4c ec       	ldi	r20, 0xCC	; 204
    1224:	5d e3       	ldi	r21, 0x3D	; 61
    1226:	0e 94 62 0a 	call	0x14c4	; 0x14c4 <__cmpsf2>
    122a:	88 23       	and	r24, r24
    122c:	4c f0       	brlt	.+18     	; 0x1240 <tinyPotential_update+0x6a>
*/
static void tinyPotential_decay()
{
		
	uint8_t time_since_last_update = tinyTime_now() - previous_update_time;
	tinyPotential_potential *= (exp(-((float)time_since_last_update/(float)TINYPOTENTIAL_TIME_CONST)));
    122e:	c0 92 4a 38 	sts	0x384A, r12	; 0x80384a <tinyPotential_potential>
    1232:	d0 92 4b 38 	sts	0x384B, r13	; 0x80384b <tinyPotential_potential+0x1>
    1236:	e0 92 4c 38 	sts	0x384C, r14	; 0x80384c <tinyPotential_potential+0x2>
    123a:	f0 92 4d 38 	sts	0x384D, r15	; 0x80384d <tinyPotential_potential+0x3>
    123e:	08 c0       	rjmp	.+16     	; 0x1250 <tinyPotential_update+0x7a>
	if(fabs(tinyPotential_potential)<POLARIZATION_OFFSET){
		tinyPotential_potential=0;
    1240:	10 92 4a 38 	sts	0x384A, r1	; 0x80384a <tinyPotential_potential>
    1244:	10 92 4b 38 	sts	0x384B, r1	; 0x80384b <tinyPotential_potential+0x1>
    1248:	10 92 4c 38 	sts	0x384C, r1	; 0x80384c <tinyPotential_potential+0x2>
    124c:	10 92 4d 38 	sts	0x384D, r1	; 0x80384d <tinyPotential_potential+0x3>
	}
	previous_update_time = tinyTime_now();
    1250:	0e 94 ec 09 	call	0x13d8	; 0x13d8 <tinyTime_now>
    1254:	60 93 46 38 	sts	0x3846, r22	; 0x803846 <previous_update_time>
    1258:	70 93 47 38 	sts	0x3847, r23	; 0x803847 <previous_update_time+0x1>
    125c:	80 93 48 38 	sts	0x3848, r24	; 0x803848 <previous_update_time+0x2>
    1260:	90 93 49 38 	sts	0x3849, r25	; 0x803849 <previous_update_time+0x3>
void tinyPotential_update()
{
	//Some of the potential in the neuron has decayed away
	tinyPotential_decay();
	// Update potential with values from Dendrites
	tinyPotential_potential = tinyDendrite_update_potential(tinyPotential_potential);
    1264:	60 91 4a 38 	lds	r22, 0x384A	; 0x80384a <tinyPotential_potential>
    1268:	70 91 4b 38 	lds	r23, 0x384B	; 0x80384b <tinyPotential_potential+0x1>
    126c:	80 91 4c 38 	lds	r24, 0x384C	; 0x80384c <tinyPotential_potential+0x2>
    1270:	90 91 4d 38 	lds	r25, 0x384D	; 0x80384d <tinyPotential_potential+0x3>
    1274:	0e 94 65 05 	call	0xaca	; 0xaca <tinyDendrite_update_potential>
    1278:	60 93 4a 38 	sts	0x384A, r22	; 0x80384a <tinyPotential_potential>
    127c:	70 93 4b 38 	sts	0x384B, r23	; 0x80384b <tinyPotential_potential+0x1>
    1280:	80 93 4c 38 	sts	0x384C, r24	; 0x80384c <tinyPotential_potential+0x2>
    1284:	90 93 4d 38 	sts	0x384D, r25	; 0x80384d <tinyPotential_potential+0x3>
	
	// Update potential from button press
	tinyPotential_potential = tinyButton_update_potential(tinyPotential_potential);
    1288:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <tinyButton_update_potential>
    128c:	60 93 4a 38 	sts	0x384A, r22	; 0x80384a <tinyPotential_potential>
    1290:	70 93 4b 38 	sts	0x384B, r23	; 0x80384b <tinyPotential_potential+0x1>
    1294:	80 93 4c 38 	sts	0x384C, r24	; 0x80384c <tinyPotential_potential+0x2>
    1298:	90 93 4d 38 	sts	0x384D, r25	; 0x80384d <tinyPotential_potential+0x3>
	
	// Update potential with values from spontaneous pulse.
	tinyPotential_potential = tinyPulse_update_potential(tinyPotential_potential);
    129c:	0e 94 8e 09 	call	0x131c	; 0x131c <tinyPulse_update_potential>
    12a0:	ab 01       	movw	r20, r22
    12a2:	bc 01       	movw	r22, r24
    12a4:	40 93 4a 38 	sts	0x384A, r20	; 0x80384a <tinyPotential_potential>
    12a8:	50 93 4b 38 	sts	0x384B, r21	; 0x80384b <tinyPotential_potential+0x1>
    12ac:	60 93 4c 38 	sts	0x384C, r22	; 0x80384c <tinyPotential_potential+0x2>
    12b0:	70 93 4d 38 	sts	0x384D, r23	; 0x80384d <tinyPotential_potential+0x3>
	
	tinyDebugger_send_double("Potential", tinyPotential_potential);
    12b4:	84 e9       	ldi	r24, 0x94	; 148
    12b6:	9b e9       	ldi	r25, 0x9B	; 155
    12b8:	0e 94 61 04 	call	0x8c2	; 0x8c2 <tinyDebugger_send_double>
	
	
	// Let the axon affect the potential
	// This is also where we decide whether or not the axon should fire
	tinyPotential_potential = tinyAxon_update_potential(tinyPotential_potential);
    12bc:	60 91 4a 38 	lds	r22, 0x384A	; 0x80384a <tinyPotential_potential>
    12c0:	70 91 4b 38 	lds	r23, 0x384B	; 0x80384b <tinyPotential_potential+0x1>
    12c4:	80 91 4c 38 	lds	r24, 0x384C	; 0x80384c <tinyPotential_potential+0x2>
    12c8:	90 91 4d 38 	lds	r25, 0x384D	; 0x80384d <tinyPotential_potential+0x3>
    12cc:	0e 94 c1 02 	call	0x582	; 0x582 <tinyAxon_update_potential>
    12d0:	60 93 4a 38 	sts	0x384A, r22	; 0x80384a <tinyPotential_potential>
    12d4:	70 93 4b 38 	sts	0x384B, r23	; 0x80384b <tinyPotential_potential+0x1>
    12d8:	80 93 4c 38 	sts	0x384C, r24	; 0x80384c <tinyPotential_potential+0x2>
    12dc:	90 93 4d 38 	sts	0x384D, r25	; 0x80384d <tinyPotential_potential+0x3>
}
    12e0:	ff 90       	pop	r15
    12e2:	ef 90       	pop	r14
    12e4:	df 90       	pop	r13
    12e6:	cf 90       	pop	r12
    12e8:	08 95       	ret

000012ea <tinyPulse_toggle_pulse_mode>:
_Bool tinyPulse_is_in_pulse_mode(){
	return pulse_mode;
}

void tinyPulse_toggle_pulse_mode(){
	pulse_mode = !pulse_mode;
    12ea:	90 91 54 38 	lds	r25, 0x3854	; 0x803854 <pulse_mode>
    12ee:	81 e0       	ldi	r24, 0x01	; 1
    12f0:	89 27       	eor	r24, r25
    12f2:	80 93 54 38 	sts	0x3854, r24	; 0x803854 <pulse_mode>
	
	if(tinyPulse_is_in_pulse_mode()){
    12f6:	88 23       	and	r24, r24
    12f8:	31 f0       	breq	.+12     	; 0x1306 <tinyPulse_toggle_pulse_mode+0x1c>
		tinyLED_set_color_mode(OUT_LED, PULSEMODE_COLOR, WEAK);
    12fa:	41 e0       	ldi	r20, 0x01	; 1
    12fc:	63 e0       	ldi	r22, 0x03	; 3
    12fe:	81 e0       	ldi	r24, 0x01	; 1
    1300:	0e 94 c9 05 	call	0xb92	; 0xb92 <tinyLED_set_color_mode>
    1304:	08 95       	ret
		//tinyLED_set_color_mode(INN_LED, PULSEMODE_COLOR, WEAK);
	}
	else{
		tinyLED_set_color(OUT_LED, LED_OFF);
    1306:	60 e0       	ldi	r22, 0x00	; 0
    1308:	81 e0       	ldi	r24, 0x01	; 1
    130a:	0e 94 0e 06 	call	0xc1c	; 0xc1c <tinyLED_set_color>
    130e:	08 95       	ret

00001310 <tinyPulse_set_pulse_mode>:
		//tinyLED_set_color(INN_LED, LED_OFF);
	}
}

void tinyPulse_set_pulse_mode(_Bool mode){
	if (pulse_mode != mode)
    1310:	90 91 54 38 	lds	r25, 0x3854	; 0x803854 <pulse_mode>
    1314:	98 13       	cpse	r25, r24
	{
		tinyPulse_toggle_pulse_mode();
    1316:	0e 94 75 09 	call	0x12ea	; 0x12ea <tinyPulse_toggle_pulse_mode>
    131a:	08 95       	ret

0000131c <tinyPulse_update_potential>:
	}
}

double tinyPulse_update_potential(double potential){
    131c:	cf 92       	push	r12
    131e:	df 92       	push	r13
    1320:	ef 92       	push	r14
    1322:	ff 92       	push	r15
    1324:	6b 01       	movw	r12, r22
    1326:	7c 01       	movw	r14, r24
	if(pulse_mode){
    1328:	80 91 54 38 	lds	r24, 0x3854	; 0x803854 <pulse_mode>
    132c:	88 23       	and	r24, r24
    132e:	39 f1       	breq	.+78     	; 0x137e <tinyPulse_update_potential+0x62>
		
		time_since_last_pulse = tinyTime_now() - time_of_last_pulse;
    1330:	0e 94 ec 09 	call	0x13d8	; 0x13d8 <tinyTime_now>
    1334:	20 91 50 38 	lds	r18, 0x3850	; 0x803850 <time_of_last_pulse>
    1338:	30 91 51 38 	lds	r19, 0x3851	; 0x803851 <time_of_last_pulse+0x1>
    133c:	62 1b       	sub	r22, r18
    133e:	73 0b       	sbc	r23, r19
    1340:	60 93 4e 38 	sts	0x384E, r22	; 0x80384e <time_since_last_pulse>
    1344:	70 93 4f 38 	sts	0x384F, r23	; 0x80384f <time_since_last_pulse+0x1>
		
		if(time_since_last_pulse >= ideal_time_between_pulses){
    1348:	80 91 13 38 	lds	r24, 0x3813	; 0x803813 <ideal_time_between_pulses>
    134c:	90 91 14 38 	lds	r25, 0x3814	; 0x803814 <ideal_time_between_pulses+0x1>
    1350:	68 17       	cp	r22, r24
    1352:	79 07       	cpc	r23, r25
    1354:	a0 f0       	brcs	.+40     	; 0x137e <tinyPulse_update_potential+0x62>
			// This isn't actually a button press. You could have a separate variable for this, but it seems unnecessary.
			potential += BUTTON_PRESS_REACTION;
    1356:	20 e0       	ldi	r18, 0x00	; 0
    1358:	30 e0       	ldi	r19, 0x00	; 0
    135a:	40 ed       	ldi	r20, 0xD0	; 208
    135c:	51 e4       	ldi	r21, 0x41	; 65
    135e:	c7 01       	movw	r24, r14
    1360:	b6 01       	movw	r22, r12
    1362:	0e 94 f6 09 	call	0x13ec	; 0x13ec <__addsf3>
    1366:	6b 01       	movw	r12, r22
    1368:	7c 01       	movw	r14, r24
			time_of_last_pulse = tinyTime_now();			
    136a:	0e 94 ec 09 	call	0x13d8	; 0x13d8 <tinyTime_now>
    136e:	60 93 50 38 	sts	0x3850, r22	; 0x803850 <time_of_last_pulse>
    1372:	70 93 51 38 	sts	0x3851, r23	; 0x803851 <time_of_last_pulse+0x1>
    1376:	80 93 52 38 	sts	0x3852, r24	; 0x803852 <time_of_last_pulse+0x2>
    137a:	90 93 53 38 	sts	0x3853, r25	; 0x803853 <time_of_last_pulse+0x3>
		}
	}
	return potential;
}
    137e:	c7 01       	movw	r24, r14
    1380:	b6 01       	movw	r22, r12
    1382:	ff 90       	pop	r15
    1384:	ef 90       	pop	r14
    1386:	df 90       	pop	r13
    1388:	cf 90       	pop	r12
    138a:	08 95       	ret

0000138c <tinySleep_prepare_sleep>:
  PCMSK |= _BV(PCINT3);                   // Use PB3 as interrupt pin
  ADCSRA &= ~_BV(ADEN);                   // ADC off
  */
  
  //set_sleep_mode(SLEEP_MODE_PWR_DOWN);  // Set sleep mode to POWER DOWN mode
  set_sleep_mode(SLEEP_MODE_IDLE);  // Set sleep mode to POWER DOWN mode
    138c:	e0 e5       	ldi	r30, 0x50	; 80
    138e:	f0 e0       	ldi	r31, 0x00	; 0
    1390:	80 81       	ld	r24, Z
    1392:	89 7f       	andi	r24, 0xF9	; 249
    1394:	80 83       	st	Z, r24
  sleep_enable();
    1396:	80 81       	ld	r24, Z
    1398:	81 60       	ori	r24, 0x01	; 1
    139a:	80 83       	st	Z, r24
    139c:	08 95       	ret

0000139e <tinySleep_enter_sleep>:

void tinySleep_enter_sleep(){

	
  //sleep_bod_disable();
  cli();
    139e:	f8 94       	cli
  sei();
    13a0:	78 94       	sei
  sleep_cpu();
    13a2:	88 95       	sleep
  sleep_disable();
    13a4:	e0 e5       	ldi	r30, 0x50	; 80
    13a6:	f0 e0       	ldi	r31, 0x00	; 0
    13a8:	80 81       	ld	r24, Z
    13aa:	8e 7f       	andi	r24, 0xFE	; 254
    13ac:	80 83       	st	Z, r24
    13ae:	08 95       	ret

000013b0 <tinyTime_counter_increment>:
If the Interrupt Service Routine is clocked by a crystal oscillator
it gives a very precise timer-counter.
*/
void tinyTime_counter_increment(void)
{
	time_counter++;
    13b0:	80 91 55 38 	lds	r24, 0x3855	; 0x803855 <time_counter>
    13b4:	90 91 56 38 	lds	r25, 0x3856	; 0x803856 <time_counter+0x1>
    13b8:	a0 91 57 38 	lds	r26, 0x3857	; 0x803857 <time_counter+0x2>
    13bc:	b0 91 58 38 	lds	r27, 0x3858	; 0x803858 <time_counter+0x3>
    13c0:	01 96       	adiw	r24, 0x01	; 1
    13c2:	a1 1d       	adc	r26, r1
    13c4:	b1 1d       	adc	r27, r1
    13c6:	80 93 55 38 	sts	0x3855, r24	; 0x803855 <time_counter>
    13ca:	90 93 56 38 	sts	0x3856, r25	; 0x803856 <time_counter+0x1>
    13ce:	a0 93 57 38 	sts	0x3857, r26	; 0x803857 <time_counter+0x2>
    13d2:	b0 93 58 38 	sts	0x3858, r27	; 0x803858 <time_counter+0x3>
    13d6:	08 95       	ret

000013d8 <tinyTime_now>:
/*
This function is callable by external libraries to give them the counted time so far.
*/
uint32_t tinyTime_now(void)
{
	return time_counter;
    13d8:	60 91 55 38 	lds	r22, 0x3855	; 0x803855 <time_counter>
    13dc:	70 91 56 38 	lds	r23, 0x3856	; 0x803856 <time_counter+0x1>
    13e0:	80 91 57 38 	lds	r24, 0x3857	; 0x803857 <time_counter+0x2>
    13e4:	90 91 58 38 	lds	r25, 0x3858	; 0x803858 <time_counter+0x3>
    13e8:	08 95       	ret

000013ea <__subsf3>:
    13ea:	50 58       	subi	r21, 0x80	; 128

000013ec <__addsf3>:
    13ec:	bb 27       	eor	r27, r27
    13ee:	aa 27       	eor	r26, r26
    13f0:	0e 94 0d 0a 	call	0x141a	; 0x141a <__addsf3x>
    13f4:	0c 94 07 0c 	jmp	0x180e	; 0x180e <__fp_round>
    13f8:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <__fp_pscA>
    13fc:	38 f0       	brcs	.+14     	; 0x140c <__addsf3+0x20>
    13fe:	0e 94 00 0c 	call	0x1800	; 0x1800 <__fp_pscB>
    1402:	20 f0       	brcs	.+8      	; 0x140c <__addsf3+0x20>
    1404:	39 f4       	brne	.+14     	; 0x1414 <__addsf3+0x28>
    1406:	9f 3f       	cpi	r25, 0xFF	; 255
    1408:	19 f4       	brne	.+6      	; 0x1410 <__addsf3+0x24>
    140a:	26 f4       	brtc	.+8      	; 0x1414 <__addsf3+0x28>
    140c:	0c 94 cf 0b 	jmp	0x179e	; 0x179e <__fp_nan>
    1410:	0e f4       	brtc	.+2      	; 0x1414 <__addsf3+0x28>
    1412:	e0 95       	com	r30
    1414:	e7 fb       	bst	r30, 7
    1416:	0c 94 c9 0b 	jmp	0x1792	; 0x1792 <__fp_inf>

0000141a <__addsf3x>:
    141a:	e9 2f       	mov	r30, r25
    141c:	0e 94 18 0c 	call	0x1830	; 0x1830 <__fp_split3>
    1420:	58 f3       	brcs	.-42     	; 0x13f8 <__addsf3+0xc>
    1422:	ba 17       	cp	r27, r26
    1424:	62 07       	cpc	r22, r18
    1426:	73 07       	cpc	r23, r19
    1428:	84 07       	cpc	r24, r20
    142a:	95 07       	cpc	r25, r21
    142c:	20 f0       	brcs	.+8      	; 0x1436 <__addsf3x+0x1c>
    142e:	79 f4       	brne	.+30     	; 0x144e <__addsf3x+0x34>
    1430:	a6 f5       	brtc	.+104    	; 0x149a <__addsf3x+0x80>
    1432:	0c 94 3a 0c 	jmp	0x1874	; 0x1874 <__fp_zero>
    1436:	0e f4       	brtc	.+2      	; 0x143a <__addsf3x+0x20>
    1438:	e0 95       	com	r30
    143a:	0b 2e       	mov	r0, r27
    143c:	ba 2f       	mov	r27, r26
    143e:	a0 2d       	mov	r26, r0
    1440:	0b 01       	movw	r0, r22
    1442:	b9 01       	movw	r22, r18
    1444:	90 01       	movw	r18, r0
    1446:	0c 01       	movw	r0, r24
    1448:	ca 01       	movw	r24, r20
    144a:	a0 01       	movw	r20, r0
    144c:	11 24       	eor	r1, r1
    144e:	ff 27       	eor	r31, r31
    1450:	59 1b       	sub	r21, r25
    1452:	99 f0       	breq	.+38     	; 0x147a <__addsf3x+0x60>
    1454:	59 3f       	cpi	r21, 0xF9	; 249
    1456:	50 f4       	brcc	.+20     	; 0x146c <__addsf3x+0x52>
    1458:	50 3e       	cpi	r21, 0xE0	; 224
    145a:	68 f1       	brcs	.+90     	; 0x14b6 <__addsf3x+0x9c>
    145c:	1a 16       	cp	r1, r26
    145e:	f0 40       	sbci	r31, 0x00	; 0
    1460:	a2 2f       	mov	r26, r18
    1462:	23 2f       	mov	r18, r19
    1464:	34 2f       	mov	r19, r20
    1466:	44 27       	eor	r20, r20
    1468:	58 5f       	subi	r21, 0xF8	; 248
    146a:	f3 cf       	rjmp	.-26     	; 0x1452 <__addsf3x+0x38>
    146c:	46 95       	lsr	r20
    146e:	37 95       	ror	r19
    1470:	27 95       	ror	r18
    1472:	a7 95       	ror	r26
    1474:	f0 40       	sbci	r31, 0x00	; 0
    1476:	53 95       	inc	r21
    1478:	c9 f7       	brne	.-14     	; 0x146c <__addsf3x+0x52>
    147a:	7e f4       	brtc	.+30     	; 0x149a <__addsf3x+0x80>
    147c:	1f 16       	cp	r1, r31
    147e:	ba 0b       	sbc	r27, r26
    1480:	62 0b       	sbc	r22, r18
    1482:	73 0b       	sbc	r23, r19
    1484:	84 0b       	sbc	r24, r20
    1486:	ba f0       	brmi	.+46     	; 0x14b6 <__addsf3x+0x9c>
    1488:	91 50       	subi	r25, 0x01	; 1
    148a:	a1 f0       	breq	.+40     	; 0x14b4 <__addsf3x+0x9a>
    148c:	ff 0f       	add	r31, r31
    148e:	bb 1f       	adc	r27, r27
    1490:	66 1f       	adc	r22, r22
    1492:	77 1f       	adc	r23, r23
    1494:	88 1f       	adc	r24, r24
    1496:	c2 f7       	brpl	.-16     	; 0x1488 <__addsf3x+0x6e>
    1498:	0e c0       	rjmp	.+28     	; 0x14b6 <__addsf3x+0x9c>
    149a:	ba 0f       	add	r27, r26
    149c:	62 1f       	adc	r22, r18
    149e:	73 1f       	adc	r23, r19
    14a0:	84 1f       	adc	r24, r20
    14a2:	48 f4       	brcc	.+18     	; 0x14b6 <__addsf3x+0x9c>
    14a4:	87 95       	ror	r24
    14a6:	77 95       	ror	r23
    14a8:	67 95       	ror	r22
    14aa:	b7 95       	ror	r27
    14ac:	f7 95       	ror	r31
    14ae:	9e 3f       	cpi	r25, 0xFE	; 254
    14b0:	08 f0       	brcs	.+2      	; 0x14b4 <__addsf3x+0x9a>
    14b2:	b0 cf       	rjmp	.-160    	; 0x1414 <__addsf3+0x28>
    14b4:	93 95       	inc	r25
    14b6:	88 0f       	add	r24, r24
    14b8:	08 f0       	brcs	.+2      	; 0x14bc <__addsf3x+0xa2>
    14ba:	99 27       	eor	r25, r25
    14bc:	ee 0f       	add	r30, r30
    14be:	97 95       	ror	r25
    14c0:	87 95       	ror	r24
    14c2:	08 95       	ret

000014c4 <__cmpsf2>:
    14c4:	0e 94 a5 0b 	call	0x174a	; 0x174a <__fp_cmp>
    14c8:	08 f4       	brcc	.+2      	; 0x14cc <__cmpsf2+0x8>
    14ca:	81 e0       	ldi	r24, 0x01	; 1
    14cc:	08 95       	ret

000014ce <__divsf3>:
    14ce:	0e 94 7b 0a 	call	0x14f6	; 0x14f6 <__divsf3x>
    14d2:	0c 94 07 0c 	jmp	0x180e	; 0x180e <__fp_round>
    14d6:	0e 94 00 0c 	call	0x1800	; 0x1800 <__fp_pscB>
    14da:	58 f0       	brcs	.+22     	; 0x14f2 <__divsf3+0x24>
    14dc:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <__fp_pscA>
    14e0:	40 f0       	brcs	.+16     	; 0x14f2 <__divsf3+0x24>
    14e2:	29 f4       	brne	.+10     	; 0x14ee <__divsf3+0x20>
    14e4:	5f 3f       	cpi	r21, 0xFF	; 255
    14e6:	29 f0       	breq	.+10     	; 0x14f2 <__divsf3+0x24>
    14e8:	0c 94 c9 0b 	jmp	0x1792	; 0x1792 <__fp_inf>
    14ec:	51 11       	cpse	r21, r1
    14ee:	0c 94 3b 0c 	jmp	0x1876	; 0x1876 <__fp_szero>
    14f2:	0c 94 cf 0b 	jmp	0x179e	; 0x179e <__fp_nan>

000014f6 <__divsf3x>:
    14f6:	0e 94 18 0c 	call	0x1830	; 0x1830 <__fp_split3>
    14fa:	68 f3       	brcs	.-38     	; 0x14d6 <__divsf3+0x8>

000014fc <__divsf3_pse>:
    14fc:	99 23       	and	r25, r25
    14fe:	b1 f3       	breq	.-20     	; 0x14ec <__divsf3+0x1e>
    1500:	55 23       	and	r21, r21
    1502:	91 f3       	breq	.-28     	; 0x14e8 <__divsf3+0x1a>
    1504:	95 1b       	sub	r25, r21
    1506:	55 0b       	sbc	r21, r21
    1508:	bb 27       	eor	r27, r27
    150a:	aa 27       	eor	r26, r26
    150c:	62 17       	cp	r22, r18
    150e:	73 07       	cpc	r23, r19
    1510:	84 07       	cpc	r24, r20
    1512:	38 f0       	brcs	.+14     	; 0x1522 <__divsf3_pse+0x26>
    1514:	9f 5f       	subi	r25, 0xFF	; 255
    1516:	5f 4f       	sbci	r21, 0xFF	; 255
    1518:	22 0f       	add	r18, r18
    151a:	33 1f       	adc	r19, r19
    151c:	44 1f       	adc	r20, r20
    151e:	aa 1f       	adc	r26, r26
    1520:	a9 f3       	breq	.-22     	; 0x150c <__divsf3_pse+0x10>
    1522:	35 d0       	rcall	.+106    	; 0x158e <__divsf3_pse+0x92>
    1524:	0e 2e       	mov	r0, r30
    1526:	3a f0       	brmi	.+14     	; 0x1536 <__divsf3_pse+0x3a>
    1528:	e0 e8       	ldi	r30, 0x80	; 128
    152a:	32 d0       	rcall	.+100    	; 0x1590 <__divsf3_pse+0x94>
    152c:	91 50       	subi	r25, 0x01	; 1
    152e:	50 40       	sbci	r21, 0x00	; 0
    1530:	e6 95       	lsr	r30
    1532:	00 1c       	adc	r0, r0
    1534:	ca f7       	brpl	.-14     	; 0x1528 <__divsf3_pse+0x2c>
    1536:	2b d0       	rcall	.+86     	; 0x158e <__divsf3_pse+0x92>
    1538:	fe 2f       	mov	r31, r30
    153a:	29 d0       	rcall	.+82     	; 0x158e <__divsf3_pse+0x92>
    153c:	66 0f       	add	r22, r22
    153e:	77 1f       	adc	r23, r23
    1540:	88 1f       	adc	r24, r24
    1542:	bb 1f       	adc	r27, r27
    1544:	26 17       	cp	r18, r22
    1546:	37 07       	cpc	r19, r23
    1548:	48 07       	cpc	r20, r24
    154a:	ab 07       	cpc	r26, r27
    154c:	b0 e8       	ldi	r27, 0x80	; 128
    154e:	09 f0       	breq	.+2      	; 0x1552 <__divsf3_pse+0x56>
    1550:	bb 0b       	sbc	r27, r27
    1552:	80 2d       	mov	r24, r0
    1554:	bf 01       	movw	r22, r30
    1556:	ff 27       	eor	r31, r31
    1558:	93 58       	subi	r25, 0x83	; 131
    155a:	5f 4f       	sbci	r21, 0xFF	; 255
    155c:	3a f0       	brmi	.+14     	; 0x156c <__divsf3_pse+0x70>
    155e:	9e 3f       	cpi	r25, 0xFE	; 254
    1560:	51 05       	cpc	r21, r1
    1562:	78 f0       	brcs	.+30     	; 0x1582 <__divsf3_pse+0x86>
    1564:	0c 94 c9 0b 	jmp	0x1792	; 0x1792 <__fp_inf>
    1568:	0c 94 3b 0c 	jmp	0x1876	; 0x1876 <__fp_szero>
    156c:	5f 3f       	cpi	r21, 0xFF	; 255
    156e:	e4 f3       	brlt	.-8      	; 0x1568 <__divsf3_pse+0x6c>
    1570:	98 3e       	cpi	r25, 0xE8	; 232
    1572:	d4 f3       	brlt	.-12     	; 0x1568 <__divsf3_pse+0x6c>
    1574:	86 95       	lsr	r24
    1576:	77 95       	ror	r23
    1578:	67 95       	ror	r22
    157a:	b7 95       	ror	r27
    157c:	f7 95       	ror	r31
    157e:	9f 5f       	subi	r25, 0xFF	; 255
    1580:	c9 f7       	brne	.-14     	; 0x1574 <__divsf3_pse+0x78>
    1582:	88 0f       	add	r24, r24
    1584:	91 1d       	adc	r25, r1
    1586:	96 95       	lsr	r25
    1588:	87 95       	ror	r24
    158a:	97 f9       	bld	r25, 7
    158c:	08 95       	ret
    158e:	e1 e0       	ldi	r30, 0x01	; 1
    1590:	66 0f       	add	r22, r22
    1592:	77 1f       	adc	r23, r23
    1594:	88 1f       	adc	r24, r24
    1596:	bb 1f       	adc	r27, r27
    1598:	62 17       	cp	r22, r18
    159a:	73 07       	cpc	r23, r19
    159c:	84 07       	cpc	r24, r20
    159e:	ba 07       	cpc	r27, r26
    15a0:	20 f0       	brcs	.+8      	; 0x15aa <__divsf3_pse+0xae>
    15a2:	62 1b       	sub	r22, r18
    15a4:	73 0b       	sbc	r23, r19
    15a6:	84 0b       	sbc	r24, r20
    15a8:	ba 0b       	sbc	r27, r26
    15aa:	ee 1f       	adc	r30, r30
    15ac:	88 f7       	brcc	.-30     	; 0x1590 <__divsf3_pse+0x94>
    15ae:	e0 95       	com	r30
    15b0:	08 95       	ret
    15b2:	29 f4       	brne	.+10     	; 0x15be <__divsf3_pse+0xc2>
    15b4:	16 f0       	brts	.+4      	; 0x15ba <__divsf3_pse+0xbe>
    15b6:	0c 94 c9 0b 	jmp	0x1792	; 0x1792 <__fp_inf>
    15ba:	0c 94 3a 0c 	jmp	0x1874	; 0x1874 <__fp_zero>
    15be:	0c 94 cf 0b 	jmp	0x179e	; 0x179e <__fp_nan>

000015c2 <exp>:
    15c2:	0e 94 20 0c 	call	0x1840	; 0x1840 <__fp_splitA>
    15c6:	a8 f3       	brcs	.-22     	; 0x15b2 <__divsf3_pse+0xb6>
    15c8:	96 38       	cpi	r25, 0x86	; 134
    15ca:	a0 f7       	brcc	.-24     	; 0x15b4 <__divsf3_pse+0xb8>
    15cc:	07 f8       	bld	r0, 7
    15ce:	0f 92       	push	r0
    15d0:	e8 94       	clt
    15d2:	2b e3       	ldi	r18, 0x3B	; 59
    15d4:	3a ea       	ldi	r19, 0xAA	; 170
    15d6:	48 eb       	ldi	r20, 0xB8	; 184
    15d8:	5f e7       	ldi	r21, 0x7F	; 127
    15da:	0e 94 d2 0c 	call	0x19a4	; 0x19a4 <__mulsf3_pse>
    15de:	0f 92       	push	r0
    15e0:	0f 92       	push	r0
    15e2:	0f 92       	push	r0
    15e4:	4d b7       	in	r20, 0x3d	; 61
    15e6:	5e b7       	in	r21, 0x3e	; 62
    15e8:	0f 92       	push	r0
    15ea:	0e 94 88 0c 	call	0x1910	; 0x1910 <modf>
    15ee:	ec e7       	ldi	r30, 0x7C	; 124
    15f0:	f0 e0       	ldi	r31, 0x00	; 0
    15f2:	0e 94 d2 0b 	call	0x17a4	; 0x17a4 <__fp_powser>
    15f6:	4f 91       	pop	r20
    15f8:	5f 91       	pop	r21
    15fa:	ef 91       	pop	r30
    15fc:	ff 91       	pop	r31
    15fe:	e5 95       	asr	r30
    1600:	ee 1f       	adc	r30, r30
    1602:	ff 1f       	adc	r31, r31
    1604:	49 f0       	breq	.+18     	; 0x1618 <exp+0x56>
    1606:	fe 57       	subi	r31, 0x7E	; 126
    1608:	e0 68       	ori	r30, 0x80	; 128
    160a:	44 27       	eor	r20, r20
    160c:	ee 0f       	add	r30, r30
    160e:	44 1f       	adc	r20, r20
    1610:	fa 95       	dec	r31
    1612:	e1 f7       	brne	.-8      	; 0x160c <exp+0x4a>
    1614:	41 95       	neg	r20
    1616:	55 0b       	sbc	r21, r21
    1618:	0e 94 52 0c 	call	0x18a4	; 0x18a4 <ldexp>
    161c:	0f 90       	pop	r0
    161e:	07 fe       	sbrs	r0, 7
    1620:	0c 94 46 0c 	jmp	0x188c	; 0x188c <inverse>
    1624:	08 95       	ret

00001626 <__fixsfsi>:
    1626:	0e 94 1a 0b 	call	0x1634	; 0x1634 <__fixunssfsi>
    162a:	68 94       	set
    162c:	b1 11       	cpse	r27, r1
    162e:	0c 94 3b 0c 	jmp	0x1876	; 0x1876 <__fp_szero>
    1632:	08 95       	ret

00001634 <__fixunssfsi>:
    1634:	0e 94 20 0c 	call	0x1840	; 0x1840 <__fp_splitA>
    1638:	88 f0       	brcs	.+34     	; 0x165c <__fixunssfsi+0x28>
    163a:	9f 57       	subi	r25, 0x7F	; 127
    163c:	98 f0       	brcs	.+38     	; 0x1664 <__fixunssfsi+0x30>
    163e:	b9 2f       	mov	r27, r25
    1640:	99 27       	eor	r25, r25
    1642:	b7 51       	subi	r27, 0x17	; 23
    1644:	b0 f0       	brcs	.+44     	; 0x1672 <__fixunssfsi+0x3e>
    1646:	e1 f0       	breq	.+56     	; 0x1680 <__fixunssfsi+0x4c>
    1648:	66 0f       	add	r22, r22
    164a:	77 1f       	adc	r23, r23
    164c:	88 1f       	adc	r24, r24
    164e:	99 1f       	adc	r25, r25
    1650:	1a f0       	brmi	.+6      	; 0x1658 <__fixunssfsi+0x24>
    1652:	ba 95       	dec	r27
    1654:	c9 f7       	brne	.-14     	; 0x1648 <__fixunssfsi+0x14>
    1656:	14 c0       	rjmp	.+40     	; 0x1680 <__fixunssfsi+0x4c>
    1658:	b1 30       	cpi	r27, 0x01	; 1
    165a:	91 f0       	breq	.+36     	; 0x1680 <__fixunssfsi+0x4c>
    165c:	0e 94 3a 0c 	call	0x1874	; 0x1874 <__fp_zero>
    1660:	b1 e0       	ldi	r27, 0x01	; 1
    1662:	08 95       	ret
    1664:	0c 94 3a 0c 	jmp	0x1874	; 0x1874 <__fp_zero>
    1668:	67 2f       	mov	r22, r23
    166a:	78 2f       	mov	r23, r24
    166c:	88 27       	eor	r24, r24
    166e:	b8 5f       	subi	r27, 0xF8	; 248
    1670:	39 f0       	breq	.+14     	; 0x1680 <__fixunssfsi+0x4c>
    1672:	b9 3f       	cpi	r27, 0xF9	; 249
    1674:	cc f3       	brlt	.-14     	; 0x1668 <__fixunssfsi+0x34>
    1676:	86 95       	lsr	r24
    1678:	77 95       	ror	r23
    167a:	67 95       	ror	r22
    167c:	b3 95       	inc	r27
    167e:	d9 f7       	brne	.-10     	; 0x1676 <__fixunssfsi+0x42>
    1680:	3e f4       	brtc	.+14     	; 0x1690 <__fixunssfsi+0x5c>
    1682:	90 95       	com	r25
    1684:	80 95       	com	r24
    1686:	70 95       	com	r23
    1688:	61 95       	neg	r22
    168a:	7f 4f       	sbci	r23, 0xFF	; 255
    168c:	8f 4f       	sbci	r24, 0xFF	; 255
    168e:	9f 4f       	sbci	r25, 0xFF	; 255
    1690:	08 95       	ret

00001692 <__floatunsisf>:
    1692:	e8 94       	clt
    1694:	09 c0       	rjmp	.+18     	; 0x16a8 <__floatsisf+0x12>

00001696 <__floatsisf>:
    1696:	97 fb       	bst	r25, 7
    1698:	3e f4       	brtc	.+14     	; 0x16a8 <__floatsisf+0x12>
    169a:	90 95       	com	r25
    169c:	80 95       	com	r24
    169e:	70 95       	com	r23
    16a0:	61 95       	neg	r22
    16a2:	7f 4f       	sbci	r23, 0xFF	; 255
    16a4:	8f 4f       	sbci	r24, 0xFF	; 255
    16a6:	9f 4f       	sbci	r25, 0xFF	; 255
    16a8:	99 23       	and	r25, r25
    16aa:	a9 f0       	breq	.+42     	; 0x16d6 <__floatsisf+0x40>
    16ac:	f9 2f       	mov	r31, r25
    16ae:	96 e9       	ldi	r25, 0x96	; 150
    16b0:	bb 27       	eor	r27, r27
    16b2:	93 95       	inc	r25
    16b4:	f6 95       	lsr	r31
    16b6:	87 95       	ror	r24
    16b8:	77 95       	ror	r23
    16ba:	67 95       	ror	r22
    16bc:	b7 95       	ror	r27
    16be:	f1 11       	cpse	r31, r1
    16c0:	f8 cf       	rjmp	.-16     	; 0x16b2 <__floatsisf+0x1c>
    16c2:	fa f4       	brpl	.+62     	; 0x1702 <__floatsisf+0x6c>
    16c4:	bb 0f       	add	r27, r27
    16c6:	11 f4       	brne	.+4      	; 0x16cc <__floatsisf+0x36>
    16c8:	60 ff       	sbrs	r22, 0
    16ca:	1b c0       	rjmp	.+54     	; 0x1702 <__floatsisf+0x6c>
    16cc:	6f 5f       	subi	r22, 0xFF	; 255
    16ce:	7f 4f       	sbci	r23, 0xFF	; 255
    16d0:	8f 4f       	sbci	r24, 0xFF	; 255
    16d2:	9f 4f       	sbci	r25, 0xFF	; 255
    16d4:	16 c0       	rjmp	.+44     	; 0x1702 <__floatsisf+0x6c>
    16d6:	88 23       	and	r24, r24
    16d8:	11 f0       	breq	.+4      	; 0x16de <__floatsisf+0x48>
    16da:	96 e9       	ldi	r25, 0x96	; 150
    16dc:	11 c0       	rjmp	.+34     	; 0x1700 <__floatsisf+0x6a>
    16de:	77 23       	and	r23, r23
    16e0:	21 f0       	breq	.+8      	; 0x16ea <__floatsisf+0x54>
    16e2:	9e e8       	ldi	r25, 0x8E	; 142
    16e4:	87 2f       	mov	r24, r23
    16e6:	76 2f       	mov	r23, r22
    16e8:	05 c0       	rjmp	.+10     	; 0x16f4 <__floatsisf+0x5e>
    16ea:	66 23       	and	r22, r22
    16ec:	71 f0       	breq	.+28     	; 0x170a <__floatsisf+0x74>
    16ee:	96 e8       	ldi	r25, 0x86	; 134
    16f0:	86 2f       	mov	r24, r22
    16f2:	70 e0       	ldi	r23, 0x00	; 0
    16f4:	60 e0       	ldi	r22, 0x00	; 0
    16f6:	2a f0       	brmi	.+10     	; 0x1702 <__floatsisf+0x6c>
    16f8:	9a 95       	dec	r25
    16fa:	66 0f       	add	r22, r22
    16fc:	77 1f       	adc	r23, r23
    16fe:	88 1f       	adc	r24, r24
    1700:	da f7       	brpl	.-10     	; 0x16f8 <__floatsisf+0x62>
    1702:	88 0f       	add	r24, r24
    1704:	96 95       	lsr	r25
    1706:	87 95       	ror	r24
    1708:	97 f9       	bld	r25, 7
    170a:	08 95       	ret

0000170c <fmin>:
    170c:	99 0f       	add	r25, r25
    170e:	bb 0b       	sbc	r27, r27
    1710:	55 0f       	add	r21, r21
    1712:	aa 0b       	sbc	r26, r26
    1714:	e0 e8       	ldi	r30, 0x80	; 128
    1716:	fe ef       	ldi	r31, 0xFE	; 254
    1718:	16 16       	cp	r1, r22
    171a:	17 06       	cpc	r1, r23
    171c:	e8 07       	cpc	r30, r24
    171e:	f9 07       	cpc	r31, r25
    1720:	70 f0       	brcs	.+28     	; 0x173e <fmin+0x32>
    1722:	12 16       	cp	r1, r18
    1724:	13 06       	cpc	r1, r19
    1726:	e4 07       	cpc	r30, r20
    1728:	f5 07       	cpc	r31, r21
    172a:	60 f0       	brcs	.+24     	; 0x1744 <fmin+0x38>
    172c:	ba 17       	cp	r27, r26
    172e:	54 f0       	brlt	.+20     	; 0x1744 <fmin+0x38>
    1730:	31 f4       	brne	.+12     	; 0x173e <fmin+0x32>
    1732:	26 17       	cp	r18, r22
    1734:	37 07       	cpc	r19, r23
    1736:	48 07       	cpc	r20, r24
    1738:	59 07       	cpc	r21, r25
    173a:	a7 95       	ror	r26
    173c:	1b f4       	brvc	.+6      	; 0x1744 <fmin+0x38>
    173e:	b9 01       	movw	r22, r18
    1740:	ca 01       	movw	r24, r20
    1742:	ba 2f       	mov	r27, r26
    1744:	b6 95       	lsr	r27
    1746:	97 95       	ror	r25
    1748:	08 95       	ret

0000174a <__fp_cmp>:
    174a:	99 0f       	add	r25, r25
    174c:	00 08       	sbc	r0, r0
    174e:	55 0f       	add	r21, r21
    1750:	aa 0b       	sbc	r26, r26
    1752:	e0 e8       	ldi	r30, 0x80	; 128
    1754:	fe ef       	ldi	r31, 0xFE	; 254
    1756:	16 16       	cp	r1, r22
    1758:	17 06       	cpc	r1, r23
    175a:	e8 07       	cpc	r30, r24
    175c:	f9 07       	cpc	r31, r25
    175e:	c0 f0       	brcs	.+48     	; 0x1790 <__fp_cmp+0x46>
    1760:	12 16       	cp	r1, r18
    1762:	13 06       	cpc	r1, r19
    1764:	e4 07       	cpc	r30, r20
    1766:	f5 07       	cpc	r31, r21
    1768:	98 f0       	brcs	.+38     	; 0x1790 <__fp_cmp+0x46>
    176a:	62 1b       	sub	r22, r18
    176c:	73 0b       	sbc	r23, r19
    176e:	84 0b       	sbc	r24, r20
    1770:	95 0b       	sbc	r25, r21
    1772:	39 f4       	brne	.+14     	; 0x1782 <__fp_cmp+0x38>
    1774:	0a 26       	eor	r0, r26
    1776:	61 f0       	breq	.+24     	; 0x1790 <__fp_cmp+0x46>
    1778:	23 2b       	or	r18, r19
    177a:	24 2b       	or	r18, r20
    177c:	25 2b       	or	r18, r21
    177e:	21 f4       	brne	.+8      	; 0x1788 <__fp_cmp+0x3e>
    1780:	08 95       	ret
    1782:	0a 26       	eor	r0, r26
    1784:	09 f4       	brne	.+2      	; 0x1788 <__fp_cmp+0x3e>
    1786:	a1 40       	sbci	r26, 0x01	; 1
    1788:	a6 95       	lsr	r26
    178a:	8f ef       	ldi	r24, 0xFF	; 255
    178c:	81 1d       	adc	r24, r1
    178e:	81 1d       	adc	r24, r1
    1790:	08 95       	ret

00001792 <__fp_inf>:
    1792:	97 f9       	bld	r25, 7
    1794:	9f 67       	ori	r25, 0x7F	; 127
    1796:	80 e8       	ldi	r24, 0x80	; 128
    1798:	70 e0       	ldi	r23, 0x00	; 0
    179a:	60 e0       	ldi	r22, 0x00	; 0
    179c:	08 95       	ret

0000179e <__fp_nan>:
    179e:	9f ef       	ldi	r25, 0xFF	; 255
    17a0:	80 ec       	ldi	r24, 0xC0	; 192
    17a2:	08 95       	ret

000017a4 <__fp_powser>:
    17a4:	df 93       	push	r29
    17a6:	cf 93       	push	r28
    17a8:	1f 93       	push	r17
    17aa:	0f 93       	push	r16
    17ac:	ff 92       	push	r15
    17ae:	ef 92       	push	r14
    17b0:	df 92       	push	r13
    17b2:	7b 01       	movw	r14, r22
    17b4:	8c 01       	movw	r16, r24
    17b6:	68 94       	set
    17b8:	06 c0       	rjmp	.+12     	; 0x17c6 <__fp_powser+0x22>
    17ba:	da 2e       	mov	r13, r26
    17bc:	ef 01       	movw	r28, r30
    17be:	0e 94 cf 0c 	call	0x199e	; 0x199e <__mulsf3x>
    17c2:	fe 01       	movw	r30, r28
    17c4:	e8 94       	clt
    17c6:	a5 91       	lpm	r26, Z+
    17c8:	25 91       	lpm	r18, Z+
    17ca:	35 91       	lpm	r19, Z+
    17cc:	45 91       	lpm	r20, Z+
    17ce:	55 91       	lpm	r21, Z+
    17d0:	a6 f3       	brts	.-24     	; 0x17ba <__fp_powser+0x16>
    17d2:	ef 01       	movw	r28, r30
    17d4:	0e 94 0d 0a 	call	0x141a	; 0x141a <__addsf3x>
    17d8:	fe 01       	movw	r30, r28
    17da:	97 01       	movw	r18, r14
    17dc:	a8 01       	movw	r20, r16
    17de:	da 94       	dec	r13
    17e0:	69 f7       	brne	.-38     	; 0x17bc <__fp_powser+0x18>
    17e2:	df 90       	pop	r13
    17e4:	ef 90       	pop	r14
    17e6:	ff 90       	pop	r15
    17e8:	0f 91       	pop	r16
    17ea:	1f 91       	pop	r17
    17ec:	cf 91       	pop	r28
    17ee:	df 91       	pop	r29
    17f0:	08 95       	ret

000017f2 <__fp_pscA>:
    17f2:	00 24       	eor	r0, r0
    17f4:	0a 94       	dec	r0
    17f6:	16 16       	cp	r1, r22
    17f8:	17 06       	cpc	r1, r23
    17fa:	18 06       	cpc	r1, r24
    17fc:	09 06       	cpc	r0, r25
    17fe:	08 95       	ret

00001800 <__fp_pscB>:
    1800:	00 24       	eor	r0, r0
    1802:	0a 94       	dec	r0
    1804:	12 16       	cp	r1, r18
    1806:	13 06       	cpc	r1, r19
    1808:	14 06       	cpc	r1, r20
    180a:	05 06       	cpc	r0, r21
    180c:	08 95       	ret

0000180e <__fp_round>:
    180e:	09 2e       	mov	r0, r25
    1810:	03 94       	inc	r0
    1812:	00 0c       	add	r0, r0
    1814:	11 f4       	brne	.+4      	; 0x181a <__fp_round+0xc>
    1816:	88 23       	and	r24, r24
    1818:	52 f0       	brmi	.+20     	; 0x182e <__fp_round+0x20>
    181a:	bb 0f       	add	r27, r27
    181c:	40 f4       	brcc	.+16     	; 0x182e <__fp_round+0x20>
    181e:	bf 2b       	or	r27, r31
    1820:	11 f4       	brne	.+4      	; 0x1826 <__fp_round+0x18>
    1822:	60 ff       	sbrs	r22, 0
    1824:	04 c0       	rjmp	.+8      	; 0x182e <__fp_round+0x20>
    1826:	6f 5f       	subi	r22, 0xFF	; 255
    1828:	7f 4f       	sbci	r23, 0xFF	; 255
    182a:	8f 4f       	sbci	r24, 0xFF	; 255
    182c:	9f 4f       	sbci	r25, 0xFF	; 255
    182e:	08 95       	ret

00001830 <__fp_split3>:
    1830:	57 fd       	sbrc	r21, 7
    1832:	90 58       	subi	r25, 0x80	; 128
    1834:	44 0f       	add	r20, r20
    1836:	55 1f       	adc	r21, r21
    1838:	59 f0       	breq	.+22     	; 0x1850 <__fp_splitA+0x10>
    183a:	5f 3f       	cpi	r21, 0xFF	; 255
    183c:	71 f0       	breq	.+28     	; 0x185a <__fp_splitA+0x1a>
    183e:	47 95       	ror	r20

00001840 <__fp_splitA>:
    1840:	88 0f       	add	r24, r24
    1842:	97 fb       	bst	r25, 7
    1844:	99 1f       	adc	r25, r25
    1846:	61 f0       	breq	.+24     	; 0x1860 <__fp_splitA+0x20>
    1848:	9f 3f       	cpi	r25, 0xFF	; 255
    184a:	79 f0       	breq	.+30     	; 0x186a <__fp_splitA+0x2a>
    184c:	87 95       	ror	r24
    184e:	08 95       	ret
    1850:	12 16       	cp	r1, r18
    1852:	13 06       	cpc	r1, r19
    1854:	14 06       	cpc	r1, r20
    1856:	55 1f       	adc	r21, r21
    1858:	f2 cf       	rjmp	.-28     	; 0x183e <__fp_split3+0xe>
    185a:	46 95       	lsr	r20
    185c:	f1 df       	rcall	.-30     	; 0x1840 <__fp_splitA>
    185e:	08 c0       	rjmp	.+16     	; 0x1870 <__fp_splitA+0x30>
    1860:	16 16       	cp	r1, r22
    1862:	17 06       	cpc	r1, r23
    1864:	18 06       	cpc	r1, r24
    1866:	99 1f       	adc	r25, r25
    1868:	f1 cf       	rjmp	.-30     	; 0x184c <__fp_splitA+0xc>
    186a:	86 95       	lsr	r24
    186c:	71 05       	cpc	r23, r1
    186e:	61 05       	cpc	r22, r1
    1870:	08 94       	sec
    1872:	08 95       	ret

00001874 <__fp_zero>:
    1874:	e8 94       	clt

00001876 <__fp_szero>:
    1876:	bb 27       	eor	r27, r27
    1878:	66 27       	eor	r22, r22
    187a:	77 27       	eor	r23, r23
    187c:	cb 01       	movw	r24, r22
    187e:	97 f9       	bld	r25, 7
    1880:	08 95       	ret

00001882 <__gesf2>:
    1882:	0e 94 a5 0b 	call	0x174a	; 0x174a <__fp_cmp>
    1886:	08 f4       	brcc	.+2      	; 0x188a <__gesf2+0x8>
    1888:	8f ef       	ldi	r24, 0xFF	; 255
    188a:	08 95       	ret

0000188c <inverse>:
    188c:	9b 01       	movw	r18, r22
    188e:	ac 01       	movw	r20, r24
    1890:	60 e0       	ldi	r22, 0x00	; 0
    1892:	70 e0       	ldi	r23, 0x00	; 0
    1894:	80 e8       	ldi	r24, 0x80	; 128
    1896:	9f e3       	ldi	r25, 0x3F	; 63
    1898:	0c 94 67 0a 	jmp	0x14ce	; 0x14ce <__divsf3>
    189c:	0c 94 c9 0b 	jmp	0x1792	; 0x1792 <__fp_inf>
    18a0:	0c 94 31 0d 	jmp	0x1a62	; 0x1a62 <__fp_mpack>

000018a4 <ldexp>:
    18a4:	0e 94 20 0c 	call	0x1840	; 0x1840 <__fp_splitA>
    18a8:	d8 f3       	brcs	.-10     	; 0x18a0 <inverse+0x14>
    18aa:	99 23       	and	r25, r25
    18ac:	c9 f3       	breq	.-14     	; 0x18a0 <inverse+0x14>
    18ae:	94 0f       	add	r25, r20
    18b0:	51 1d       	adc	r21, r1
    18b2:	a3 f3       	brvs	.-24     	; 0x189c <inverse+0x10>
    18b4:	91 50       	subi	r25, 0x01	; 1
    18b6:	50 40       	sbci	r21, 0x00	; 0
    18b8:	94 f0       	brlt	.+36     	; 0x18de <ldexp+0x3a>
    18ba:	59 f0       	breq	.+22     	; 0x18d2 <ldexp+0x2e>
    18bc:	88 23       	and	r24, r24
    18be:	32 f0       	brmi	.+12     	; 0x18cc <ldexp+0x28>
    18c0:	66 0f       	add	r22, r22
    18c2:	77 1f       	adc	r23, r23
    18c4:	88 1f       	adc	r24, r24
    18c6:	91 50       	subi	r25, 0x01	; 1
    18c8:	50 40       	sbci	r21, 0x00	; 0
    18ca:	c1 f7       	brne	.-16     	; 0x18bc <ldexp+0x18>
    18cc:	9e 3f       	cpi	r25, 0xFE	; 254
    18ce:	51 05       	cpc	r21, r1
    18d0:	2c f7       	brge	.-54     	; 0x189c <inverse+0x10>
    18d2:	88 0f       	add	r24, r24
    18d4:	91 1d       	adc	r25, r1
    18d6:	96 95       	lsr	r25
    18d8:	87 95       	ror	r24
    18da:	97 f9       	bld	r25, 7
    18dc:	08 95       	ret
    18de:	5f 3f       	cpi	r21, 0xFF	; 255
    18e0:	ac f0       	brlt	.+42     	; 0x190c <ldexp+0x68>
    18e2:	98 3e       	cpi	r25, 0xE8	; 232
    18e4:	9c f0       	brlt	.+38     	; 0x190c <ldexp+0x68>
    18e6:	bb 27       	eor	r27, r27
    18e8:	86 95       	lsr	r24
    18ea:	77 95       	ror	r23
    18ec:	67 95       	ror	r22
    18ee:	b7 95       	ror	r27
    18f0:	08 f4       	brcc	.+2      	; 0x18f4 <ldexp+0x50>
    18f2:	b1 60       	ori	r27, 0x01	; 1
    18f4:	93 95       	inc	r25
    18f6:	c1 f7       	brne	.-16     	; 0x18e8 <ldexp+0x44>
    18f8:	bb 0f       	add	r27, r27
    18fa:	58 f7       	brcc	.-42     	; 0x18d2 <ldexp+0x2e>
    18fc:	11 f4       	brne	.+4      	; 0x1902 <ldexp+0x5e>
    18fe:	60 ff       	sbrs	r22, 0
    1900:	e8 cf       	rjmp	.-48     	; 0x18d2 <ldexp+0x2e>
    1902:	6f 5f       	subi	r22, 0xFF	; 255
    1904:	7f 4f       	sbci	r23, 0xFF	; 255
    1906:	8f 4f       	sbci	r24, 0xFF	; 255
    1908:	9f 4f       	sbci	r25, 0xFF	; 255
    190a:	e3 cf       	rjmp	.-58     	; 0x18d2 <ldexp+0x2e>
    190c:	0c 94 3b 0c 	jmp	0x1876	; 0x1876 <__fp_szero>

00001910 <modf>:
    1910:	fa 01       	movw	r30, r20
    1912:	dc 01       	movw	r26, r24
    1914:	aa 0f       	add	r26, r26
    1916:	bb 1f       	adc	r27, r27
    1918:	9b 01       	movw	r18, r22
    191a:	ac 01       	movw	r20, r24
    191c:	bf 57       	subi	r27, 0x7F	; 127
    191e:	28 f4       	brcc	.+10     	; 0x192a <modf+0x1a>
    1920:	22 27       	eor	r18, r18
    1922:	33 27       	eor	r19, r19
    1924:	44 27       	eor	r20, r20
    1926:	50 78       	andi	r21, 0x80	; 128
    1928:	20 c0       	rjmp	.+64     	; 0x196a <modf+0x5a>
    192a:	b7 51       	subi	r27, 0x17	; 23
    192c:	90 f4       	brcc	.+36     	; 0x1952 <modf+0x42>
    192e:	ab 2f       	mov	r26, r27
    1930:	00 24       	eor	r0, r0
    1932:	46 95       	lsr	r20
    1934:	37 95       	ror	r19
    1936:	27 95       	ror	r18
    1938:	01 1c       	adc	r0, r1
    193a:	a3 95       	inc	r26
    193c:	d2 f3       	brmi	.-12     	; 0x1932 <modf+0x22>
    193e:	00 20       	and	r0, r0
    1940:	71 f0       	breq	.+28     	; 0x195e <modf+0x4e>
    1942:	22 0f       	add	r18, r18
    1944:	33 1f       	adc	r19, r19
    1946:	44 1f       	adc	r20, r20
    1948:	b3 95       	inc	r27
    194a:	da f3       	brmi	.-10     	; 0x1942 <modf+0x32>
    194c:	0e d0       	rcall	.+28     	; 0x196a <modf+0x5a>
    194e:	0c 94 f5 09 	jmp	0x13ea	; 0x13ea <__subsf3>
    1952:	61 30       	cpi	r22, 0x01	; 1
    1954:	71 05       	cpc	r23, r1
    1956:	a0 e8       	ldi	r26, 0x80	; 128
    1958:	8a 07       	cpc	r24, r26
    195a:	b9 46       	sbci	r27, 0x69	; 105
    195c:	30 f4       	brcc	.+12     	; 0x196a <modf+0x5a>
    195e:	9b 01       	movw	r18, r22
    1960:	ac 01       	movw	r20, r24
    1962:	66 27       	eor	r22, r22
    1964:	77 27       	eor	r23, r23
    1966:	88 27       	eor	r24, r24
    1968:	90 78       	andi	r25, 0x80	; 128
    196a:	30 96       	adiw	r30, 0x00	; 0
    196c:	21 f0       	breq	.+8      	; 0x1976 <modf+0x66>
    196e:	20 83       	st	Z, r18
    1970:	31 83       	std	Z+1, r19	; 0x01
    1972:	42 83       	std	Z+2, r20	; 0x02
    1974:	53 83       	std	Z+3, r21	; 0x03
    1976:	08 95       	ret

00001978 <__mulsf3>:
    1978:	0e 94 cf 0c 	call	0x199e	; 0x199e <__mulsf3x>
    197c:	0c 94 07 0c 	jmp	0x180e	; 0x180e <__fp_round>
    1980:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <__fp_pscA>
    1984:	38 f0       	brcs	.+14     	; 0x1994 <__mulsf3+0x1c>
    1986:	0e 94 00 0c 	call	0x1800	; 0x1800 <__fp_pscB>
    198a:	20 f0       	brcs	.+8      	; 0x1994 <__mulsf3+0x1c>
    198c:	95 23       	and	r25, r21
    198e:	11 f0       	breq	.+4      	; 0x1994 <__mulsf3+0x1c>
    1990:	0c 94 c9 0b 	jmp	0x1792	; 0x1792 <__fp_inf>
    1994:	0c 94 cf 0b 	jmp	0x179e	; 0x179e <__fp_nan>
    1998:	11 24       	eor	r1, r1
    199a:	0c 94 3b 0c 	jmp	0x1876	; 0x1876 <__fp_szero>

0000199e <__mulsf3x>:
    199e:	0e 94 18 0c 	call	0x1830	; 0x1830 <__fp_split3>
    19a2:	70 f3       	brcs	.-36     	; 0x1980 <__mulsf3+0x8>

000019a4 <__mulsf3_pse>:
    19a4:	95 9f       	mul	r25, r21
    19a6:	c1 f3       	breq	.-16     	; 0x1998 <__mulsf3+0x20>
    19a8:	95 0f       	add	r25, r21
    19aa:	50 e0       	ldi	r21, 0x00	; 0
    19ac:	55 1f       	adc	r21, r21
    19ae:	62 9f       	mul	r22, r18
    19b0:	f0 01       	movw	r30, r0
    19b2:	72 9f       	mul	r23, r18
    19b4:	bb 27       	eor	r27, r27
    19b6:	f0 0d       	add	r31, r0
    19b8:	b1 1d       	adc	r27, r1
    19ba:	63 9f       	mul	r22, r19
    19bc:	aa 27       	eor	r26, r26
    19be:	f0 0d       	add	r31, r0
    19c0:	b1 1d       	adc	r27, r1
    19c2:	aa 1f       	adc	r26, r26
    19c4:	64 9f       	mul	r22, r20
    19c6:	66 27       	eor	r22, r22
    19c8:	b0 0d       	add	r27, r0
    19ca:	a1 1d       	adc	r26, r1
    19cc:	66 1f       	adc	r22, r22
    19ce:	82 9f       	mul	r24, r18
    19d0:	22 27       	eor	r18, r18
    19d2:	b0 0d       	add	r27, r0
    19d4:	a1 1d       	adc	r26, r1
    19d6:	62 1f       	adc	r22, r18
    19d8:	73 9f       	mul	r23, r19
    19da:	b0 0d       	add	r27, r0
    19dc:	a1 1d       	adc	r26, r1
    19de:	62 1f       	adc	r22, r18
    19e0:	83 9f       	mul	r24, r19
    19e2:	a0 0d       	add	r26, r0
    19e4:	61 1d       	adc	r22, r1
    19e6:	22 1f       	adc	r18, r18
    19e8:	74 9f       	mul	r23, r20
    19ea:	33 27       	eor	r19, r19
    19ec:	a0 0d       	add	r26, r0
    19ee:	61 1d       	adc	r22, r1
    19f0:	23 1f       	adc	r18, r19
    19f2:	84 9f       	mul	r24, r20
    19f4:	60 0d       	add	r22, r0
    19f6:	21 1d       	adc	r18, r1
    19f8:	82 2f       	mov	r24, r18
    19fa:	76 2f       	mov	r23, r22
    19fc:	6a 2f       	mov	r22, r26
    19fe:	11 24       	eor	r1, r1
    1a00:	9f 57       	subi	r25, 0x7F	; 127
    1a02:	50 40       	sbci	r21, 0x00	; 0
    1a04:	9a f0       	brmi	.+38     	; 0x1a2c <__mulsf3_pse+0x88>
    1a06:	f1 f0       	breq	.+60     	; 0x1a44 <__mulsf3_pse+0xa0>
    1a08:	88 23       	and	r24, r24
    1a0a:	4a f0       	brmi	.+18     	; 0x1a1e <__mulsf3_pse+0x7a>
    1a0c:	ee 0f       	add	r30, r30
    1a0e:	ff 1f       	adc	r31, r31
    1a10:	bb 1f       	adc	r27, r27
    1a12:	66 1f       	adc	r22, r22
    1a14:	77 1f       	adc	r23, r23
    1a16:	88 1f       	adc	r24, r24
    1a18:	91 50       	subi	r25, 0x01	; 1
    1a1a:	50 40       	sbci	r21, 0x00	; 0
    1a1c:	a9 f7       	brne	.-22     	; 0x1a08 <__mulsf3_pse+0x64>
    1a1e:	9e 3f       	cpi	r25, 0xFE	; 254
    1a20:	51 05       	cpc	r21, r1
    1a22:	80 f0       	brcs	.+32     	; 0x1a44 <__mulsf3_pse+0xa0>
    1a24:	0c 94 c9 0b 	jmp	0x1792	; 0x1792 <__fp_inf>
    1a28:	0c 94 3b 0c 	jmp	0x1876	; 0x1876 <__fp_szero>
    1a2c:	5f 3f       	cpi	r21, 0xFF	; 255
    1a2e:	e4 f3       	brlt	.-8      	; 0x1a28 <__mulsf3_pse+0x84>
    1a30:	98 3e       	cpi	r25, 0xE8	; 232
    1a32:	d4 f3       	brlt	.-12     	; 0x1a28 <__mulsf3_pse+0x84>
    1a34:	86 95       	lsr	r24
    1a36:	77 95       	ror	r23
    1a38:	67 95       	ror	r22
    1a3a:	b7 95       	ror	r27
    1a3c:	f7 95       	ror	r31
    1a3e:	e7 95       	ror	r30
    1a40:	9f 5f       	subi	r25, 0xFF	; 255
    1a42:	c1 f7       	brne	.-16     	; 0x1a34 <__mulsf3_pse+0x90>
    1a44:	fe 2b       	or	r31, r30
    1a46:	88 0f       	add	r24, r24
    1a48:	91 1d       	adc	r25, r1
    1a4a:	96 95       	lsr	r25
    1a4c:	87 95       	ror	r24
    1a4e:	97 f9       	bld	r25, 7
    1a50:	08 95       	ret

00001a52 <sin>:
    1a52:	9f 93       	push	r25
    1a54:	0e 94 41 0d 	call	0x1a82	; 0x1a82 <__fp_rempio2>
    1a58:	0f 90       	pop	r0
    1a5a:	07 fc       	sbrc	r0, 7
    1a5c:	ee 5f       	subi	r30, 0xFE	; 254
    1a5e:	0c 94 6a 0d 	jmp	0x1ad4	; 0x1ad4 <__fp_sinus>

00001a62 <__fp_mpack>:
    1a62:	9f 3f       	cpi	r25, 0xFF	; 255
    1a64:	31 f0       	breq	.+12     	; 0x1a72 <__fp_mpack_finite+0xc>

00001a66 <__fp_mpack_finite>:
    1a66:	91 50       	subi	r25, 0x01	; 1
    1a68:	20 f4       	brcc	.+8      	; 0x1a72 <__fp_mpack_finite+0xc>
    1a6a:	87 95       	ror	r24
    1a6c:	77 95       	ror	r23
    1a6e:	67 95       	ror	r22
    1a70:	b7 95       	ror	r27
    1a72:	88 0f       	add	r24, r24
    1a74:	91 1d       	adc	r25, r1
    1a76:	96 95       	lsr	r25
    1a78:	87 95       	ror	r24
    1a7a:	97 f9       	bld	r25, 7
    1a7c:	08 95       	ret
    1a7e:	0c 94 cf 0b 	jmp	0x179e	; 0x179e <__fp_nan>

00001a82 <__fp_rempio2>:
    1a82:	0e 94 20 0c 	call	0x1840	; 0x1840 <__fp_splitA>
    1a86:	d8 f3       	brcs	.-10     	; 0x1a7e <__fp_mpack_finite+0x18>
    1a88:	e8 94       	clt
    1a8a:	e0 e0       	ldi	r30, 0x00	; 0
    1a8c:	bb 27       	eor	r27, r27
    1a8e:	9f 57       	subi	r25, 0x7F	; 127
    1a90:	f0 f0       	brcs	.+60     	; 0x1ace <__fp_rempio2+0x4c>
    1a92:	2a ed       	ldi	r18, 0xDA	; 218
    1a94:	3f e0       	ldi	r19, 0x0F	; 15
    1a96:	49 ec       	ldi	r20, 0xC9	; 201
    1a98:	06 c0       	rjmp	.+12     	; 0x1aa6 <__fp_rempio2+0x24>
    1a9a:	ee 0f       	add	r30, r30
    1a9c:	bb 0f       	add	r27, r27
    1a9e:	66 1f       	adc	r22, r22
    1aa0:	77 1f       	adc	r23, r23
    1aa2:	88 1f       	adc	r24, r24
    1aa4:	28 f0       	brcs	.+10     	; 0x1ab0 <__fp_rempio2+0x2e>
    1aa6:	b2 3a       	cpi	r27, 0xA2	; 162
    1aa8:	62 07       	cpc	r22, r18
    1aaa:	73 07       	cpc	r23, r19
    1aac:	84 07       	cpc	r24, r20
    1aae:	28 f0       	brcs	.+10     	; 0x1aba <__fp_rempio2+0x38>
    1ab0:	b2 5a       	subi	r27, 0xA2	; 162
    1ab2:	62 0b       	sbc	r22, r18
    1ab4:	73 0b       	sbc	r23, r19
    1ab6:	84 0b       	sbc	r24, r20
    1ab8:	e3 95       	inc	r30
    1aba:	9a 95       	dec	r25
    1abc:	72 f7       	brpl	.-36     	; 0x1a9a <__fp_rempio2+0x18>
    1abe:	80 38       	cpi	r24, 0x80	; 128
    1ac0:	30 f4       	brcc	.+12     	; 0x1ace <__fp_rempio2+0x4c>
    1ac2:	9a 95       	dec	r25
    1ac4:	bb 0f       	add	r27, r27
    1ac6:	66 1f       	adc	r22, r22
    1ac8:	77 1f       	adc	r23, r23
    1aca:	88 1f       	adc	r24, r24
    1acc:	d2 f7       	brpl	.-12     	; 0x1ac2 <__fp_rempio2+0x40>
    1ace:	90 48       	sbci	r25, 0x80	; 128
    1ad0:	0c 94 33 0d 	jmp	0x1a66	; 0x1a66 <__fp_mpack_finite>

00001ad4 <__fp_sinus>:
    1ad4:	ef 93       	push	r30
    1ad6:	e0 ff       	sbrs	r30, 0
    1ad8:	07 c0       	rjmp	.+14     	; 0x1ae8 <__fp_sinus+0x14>
    1ada:	a2 ea       	ldi	r26, 0xA2	; 162
    1adc:	2a ed       	ldi	r18, 0xDA	; 218
    1ade:	3f e0       	ldi	r19, 0x0F	; 15
    1ae0:	49 ec       	ldi	r20, 0xC9	; 201
    1ae2:	5f eb       	ldi	r21, 0xBF	; 191
    1ae4:	0e 94 0d 0a 	call	0x141a	; 0x141a <__addsf3x>
    1ae8:	0e 94 07 0c 	call	0x180e	; 0x180e <__fp_round>
    1aec:	0f 90       	pop	r0
    1aee:	03 94       	inc	r0
    1af0:	01 fc       	sbrc	r0, 1
    1af2:	90 58       	subi	r25, 0x80	; 128
    1af4:	e4 ea       	ldi	r30, 0xA4	; 164
    1af6:	f0 e0       	ldi	r31, 0x00	; 0
    1af8:	0c 94 7e 0d 	jmp	0x1afc	; 0x1afc <__fp_powsodd>

00001afc <__fp_powsodd>:
    1afc:	9f 93       	push	r25
    1afe:	8f 93       	push	r24
    1b00:	7f 93       	push	r23
    1b02:	6f 93       	push	r22
    1b04:	ff 93       	push	r31
    1b06:	ef 93       	push	r30
    1b08:	9b 01       	movw	r18, r22
    1b0a:	ac 01       	movw	r20, r24
    1b0c:	0e 94 bc 0c 	call	0x1978	; 0x1978 <__mulsf3>
    1b10:	ef 91       	pop	r30
    1b12:	ff 91       	pop	r31
    1b14:	0e 94 d2 0b 	call	0x17a4	; 0x17a4 <__fp_powser>
    1b18:	2f 91       	pop	r18
    1b1a:	3f 91       	pop	r19
    1b1c:	4f 91       	pop	r20
    1b1e:	5f 91       	pop	r21
    1b20:	0c 94 bc 0c 	jmp	0x1978	; 0x1978 <__mulsf3>

00001b24 <__udivmodsi4>:
    1b24:	a1 e2       	ldi	r26, 0x21	; 33
    1b26:	1a 2e       	mov	r1, r26
    1b28:	aa 1b       	sub	r26, r26
    1b2a:	bb 1b       	sub	r27, r27
    1b2c:	fd 01       	movw	r30, r26
    1b2e:	0d c0       	rjmp	.+26     	; 0x1b4a <__udivmodsi4_ep>

00001b30 <__udivmodsi4_loop>:
    1b30:	aa 1f       	adc	r26, r26
    1b32:	bb 1f       	adc	r27, r27
    1b34:	ee 1f       	adc	r30, r30
    1b36:	ff 1f       	adc	r31, r31
    1b38:	a2 17       	cp	r26, r18
    1b3a:	b3 07       	cpc	r27, r19
    1b3c:	e4 07       	cpc	r30, r20
    1b3e:	f5 07       	cpc	r31, r21
    1b40:	20 f0       	brcs	.+8      	; 0x1b4a <__udivmodsi4_ep>
    1b42:	a2 1b       	sub	r26, r18
    1b44:	b3 0b       	sbc	r27, r19
    1b46:	e4 0b       	sbc	r30, r20
    1b48:	f5 0b       	sbc	r31, r21

00001b4a <__udivmodsi4_ep>:
    1b4a:	66 1f       	adc	r22, r22
    1b4c:	77 1f       	adc	r23, r23
    1b4e:	88 1f       	adc	r24, r24
    1b50:	99 1f       	adc	r25, r25
    1b52:	1a 94       	dec	r1
    1b54:	69 f7       	brne	.-38     	; 0x1b30 <__udivmodsi4_loop>
    1b56:	60 95       	com	r22
    1b58:	70 95       	com	r23
    1b5a:	80 95       	com	r24
    1b5c:	90 95       	com	r25
    1b5e:	9b 01       	movw	r18, r22
    1b60:	ac 01       	movw	r20, r24
    1b62:	bd 01       	movw	r22, r26
    1b64:	cf 01       	movw	r24, r30
    1b66:	08 95       	ret

00001b68 <_exit>:
    1b68:	f8 94       	cli

00001b6a <__stop_program>:
    1b6a:	ff cf       	rjmp	.-2      	; 0x1b6a <__stop_program>
