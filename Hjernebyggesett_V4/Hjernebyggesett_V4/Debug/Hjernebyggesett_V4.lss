
Hjernebyggesett_V4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000016  00803800  00002847  000028fb  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002754  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       000000f3  0000a754  00002754  00002808  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .bss          0000005a  00803816  00803816  00002911  2**0
                  ALLOC
  4 .comment      0000005c  00000000  00000000  00002911  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002970  2**2
                  CONTENTS, READONLY
  6 .debug_aranges 00000550  00000000  00000000  000029b0  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00008f92  00000000  00000000  00002f00  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000038ab  00000000  00000000  0000be92  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00002c9d  00000000  00000000  0000f73d  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000a20  00000000  00000000  000123dc  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000036db  00000000  00000000  00012dfc  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00001bae  00000000  00000000  000164d7  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000400  00000000  00000000  00018085  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 de 00 	jmp	0x1bc	; 0x1bc <__ctors_end>
       4:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
       8:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
       c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      10:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      14:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      18:	0c 94 31 06 	jmp	0xc62	; 0xc62 <__vector_6>
      1c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      20:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      24:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      28:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      2c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      30:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      34:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      38:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      3c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      40:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      44:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      48:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      4c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      50:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      54:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      58:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      5c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      60:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      64:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      68:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      6c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      70:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      74:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      78:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      7c:	07 63       	ori	r16, 0x37	; 55
      7e:	42 36       	cpi	r20, 0x62	; 98
      80:	b7 9b       	sbis	0x16, 7	; 22
      82:	d8 a7       	std	Y+40, r29	; 0x28
      84:	1a 39       	cpi	r17, 0x9A	; 154
      86:	68 56       	subi	r22, 0x68	; 104
      88:	18 ae       	std	Y+56, r1	; 0x38
      8a:	ba ab       	std	Y+50, r27	; 0x32
      8c:	55 8c       	ldd	r5, Z+29	; 0x1d
      8e:	1d 3c       	cpi	r17, 0xCD	; 205
      90:	b7 cc       	rjmp	.-1682   	; 0xfffffa00 <__eeprom_end+0xff7efa00>
      92:	57 63       	ori	r21, 0x37	; 55
      94:	bd 6d       	ori	r27, 0xDD	; 221
      96:	ed fd       	.word	0xfded	; ????
      98:	75 3e       	cpi	r23, 0xE5	; 229
      9a:	f6 17       	cp	r31, r22
      9c:	72 31       	cpi	r23, 0x12	; 18
      9e:	bf 00       	.word	0x00bf	; ????
      a0:	00 00       	nop
      a2:	80 3f       	cpi	r24, 0xF0	; 240
      a4:	05 a8       	ldd	r0, Z+53	; 0x35
      a6:	4c cd       	rjmp	.-1384   	; 0xfffffb40 <__eeprom_end+0xff7efb40>
      a8:	b2 d4       	rcall	.+2404   	; 0xa0e <tinyDebugger_send_double+0x68>
      aa:	4e b9       	out	0x0e, r20	; 14
      ac:	38 36       	cpi	r19, 0x68	; 104
      ae:	a9 02       	muls	r26, r25
      b0:	0c 50       	subi	r16, 0x0C	; 12
      b2:	b9 91       	ld	r27, Y+
      b4:	86 88       	ldd	r8, Z+22	; 0x16
      b6:	08 3c       	cpi	r16, 0xC8	; 200
      b8:	a6 aa       	std	Z+54, r10	; 0x36
      ba:	aa 2a       	or	r10, r26
      bc:	be 00       	.word	0x00be	; ????
      be:	00 00       	nop
      c0:	80 3f       	cpi	r24, 0xF0	; 240

000000c2 <__trampolines_end>:
      c2:	00 40       	sbci	r16, 0x00	; 0
      c4:	7a 10       	cpse	r7, r10
      c6:	f3 5a       	subi	r31, 0xA3	; 163
      c8:	00 a0       	ldd	r0, Z+32	; 0x20
      ca:	72 4e       	sbci	r23, 0xE2	; 226
      cc:	18 09       	sbc	r17, r8
      ce:	00 10       	cpse	r0, r0
      d0:	a5 d4       	rcall	.+2378   	; 0xa1c <tinyDendrite_read_signals>
      d2:	e8 00       	.word	0x00e8	; ????
      d4:	00 e8       	ldi	r16, 0x80	; 128
      d6:	76 48       	sbci	r23, 0x86	; 134
      d8:	17 00       	.word	0x0017	; ????
      da:	00 e4       	ldi	r16, 0x40	; 64
      dc:	0b 54       	subi	r16, 0x4B	; 75
      de:	02 00       	.word	0x0002	; ????
      e0:	00 ca       	rjmp	.-3072   	; 0xfffff4e2 <__eeprom_end+0xff7ef4e2>
      e2:	9a 3b       	cpi	r25, 0xBA	; 186
      e4:	00 00       	nop
      e6:	00 e1       	ldi	r16, 0x10	; 16
      e8:	f5 05       	cpc	r31, r5
      ea:	00 00       	nop
      ec:	80 96       	adiw	r24, 0x20	; 32
      ee:	98 00       	.word	0x0098	; ????
      f0:	00 00       	nop
      f2:	40 42       	sbci	r20, 0x20	; 32
      f4:	0f 00       	.word	0x000f	; ????
      f6:	00 00       	nop
      f8:	a0 86       	std	Z+8, r10	; 0x08
      fa:	01 00       	.word	0x0001	; ????
      fc:	00 00       	nop
      fe:	10 27       	eor	r17, r16
     100:	00 00       	nop
     102:	00 00       	nop
     104:	e8 03       	fmulsu	r22, r16
     106:	00 00       	nop
     108:	00 00       	nop
     10a:	64 00       	.word	0x0064	; ????
     10c:	00 00       	nop
     10e:	00 00       	nop
     110:	0a 00       	.word	0x000a	; ????
     112:	00 00       	nop
     114:	00 00       	nop
     116:	01 00       	.word	0x0001	; ????
     118:	00 00       	nop
     11a:	00 00       	nop
     11c:	2c 76       	andi	r18, 0x6C	; 108
     11e:	d8 88       	ldd	r13, Y+16	; 0x10
     120:	dc 67       	ori	r29, 0x7C	; 124
     122:	4f 08       	sbc	r4, r15
     124:	23 df       	rcall	.-442    	; 0xffffff6c <__eeprom_end+0xff7eff6c>
     126:	c1 df       	rcall	.-126    	; 0xaa <__SREG__+0x6b>
     128:	ae 59       	subi	r26, 0x9E	; 158
     12a:	e1 b1       	in	r30, 0x01	; 1
     12c:	b7 96       	adiw	r30, 0x27	; 39
     12e:	e5 e3       	ldi	r30, 0x35	; 53
     130:	e4 53       	subi	r30, 0x34	; 52
     132:	c6 3a       	cpi	r28, 0xA6	; 166
     134:	e6 51       	subi	r30, 0x16	; 22
     136:	99 76       	andi	r25, 0x69	; 105
     138:	96 e8       	ldi	r25, 0x86	; 134
     13a:	e6 c2       	rjmp	.+1484   	; 0x708 <tinyAxon_update_potential+0xe2>
     13c:	84 26       	eor	r8, r20
     13e:	eb 89       	ldd	r30, Y+19	; 0x13
     140:	8c 9b       	sbis	0x11, 4	; 17
     142:	62 ed       	ldi	r22, 0xD2	; 210
     144:	40 7c       	andi	r20, 0xC0	; 192
     146:	6f fc       	.word	0xfc6f	; ????
     148:	ef bc       	out	0x2f, r14	; 47
     14a:	9c 9f       	mul	r25, r28
     14c:	40 f2       	brcs	.-112    	; 0xde <__trampolines_end+0x1c>
     14e:	ba a5       	ldd	r27, Y+42	; 0x2a
     150:	6f a5       	ldd	r22, Y+47	; 0x2f
     152:	f4 90       	lpm	r15, Z
     154:	05 5a       	subi	r16, 0xA5	; 165
     156:	2a f7       	brpl	.-54     	; 0x122 <__trampolines_end+0x60>
     158:	5c 93       	st	X, r21
     15a:	6b 6c       	ori	r22, 0xCB	; 203
     15c:	f9 67       	ori	r31, 0x79	; 121
     15e:	6d c1       	rjmp	.+730    	; 0x43a <DAC_0_initialization+0xa>
     160:	1b fc       	.word	0xfc1b	; ????
     162:	e0 e4       	ldi	r30, 0x40	; 64
     164:	0d 47       	sbci	r16, 0x7D	; 125
     166:	fe f5       	brtc	.+126    	; 0x1e6 <.do_clear_bss_loop>
     168:	20 e6       	ldi	r18, 0x60	; 96
     16a:	b5 00       	.word	0x00b5	; ????
     16c:	d0 ed       	ldi	r29, 0xD0	; 208
     16e:	90 2e       	mov	r9, r16
     170:	03 00       	.word	0x0003	; ????
     172:	94 35       	cpi	r25, 0x54	; 84
     174:	77 05       	cpc	r23, r7
     176:	00 80       	ld	r0, Z
     178:	84 1e       	adc	r8, r20
     17a:	08 00       	.word	0x0008	; ????
     17c:	00 20       	and	r0, r0
     17e:	4e 0a       	sbc	r4, r30
     180:	00 00       	nop
     182:	00 c8       	rjmp	.-4096   	; 0xfffff184 <__eeprom_end+0xff7ef184>
     184:	0c 33       	cpi	r16, 0x3C	; 60
     186:	33 33       	cpi	r19, 0x33	; 51
     188:	33 0f       	add	r19, r19
     18a:	98 6e       	ori	r25, 0xE8	; 232
     18c:	12 83       	std	Z+2, r17	; 0x02
     18e:	11 41       	sbci	r17, 0x11	; 17
     190:	ef 8d       	ldd	r30, Y+31	; 0x1f
     192:	21 14       	cp	r2, r1
     194:	89 3b       	cpi	r24, 0xB9	; 185
     196:	e6 55       	subi	r30, 0x56	; 86
     198:	16 cf       	rjmp	.-468    	; 0xffffffc6 <__eeprom_end+0xff7effc6>
     19a:	fe e6       	ldi	r31, 0x6E	; 110
     19c:	db 18       	sub	r13, r11
     19e:	d1 84       	ldd	r13, Z+9	; 0x09
     1a0:	4b 38       	cpi	r20, 0x8B	; 139
     1a2:	1b f7       	brvc	.-58     	; 0x16a <__trampolines_end+0xa8>
     1a4:	7c 1d       	adc	r23, r12
     1a6:	90 1d       	adc	r25, r0
     1a8:	a4 bb       	out	0x14, r26	; 20
     1aa:	e4 24       	eor	r14, r4
     1ac:	20 32       	cpi	r18, 0x20	; 32
     1ae:	84 72       	andi	r24, 0x24	; 36
     1b0:	5e 22       	and	r5, r30
     1b2:	81 00       	.word	0x0081	; ????
     1b4:	c9 f1       	breq	.+114    	; 0x228 <main+0x28>
     1b6:	24 ec       	ldi	r18, 0xC4	; 196
     1b8:	a1 e5       	ldi	r26, 0x51	; 81
     1ba:	3d 27       	eor	r19, r29

000001bc <__ctors_end>:
     1bc:	11 24       	eor	r1, r1
     1be:	1f be       	out	0x3f, r1	; 63
     1c0:	cf ef       	ldi	r28, 0xFF	; 255
     1c2:	cd bf       	out	0x3d, r28	; 61
     1c4:	df e3       	ldi	r29, 0x3F	; 63
     1c6:	de bf       	out	0x3e, r29	; 62

000001c8 <__do_copy_data>:
     1c8:	18 e3       	ldi	r17, 0x38	; 56
     1ca:	a0 e0       	ldi	r26, 0x00	; 0
     1cc:	b8 e3       	ldi	r27, 0x38	; 56
     1ce:	e7 e4       	ldi	r30, 0x47	; 71
     1d0:	f8 e2       	ldi	r31, 0x28	; 40
     1d2:	02 c0       	rjmp	.+4      	; 0x1d8 <__do_copy_data+0x10>
     1d4:	05 90       	lpm	r0, Z+
     1d6:	0d 92       	st	X+, r0
     1d8:	a6 31       	cpi	r26, 0x16	; 22
     1da:	b1 07       	cpc	r27, r17
     1dc:	d9 f7       	brne	.-10     	; 0x1d4 <__do_copy_data+0xc>

000001de <__do_clear_bss>:
     1de:	28 e3       	ldi	r18, 0x38	; 56
     1e0:	a6 e1       	ldi	r26, 0x16	; 22
     1e2:	b8 e3       	ldi	r27, 0x38	; 56
     1e4:	01 c0       	rjmp	.+2      	; 0x1e8 <.do_clear_bss_start>

000001e6 <.do_clear_bss_loop>:
     1e6:	1d 92       	st	X+, r1

000001e8 <.do_clear_bss_start>:
     1e8:	a0 37       	cpi	r26, 0x70	; 112
     1ea:	b2 07       	cpc	r27, r18
     1ec:	e1 f7       	brne	.-8      	; 0x1e6 <.do_clear_bss_loop>
     1ee:	0e 94 00 01 	call	0x200	; 0x200 <main>
     1f2:	0c 94 a8 13 	jmp	0x2750	; 0x2750 <_exit>

000001f6 <__bad_interrupt>:
     1f6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000001fa <atmel_start_init>:
/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
	system_init();
     1fa:	0e 94 24 02 	call	0x448	; 0x448 <system_init>
     1fe:	08 95       	ret

00000200 <main>:

int main(void)
{	
	
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
     200:	0e 94 fd 00 	call	0x1fa	; 0x1fa <atmel_start_init>
	For some reason, instead of the reference voltage being 4.32v, it is 3.3v. 
	A plausible explanation is that the microchip does not up the voltage, so that if the microchip is only ever 
	supplied with 3.3v, it will output 3.3v as the max.
	*/
	
	VREF.CTRLA |= VREF_DAC0REFSEL_4V34_gc;
     204:	e0 ea       	ldi	r30, 0xA0	; 160
     206:	f0 e0       	ldi	r31, 0x00	; 0
     208:	80 81       	ld	r24, Z
     20a:	83 60       	ori	r24, 0x03	; 3
     20c:	80 83       	st	Z, r24
	
	tinyTester_test();
     20e:	0e 94 4d 0a 	call	0x149a	; 0x149a <tinyTester_test>
	
	while (1)
	{
		// We don't want to update the neuron too often because of various reasons. The tinyISR_getflag is set every ms, and so the loop is only run once every ms.  
		if(tinyISR_getflag())
     212:	0e 94 5f 06 	call	0xcbe	; 0xcbe <tinyISR_getflag>
     216:	88 23       	and	r24, r24
     218:	e1 f3       	breq	.-8      	; 0x212 <main+0x12>
		{
			tinyCharge_update_charging_mode();
     21a:	0e 94 7e 04 	call	0x8fc	; 0x8fc <tinyCharge_update_charging_mode>
			
			if(tinyCharge_is_connected_to_charger()){
     21e:	0e 94 43 04 	call	0x886	; 0x886 <tinyCharge_is_connected_to_charger>
     222:	88 23       	and	r24, r24
     224:	b9 f0       	breq	.+46     	; 0x254 <main+0x54>
				// Charge loop
				
				if(tinyCharge_is_fully_charged()){
     226:	0e 94 46 04 	call	0x88c	; 0x88c <tinyCharge_is_fully_charged>
     22a:	88 23       	and	r24, r24
     22c:	49 f0       	breq	.+18     	; 0x240 <main+0x40>
					// When the neuron is connected to a charger, and fully charged:
					tinyLED_set_color(INN_LED, CHARGING_DONE_COLOR);
     22e:	63 e0       	ldi	r22, 0x03	; 3
     230:	80 e0       	ldi	r24, 0x00	; 0
     232:	0e 94 a2 06 	call	0xd44	; 0xd44 <tinyLED_set_color>
					tinyLED_set_color(OUT_LED, LED_OFF);
     236:	60 e0       	ldi	r22, 0x00	; 0
     238:	81 e0       	ldi	r24, 0x01	; 1
     23a:	0e 94 a2 06 	call	0xd44	; 0xd44 <tinyLED_set_color>
     23e:	11 c0       	rjmp	.+34     	; 0x262 <main+0x62>
				}
				else{
					// When the neuron is charging and is not fully charged
					tinyLED_set_color_mode(OUT_LED, CHARGING_COLOR, SWING);
     240:	43 e0       	ldi	r20, 0x03	; 3
     242:	61 e0       	ldi	r22, 0x01	; 1
     244:	81 e0       	ldi	r24, 0x01	; 1
     246:	0e 94 7e 06 	call	0xcfc	; 0xcfc <tinyLED_set_color_mode>
					tinyLED_set_color(INN_LED, LED_OFF);
     24a:	60 e0       	ldi	r22, 0x00	; 0
     24c:	80 e0       	ldi	r24, 0x00	; 0
     24e:	0e 94 a2 06 	call	0xd44	; 0xd44 <tinyLED_set_color>
     252:	07 c0       	rjmp	.+14     	; 0x262 <main+0x62>
				// Main loop			
				
				// Set LED
				// If the out led is turned LED_OFF, and the ping color is not disabled,
				// we turn on ping mode
				if(tinyLED_get_color(OUT_LED) == LED_OFF && PING_COLOR != LED_OFF){
     254:	81 e0       	ldi	r24, 0x01	; 1
     256:	0e 94 76 06 	call	0xcec	; 0xcec <tinyLED_get_color>
					tinyLED_set_color_mode(OUT_LED, PING_COLOR, PING);
				}				
				
				// Update button	
				tinyButton_update();
     25a:	0e 94 da 03 	call	0x7b4	; 0x7b4 <tinyButton_update>
				
				// Update the potential (This is where most of the important stuff happens)
				tinyPotential_update();
     25e:	0e 94 ec 08 	call	0x11d8	; 0x11d8 <tinyPotential_update>
			}
			// Update LED
			tinyLED_update();
     262:	0e 94 d6 06 	call	0xdac	; 0xdac <tinyLED_update>
				
			// Switch transistors
			tinyCharge_set_transistors();
     266:	0e 94 a6 04 	call	0x94c	; 0x94c <tinyCharge_set_transistors>
			
			// Prepare for next cycle
			tinyISR_setflag(false);
     26a:	80 e0       	ldi	r24, 0x00	; 0
     26c:	0e 94 5c 06 	call	0xcb8	; 0xcb8 <tinyISR_setflag>
			tinyDebugger_send_uint32("time", tinyTime_now());
     270:	0e 94 8d 0a 	call	0x151a	; 0x151a <tinyTime_now>
     274:	ab 01       	movw	r20, r22
     276:	bc 01       	movw	r22, r24
     278:	8e e5       	ldi	r24, 0x5E	; 94
     27a:	97 ea       	ldi	r25, 0xA7	; 167
     27c:	0e 94 b0 04 	call	0x960	; 0x960 <tinyDebugger_send_uint32>
			tinyDebugger_end_line();
     280:	0e 94 09 05 	call	0xa12	; 0xa12 <tinyDebugger_end_line>
     284:	c6 cf       	rjmp	.-116    	; 0x212 <main+0x12>

00000286 <ADC_0_init>:
 * \return Conversion result read from the ADC_0 ADC module
 */
adc_result_t ADC_0_get_conversion_result(void)
{
	return (ADC1.RES);
}
     286:	e0 e4       	ldi	r30, 0x40	; 64
     288:	f6 e0       	ldi	r31, 0x06	; 6
     28a:	80 e1       	ldi	r24, 0x10	; 16
     28c:	82 83       	std	Z+2, r24	; 0x02
     28e:	85 e0       	ldi	r24, 0x05	; 5
     290:	80 83       	st	Z, r24
     292:	80 e0       	ldi	r24, 0x00	; 0
     294:	08 95       	ret

00000296 <ADC_0_is_conversion_done>:
     296:	80 91 4b 06 	lds	r24, 0x064B	; 0x80064b <__TEXT_REGION_LENGTH__+0x70064b>
     29a:	81 70       	andi	r24, 0x01	; 1
     29c:	08 95       	ret

0000029e <ADC_0_get_conversion>:
 *
 * \return Nothing
 */
void ADC_0_start_conversion(adc_1_channel_t channel)
{
	ADC1.MUXPOS  = channel;
     29e:	e0 e4       	ldi	r30, 0x40	; 64
     2a0:	f6 e0       	ldi	r31, 0x06	; 6
     2a2:	86 83       	std	Z+6, r24	; 0x06
	ADC1.COMMAND = ADC_STCONV_bm;
     2a4:	81 e0       	ldi	r24, 0x01	; 1
     2a6:	80 87       	std	Z+8, r24	; 0x08
adc_result_t ADC_0_get_conversion(adc_1_channel_t channel)
{
	adc_result_t res;

	ADC_0_start_conversion(channel);
	while (!ADC_0_is_conversion_done())
     2a8:	0e 94 4b 01 	call	0x296	; 0x296 <ADC_0_is_conversion_done>
     2ac:	88 23       	and	r24, r24
     2ae:	e1 f3       	breq	.-8      	; 0x2a8 <ADC_0_get_conversion+0xa>
 *
 * \return Conversion result read from the ADC_0 ADC module
 */
adc_result_t ADC_0_get_conversion_result(void)
{
	return (ADC1.RES);
     2b0:	e0 e4       	ldi	r30, 0x40	; 64
     2b2:	f6 e0       	ldi	r31, 0x06	; 6
     2b4:	20 89       	ldd	r18, Z+16	; 0x10
     2b6:	31 89       	ldd	r19, Z+17	; 0x11

	ADC_0_start_conversion(channel);
	while (!ADC_0_is_conversion_done())
		;
	res = ADC_0_get_conversion_result();
	ADC1.INTFLAGS |= ADC_RESRDY_bm;
     2b8:	93 85       	ldd	r25, Z+11	; 0x0b
     2ba:	91 60       	ori	r25, 0x01	; 1
     2bc:	93 87       	std	Z+11, r25	; 0x0b
	return res;
}
     2be:	c9 01       	movw	r24, r18
     2c0:	08 95       	ret

000002c2 <BOD_init>:
	//		 | BOD_VLMCFG_BELOW_gc; /* Interrupt when supply goes below VLM level */

	// BOD.VLMCTRLA = BOD_VLMLVL_5ABOVE_gc; /* VLM threshold 5% above BOD level */

	return 0;
}
     2c2:	80 e0       	ldi	r24, 0x00	; 0
     2c4:	08 95       	ret

000002c6 <DIGITAL_GLUE_LOGIC_0_init>:

	// Enable Protected register, peripheral must be disabled (ENABLE=0, in TCD.LUT0CTRLA).

	// CCL.SEQCTRL0 = CCL_SEQSEL_DISABLE_gc /* Sequential logic disabled */;

	CCL.TRUTH0 = 168; /* Truth 0: 168 */
     2c6:	e0 ec       	ldi	r30, 0xC0	; 192
     2c8:	f1 e0       	ldi	r31, 0x01	; 1
     2ca:	28 ea       	ldi	r18, 0xA8	; 168
     2cc:	20 87       	std	Z+8, r18	; 0x08

	CCL.LUT0CTRLC = CCL_INSEL2_TCA0_gc /* TCA0 WO2 input source */;
     2ce:	98 e0       	ldi	r25, 0x08	; 8
     2d0:	97 83       	std	Z+7, r25	; 0x07

	CCL.LUT0CTRLB = CCL_INSEL0_SPI0_gc /* SPI0 SCK source */
     2d2:	8b eb       	ldi	r24, 0xBB	; 187
     2d4:	86 83       	std	Z+6, r24	; 0x06
	                | CCL_INSEL1_SPI0_gc /* SPI0 MOSI input source */;

	CCL.LUT0CTRLA = 0 << CCL_CLKSRC_bp       /* Clock Source Selection: disabled */
     2d6:	39 e0       	ldi	r19, 0x09	; 9
     2d8:	35 83       	std	Z+5, r19	; 0x05
	                | CCL_EDGEDET_DIS_gc     /* Edge detector is disabled */
	                | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	                | 1 << CCL_ENABLE_bp     /* LUT Enable: enabled */
	                | 1 << CCL_OUTEN_bp;     /* Output Enable: enabled */

	CCL.TRUTH1 = 168; /* Truth 1: 168 */
     2da:	24 87       	std	Z+12, r18	; 0x0c

	CCL.LUT1CTRLC = CCL_INSEL2_TCA0_gc /* TCA0 WO2 input source */;
     2dc:	93 87       	std	Z+11, r25	; 0x0b

	CCL.LUT1CTRLB = CCL_INSEL0_SPI0_gc /* SPI0 SCK source */
     2de:	82 87       	std	Z+10, r24	; 0x0a
	//		 | CCL_EDGEDET_DIS_gc /* Edge detector is disabled */
	//		 | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	//		 | 0 << CCL_ENABLE_bp /* LUT Enable: disabled */
	//		 | 0 << CCL_OUTEN_bp; /* Output Enable: disabled */

	CCL.CTRLA = 1 << CCL_ENABLE_bp      /* Enable: enabled */
     2e0:	81 e4       	ldi	r24, 0x41	; 65
     2e2:	80 83       	st	Z, r24
	            | 1 << CCL_RUNSTDBY_bp; /* Run in Standby: enabled */

	return 0;
}
     2e4:	80 e0       	ldi	r24, 0x00	; 0
     2e6:	08 95       	ret

000002e8 <CLKCTRL_init>:
 *       on calling convention. The memory model is not visible to the
 *       preprocessor, so it must be defined in the Assembler preprocessor directives.
 */
static inline void ccp_write_io(void *addr, uint8_t value)
{
	protected_write_io(addr, CCP_IOREG_gc, value);
     2e8:	47 e0       	ldi	r20, 0x07	; 7
     2ea:	68 ed       	ldi	r22, 0xD8	; 216
     2ec:	8c e7       	ldi	r24, 0x7C	; 124
     2ee:	90 e0       	ldi	r25, 0x00	; 0
     2f0:	0e 94 53 02 	call	0x4a6	; 0x4a6 <protected_write_io>
     2f4:	41 e0       	ldi	r20, 0x01	; 1
     2f6:	68 ed       	ldi	r22, 0xD8	; 216
     2f8:	81 e6       	ldi	r24, 0x61	; 97
     2fa:	90 e0       	ldi	r25, 0x00	; 0
     2fc:	0e 94 53 02 	call	0x4a6	; 0x4a6 <protected_write_io>
	//		 | 0 << CLKCTRL_CLKOUT_bp /* System clock out: disabled */);

	// ccp_write_io((void*)&(CLKCTRL.MCLKLOCK),0 << CLKCTRL_LOCKEN_bp /* lock enable: disabled */);

	return 0;
}
     300:	80 e0       	ldi	r24, 0x00	; 0
     302:	08 95       	ret

00000304 <CPUINT_init>:

	// CPUINT.LVL0PRI = 0x0 << CPUINT_LVL0PRI_gp; /* Interrupt Level Priority: 0x0 */

	// CPUINT.LVL1VEC = 0x0 << CPUINT_LVL1VEC_gp; /* Interrupt Vector with High Priority: 0x0 */

	ENABLE_INTERRUPTS();
     304:	78 94       	sei

	return 0;
}
     306:	80 e0       	ldi	r24, 0x00	; 0
     308:	08 95       	ret

0000030a <DAC_0_init>:
int8_t DAC_0_init()
{

	// DAC0.DATA = 0x0; /* DATA Register: 0x0 */

	DAC0.CTRLA = 1 << DAC_ENABLE_bp      /* DAC Enable: enabled */
     30a:	81 e4       	ldi	r24, 0x41	; 65
     30c:	80 93 a0 06 	sts	0x06A0, r24	; 0x8006a0 <__TEXT_REGION_LENGTH__+0x7006a0>
	             | 1 << DAC_OUTEN_bp     /* Output Buffer Enable: enabled */
	             | 0 << DAC_RUNSTDBY_bp; /* Run in Standby Mode: disabled */

	return 0;
}
     310:	80 e0       	ldi	r24, 0x00	; 0
     312:	08 95       	ret

00000314 <DAC_0_uninit>:
int8_t DAC_0_uninit()
{

	// DAC0.DATA = 0x0; /* DATA Register: 0x0 */

	DAC0.CTRLA = 1 << DAC_ENABLE_bp      /* DAC Enable: enabled */
     314:	81 e0       	ldi	r24, 0x01	; 1
     316:	80 93 a0 06 	sts	0x06A0, r24	; 0x8006a0 <__TEXT_REGION_LENGTH__+0x7006a0>
	| 0 << DAC_OUTEN_bp     /* Output Buffer Enable: disabled */
	| 0 << DAC_RUNSTDBY_bp; /* Run in Standby Mode: disabled */

	return 0;
}
     31a:	80 e0       	ldi	r24, 0x00	; 0
     31c:	08 95       	ret

0000031e <DAC_0_enable>:
 *
 * \return Nothing
 */
void DAC_0_enable()
{
	DAC0.CTRLA |= DAC_ENABLE_bm;
     31e:	e0 ea       	ldi	r30, 0xA0	; 160
     320:	f6 e0       	ldi	r31, 0x06	; 6
     322:	80 81       	ld	r24, Z
     324:	81 60       	ori	r24, 0x01	; 1
     326:	80 83       	st	Z, r24
     328:	08 95       	ret

0000032a <DAC_0_disable>:
 *
 * \return Nothing
 */
void DAC_0_disable()
{
	DAC0.CTRLA &= ~DAC_ENABLE_bm;
     32a:	e0 ea       	ldi	r30, 0xA0	; 160
     32c:	f6 e0       	ldi	r31, 0x06	; 6
     32e:	80 81       	ld	r24, Z
     330:	8e 7f       	andi	r24, 0xFE	; 254
     332:	80 83       	st	Z, r24
     334:	08 95       	ret

00000336 <DAC_0_set_output>:
 *
 * \return Nothing
 */
void DAC_0_set_output(dac_resolution_t value)
{
	DAC0.DATA = value;
     336:	80 93 a1 06 	sts	0x06A1, r24	; 0x8006a1 <__TEXT_REGION_LENGTH__+0x7006a1>
     33a:	08 95       	ret

0000033c <mcu_init>:
#ifdef __cplusplus
extern "C" {
#endif

void mcu_init(void)
{
     33c:	e0 e1       	ldi	r30, 0x10	; 16
     33e:	f4 e0       	ldi	r31, 0x04	; 4
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     340:	80 81       	ld	r24, Z
     342:	88 60       	ori	r24, 0x08	; 8
     344:	81 93       	st	Z+, r24
	 * disables all peripherals to save power. Driver shall enable
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
     346:	e8 31       	cpi	r30, 0x18	; 24
     348:	84 e0       	ldi	r24, 0x04	; 4
     34a:	f8 07       	cpc	r31, r24
     34c:	c9 f7       	brne	.-14     	; 0x340 <mcu_init+0x4>
     34e:	e0 e3       	ldi	r30, 0x30	; 48
     350:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     352:	80 81       	ld	r24, Z
     354:	88 60       	ori	r24, 0x08	; 8
     356:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     358:	e8 33       	cpi	r30, 0x38	; 56
     35a:	84 e0       	ldi	r24, 0x04	; 4
     35c:	f8 07       	cpc	r31, r24
     35e:	c9 f7       	brne	.-14     	; 0x352 <mcu_init+0x16>
     360:	e0 e5       	ldi	r30, 0x50	; 80
     362:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     364:	80 81       	ld	r24, Z
     366:	88 60       	ori	r24, 0x08	; 8
     368:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     36a:	e8 35       	cpi	r30, 0x58	; 88
     36c:	84 e0       	ldi	r24, 0x04	; 4
     36e:	f8 07       	cpc	r31, r24
     370:	c9 f7       	brne	.-14     	; 0x364 <mcu_init+0x28>
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}
}
     372:	08 95       	ret

00000374 <ADC_0_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     374:	e5 e1       	ldi	r30, 0x15	; 21
     376:	f4 e0       	ldi	r31, 0x04	; 4
     378:	80 81       	ld	r24, Z
     37a:	88 7f       	andi	r24, 0xF8	; 248
     37c:	84 60       	ori	r24, 0x04	; 4
     37e:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     380:	80 81       	ld	r24, Z
     382:	87 7f       	andi	r24, 0xF7	; 247
     384:	80 83       	st	Z, r24
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     386:	e7 e1       	ldi	r30, 0x17	; 23
     388:	f4 e0       	ldi	r31, 0x04	; 4
     38a:	80 81       	ld	r24, Z
     38c:	88 7f       	andi	r24, 0xF8	; 248
     38e:	84 60       	ori	r24, 0x04	; 4
     390:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     392:	80 81       	ld	r24, Z
     394:	87 7f       	andi	r24, 0xF7	; 247
     396:	80 83       	st	Z, r24
 */
static inline void PORTC_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     398:	e0 e5       	ldi	r30, 0x50	; 80
     39a:	f4 e0       	ldi	r31, 0x04	; 4
     39c:	80 81       	ld	r24, Z
     39e:	88 7f       	andi	r24, 0xF8	; 248
     3a0:	84 60       	ori	r24, 0x04	; 4
     3a2:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     3a4:	80 81       	ld	r24, Z
     3a6:	87 7f       	andi	r24, 0xF7	; 247
     3a8:	80 83       	st	Z, r24
 */
static inline void PORTC_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     3aa:	e1 e5       	ldi	r30, 0x51	; 81
     3ac:	f4 e0       	ldi	r31, 0x04	; 4
     3ae:	80 81       	ld	r24, Z
     3b0:	88 7f       	andi	r24, 0xF8	; 248
     3b2:	84 60       	ori	r24, 0x04	; 4
     3b4:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     3b6:	80 81       	ld	r24, Z
     3b8:	87 7f       	andi	r24, 0xF7	; 247
     3ba:	80 83       	st	Z, r24
 */
static inline void PORTC_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     3bc:	e3 e5       	ldi	r30, 0x53	; 83
     3be:	f4 e0       	ldi	r31, 0x04	; 4
     3c0:	80 81       	ld	r24, Z
     3c2:	88 7f       	andi	r24, 0xF8	; 248
     3c4:	84 60       	ori	r24, 0x04	; 4
     3c6:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     3c8:	80 81       	ld	r24, Z
     3ca:	87 7f       	andi	r24, 0xF7	; 247
     3cc:	80 83       	st	Z, r24
	// Disable digital input buffer
	DEN4_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	DEN4_PIN_set_pull_mode(PORT_PULL_OFF);

	ADC_0_init();
     3ce:	0e 94 43 01 	call	0x286	; 0x286 <ADC_0_init>
     3d2:	08 95       	ret

000003d4 <USART_0_initialization>:
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     3d4:	23 98       	cbi	0x04, 3	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     3d6:	e3 e3       	ldi	r30, 0x33	; 51
     3d8:	f4 e0       	ldi	r31, 0x04	; 4
     3da:	80 81       	ld	r24, Z
     3dc:	87 7f       	andi	r24, 0xF7	; 247
     3de:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     3e0:	22 9a       	sbi	0x04, 2	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     3e2:	2a 98       	cbi	0x05, 2	; 5
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	USART_0_init();
     3e4:	0e 94 8d 02 	call	0x51a	; 0x51a <USART_0_init>
     3e8:	08 95       	ret

000003ea <TIMER_0_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     3ea:	25 9a       	sbi	0x04, 5	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     3ec:	2d 98       	cbi	0x05, 5	; 5
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLC |= PORTMUX_TCA02_bm;
     3ee:	e0 e0       	ldi	r30, 0x00	; 0
     3f0:	f2 e0       	ldi	r31, 0x02	; 2
     3f2:	82 81       	ldd	r24, Z+2	; 0x02
     3f4:	84 60       	ori	r24, 0x04	; 4
     3f6:	82 83       	std	Z+2, r24	; 0x02

	TIMER_0_init();
     3f8:	0e 94 7d 02 	call	0x4fa	; 0x4fa <TIMER_0_init>
     3fc:	08 95       	ret

000003fe <DIGITAL_GLUE_LOGIC_0_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     3fe:	24 9a       	sbi	0x04, 4	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     400:	2c 98       	cbi	0x05, 4	; 5
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLA |= PORTMUX_LUT0_bm;
     402:	e0 e0       	ldi	r30, 0x00	; 0
     404:	f2 e0       	ldi	r31, 0x02	; 2
     406:	80 81       	ld	r24, Z
     408:	80 61       	ori	r24, 0x10	; 16
     40a:	80 83       	st	Z, r24

	DIGITAL_GLUE_LOGIC_0_init();
     40c:	0e 94 63 01 	call	0x2c6	; 0x2c6 <DIGITAL_GLUE_LOGIC_0_init>
     410:	08 95       	ret

00000412 <SPI_0_initialization>:
 */
static inline void PORTA_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
     412:	02 98       	cbi	0x00, 2	; 0
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     414:	e2 e1       	ldi	r30, 0x12	; 18
     416:	f4 e0       	ldi	r31, 0x04	; 4
     418:	80 81       	ld	r24, Z
     41a:	87 7f       	andi	r24, 0xF7	; 247
     41c:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     41e:	01 9a       	sbi	0x00, 1	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     420:	09 98       	cbi	0x01, 1	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     422:	03 9a       	sbi	0x00, 3	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     424:	0b 98       	cbi	0x01, 3	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     426:	04 9a       	sbi	0x00, 4	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     428:	0c 98       	cbi	0x01, 4	; 1
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	SPI_0_init();
     42a:	0e 94 75 02 	call	0x4ea	; 0x4ea <SPI_0_init>
     42e:	08 95       	ret

00000430 <DAC_0_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     430:	e6 e1       	ldi	r30, 0x16	; 22
     432:	f4 e0       	ldi	r31, 0x04	; 4
     434:	80 81       	ld	r24, Z
     436:	88 7f       	andi	r24, 0xF8	; 248
     438:	84 60       	ori	r24, 0x04	; 4
     43a:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     43c:	80 81       	ld	r24, Z
     43e:	87 7f       	andi	r24, 0xF7	; 247
     440:	80 83       	st	Z, r24
	// Disable digital input buffer
	AXON_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	AXON_PIN_set_pull_mode(PORT_PULL_OFF);

	DAC_0_init();
     442:	0e 94 85 01 	call	0x30a	; 0x30a <DAC_0_init>
     446:	08 95       	ret

00000448 <system_init>:
/**
 * \brief System initialization
 */
void system_init()
{
	mcu_init();
     448:	0e 94 9e 01 	call	0x33c	; 0x33c <mcu_init>
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     44c:	21 9a       	sbi	0x04, 1	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     44e:	29 98       	cbi	0x05, 1	; 5
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     450:	26 98       	cbi	0x04, 6	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     452:	e6 e3       	ldi	r30, 0x36	; 54
     454:	f4 e0       	ldi	r31, 0x04	; 4
     456:	80 81       	ld	r24, Z
     458:	87 7f       	andi	r24, 0xF7	; 247
     45a:	80 83       	st	Z, r24
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     45c:	27 98       	cbi	0x04, 7	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     45e:	e7 e3       	ldi	r30, 0x37	; 55
     460:	f4 e0       	ldi	r31, 0x04	; 4
     462:	80 81       	ld	r24, Z
     464:	87 7f       	andi	r24, 0xF7	; 247
     466:	80 83       	st	Z, r24
 */
static inline void PORTC_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
     468:	42 98       	cbi	0x08, 2	; 8
static inline void PORTC_set_pin_pull_mode(const uint8_t pin, const enum port_pull_mode pull_mode)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
     46a:	e2 e5       	ldi	r30, 0x52	; 82
     46c:	f4 e0       	ldi	r31, 0x04	; 4
     46e:	80 81       	ld	r24, Z
     470:	88 60       	ori	r24, 0x08	; 8
     472:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTC.DIR |= (1 << pin);
     474:	45 9a       	sbi	0x08, 5	; 8
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     476:	4d 9a       	sbi	0x09, 5	; 9
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    true);

	CLKCTRL_init();
     478:	0e 94 74 01 	call	0x2e8	; 0x2e8 <CLKCTRL_init>

	RTC_0_init();
     47c:	0e 94 57 02 	call	0x4ae	; 0x4ae <RTC_0_init>

	ADC_0_initialization();
     480:	0e 94 ba 01 	call	0x374	; 0x374 <ADC_0_initialization>

	USART_0_initialization();
     484:	0e 94 ea 01 	call	0x3d4	; 0x3d4 <USART_0_initialization>

	TIMER_0_initialization();
     488:	0e 94 f5 01 	call	0x3ea	; 0x3ea <TIMER_0_initialization>

	DIGITAL_GLUE_LOGIC_0_initialization();
     48c:	0e 94 ff 01 	call	0x3fe	; 0x3fe <DIGITAL_GLUE_LOGIC_0_initialization>

	SPI_0_initialization();
     490:	0e 94 09 02 	call	0x412	; 0x412 <SPI_0_initialization>

	DAC_0_initialization();
     494:	0e 94 18 02 	call	0x430	; 0x430 <DAC_0_initialization>

	CPUINT_init();
     498:	0e 94 82 01 	call	0x304	; 0x304 <CPUINT_init>

	SLPCTRL_init();
     49c:	0e 94 73 02 	call	0x4e6	; 0x4e6 <SLPCTRL_init>

	BOD_init();
     4a0:	0e 94 61 01 	call	0x2c2	; 0x2c2 <BOD_init>
     4a4:	08 95       	ret

000004a6 <protected_write_io>:
#if defined(__GNUC__)
  
#ifdef RAMPZ
	out     _SFR_IO_ADDR(RAMPZ), r1         // Clear bits 23:16 of Z
#endif
	movw    r30, r24                // Load addr into Z
     4a6:	fc 01       	movw	r30, r24
	out     CCP, r22                // Start CCP handshake
     4a8:	64 bf       	out	0x34, r22	; 52
	st      Z, r20                  // Write value to I/O register
     4aa:	40 83       	st	Z, r20
	ret                             // Return to caller
     4ac:	08 95       	ret

000004ae <RTC_0_init>:
 * \return Initialization status.
 */
int8_t RTC_0_init()
{

	while (RTC.STATUS > 0) { /* Wait for all register to be synchronized */
     4ae:	e0 e4       	ldi	r30, 0x40	; 64
     4b0:	f1 e0       	ldi	r31, 0x01	; 1
     4b2:	81 81       	ldd	r24, Z+1	; 0x01
     4b4:	81 11       	cpse	r24, r1
     4b6:	fd cf       	rjmp	.-6      	; 0x4b2 <RTC_0_init+0x4>
	}

	// RTC.CMP = 0x0; /* Compare: 0x0 */

	RTC.CNT = 0x20; /* Counter: 0x20 */
     4b8:	e0 e4       	ldi	r30, 0x40	; 64
     4ba:	f1 e0       	ldi	r31, 0x01	; 1
     4bc:	80 e2       	ldi	r24, 0x20	; 32
     4be:	90 e0       	ldi	r25, 0x00	; 0
     4c0:	80 87       	std	Z+8, r24	; 0x08
     4c2:	91 87       	std	Z+9, r25	; 0x09

	RTC.CTRLA = RTC_PRESCALER_DIV1_gc   /* 1 */
     4c4:	81 e8       	ldi	r24, 0x81	; 129
     4c6:	80 83       	st	Z, r24
	            | 1 << RTC_RTCEN_bp     /* Enable: enabled */
	            | 1 << RTC_RUNSTDBY_bp; /* Run In Standby: enabled */

	RTC.PER = 0x20 / TIMESCALE; /* Period: 0x20 */
     4c8:	80 e8       	ldi	r24, 0x80	; 128
     4ca:	92 e0       	ldi	r25, 0x02	; 2
     4cc:	82 87       	std	Z+10, r24	; 0x0a
     4ce:	93 87       	std	Z+11, r25	; 0x0b

	// RTC.CLKSEL = RTC_CLKSEL_INT32K_gc; /* 32KHz Internal Ultra Low Power Oscillator (OSCULP32K) */

	RTC.DBGCTRL = 1 << RTC_DBGRUN_bp; /* Run in debug: enabled */
     4d0:	81 e0       	ldi	r24, 0x01	; 1
     4d2:	85 83       	std	Z+5, r24	; 0x05

	RTC.INTCTRL = 0 << RTC_CMP_bp    /* Compare Match Interrupt enable: disabled */
     4d4:	82 83       	std	Z+2, r24	; 0x02
	              | 1 << RTC_OVF_bp; /* Overflow Interrupt enable: enabled */

	while (RTC.PITSTATUS > 0) { /* Wait for all register to be synchronized */
     4d6:	81 89       	ldd	r24, Z+17	; 0x11
     4d8:	81 11       	cpse	r24, r1
     4da:	fd cf       	rjmp	.-6      	; 0x4d6 <RTC_0_init+0x28>
	}

	RTC.PITCTRLA = RTC_PERIOD_OFF_gc    /* Off */
     4dc:	81 e0       	ldi	r24, 0x01	; 1
     4de:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <__TEXT_REGION_LENGTH__+0x700150>
	// RTC.PITDBGCTRL = 0 << RTC_DBGRUN_bp; /* Run in debug: disabled */

	// RTC.PITINTCTRL = 0 << RTC_PI_bp; /* Periodic Interrupt: disabled */

	return 0;
}
     4e2:	80 e0       	ldi	r24, 0x00	; 0
     4e4:	08 95       	ret

000004e6 <SLPCTRL_init>:

	// SLPCTRL.CTRLA = 0 << SLPCTRL_SEN_bp /* Sleep enable: disabled */
	//		 | SLPCTRL_SMODE_IDLE_gc; /* Idle mode */

	return 0;
}
     4e6:	80 e0       	ldi	r24, 0x00	; 0
     4e8:	08 95       	ret

000004ea <SPI_0_init>:
 * \return Initialization status
 */
int8_t SPI_0_init()
{

	SPI0.CTRLA = 0 << SPI_CLK2X_bp     /* Enable Double Speed: disabled */
     4ea:	e0 e2       	ldi	r30, 0x20	; 32
     4ec:	f8 e0       	ldi	r31, 0x08	; 8
     4ee:	83 e2       	ldi	r24, 0x23	; 35
     4f0:	80 83       	st	Z, r24
	             | 0 << SPI_DORD_bp    /* Data Order Setting: disabled */
	             | 1 << SPI_ENABLE_bp  /* Enable Module: enabled */
	             | 1 << SPI_MASTER_bp  /* SPI module in master mode */
	             | SPI_PRESC_DIV16_gc; /* System Clock / 16 */

	SPI0.CTRLB = 0 << SPI_BUFEN_bp   /* Buffer Mode Enable: disabled */
     4f2:	84 e0       	ldi	r24, 0x04	; 4
     4f4:	81 83       	std	Z+1, r24	; 0x01
	//		 | 0 << SPI_RXCIE_bp /* Receive Complete Interrupt Enable: disabled */
	//		 | 0 << SPI_SSIE_bp /* Slave Select Trigger Interrupt Enable: disabled */
	//		 | 0 << SPI_TXCIE_bp; /* Transfer Complete Interrupt Enable: disabled */

	return 0;
}
     4f6:	80 e0       	ldi	r24, 0x00	; 0
     4f8:	08 95       	ret

000004fa <TIMER_0_init>:

	// TCA0.SINGLE.CMP0 = 0x0; /* Compare Register 0: 0x0 */

	// TCA0.SINGLE.CMP1 = 0x0; /* Compare Register 1: 0x0 */

	TCA0.SINGLE.CMP2 = 0x4; /* Compare Register 2: 0x4 */
     4fa:	e0 e0       	ldi	r30, 0x00	; 0
     4fc:	fa e0       	ldi	r31, 0x0A	; 10
     4fe:	84 e0       	ldi	r24, 0x04	; 4
     500:	90 e0       	ldi	r25, 0x00	; 0
     502:	84 a7       	std	Z+44, r24	; 0x2c
     504:	95 a7       	std	Z+45, r25	; 0x2d

	// TCA0.SINGLE.CNT = 0x0; /* Count: 0x0 */

	TCA0.SINGLE.CTRLB = 0 << TCA_SINGLE_ALUPD_bp            /* Auto Lock Update: disabled */
     506:	83 e4       	ldi	r24, 0x43	; 67
     508:	81 83       	std	Z+1, r24	; 0x01
	                    | 0 << TCA_SINGLE_CMP0EN_bp         /* Compare 0 Enable: disabled */
	                    | 0 << TCA_SINGLE_CMP1EN_bp         /* Compare 1 Enable: disabled */
	                    | 1 << TCA_SINGLE_CMP2EN_bp         /* Compare 2 Enable: enabled */
	                    | TCA_SINGLE_WGMODE_SINGLESLOPE_gc; /*  */

	TCA0.SINGLE.CTRLC = 0 << TCA_SINGLE_CMP0OV_bp    /* Compare 0 Waveform Output Value: disabled */
     50a:	84 e0       	ldi	r24, 0x04	; 4
     50c:	82 83       	std	Z+2, r24	; 0x02
	// TCA0.SINGLE.INTCTRL = 0 << TCA_SINGLE_CMP0_bp /* Compare 0 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP1_bp /* Compare 1 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP2_bp /* Compare 2 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_OVF_bp; /* Overflow Interrupt: disabled */

	TCA0.SINGLE.PER = 0x7; /* Period: 0x7 */
     50e:	87 e0       	ldi	r24, 0x07	; 7
     510:	90 e0       	ldi	r25, 0x00	; 0
     512:	86 a3       	std	Z+38, r24	; 0x26
     514:	97 a3       	std	Z+39, r25	; 0x27

	// TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV1_gc /* System Clock */
	//		 | 0 << TCA_SINGLE_ENABLE_bp; /* Module Enable: disabled */

	return 0;
}
     516:	80 e0       	ldi	r24, 0x00	; 0
     518:	08 95       	ret

0000051a <USART_0_init>:
uint8_t USART_0_read()
{
	while (!(USART0.STATUS & USART_RXCIF_bm))
		;
	return USART0.RXDATAL;
}
     51a:	e0 e0       	ldi	r30, 0x00	; 0
     51c:	f8 e0       	ldi	r31, 0x08	; 8
     51e:	8b e5       	ldi	r24, 0x5B	; 91
     520:	91 e0       	ldi	r25, 0x01	; 1
     522:	80 87       	std	Z+8, r24	; 0x08
     524:	91 87       	std	Z+9, r25	; 0x09
     526:	80 ec       	ldi	r24, 0xC0	; 192
     528:	86 83       	std	Z+6, r24	; 0x06
     52a:	80 e0       	ldi	r24, 0x00	; 0
     52c:	98 e3       	ldi	r25, 0x38	; 56
     52e:	80 93 6c 38 	sts	0x386C, r24	; 0x80386c <__iob+0x2>
     532:	90 93 6d 38 	sts	0x386D, r25	; 0x80386d <__iob+0x3>
     536:	80 e0       	ldi	r24, 0x00	; 0
     538:	08 95       	ret

0000053a <USART_0_write>:
 *
 * \return Nothing
 */
void USART_0_write(const uint8_t data)
{
	while (!(USART0.STATUS & USART_DREIF_bm))
     53a:	e0 e0       	ldi	r30, 0x00	; 0
     53c:	f8 e0       	ldi	r31, 0x08	; 8
     53e:	94 81       	ldd	r25, Z+4	; 0x04
     540:	95 ff       	sbrs	r25, 5
     542:	fd cf       	rjmp	.-6      	; 0x53e <USART_0_write+0x4>
		;
	USART0.TXDATAL = data;
     544:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <__TEXT_REGION_LENGTH__+0x700802>
     548:	08 95       	ret

0000054a <USART_0_printCHAR>:

#if defined(__GNUC__)

int USART_0_printCHAR(char character, FILE *stream)
{
	USART_0_write(character);
     54a:	0e 94 9d 02 	call	0x53a	; 0x53a <USART_0_write>
	return 0;
}
     54e:	80 e0       	ldi	r24, 0x00	; 0
     550:	90 e0       	ldi	r25, 0x00	; 0
     552:	08 95       	ret

00000554 <tinyAxon_add_pulse>:
{
	// We want to check each slot in the pulse_queue, and
	// if we find an empty slot (0), we add a pulse.
	for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
	{
		if(pulse_queue[i] == 0){
     554:	20 91 16 38 	lds	r18, 0x3816	; 0x803816 <__data_end>
     558:	30 91 17 38 	lds	r19, 0x3817	; 0x803817 <__data_end+0x1>
     55c:	23 2b       	or	r18, r19
     55e:	51 f0       	breq	.+20     	; 0x574 <tinyAxon_add_pulse+0x20>
     560:	e8 e1       	ldi	r30, 0x18	; 24
     562:	f8 e3       	ldi	r31, 0x38	; 56
     564:	21 e0       	ldi	r18, 0x01	; 1
     566:	30 e0       	ldi	r19, 0x00	; 0
     568:	b9 01       	movw	r22, r18
     56a:	41 91       	ld	r20, Z+
     56c:	51 91       	ld	r21, Z+
     56e:	45 2b       	or	r20, r21
     570:	81 f4       	brne	.+32     	; 0x592 <tinyAxon_add_pulse+0x3e>
     572:	02 c0       	rjmp	.+4      	; 0x578 <tinyAxon_add_pulse+0x24>
     574:	60 e0       	ldi	r22, 0x00	; 0
     576:	70 e0       	ldi	r23, 0x00	; 0
			pulse_queue[i] = new_pulse;
     578:	66 0f       	add	r22, r22
     57a:	77 1f       	adc	r23, r23
     57c:	fb 01       	movw	r30, r22
     57e:	ea 5e       	subi	r30, 0xEA	; 234
     580:	f7 4c       	sbci	r31, 0xC7	; 199
     582:	80 83       	st	Z, r24
     584:	91 83       	std	Z+1, r25	; 0x01
			pulses_in_queue++;
     586:	80 91 2a 38 	lds	r24, 0x382A	; 0x80382a <pulses_in_queue>
     58a:	8f 5f       	subi	r24, 0xFF	; 255
     58c:	80 93 2a 38 	sts	0x382A, r24	; 0x80382a <pulses_in_queue>
			// We return so we only ever add one
			break;
     590:	08 95       	ret
     592:	2f 5f       	subi	r18, 0xFF	; 255
     594:	3f 4f       	sbci	r19, 0xFF	; 255
*/
static void tinyAxon_add_pulse(uint16_t new_pulse)
{
	// We want to check each slot in the pulse_queue, and
	// if we find an empty slot (0), we add a pulse.
	for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
     596:	2a 30       	cpi	r18, 0x0A	; 10
     598:	31 05       	cpc	r19, r1
     59a:	31 f7       	brne	.-52     	; 0x568 <tinyAxon_add_pulse+0x14>
     59c:	08 95       	ret

0000059e <tinyAxon_is_firing>:
// DAC has no DAC_0_get_output, so we keep track of this here.
uint8_t axonOutputValue = 0;


_Bool tinyAxon_is_firing(){
	return axonOutputValue != NO_SIGNAL_OUTPUT;
     59e:	81 e0       	ldi	r24, 0x01	; 1
     5a0:	90 91 2b 38 	lds	r25, 0x382B	; 0x80382b <axonOutputValue>
     5a4:	91 11       	cpse	r25, r1
     5a6:	01 c0       	rjmp	.+2      	; 0x5aa <tinyAxon_is_firing+0xc>
     5a8:	80 e0       	ldi	r24, 0x00	; 0
}
     5aa:	08 95       	ret

000005ac <find_newest_pulse>:
uint8_t find_newest_pulse() {
	uint16_t max;
	uint8_t current_index = 0;
	uint8_t return_index = 0;
	
	max = pulse_queue[current_index];
     5ac:	40 91 16 38 	lds	r20, 0x3816	; 0x803816 <__data_end>
     5b0:	50 91 17 38 	lds	r21, 0x3817	; 0x803817 <__data_end+0x1>
     5b4:	e8 e1       	ldi	r30, 0x18	; 24
     5b6:	f8 e3       	ldi	r31, 0x38	; 56
	
// This function will be used with pulse_queue to find the newest pulse
uint8_t find_newest_pulse() {
	uint16_t max;
	uint8_t current_index = 0;
	uint8_t return_index = 0;
     5b8:	80 e0       	ldi	r24, 0x00	; 0
	
	max = pulse_queue[current_index];
	
	for (current_index = 1; current_index < MAX_NUMBER_OF_PULSES; current_index++) {
     5ba:	91 e0       	ldi	r25, 0x01	; 1
		if (pulse_queue[current_index] > max) {
     5bc:	21 91       	ld	r18, Z+
     5be:	31 91       	ld	r19, Z+
     5c0:	42 17       	cp	r20, r18
     5c2:	53 07       	cpc	r21, r19
     5c4:	10 f4       	brcc	.+4      	; 0x5ca <find_newest_pulse+0x1e>
     5c6:	89 2f       	mov	r24, r25
			return_index = current_index;
			max = pulse_queue[current_index];
     5c8:	a9 01       	movw	r20, r18
	uint8_t current_index = 0;
	uint8_t return_index = 0;
	
	max = pulse_queue[current_index];
	
	for (current_index = 1; current_index < MAX_NUMBER_OF_PULSES; current_index++) {
     5ca:	9f 5f       	subi	r25, 0xFF	; 255
     5cc:	9a 30       	cpi	r25, 0x0A	; 10
     5ce:	b1 f7       	brne	.-20     	; 0x5bc <find_newest_pulse+0x10>
			return_index = current_index;
			max = pulse_queue[current_index];
		}
	}
	return return_index;
}
     5d0:	08 95       	ret

000005d2 <tinyAxon_stop_sending_pulse>:
	tinyLED_set_color_mode(OUT_LED, WHITE, FLASH_ONCE);
}

void tinyAxon_stop_sending_pulse()
{
	DAC_0_set_output(NO_SIGNAL_OUTPUT);
     5d2:	80 e0       	ldi	r24, 0x00	; 0
     5d4:	90 e0       	ldi	r25, 0x00	; 0
     5d6:	0e 94 9b 01 	call	0x336	; 0x336 <DAC_0_set_output>
	axonOutputValue=NO_SIGNAL_OUTPUT;
     5da:	10 92 2b 38 	sts	0x382B, r1	; 0x80382b <axonOutputValue>
     5de:	08 95       	ret

000005e0 <tinyAxon_remove_pulse>:

/*
If the potential is very low, we want to try to remove a pulse.
*/
bool tinyAxon_remove_pulse(void)
{
     5e0:	cf 93       	push	r28
	// We want to return a bool indicating whether or not a pulse actually was removed.
	if(pulses_in_queue == 0){
     5e2:	c0 91 2a 38 	lds	r28, 0x382A	; 0x80382a <pulses_in_queue>
     5e6:	cc 23       	and	r28, r28
     5e8:	c9 f0       	breq	.+50     	; 0x61c <tinyAxon_remove_pulse+0x3c>
		//There was no pulse to remove.
		return false;
	}
	else{
		// If we are to remove a pulse, we want to remove the one that will fire last.
		uint8_t pulse_index = find_newest_pulse();
     5ea:	0e 94 d6 02 	call	0x5ac	; 0x5ac <find_newest_pulse>
		uint16_t newest_pulse = pulse_queue[pulse_index];
     5ee:	90 e0       	ldi	r25, 0x00	; 0
     5f0:	fc 01       	movw	r30, r24
     5f2:	ee 0f       	add	r30, r30
     5f4:	ff 1f       	adc	r31, r31
     5f6:	ea 5e       	subi	r30, 0xEA	; 234
     5f8:	f7 4c       	sbci	r31, 0xC7	; 199
	
		// Now we want to check if the pulse is too far away to be affected by the low potential, or close enough that we decide to remove it.
		// (When we say that the pulse is too far away, it refers to the biological process of how the potential spreads from Dendrites to axon).
		if(newest_pulse > PULSE_NO_RETURN_TIME){
     5fa:	20 81       	ld	r18, Z
     5fc:	31 81       	ldd	r19, Z+1	; 0x01
     5fe:	2d 33       	cpi	r18, 0x3D	; 61
     600:	31 05       	cpc	r19, r1
     602:	70 f0       	brcs	.+28     	; 0x620 <tinyAxon_remove_pulse+0x40>
			// We decided to remove the pulse
			pulse_queue[pulse_index] = 0;
     604:	88 0f       	add	r24, r24
     606:	99 1f       	adc	r25, r25
     608:	fc 01       	movw	r30, r24
     60a:	ea 5e       	subi	r30, 0xEA	; 234
     60c:	f7 4c       	sbci	r31, 0xC7	; 199
     60e:	10 82       	st	Z, r1
     610:	11 82       	std	Z+1, r1	; 0x01
			pulses_in_queue--;
     612:	c1 50       	subi	r28, 0x01	; 1
     614:	c0 93 2a 38 	sts	0x382A, r28	; 0x80382a <pulses_in_queue>
			return true;
     618:	81 e0       	ldi	r24, 0x01	; 1
     61a:	03 c0       	rjmp	.+6      	; 0x622 <tinyAxon_remove_pulse+0x42>
bool tinyAxon_remove_pulse(void)
{
	// We want to return a bool indicating whether or not a pulse actually was removed.
	if(pulses_in_queue == 0){
		//There was no pulse to remove.
		return false;
     61c:	80 e0       	ldi	r24, 0x00	; 0
     61e:	01 c0       	rjmp	.+2      	; 0x622 <tinyAxon_remove_pulse+0x42>
			pulses_in_queue--;
			return true;
		}
		// Here we have found that there is a pulse queued, but it is old enough to let pass anyway, so now we need to put it back into the queue.
		else{
			return false;
     620:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     622:	cf 91       	pop	r28
     624:	08 95       	ret

00000626 <tinyAxon_update_potential>:
/*
Decides whether or not the axon should fire
If the axon does fire, the potential is reduced
*/
double tinyAxon_update_potential(double potential)
{	
     626:	cf 92       	push	r12
     628:	df 92       	push	r13
     62a:	ef 92       	push	r14
     62c:	ff 92       	push	r15
     62e:	6b 01       	movw	r12, r22
     630:	7c 01       	movw	r14, r24
	//While the neuron has enough potential to fire, we want to fire more
	while (potential >= THRESHOLD_POTENTIAL)
     632:	20 e0       	ldi	r18, 0x00	; 0
     634:	30 e0       	ldi	r19, 0x00	; 0
     636:	48 ec       	ldi	r20, 0xC8	; 200
     638:	51 e4       	ldi	r21, 0x41	; 65
     63a:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <__gesf2>
     63e:	88 23       	and	r24, r24
     640:	bc f1       	brlt	.+110    	; 0x6b0 <tinyAxon_update_potential+0x8a>
	{
		// We have to check if there are already queued pulses, so that the frequency never exceeds FIRE_DELAY
		if(pulses_in_queue>0){
     642:	80 91 2a 38 	lds	r24, 0x382A	; 0x80382a <pulses_in_queue>
     646:	88 23       	and	r24, r24
     648:	b1 f0       	breq	.+44     	; 0x676 <tinyAxon_update_potential+0x50>
			uint16_t newest_pulse = pulse_queue[find_newest_pulse()];
     64a:	0e 94 d6 02 	call	0x5ac	; 0x5ac <find_newest_pulse>
     64e:	e8 2f       	mov	r30, r24
     650:	f0 e0       	ldi	r31, 0x00	; 0
     652:	ee 0f       	add	r30, r30
     654:	ff 1f       	adc	r31, r31
     656:	ea 5e       	subi	r30, 0xEA	; 234
     658:	f7 4c       	sbci	r31, 0xC7	; 199
			
			// There is at least one pulse in the queue, and it is "so close", that we need to offset the new pulse, so that we keep at least
			// one FIRE_DELAY between each pulse
			if(newest_pulse + FIRE_DELAY > TRAVLE_DELAY){
     65a:	80 81       	ld	r24, Z
     65c:	91 81       	ldd	r25, Z+1	; 0x01
     65e:	0a 96       	adiw	r24, 0x0a	; 10
     660:	85 36       	cpi	r24, 0x65	; 101
     662:	91 05       	cpc	r25, r1
     664:	18 f0       	brcs	.+6      	; 0x66c <tinyAxon_update_potential+0x46>
				tinyAxon_add_pulse(newest_pulse + FIRE_DELAY);
     666:	0e 94 aa 02 	call	0x554	; 0x554 <tinyAxon_add_pulse>
     66a:	09 c0       	rjmp	.+18     	; 0x67e <tinyAxon_update_potential+0x58>
			}
			// There is at least one pulse in the queue, but it's "far enough away" to ignore
			else{
				tinyAxon_add_pulse(TRAVLE_DELAY);
     66c:	84 e6       	ldi	r24, 0x64	; 100
     66e:	90 e0       	ldi	r25, 0x00	; 0
     670:	0e 94 aa 02 	call	0x554	; 0x554 <tinyAxon_add_pulse>
     674:	04 c0       	rjmp	.+8      	; 0x67e <tinyAxon_update_potential+0x58>
			}
		}
		// There are no pulses in the queue, so we add a pulse as normal
		else{
			tinyAxon_add_pulse(TRAVLE_DELAY);		
     676:	84 e6       	ldi	r24, 0x64	; 100
     678:	90 e0       	ldi	r25, 0x00	; 0
     67a:	0e 94 aa 02 	call	0x554	; 0x554 <tinyAxon_add_pulse>
		}
		
		potential += POSTFIRE_POTENTIAL_REACTION; // This is usually defined as a negative value, don't be confused by the +=
     67e:	20 e0       	ldi	r18, 0x00	; 0
     680:	30 e0       	ldi	r19, 0x00	; 0
     682:	48 ec       	ldi	r20, 0xC8	; 200
     684:	51 e4       	ldi	r21, 0x41	; 65
     686:	c7 01       	movw	r24, r14
     688:	b6 01       	movw	r22, r12
     68a:	0e 94 96 0a 	call	0x152c	; 0x152c <__subsf3>
     68e:	6b 01       	movw	r12, r22
     690:	7c 01       	movw	r14, r24
		
		tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
     692:	45 e0       	ldi	r20, 0x05	; 5
     694:	63 e0       	ldi	r22, 0x03	; 3
     696:	80 e0       	ldi	r24, 0x00	; 0
     698:	0e 94 7e 06 	call	0xcfc	; 0xcfc <tinyLED_set_color_mode>
If the axon does fire, the potential is reduced
*/
double tinyAxon_update_potential(double potential)
{	
	//While the neuron has enough potential to fire, we want to fire more
	while (potential >= THRESHOLD_POTENTIAL)
     69c:	20 e0       	ldi	r18, 0x00	; 0
     69e:	30 e0       	ldi	r19, 0x00	; 0
     6a0:	48 ec       	ldi	r20, 0xC8	; 200
     6a2:	51 e4       	ldi	r21, 0x41	; 65
     6a4:	c7 01       	movw	r24, r14
     6a6:	b6 01       	movw	r22, r12
     6a8:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <__gesf2>
     6ac:	88 23       	and	r24, r24
     6ae:	4c f6       	brge	.-110    	; 0x642 <tinyAxon_update_potential+0x1c>
		
		tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
	}
	
	// If the neuron has a very low potential, we want to remove a pulse from the queue (if there is one)
	if(potential < -THRESHOLD_POTENTIAL)
     6b0:	20 e0       	ldi	r18, 0x00	; 0
     6b2:	30 e0       	ldi	r19, 0x00	; 0
     6b4:	48 ec       	ldi	r20, 0xC8	; 200
     6b6:	51 ec       	ldi	r21, 0xC1	; 193
     6b8:	c7 01       	movw	r24, r14
     6ba:	b6 01       	movw	r22, r12
     6bc:	0e 94 03 0b 	call	0x1606	; 0x1606 <__cmpsf2>
     6c0:	88 23       	and	r24, r24
     6c2:	0c f0       	brlt	.+2      	; 0x6c6 <tinyAxon_update_potential+0xa0>
     6c4:	46 c0       	rjmp	.+140    	; 0x752 <tinyAxon_update_potential+0x12c>
	{
		if(pulses_in_queue > 0) // Perhaps this should be a separate variable? For now, we will just simply use -THRESHOLD_POTENTIAL
     6c6:	80 91 2a 38 	lds	r24, 0x382A	; 0x80382a <pulses_in_queue>
     6ca:	88 23       	and	r24, r24
     6cc:	11 f1       	breq	.+68     	; 0x712 <tinyAxon_update_potential+0xec>
		{
			// The neurons potential is low enough to attempt to remove a queued fire (Fire less)
			if(tinyAxon_remove_pulse())
     6ce:	0e 94 f0 02 	call	0x5e0	; 0x5e0 <tinyAxon_remove_pulse>
     6d2:	88 23       	and	r24, r24
     6d4:	f1 f1       	breq	.+124    	; 0x752 <tinyAxon_update_potential+0x12c>
			{
				// The potential has evened out a bit
				potential += THRESHOLD_POTENTIAL;
     6d6:	20 e0       	ldi	r18, 0x00	; 0
     6d8:	30 e0       	ldi	r19, 0x00	; 0
     6da:	48 ec       	ldi	r20, 0xC8	; 200
     6dc:	51 e4       	ldi	r21, 0x41	; 65
     6de:	c7 01       	movw	r24, r14
     6e0:	b6 01       	movw	r22, r12
     6e2:	0e 94 97 0a 	call	0x152e	; 0x152e <__addsf3>
     6e6:	6b 01       	movw	r12, r22
     6e8:	7c 01       	movw	r14, r24
     6ea:	33 c0       	rjmp	.+102    	; 0x752 <tinyAxon_update_potential+0x12c>
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
	{
		for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
		{
			if(pulse_queue[i] != 0){
     6ec:	80 81       	ld	r24, Z
     6ee:	91 81       	ldd	r25, Z+1	; 0x01
     6f0:	00 97       	sbiw	r24, 0x00	; 0
     6f2:	39 f0       	breq	.+14     	; 0x702 <tinyAxon_update_potential+0xdc>
				pulse_queue[i]--;
     6f4:	01 97       	sbiw	r24, 0x01	; 1
     6f6:	80 83       	st	Z, r24
     6f8:	91 83       	std	Z+1, r25	; 0x01
				
				// If the time went from 1 to 0, we fire the axon
				if(pulse_queue[i] == 0){
     6fa:	89 2b       	or	r24, r25
     6fc:	11 f4       	brne	.+4      	; 0x702 <tinyAxon_update_potential+0xdc>
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
	pulses_in_queue--;
     6fe:	41 50       	subi	r20, 0x01	; 1
Function to set firing.
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
     700:	51 e0       	ldi	r21, 0x01	; 1
     702:	32 96       	adiw	r30, 0x02	; 2
	}
	
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
	{
		for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
     704:	e2 17       	cp	r30, r18
     706:	f3 07       	cpc	r31, r19
     708:	89 f7       	brne	.-30     	; 0x6ec <tinyAxon_update_potential+0xc6>
     70a:	50 93 2c 38 	sts	0x382C, r21	; 0x80382c <tinyAxon_should_fire>
     70e:	40 93 2a 38 	sts	0x382A, r20	; 0x80382a <pulses_in_queue>
The function should set the DAC to fire for two
update cycles once the pulse flag is set high.
*/
static void tinyAxon_update_pulse_transmitter(void)
{
	if (tinyAxon_should_fire)
     712:	80 91 2c 38 	lds	r24, 0x382C	; 0x80382c <tinyAxon_should_fire>
     716:	88 23       	and	r24, r24
     718:	91 f0       	breq	.+36     	; 0x73e <tinyAxon_update_potential+0x118>
	{
		tinyAxon_should_fire = false;
     71a:	10 92 2c 38 	sts	0x382C, r1	; 0x80382c <tinyAxon_should_fire>
*/
static void tinyAxon_start_sending_pulse()
{
	if (NEURONTYPE == EXCITATORY_NEURON)
	{
		DAC_0_set_output(EXCITATORY_NEURON_OUTPUT);
     71e:	80 e8       	ldi	r24, 0x80	; 128
     720:	90 e0       	ldi	r25, 0x00	; 0
     722:	0e 94 9b 01 	call	0x336	; 0x336 <DAC_0_set_output>
		axonOutputValue=EXCITATORY_NEURON_OUTPUT;
     726:	80 e8       	ldi	r24, 0x80	; 128
     728:	80 93 2b 38 	sts	0x382B, r24	; 0x80382b <axonOutputValue>
	{
		DAC_0_set_output(INHIBITORY_NEURON_OUTPUT);
		axonOutputValue=INHIBITORY_NEURON_OUTPUT;
	}
	
	tinyLED_set_color_mode(OUT_LED, WHITE, FLASH_ONCE);
     72c:	45 e0       	ldi	r20, 0x05	; 5
     72e:	65 e0       	ldi	r22, 0x05	; 5
     730:	81 e0       	ldi	r24, 0x01	; 1
     732:	0e 94 7e 06 	call	0xcfc	; 0xcfc <tinyLED_set_color_mode>
{
	if (tinyAxon_should_fire)
	{
		tinyAxon_should_fire = false;
		tinyAxon_start_sending_pulse();
		tinyAxon_has_just_fired = true;
     736:	81 e0       	ldi	r24, 0x01	; 1
     738:	80 93 2d 38 	sts	0x382D, r24	; 0x80382d <tinyAxon_has_just_fired>
     73c:	15 c0       	rjmp	.+42     	; 0x768 <tinyAxon_update_potential+0x142>
		
	}
	else if (tinyAxon_has_just_fired)
     73e:	80 91 2d 38 	lds	r24, 0x382D	; 0x80382d <tinyAxon_has_just_fired>
     742:	88 23       	and	r24, r24
     744:	19 f0       	breq	.+6      	; 0x74c <tinyAxon_update_potential+0x126>
	{
		tinyAxon_has_just_fired = false;
     746:	10 92 2d 38 	sts	0x382D, r1	; 0x80382d <tinyAxon_has_just_fired>
     74a:	0e c0       	rjmp	.+28     	; 0x768 <tinyAxon_update_potential+0x142>
	}
	else if (!tinyAxon_has_just_fired && !tinyAxon_should_fire)
	{
		tinyAxon_stop_sending_pulse();
     74c:	0e 94 e9 02 	call	0x5d2	; 0x5d2 <tinyAxon_stop_sending_pulse>
     750:	0b c0       	rjmp	.+22     	; 0x768 <tinyAxon_update_potential+0x142>
			}
		}
	}
	
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
     752:	40 91 2a 38 	lds	r20, 0x382A	; 0x80382a <pulses_in_queue>
     756:	44 23       	and	r20, r20
     758:	e1 f2       	breq	.-72     	; 0x712 <tinyAxon_update_potential+0xec>
     75a:	50 91 2c 38 	lds	r21, 0x382C	; 0x80382c <tinyAxon_should_fire>
     75e:	e6 e1       	ldi	r30, 0x16	; 22
     760:	f8 e3       	ldi	r31, 0x38	; 56
     762:	2a e2       	ldi	r18, 0x2A	; 42
     764:	38 e3       	ldi	r19, 0x38	; 56
     766:	c2 cf       	rjmp	.-124    	; 0x6ec <tinyAxon_update_potential+0xc6>
	}
	
	// Here we set the actual output of the DAC (Digital to Analog Converter)
	tinyAxon_update_pulse_transmitter();
	
	tinyDebugger_send_uint8("Axon", axonOutputValue);
     768:	60 91 2b 38 	lds	r22, 0x382B	; 0x80382b <axonOutputValue>
     76c:	83 e6       	ldi	r24, 0x63	; 99
     76e:	97 ea       	ldi	r25, 0xA7	; 167
     770:	0e 94 c2 04 	call	0x984	; 0x984 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("Pulses", pulses_in_queue);
     774:	60 91 2a 38 	lds	r22, 0x382A	; 0x80382a <pulses_in_queue>
     778:	88 e6       	ldi	r24, 0x68	; 104
     77a:	97 ea       	ldi	r25, 0xA7	; 167
     77c:	0e 94 c2 04 	call	0x984	; 0x984 <tinyDebugger_send_uint8>
	
	
	return potential;
}
     780:	c7 01       	movw	r24, r14
     782:	b6 01       	movw	r22, r12
     784:	ff 90       	pop	r15
     786:	ef 90       	pop	r14
     788:	df 90       	pop	r13
     78a:	cf 90       	pop	r12
     78c:	08 95       	ret

0000078e <tinyAxon_check_charge_level>:
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTB_get_pin_level(const uint8_t pin)
{
	return VPORTB.IN & (1 << pin);
     78e:	66 b1       	in	r22, 0x06	; 6

_Bool tinyAxon_check_charge_level(void)
{
	// We check the AXON_CHECK_PIN. If it is hight while the axon is not firing, it must be connected to a charger
	
	tinyDebugger_send_uint8("Pulses", AXON_CHECK_PIN_get_level());
     790:	66 1f       	adc	r22, r22
     792:	66 27       	eor	r22, r22
     794:	66 1f       	adc	r22, r22
     796:	88 e6       	ldi	r24, 0x68	; 104
     798:	97 ea       	ldi	r25, 0xA7	; 167
     79a:	0e 94 c2 04 	call	0x984	; 0x984 <tinyDebugger_send_uint8>
	return (AXON_CHECK_PIN_get_level() && !tinyAxon_has_just_fired);
     79e:	37 9b       	sbis	0x06, 7	; 6
     7a0:	05 c0       	rjmp	.+10     	; 0x7ac <tinyAxon_check_charge_level+0x1e>
     7a2:	90 91 2d 38 	lds	r25, 0x382D	; 0x80382d <tinyAxon_has_just_fired>
     7a6:	81 e0       	ldi	r24, 0x01	; 1
     7a8:	89 27       	eor	r24, r25
     7aa:	02 c0       	rjmp	.+4      	; 0x7b0 <tinyAxon_check_charge_level+0x22>
     7ac:	80 e0       	ldi	r24, 0x00	; 0
     7ae:	90 e0       	ldi	r25, 0x00	; 0
     7b0:	81 70       	andi	r24, 0x01	; 1
     7b2:	08 95       	ret

000007b4 <tinyButton_update>:
/*
If the button has been let go, we change button_press to true. This only lasts one cycle, before it is set to false again.
If the button is held down for longer than PULSEMODE_BUTTON_PRESS_TIME, we toggle the pulse mode state.
*/
void tinyButton_update(void)
{
     7b4:	0f 93       	push	r16
     7b6:	1f 93       	push	r17
     7b8:	cf 93       	push	r28
     7ba:	df 93       	push	r29
	button_press = false;
     7bc:	10 92 33 38 	sts	0x3833, r1	; 0x803833 <button_press>
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTC_get_pin_level(const uint8_t pin)
{
	return VPORTC.IN & (1 << pin);
     7c0:	8a b1       	in	r24, 0x0a	; 10
	_Bool button_is_pushed_down = !BUTTON_PIN_get_level(); // The digital port will be read as low if the button is pushed down.
     7c2:	d1 e0       	ldi	r29, 0x01	; 1
     7c4:	c8 2f       	mov	r28, r24
     7c6:	c4 70       	andi	r28, 0x04	; 4
     7c8:	82 fd       	sbrc	r24, 2
     7ca:	d0 e0       	ldi	r29, 0x00	; 0

	if (button_is_pushed_down && !button_was_pushed_down)
     7cc:	c1 11       	cpse	r28, r1
     7ce:	39 c0       	rjmp	.+114    	; 0x842 <tinyButton_update+0x8e>
     7d0:	80 91 34 38 	lds	r24, 0x3834	; 0x803834 <button_was_pushed_down>
     7d4:	81 11       	cpse	r24, r1
     7d6:	0e c0       	rjmp	.+28     	; 0x7f4 <tinyButton_update+0x40>
	{
		tinyButton_start_time = tinyTime_now();
     7d8:	0e 94 8d 0a 	call	0x151a	; 0x151a <tinyTime_now>
     7dc:	60 93 2e 38 	sts	0x382E, r22	; 0x80382e <tinyButton_start_time>
     7e0:	70 93 2f 38 	sts	0x382F, r23	; 0x80382f <tinyButton_start_time+0x1>
     7e4:	80 93 30 38 	sts	0x3830, r24	; 0x803830 <tinyButton_start_time+0x2>
     7e8:	90 93 31 38 	sts	0x3831, r25	; 0x803831 <tinyButton_start_time+0x3>
	}
	if (button_is_pushed_down && button_was_pushed_down)
     7ec:	80 91 34 38 	lds	r24, 0x3834	; 0x803834 <button_was_pushed_down>
     7f0:	88 23       	and	r24, r24
     7f2:	b9 f1       	breq	.+110    	; 0x862 <tinyButton_update+0xae>
	{
		if ((tinyTime_now() - tinyButton_start_time) > PULSEMODE_BUTTON_PRESS_TIME)
     7f4:	0e 94 8d 0a 	call	0x151a	; 0x151a <tinyTime_now>
     7f8:	00 91 2e 38 	lds	r16, 0x382E	; 0x80382e <tinyButton_start_time>
     7fc:	10 91 2f 38 	lds	r17, 0x382F	; 0x80382f <tinyButton_start_time+0x1>
     800:	20 91 30 38 	lds	r18, 0x3830	; 0x803830 <tinyButton_start_time+0x2>
     804:	30 91 31 38 	lds	r19, 0x3831	; 0x803831 <tinyButton_start_time+0x3>
     808:	60 1b       	sub	r22, r16
     80a:	71 0b       	sbc	r23, r17
     80c:	82 0b       	sbc	r24, r18
     80e:	93 0b       	sbc	r25, r19
     810:	0e 94 e3 0b 	call	0x17c6	; 0x17c6 <__floatunsisf>
     814:	20 e0       	ldi	r18, 0x00	; 0
     816:	30 e0       	ldi	r19, 0x00	; 0
     818:	48 ec       	ldi	r20, 0xC8	; 200
     81a:	52 e4       	ldi	r21, 0x42	; 66
     81c:	0e 94 db 0c 	call	0x19b6	; 0x19b6 <__gesf2>
     820:	18 16       	cp	r1, r24
     822:	7c f4       	brge	.+30     	; 0x842 <tinyButton_update+0x8e>
		{
			tinyPulse_toggle_pulse_mode();
     824:	0e 94 76 09 	call	0x12ec	; 0x12ec <tinyPulse_toggle_pulse_mode>
			tinyButton_start_time = tinyTime_now();
     828:	0e 94 8d 0a 	call	0x151a	; 0x151a <tinyTime_now>
     82c:	60 93 2e 38 	sts	0x382E, r22	; 0x80382e <tinyButton_start_time>
     830:	70 93 2f 38 	sts	0x382F, r23	; 0x80382f <tinyButton_start_time+0x1>
     834:	80 93 30 38 	sts	0x3830, r24	; 0x803830 <tinyButton_start_time+0x2>
     838:	90 93 31 38 	sts	0x3831, r25	; 0x803831 <tinyButton_start_time+0x3>
			// We don't want switching to pulse mode to count as a button press, so we ignore the next button press
			ignore_next_button_press = true;
     83c:	81 e0       	ldi	r24, 0x01	; 1
     83e:	80 93 32 38 	sts	0x3832, r24	; 0x803832 <ignore_next_button_press>
		}
	}
	if (!button_is_pushed_down && button_was_pushed_down)
     842:	cc 23       	and	r28, r28
     844:	71 f0       	breq	.+28     	; 0x862 <tinyButton_update+0xae>
     846:	80 91 34 38 	lds	r24, 0x3834	; 0x803834 <button_was_pushed_down>
     84a:	88 23       	and	r24, r24
     84c:	51 f0       	breq	.+20     	; 0x862 <tinyButton_update+0xae>
	{
		if(!ignore_next_button_press){
     84e:	80 91 32 38 	lds	r24, 0x3832	; 0x803832 <ignore_next_button_press>
     852:	81 11       	cpse	r24, r1
     854:	04 c0       	rjmp	.+8      	; 0x85e <tinyButton_update+0xaa>
			button_press = true;
     856:	81 e0       	ldi	r24, 0x01	; 1
     858:	80 93 33 38 	sts	0x3833, r24	; 0x803833 <button_press>
     85c:	02 c0       	rjmp	.+4      	; 0x862 <tinyButton_update+0xae>
		}
		else{
			ignore_next_button_press = false;
     85e:	10 92 32 38 	sts	0x3832, r1	; 0x803832 <ignore_next_button_press>
		}
		
	}
	button_was_pushed_down = button_is_pushed_down;
     862:	d0 93 34 38 	sts	0x3834, r29	; 0x803834 <button_was_pushed_down>
}
     866:	df 91       	pop	r29
     868:	cf 91       	pop	r28
     86a:	1f 91       	pop	r17
     86c:	0f 91       	pop	r16
     86e:	08 95       	ret

00000870 <tinyButton_update_potential>:

double tinyButton_update_potential(double potential){
	if(button_press){
     870:	20 91 33 38 	lds	r18, 0x3833	; 0x803833 <button_press>
     874:	22 23       	and	r18, r18
     876:	31 f0       	breq	.+12     	; 0x884 <tinyButton_update_potential+0x14>
		potential += BUTTON_PRESS_REACTION;
     878:	20 e0       	ldi	r18, 0x00	; 0
     87a:	30 e0       	ldi	r19, 0x00	; 0
     87c:	40 ed       	ldi	r20, 0xD0	; 208
     87e:	51 e4       	ldi	r21, 0x41	; 65
     880:	0e 94 97 0a 	call	0x152e	; 0x152e <__addsf3>
	}
	return potential;
}
     884:	08 95       	ret

00000886 <tinyCharge_is_connected_to_charger>:
*/
uint8_t charge_counter = 0; 

_Bool tinyCharge_is_connected_to_charger(){
	return connected_to_charger;
}
     886:	80 91 59 38 	lds	r24, 0x3859	; 0x803859 <connected_to_charger>
     88a:	08 95       	ret

0000088c <tinyCharge_is_fully_charged>:
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTB_get_pin_level(const uint8_t pin)
{
	return VPORTB.IN & (1 << pin);
     88c:	86 b1       	in	r24, 0x06	; 6

_Bool tinyCharge_is_fully_charged(){
	return CHARGING_STATUS_PIN_get_level();
}
     88e:	86 fb       	bst	r24, 6
     890:	88 27       	eor	r24, r24
     892:	80 f9       	bld	r24, 0
     894:	08 95       	ret

00000896 <tinyCharge_DAC_dissable>:
void tinyCharge_DAC_dissable(){
	
	// We need some way to disable the DAC to prevent huge current draw when charging (64mA). When there is no code uploaded to the attiny, there is no problem.
	// We're going to try to enable the pin as a dendrite, since they seem to be doing fine. Completely uninitializing the pin probably caused a microchip to be fried.
	
	DAC_0_uninit();
     896:	0e 94 8a 01 	call	0x314	; 0x314 <DAC_0_uninit>
	DAC_0_disable();
     89a:	0e 94 95 01 	call	0x32a	; 0x32a <DAC_0_disable>
     89e:	08 95       	ret

000008a0 <tinyCharge_DAC_enable>:
void tinyCharge_DAC_enable(){
	
	// We need some way to disable the DAC to prevent huge current draw when charging (64mA). When there is no code uploaded to the attiny, there is no problem.
	// We're going to try to enable the pin as a dendrite, since they seem to be doing fine. Completely uninitializing the pin probably caused a microchip to be fried.
	
	DAC_0_init();
     8a0:	0e 94 85 01 	call	0x30a	; 0x30a <DAC_0_init>
	DAC_0_enable();
     8a4:	0e 94 8f 01 	call	0x31e	; 0x31e <DAC_0_enable>
     8a8:	08 95       	ret

000008aa <tinyCharge_switch_mode>:
}


void tinyCharge_switch_mode(){
	
	if(connected_to_charger){
     8aa:	80 91 59 38 	lds	r24, 0x3859	; 0x803859 <connected_to_charger>
     8ae:	88 23       	and	r24, r24
     8b0:	89 f0       	breq	.+34     	; 0x8d4 <tinyCharge_switch_mode+0x2a>
		// Switch from main to charging mode
		
		// Set LED
		tinyLED_set_color_mode(OUT_LED, CHARGING_COLOR, SWING);
     8b2:	43 e0       	ldi	r20, 0x03	; 3
     8b4:	61 e0       	ldi	r22, 0x01	; 1
     8b6:	81 e0       	ldi	r24, 0x01	; 1
     8b8:	0e 94 7e 06 	call	0xcfc	; 0xcfc <tinyLED_set_color_mode>
		tinyLED_set_color(INN_LED, LED_OFF);
     8bc:	60 e0       	ldi	r22, 0x00	; 0
     8be:	80 e0       	ldi	r24, 0x00	; 0
     8c0:	0e 94 a2 06 	call	0xd44	; 0xd44 <tinyLED_set_color>


		// Stop axon from firing
		// (There is a small chance that the neuron is put into charging mode as it is firing. The axon is then never told to stop firing)
		tinyAxon_stop_sending_pulse();
     8c4:	0e 94 e9 02 	call	0x5d2	; 0x5d2 <tinyAxon_stop_sending_pulse>

		// disable DAC
		tinyCharge_DAC_dissable();
     8c8:	0e 94 4b 04 	call	0x896	; 0x896 <tinyCharge_DAC_dissable>
		
		// We also turn off pulse mode, because it's confusing if it suddenly comes on
		// after it has been charging
		tinyPulse_set_pulse_mode(false);
     8cc:	80 e0       	ldi	r24, 0x00	; 0
     8ce:	0e 94 92 09 	call	0x1324	; 0x1324 <tinyPulse_set_pulse_mode>
     8d2:	08 95       	ret
	}
	else{
		// Switch from charge to main mode
		
		// Set LED
		tinyLED_set_color(OUT_LED, LED_OFF);
     8d4:	60 e0       	ldi	r22, 0x00	; 0
     8d6:	81 e0       	ldi	r24, 0x01	; 1
     8d8:	0e 94 a2 06 	call	0xd44	; 0xd44 <tinyLED_set_color>
		tinyLED_set_color(INN_LED, LED_OFF);
     8dc:	60 e0       	ldi	r22, 0x00	; 0
     8de:	80 e0       	ldi	r24, 0x00	; 0
     8e0:	0e 94 a2 06 	call	0xd44	; 0xd44 <tinyLED_set_color>
		
		// enable DAC
		tinyCharge_DAC_enable();
     8e4:	0e 94 50 04 	call	0x8a0	; 0x8a0 <tinyCharge_DAC_enable>
     8e8:	08 95       	ret

000008ea <tinyCharge_set_charging_mode>:
	}
}

void tinyCharge_set_charging_mode(_Bool charging_status){
	if(charging_status != connected_to_charger){
     8ea:	90 91 59 38 	lds	r25, 0x3859	; 0x803859 <connected_to_charger>
     8ee:	98 17       	cp	r25, r24
     8f0:	21 f0       	breq	.+8      	; 0x8fa <tinyCharge_set_charging_mode+0x10>
		connected_to_charger = charging_status;
     8f2:	80 93 59 38 	sts	0x3859, r24	; 0x803859 <connected_to_charger>
		tinyCharge_switch_mode();
     8f6:	0e 94 55 04 	call	0x8aa	; 0x8aa <tinyCharge_switch_mode>
     8fa:	08 95       	ret

000008fc <tinyCharge_update_charging_mode>:
*/
void tinyCharge_update_charging_mode(){
	// For complicated reasons, the axon_check_level will be high even when the charger is not connected
	// WHEN the neuron is in charging mode, hence we ignore the axon level when the neuron is in charging mode
	_Bool charging;
	if(connected_to_charger){
     8fc:	80 91 59 38 	lds	r24, 0x3859	; 0x803859 <connected_to_charger>
     900:	88 23       	and	r24, r24
     902:	19 f0       	breq	.+6      	; 0x90a <tinyCharge_update_charging_mode+0xe>
		charging = tinyDendrite_check_charge_level();
     904:	0e 94 34 05 	call	0xa68	; 0xa68 <tinyDendrite_check_charge_level>
     908:	0a c0       	rjmp	.+20     	; 0x91e <tinyCharge_update_charging_mode+0x22>
	} else{
		charging = tinyDendrite_check_charge_level() || tinyAxon_check_charge_level();
     90a:	0e 94 34 05 	call	0xa68	; 0xa68 <tinyDendrite_check_charge_level>
     90e:	81 11       	cpse	r24, r1
     910:	03 c0       	rjmp	.+6      	; 0x918 <tinyCharge_update_charging_mode+0x1c>
     912:	0e 94 c7 03 	call	0x78e	; 0x78e <tinyAxon_check_charge_level>
     916:	02 c0       	rjmp	.+4      	; 0x91c <tinyCharge_update_charging_mode+0x20>
     918:	81 e0       	ldi	r24, 0x01	; 1
     91a:	90 e0       	ldi	r25, 0x00	; 0
     91c:	81 70       	andi	r24, 0x01	; 1
	}
	
	// In order to prevent the axon from stimulating itself, we only switch into charging mode when the conditions have been right for several cycles
	if(!connected_to_charger && charging){
     91e:	90 91 59 38 	lds	r25, 0x3859	; 0x803859 <connected_to_charger>
     922:	91 11       	cpse	r25, r1
     924:	10 c0       	rjmp	.+32     	; 0x946 <tinyCharge_update_charging_mode+0x4a>
     926:	88 23       	and	r24, r24
     928:	71 f0       	breq	.+28     	; 0x946 <tinyCharge_update_charging_mode+0x4a>
		charge_counter++;
     92a:	80 91 35 38 	lds	r24, 0x3835	; 0x803835 <charge_counter>
     92e:	8f 5f       	subi	r24, 0xFF	; 255
		if(charge_counter > CYCLES_REQUIRED_FOR_CHARGING_MODE_SWITCH){
     930:	8b 30       	cpi	r24, 0x0B	; 11
     932:	18 f4       	brcc	.+6      	; 0x93a <tinyCharge_update_charging_mode+0x3e>
		charging = tinyDendrite_check_charge_level() || tinyAxon_check_charge_level();
	}
	
	// In order to prevent the axon from stimulating itself, we only switch into charging mode when the conditions have been right for several cycles
	if(!connected_to_charger && charging){
		charge_counter++;
     934:	80 93 35 38 	sts	0x3835, r24	; 0x803835 <charge_counter>
     938:	08 95       	ret
		if(charge_counter > CYCLES_REQUIRED_FOR_CHARGING_MODE_SWITCH){
			charge_counter = 0;
     93a:	10 92 35 38 	sts	0x3835, r1	; 0x803835 <charge_counter>
			tinyCharge_set_charging_mode(charging);
     93e:	81 e0       	ldi	r24, 0x01	; 1
     940:	0e 94 75 04 	call	0x8ea	; 0x8ea <tinyCharge_set_charging_mode>
     944:	08 95       	ret
		}
	}
	else{
		tinyCharge_set_charging_mode(charging);
     946:	0e 94 75 04 	call	0x8ea	; 0x8ea <tinyCharge_set_charging_mode>
     94a:	08 95       	ret

0000094c <tinyCharge_set_transistors>:
}



void tinyCharge_set_transistors(){
	if(connected_to_charger){
     94c:	80 91 59 38 	lds	r24, 0x3859	; 0x803859 <connected_to_charger>
     950:	88 23       	and	r24, r24
     952:	19 f0       	breq	.+6      	; 0x95a <tinyCharge_set_transistors+0xe>
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
	} else {
		VPORTC.OUT &= ~(1 << pin);
     954:	4d 98       	cbi	0x09, 5	; 9
 *                  false = Pin level set to "low" state
 */
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
     956:	29 9a       	sbi	0x05, 1	; 5
     958:	08 95       	ret
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     95a:	4d 9a       	sbi	0x09, 5	; 9
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     95c:	29 98       	cbi	0x05, 1	; 5
     95e:	08 95       	ret

00000960 <tinyDebugger_send_uint32>:
}
void tinyDebugger_send_string(const char* name, char * value){
	if(DEBUGGING){
		printf("%s:%s\t", name, value);
	}
}
     960:	7f 93       	push	r23
     962:	6f 93       	push	r22
     964:	5f 93       	push	r21
     966:	4f 93       	push	r20
     968:	9f 93       	push	r25
     96a:	8f 93       	push	r24
     96c:	87 e7       	ldi	r24, 0x77	; 119
     96e:	97 ea       	ldi	r25, 0xA7	; 167
     970:	9f 93       	push	r25
     972:	8f 93       	push	r24
     974:	0e 94 6e 0e 	call	0x1cdc	; 0x1cdc <printf>
     978:	8d b7       	in	r24, 0x3d	; 61
     97a:	9e b7       	in	r25, 0x3e	; 62
     97c:	08 96       	adiw	r24, 0x08	; 8
     97e:	8d bf       	out	0x3d, r24	; 61
     980:	9e bf       	out	0x3e, r25	; 62
     982:	08 95       	ret

00000984 <tinyDebugger_send_uint8>:
     984:	1f 92       	push	r1
     986:	6f 93       	push	r22
     988:	9f 93       	push	r25
     98a:	8f 93       	push	r24
     98c:	80 e8       	ldi	r24, 0x80	; 128
     98e:	97 ea       	ldi	r25, 0xA7	; 167
     990:	9f 93       	push	r25
     992:	8f 93       	push	r24
     994:	0e 94 6e 0e 	call	0x1cdc	; 0x1cdc <printf>
     998:	0f 90       	pop	r0
     99a:	0f 90       	pop	r0
     99c:	0f 90       	pop	r0
     99e:	0f 90       	pop	r0
     9a0:	0f 90       	pop	r0
     9a2:	0f 90       	pop	r0
     9a4:	08 95       	ret

000009a6 <tinyDebugger_send_double>:
     9a6:	cf 92       	push	r12
     9a8:	df 92       	push	r13
     9aa:	ef 92       	push	r14
     9ac:	ff 92       	push	r15
     9ae:	0f 93       	push	r16
     9b0:	1f 93       	push	r17
     9b2:	cf 93       	push	r28
     9b4:	df 93       	push	r29
     9b6:	cd b7       	in	r28, 0x3d	; 61
     9b8:	de b7       	in	r29, 0x3e	; 62
     9ba:	64 97       	sbiw	r28, 0x14	; 20
     9bc:	cd bf       	out	0x3d, r28	; 61
     9be:	de bf       	out	0x3e, r29	; 62
     9c0:	d8 2e       	mov	r13, r24
     9c2:	c9 2e       	mov	r12, r25
     9c4:	cb 01       	movw	r24, r22
     9c6:	ba 01       	movw	r22, r20
     9c8:	9e 01       	movw	r18, r28
     9ca:	2f 5f       	subi	r18, 0xFF	; 255
     9cc:	3f 4f       	sbci	r19, 0xFF	; 255
     9ce:	79 01       	movw	r14, r18
     9d0:	89 01       	movw	r16, r18
     9d2:	21 e0       	ldi	r18, 0x01	; 1
     9d4:	41 e0       	ldi	r20, 0x01	; 1
     9d6:	0e 94 4e 0e 	call	0x1c9c	; 0x1c9c <dtostrf>
     9da:	ff 92       	push	r15
     9dc:	ef 92       	push	r14
     9de:	cf 92       	push	r12
     9e0:	df 92       	push	r13
     9e2:	88 e8       	ldi	r24, 0x88	; 136
     9e4:	97 ea       	ldi	r25, 0xA7	; 167
     9e6:	9f 93       	push	r25
     9e8:	8f 93       	push	r24
     9ea:	0e 94 6e 0e 	call	0x1cdc	; 0x1cdc <printf>
     9ee:	0f 90       	pop	r0
     9f0:	0f 90       	pop	r0
     9f2:	0f 90       	pop	r0
     9f4:	0f 90       	pop	r0
     9f6:	0f 90       	pop	r0
     9f8:	0f 90       	pop	r0
     9fa:	64 96       	adiw	r28, 0x14	; 20
     9fc:	cd bf       	out	0x3d, r28	; 61
     9fe:	de bf       	out	0x3e, r29	; 62
     a00:	df 91       	pop	r29
     a02:	cf 91       	pop	r28
     a04:	1f 91       	pop	r17
     a06:	0f 91       	pop	r16
     a08:	ff 90       	pop	r15
     a0a:	ef 90       	pop	r14
     a0c:	df 90       	pop	r13
     a0e:	cf 90       	pop	r12
     a10:	08 95       	ret

00000a12 <tinyDebugger_end_line>:
void tinyDebugger_end_line(){
	if(DEBUGGING){
		printf("\r\n");
     a12:	85 e4       	ldi	r24, 0x45	; 69
     a14:	98 ea       	ldi	r25, 0xA8	; 168
     a16:	0e 94 84 0e 	call	0x1d08	; 0x1d08 <puts>
     a1a:	08 95       	ret

00000a1c <tinyDendrite_read_signals>:

/*
This function reads the voltage at the Dendrite inputs with the ADC
*/
void tinyDendrite_read_signals(void)
{
     a1c:	ef 92       	push	r14
     a1e:	ff 92       	push	r15
     a20:	0f 93       	push	r16
     a22:	1f 93       	push	r17
     a24:	cf 93       	push	r28
     a26:	df 93       	push	r29
     a28:	ce e0       	ldi	r28, 0x0E	; 14
     a2a:	d8 e3       	ldi	r29, 0x38	; 56
     a2c:	00 e4       	ldi	r16, 0x40	; 64
     a2e:	18 e3       	ldi	r17, 0x38	; 56
     a30:	0f 2e       	mov	r0, r31
     a32:	f3 e1       	ldi	r31, 0x13	; 19
     a34:	ef 2e       	mov	r14, r31
     a36:	f8 e3       	ldi	r31, 0x38	; 56
     a38:	ff 2e       	mov	r15, r31
     a3a:	f0 2d       	mov	r31, r0
	for (int i = 0; i < DENDRITE_COUNT; i++)
	{
		tinyDendrite_values[i] = ADC_0_get_conversion(Dendrite_ports[i]);
     a3c:	89 91       	ld	r24, Y+
     a3e:	0e 94 4f 01 	call	0x29e	; 0x29e <ADC_0_get_conversion>
     a42:	f8 01       	movw	r30, r16
     a44:	81 93       	st	Z+, r24
     a46:	8f 01       	movw	r16, r30
/*
This function reads the voltage at the Dendrite inputs with the ADC
*/
void tinyDendrite_read_signals(void)
{
	for (int i = 0; i < DENDRITE_COUNT; i++)
     a48:	ce 15       	cp	r28, r14
     a4a:	df 05       	cpc	r29, r15
     a4c:	b9 f7       	brne	.-18     	; 0xa3c <tinyDendrite_read_signals+0x20>
	{
		tinyDendrite_values[i] = ADC_0_get_conversion(Dendrite_ports[i]);
	}
}
     a4e:	df 91       	pop	r29
     a50:	cf 91       	pop	r28
     a52:	1f 91       	pop	r17
     a54:	0f 91       	pop	r16
     a56:	ff 90       	pop	r15
     a58:	ef 90       	pop	r14
     a5a:	08 95       	ret

00000a5c <tinyDendrite_get_value>:

uint8_t tinyDendrite_get_value(uint8_t dendrite_number){
	return tinyDendrite_values[dendrite_number];
     a5c:	e8 2f       	mov	r30, r24
     a5e:	f0 e0       	ldi	r31, 0x00	; 0
     a60:	e0 5c       	subi	r30, 0xC0	; 192
     a62:	f7 4c       	sbci	r31, 0xC7	; 199
}
     a64:	80 81       	ld	r24, Z
     a66:	08 95       	ret

00000a68 <tinyDendrite_check_charge_level>:

_Bool tinyDendrite_check_charge_level(void)
{
     a68:	cf 93       	push	r28
     a6a:	df 93       	push	r29
	_Bool charging = false;
	
	tinyDendrite_read_signals();
     a6c:	0e 94 0e 05 	call	0xa1c	; 0xa1c <tinyDendrite_read_signals>
     a70:	eb e3       	ldi	r30, 0x3B	; 59
     a72:	f8 e3       	ldi	r31, 0x38	; 56
     a74:	c6 e3       	ldi	r28, 0x36	; 54
     a76:	d8 e3       	ldi	r29, 0x38	; 56
     a78:	a0 e4       	ldi	r26, 0x40	; 64
     a7a:	b8 e3       	ldi	r27, 0x38	; 56
     a7c:	20 e4       	ldi	r18, 0x40	; 64
     a7e:	38 e3       	ldi	r19, 0x38	; 56
	return tinyDendrite_values[dendrite_number];
}

_Bool tinyDendrite_check_charge_level(void)
{
	_Bool charging = false;
     a80:	80 e0       	ldi	r24, 0x00	; 0
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = CHARGING;
     a82:	47 e0       	ldi	r20, 0x07	; 7
	_Bool charging = false;
	
	tinyDendrite_read_signals();
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
     a84:	90 81       	ld	r25, Z
     a86:	99 93       	st	Y+, r25
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
     a88:	9d 91       	ld	r25, X+
     a8a:	99 3e       	cpi	r25, 0xE9	; 233
     a8c:	10 f0       	brcs	.+4      	; 0xa92 <tinyDendrite_check_charge_level+0x2a>
		{
			tinyDendrite_current_signals[i] = CHARGING;
     a8e:	40 83       	st	Z, r20
			charging = true;
     a90:	81 e0       	ldi	r24, 0x01	; 1
     a92:	31 96       	adiw	r30, 0x01	; 1
_Bool tinyDendrite_check_charge_level(void)
{
	_Bool charging = false;
	
	tinyDendrite_read_signals();
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
     a94:	e2 17       	cp	r30, r18
     a96:	f3 07       	cpc	r31, r19
     a98:	a9 f7       	brne	.-22     	; 0xa84 <tinyDendrite_check_charge_level+0x1c>
			tinyDendrite_current_signals[i] = CHARGING;
			charging = true;
		}
	}
	return charging;
}
     a9a:	df 91       	pop	r29
     a9c:	cf 91       	pop	r28
     a9e:	08 95       	ret

00000aa0 <tinyDendrite_update_signals>:

/*
This function converts the 8 bit value from the ADC into one of the signal types defined in DendriteSignal
*/
void tinyDendrite_update_signals(void)
{
     aa0:	af 92       	push	r10
     aa2:	bf 92       	push	r11
     aa4:	df 92       	push	r13
     aa6:	ef 92       	push	r14
     aa8:	ff 92       	push	r15
     aaa:	0f 93       	push	r16
     aac:	1f 93       	push	r17
     aae:	cf 93       	push	r28
     ab0:	df 93       	push	r29
	
	// This function does not read the dendrite values! Read_signals must be called somewhere prior to this function!
	// As of writing this, the update_charging_mode function in main runs check_charge_level, so 
	// the tinyDendrite_values are updated when update_signals is called later
	
	tinyDebugger_send_uint8("D1", tinyDendrite_values[0]);
     ab2:	c0 e4       	ldi	r28, 0x40	; 64
     ab4:	d8 e3       	ldi	r29, 0x38	; 56
     ab6:	68 81       	ld	r22, Y
     ab8:	87 e9       	ldi	r24, 0x97	; 151
     aba:	97 ea       	ldi	r25, 0xA7	; 167
     abc:	0e 94 c2 04 	call	0x984	; 0x984 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D2", tinyDendrite_values[1]);
     ac0:	69 81       	ldd	r22, Y+1	; 0x01
     ac2:	8a e9       	ldi	r24, 0x9A	; 154
     ac4:	97 ea       	ldi	r25, 0xA7	; 167
     ac6:	0e 94 c2 04 	call	0x984	; 0x984 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D3", tinyDendrite_values[2]);
     aca:	6a 81       	ldd	r22, Y+2	; 0x02
     acc:	8d e9       	ldi	r24, 0x9D	; 157
     ace:	97 ea       	ldi	r25, 0xA7	; 167
     ad0:	0e 94 c2 04 	call	0x984	; 0x984 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D4", tinyDendrite_values[3]);
     ad4:	6b 81       	ldd	r22, Y+3	; 0x03
     ad6:	80 ea       	ldi	r24, 0xA0	; 160
     ad8:	97 ea       	ldi	r25, 0xA7	; 167
     ada:	0e 94 c2 04 	call	0x984	; 0x984 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D5", tinyDendrite_values[4]);
     ade:	6c 81       	ldd	r22, Y+4	; 0x04
     ae0:	83 ea       	ldi	r24, 0xA3	; 163
     ae2:	97 ea       	ldi	r25, 0xA7	; 167
     ae4:	0e 94 c2 04 	call	0x984	; 0x984 <tinyDebugger_send_uint8>
     ae8:	eb e3       	ldi	r30, 0x3B	; 59
     aea:	f8 e3       	ldi	r31, 0x38	; 56
     aec:	26 e3       	ldi	r18, 0x36	; 54
     aee:	38 e3       	ldi	r19, 0x38	; 56
     af0:	40 e4       	ldi	r20, 0x40	; 64
     af2:	58 e3       	ldi	r21, 0x38	; 56
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     af4:	dd 24       	eor	r13, r13
     af6:	d3 94       	inc	r13
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
		}
		else if (tinyDendrite_values[i] > HIGH_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
     af8:	0f 2e       	mov	r0, r31
     afa:	f3 e0       	ldi	r31, 0x03	; 3
     afc:	ef 2e       	mov	r14, r31
     afe:	f0 2d       	mov	r31, r0
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     b00:	68 94       	set
     b02:	ff 24       	eor	r15, r15
     b04:	f1 f8       	bld	r15, 1
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     b06:	04 e0       	ldi	r16, 0x04	; 4
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     b08:	16 e0       	ldi	r17, 0x06	; 6
			// been moved to tinyDendrite_check_charging.
			//charging = true;
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     b0a:	75 e0       	ldi	r23, 0x05	; 5
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = CHARGING;
     b0c:	67 e0       	ldi	r22, 0x07	; 7
     b0e:	5f 01       	movw	r10, r30
	tinyDebugger_send_uint8("D4", tinyDendrite_values[3]);
	tinyDebugger_send_uint8("D5", tinyDendrite_values[4]);
	
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
     b10:	80 81       	ld	r24, Z
     b12:	d9 01       	movw	r26, r18
     b14:	8d 93       	st	X+, r24
     b16:	9d 01       	movw	r18, r26
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
     b18:	99 91       	ld	r25, Y+
     b1a:	99 3e       	cpi	r25, 0xE9	; 233
     b1c:	10 f0       	brcs	.+4      	; 0xb22 <tinyDendrite_update_signals+0x82>
		{
			tinyDendrite_current_signals[i] = CHARGING;
     b1e:	60 83       	st	Z, r22
     b20:	19 c0       	rjmp	.+50     	; 0xb54 <tinyDendrite_update_signals+0xb4>
			// Previously, we used this function to check charging, but this has now
			// been moved to tinyDendrite_check_charging.
			//charging = true;
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
     b22:	98 3c       	cpi	r25, 0xC8	; 200
     b24:	10 f0       	brcs	.+4      	; 0xb2a <tinyDendrite_update_signals+0x8a>
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     b26:	70 83       	st	Z, r23
     b28:	15 c0       	rjmp	.+42     	; 0xb54 <tinyDendrite_update_signals+0xb4>
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
     b2a:	97 3a       	cpi	r25, 0xA7	; 167
     b2c:	10 f0       	brcs	.+4      	; 0xb32 <tinyDendrite_update_signals+0x92>
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     b2e:	10 83       	st	Z, r17
     b30:	11 c0       	rjmp	.+34     	; 0xb54 <tinyDendrite_update_signals+0xb4>
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
     b32:	95 38       	cpi	r25, 0x85	; 133
     b34:	10 f0       	brcs	.+4      	; 0xb3a <tinyDendrite_update_signals+0x9a>
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     b36:	00 83       	st	Z, r16
     b38:	0d c0       	rjmp	.+26     	; 0xb54 <tinyDendrite_update_signals+0xb4>
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
     b3a:	94 36       	cpi	r25, 0x64	; 100
     b3c:	10 f0       	brcs	.+4      	; 0xb42 <tinyDendrite_update_signals+0xa2>
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     b3e:	f0 82       	st	Z, r15
     b40:	09 c0       	rjmp	.+18     	; 0xb54 <tinyDendrite_update_signals+0xb4>
		}
		else if (tinyDendrite_values[i] > HIGH_INHIB_THRESHOLD)
     b42:	93 34       	cpi	r25, 0x43	; 67
     b44:	10 f0       	brcs	.+4      	; 0xb4a <tinyDendrite_update_signals+0xaa>
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
     b46:	e0 82       	st	Z, r14
     b48:	05 c0       	rjmp	.+10     	; 0xb54 <tinyDendrite_update_signals+0xb4>
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
     b4a:	92 32       	cpi	r25, 0x22	; 34
     b4c:	10 f0       	brcs	.+4      	; 0xb52 <tinyDendrite_update_signals+0xb2>
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     b4e:	d0 82       	st	Z, r13
     b50:	01 c0       	rjmp	.+2      	; 0xb54 <tinyDendrite_update_signals+0xb4>
		}
		else
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     b52:	10 82       	st	Z, r1
		}
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
     b54:	d5 01       	movw	r26, r10
     b56:	9c 91       	ld	r25, X
     b58:	89 13       	cpse	r24, r25
     b5a:	01 c0       	rjmp	.+2      	; 0xb5e <tinyDendrite_update_signals+0xbe>
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     b5c:	1c 92       	st	X, r1
     b5e:	31 96       	adiw	r30, 0x01	; 1
	tinyDebugger_send_uint8("D2", tinyDendrite_values[1]);
	tinyDebugger_send_uint8("D3", tinyDendrite_values[2]);
	tinyDebugger_send_uint8("D4", tinyDendrite_values[3]);
	tinyDebugger_send_uint8("D5", tinyDendrite_values[4]);
	
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
     b60:	e4 17       	cp	r30, r20
     b62:	f5 07       	cpc	r31, r21
     b64:	a1 f6       	brne	.-88     	; 0xb0e <tinyDendrite_update_signals+0x6e>
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
		}
	}
}
     b66:	df 91       	pop	r29
     b68:	cf 91       	pop	r28
     b6a:	1f 91       	pop	r17
     b6c:	0f 91       	pop	r16
     b6e:	ff 90       	pop	r15
     b70:	ef 90       	pop	r14
     b72:	df 90       	pop	r13
     b74:	bf 90       	pop	r11
     b76:	af 90       	pop	r10
     b78:	08 95       	ret

00000b7a <tinyDendrite_get_potential>:
/*
This is the master function of the module that is callable from
outside. It uses the previously declared functions to return the potential.
*/
int16_t tinyDendrite_get_potential()
{
     b7a:	ef 92       	push	r14
     b7c:	ff 92       	push	r15
     b7e:	0f 93       	push	r16
     b80:	1f 93       	push	r17
     b82:	cf 93       	push	r28
     b84:	df 93       	push	r29
	if(tinyAxon_is_firing() && IGNORE_INPUT_WHILE_FIRING){
     b86:	0e 94 cf 02 	call	0x59e	; 0x59e <tinyAxon_is_firing>
		
		return NO_SIGNAL_REACTION;
	}
	
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
     b8a:	0e 94 50 05 	call	0xaa0	; 0xaa0 <tinyDendrite_update_signals>
     b8e:	cb e3       	ldi	r28, 0x3B	; 59
     b90:	d8 e3       	ldi	r29, 0x38	; 56
     b92:	0f 2e       	mov	r0, r31
     b94:	f0 e4       	ldi	r31, 0x40	; 64
     b96:	ef 2e       	mov	r14, r31
     b98:	f8 e3       	ldi	r31, 0x38	; 56
     b9a:	ff 2e       	mov	r15, r31
     b9c:	f0 2d       	mov	r31, r0
	
	int16_t return_potential_val = 0;
     b9e:	00 e0       	ldi	r16, 0x00	; 0
     ba0:	10 e0       	ldi	r17, 0x00	; 0
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		switch(tinyDendrite_current_signals[i])
     ba2:	89 91       	ld	r24, Y+
     ba4:	83 30       	cpi	r24, 0x03	; 3
     ba6:	19 f1       	breq	.+70     	; 0xbee <tinyDendrite_get_potential+0x74>
     ba8:	28 f4       	brcc	.+10     	; 0xbb4 <tinyDendrite_get_potential+0x3a>
     baa:	81 30       	cpi	r24, 0x01	; 1
     bac:	81 f1       	breq	.+96     	; 0xc0e <tinyDendrite_get_potential+0x94>
     bae:	82 30       	cpi	r24, 0x02	; 2
     bb0:	31 f1       	breq	.+76     	; 0xbfe <tinyDendrite_get_potential+0x84>
     bb2:	34 c0       	rjmp	.+104    	; 0xc1c <tinyDendrite_get_potential+0xa2>
     bb4:	85 30       	cpi	r24, 0x05	; 5
     bb6:	59 f0       	breq	.+22     	; 0xbce <tinyDendrite_get_potential+0x54>
     bb8:	90 f0       	brcs	.+36     	; 0xbde <tinyDendrite_get_potential+0x64>
     bba:	86 30       	cpi	r24, 0x06	; 6
     bbc:	79 f5       	brne	.+94     	; 0xc1c <tinyDendrite_get_potential+0xa2>
		{
			case NO_SIGNAL:
				return_potential_val += NO_SIGNAL_REACTION;
				break;
			case HIGH_EXCITE:
				return_potential_val += HIGH_EXCITE_REACTION;
     bbe:	0c 5c       	subi	r16, 0xCC	; 204
     bc0:	1f 4f       	sbci	r17, 0xFF	; 255
				tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
     bc2:	45 e0       	ldi	r20, 0x05	; 5
     bc4:	63 e0       	ldi	r22, 0x03	; 3
     bc6:	80 e0       	ldi	r24, 0x00	; 0
     bc8:	0e 94 7e 06 	call	0xcfc	; 0xcfc <tinyLED_set_color_mode>
				break;
     bcc:	27 c0       	rjmp	.+78     	; 0xc1c <tinyDendrite_get_potential+0xa2>
			case NORMAL_EXCITE:
				return_potential_val += NORMAL_EXCITE_REACTION;
     bce:	07 5e       	subi	r16, 0xE7	; 231
     bd0:	1f 4f       	sbci	r17, 0xFF	; 255
				tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
     bd2:	45 e0       	ldi	r20, 0x05	; 5
     bd4:	63 e0       	ldi	r22, 0x03	; 3
     bd6:	80 e0       	ldi	r24, 0x00	; 0
     bd8:	0e 94 7e 06 	call	0xcfc	; 0xcfc <tinyLED_set_color_mode>
				break;
     bdc:	1f c0       	rjmp	.+62     	; 0xc1c <tinyDendrite_get_potential+0xa2>
			case LOW_EXCITE:
				return_potential_val += LOW_EXCITE_REACTION;
     bde:	0c 5e       	subi	r16, 0xEC	; 236
     be0:	1f 4f       	sbci	r17, 0xFF	; 255
				tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
     be2:	45 e0       	ldi	r20, 0x05	; 5
     be4:	63 e0       	ldi	r22, 0x03	; 3
     be6:	80 e0       	ldi	r24, 0x00	; 0
     be8:	0e 94 7e 06 	call	0xcfc	; 0xcfc <tinyLED_set_color_mode>
				break;
     bec:	17 c0       	rjmp	.+46     	; 0xc1c <tinyDendrite_get_potential+0xa2>
			case HIGH_INHIB:
				return_potential_val += HIGH_INHIB_REACTION;
     bee:	02 53       	subi	r16, 0x32	; 50
     bf0:	11 09       	sbc	r17, r1
				tinyLED_set_color_mode(INN_LED, RED, FLASH_ONCE);
     bf2:	45 e0       	ldi	r20, 0x05	; 5
     bf4:	61 e0       	ldi	r22, 0x01	; 1
     bf6:	80 e0       	ldi	r24, 0x00	; 0
     bf8:	0e 94 7e 06 	call	0xcfc	; 0xcfc <tinyLED_set_color_mode>
				break;
     bfc:	0f c0       	rjmp	.+30     	; 0xc1c <tinyDendrite_get_potential+0xa2>
			case NORMAL_INHIB:
				return_potential_val += NORMAL_INHIB_REACTION;
     bfe:	09 51       	subi	r16, 0x19	; 25
     c00:	11 09       	sbc	r17, r1
				tinyLED_set_color_mode(INN_LED, RED, FLASH_ONCE);
     c02:	45 e0       	ldi	r20, 0x05	; 5
     c04:	61 e0       	ldi	r22, 0x01	; 1
     c06:	80 e0       	ldi	r24, 0x00	; 0
     c08:	0e 94 7e 06 	call	0xcfc	; 0xcfc <tinyLED_set_color_mode>
				break;
     c0c:	07 c0       	rjmp	.+14     	; 0xc1c <tinyDendrite_get_potential+0xa2>
			case LOW_INHIB:
				return_potential_val += LOW_INHIB_REACTION;
     c0e:	04 51       	subi	r16, 0x14	; 20
     c10:	11 09       	sbc	r17, r1
				tinyLED_set_color_mode(INN_LED, RED, FLASH_ONCE);
     c12:	45 e0       	ldi	r20, 0x05	; 5
     c14:	61 e0       	ldi	r22, 0x01	; 1
     c16:	80 e0       	ldi	r24, 0x00	; 0
     c18:	0e 94 7e 06 	call	0xcfc	; 0xcfc <tinyLED_set_color_mode>
	
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
	
	int16_t return_potential_val = 0;
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
     c1c:	ce 15       	cp	r28, r14
     c1e:	df 05       	cpc	r29, r15
     c20:	09 f0       	breq	.+2      	; 0xc24 <tinyDendrite_get_potential+0xaa>
     c22:	bf cf       	rjmp	.-130    	; 0xba2 <tinyDendrite_get_potential+0x28>
		}
	}
	
	return return_potential_val;
	
}
     c24:	c8 01       	movw	r24, r16
     c26:	df 91       	pop	r29
     c28:	cf 91       	pop	r28
     c2a:	1f 91       	pop	r17
     c2c:	0f 91       	pop	r16
     c2e:	ff 90       	pop	r15
     c30:	ef 90       	pop	r14
     c32:	08 95       	ret

00000c34 <tinyDendrite_update_potential>:

double tinyDendrite_update_potential(double potential){
     c34:	cf 92       	push	r12
     c36:	df 92       	push	r13
     c38:	ef 92       	push	r14
     c3a:	ff 92       	push	r15
     c3c:	6b 01       	movw	r12, r22
     c3e:	7c 01       	movw	r14, r24
	
	int16_t potential_change = tinyDendrite_get_potential();
     c40:	0e 94 bd 05 	call	0xb7a	; 0xb7a <tinyDendrite_get_potential>
	potential += potential_change;
	return potential;
     c44:	bc 01       	movw	r22, r24
     c46:	99 0f       	add	r25, r25
     c48:	88 0b       	sbc	r24, r24
     c4a:	99 0b       	sbc	r25, r25
     c4c:	0e 94 e5 0b 	call	0x17ca	; 0x17ca <__floatsisf>
     c50:	a7 01       	movw	r20, r14
     c52:	96 01       	movw	r18, r12
     c54:	0e 94 97 0a 	call	0x152e	; 0x152e <__addsf3>
     c58:	ff 90       	pop	r15
     c5a:	ef 90       	pop	r14
     c5c:	df 90       	pop	r13
     c5e:	cf 90       	pop	r12
     c60:	08 95       	ret

00000c62 <__vector_6>:
This function is called every time the RTC (Real Time Clock) counter overflows.
With the current settings, it will be called every ms.
The RTC clock runs at 1kHz, and the number of cycles before overflow is set with RTC.PER = someHexValue (e.g. 0x20) in src/rtc.c
*/
ISR(RTC_CNT_vect)
{
     c62:	1f 92       	push	r1
     c64:	0f 92       	push	r0
     c66:	0f b6       	in	r0, 0x3f	; 63
     c68:	0f 92       	push	r0
     c6a:	11 24       	eor	r1, r1
     c6c:	2f 93       	push	r18
     c6e:	3f 93       	push	r19
     c70:	4f 93       	push	r20
     c72:	5f 93       	push	r21
     c74:	6f 93       	push	r22
     c76:	7f 93       	push	r23
     c78:	8f 93       	push	r24
     c7a:	9f 93       	push	r25
     c7c:	af 93       	push	r26
     c7e:	bf 93       	push	r27
     c80:	cf 93       	push	r28
     c82:	ef 93       	push	r30
     c84:	ff 93       	push	r31
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     c86:	c1 e0       	ldi	r28, 0x01	; 1
     c88:	c0 93 45 38 	sts	0x3845, r28	; 0x803845 <tinyISR_interrupt_flag>
{
	// Set flag to let main loop run a new cycle
	tinyISR_setflag(true);
	
	// Timer counter incrementation
	tinyTime_counter_increment();
     c8c:	0e 94 79 0a 	call	0x14f2	; 0x14f2 <tinyTime_counter_increment>

	/* Overflow interrupt flag has to be cleared manually */
	RTC.INTFLAGS = RTC_OVF_bm;
     c90:	c0 93 43 01 	sts	0x0143, r28	; 0x800143 <__TEXT_REGION_LENGTH__+0x700143>
}
     c94:	ff 91       	pop	r31
     c96:	ef 91       	pop	r30
     c98:	cf 91       	pop	r28
     c9a:	bf 91       	pop	r27
     c9c:	af 91       	pop	r26
     c9e:	9f 91       	pop	r25
     ca0:	8f 91       	pop	r24
     ca2:	7f 91       	pop	r23
     ca4:	6f 91       	pop	r22
     ca6:	5f 91       	pop	r21
     ca8:	4f 91       	pop	r20
     caa:	3f 91       	pop	r19
     cac:	2f 91       	pop	r18
     cae:	0f 90       	pop	r0
     cb0:	0f be       	out	0x3f, r0	; 63
     cb2:	0f 90       	pop	r0
     cb4:	1f 90       	pop	r1
     cb6:	18 95       	reti

00000cb8 <tinyISR_setflag>:
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     cb8:	80 93 45 38 	sts	0x3845, r24	; 0x803845 <tinyISR_interrupt_flag>
     cbc:	08 95       	ret

00000cbe <tinyISR_getflag>:
}

_Bool tinyISR_getflag(void)
{
	return tinyISR_interrupt_flag;
}
     cbe:	80 91 45 38 	lds	r24, 0x3845	; 0x803845 <tinyISR_interrupt_flag>
     cc2:	08 95       	ret

00000cc4 <tinyLED_SPIWriteByte>:
Function used to send a byte over SPI, which in turn gets
translated to the bit-sequence required by the LEDs over the CCL.
*/
static void tinyLED_SPIWriteByte(uint8_t byte)
{
	SPI0.INTFLAGS = SPI0_INTFLAGS; // clear the write collision flag to allow writing
     cc4:	90 91 23 08 	lds	r25, 0x0823	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
     cc8:	90 93 23 08 	sts	0x0823, r25	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
	TCA0.SINGLE.CNT = 0; // reset TCA counter register to ensure the first rising edge of the PWM is predictable
     ccc:	e0 e0       	ldi	r30, 0x00	; 0
     cce:	fa e0       	ldi	r31, 0x0A	; 10
     cd0:	10 a2       	std	Z+32, r1	; 0x20
     cd2:	11 a2       	std	Z+33, r1	; 0x21
	
	// start TCA
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 1 << TCA_SPLIT_ENABLE_bp;
     cd4:	91 e0       	ldi	r25, 0x01	; 1
     cd6:	90 83       	st	Z, r25
	SPI0_DATA = byte;
     cd8:	80 93 24 08 	sts	0x0824, r24	; 0x800824 <__TEXT_REGION_LENGTH__+0x700824>

	while((SPI0.INTFLAGS & SPI_RXCIE_bm) == 0){} // wait for transfer to complete
     cdc:	e0 e2       	ldi	r30, 0x20	; 32
     cde:	f8 e0       	ldi	r31, 0x08	; 8
     ce0:	83 81       	ldd	r24, Z+3	; 0x03
     ce2:	88 23       	and	r24, r24
     ce4:	ec f7       	brge	.-6      	; 0xce0 <tinyLED_SPIWriteByte+0x1c>
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 0 << TCA_SPLIT_ENABLE_bp; //Stop TCA
     ce6:	10 92 00 0a 	sts	0x0A00, r1	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
     cea:	08 95       	ret

00000cec <tinyLED_get_color>:
	tinyLED_set_color_mode(LED_id, color, STABLE);
}

enum Colors tinyLED_get_color(uint8_t LED_id)
{
	return tinyLED_settings[LED_id].color;
     cec:	e8 2f       	mov	r30, r24
     cee:	f0 e0       	ldi	r31, 0x00	; 0
     cf0:	ee 0f       	add	r30, r30
     cf2:	ff 1f       	adc	r31, r31
     cf4:	ee 59       	subi	r30, 0x9E	; 158
     cf6:	f7 4c       	sbci	r31, 0xC7	; 199
}
     cf8:	80 81       	ld	r24, Z
     cfa:	08 95       	ret

00000cfc <tinyLED_set_color_mode>:
{
	// If we are in pulse mode, we want to stay in pulse mode after we have flashed a light.
	// We do this by storing the previous mode in old settings.
	// However, it can happen that two flashes comes very quickly after one another, that leads
	// to an infinite flash loop, therefore, we only store the settings if it is not flash mode.
	if(tinyLED_settings[LED_id].mode != FLASH_ONCE){
     cfc:	90 e0       	ldi	r25, 0x00	; 0
     cfe:	fc 01       	movw	r30, r24
     d00:	ee 0f       	add	r30, r30
     d02:	ff 1f       	adc	r31, r31
     d04:	ee 59       	subi	r30, 0x9E	; 158
     d06:	f7 4c       	sbci	r31, 0xC7	; 199
     d08:	51 81       	ldd	r21, Z+1	; 0x01
     d0a:	55 30       	cpi	r21, 0x05	; 5
     d0c:	61 f0       	breq	.+24     	; 0xd26 <tinyLED_set_color_mode+0x2a>
		// We use two lines to avoid pointer trouble. (I'm not good with pointers)
		tinyLED_old_settings[LED_id].color = tinyLED_settings[LED_id].color;
     d0e:	9c 01       	movw	r18, r24
     d10:	22 0f       	add	r18, r18
     d12:	33 1f       	adc	r19, r19
     d14:	f9 01       	movw	r30, r18
     d16:	ea 59       	subi	r30, 0x9A	; 154
     d18:	f7 4c       	sbci	r31, 0xC7	; 199
     d1a:	d9 01       	movw	r26, r18
     d1c:	ae 59       	subi	r26, 0x9E	; 158
     d1e:	b7 4c       	sbci	r27, 0xC7	; 199
     d20:	2c 91       	ld	r18, X
     d22:	20 83       	st	Z, r18
		tinyLED_old_settings[LED_id].mode = tinyLED_settings[LED_id].mode;
     d24:	51 83       	std	Z+1, r21	; 0x01
	}
	
	struct ColorSetting setting = {.color=color, .mode=mode};
	tinyLED_settings[LED_id] = setting;
     d26:	fc 01       	movw	r30, r24
     d28:	ee 0f       	add	r30, r30
     d2a:	ff 1f       	adc	r31, r31
     d2c:	ee 59       	subi	r30, 0x9E	; 158
     d2e:	f7 4c       	sbci	r31, 0xC7	; 199
     d30:	60 83       	st	Z, r22
     d32:	41 83       	std	Z+1, r20	; 0x01
	if (mode == FLASH_ONCE)
     d34:	45 30       	cpi	r20, 0x05	; 5
     d36:	29 f4       	brne	.+10     	; 0xd42 <tinyLED_set_color_mode+0x46>
	{
		tinyLED_flash_once_time[LED_id] = 1000*FLASH_TIME;
     d38:	fc 01       	movw	r30, r24
     d3a:	e6 5a       	subi	r30, 0xA6	; 166
     d3c:	f7 4c       	sbci	r31, 0xC7	; 199
     d3e:	2a e0       	ldi	r18, 0x0A	; 10
     d40:	20 83       	st	Z, r18
     d42:	08 95       	ret

00000d44 <tinyLED_set_color>:
/*
changes the values in the variables stored in the LED-array.
*/
void tinyLED_set_color(uint8_t LED_id, enum Colors color)
{
	tinyLED_set_color_mode(LED_id, color, STABLE);
     d44:	40 e0       	ldi	r20, 0x00	; 0
     d46:	0e 94 7e 06 	call	0xcfc	; 0xcfc <tinyLED_set_color_mode>
     d4a:	08 95       	ret

00000d4c <tinyLED_RGB_Color_Compare>:
	return rgb_color;
			
};
// This might be cause of strange light behavior?
//Message		expected 'struct RGB_Color *' but argument is of type 'struct RGB_Color (*)[2]'	Hjernebyggesett_V4	C:\Users\Elias Lundheim\Documents\GitHub\neural\Hjernebyggesett_V4\Hjernebyggesett_V4\tinyLED\tinyLED.c	121
_Bool tinyLED_RGB_Color_Compare(struct RGB_Color (*a)[NUMBER_OF_LEDS], struct RGB_Color (*b)[NUMBER_OF_LEDS]){
     d4c:	dc 01       	movw	r26, r24
     d4e:	fb 01       	movw	r30, r22
	for (int i=0; i<NUMBER_OF_LEDS; i++)
	{
		if(!((*a)[i].red==(*b)[i].red && (*a)[i].green==(*b)[i].green && (*a)[i].blue==(*b)[i].blue)){
     d50:	9c 91       	ld	r25, X
     d52:	80 81       	ld	r24, Z
     d54:	98 13       	cpse	r25, r24
     d56:	20 c0       	rjmp	.+64     	; 0xd98 <tinyLED_RGB_Color_Compare+0x4c>
     d58:	11 96       	adiw	r26, 0x01	; 1
     d5a:	9c 91       	ld	r25, X
     d5c:	11 97       	sbiw	r26, 0x01	; 1
     d5e:	81 81       	ldd	r24, Z+1	; 0x01
     d60:	98 13       	cpse	r25, r24
     d62:	1c c0       	rjmp	.+56     	; 0xd9c <tinyLED_RGB_Color_Compare+0x50>
     d64:	12 96       	adiw	r26, 0x02	; 2
     d66:	9c 91       	ld	r25, X
     d68:	12 97       	sbiw	r26, 0x02	; 2
     d6a:	82 81       	ldd	r24, Z+2	; 0x02
     d6c:	98 13       	cpse	r25, r24
     d6e:	18 c0       	rjmp	.+48     	; 0xda0 <tinyLED_RGB_Color_Compare+0x54>
     d70:	13 96       	adiw	r26, 0x03	; 3
     d72:	9c 91       	ld	r25, X
     d74:	13 97       	sbiw	r26, 0x03	; 3
     d76:	83 81       	ldd	r24, Z+3	; 0x03
     d78:	98 13       	cpse	r25, r24
     d7a:	14 c0       	rjmp	.+40     	; 0xda4 <tinyLED_RGB_Color_Compare+0x58>
     d7c:	14 96       	adiw	r26, 0x04	; 4
     d7e:	9c 91       	ld	r25, X
     d80:	14 97       	sbiw	r26, 0x04	; 4
     d82:	84 81       	ldd	r24, Z+4	; 0x04
     d84:	98 13       	cpse	r25, r24
     d86:	10 c0       	rjmp	.+32     	; 0xda8 <tinyLED_RGB_Color_Compare+0x5c>
     d88:	81 e0       	ldi	r24, 0x01	; 1
     d8a:	15 96       	adiw	r26, 0x05	; 5
     d8c:	2c 91       	ld	r18, X
     d8e:	95 81       	ldd	r25, Z+5	; 0x05
     d90:	29 17       	cp	r18, r25
     d92:	59 f0       	breq	.+22     	; 0xdaa <tinyLED_RGB_Color_Compare+0x5e>
     d94:	80 e0       	ldi	r24, 0x00	; 0
     d96:	08 95       	ret
			return false;
     d98:	80 e0       	ldi	r24, 0x00	; 0
     d9a:	08 95       	ret
     d9c:	80 e0       	ldi	r24, 0x00	; 0
     d9e:	08 95       	ret
     da0:	80 e0       	ldi	r24, 0x00	; 0
     da2:	08 95       	ret
     da4:	80 e0       	ldi	r24, 0x00	; 0
     da6:	08 95       	ret
     da8:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	return true;
}
     daa:	08 95       	ret

00000dac <tinyLED_update>:
/*
function to write the current LED-array on to the LEDs and
effectively update the values stored in the LEDs to the values stored in the MCU.
*/
void tinyLED_update(void)
{
     dac:	2f 92       	push	r2
     dae:	3f 92       	push	r3
     db0:	4f 92       	push	r4
     db2:	5f 92       	push	r5
     db4:	6f 92       	push	r6
     db6:	7f 92       	push	r7
     db8:	8f 92       	push	r8
     dba:	9f 92       	push	r9
     dbc:	af 92       	push	r10
     dbe:	bf 92       	push	r11
     dc0:	cf 92       	push	r12
     dc2:	df 92       	push	r13
     dc4:	ef 92       	push	r14
     dc6:	ff 92       	push	r15
     dc8:	0f 93       	push	r16
     dca:	1f 93       	push	r17
     dcc:	cf 93       	push	r28
     dce:	df 93       	push	r29
     dd0:	cd b7       	in	r28, 0x3d	; 61
     dd2:	de b7       	in	r29, 0x3e	; 62
     dd4:	6f 97       	sbiw	r28, 0x1f	; 31
     dd6:	cd bf       	out	0x3d, r28	; 61
     dd8:	de bf       	out	0x3e, r29	; 62
			
	uint32_t now = tinyTime_now();
     dda:	0e 94 8d 0a 	call	0x151a	; 0x151a <tinyTime_now>
     dde:	6b 01       	movw	r12, r22
     de0:	7c 01       	movw	r14, r24
	
	// This is a sin curve, but between 0 and 1 instead of -1 and 1
	double sinValue = 0.5+sin((double)now/(100*M_PI/SWING_RATE))/2;
     de2:	0e 94 e3 0b 	call	0x17c6	; 0x17c6 <__floatunsisf>
     de6:	22 ed       	ldi	r18, 0xD2	; 210
     de8:	33 e5       	ldi	r19, 0x53	; 83
     dea:	4b ef       	ldi	r20, 0xFB	; 251
     dec:	51 e4       	ldi	r21, 0x41	; 65
     dee:	0e 94 08 0b 	call	0x1610	; 0x1610 <__divsf3>
     df2:	0e 94 c3 0d 	call	0x1b86	; 0x1b86 <sin>
     df6:	20 e0       	ldi	r18, 0x00	; 0
     df8:	30 e0       	ldi	r19, 0x00	; 0
     dfa:	40 e0       	ldi	r20, 0x00	; 0
     dfc:	5f e3       	ldi	r21, 0x3F	; 63
     dfe:	0e 94 56 0d 	call	0x1aac	; 0x1aac <__mulsf3>
     e02:	20 e0       	ldi	r18, 0x00	; 0
     e04:	30 e0       	ldi	r19, 0x00	; 0
     e06:	40 e0       	ldi	r20, 0x00	; 0
     e08:	5f e3       	ldi	r21, 0x3F	; 63
     e0a:	0e 94 97 0a 	call	0x152e	; 0x152e <__addsf3>
     e0e:	6f 83       	std	Y+7, r22	; 0x07
     e10:	78 87       	std	Y+8, r23	; 0x08
     e12:	89 87       	std	Y+9, r24	; 0x09
     e14:	9a 87       	std	Y+10, r25	; 0x0a
	
	// If FLASH_RATE is one, then that means that the left side of the "<" will just count from 0 to 1000, and flash_on will be true for half of the time
	_Bool flash_on = now%(uint32_t)(1000/FLASH_RATE)  <   500/FLASH_RATE;
     e16:	c7 01       	movw	r24, r14
     e18:	b6 01       	movw	r22, r12
     e1a:	22 e3       	ldi	r18, 0x32	; 50
     e1c:	30 e0       	ldi	r19, 0x00	; 0
     e1e:	40 e0       	ldi	r20, 0x00	; 0
     e20:	50 e0       	ldi	r21, 0x00	; 0
     e22:	0e 94 2c 0e 	call	0x1c58	; 0x1c58 <__udivmodsi4>
     e26:	0e 94 e3 0b 	call	0x17c6	; 0x17c6 <__floatunsisf>
     e2a:	20 e0       	ldi	r18, 0x00	; 0
     e2c:	30 e0       	ldi	r19, 0x00	; 0
     e2e:	48 ec       	ldi	r20, 0xC8	; 200
     e30:	51 e4       	ldi	r21, 0x41	; 65
     e32:	0e 94 03 0b 	call	0x1606	; 0x1606 <__cmpsf2>
     e36:	88 1f       	adc	r24, r24
     e38:	88 27       	eor	r24, r24
     e3a:	88 1f       	adc	r24, r24
     e3c:	8b 87       	std	Y+11, r24	; 0x0b
	
	// PING_RATE is usually small, so the left side counts to some large number. Since flash_time usually is also quite small,
	// the left side will usually be larger than the right
	_Bool ping_on =  now%(uint32_t)(1000/PING_RATE)   <   1000*FLASH_TIME;
     e3e:	c7 01       	movw	r24, r14
     e40:	b6 01       	movw	r22, r12
     e42:	24 ef       	ldi	r18, 0xF4	; 244
     e44:	31 e0       	ldi	r19, 0x01	; 1
     e46:	40 e0       	ldi	r20, 0x00	; 0
     e48:	50 e0       	ldi	r21, 0x00	; 0
     e4a:	0e 94 2c 0e 	call	0x1c58	; 0x1c58 <__udivmodsi4>
     e4e:	0e 94 e3 0b 	call	0x17c6	; 0x17c6 <__floatunsisf>
     e52:	20 e0       	ldi	r18, 0x00	; 0
     e54:	30 e0       	ldi	r19, 0x00	; 0
     e56:	40 e2       	ldi	r20, 0x20	; 32
     e58:	51 e4       	ldi	r21, 0x41	; 65
     e5a:	0e 94 03 0b 	call	0x1606	; 0x1606 <__cmpsf2>
     e5e:	88 1f       	adc	r24, r24
     e60:	88 27       	eor	r24, r24
     e62:	88 1f       	adc	r24, r24
     e64:	0f 2e       	mov	r0, r31
     e66:	f2 e6       	ldi	r31, 0x62	; 98
     e68:	2f 2e       	mov	r2, r31
     e6a:	f8 e3       	ldi	r31, 0x38	; 56
     e6c:	3f 2e       	mov	r3, r31
     e6e:	f0 2d       	mov	r31, r0
     e70:	9e 01       	movw	r18, r28
     e72:	2f 5f       	subi	r18, 0xFF	; 255
     e74:	3f 4f       	sbci	r19, 0xFF	; 255
     e76:	69 01       	movw	r12, r18
     e78:	0f 2e       	mov	r0, r31
     e7a:	f6 e6       	ldi	r31, 0x66	; 102
     e7c:	af 2e       	mov	r10, r31
     e7e:	f8 e3       	ldi	r31, 0x38	; 56
     e80:	bf 2e       	mov	r11, r31
     e82:	f0 2d       	mov	r31, r0
     e84:	0a e5       	ldi	r16, 0x5A	; 90
     e86:	18 e3       	ldi	r17, 0x38	; 56
     e88:	0f 2e       	mov	r0, r31
     e8a:	f6 e6       	ldi	r31, 0x66	; 102
     e8c:	4f 2e       	mov	r4, r31
     e8e:	f8 e3       	ldi	r31, 0x38	; 56
     e90:	5f 2e       	mov	r5, r31
     e92:	f0 2d       	mov	r31, r0
     e94:	39 01       	movw	r6, r18
			case SWING:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*sinValue, rgb_colors[i].green*sinValue, rgb_colors[i].blue*sinValue};
				break;
			case PING:
				// in the line below, fmin will either return 1 or 0, so each rgb color is either 0 or 255*PING_BRIGHTNESS
				rgb_colors[i] = (struct RGB_Color){255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].red)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].green)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].blue)*ping_on};
     e96:	28 2f       	mov	r18, r24
     e98:	30 e0       	ldi	r19, 0x00	; 0
     e9a:	40 e0       	ldi	r20, 0x00	; 0
     e9c:	50 e0       	ldi	r21, 0x00	; 0
     e9e:	28 8b       	std	Y+16, r18	; 0x10
     ea0:	39 8b       	std	Y+17, r19	; 0x11
     ea2:	4a 8b       	std	Y+18, r20	; 0x12
     ea4:	5b 8b       	std	Y+19, r21	; 0x13
     ea6:	f1 01       	movw	r30, r2
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 0 << TCA_SPLIT_ENABLE_bp; //Stop TCA
}

static struct RGB_Color tinyLED_enum_to_RGB_Color(enum Colors color){
	struct RGB_Color rgb_color;
	switch(color)
     ea8:	80 81       	ld	r24, Z
     eaa:	83 30       	cpi	r24, 0x03	; 3
     eac:	79 f0       	breq	.+30     	; 0xecc <tinyLED_update+0x120>
     eae:	28 f4       	brcc	.+10     	; 0xeba <tinyLED_update+0x10e>
     eb0:	81 30       	cpi	r24, 0x01	; 1
     eb2:	41 f0       	breq	.+16     	; 0xec4 <tinyLED_update+0x118>
     eb4:	82 30       	cpi	r24, 0x02	; 2
     eb6:	89 f0       	breq	.+34     	; 0xeda <tinyLED_update+0x12e>
     eb8:	28 c0       	rjmp	.+80     	; 0xf0a <tinyLED_update+0x15e>
     eba:	84 30       	cpi	r24, 0x04	; 4
     ebc:	a9 f0       	breq	.+42     	; 0xee8 <tinyLED_update+0x13c>
     ebe:	85 30       	cpi	r24, 0x05	; 5
     ec0:	d1 f0       	breq	.+52     	; 0xef6 <tinyLED_update+0x14a>
     ec2:	23 c0       	rjmp	.+70     	; 0xf0a <tinyLED_update+0x15e>
	{
		case LED_OFF:
			rgb_color = (struct RGB_Color){0, 0, 0};
			break;
		case RED:
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 0, 0};
     ec4:	f1 2c       	mov	r15, r1
     ec6:	e1 2c       	mov	r14, r1
     ec8:	69 e1       	ldi	r22, 0x19	; 25
     eca:	22 c0       	rjmp	.+68     	; 0xf10 <tinyLED_update+0x164>
			break;
		case GREEN:
			rgb_color = (struct RGB_Color){0, 255*LED_BRIGHTNESS, 0};
     ecc:	f1 2c       	mov	r15, r1
     ece:	0f 2e       	mov	r0, r31
     ed0:	f9 e1       	ldi	r31, 0x19	; 25
     ed2:	ef 2e       	mov	r14, r31
     ed4:	f0 2d       	mov	r31, r0
     ed6:	60 e0       	ldi	r22, 0x00	; 0
     ed8:	1b c0       	rjmp	.+54     	; 0xf10 <tinyLED_update+0x164>
			break;
		case BLUE:
			rgb_color = (struct RGB_Color){0, 0, 255*LED_BRIGHTNESS};
     eda:	0f 2e       	mov	r0, r31
     edc:	f9 e1       	ldi	r31, 0x19	; 25
     ede:	ff 2e       	mov	r15, r31
     ee0:	f0 2d       	mov	r31, r0
     ee2:	e1 2c       	mov	r14, r1
     ee4:	60 e0       	ldi	r22, 0x00	; 0
     ee6:	14 c0       	rjmp	.+40     	; 0xf10 <tinyLED_update+0x164>
			break;
		case YELLOW:
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS, 0};
     ee8:	f1 2c       	mov	r15, r1
     eea:	0f 2e       	mov	r0, r31
     eec:	f9 e1       	ldi	r31, 0x19	; 25
     eee:	ef 2e       	mov	r14, r31
     ef0:	f0 2d       	mov	r31, r0
     ef2:	69 e1       	ldi	r22, 0x19	; 25
     ef4:	0d c0       	rjmp	.+26     	; 0xf10 <tinyLED_update+0x164>
			// Should the /3 be there? This requires testing.
			// After testing, findings were that at 0.1 brightness, one would see the three LEDs instead of one white led
			// We try with /2 instead.
			// We find that the best results come from not dividing by anything. At leasts in the lower brightness settings, and that
			// is where we suspect it will be most of the time. When we divide, the LEDs are so weak, that they appear as three lights instead of one.
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS};
     ef6:	0f 2e       	mov	r0, r31
     ef8:	f9 e1       	ldi	r31, 0x19	; 25
     efa:	ff 2e       	mov	r15, r31
     efc:	f0 2d       	mov	r31, r0
     efe:	0f 2e       	mov	r0, r31
     f00:	f9 e1       	ldi	r31, 0x19	; 25
     f02:	ef 2e       	mov	r14, r31
     f04:	f0 2d       	mov	r31, r0
     f06:	69 e1       	ldi	r22, 0x19	; 25
     f08:	03 c0       	rjmp	.+6      	; 0xf10 <tinyLED_update+0x164>
static struct RGB_Color tinyLED_enum_to_RGB_Color(enum Colors color){
	struct RGB_Color rgb_color;
	switch(color)
	{
		case LED_OFF:
			rgb_color = (struct RGB_Color){0, 0, 0};
     f0a:	f1 2c       	mov	r15, r1
     f0c:	e1 2c       	mov	r14, r1
     f0e:	60 e0       	ldi	r22, 0x00	; 0
	
		
	for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
	{		
		// Convert enum to RGB_Color
		rgb_colors[i] = tinyLED_enum_to_RGB_Color(tinyLED_settings[i].color);
     f10:	d3 01       	movw	r26, r6
     f12:	6c 93       	st	X, r22
     f14:	11 96       	adiw	r26, 0x01	; 1
     f16:	ec 92       	st	X, r14
     f18:	11 97       	sbiw	r26, 0x01	; 1
     f1a:	12 96       	adiw	r26, 0x02	; 2
     f1c:	fc 92       	st	X, r15
			
		// Adjust colors according to mode
		switch(tinyLED_settings[i].mode)
     f1e:	81 81       	ldd	r24, Z+1	; 0x01
     f20:	83 30       	cpi	r24, 0x03	; 3
     f22:	09 f4       	brne	.+2      	; 0xf26 <tinyLED_update+0x17a>
     f24:	50 c0       	rjmp	.+160    	; 0xfc6 <tinyLED_update+0x21a>
     f26:	28 f4       	brcc	.+10     	; 0xf32 <tinyLED_update+0x186>
     f28:	81 30       	cpi	r24, 0x01	; 1
     f2a:	51 f0       	breq	.+20     	; 0xf40 <tinyLED_update+0x194>
     f2c:	82 30       	cpi	r24, 0x02	; 2
     f2e:	c9 f1       	breq	.+114    	; 0xfa2 <tinyLED_update+0x1f6>
     f30:	05 c1       	rjmp	.+522    	; 0x113c <tinyLED_update+0x390>
     f32:	84 30       	cpi	r24, 0x04	; 4
     f34:	09 f4       	brne	.+2      	; 0xf38 <tinyLED_update+0x18c>
     f36:	78 c0       	rjmp	.+240    	; 0x1028 <tinyLED_update+0x27c>
     f38:	85 30       	cpi	r24, 0x05	; 5
     f3a:	09 f4       	brne	.+2      	; 0xf3e <tinyLED_update+0x192>
     f3c:	f2 c0       	rjmp	.+484    	; 0x1122 <tinyLED_update+0x376>
     f3e:	fe c0       	rjmp	.+508    	; 0x113c <tinyLED_update+0x390>
		{
			case STABLE:
				break;
			case WEAK:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*WEAK_BRIGHTNESS, rgb_colors[i].green*WEAK_BRIGHTNESS, rgb_colors[i].blue*WEAK_BRIGHTNESS};
     f40:	70 e0       	ldi	r23, 0x00	; 0
     f42:	80 e0       	ldi	r24, 0x00	; 0
     f44:	90 e0       	ldi	r25, 0x00	; 0
     f46:	0e 94 e5 0b 	call	0x17ca	; 0x17ca <__floatsisf>
     f4a:	2d ec       	ldi	r18, 0xCD	; 205
     f4c:	3c ec       	ldi	r19, 0xCC	; 204
     f4e:	4c ec       	ldi	r20, 0xCC	; 204
     f50:	5d e3       	ldi	r21, 0x3D	; 61
     f52:	0e 94 56 0d 	call	0x1aac	; 0x1aac <__mulsf3>
     f56:	0e 94 b4 0b 	call	0x1768	; 0x1768 <__fixunssfsi>
     f5a:	f3 01       	movw	r30, r6
     f5c:	60 83       	st	Z, r22
     f5e:	6e 2d       	mov	r22, r14
     f60:	70 e0       	ldi	r23, 0x00	; 0
     f62:	80 e0       	ldi	r24, 0x00	; 0
     f64:	90 e0       	ldi	r25, 0x00	; 0
     f66:	0e 94 e5 0b 	call	0x17ca	; 0x17ca <__floatsisf>
     f6a:	2d ec       	ldi	r18, 0xCD	; 205
     f6c:	3c ec       	ldi	r19, 0xCC	; 204
     f6e:	4c ec       	ldi	r20, 0xCC	; 204
     f70:	5d e3       	ldi	r21, 0x3D	; 61
     f72:	0e 94 56 0d 	call	0x1aac	; 0x1aac <__mulsf3>
     f76:	0e 94 b4 0b 	call	0x1768	; 0x1768 <__fixunssfsi>
     f7a:	d3 01       	movw	r26, r6
     f7c:	11 96       	adiw	r26, 0x01	; 1
     f7e:	6c 93       	st	X, r22
     f80:	6f 2d       	mov	r22, r15
     f82:	70 e0       	ldi	r23, 0x00	; 0
     f84:	80 e0       	ldi	r24, 0x00	; 0
     f86:	90 e0       	ldi	r25, 0x00	; 0
     f88:	0e 94 e5 0b 	call	0x17ca	; 0x17ca <__floatsisf>
     f8c:	2d ec       	ldi	r18, 0xCD	; 205
     f8e:	3c ec       	ldi	r19, 0xCC	; 204
     f90:	4c ec       	ldi	r20, 0xCC	; 204
     f92:	5d e3       	ldi	r21, 0x3D	; 61
     f94:	0e 94 56 0d 	call	0x1aac	; 0x1aac <__mulsf3>
     f98:	0e 94 b4 0b 	call	0x1768	; 0x1768 <__fixunssfsi>
     f9c:	f3 01       	movw	r30, r6
     f9e:	62 83       	std	Z+2, r22	; 0x02
				break;
     fa0:	cd c0       	rjmp	.+410    	; 0x113c <tinyLED_update+0x390>
			case FLASH:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*flash_on, rgb_colors[i].green*flash_on, rgb_colors[i].blue*flash_on};
     fa2:	fb 85       	ldd	r31, Y+11	; 0x0b
     fa4:	f6 9f       	mul	r31, r22
     fa6:	60 2d       	mov	r22, r0
     fa8:	11 24       	eor	r1, r1
     faa:	d3 01       	movw	r26, r6
     fac:	6c 93       	st	X, r22
     fae:	fe 9d       	mul	r31, r14
     fb0:	e0 2c       	mov	r14, r0
     fb2:	11 24       	eor	r1, r1
     fb4:	11 96       	adiw	r26, 0x01	; 1
     fb6:	ec 92       	st	X, r14
     fb8:	11 97       	sbiw	r26, 0x01	; 1
     fba:	ff 9d       	mul	r31, r15
     fbc:	f0 2c       	mov	r15, r0
     fbe:	11 24       	eor	r1, r1
     fc0:	12 96       	adiw	r26, 0x02	; 2
     fc2:	fc 92       	st	X, r15
				break;
     fc4:	bb c0       	rjmp	.+374    	; 0x113c <tinyLED_update+0x390>
			case SWING:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*sinValue, rgb_colors[i].green*sinValue, rgb_colors[i].blue*sinValue};
     fc6:	70 e0       	ldi	r23, 0x00	; 0
     fc8:	80 e0       	ldi	r24, 0x00	; 0
     fca:	90 e0       	ldi	r25, 0x00	; 0
     fcc:	0e 94 e5 0b 	call	0x17ca	; 0x17ca <__floatsisf>
     fd0:	2f 81       	ldd	r18, Y+7	; 0x07
     fd2:	38 85       	ldd	r19, Y+8	; 0x08
     fd4:	49 85       	ldd	r20, Y+9	; 0x09
     fd6:	5a 85       	ldd	r21, Y+10	; 0x0a
     fd8:	0e 94 56 0d 	call	0x1aac	; 0x1aac <__mulsf3>
     fdc:	0e 94 b4 0b 	call	0x1768	; 0x1768 <__fixunssfsi>
     fe0:	f3 01       	movw	r30, r6
     fe2:	60 83       	st	Z, r22
     fe4:	6e 2d       	mov	r22, r14
     fe6:	70 e0       	ldi	r23, 0x00	; 0
     fe8:	80 e0       	ldi	r24, 0x00	; 0
     fea:	90 e0       	ldi	r25, 0x00	; 0
     fec:	0e 94 e5 0b 	call	0x17ca	; 0x17ca <__floatsisf>
     ff0:	2f 81       	ldd	r18, Y+7	; 0x07
     ff2:	38 85       	ldd	r19, Y+8	; 0x08
     ff4:	49 85       	ldd	r20, Y+9	; 0x09
     ff6:	5a 85       	ldd	r21, Y+10	; 0x0a
     ff8:	0e 94 56 0d 	call	0x1aac	; 0x1aac <__mulsf3>
     ffc:	0e 94 b4 0b 	call	0x1768	; 0x1768 <__fixunssfsi>
    1000:	d3 01       	movw	r26, r6
    1002:	11 96       	adiw	r26, 0x01	; 1
    1004:	6c 93       	st	X, r22
    1006:	6f 2d       	mov	r22, r15
    1008:	70 e0       	ldi	r23, 0x00	; 0
    100a:	80 e0       	ldi	r24, 0x00	; 0
    100c:	90 e0       	ldi	r25, 0x00	; 0
    100e:	0e 94 e5 0b 	call	0x17ca	; 0x17ca <__floatsisf>
    1012:	2f 81       	ldd	r18, Y+7	; 0x07
    1014:	38 85       	ldd	r19, Y+8	; 0x08
    1016:	49 85       	ldd	r20, Y+9	; 0x09
    1018:	5a 85       	ldd	r21, Y+10	; 0x0a
    101a:	0e 94 56 0d 	call	0x1aac	; 0x1aac <__mulsf3>
    101e:	0e 94 b4 0b 	call	0x1768	; 0x1768 <__fixunssfsi>
    1022:	f3 01       	movw	r30, r6
    1024:	62 83       	std	Z+2, r22	; 0x02
				break;
    1026:	8a c0       	rjmp	.+276    	; 0x113c <tinyLED_update+0x390>
			case PING:
				// in the line below, fmin will either return 1 or 0, so each rgb color is either 0 or 255*PING_BRIGHTNESS
				rgb_colors[i] = (struct RGB_Color){255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].red)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].green)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].blue)*ping_on};
    1028:	70 e0       	ldi	r23, 0x00	; 0
    102a:	80 e0       	ldi	r24, 0x00	; 0
    102c:	90 e0       	ldi	r25, 0x00	; 0
    102e:	0e 94 e3 0b 	call	0x17c6	; 0x17c6 <__floatunsisf>
    1032:	9b 01       	movw	r18, r22
    1034:	ac 01       	movw	r20, r24
    1036:	60 e0       	ldi	r22, 0x00	; 0
    1038:	70 e0       	ldi	r23, 0x00	; 0
    103a:	80 e8       	ldi	r24, 0x80	; 128
    103c:	9f e3       	ldi	r25, 0x3F	; 63
    103e:	0e 94 20 0c 	call	0x1840	; 0x1840 <fmin>
    1042:	6c 8b       	std	Y+20, r22	; 0x14
    1044:	7d 8b       	std	Y+21, r23	; 0x15
    1046:	8e 8b       	std	Y+22, r24	; 0x16
    1048:	9f 8b       	std	Y+23, r25	; 0x17
    104a:	68 89       	ldd	r22, Y+16	; 0x10
    104c:	79 89       	ldd	r23, Y+17	; 0x11
    104e:	8a 89       	ldd	r24, Y+18	; 0x12
    1050:	9b 89       	ldd	r25, Y+19	; 0x13
    1052:	0e 94 e5 0b 	call	0x17ca	; 0x17ca <__floatsisf>
    1056:	6c 87       	std	Y+12, r22	; 0x0c
    1058:	7d 87       	std	Y+13, r23	; 0x0d
    105a:	8e 87       	std	Y+14, r24	; 0x0e
    105c:	9f 87       	std	Y+15, r25	; 0x0f
    105e:	6e 2d       	mov	r22, r14
    1060:	70 e0       	ldi	r23, 0x00	; 0
    1062:	80 e0       	ldi	r24, 0x00	; 0
    1064:	90 e0       	ldi	r25, 0x00	; 0
    1066:	0e 94 e3 0b 	call	0x17c6	; 0x17c6 <__floatunsisf>
    106a:	9b 01       	movw	r18, r22
    106c:	ac 01       	movw	r20, r24
    106e:	60 e0       	ldi	r22, 0x00	; 0
    1070:	70 e0       	ldi	r23, 0x00	; 0
    1072:	80 e8       	ldi	r24, 0x80	; 128
    1074:	9f e3       	ldi	r25, 0x3F	; 63
    1076:	0e 94 20 0c 	call	0x1840	; 0x1840 <fmin>
    107a:	68 8f       	std	Y+24, r22	; 0x18
    107c:	79 8f       	std	Y+25, r23	; 0x19
    107e:	8a 8f       	std	Y+26, r24	; 0x1a
    1080:	9b 8f       	std	Y+27, r25	; 0x1b
    1082:	6f 2d       	mov	r22, r15
    1084:	70 e0       	ldi	r23, 0x00	; 0
    1086:	80 e0       	ldi	r24, 0x00	; 0
    1088:	90 e0       	ldi	r25, 0x00	; 0
    108a:	0e 94 e3 0b 	call	0x17c6	; 0x17c6 <__floatunsisf>
    108e:	9b 01       	movw	r18, r22
    1090:	ac 01       	movw	r20, r24
    1092:	60 e0       	ldi	r22, 0x00	; 0
    1094:	70 e0       	ldi	r23, 0x00	; 0
    1096:	80 e8       	ldi	r24, 0x80	; 128
    1098:	9f e3       	ldi	r25, 0x3F	; 63
    109a:	0e 94 20 0c 	call	0x1840	; 0x1840 <fmin>
    109e:	6c 8f       	std	Y+28, r22	; 0x1c
    10a0:	7d 8f       	std	Y+29, r23	; 0x1d
    10a2:	8e 8f       	std	Y+30, r24	; 0x1e
    10a4:	9f 8f       	std	Y+31, r25	; 0x1f
    10a6:	23 e3       	ldi	r18, 0x33	; 51
    10a8:	33 e3       	ldi	r19, 0x33	; 51
    10aa:	43 ea       	ldi	r20, 0xA3	; 163
    10ac:	50 e4       	ldi	r21, 0x40	; 64
    10ae:	6c 89       	ldd	r22, Y+20	; 0x14
    10b0:	7d 89       	ldd	r23, Y+21	; 0x15
    10b2:	8e 89       	ldd	r24, Y+22	; 0x16
    10b4:	9f 89       	ldd	r25, Y+23	; 0x17
    10b6:	0e 94 56 0d 	call	0x1aac	; 0x1aac <__mulsf3>
    10ba:	2c 85       	ldd	r18, Y+12	; 0x0c
    10bc:	3d 85       	ldd	r19, Y+13	; 0x0d
    10be:	4e 85       	ldd	r20, Y+14	; 0x0e
    10c0:	5f 85       	ldd	r21, Y+15	; 0x0f
    10c2:	0e 94 56 0d 	call	0x1aac	; 0x1aac <__mulsf3>
    10c6:	0e 94 b4 0b 	call	0x1768	; 0x1768 <__fixunssfsi>
    10ca:	d3 01       	movw	r26, r6
    10cc:	6c 93       	st	X, r22
    10ce:	23 e3       	ldi	r18, 0x33	; 51
    10d0:	33 e3       	ldi	r19, 0x33	; 51
    10d2:	43 ea       	ldi	r20, 0xA3	; 163
    10d4:	50 e4       	ldi	r21, 0x40	; 64
    10d6:	68 8d       	ldd	r22, Y+24	; 0x18
    10d8:	79 8d       	ldd	r23, Y+25	; 0x19
    10da:	8a 8d       	ldd	r24, Y+26	; 0x1a
    10dc:	9b 8d       	ldd	r25, Y+27	; 0x1b
    10de:	0e 94 56 0d 	call	0x1aac	; 0x1aac <__mulsf3>
    10e2:	2c 85       	ldd	r18, Y+12	; 0x0c
    10e4:	3d 85       	ldd	r19, Y+13	; 0x0d
    10e6:	4e 85       	ldd	r20, Y+14	; 0x0e
    10e8:	5f 85       	ldd	r21, Y+15	; 0x0f
    10ea:	0e 94 56 0d 	call	0x1aac	; 0x1aac <__mulsf3>
    10ee:	0e 94 b4 0b 	call	0x1768	; 0x1768 <__fixunssfsi>
    10f2:	f3 01       	movw	r30, r6
    10f4:	61 83       	std	Z+1, r22	; 0x01
    10f6:	23 e3       	ldi	r18, 0x33	; 51
    10f8:	33 e3       	ldi	r19, 0x33	; 51
    10fa:	43 ea       	ldi	r20, 0xA3	; 163
    10fc:	50 e4       	ldi	r21, 0x40	; 64
    10fe:	6c 8d       	ldd	r22, Y+28	; 0x1c
    1100:	7d 8d       	ldd	r23, Y+29	; 0x1d
    1102:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1104:	9f 8d       	ldd	r25, Y+31	; 0x1f
    1106:	0e 94 56 0d 	call	0x1aac	; 0x1aac <__mulsf3>
    110a:	2c 85       	ldd	r18, Y+12	; 0x0c
    110c:	3d 85       	ldd	r19, Y+13	; 0x0d
    110e:	4e 85       	ldd	r20, Y+14	; 0x0e
    1110:	5f 85       	ldd	r21, Y+15	; 0x0f
    1112:	0e 94 56 0d 	call	0x1aac	; 0x1aac <__mulsf3>
    1116:	0e 94 b4 0b 	call	0x1768	; 0x1768 <__fixunssfsi>
    111a:	d3 01       	movw	r26, r6
    111c:	12 96       	adiw	r26, 0x02	; 2
    111e:	6c 93       	st	X, r22
				break;
    1120:	0d c0       	rjmp	.+26     	; 0x113c <tinyLED_update+0x390>
			case FLASH_ONCE:
				if(tinyLED_flash_once_time[i]>0){
    1122:	d8 01       	movw	r26, r16
    1124:	8c 91       	ld	r24, X
    1126:	88 23       	and	r24, r24
    1128:	19 f0       	breq	.+6      	; 0x1130 <tinyLED_update+0x384>
					rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red, rgb_colors[i].green, rgb_colors[i].blue};
					tinyLED_flash_once_time[i]--;
    112a:	81 50       	subi	r24, 0x01	; 1
    112c:	8c 93       	st	X, r24
    112e:	06 c0       	rjmp	.+12     	; 0x113c <tinyLED_update+0x390>
				}
				else{
					// Here we return to the previous color and mode
					tinyLED_settings[i].color = tinyLED_old_settings[i].color;
    1130:	d5 01       	movw	r26, r10
    1132:	8c 91       	ld	r24, X
    1134:	80 83       	st	Z, r24
					tinyLED_settings[i].mode = tinyLED_old_settings[i].mode;
    1136:	11 96       	adiw	r26, 0x01	; 1
    1138:	8c 91       	ld	r24, X
    113a:	81 83       	std	Z+1, r24	; 0x01
    113c:	b2 e0       	ldi	r27, 0x02	; 2
    113e:	2b 0e       	add	r2, r27
    1140:	31 1c       	adc	r3, r1
    1142:	e3 e0       	ldi	r30, 0x03	; 3
    1144:	6e 0e       	add	r6, r30
    1146:	71 1c       	adc	r7, r1
    1148:	f2 e0       	ldi	r31, 0x02	; 2
    114a:	af 0e       	add	r10, r31
    114c:	b1 1c       	adc	r11, r1
    114e:	0f 5f       	subi	r16, 0xFF	; 255
    1150:	1f 4f       	sbci	r17, 0xFF	; 255
	
	// This is where we store all the actual color values we want to send to the LED
	struct RGB_Color rgb_colors[NUMBER_OF_LEDS];
	
		
	for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
    1152:	24 14       	cp	r2, r4
    1154:	35 04       	cpc	r3, r5
    1156:	09 f0       	breq	.+2      	; 0x115a <tinyLED_update+0x3ae>
    1158:	a6 ce       	rjmp	.-692    	; 0xea6 <tinyLED_update+0xfa>
				break;
		}
	}
	
	// We only write to the LEDs if there is something to change. (eg. in SWING mode, we update the LEDs almost every cycle)
	if(!tinyLED_RGB_Color_Compare(&rgb_colors, &tinyLED_old_colors)){
    115a:	6c e5       	ldi	r22, 0x5C	; 92
    115c:	78 e3       	ldi	r23, 0x38	; 56
    115e:	ce 01       	movw	r24, r28
    1160:	01 96       	adiw	r24, 0x01	; 1
    1162:	0e 94 a6 06 	call	0xd4c	; 0xd4c <tinyLED_RGB_Color_Compare>
    1166:	81 11       	cpse	r24, r1
    1168:	21 c0       	rjmp	.+66     	; 0x11ac <tinyLED_update+0x400>
    116a:	0c e5       	ldi	r16, 0x5C	; 92
    116c:	18 e3       	ldi	r17, 0x38	; 56
    116e:	7e 01       	movw	r14, r28
    1170:	27 e0       	ldi	r18, 0x07	; 7
    1172:	e2 0e       	add	r14, r18
    1174:	f1 1c       	adc	r15, r1
		for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
		{
			// Write to LEDs
			//For some reason, the data-bus to the LEDs is serialized as GRB
			//which means the 24-bit data-bus will look like [Green[0:7], Red[0:7], Blue[0:7]]
			tinyLED_SPIWriteByte(rgb_colors[i].green);
    1176:	d6 01       	movw	r26, r12
    1178:	11 96       	adiw	r26, 0x01	; 1
    117a:	8c 91       	ld	r24, X
    117c:	0e 94 62 06 	call	0xcc4	; 0xcc4 <tinyLED_SPIWriteByte>
			tinyLED_SPIWriteByte(rgb_colors[i].red);
    1180:	f6 01       	movw	r30, r12
    1182:	80 81       	ld	r24, Z
    1184:	0e 94 62 06 	call	0xcc4	; 0xcc4 <tinyLED_SPIWriteByte>
			tinyLED_SPIWriteByte(rgb_colors[i].blue);
    1188:	d6 01       	movw	r26, r12
    118a:	12 96       	adiw	r26, 0x02	; 2
    118c:	8c 91       	ld	r24, X
    118e:	0e 94 62 06 	call	0xcc4	; 0xcc4 <tinyLED_SPIWriteByte>
			tinyLED_old_colors[i] = rgb_colors[i];
    1192:	f6 01       	movw	r30, r12
    1194:	81 91       	ld	r24, Z+
    1196:	91 91       	ld	r25, Z+
    1198:	a1 91       	ld	r26, Z+
    119a:	6f 01       	movw	r12, r30
    119c:	f8 01       	movw	r30, r16
    119e:	81 93       	st	Z+, r24
    11a0:	91 93       	st	Z+, r25
    11a2:	a1 93       	st	Z+, r26
    11a4:	8f 01       	movw	r16, r30
		}
	}
	
	// We only write to the LEDs if there is something to change. (eg. in SWING mode, we update the LEDs almost every cycle)
	if(!tinyLED_RGB_Color_Compare(&rgb_colors, &tinyLED_old_colors)){
		for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
    11a6:	ce 14       	cp	r12, r14
    11a8:	df 04       	cpc	r13, r15
    11aa:	29 f7       	brne	.-54     	; 0x1176 <tinyLED_update+0x3ca>
			tinyLED_old_colors[i] = rgb_colors[i];
		}
		//tinyDebugger_send_uint8("LED1 color", tinyLED_settings[0].color);
		//tinyDebugger_send_uint8("LED2 color", tinyLED_settings[1].color);
	}
}
    11ac:	6f 96       	adiw	r28, 0x1f	; 31
    11ae:	cd bf       	out	0x3d, r28	; 61
    11b0:	de bf       	out	0x3e, r29	; 62
    11b2:	df 91       	pop	r29
    11b4:	cf 91       	pop	r28
    11b6:	1f 91       	pop	r17
    11b8:	0f 91       	pop	r16
    11ba:	ff 90       	pop	r15
    11bc:	ef 90       	pop	r14
    11be:	df 90       	pop	r13
    11c0:	cf 90       	pop	r12
    11c2:	bf 90       	pop	r11
    11c4:	af 90       	pop	r10
    11c6:	9f 90       	pop	r9
    11c8:	8f 90       	pop	r8
    11ca:	7f 90       	pop	r7
    11cc:	6f 90       	pop	r6
    11ce:	5f 90       	pop	r5
    11d0:	4f 90       	pop	r4
    11d2:	3f 90       	pop	r3
    11d4:	2f 90       	pop	r2
    11d6:	08 95       	ret

000011d8 <tinyPotential_update>:

/*
Update the potential
*/
void tinyPotential_update()
{
    11d8:	cf 92       	push	r12
    11da:	df 92       	push	r13
    11dc:	ef 92       	push	r14
    11de:	ff 92       	push	r15
Function to decay the potential towards 0
*/
static void tinyPotential_decay()
{
		
	uint8_t time_since_last_update = tinyTime_now() - previous_update_time;
    11e0:	0e 94 8d 0a 	call	0x151a	; 0x151a <tinyTime_now>
	tinyPotential_potential *= (exp(-((float)time_since_last_update/(float)TINYPOTENTIAL_TIME_CONST)));
    11e4:	80 91 46 38 	lds	r24, 0x3846	; 0x803846 <previous_update_time>
    11e8:	68 1b       	sub	r22, r24
    11ea:	70 e0       	ldi	r23, 0x00	; 0
    11ec:	80 e0       	ldi	r24, 0x00	; 0
    11ee:	90 e0       	ldi	r25, 0x00	; 0
    11f0:	0e 94 e3 0b 	call	0x17c6	; 0x17c6 <__floatunsisf>
    11f4:	20 e0       	ldi	r18, 0x00	; 0
    11f6:	30 e0       	ldi	r19, 0x00	; 0
    11f8:	48 ec       	ldi	r20, 0xC8	; 200
    11fa:	52 e4       	ldi	r21, 0x42	; 66
    11fc:	0e 94 08 0b 	call	0x1610	; 0x1610 <__divsf3>
    1200:	90 58       	subi	r25, 0x80	; 128
    1202:	0e 94 82 0b 	call	0x1704	; 0x1704 <exp>
    1206:	20 91 4a 38 	lds	r18, 0x384A	; 0x80384a <tinyPotential_potential>
    120a:	30 91 4b 38 	lds	r19, 0x384B	; 0x80384b <tinyPotential_potential+0x1>
    120e:	40 91 4c 38 	lds	r20, 0x384C	; 0x80384c <tinyPotential_potential+0x2>
    1212:	50 91 4d 38 	lds	r21, 0x384D	; 0x80384d <tinyPotential_potential+0x3>
    1216:	0e 94 56 0d 	call	0x1aac	; 0x1aac <__mulsf3>
    121a:	6b 01       	movw	r12, r22
    121c:	7c 01       	movw	r14, r24
	if(fabs(tinyPotential_potential)<0.1){
    121e:	9f 77       	andi	r25, 0x7F	; 127
    1220:	2d ec       	ldi	r18, 0xCD	; 205
    1222:	3c ec       	ldi	r19, 0xCC	; 204
    1224:	4c ec       	ldi	r20, 0xCC	; 204
    1226:	5d e3       	ldi	r21, 0x3D	; 61
    1228:	0e 94 03 0b 	call	0x1606	; 0x1606 <__cmpsf2>
    122c:	88 23       	and	r24, r24
    122e:	4c f0       	brlt	.+18     	; 0x1242 <tinyPotential_update+0x6a>
*/
static void tinyPotential_decay()
{
		
	uint8_t time_since_last_update = tinyTime_now() - previous_update_time;
	tinyPotential_potential *= (exp(-((float)time_since_last_update/(float)TINYPOTENTIAL_TIME_CONST)));
    1230:	c0 92 4a 38 	sts	0x384A, r12	; 0x80384a <tinyPotential_potential>
    1234:	d0 92 4b 38 	sts	0x384B, r13	; 0x80384b <tinyPotential_potential+0x1>
    1238:	e0 92 4c 38 	sts	0x384C, r14	; 0x80384c <tinyPotential_potential+0x2>
    123c:	f0 92 4d 38 	sts	0x384D, r15	; 0x80384d <tinyPotential_potential+0x3>
    1240:	08 c0       	rjmp	.+16     	; 0x1252 <tinyPotential_update+0x7a>
	if(fabs(tinyPotential_potential)<0.1){
		tinyPotential_potential=0;
    1242:	10 92 4a 38 	sts	0x384A, r1	; 0x80384a <tinyPotential_potential>
    1246:	10 92 4b 38 	sts	0x384B, r1	; 0x80384b <tinyPotential_potential+0x1>
    124a:	10 92 4c 38 	sts	0x384C, r1	; 0x80384c <tinyPotential_potential+0x2>
    124e:	10 92 4d 38 	sts	0x384D, r1	; 0x80384d <tinyPotential_potential+0x3>
	}
	previous_update_time = tinyTime_now();
    1252:	0e 94 8d 0a 	call	0x151a	; 0x151a <tinyTime_now>
    1256:	60 93 46 38 	sts	0x3846, r22	; 0x803846 <previous_update_time>
    125a:	70 93 47 38 	sts	0x3847, r23	; 0x803847 <previous_update_time+0x1>
    125e:	80 93 48 38 	sts	0x3848, r24	; 0x803848 <previous_update_time+0x2>
    1262:	90 93 49 38 	sts	0x3849, r25	; 0x803849 <previous_update_time+0x3>
void tinyPotential_update()
{
	//Some of the potential in the neuron has decayed away
	tinyPotential_decay();
	// Update potential with values from Dendrites
	tinyPotential_potential = tinyDendrite_update_potential(tinyPotential_potential);
    1266:	60 91 4a 38 	lds	r22, 0x384A	; 0x80384a <tinyPotential_potential>
    126a:	70 91 4b 38 	lds	r23, 0x384B	; 0x80384b <tinyPotential_potential+0x1>
    126e:	80 91 4c 38 	lds	r24, 0x384C	; 0x80384c <tinyPotential_potential+0x2>
    1272:	90 91 4d 38 	lds	r25, 0x384D	; 0x80384d <tinyPotential_potential+0x3>
    1276:	0e 94 1a 06 	call	0xc34	; 0xc34 <tinyDendrite_update_potential>
    127a:	60 93 4a 38 	sts	0x384A, r22	; 0x80384a <tinyPotential_potential>
    127e:	70 93 4b 38 	sts	0x384B, r23	; 0x80384b <tinyPotential_potential+0x1>
    1282:	80 93 4c 38 	sts	0x384C, r24	; 0x80384c <tinyPotential_potential+0x2>
    1286:	90 93 4d 38 	sts	0x384D, r25	; 0x80384d <tinyPotential_potential+0x3>
	
	// Update potential from button press
	tinyPotential_potential = tinyButton_update_potential(tinyPotential_potential);
    128a:	0e 94 38 04 	call	0x870	; 0x870 <tinyButton_update_potential>
    128e:	60 93 4a 38 	sts	0x384A, r22	; 0x80384a <tinyPotential_potential>
    1292:	70 93 4b 38 	sts	0x384B, r23	; 0x80384b <tinyPotential_potential+0x1>
    1296:	80 93 4c 38 	sts	0x384C, r24	; 0x80384c <tinyPotential_potential+0x2>
    129a:	90 93 4d 38 	sts	0x384D, r25	; 0x80384d <tinyPotential_potential+0x3>
	
	// Update potential with values from spontaneous pulse.
	tinyPotential_potential = tinyPulse_update_potential(tinyPotential_potential);
    129e:	0e 94 98 09 	call	0x1330	; 0x1330 <tinyPulse_update_potential>
    12a2:	ab 01       	movw	r20, r22
    12a4:	bc 01       	movw	r22, r24
    12a6:	40 93 4a 38 	sts	0x384A, r20	; 0x80384a <tinyPotential_potential>
    12aa:	50 93 4b 38 	sts	0x384B, r21	; 0x80384b <tinyPotential_potential+0x1>
    12ae:	60 93 4c 38 	sts	0x384C, r22	; 0x80384c <tinyPotential_potential+0x2>
    12b2:	70 93 4d 38 	sts	0x384D, r23	; 0x80384d <tinyPotential_potential+0x3>
	
	tinyDebugger_send_double("Potential", tinyPotential_potential);
    12b6:	86 ea       	ldi	r24, 0xA6	; 166
    12b8:	97 ea       	ldi	r25, 0xA7	; 167
    12ba:	0e 94 d3 04 	call	0x9a6	; 0x9a6 <tinyDebugger_send_double>
	
	
	// Let the axon affect the potential
	// This is also where we decide whether or not the axon should fire
	tinyPotential_potential = tinyAxon_update_potential(tinyPotential_potential);
    12be:	60 91 4a 38 	lds	r22, 0x384A	; 0x80384a <tinyPotential_potential>
    12c2:	70 91 4b 38 	lds	r23, 0x384B	; 0x80384b <tinyPotential_potential+0x1>
    12c6:	80 91 4c 38 	lds	r24, 0x384C	; 0x80384c <tinyPotential_potential+0x2>
    12ca:	90 91 4d 38 	lds	r25, 0x384D	; 0x80384d <tinyPotential_potential+0x3>
    12ce:	0e 94 13 03 	call	0x626	; 0x626 <tinyAxon_update_potential>
    12d2:	60 93 4a 38 	sts	0x384A, r22	; 0x80384a <tinyPotential_potential>
    12d6:	70 93 4b 38 	sts	0x384B, r23	; 0x80384b <tinyPotential_potential+0x1>
    12da:	80 93 4c 38 	sts	0x384C, r24	; 0x80384c <tinyPotential_potential+0x2>
    12de:	90 93 4d 38 	sts	0x384D, r25	; 0x80384d <tinyPotential_potential+0x3>
}
    12e2:	ff 90       	pop	r15
    12e4:	ef 90       	pop	r14
    12e6:	df 90       	pop	r13
    12e8:	cf 90       	pop	r12
    12ea:	08 95       	ret

000012ec <tinyPulse_toggle_pulse_mode>:
_Bool tinyPulse_is_in_pulse_mode(){
	return pulse_mode;
}

void tinyPulse_toggle_pulse_mode(){
	pulse_mode = !pulse_mode;
    12ec:	90 91 54 38 	lds	r25, 0x3854	; 0x803854 <pulse_mode>
    12f0:	81 e0       	ldi	r24, 0x01	; 1
    12f2:	89 27       	eor	r24, r25
    12f4:	80 93 54 38 	sts	0x3854, r24	; 0x803854 <pulse_mode>
	
	if(tinyPulse_is_in_pulse_mode()){
    12f8:	88 23       	and	r24, r24
    12fa:	59 f0       	breq	.+22     	; 0x1312 <tinyPulse_toggle_pulse_mode+0x26>
		tinyLED_set_color_mode(OUT_LED, PULSEMODE_COLOR, WEAK);
    12fc:	41 e0       	ldi	r20, 0x01	; 1
    12fe:	62 e0       	ldi	r22, 0x02	; 2
    1300:	81 e0       	ldi	r24, 0x01	; 1
    1302:	0e 94 7e 06 	call	0xcfc	; 0xcfc <tinyLED_set_color_mode>
		tinyLED_set_color_mode(INN_LED, PULSEMODE_COLOR, WEAK);
    1306:	41 e0       	ldi	r20, 0x01	; 1
    1308:	62 e0       	ldi	r22, 0x02	; 2
    130a:	80 e0       	ldi	r24, 0x00	; 0
    130c:	0e 94 7e 06 	call	0xcfc	; 0xcfc <tinyLED_set_color_mode>
    1310:	08 95       	ret
	}
	else{
		tinyLED_set_color(OUT_LED, LED_OFF);
    1312:	60 e0       	ldi	r22, 0x00	; 0
    1314:	81 e0       	ldi	r24, 0x01	; 1
    1316:	0e 94 a2 06 	call	0xd44	; 0xd44 <tinyLED_set_color>
		tinyLED_set_color(INN_LED, LED_OFF);
    131a:	60 e0       	ldi	r22, 0x00	; 0
    131c:	80 e0       	ldi	r24, 0x00	; 0
    131e:	0e 94 a2 06 	call	0xd44	; 0xd44 <tinyLED_set_color>
    1322:	08 95       	ret

00001324 <tinyPulse_set_pulse_mode>:
	}
}

void tinyPulse_set_pulse_mode(_Bool mode){
	if (pulse_mode != mode)
    1324:	90 91 54 38 	lds	r25, 0x3854	; 0x803854 <pulse_mode>
    1328:	98 13       	cpse	r25, r24
	{
		tinyPulse_toggle_pulse_mode();
    132a:	0e 94 76 09 	call	0x12ec	; 0x12ec <tinyPulse_toggle_pulse_mode>
    132e:	08 95       	ret

00001330 <tinyPulse_update_potential>:
	}
}

double tinyPulse_update_potential(double potential){
    1330:	cf 92       	push	r12
    1332:	df 92       	push	r13
    1334:	ef 92       	push	r14
    1336:	ff 92       	push	r15
    1338:	6b 01       	movw	r12, r22
    133a:	7c 01       	movw	r14, r24
	if(pulse_mode){
    133c:	80 91 54 38 	lds	r24, 0x3854	; 0x803854 <pulse_mode>
    1340:	88 23       	and	r24, r24
    1342:	39 f1       	breq	.+78     	; 0x1392 <tinyPulse_update_potential+0x62>
		
		time_since_last_pulse = tinyTime_now() - time_of_last_pulse;
    1344:	0e 94 8d 0a 	call	0x151a	; 0x151a <tinyTime_now>
    1348:	20 91 50 38 	lds	r18, 0x3850	; 0x803850 <time_of_last_pulse>
    134c:	30 91 51 38 	lds	r19, 0x3851	; 0x803851 <time_of_last_pulse+0x1>
    1350:	62 1b       	sub	r22, r18
    1352:	73 0b       	sbc	r23, r19
    1354:	60 93 4e 38 	sts	0x384E, r22	; 0x80384e <time_since_last_pulse>
    1358:	70 93 4f 38 	sts	0x384F, r23	; 0x80384f <time_since_last_pulse+0x1>
		
		if(time_since_last_pulse >= ideal_time_between_pulses){
    135c:	80 91 13 38 	lds	r24, 0x3813	; 0x803813 <ideal_time_between_pulses>
    1360:	90 91 14 38 	lds	r25, 0x3814	; 0x803814 <ideal_time_between_pulses+0x1>
    1364:	68 17       	cp	r22, r24
    1366:	79 07       	cpc	r23, r25
    1368:	a0 f0       	brcs	.+40     	; 0x1392 <tinyPulse_update_potential+0x62>
			// This isn't actually a button press. You could have a separate variable for this, but it seems unnecessary.
			potential += BUTTON_PRESS_REACTION;
    136a:	20 e0       	ldi	r18, 0x00	; 0
    136c:	30 e0       	ldi	r19, 0x00	; 0
    136e:	40 ed       	ldi	r20, 0xD0	; 208
    1370:	51 e4       	ldi	r21, 0x41	; 65
    1372:	c7 01       	movw	r24, r14
    1374:	b6 01       	movw	r22, r12
    1376:	0e 94 97 0a 	call	0x152e	; 0x152e <__addsf3>
    137a:	6b 01       	movw	r12, r22
    137c:	7c 01       	movw	r14, r24
			time_of_last_pulse = tinyTime_now();			
    137e:	0e 94 8d 0a 	call	0x151a	; 0x151a <tinyTime_now>
    1382:	60 93 50 38 	sts	0x3850, r22	; 0x803850 <time_of_last_pulse>
    1386:	70 93 51 38 	sts	0x3851, r23	; 0x803851 <time_of_last_pulse+0x1>
    138a:	80 93 52 38 	sts	0x3852, r24	; 0x803852 <time_of_last_pulse+0x2>
    138e:	90 93 53 38 	sts	0x3853, r25	; 0x803853 <time_of_last_pulse+0x3>
		}
	}
	return potential;
}
    1392:	c7 01       	movw	r24, r14
    1394:	b6 01       	movw	r22, r12
    1396:	ff 90       	pop	r15
    1398:	ef 90       	pop	r14
    139a:	df 90       	pop	r13
    139c:	cf 90       	pop	r12
    139e:	08 95       	ret

000013a0 <tinyTester_check_signals>:

/*
check_signals() will send signals out through the axon and check that all of it's own dendrites recieve the sent signal.
This assumes that the neuron is placed in a circuit connecting the axon to all the dendrites.
*/
_Bool tinyTester_check_signals(){	
    13a0:	5f 92       	push	r5
    13a2:	6f 92       	push	r6
    13a4:	7f 92       	push	r7
    13a6:	8f 92       	push	r8
    13a8:	9f 92       	push	r9
    13aa:	af 92       	push	r10
    13ac:	bf 92       	push	r11
    13ae:	cf 92       	push	r12
    13b0:	df 92       	push	r13
    13b2:	ef 92       	push	r14
    13b4:	ff 92       	push	r15
    13b6:	0f 93       	push	r16
    13b8:	1f 93       	push	r17
    13ba:	cf 93       	push	r28
    13bc:	df 93       	push	r29
    13be:	cd b7       	in	r28, 0x3d	; 61
    13c0:	de b7       	in	r29, 0x3e	; 62
    13c2:	2a 97       	sbiw	r28, 0x0a	; 10
    13c4:	cd bf       	out	0x3d, r28	; 61
    13c6:	de bf       	out	0x3e, r29	; 62
	_Bool test_failed = false;
	
	# define NUMBER_OF_TEST_VALUES 10
	// The neuron seems to have trouble reaching a value of 255. Often at least one dendrite reads 249, which gives an error.
	// But there are no errors when sending 250.
	uint8_t test_values[NUMBER_OF_TEST_VALUES] = {0, 33, 66, 99, 132, 166, 199, 232, 250, 0}; // Current ADC (Analog to Digital Converter) values
    13c8:	8a e0       	ldi	r24, 0x0A	; 10
    13ca:	e4 e5       	ldi	r30, 0x54	; 84
    13cc:	f7 ea       	ldi	r31, 0xA7	; 167
    13ce:	de 01       	movw	r26, r28
    13d0:	11 96       	adiw	r26, 0x01	; 1
    13d2:	01 90       	ld	r0, Z+
    13d4:	0d 92       	st	X+, r0
    13d6:	8a 95       	dec	r24
    13d8:	e1 f7       	brne	.-8      	; 0x13d2 <tinyTester_check_signals+0x32>
	
	
	printf("Starting signal test.\r\n");
    13da:	80 eb       	ldi	r24, 0xB0	; 176
    13dc:	97 ea       	ldi	r25, 0xA7	; 167
    13de:	0e 94 84 0e 	call	0x1d08	; 0x1d08 <puts>
    13e2:	ce 01       	movw	r24, r28
    13e4:	01 96       	adiw	r24, 0x01	; 1
    13e6:	6c 01       	movw	r12, r24
    13e8:	4e 01       	movw	r8, r28
    13ea:	9b e0       	ldi	r25, 0x0B	; 11
    13ec:	89 0e       	add	r8, r25
    13ee:	91 1c       	adc	r9, r1
/*
check_signals() will send signals out through the axon and check that all of it's own dendrites recieve the sent signal.
This assumes that the neuron is placed in a circuit connecting the axon to all the dendrites.
*/
_Bool tinyTester_check_signals(){	
	_Bool test_failed = false;
    13f0:	51 2c       	mov	r5, r1
		for (int j = 0; j < DENDRITE_COUNT; j++)
		{
			int difference = test_values[i] - tinyDendrite_get_value(j);
			if(abs(difference) > ACCEPTABLE_NOISE){
				test_failed = true;
				printf("Signal test failed! Axon sent %3u but dendrite %1u received %3u.\r\n", test_values[i], j, tinyDendrite_get_value(j));
    13f2:	0f 2e       	mov	r0, r31
    13f4:	f7 ec       	ldi	r31, 0xC7	; 199
    13f6:	af 2e       	mov	r10, r31
    13f8:	f7 ea       	ldi	r31, 0xA7	; 167
    13fa:	bf 2e       	mov	r11, r31
    13fc:	f0 2d       	mov	r31, r0
	printf("Starting signal test.\r\n");
	
	for (int i = 0; i < NUMBER_OF_TEST_VALUES; i++)
	{
		// Set the axon value
		DAC_0_set_output(test_values[i]);
    13fe:	f6 01       	movw	r30, r12
    1400:	61 90       	ld	r6, Z+
    1402:	6f 01       	movw	r12, r30
    1404:	86 2d       	mov	r24, r6
    1406:	90 e0       	ldi	r25, 0x00	; 0
    1408:	0e 94 9b 01 	call	0x336	; 0x336 <DAC_0_set_output>
		tinyDendrite_read_signals();
    140c:	0e 94 0e 05 	call	0xa1c	; 0xa1c <tinyDendrite_read_signals>
		for (int j = 0; j < DENDRITE_COUNT; j++)
    1410:	00 e0       	ldi	r16, 0x00	; 0
    1412:	10 e0       	ldi	r17, 0x00	; 0
		{
			int difference = test_values[i] - tinyDendrite_get_value(j);
    1414:	e6 2c       	mov	r14, r6
    1416:	f1 2c       	mov	r15, r1
    1418:	70 2e       	mov	r7, r16
    141a:	80 2f       	mov	r24, r16
    141c:	0e 94 2e 05 	call	0xa5c	; 0xa5c <tinyDendrite_get_value>
			if(abs(difference) > ACCEPTABLE_NOISE){
    1420:	97 01       	movw	r18, r14
    1422:	28 1b       	sub	r18, r24
    1424:	31 09       	sbc	r19, r1
    1426:	c9 01       	movw	r24, r18
    1428:	99 23       	and	r25, r25
    142a:	24 f4       	brge	.+8      	; 0x1434 <tinyTester_check_signals+0x94>
    142c:	88 27       	eor	r24, r24
    142e:	99 27       	eor	r25, r25
    1430:	82 1b       	sub	r24, r18
    1432:	93 0b       	sbc	r25, r19
    1434:	06 97       	sbiw	r24, 0x06	; 6
    1436:	8c f0       	brlt	.+34     	; 0x145a <tinyTester_check_signals+0xba>
				test_failed = true;
				printf("Signal test failed! Axon sent %3u but dendrite %1u received %3u.\r\n", test_values[i], j, tinyDendrite_get_value(j));
    1438:	87 2d       	mov	r24, r7
    143a:	0e 94 2e 05 	call	0xa5c	; 0xa5c <tinyDendrite_get_value>
    143e:	1f 92       	push	r1
    1440:	8f 93       	push	r24
    1442:	1f 93       	push	r17
    1444:	0f 93       	push	r16
    1446:	1f 92       	push	r1
    1448:	6f 92       	push	r6
    144a:	bf 92       	push	r11
    144c:	af 92       	push	r10
    144e:	0e 94 6e 0e 	call	0x1cdc	; 0x1cdc <printf>
    1452:	cd bf       	out	0x3d, r28	; 61
    1454:	de bf       	out	0x3e, r29	; 62
		tinyDendrite_read_signals();
		for (int j = 0; j < DENDRITE_COUNT; j++)
		{
			int difference = test_values[i] - tinyDendrite_get_value(j);
			if(abs(difference) > ACCEPTABLE_NOISE){
				test_failed = true;
    1456:	55 24       	eor	r5, r5
    1458:	53 94       	inc	r5
	for (int i = 0; i < NUMBER_OF_TEST_VALUES; i++)
	{
		// Set the axon value
		DAC_0_set_output(test_values[i]);
		tinyDendrite_read_signals();
		for (int j = 0; j < DENDRITE_COUNT; j++)
    145a:	0f 5f       	subi	r16, 0xFF	; 255
    145c:	1f 4f       	sbci	r17, 0xFF	; 255
    145e:	05 30       	cpi	r16, 0x05	; 5
    1460:	11 05       	cpc	r17, r1
    1462:	d1 f6       	brne	.-76     	; 0x1418 <tinyTester_check_signals+0x78>
	uint8_t test_values[NUMBER_OF_TEST_VALUES] = {0, 33, 66, 99, 132, 166, 199, 232, 250, 0}; // Current ADC (Analog to Digital Converter) values
	
	
	printf("Starting signal test.\r\n");
	
	for (int i = 0; i < NUMBER_OF_TEST_VALUES; i++)
    1464:	8c 14       	cp	r8, r12
    1466:	9d 04       	cpc	r9, r13
    1468:	51 f6       	brne	.-108    	; 0x13fe <tinyTester_check_signals+0x5e>
				printf("Signal test failed! Axon sent %3u but dendrite %1u received %3u.\r\n", test_values[i], j, tinyDendrite_get_value(j));
			}
		}
	}
	
	printf("Signal test is done.\r\n");
    146a:	8a e0       	ldi	r24, 0x0A	; 10
    146c:	98 ea       	ldi	r25, 0xA8	; 168
    146e:	0e 94 84 0e 	call	0x1d08	; 0x1d08 <puts>
	return test_failed;
}
    1472:	85 2d       	mov	r24, r5
    1474:	2a 96       	adiw	r28, 0x0a	; 10
    1476:	cd bf       	out	0x3d, r28	; 61
    1478:	de bf       	out	0x3e, r29	; 62
    147a:	df 91       	pop	r29
    147c:	cf 91       	pop	r28
    147e:	1f 91       	pop	r17
    1480:	0f 91       	pop	r16
    1482:	ff 90       	pop	r15
    1484:	ef 90       	pop	r14
    1486:	df 90       	pop	r13
    1488:	cf 90       	pop	r12
    148a:	bf 90       	pop	r11
    148c:	af 90       	pop	r10
    148e:	9f 90       	pop	r9
    1490:	8f 90       	pop	r8
    1492:	7f 90       	pop	r7
    1494:	6f 90       	pop	r6
    1496:	5f 90       	pop	r5
    1498:	08 95       	ret

0000149a <tinyTester_test>:
void tinyTester_test(){
	_Bool test_failed = false;
	uint8_t number_of_failed_tests = 0;
	
	// Show that testing has started
	tinyLED_set_color(INN_LED, BLUE);
    149a:	62 e0       	ldi	r22, 0x02	; 2
    149c:	80 e0       	ldi	r24, 0x00	; 0
    149e:	0e 94 a2 06 	call	0xd44	; 0xd44 <tinyLED_set_color>
	printf("Starting testing.\r\n");
    14a2:	80 e2       	ldi	r24, 0x20	; 32
    14a4:	98 ea       	ldi	r25, 0xA8	; 168
    14a6:	0e 94 84 0e 	call	0x1d08	; 0x1d08 <puts>
	_Bool (*testFunctions[NUMBER_OF_TEST_FUNCTIONS])() = {&tinyTester_check_signals};
	
	for (int i=0; i<NUMBER_OF_TEST_FUNCTIONS; i++){
		test_failed = false;
		//Starting test
		tinyLED_set_color(OUT_LED, YELLOW);
    14aa:	64 e0       	ldi	r22, 0x04	; 4
    14ac:	81 e0       	ldi	r24, 0x01	; 1
    14ae:	0e 94 a2 06 	call	0xd44	; 0xd44 <tinyLED_set_color>
		
		//Update LED
		tinyLED_update();
    14b2:	0e 94 d6 06 	call	0xdac	; 0xdac <tinyLED_update>
		
		test_failed = testFunctions[i]();
    14b6:	0e 94 d0 09 	call	0x13a0	; 0x13a0 <tinyTester_check_signals>
		if(test_failed){
    14ba:	88 23       	and	r24, r24
    14bc:	59 f0       	breq	.+22     	; 0x14d4 <tinyTester_test+0x3a>
			tinyLED_set_color(OUT_LED, RED);
    14be:	61 e0       	ldi	r22, 0x01	; 1
    14c0:	81 e0       	ldi	r24, 0x01	; 1
    14c2:	0e 94 a2 06 	call	0xd44	; 0xd44 <tinyLED_set_color>
		else{
			tinyLED_set_color(OUT_LED, GREEN);
		}
		
		// Update LED
		tinyLED_update();
    14c6:	0e 94 d6 06 	call	0xdac	; 0xdac <tinyLED_update>
	}
	
	//Final verdict
	if(number_of_failed_tests>0){
		tinyLED_set_color(INN_LED, RED);
    14ca:	61 e0       	ldi	r22, 0x01	; 1
    14cc:	80 e0       	ldi	r24, 0x00	; 0
    14ce:	0e 94 a2 06 	call	0xd44	; 0xd44 <tinyLED_set_color>
    14d2:	0a c0       	rjmp	.+20     	; 0x14e8 <tinyTester_test+0x4e>
		if(test_failed){
			tinyLED_set_color(OUT_LED, RED);
			number_of_failed_tests++;
		}
		else{
			tinyLED_set_color(OUT_LED, GREEN);
    14d4:	63 e0       	ldi	r22, 0x03	; 3
    14d6:	81 e0       	ldi	r24, 0x01	; 1
    14d8:	0e 94 a2 06 	call	0xd44	; 0xd44 <tinyLED_set_color>
		}
		
		// Update LED
		tinyLED_update();
    14dc:	0e 94 d6 06 	call	0xdac	; 0xdac <tinyLED_update>
	
	//Final verdict
	if(number_of_failed_tests>0){
		tinyLED_set_color(INN_LED, RED);
		}else{
		tinyLED_set_color(INN_LED, GREEN);
    14e0:	63 e0       	ldi	r22, 0x03	; 3
    14e2:	80 e0       	ldi	r24, 0x00	; 0
    14e4:	0e 94 a2 06 	call	0xd44	; 0xd44 <tinyLED_set_color>
	}
	
	printf("Testing is done.\r\n\r\n");
    14e8:	83 e3       	ldi	r24, 0x33	; 51
    14ea:	98 ea       	ldi	r25, 0xA8	; 168
    14ec:	0e 94 84 0e 	call	0x1d08	; 0x1d08 <puts>
    14f0:	08 95       	ret

000014f2 <tinyTime_counter_increment>:
If the Interrupt Service Routine is clocked by a crystal oscillator
it gives a very precise timer-counter.
*/
void tinyTime_counter_increment(void)
{
	time_counter++;
    14f2:	80 91 55 38 	lds	r24, 0x3855	; 0x803855 <time_counter>
    14f6:	90 91 56 38 	lds	r25, 0x3856	; 0x803856 <time_counter+0x1>
    14fa:	a0 91 57 38 	lds	r26, 0x3857	; 0x803857 <time_counter+0x2>
    14fe:	b0 91 58 38 	lds	r27, 0x3858	; 0x803858 <time_counter+0x3>
    1502:	01 96       	adiw	r24, 0x01	; 1
    1504:	a1 1d       	adc	r26, r1
    1506:	b1 1d       	adc	r27, r1
    1508:	80 93 55 38 	sts	0x3855, r24	; 0x803855 <time_counter>
    150c:	90 93 56 38 	sts	0x3856, r25	; 0x803856 <time_counter+0x1>
    1510:	a0 93 57 38 	sts	0x3857, r26	; 0x803857 <time_counter+0x2>
    1514:	b0 93 58 38 	sts	0x3858, r27	; 0x803858 <time_counter+0x3>
    1518:	08 95       	ret

0000151a <tinyTime_now>:
/*
This function is callable by external libraries to give them the counted time so far.
*/
uint32_t tinyTime_now(void)
{
	return time_counter;
    151a:	60 91 55 38 	lds	r22, 0x3855	; 0x803855 <time_counter>
    151e:	70 91 56 38 	lds	r23, 0x3856	; 0x803856 <time_counter+0x1>
    1522:	80 91 57 38 	lds	r24, 0x3857	; 0x803857 <time_counter+0x2>
    1526:	90 91 58 38 	lds	r25, 0x3858	; 0x803858 <time_counter+0x3>
    152a:	08 95       	ret

0000152c <__subsf3>:
    152c:	50 58       	subi	r21, 0x80	; 128

0000152e <__addsf3>:
    152e:	bb 27       	eor	r27, r27
    1530:	aa 27       	eor	r26, r26
    1532:	0e 94 ae 0a 	call	0x155c	; 0x155c <__addsf3x>
    1536:	0c 94 a1 0c 	jmp	0x1942	; 0x1942 <__fp_round>
    153a:	0e 94 93 0c 	call	0x1926	; 0x1926 <__fp_pscA>
    153e:	38 f0       	brcs	.+14     	; 0x154e <__addsf3+0x20>
    1540:	0e 94 9a 0c 	call	0x1934	; 0x1934 <__fp_pscB>
    1544:	20 f0       	brcs	.+8      	; 0x154e <__addsf3+0x20>
    1546:	39 f4       	brne	.+14     	; 0x1556 <__addsf3+0x28>
    1548:	9f 3f       	cpi	r25, 0xFF	; 255
    154a:	19 f4       	brne	.+6      	; 0x1552 <__addsf3+0x24>
    154c:	26 f4       	brtc	.+8      	; 0x1556 <__addsf3+0x28>
    154e:	0c 94 69 0c 	jmp	0x18d2	; 0x18d2 <__fp_nan>
    1552:	0e f4       	brtc	.+2      	; 0x1556 <__addsf3+0x28>
    1554:	e0 95       	com	r30
    1556:	e7 fb       	bst	r30, 7
    1558:	0c 94 63 0c 	jmp	0x18c6	; 0x18c6 <__fp_inf>

0000155c <__addsf3x>:
    155c:	e9 2f       	mov	r30, r25
    155e:	0e 94 b2 0c 	call	0x1964	; 0x1964 <__fp_split3>
    1562:	58 f3       	brcs	.-42     	; 0x153a <__addsf3+0xc>
    1564:	ba 17       	cp	r27, r26
    1566:	62 07       	cpc	r22, r18
    1568:	73 07       	cpc	r23, r19
    156a:	84 07       	cpc	r24, r20
    156c:	95 07       	cpc	r25, r21
    156e:	20 f0       	brcs	.+8      	; 0x1578 <__addsf3x+0x1c>
    1570:	79 f4       	brne	.+30     	; 0x1590 <__addsf3x+0x34>
    1572:	a6 f5       	brtc	.+104    	; 0x15dc <__addsf3x+0x80>
    1574:	0c 94 d4 0c 	jmp	0x19a8	; 0x19a8 <__fp_zero>
    1578:	0e f4       	brtc	.+2      	; 0x157c <__addsf3x+0x20>
    157a:	e0 95       	com	r30
    157c:	0b 2e       	mov	r0, r27
    157e:	ba 2f       	mov	r27, r26
    1580:	a0 2d       	mov	r26, r0
    1582:	0b 01       	movw	r0, r22
    1584:	b9 01       	movw	r22, r18
    1586:	90 01       	movw	r18, r0
    1588:	0c 01       	movw	r0, r24
    158a:	ca 01       	movw	r24, r20
    158c:	a0 01       	movw	r20, r0
    158e:	11 24       	eor	r1, r1
    1590:	ff 27       	eor	r31, r31
    1592:	59 1b       	sub	r21, r25
    1594:	99 f0       	breq	.+38     	; 0x15bc <__addsf3x+0x60>
    1596:	59 3f       	cpi	r21, 0xF9	; 249
    1598:	50 f4       	brcc	.+20     	; 0x15ae <__addsf3x+0x52>
    159a:	50 3e       	cpi	r21, 0xE0	; 224
    159c:	68 f1       	brcs	.+90     	; 0x15f8 <__addsf3x+0x9c>
    159e:	1a 16       	cp	r1, r26
    15a0:	f0 40       	sbci	r31, 0x00	; 0
    15a2:	a2 2f       	mov	r26, r18
    15a4:	23 2f       	mov	r18, r19
    15a6:	34 2f       	mov	r19, r20
    15a8:	44 27       	eor	r20, r20
    15aa:	58 5f       	subi	r21, 0xF8	; 248
    15ac:	f3 cf       	rjmp	.-26     	; 0x1594 <__addsf3x+0x38>
    15ae:	46 95       	lsr	r20
    15b0:	37 95       	ror	r19
    15b2:	27 95       	ror	r18
    15b4:	a7 95       	ror	r26
    15b6:	f0 40       	sbci	r31, 0x00	; 0
    15b8:	53 95       	inc	r21
    15ba:	c9 f7       	brne	.-14     	; 0x15ae <__addsf3x+0x52>
    15bc:	7e f4       	brtc	.+30     	; 0x15dc <__addsf3x+0x80>
    15be:	1f 16       	cp	r1, r31
    15c0:	ba 0b       	sbc	r27, r26
    15c2:	62 0b       	sbc	r22, r18
    15c4:	73 0b       	sbc	r23, r19
    15c6:	84 0b       	sbc	r24, r20
    15c8:	ba f0       	brmi	.+46     	; 0x15f8 <__addsf3x+0x9c>
    15ca:	91 50       	subi	r25, 0x01	; 1
    15cc:	a1 f0       	breq	.+40     	; 0x15f6 <__addsf3x+0x9a>
    15ce:	ff 0f       	add	r31, r31
    15d0:	bb 1f       	adc	r27, r27
    15d2:	66 1f       	adc	r22, r22
    15d4:	77 1f       	adc	r23, r23
    15d6:	88 1f       	adc	r24, r24
    15d8:	c2 f7       	brpl	.-16     	; 0x15ca <__addsf3x+0x6e>
    15da:	0e c0       	rjmp	.+28     	; 0x15f8 <__addsf3x+0x9c>
    15dc:	ba 0f       	add	r27, r26
    15de:	62 1f       	adc	r22, r18
    15e0:	73 1f       	adc	r23, r19
    15e2:	84 1f       	adc	r24, r20
    15e4:	48 f4       	brcc	.+18     	; 0x15f8 <__addsf3x+0x9c>
    15e6:	87 95       	ror	r24
    15e8:	77 95       	ror	r23
    15ea:	67 95       	ror	r22
    15ec:	b7 95       	ror	r27
    15ee:	f7 95       	ror	r31
    15f0:	9e 3f       	cpi	r25, 0xFE	; 254
    15f2:	08 f0       	brcs	.+2      	; 0x15f6 <__addsf3x+0x9a>
    15f4:	b0 cf       	rjmp	.-160    	; 0x1556 <__addsf3+0x28>
    15f6:	93 95       	inc	r25
    15f8:	88 0f       	add	r24, r24
    15fa:	08 f0       	brcs	.+2      	; 0x15fe <__addsf3x+0xa2>
    15fc:	99 27       	eor	r25, r25
    15fe:	ee 0f       	add	r30, r30
    1600:	97 95       	ror	r25
    1602:	87 95       	ror	r24
    1604:	08 95       	ret

00001606 <__cmpsf2>:
    1606:	0e 94 3f 0c 	call	0x187e	; 0x187e <__fp_cmp>
    160a:	08 f4       	brcc	.+2      	; 0x160e <__cmpsf2+0x8>
    160c:	81 e0       	ldi	r24, 0x01	; 1
    160e:	08 95       	ret

00001610 <__divsf3>:
    1610:	0e 94 1c 0b 	call	0x1638	; 0x1638 <__divsf3x>
    1614:	0c 94 a1 0c 	jmp	0x1942	; 0x1942 <__fp_round>
    1618:	0e 94 9a 0c 	call	0x1934	; 0x1934 <__fp_pscB>
    161c:	58 f0       	brcs	.+22     	; 0x1634 <__divsf3+0x24>
    161e:	0e 94 93 0c 	call	0x1926	; 0x1926 <__fp_pscA>
    1622:	40 f0       	brcs	.+16     	; 0x1634 <__divsf3+0x24>
    1624:	29 f4       	brne	.+10     	; 0x1630 <__divsf3+0x20>
    1626:	5f 3f       	cpi	r21, 0xFF	; 255
    1628:	29 f0       	breq	.+10     	; 0x1634 <__divsf3+0x24>
    162a:	0c 94 63 0c 	jmp	0x18c6	; 0x18c6 <__fp_inf>
    162e:	51 11       	cpse	r21, r1
    1630:	0c 94 d5 0c 	jmp	0x19aa	; 0x19aa <__fp_szero>
    1634:	0c 94 69 0c 	jmp	0x18d2	; 0x18d2 <__fp_nan>

00001638 <__divsf3x>:
    1638:	0e 94 b2 0c 	call	0x1964	; 0x1964 <__fp_split3>
    163c:	68 f3       	brcs	.-38     	; 0x1618 <__divsf3+0x8>

0000163e <__divsf3_pse>:
    163e:	99 23       	and	r25, r25
    1640:	b1 f3       	breq	.-20     	; 0x162e <__divsf3+0x1e>
    1642:	55 23       	and	r21, r21
    1644:	91 f3       	breq	.-28     	; 0x162a <__divsf3+0x1a>
    1646:	95 1b       	sub	r25, r21
    1648:	55 0b       	sbc	r21, r21
    164a:	bb 27       	eor	r27, r27
    164c:	aa 27       	eor	r26, r26
    164e:	62 17       	cp	r22, r18
    1650:	73 07       	cpc	r23, r19
    1652:	84 07       	cpc	r24, r20
    1654:	38 f0       	brcs	.+14     	; 0x1664 <__divsf3_pse+0x26>
    1656:	9f 5f       	subi	r25, 0xFF	; 255
    1658:	5f 4f       	sbci	r21, 0xFF	; 255
    165a:	22 0f       	add	r18, r18
    165c:	33 1f       	adc	r19, r19
    165e:	44 1f       	adc	r20, r20
    1660:	aa 1f       	adc	r26, r26
    1662:	a9 f3       	breq	.-22     	; 0x164e <__divsf3_pse+0x10>
    1664:	35 d0       	rcall	.+106    	; 0x16d0 <__divsf3_pse+0x92>
    1666:	0e 2e       	mov	r0, r30
    1668:	3a f0       	brmi	.+14     	; 0x1678 <__divsf3_pse+0x3a>
    166a:	e0 e8       	ldi	r30, 0x80	; 128
    166c:	32 d0       	rcall	.+100    	; 0x16d2 <__divsf3_pse+0x94>
    166e:	91 50       	subi	r25, 0x01	; 1
    1670:	50 40       	sbci	r21, 0x00	; 0
    1672:	e6 95       	lsr	r30
    1674:	00 1c       	adc	r0, r0
    1676:	ca f7       	brpl	.-14     	; 0x166a <__divsf3_pse+0x2c>
    1678:	2b d0       	rcall	.+86     	; 0x16d0 <__divsf3_pse+0x92>
    167a:	fe 2f       	mov	r31, r30
    167c:	29 d0       	rcall	.+82     	; 0x16d0 <__divsf3_pse+0x92>
    167e:	66 0f       	add	r22, r22
    1680:	77 1f       	adc	r23, r23
    1682:	88 1f       	adc	r24, r24
    1684:	bb 1f       	adc	r27, r27
    1686:	26 17       	cp	r18, r22
    1688:	37 07       	cpc	r19, r23
    168a:	48 07       	cpc	r20, r24
    168c:	ab 07       	cpc	r26, r27
    168e:	b0 e8       	ldi	r27, 0x80	; 128
    1690:	09 f0       	breq	.+2      	; 0x1694 <__divsf3_pse+0x56>
    1692:	bb 0b       	sbc	r27, r27
    1694:	80 2d       	mov	r24, r0
    1696:	bf 01       	movw	r22, r30
    1698:	ff 27       	eor	r31, r31
    169a:	93 58       	subi	r25, 0x83	; 131
    169c:	5f 4f       	sbci	r21, 0xFF	; 255
    169e:	3a f0       	brmi	.+14     	; 0x16ae <__divsf3_pse+0x70>
    16a0:	9e 3f       	cpi	r25, 0xFE	; 254
    16a2:	51 05       	cpc	r21, r1
    16a4:	78 f0       	brcs	.+30     	; 0x16c4 <__divsf3_pse+0x86>
    16a6:	0c 94 63 0c 	jmp	0x18c6	; 0x18c6 <__fp_inf>
    16aa:	0c 94 d5 0c 	jmp	0x19aa	; 0x19aa <__fp_szero>
    16ae:	5f 3f       	cpi	r21, 0xFF	; 255
    16b0:	e4 f3       	brlt	.-8      	; 0x16aa <__divsf3_pse+0x6c>
    16b2:	98 3e       	cpi	r25, 0xE8	; 232
    16b4:	d4 f3       	brlt	.-12     	; 0x16aa <__divsf3_pse+0x6c>
    16b6:	86 95       	lsr	r24
    16b8:	77 95       	ror	r23
    16ba:	67 95       	ror	r22
    16bc:	b7 95       	ror	r27
    16be:	f7 95       	ror	r31
    16c0:	9f 5f       	subi	r25, 0xFF	; 255
    16c2:	c9 f7       	brne	.-14     	; 0x16b6 <__divsf3_pse+0x78>
    16c4:	88 0f       	add	r24, r24
    16c6:	91 1d       	adc	r25, r1
    16c8:	96 95       	lsr	r25
    16ca:	87 95       	ror	r24
    16cc:	97 f9       	bld	r25, 7
    16ce:	08 95       	ret
    16d0:	e1 e0       	ldi	r30, 0x01	; 1
    16d2:	66 0f       	add	r22, r22
    16d4:	77 1f       	adc	r23, r23
    16d6:	88 1f       	adc	r24, r24
    16d8:	bb 1f       	adc	r27, r27
    16da:	62 17       	cp	r22, r18
    16dc:	73 07       	cpc	r23, r19
    16de:	84 07       	cpc	r24, r20
    16e0:	ba 07       	cpc	r27, r26
    16e2:	20 f0       	brcs	.+8      	; 0x16ec <__divsf3_pse+0xae>
    16e4:	62 1b       	sub	r22, r18
    16e6:	73 0b       	sbc	r23, r19
    16e8:	84 0b       	sbc	r24, r20
    16ea:	ba 0b       	sbc	r27, r26
    16ec:	ee 1f       	adc	r30, r30
    16ee:	88 f7       	brcc	.-30     	; 0x16d2 <__divsf3_pse+0x94>
    16f0:	e0 95       	com	r30
    16f2:	08 95       	ret
    16f4:	29 f4       	brne	.+10     	; 0x1700 <__divsf3_pse+0xc2>
    16f6:	16 f0       	brts	.+4      	; 0x16fc <__divsf3_pse+0xbe>
    16f8:	0c 94 63 0c 	jmp	0x18c6	; 0x18c6 <__fp_inf>
    16fc:	0c 94 d4 0c 	jmp	0x19a8	; 0x19a8 <__fp_zero>
    1700:	0c 94 69 0c 	jmp	0x18d2	; 0x18d2 <__fp_nan>

00001704 <exp>:
    1704:	0e 94 ba 0c 	call	0x1974	; 0x1974 <__fp_splitA>
    1708:	a8 f3       	brcs	.-22     	; 0x16f4 <__divsf3_pse+0xb6>
    170a:	96 38       	cpi	r25, 0x86	; 134
    170c:	a0 f7       	brcc	.-24     	; 0x16f6 <__divsf3_pse+0xb8>
    170e:	07 f8       	bld	r0, 7
    1710:	0f 92       	push	r0
    1712:	e8 94       	clt
    1714:	2b e3       	ldi	r18, 0x3B	; 59
    1716:	3a ea       	ldi	r19, 0xAA	; 170
    1718:	48 eb       	ldi	r20, 0xB8	; 184
    171a:	5f e7       	ldi	r21, 0x7F	; 127
    171c:	0e 94 6c 0d 	call	0x1ad8	; 0x1ad8 <__mulsf3_pse>
    1720:	0f 92       	push	r0
    1722:	0f 92       	push	r0
    1724:	0f 92       	push	r0
    1726:	4d b7       	in	r20, 0x3d	; 61
    1728:	5e b7       	in	r21, 0x3e	; 62
    172a:	0f 92       	push	r0
    172c:	0e 94 22 0d 	call	0x1a44	; 0x1a44 <modf>
    1730:	ec e7       	ldi	r30, 0x7C	; 124
    1732:	f0 e0       	ldi	r31, 0x00	; 0
    1734:	0e 94 6c 0c 	call	0x18d8	; 0x18d8 <__fp_powser>
    1738:	4f 91       	pop	r20
    173a:	5f 91       	pop	r21
    173c:	ef 91       	pop	r30
    173e:	ff 91       	pop	r31
    1740:	e5 95       	asr	r30
    1742:	ee 1f       	adc	r30, r30
    1744:	ff 1f       	adc	r31, r31
    1746:	49 f0       	breq	.+18     	; 0x175a <exp+0x56>
    1748:	fe 57       	subi	r31, 0x7E	; 126
    174a:	e0 68       	ori	r30, 0x80	; 128
    174c:	44 27       	eor	r20, r20
    174e:	ee 0f       	add	r30, r30
    1750:	44 1f       	adc	r20, r20
    1752:	fa 95       	dec	r31
    1754:	e1 f7       	brne	.-8      	; 0x174e <exp+0x4a>
    1756:	41 95       	neg	r20
    1758:	55 0b       	sbc	r21, r21
    175a:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <ldexp>
    175e:	0f 90       	pop	r0
    1760:	07 fe       	sbrs	r0, 7
    1762:	0c 94 e0 0c 	jmp	0x19c0	; 0x19c0 <inverse>
    1766:	08 95       	ret

00001768 <__fixunssfsi>:
    1768:	0e 94 ba 0c 	call	0x1974	; 0x1974 <__fp_splitA>
    176c:	88 f0       	brcs	.+34     	; 0x1790 <__fixunssfsi+0x28>
    176e:	9f 57       	subi	r25, 0x7F	; 127
    1770:	98 f0       	brcs	.+38     	; 0x1798 <__fixunssfsi+0x30>
    1772:	b9 2f       	mov	r27, r25
    1774:	99 27       	eor	r25, r25
    1776:	b7 51       	subi	r27, 0x17	; 23
    1778:	b0 f0       	brcs	.+44     	; 0x17a6 <__fixunssfsi+0x3e>
    177a:	e1 f0       	breq	.+56     	; 0x17b4 <__fixunssfsi+0x4c>
    177c:	66 0f       	add	r22, r22
    177e:	77 1f       	adc	r23, r23
    1780:	88 1f       	adc	r24, r24
    1782:	99 1f       	adc	r25, r25
    1784:	1a f0       	brmi	.+6      	; 0x178c <__fixunssfsi+0x24>
    1786:	ba 95       	dec	r27
    1788:	c9 f7       	brne	.-14     	; 0x177c <__fixunssfsi+0x14>
    178a:	14 c0       	rjmp	.+40     	; 0x17b4 <__fixunssfsi+0x4c>
    178c:	b1 30       	cpi	r27, 0x01	; 1
    178e:	91 f0       	breq	.+36     	; 0x17b4 <__fixunssfsi+0x4c>
    1790:	0e 94 d4 0c 	call	0x19a8	; 0x19a8 <__fp_zero>
    1794:	b1 e0       	ldi	r27, 0x01	; 1
    1796:	08 95       	ret
    1798:	0c 94 d4 0c 	jmp	0x19a8	; 0x19a8 <__fp_zero>
    179c:	67 2f       	mov	r22, r23
    179e:	78 2f       	mov	r23, r24
    17a0:	88 27       	eor	r24, r24
    17a2:	b8 5f       	subi	r27, 0xF8	; 248
    17a4:	39 f0       	breq	.+14     	; 0x17b4 <__fixunssfsi+0x4c>
    17a6:	b9 3f       	cpi	r27, 0xF9	; 249
    17a8:	cc f3       	brlt	.-14     	; 0x179c <__fixunssfsi+0x34>
    17aa:	86 95       	lsr	r24
    17ac:	77 95       	ror	r23
    17ae:	67 95       	ror	r22
    17b0:	b3 95       	inc	r27
    17b2:	d9 f7       	brne	.-10     	; 0x17aa <__fixunssfsi+0x42>
    17b4:	3e f4       	brtc	.+14     	; 0x17c4 <__fixunssfsi+0x5c>
    17b6:	90 95       	com	r25
    17b8:	80 95       	com	r24
    17ba:	70 95       	com	r23
    17bc:	61 95       	neg	r22
    17be:	7f 4f       	sbci	r23, 0xFF	; 255
    17c0:	8f 4f       	sbci	r24, 0xFF	; 255
    17c2:	9f 4f       	sbci	r25, 0xFF	; 255
    17c4:	08 95       	ret

000017c6 <__floatunsisf>:
    17c6:	e8 94       	clt
    17c8:	09 c0       	rjmp	.+18     	; 0x17dc <__floatsisf+0x12>

000017ca <__floatsisf>:
    17ca:	97 fb       	bst	r25, 7
    17cc:	3e f4       	brtc	.+14     	; 0x17dc <__floatsisf+0x12>
    17ce:	90 95       	com	r25
    17d0:	80 95       	com	r24
    17d2:	70 95       	com	r23
    17d4:	61 95       	neg	r22
    17d6:	7f 4f       	sbci	r23, 0xFF	; 255
    17d8:	8f 4f       	sbci	r24, 0xFF	; 255
    17da:	9f 4f       	sbci	r25, 0xFF	; 255
    17dc:	99 23       	and	r25, r25
    17de:	a9 f0       	breq	.+42     	; 0x180a <__floatsisf+0x40>
    17e0:	f9 2f       	mov	r31, r25
    17e2:	96 e9       	ldi	r25, 0x96	; 150
    17e4:	bb 27       	eor	r27, r27
    17e6:	93 95       	inc	r25
    17e8:	f6 95       	lsr	r31
    17ea:	87 95       	ror	r24
    17ec:	77 95       	ror	r23
    17ee:	67 95       	ror	r22
    17f0:	b7 95       	ror	r27
    17f2:	f1 11       	cpse	r31, r1
    17f4:	f8 cf       	rjmp	.-16     	; 0x17e6 <__floatsisf+0x1c>
    17f6:	fa f4       	brpl	.+62     	; 0x1836 <__floatsisf+0x6c>
    17f8:	bb 0f       	add	r27, r27
    17fa:	11 f4       	brne	.+4      	; 0x1800 <__floatsisf+0x36>
    17fc:	60 ff       	sbrs	r22, 0
    17fe:	1b c0       	rjmp	.+54     	; 0x1836 <__floatsisf+0x6c>
    1800:	6f 5f       	subi	r22, 0xFF	; 255
    1802:	7f 4f       	sbci	r23, 0xFF	; 255
    1804:	8f 4f       	sbci	r24, 0xFF	; 255
    1806:	9f 4f       	sbci	r25, 0xFF	; 255
    1808:	16 c0       	rjmp	.+44     	; 0x1836 <__floatsisf+0x6c>
    180a:	88 23       	and	r24, r24
    180c:	11 f0       	breq	.+4      	; 0x1812 <__floatsisf+0x48>
    180e:	96 e9       	ldi	r25, 0x96	; 150
    1810:	11 c0       	rjmp	.+34     	; 0x1834 <__floatsisf+0x6a>
    1812:	77 23       	and	r23, r23
    1814:	21 f0       	breq	.+8      	; 0x181e <__floatsisf+0x54>
    1816:	9e e8       	ldi	r25, 0x8E	; 142
    1818:	87 2f       	mov	r24, r23
    181a:	76 2f       	mov	r23, r22
    181c:	05 c0       	rjmp	.+10     	; 0x1828 <__floatsisf+0x5e>
    181e:	66 23       	and	r22, r22
    1820:	71 f0       	breq	.+28     	; 0x183e <__floatsisf+0x74>
    1822:	96 e8       	ldi	r25, 0x86	; 134
    1824:	86 2f       	mov	r24, r22
    1826:	70 e0       	ldi	r23, 0x00	; 0
    1828:	60 e0       	ldi	r22, 0x00	; 0
    182a:	2a f0       	brmi	.+10     	; 0x1836 <__floatsisf+0x6c>
    182c:	9a 95       	dec	r25
    182e:	66 0f       	add	r22, r22
    1830:	77 1f       	adc	r23, r23
    1832:	88 1f       	adc	r24, r24
    1834:	da f7       	brpl	.-10     	; 0x182c <__floatsisf+0x62>
    1836:	88 0f       	add	r24, r24
    1838:	96 95       	lsr	r25
    183a:	87 95       	ror	r24
    183c:	97 f9       	bld	r25, 7
    183e:	08 95       	ret

00001840 <fmin>:
    1840:	99 0f       	add	r25, r25
    1842:	bb 0b       	sbc	r27, r27
    1844:	55 0f       	add	r21, r21
    1846:	aa 0b       	sbc	r26, r26
    1848:	e0 e8       	ldi	r30, 0x80	; 128
    184a:	fe ef       	ldi	r31, 0xFE	; 254
    184c:	16 16       	cp	r1, r22
    184e:	17 06       	cpc	r1, r23
    1850:	e8 07       	cpc	r30, r24
    1852:	f9 07       	cpc	r31, r25
    1854:	70 f0       	brcs	.+28     	; 0x1872 <fmin+0x32>
    1856:	12 16       	cp	r1, r18
    1858:	13 06       	cpc	r1, r19
    185a:	e4 07       	cpc	r30, r20
    185c:	f5 07       	cpc	r31, r21
    185e:	60 f0       	brcs	.+24     	; 0x1878 <fmin+0x38>
    1860:	ba 17       	cp	r27, r26
    1862:	54 f0       	brlt	.+20     	; 0x1878 <fmin+0x38>
    1864:	31 f4       	brne	.+12     	; 0x1872 <fmin+0x32>
    1866:	26 17       	cp	r18, r22
    1868:	37 07       	cpc	r19, r23
    186a:	48 07       	cpc	r20, r24
    186c:	59 07       	cpc	r21, r25
    186e:	a7 95       	ror	r26
    1870:	1b f4       	brvc	.+6      	; 0x1878 <fmin+0x38>
    1872:	b9 01       	movw	r22, r18
    1874:	ca 01       	movw	r24, r20
    1876:	ba 2f       	mov	r27, r26
    1878:	b6 95       	lsr	r27
    187a:	97 95       	ror	r25
    187c:	08 95       	ret

0000187e <__fp_cmp>:
    187e:	99 0f       	add	r25, r25
    1880:	00 08       	sbc	r0, r0
    1882:	55 0f       	add	r21, r21
    1884:	aa 0b       	sbc	r26, r26
    1886:	e0 e8       	ldi	r30, 0x80	; 128
    1888:	fe ef       	ldi	r31, 0xFE	; 254
    188a:	16 16       	cp	r1, r22
    188c:	17 06       	cpc	r1, r23
    188e:	e8 07       	cpc	r30, r24
    1890:	f9 07       	cpc	r31, r25
    1892:	c0 f0       	brcs	.+48     	; 0x18c4 <__fp_cmp+0x46>
    1894:	12 16       	cp	r1, r18
    1896:	13 06       	cpc	r1, r19
    1898:	e4 07       	cpc	r30, r20
    189a:	f5 07       	cpc	r31, r21
    189c:	98 f0       	brcs	.+38     	; 0x18c4 <__fp_cmp+0x46>
    189e:	62 1b       	sub	r22, r18
    18a0:	73 0b       	sbc	r23, r19
    18a2:	84 0b       	sbc	r24, r20
    18a4:	95 0b       	sbc	r25, r21
    18a6:	39 f4       	brne	.+14     	; 0x18b6 <__fp_cmp+0x38>
    18a8:	0a 26       	eor	r0, r26
    18aa:	61 f0       	breq	.+24     	; 0x18c4 <__fp_cmp+0x46>
    18ac:	23 2b       	or	r18, r19
    18ae:	24 2b       	or	r18, r20
    18b0:	25 2b       	or	r18, r21
    18b2:	21 f4       	brne	.+8      	; 0x18bc <__fp_cmp+0x3e>
    18b4:	08 95       	ret
    18b6:	0a 26       	eor	r0, r26
    18b8:	09 f4       	brne	.+2      	; 0x18bc <__fp_cmp+0x3e>
    18ba:	a1 40       	sbci	r26, 0x01	; 1
    18bc:	a6 95       	lsr	r26
    18be:	8f ef       	ldi	r24, 0xFF	; 255
    18c0:	81 1d       	adc	r24, r1
    18c2:	81 1d       	adc	r24, r1
    18c4:	08 95       	ret

000018c6 <__fp_inf>:
    18c6:	97 f9       	bld	r25, 7
    18c8:	9f 67       	ori	r25, 0x7F	; 127
    18ca:	80 e8       	ldi	r24, 0x80	; 128
    18cc:	70 e0       	ldi	r23, 0x00	; 0
    18ce:	60 e0       	ldi	r22, 0x00	; 0
    18d0:	08 95       	ret

000018d2 <__fp_nan>:
    18d2:	9f ef       	ldi	r25, 0xFF	; 255
    18d4:	80 ec       	ldi	r24, 0xC0	; 192
    18d6:	08 95       	ret

000018d8 <__fp_powser>:
    18d8:	df 93       	push	r29
    18da:	cf 93       	push	r28
    18dc:	1f 93       	push	r17
    18de:	0f 93       	push	r16
    18e0:	ff 92       	push	r15
    18e2:	ef 92       	push	r14
    18e4:	df 92       	push	r13
    18e6:	7b 01       	movw	r14, r22
    18e8:	8c 01       	movw	r16, r24
    18ea:	68 94       	set
    18ec:	06 c0       	rjmp	.+12     	; 0x18fa <__fp_powser+0x22>
    18ee:	da 2e       	mov	r13, r26
    18f0:	ef 01       	movw	r28, r30
    18f2:	0e 94 69 0d 	call	0x1ad2	; 0x1ad2 <__mulsf3x>
    18f6:	fe 01       	movw	r30, r28
    18f8:	e8 94       	clt
    18fa:	a5 91       	lpm	r26, Z+
    18fc:	25 91       	lpm	r18, Z+
    18fe:	35 91       	lpm	r19, Z+
    1900:	45 91       	lpm	r20, Z+
    1902:	55 91       	lpm	r21, Z+
    1904:	a6 f3       	brts	.-24     	; 0x18ee <__fp_powser+0x16>
    1906:	ef 01       	movw	r28, r30
    1908:	0e 94 ae 0a 	call	0x155c	; 0x155c <__addsf3x>
    190c:	fe 01       	movw	r30, r28
    190e:	97 01       	movw	r18, r14
    1910:	a8 01       	movw	r20, r16
    1912:	da 94       	dec	r13
    1914:	69 f7       	brne	.-38     	; 0x18f0 <__fp_powser+0x18>
    1916:	df 90       	pop	r13
    1918:	ef 90       	pop	r14
    191a:	ff 90       	pop	r15
    191c:	0f 91       	pop	r16
    191e:	1f 91       	pop	r17
    1920:	cf 91       	pop	r28
    1922:	df 91       	pop	r29
    1924:	08 95       	ret

00001926 <__fp_pscA>:
    1926:	00 24       	eor	r0, r0
    1928:	0a 94       	dec	r0
    192a:	16 16       	cp	r1, r22
    192c:	17 06       	cpc	r1, r23
    192e:	18 06       	cpc	r1, r24
    1930:	09 06       	cpc	r0, r25
    1932:	08 95       	ret

00001934 <__fp_pscB>:
    1934:	00 24       	eor	r0, r0
    1936:	0a 94       	dec	r0
    1938:	12 16       	cp	r1, r18
    193a:	13 06       	cpc	r1, r19
    193c:	14 06       	cpc	r1, r20
    193e:	05 06       	cpc	r0, r21
    1940:	08 95       	ret

00001942 <__fp_round>:
    1942:	09 2e       	mov	r0, r25
    1944:	03 94       	inc	r0
    1946:	00 0c       	add	r0, r0
    1948:	11 f4       	brne	.+4      	; 0x194e <__fp_round+0xc>
    194a:	88 23       	and	r24, r24
    194c:	52 f0       	brmi	.+20     	; 0x1962 <__fp_round+0x20>
    194e:	bb 0f       	add	r27, r27
    1950:	40 f4       	brcc	.+16     	; 0x1962 <__fp_round+0x20>
    1952:	bf 2b       	or	r27, r31
    1954:	11 f4       	brne	.+4      	; 0x195a <__fp_round+0x18>
    1956:	60 ff       	sbrs	r22, 0
    1958:	04 c0       	rjmp	.+8      	; 0x1962 <__fp_round+0x20>
    195a:	6f 5f       	subi	r22, 0xFF	; 255
    195c:	7f 4f       	sbci	r23, 0xFF	; 255
    195e:	8f 4f       	sbci	r24, 0xFF	; 255
    1960:	9f 4f       	sbci	r25, 0xFF	; 255
    1962:	08 95       	ret

00001964 <__fp_split3>:
    1964:	57 fd       	sbrc	r21, 7
    1966:	90 58       	subi	r25, 0x80	; 128
    1968:	44 0f       	add	r20, r20
    196a:	55 1f       	adc	r21, r21
    196c:	59 f0       	breq	.+22     	; 0x1984 <__fp_splitA+0x10>
    196e:	5f 3f       	cpi	r21, 0xFF	; 255
    1970:	71 f0       	breq	.+28     	; 0x198e <__fp_splitA+0x1a>
    1972:	47 95       	ror	r20

00001974 <__fp_splitA>:
    1974:	88 0f       	add	r24, r24
    1976:	97 fb       	bst	r25, 7
    1978:	99 1f       	adc	r25, r25
    197a:	61 f0       	breq	.+24     	; 0x1994 <__fp_splitA+0x20>
    197c:	9f 3f       	cpi	r25, 0xFF	; 255
    197e:	79 f0       	breq	.+30     	; 0x199e <__fp_splitA+0x2a>
    1980:	87 95       	ror	r24
    1982:	08 95       	ret
    1984:	12 16       	cp	r1, r18
    1986:	13 06       	cpc	r1, r19
    1988:	14 06       	cpc	r1, r20
    198a:	55 1f       	adc	r21, r21
    198c:	f2 cf       	rjmp	.-28     	; 0x1972 <__fp_split3+0xe>
    198e:	46 95       	lsr	r20
    1990:	f1 df       	rcall	.-30     	; 0x1974 <__fp_splitA>
    1992:	08 c0       	rjmp	.+16     	; 0x19a4 <__fp_splitA+0x30>
    1994:	16 16       	cp	r1, r22
    1996:	17 06       	cpc	r1, r23
    1998:	18 06       	cpc	r1, r24
    199a:	99 1f       	adc	r25, r25
    199c:	f1 cf       	rjmp	.-30     	; 0x1980 <__fp_splitA+0xc>
    199e:	86 95       	lsr	r24
    19a0:	71 05       	cpc	r23, r1
    19a2:	61 05       	cpc	r22, r1
    19a4:	08 94       	sec
    19a6:	08 95       	ret

000019a8 <__fp_zero>:
    19a8:	e8 94       	clt

000019aa <__fp_szero>:
    19aa:	bb 27       	eor	r27, r27
    19ac:	66 27       	eor	r22, r22
    19ae:	77 27       	eor	r23, r23
    19b0:	cb 01       	movw	r24, r22
    19b2:	97 f9       	bld	r25, 7
    19b4:	08 95       	ret

000019b6 <__gesf2>:
    19b6:	0e 94 3f 0c 	call	0x187e	; 0x187e <__fp_cmp>
    19ba:	08 f4       	brcc	.+2      	; 0x19be <__gesf2+0x8>
    19bc:	8f ef       	ldi	r24, 0xFF	; 255
    19be:	08 95       	ret

000019c0 <inverse>:
    19c0:	9b 01       	movw	r18, r22
    19c2:	ac 01       	movw	r20, r24
    19c4:	60 e0       	ldi	r22, 0x00	; 0
    19c6:	70 e0       	ldi	r23, 0x00	; 0
    19c8:	80 e8       	ldi	r24, 0x80	; 128
    19ca:	9f e3       	ldi	r25, 0x3F	; 63
    19cc:	0c 94 08 0b 	jmp	0x1610	; 0x1610 <__divsf3>
    19d0:	0c 94 63 0c 	jmp	0x18c6	; 0x18c6 <__fp_inf>
    19d4:	0c 94 cb 0d 	jmp	0x1b96	; 0x1b96 <__fp_mpack>

000019d8 <ldexp>:
    19d8:	0e 94 ba 0c 	call	0x1974	; 0x1974 <__fp_splitA>
    19dc:	d8 f3       	brcs	.-10     	; 0x19d4 <inverse+0x14>
    19de:	99 23       	and	r25, r25
    19e0:	c9 f3       	breq	.-14     	; 0x19d4 <inverse+0x14>
    19e2:	94 0f       	add	r25, r20
    19e4:	51 1d       	adc	r21, r1
    19e6:	a3 f3       	brvs	.-24     	; 0x19d0 <inverse+0x10>
    19e8:	91 50       	subi	r25, 0x01	; 1
    19ea:	50 40       	sbci	r21, 0x00	; 0
    19ec:	94 f0       	brlt	.+36     	; 0x1a12 <ldexp+0x3a>
    19ee:	59 f0       	breq	.+22     	; 0x1a06 <ldexp+0x2e>
    19f0:	88 23       	and	r24, r24
    19f2:	32 f0       	brmi	.+12     	; 0x1a00 <ldexp+0x28>
    19f4:	66 0f       	add	r22, r22
    19f6:	77 1f       	adc	r23, r23
    19f8:	88 1f       	adc	r24, r24
    19fa:	91 50       	subi	r25, 0x01	; 1
    19fc:	50 40       	sbci	r21, 0x00	; 0
    19fe:	c1 f7       	brne	.-16     	; 0x19f0 <ldexp+0x18>
    1a00:	9e 3f       	cpi	r25, 0xFE	; 254
    1a02:	51 05       	cpc	r21, r1
    1a04:	2c f7       	brge	.-54     	; 0x19d0 <inverse+0x10>
    1a06:	88 0f       	add	r24, r24
    1a08:	91 1d       	adc	r25, r1
    1a0a:	96 95       	lsr	r25
    1a0c:	87 95       	ror	r24
    1a0e:	97 f9       	bld	r25, 7
    1a10:	08 95       	ret
    1a12:	5f 3f       	cpi	r21, 0xFF	; 255
    1a14:	ac f0       	brlt	.+42     	; 0x1a40 <ldexp+0x68>
    1a16:	98 3e       	cpi	r25, 0xE8	; 232
    1a18:	9c f0       	brlt	.+38     	; 0x1a40 <ldexp+0x68>
    1a1a:	bb 27       	eor	r27, r27
    1a1c:	86 95       	lsr	r24
    1a1e:	77 95       	ror	r23
    1a20:	67 95       	ror	r22
    1a22:	b7 95       	ror	r27
    1a24:	08 f4       	brcc	.+2      	; 0x1a28 <ldexp+0x50>
    1a26:	b1 60       	ori	r27, 0x01	; 1
    1a28:	93 95       	inc	r25
    1a2a:	c1 f7       	brne	.-16     	; 0x1a1c <ldexp+0x44>
    1a2c:	bb 0f       	add	r27, r27
    1a2e:	58 f7       	brcc	.-42     	; 0x1a06 <ldexp+0x2e>
    1a30:	11 f4       	brne	.+4      	; 0x1a36 <ldexp+0x5e>
    1a32:	60 ff       	sbrs	r22, 0
    1a34:	e8 cf       	rjmp	.-48     	; 0x1a06 <ldexp+0x2e>
    1a36:	6f 5f       	subi	r22, 0xFF	; 255
    1a38:	7f 4f       	sbci	r23, 0xFF	; 255
    1a3a:	8f 4f       	sbci	r24, 0xFF	; 255
    1a3c:	9f 4f       	sbci	r25, 0xFF	; 255
    1a3e:	e3 cf       	rjmp	.-58     	; 0x1a06 <ldexp+0x2e>
    1a40:	0c 94 d5 0c 	jmp	0x19aa	; 0x19aa <__fp_szero>

00001a44 <modf>:
    1a44:	fa 01       	movw	r30, r20
    1a46:	dc 01       	movw	r26, r24
    1a48:	aa 0f       	add	r26, r26
    1a4a:	bb 1f       	adc	r27, r27
    1a4c:	9b 01       	movw	r18, r22
    1a4e:	ac 01       	movw	r20, r24
    1a50:	bf 57       	subi	r27, 0x7F	; 127
    1a52:	28 f4       	brcc	.+10     	; 0x1a5e <modf+0x1a>
    1a54:	22 27       	eor	r18, r18
    1a56:	33 27       	eor	r19, r19
    1a58:	44 27       	eor	r20, r20
    1a5a:	50 78       	andi	r21, 0x80	; 128
    1a5c:	20 c0       	rjmp	.+64     	; 0x1a9e <modf+0x5a>
    1a5e:	b7 51       	subi	r27, 0x17	; 23
    1a60:	90 f4       	brcc	.+36     	; 0x1a86 <modf+0x42>
    1a62:	ab 2f       	mov	r26, r27
    1a64:	00 24       	eor	r0, r0
    1a66:	46 95       	lsr	r20
    1a68:	37 95       	ror	r19
    1a6a:	27 95       	ror	r18
    1a6c:	01 1c       	adc	r0, r1
    1a6e:	a3 95       	inc	r26
    1a70:	d2 f3       	brmi	.-12     	; 0x1a66 <modf+0x22>
    1a72:	00 20       	and	r0, r0
    1a74:	71 f0       	breq	.+28     	; 0x1a92 <modf+0x4e>
    1a76:	22 0f       	add	r18, r18
    1a78:	33 1f       	adc	r19, r19
    1a7a:	44 1f       	adc	r20, r20
    1a7c:	b3 95       	inc	r27
    1a7e:	da f3       	brmi	.-10     	; 0x1a76 <modf+0x32>
    1a80:	0e d0       	rcall	.+28     	; 0x1a9e <modf+0x5a>
    1a82:	0c 94 96 0a 	jmp	0x152c	; 0x152c <__subsf3>
    1a86:	61 30       	cpi	r22, 0x01	; 1
    1a88:	71 05       	cpc	r23, r1
    1a8a:	a0 e8       	ldi	r26, 0x80	; 128
    1a8c:	8a 07       	cpc	r24, r26
    1a8e:	b9 46       	sbci	r27, 0x69	; 105
    1a90:	30 f4       	brcc	.+12     	; 0x1a9e <modf+0x5a>
    1a92:	9b 01       	movw	r18, r22
    1a94:	ac 01       	movw	r20, r24
    1a96:	66 27       	eor	r22, r22
    1a98:	77 27       	eor	r23, r23
    1a9a:	88 27       	eor	r24, r24
    1a9c:	90 78       	andi	r25, 0x80	; 128
    1a9e:	30 96       	adiw	r30, 0x00	; 0
    1aa0:	21 f0       	breq	.+8      	; 0x1aaa <modf+0x66>
    1aa2:	20 83       	st	Z, r18
    1aa4:	31 83       	std	Z+1, r19	; 0x01
    1aa6:	42 83       	std	Z+2, r20	; 0x02
    1aa8:	53 83       	std	Z+3, r21	; 0x03
    1aaa:	08 95       	ret

00001aac <__mulsf3>:
    1aac:	0e 94 69 0d 	call	0x1ad2	; 0x1ad2 <__mulsf3x>
    1ab0:	0c 94 a1 0c 	jmp	0x1942	; 0x1942 <__fp_round>
    1ab4:	0e 94 93 0c 	call	0x1926	; 0x1926 <__fp_pscA>
    1ab8:	38 f0       	brcs	.+14     	; 0x1ac8 <__mulsf3+0x1c>
    1aba:	0e 94 9a 0c 	call	0x1934	; 0x1934 <__fp_pscB>
    1abe:	20 f0       	brcs	.+8      	; 0x1ac8 <__mulsf3+0x1c>
    1ac0:	95 23       	and	r25, r21
    1ac2:	11 f0       	breq	.+4      	; 0x1ac8 <__mulsf3+0x1c>
    1ac4:	0c 94 63 0c 	jmp	0x18c6	; 0x18c6 <__fp_inf>
    1ac8:	0c 94 69 0c 	jmp	0x18d2	; 0x18d2 <__fp_nan>
    1acc:	11 24       	eor	r1, r1
    1ace:	0c 94 d5 0c 	jmp	0x19aa	; 0x19aa <__fp_szero>

00001ad2 <__mulsf3x>:
    1ad2:	0e 94 b2 0c 	call	0x1964	; 0x1964 <__fp_split3>
    1ad6:	70 f3       	brcs	.-36     	; 0x1ab4 <__mulsf3+0x8>

00001ad8 <__mulsf3_pse>:
    1ad8:	95 9f       	mul	r25, r21
    1ada:	c1 f3       	breq	.-16     	; 0x1acc <__mulsf3+0x20>
    1adc:	95 0f       	add	r25, r21
    1ade:	50 e0       	ldi	r21, 0x00	; 0
    1ae0:	55 1f       	adc	r21, r21
    1ae2:	62 9f       	mul	r22, r18
    1ae4:	f0 01       	movw	r30, r0
    1ae6:	72 9f       	mul	r23, r18
    1ae8:	bb 27       	eor	r27, r27
    1aea:	f0 0d       	add	r31, r0
    1aec:	b1 1d       	adc	r27, r1
    1aee:	63 9f       	mul	r22, r19
    1af0:	aa 27       	eor	r26, r26
    1af2:	f0 0d       	add	r31, r0
    1af4:	b1 1d       	adc	r27, r1
    1af6:	aa 1f       	adc	r26, r26
    1af8:	64 9f       	mul	r22, r20
    1afa:	66 27       	eor	r22, r22
    1afc:	b0 0d       	add	r27, r0
    1afe:	a1 1d       	adc	r26, r1
    1b00:	66 1f       	adc	r22, r22
    1b02:	82 9f       	mul	r24, r18
    1b04:	22 27       	eor	r18, r18
    1b06:	b0 0d       	add	r27, r0
    1b08:	a1 1d       	adc	r26, r1
    1b0a:	62 1f       	adc	r22, r18
    1b0c:	73 9f       	mul	r23, r19
    1b0e:	b0 0d       	add	r27, r0
    1b10:	a1 1d       	adc	r26, r1
    1b12:	62 1f       	adc	r22, r18
    1b14:	83 9f       	mul	r24, r19
    1b16:	a0 0d       	add	r26, r0
    1b18:	61 1d       	adc	r22, r1
    1b1a:	22 1f       	adc	r18, r18
    1b1c:	74 9f       	mul	r23, r20
    1b1e:	33 27       	eor	r19, r19
    1b20:	a0 0d       	add	r26, r0
    1b22:	61 1d       	adc	r22, r1
    1b24:	23 1f       	adc	r18, r19
    1b26:	84 9f       	mul	r24, r20
    1b28:	60 0d       	add	r22, r0
    1b2a:	21 1d       	adc	r18, r1
    1b2c:	82 2f       	mov	r24, r18
    1b2e:	76 2f       	mov	r23, r22
    1b30:	6a 2f       	mov	r22, r26
    1b32:	11 24       	eor	r1, r1
    1b34:	9f 57       	subi	r25, 0x7F	; 127
    1b36:	50 40       	sbci	r21, 0x00	; 0
    1b38:	9a f0       	brmi	.+38     	; 0x1b60 <__mulsf3_pse+0x88>
    1b3a:	f1 f0       	breq	.+60     	; 0x1b78 <__mulsf3_pse+0xa0>
    1b3c:	88 23       	and	r24, r24
    1b3e:	4a f0       	brmi	.+18     	; 0x1b52 <__mulsf3_pse+0x7a>
    1b40:	ee 0f       	add	r30, r30
    1b42:	ff 1f       	adc	r31, r31
    1b44:	bb 1f       	adc	r27, r27
    1b46:	66 1f       	adc	r22, r22
    1b48:	77 1f       	adc	r23, r23
    1b4a:	88 1f       	adc	r24, r24
    1b4c:	91 50       	subi	r25, 0x01	; 1
    1b4e:	50 40       	sbci	r21, 0x00	; 0
    1b50:	a9 f7       	brne	.-22     	; 0x1b3c <__mulsf3_pse+0x64>
    1b52:	9e 3f       	cpi	r25, 0xFE	; 254
    1b54:	51 05       	cpc	r21, r1
    1b56:	80 f0       	brcs	.+32     	; 0x1b78 <__mulsf3_pse+0xa0>
    1b58:	0c 94 63 0c 	jmp	0x18c6	; 0x18c6 <__fp_inf>
    1b5c:	0c 94 d5 0c 	jmp	0x19aa	; 0x19aa <__fp_szero>
    1b60:	5f 3f       	cpi	r21, 0xFF	; 255
    1b62:	e4 f3       	brlt	.-8      	; 0x1b5c <__mulsf3_pse+0x84>
    1b64:	98 3e       	cpi	r25, 0xE8	; 232
    1b66:	d4 f3       	brlt	.-12     	; 0x1b5c <__mulsf3_pse+0x84>
    1b68:	86 95       	lsr	r24
    1b6a:	77 95       	ror	r23
    1b6c:	67 95       	ror	r22
    1b6e:	b7 95       	ror	r27
    1b70:	f7 95       	ror	r31
    1b72:	e7 95       	ror	r30
    1b74:	9f 5f       	subi	r25, 0xFF	; 255
    1b76:	c1 f7       	brne	.-16     	; 0x1b68 <__mulsf3_pse+0x90>
    1b78:	fe 2b       	or	r31, r30
    1b7a:	88 0f       	add	r24, r24
    1b7c:	91 1d       	adc	r25, r1
    1b7e:	96 95       	lsr	r25
    1b80:	87 95       	ror	r24
    1b82:	97 f9       	bld	r25, 7
    1b84:	08 95       	ret

00001b86 <sin>:
    1b86:	9f 93       	push	r25
    1b88:	0e 94 db 0d 	call	0x1bb6	; 0x1bb6 <__fp_rempio2>
    1b8c:	0f 90       	pop	r0
    1b8e:	07 fc       	sbrc	r0, 7
    1b90:	ee 5f       	subi	r30, 0xFE	; 254
    1b92:	0c 94 04 0e 	jmp	0x1c08	; 0x1c08 <__fp_sinus>

00001b96 <__fp_mpack>:
    1b96:	9f 3f       	cpi	r25, 0xFF	; 255
    1b98:	31 f0       	breq	.+12     	; 0x1ba6 <__fp_mpack_finite+0xc>

00001b9a <__fp_mpack_finite>:
    1b9a:	91 50       	subi	r25, 0x01	; 1
    1b9c:	20 f4       	brcc	.+8      	; 0x1ba6 <__fp_mpack_finite+0xc>
    1b9e:	87 95       	ror	r24
    1ba0:	77 95       	ror	r23
    1ba2:	67 95       	ror	r22
    1ba4:	b7 95       	ror	r27
    1ba6:	88 0f       	add	r24, r24
    1ba8:	91 1d       	adc	r25, r1
    1baa:	96 95       	lsr	r25
    1bac:	87 95       	ror	r24
    1bae:	97 f9       	bld	r25, 7
    1bb0:	08 95       	ret
    1bb2:	0c 94 69 0c 	jmp	0x18d2	; 0x18d2 <__fp_nan>

00001bb6 <__fp_rempio2>:
    1bb6:	0e 94 ba 0c 	call	0x1974	; 0x1974 <__fp_splitA>
    1bba:	d8 f3       	brcs	.-10     	; 0x1bb2 <__fp_mpack_finite+0x18>
    1bbc:	e8 94       	clt
    1bbe:	e0 e0       	ldi	r30, 0x00	; 0
    1bc0:	bb 27       	eor	r27, r27
    1bc2:	9f 57       	subi	r25, 0x7F	; 127
    1bc4:	f0 f0       	brcs	.+60     	; 0x1c02 <__fp_rempio2+0x4c>
    1bc6:	2a ed       	ldi	r18, 0xDA	; 218
    1bc8:	3f e0       	ldi	r19, 0x0F	; 15
    1bca:	49 ec       	ldi	r20, 0xC9	; 201
    1bcc:	06 c0       	rjmp	.+12     	; 0x1bda <__fp_rempio2+0x24>
    1bce:	ee 0f       	add	r30, r30
    1bd0:	bb 0f       	add	r27, r27
    1bd2:	66 1f       	adc	r22, r22
    1bd4:	77 1f       	adc	r23, r23
    1bd6:	88 1f       	adc	r24, r24
    1bd8:	28 f0       	brcs	.+10     	; 0x1be4 <__fp_rempio2+0x2e>
    1bda:	b2 3a       	cpi	r27, 0xA2	; 162
    1bdc:	62 07       	cpc	r22, r18
    1bde:	73 07       	cpc	r23, r19
    1be0:	84 07       	cpc	r24, r20
    1be2:	28 f0       	brcs	.+10     	; 0x1bee <__fp_rempio2+0x38>
    1be4:	b2 5a       	subi	r27, 0xA2	; 162
    1be6:	62 0b       	sbc	r22, r18
    1be8:	73 0b       	sbc	r23, r19
    1bea:	84 0b       	sbc	r24, r20
    1bec:	e3 95       	inc	r30
    1bee:	9a 95       	dec	r25
    1bf0:	72 f7       	brpl	.-36     	; 0x1bce <__fp_rempio2+0x18>
    1bf2:	80 38       	cpi	r24, 0x80	; 128
    1bf4:	30 f4       	brcc	.+12     	; 0x1c02 <__fp_rempio2+0x4c>
    1bf6:	9a 95       	dec	r25
    1bf8:	bb 0f       	add	r27, r27
    1bfa:	66 1f       	adc	r22, r22
    1bfc:	77 1f       	adc	r23, r23
    1bfe:	88 1f       	adc	r24, r24
    1c00:	d2 f7       	brpl	.-12     	; 0x1bf6 <__fp_rempio2+0x40>
    1c02:	90 48       	sbci	r25, 0x80	; 128
    1c04:	0c 94 cd 0d 	jmp	0x1b9a	; 0x1b9a <__fp_mpack_finite>

00001c08 <__fp_sinus>:
    1c08:	ef 93       	push	r30
    1c0a:	e0 ff       	sbrs	r30, 0
    1c0c:	07 c0       	rjmp	.+14     	; 0x1c1c <__fp_sinus+0x14>
    1c0e:	a2 ea       	ldi	r26, 0xA2	; 162
    1c10:	2a ed       	ldi	r18, 0xDA	; 218
    1c12:	3f e0       	ldi	r19, 0x0F	; 15
    1c14:	49 ec       	ldi	r20, 0xC9	; 201
    1c16:	5f eb       	ldi	r21, 0xBF	; 191
    1c18:	0e 94 ae 0a 	call	0x155c	; 0x155c <__addsf3x>
    1c1c:	0e 94 a1 0c 	call	0x1942	; 0x1942 <__fp_round>
    1c20:	0f 90       	pop	r0
    1c22:	03 94       	inc	r0
    1c24:	01 fc       	sbrc	r0, 1
    1c26:	90 58       	subi	r25, 0x80	; 128
    1c28:	e4 ea       	ldi	r30, 0xA4	; 164
    1c2a:	f0 e0       	ldi	r31, 0x00	; 0
    1c2c:	0c 94 18 0e 	jmp	0x1c30	; 0x1c30 <__fp_powsodd>

00001c30 <__fp_powsodd>:
    1c30:	9f 93       	push	r25
    1c32:	8f 93       	push	r24
    1c34:	7f 93       	push	r23
    1c36:	6f 93       	push	r22
    1c38:	ff 93       	push	r31
    1c3a:	ef 93       	push	r30
    1c3c:	9b 01       	movw	r18, r22
    1c3e:	ac 01       	movw	r20, r24
    1c40:	0e 94 56 0d 	call	0x1aac	; 0x1aac <__mulsf3>
    1c44:	ef 91       	pop	r30
    1c46:	ff 91       	pop	r31
    1c48:	0e 94 6c 0c 	call	0x18d8	; 0x18d8 <__fp_powser>
    1c4c:	2f 91       	pop	r18
    1c4e:	3f 91       	pop	r19
    1c50:	4f 91       	pop	r20
    1c52:	5f 91       	pop	r21
    1c54:	0c 94 56 0d 	jmp	0x1aac	; 0x1aac <__mulsf3>

00001c58 <__udivmodsi4>:
    1c58:	a1 e2       	ldi	r26, 0x21	; 33
    1c5a:	1a 2e       	mov	r1, r26
    1c5c:	aa 1b       	sub	r26, r26
    1c5e:	bb 1b       	sub	r27, r27
    1c60:	fd 01       	movw	r30, r26
    1c62:	0d c0       	rjmp	.+26     	; 0x1c7e <__udivmodsi4_ep>

00001c64 <__udivmodsi4_loop>:
    1c64:	aa 1f       	adc	r26, r26
    1c66:	bb 1f       	adc	r27, r27
    1c68:	ee 1f       	adc	r30, r30
    1c6a:	ff 1f       	adc	r31, r31
    1c6c:	a2 17       	cp	r26, r18
    1c6e:	b3 07       	cpc	r27, r19
    1c70:	e4 07       	cpc	r30, r20
    1c72:	f5 07       	cpc	r31, r21
    1c74:	20 f0       	brcs	.+8      	; 0x1c7e <__udivmodsi4_ep>
    1c76:	a2 1b       	sub	r26, r18
    1c78:	b3 0b       	sbc	r27, r19
    1c7a:	e4 0b       	sbc	r30, r20
    1c7c:	f5 0b       	sbc	r31, r21

00001c7e <__udivmodsi4_ep>:
    1c7e:	66 1f       	adc	r22, r22
    1c80:	77 1f       	adc	r23, r23
    1c82:	88 1f       	adc	r24, r24
    1c84:	99 1f       	adc	r25, r25
    1c86:	1a 94       	dec	r1
    1c88:	69 f7       	brne	.-38     	; 0x1c64 <__udivmodsi4_loop>
    1c8a:	60 95       	com	r22
    1c8c:	70 95       	com	r23
    1c8e:	80 95       	com	r24
    1c90:	90 95       	com	r25
    1c92:	9b 01       	movw	r18, r22
    1c94:	ac 01       	movw	r20, r24
    1c96:	bd 01       	movw	r22, r26
    1c98:	cf 01       	movw	r24, r30
    1c9a:	08 95       	ret

00001c9c <dtostrf>:
    1c9c:	ef 92       	push	r14
    1c9e:	0f 93       	push	r16
    1ca0:	1f 93       	push	r17
    1ca2:	cf 93       	push	r28
    1ca4:	df 93       	push	r29
    1ca6:	e8 01       	movw	r28, r16
    1ca8:	47 fd       	sbrc	r20, 7
    1caa:	02 c0       	rjmp	.+4      	; 0x1cb0 <dtostrf+0x14>
    1cac:	34 e0       	ldi	r19, 0x04	; 4
    1cae:	01 c0       	rjmp	.+2      	; 0x1cb2 <dtostrf+0x16>
    1cb0:	34 e1       	ldi	r19, 0x14	; 20
    1cb2:	04 2e       	mov	r0, r20
    1cb4:	00 0c       	add	r0, r0
    1cb6:	55 0b       	sbc	r21, r21
    1cb8:	57 ff       	sbrs	r21, 7
    1cba:	03 c0       	rjmp	.+6      	; 0x1cc2 <dtostrf+0x26>
    1cbc:	51 95       	neg	r21
    1cbe:	41 95       	neg	r20
    1cc0:	51 09       	sbc	r21, r1
    1cc2:	e3 2e       	mov	r14, r19
    1cc4:	02 2f       	mov	r16, r18
    1cc6:	24 2f       	mov	r18, r20
    1cc8:	ae 01       	movw	r20, r28
    1cca:	0e 94 95 10 	call	0x212a	; 0x212a <dtoa_prf>
    1cce:	ce 01       	movw	r24, r28
    1cd0:	df 91       	pop	r29
    1cd2:	cf 91       	pop	r28
    1cd4:	1f 91       	pop	r17
    1cd6:	0f 91       	pop	r16
    1cd8:	ef 90       	pop	r14
    1cda:	08 95       	ret

00001cdc <printf>:
    1cdc:	a0 e0       	ldi	r26, 0x00	; 0
    1cde:	b0 e0       	ldi	r27, 0x00	; 0
    1ce0:	e4 e7       	ldi	r30, 0x74	; 116
    1ce2:	fe e0       	ldi	r31, 0x0E	; 14
    1ce4:	0c 94 87 13 	jmp	0x270e	; 0x270e <__prologue_saves__+0x20>
    1ce8:	ae 01       	movw	r20, r28
    1cea:	4b 5f       	subi	r20, 0xFB	; 251
    1cec:	5f 4f       	sbci	r21, 0xFF	; 255
    1cee:	fa 01       	movw	r30, r20
    1cf0:	61 91       	ld	r22, Z+
    1cf2:	71 91       	ld	r23, Z+
    1cf4:	af 01       	movw	r20, r30
    1cf6:	80 91 6c 38 	lds	r24, 0x386C	; 0x80386c <__iob+0x2>
    1cfa:	90 91 6d 38 	lds	r25, 0x386D	; 0x80386d <__iob+0x3>
    1cfe:	0e 94 b4 0e 	call	0x1d68	; 0x1d68 <vfprintf>
    1d02:	e2 e0       	ldi	r30, 0x02	; 2
    1d04:	0c 94 a0 13 	jmp	0x2740	; 0x2740 <__epilogue_restores__+0x20>

00001d08 <puts>:
    1d08:	0f 93       	push	r16
    1d0a:	1f 93       	push	r17
    1d0c:	cf 93       	push	r28
    1d0e:	df 93       	push	r29
    1d10:	e0 91 6c 38 	lds	r30, 0x386C	; 0x80386c <__iob+0x2>
    1d14:	f0 91 6d 38 	lds	r31, 0x386D	; 0x80386d <__iob+0x3>
    1d18:	23 81       	ldd	r18, Z+3	; 0x03
    1d1a:	21 ff       	sbrs	r18, 1
    1d1c:	1b c0       	rjmp	.+54     	; 0x1d54 <puts+0x4c>
    1d1e:	8c 01       	movw	r16, r24
    1d20:	d0 e0       	ldi	r29, 0x00	; 0
    1d22:	c0 e0       	ldi	r28, 0x00	; 0
    1d24:	f8 01       	movw	r30, r16
    1d26:	81 91       	ld	r24, Z+
    1d28:	8f 01       	movw	r16, r30
    1d2a:	60 91 6c 38 	lds	r22, 0x386C	; 0x80386c <__iob+0x2>
    1d2e:	70 91 6d 38 	lds	r23, 0x386D	; 0x80386d <__iob+0x3>
    1d32:	db 01       	movw	r26, r22
    1d34:	18 96       	adiw	r26, 0x08	; 8
    1d36:	ed 91       	ld	r30, X+
    1d38:	fc 91       	ld	r31, X
    1d3a:	19 97       	sbiw	r26, 0x09	; 9
    1d3c:	88 23       	and	r24, r24
    1d3e:	31 f0       	breq	.+12     	; 0x1d4c <puts+0x44>
    1d40:	09 95       	icall
    1d42:	89 2b       	or	r24, r25
    1d44:	79 f3       	breq	.-34     	; 0x1d24 <puts+0x1c>
    1d46:	df ef       	ldi	r29, 0xFF	; 255
    1d48:	cf ef       	ldi	r28, 0xFF	; 255
    1d4a:	ec cf       	rjmp	.-40     	; 0x1d24 <puts+0x1c>
    1d4c:	8a e0       	ldi	r24, 0x0A	; 10
    1d4e:	09 95       	icall
    1d50:	89 2b       	or	r24, r25
    1d52:	19 f0       	breq	.+6      	; 0x1d5a <puts+0x52>
    1d54:	8f ef       	ldi	r24, 0xFF	; 255
    1d56:	9f ef       	ldi	r25, 0xFF	; 255
    1d58:	02 c0       	rjmp	.+4      	; 0x1d5e <puts+0x56>
    1d5a:	8d 2f       	mov	r24, r29
    1d5c:	9c 2f       	mov	r25, r28
    1d5e:	df 91       	pop	r29
    1d60:	cf 91       	pop	r28
    1d62:	1f 91       	pop	r17
    1d64:	0f 91       	pop	r16
    1d66:	08 95       	ret

00001d68 <vfprintf>:
    1d68:	ab e0       	ldi	r26, 0x0B	; 11
    1d6a:	b0 e0       	ldi	r27, 0x00	; 0
    1d6c:	ea eb       	ldi	r30, 0xBA	; 186
    1d6e:	fe e0       	ldi	r31, 0x0E	; 14
    1d70:	0c 94 77 13 	jmp	0x26ee	; 0x26ee <__prologue_saves__>
    1d74:	6c 01       	movw	r12, r24
    1d76:	7b 01       	movw	r14, r22
    1d78:	8a 01       	movw	r16, r20
    1d7a:	fc 01       	movw	r30, r24
    1d7c:	16 82       	std	Z+6, r1	; 0x06
    1d7e:	17 82       	std	Z+7, r1	; 0x07
    1d80:	83 81       	ldd	r24, Z+3	; 0x03
    1d82:	81 ff       	sbrs	r24, 1
    1d84:	cc c1       	rjmp	.+920    	; 0x211e <vfprintf+0x3b6>
    1d86:	ce 01       	movw	r24, r28
    1d88:	01 96       	adiw	r24, 0x01	; 1
    1d8a:	3c 01       	movw	r6, r24
    1d8c:	f6 01       	movw	r30, r12
    1d8e:	93 81       	ldd	r25, Z+3	; 0x03
    1d90:	f7 01       	movw	r30, r14
    1d92:	93 fd       	sbrc	r25, 3
    1d94:	85 91       	lpm	r24, Z+
    1d96:	93 ff       	sbrs	r25, 3
    1d98:	81 91       	ld	r24, Z+
    1d9a:	7f 01       	movw	r14, r30
    1d9c:	88 23       	and	r24, r24
    1d9e:	09 f4       	brne	.+2      	; 0x1da2 <vfprintf+0x3a>
    1da0:	ba c1       	rjmp	.+884    	; 0x2116 <vfprintf+0x3ae>
    1da2:	85 32       	cpi	r24, 0x25	; 37
    1da4:	39 f4       	brne	.+14     	; 0x1db4 <vfprintf+0x4c>
    1da6:	93 fd       	sbrc	r25, 3
    1da8:	85 91       	lpm	r24, Z+
    1daa:	93 ff       	sbrs	r25, 3
    1dac:	81 91       	ld	r24, Z+
    1dae:	7f 01       	movw	r14, r30
    1db0:	85 32       	cpi	r24, 0x25	; 37
    1db2:	29 f4       	brne	.+10     	; 0x1dbe <vfprintf+0x56>
    1db4:	b6 01       	movw	r22, r12
    1db6:	90 e0       	ldi	r25, 0x00	; 0
    1db8:	0e 94 dd 12 	call	0x25ba	; 0x25ba <fputc>
    1dbc:	e7 cf       	rjmp	.-50     	; 0x1d8c <vfprintf+0x24>
    1dbe:	91 2c       	mov	r9, r1
    1dc0:	21 2c       	mov	r2, r1
    1dc2:	31 2c       	mov	r3, r1
    1dc4:	ff e1       	ldi	r31, 0x1F	; 31
    1dc6:	f3 15       	cp	r31, r3
    1dc8:	d8 f0       	brcs	.+54     	; 0x1e00 <vfprintf+0x98>
    1dca:	8b 32       	cpi	r24, 0x2B	; 43
    1dcc:	79 f0       	breq	.+30     	; 0x1dec <vfprintf+0x84>
    1dce:	38 f4       	brcc	.+14     	; 0x1dde <vfprintf+0x76>
    1dd0:	80 32       	cpi	r24, 0x20	; 32
    1dd2:	79 f0       	breq	.+30     	; 0x1df2 <vfprintf+0x8a>
    1dd4:	83 32       	cpi	r24, 0x23	; 35
    1dd6:	a1 f4       	brne	.+40     	; 0x1e00 <vfprintf+0x98>
    1dd8:	23 2d       	mov	r18, r3
    1dda:	20 61       	ori	r18, 0x10	; 16
    1ddc:	1d c0       	rjmp	.+58     	; 0x1e18 <vfprintf+0xb0>
    1dde:	8d 32       	cpi	r24, 0x2D	; 45
    1de0:	61 f0       	breq	.+24     	; 0x1dfa <vfprintf+0x92>
    1de2:	80 33       	cpi	r24, 0x30	; 48
    1de4:	69 f4       	brne	.+26     	; 0x1e00 <vfprintf+0x98>
    1de6:	23 2d       	mov	r18, r3
    1de8:	21 60       	ori	r18, 0x01	; 1
    1dea:	16 c0       	rjmp	.+44     	; 0x1e18 <vfprintf+0xb0>
    1dec:	83 2d       	mov	r24, r3
    1dee:	82 60       	ori	r24, 0x02	; 2
    1df0:	38 2e       	mov	r3, r24
    1df2:	e3 2d       	mov	r30, r3
    1df4:	e4 60       	ori	r30, 0x04	; 4
    1df6:	3e 2e       	mov	r3, r30
    1df8:	2a c0       	rjmp	.+84     	; 0x1e4e <vfprintf+0xe6>
    1dfa:	f3 2d       	mov	r31, r3
    1dfc:	f8 60       	ori	r31, 0x08	; 8
    1dfe:	1d c0       	rjmp	.+58     	; 0x1e3a <vfprintf+0xd2>
    1e00:	37 fc       	sbrc	r3, 7
    1e02:	2d c0       	rjmp	.+90     	; 0x1e5e <vfprintf+0xf6>
    1e04:	20 ed       	ldi	r18, 0xD0	; 208
    1e06:	28 0f       	add	r18, r24
    1e08:	2a 30       	cpi	r18, 0x0A	; 10
    1e0a:	40 f0       	brcs	.+16     	; 0x1e1c <vfprintf+0xb4>
    1e0c:	8e 32       	cpi	r24, 0x2E	; 46
    1e0e:	b9 f4       	brne	.+46     	; 0x1e3e <vfprintf+0xd6>
    1e10:	36 fc       	sbrc	r3, 6
    1e12:	81 c1       	rjmp	.+770    	; 0x2116 <vfprintf+0x3ae>
    1e14:	23 2d       	mov	r18, r3
    1e16:	20 64       	ori	r18, 0x40	; 64
    1e18:	32 2e       	mov	r3, r18
    1e1a:	19 c0       	rjmp	.+50     	; 0x1e4e <vfprintf+0xe6>
    1e1c:	36 fe       	sbrs	r3, 6
    1e1e:	06 c0       	rjmp	.+12     	; 0x1e2c <vfprintf+0xc4>
    1e20:	8a e0       	ldi	r24, 0x0A	; 10
    1e22:	98 9e       	mul	r9, r24
    1e24:	20 0d       	add	r18, r0
    1e26:	11 24       	eor	r1, r1
    1e28:	92 2e       	mov	r9, r18
    1e2a:	11 c0       	rjmp	.+34     	; 0x1e4e <vfprintf+0xe6>
    1e2c:	ea e0       	ldi	r30, 0x0A	; 10
    1e2e:	2e 9e       	mul	r2, r30
    1e30:	20 0d       	add	r18, r0
    1e32:	11 24       	eor	r1, r1
    1e34:	22 2e       	mov	r2, r18
    1e36:	f3 2d       	mov	r31, r3
    1e38:	f0 62       	ori	r31, 0x20	; 32
    1e3a:	3f 2e       	mov	r3, r31
    1e3c:	08 c0       	rjmp	.+16     	; 0x1e4e <vfprintf+0xe6>
    1e3e:	8c 36       	cpi	r24, 0x6C	; 108
    1e40:	21 f4       	brne	.+8      	; 0x1e4a <vfprintf+0xe2>
    1e42:	83 2d       	mov	r24, r3
    1e44:	80 68       	ori	r24, 0x80	; 128
    1e46:	38 2e       	mov	r3, r24
    1e48:	02 c0       	rjmp	.+4      	; 0x1e4e <vfprintf+0xe6>
    1e4a:	88 36       	cpi	r24, 0x68	; 104
    1e4c:	41 f4       	brne	.+16     	; 0x1e5e <vfprintf+0xf6>
    1e4e:	f7 01       	movw	r30, r14
    1e50:	93 fd       	sbrc	r25, 3
    1e52:	85 91       	lpm	r24, Z+
    1e54:	93 ff       	sbrs	r25, 3
    1e56:	81 91       	ld	r24, Z+
    1e58:	7f 01       	movw	r14, r30
    1e5a:	81 11       	cpse	r24, r1
    1e5c:	b3 cf       	rjmp	.-154    	; 0x1dc4 <vfprintf+0x5c>
    1e5e:	98 2f       	mov	r25, r24
    1e60:	9f 7d       	andi	r25, 0xDF	; 223
    1e62:	95 54       	subi	r25, 0x45	; 69
    1e64:	93 30       	cpi	r25, 0x03	; 3
    1e66:	28 f4       	brcc	.+10     	; 0x1e72 <vfprintf+0x10a>
    1e68:	0c 5f       	subi	r16, 0xFC	; 252
    1e6a:	1f 4f       	sbci	r17, 0xFF	; 255
    1e6c:	9f e3       	ldi	r25, 0x3F	; 63
    1e6e:	99 83       	std	Y+1, r25	; 0x01
    1e70:	0d c0       	rjmp	.+26     	; 0x1e8c <vfprintf+0x124>
    1e72:	83 36       	cpi	r24, 0x63	; 99
    1e74:	31 f0       	breq	.+12     	; 0x1e82 <vfprintf+0x11a>
    1e76:	83 37       	cpi	r24, 0x73	; 115
    1e78:	71 f0       	breq	.+28     	; 0x1e96 <vfprintf+0x12e>
    1e7a:	83 35       	cpi	r24, 0x53	; 83
    1e7c:	09 f0       	breq	.+2      	; 0x1e80 <vfprintf+0x118>
    1e7e:	59 c0       	rjmp	.+178    	; 0x1f32 <vfprintf+0x1ca>
    1e80:	21 c0       	rjmp	.+66     	; 0x1ec4 <vfprintf+0x15c>
    1e82:	f8 01       	movw	r30, r16
    1e84:	80 81       	ld	r24, Z
    1e86:	89 83       	std	Y+1, r24	; 0x01
    1e88:	0e 5f       	subi	r16, 0xFE	; 254
    1e8a:	1f 4f       	sbci	r17, 0xFF	; 255
    1e8c:	88 24       	eor	r8, r8
    1e8e:	83 94       	inc	r8
    1e90:	91 2c       	mov	r9, r1
    1e92:	53 01       	movw	r10, r6
    1e94:	13 c0       	rjmp	.+38     	; 0x1ebc <vfprintf+0x154>
    1e96:	28 01       	movw	r4, r16
    1e98:	f2 e0       	ldi	r31, 0x02	; 2
    1e9a:	4f 0e       	add	r4, r31
    1e9c:	51 1c       	adc	r5, r1
    1e9e:	f8 01       	movw	r30, r16
    1ea0:	a0 80       	ld	r10, Z
    1ea2:	b1 80       	ldd	r11, Z+1	; 0x01
    1ea4:	36 fe       	sbrs	r3, 6
    1ea6:	03 c0       	rjmp	.+6      	; 0x1eae <vfprintf+0x146>
    1ea8:	69 2d       	mov	r22, r9
    1eaa:	70 e0       	ldi	r23, 0x00	; 0
    1eac:	02 c0       	rjmp	.+4      	; 0x1eb2 <vfprintf+0x14a>
    1eae:	6f ef       	ldi	r22, 0xFF	; 255
    1eb0:	7f ef       	ldi	r23, 0xFF	; 255
    1eb2:	c5 01       	movw	r24, r10
    1eb4:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <strnlen>
    1eb8:	4c 01       	movw	r8, r24
    1eba:	82 01       	movw	r16, r4
    1ebc:	f3 2d       	mov	r31, r3
    1ebe:	ff 77       	andi	r31, 0x7F	; 127
    1ec0:	3f 2e       	mov	r3, r31
    1ec2:	16 c0       	rjmp	.+44     	; 0x1ef0 <vfprintf+0x188>
    1ec4:	28 01       	movw	r4, r16
    1ec6:	22 e0       	ldi	r18, 0x02	; 2
    1ec8:	42 0e       	add	r4, r18
    1eca:	51 1c       	adc	r5, r1
    1ecc:	f8 01       	movw	r30, r16
    1ece:	a0 80       	ld	r10, Z
    1ed0:	b1 80       	ldd	r11, Z+1	; 0x01
    1ed2:	36 fe       	sbrs	r3, 6
    1ed4:	03 c0       	rjmp	.+6      	; 0x1edc <vfprintf+0x174>
    1ed6:	69 2d       	mov	r22, r9
    1ed8:	70 e0       	ldi	r23, 0x00	; 0
    1eda:	02 c0       	rjmp	.+4      	; 0x1ee0 <vfprintf+0x178>
    1edc:	6f ef       	ldi	r22, 0xFF	; 255
    1ede:	7f ef       	ldi	r23, 0xFF	; 255
    1ee0:	c5 01       	movw	r24, r10
    1ee2:	0e 94 c7 12 	call	0x258e	; 0x258e <strnlen_P>
    1ee6:	4c 01       	movw	r8, r24
    1ee8:	f3 2d       	mov	r31, r3
    1eea:	f0 68       	ori	r31, 0x80	; 128
    1eec:	3f 2e       	mov	r3, r31
    1eee:	82 01       	movw	r16, r4
    1ef0:	33 fc       	sbrc	r3, 3
    1ef2:	1b c0       	rjmp	.+54     	; 0x1f2a <vfprintf+0x1c2>
    1ef4:	82 2d       	mov	r24, r2
    1ef6:	90 e0       	ldi	r25, 0x00	; 0
    1ef8:	88 16       	cp	r8, r24
    1efa:	99 06       	cpc	r9, r25
    1efc:	b0 f4       	brcc	.+44     	; 0x1f2a <vfprintf+0x1c2>
    1efe:	b6 01       	movw	r22, r12
    1f00:	80 e2       	ldi	r24, 0x20	; 32
    1f02:	90 e0       	ldi	r25, 0x00	; 0
    1f04:	0e 94 dd 12 	call	0x25ba	; 0x25ba <fputc>
    1f08:	2a 94       	dec	r2
    1f0a:	f4 cf       	rjmp	.-24     	; 0x1ef4 <vfprintf+0x18c>
    1f0c:	f5 01       	movw	r30, r10
    1f0e:	37 fc       	sbrc	r3, 7
    1f10:	85 91       	lpm	r24, Z+
    1f12:	37 fe       	sbrs	r3, 7
    1f14:	81 91       	ld	r24, Z+
    1f16:	5f 01       	movw	r10, r30
    1f18:	b6 01       	movw	r22, r12
    1f1a:	90 e0       	ldi	r25, 0x00	; 0
    1f1c:	0e 94 dd 12 	call	0x25ba	; 0x25ba <fputc>
    1f20:	21 10       	cpse	r2, r1
    1f22:	2a 94       	dec	r2
    1f24:	21 e0       	ldi	r18, 0x01	; 1
    1f26:	82 1a       	sub	r8, r18
    1f28:	91 08       	sbc	r9, r1
    1f2a:	81 14       	cp	r8, r1
    1f2c:	91 04       	cpc	r9, r1
    1f2e:	71 f7       	brne	.-36     	; 0x1f0c <vfprintf+0x1a4>
    1f30:	e8 c0       	rjmp	.+464    	; 0x2102 <vfprintf+0x39a>
    1f32:	84 36       	cpi	r24, 0x64	; 100
    1f34:	11 f0       	breq	.+4      	; 0x1f3a <vfprintf+0x1d2>
    1f36:	89 36       	cpi	r24, 0x69	; 105
    1f38:	41 f5       	brne	.+80     	; 0x1f8a <vfprintf+0x222>
    1f3a:	f8 01       	movw	r30, r16
    1f3c:	37 fe       	sbrs	r3, 7
    1f3e:	07 c0       	rjmp	.+14     	; 0x1f4e <vfprintf+0x1e6>
    1f40:	60 81       	ld	r22, Z
    1f42:	71 81       	ldd	r23, Z+1	; 0x01
    1f44:	82 81       	ldd	r24, Z+2	; 0x02
    1f46:	93 81       	ldd	r25, Z+3	; 0x03
    1f48:	0c 5f       	subi	r16, 0xFC	; 252
    1f4a:	1f 4f       	sbci	r17, 0xFF	; 255
    1f4c:	08 c0       	rjmp	.+16     	; 0x1f5e <vfprintf+0x1f6>
    1f4e:	60 81       	ld	r22, Z
    1f50:	71 81       	ldd	r23, Z+1	; 0x01
    1f52:	07 2e       	mov	r0, r23
    1f54:	00 0c       	add	r0, r0
    1f56:	88 0b       	sbc	r24, r24
    1f58:	99 0b       	sbc	r25, r25
    1f5a:	0e 5f       	subi	r16, 0xFE	; 254
    1f5c:	1f 4f       	sbci	r17, 0xFF	; 255
    1f5e:	f3 2d       	mov	r31, r3
    1f60:	ff 76       	andi	r31, 0x6F	; 111
    1f62:	3f 2e       	mov	r3, r31
    1f64:	97 ff       	sbrs	r25, 7
    1f66:	09 c0       	rjmp	.+18     	; 0x1f7a <vfprintf+0x212>
    1f68:	90 95       	com	r25
    1f6a:	80 95       	com	r24
    1f6c:	70 95       	com	r23
    1f6e:	61 95       	neg	r22
    1f70:	7f 4f       	sbci	r23, 0xFF	; 255
    1f72:	8f 4f       	sbci	r24, 0xFF	; 255
    1f74:	9f 4f       	sbci	r25, 0xFF	; 255
    1f76:	f0 68       	ori	r31, 0x80	; 128
    1f78:	3f 2e       	mov	r3, r31
    1f7a:	2a e0       	ldi	r18, 0x0A	; 10
    1f7c:	30 e0       	ldi	r19, 0x00	; 0
    1f7e:	a3 01       	movw	r20, r6
    1f80:	0e 94 19 13 	call	0x2632	; 0x2632 <__ultoa_invert>
    1f84:	88 2e       	mov	r8, r24
    1f86:	86 18       	sub	r8, r6
    1f88:	45 c0       	rjmp	.+138    	; 0x2014 <vfprintf+0x2ac>
    1f8a:	85 37       	cpi	r24, 0x75	; 117
    1f8c:	31 f4       	brne	.+12     	; 0x1f9a <vfprintf+0x232>
    1f8e:	23 2d       	mov	r18, r3
    1f90:	2f 7e       	andi	r18, 0xEF	; 239
    1f92:	b2 2e       	mov	r11, r18
    1f94:	2a e0       	ldi	r18, 0x0A	; 10
    1f96:	30 e0       	ldi	r19, 0x00	; 0
    1f98:	25 c0       	rjmp	.+74     	; 0x1fe4 <vfprintf+0x27c>
    1f9a:	93 2d       	mov	r25, r3
    1f9c:	99 7f       	andi	r25, 0xF9	; 249
    1f9e:	b9 2e       	mov	r11, r25
    1fa0:	8f 36       	cpi	r24, 0x6F	; 111
    1fa2:	c1 f0       	breq	.+48     	; 0x1fd4 <vfprintf+0x26c>
    1fa4:	18 f4       	brcc	.+6      	; 0x1fac <vfprintf+0x244>
    1fa6:	88 35       	cpi	r24, 0x58	; 88
    1fa8:	79 f0       	breq	.+30     	; 0x1fc8 <vfprintf+0x260>
    1faa:	b5 c0       	rjmp	.+362    	; 0x2116 <vfprintf+0x3ae>
    1fac:	80 37       	cpi	r24, 0x70	; 112
    1fae:	19 f0       	breq	.+6      	; 0x1fb6 <vfprintf+0x24e>
    1fb0:	88 37       	cpi	r24, 0x78	; 120
    1fb2:	21 f0       	breq	.+8      	; 0x1fbc <vfprintf+0x254>
    1fb4:	b0 c0       	rjmp	.+352    	; 0x2116 <vfprintf+0x3ae>
    1fb6:	e9 2f       	mov	r30, r25
    1fb8:	e0 61       	ori	r30, 0x10	; 16
    1fba:	be 2e       	mov	r11, r30
    1fbc:	b4 fe       	sbrs	r11, 4
    1fbe:	0d c0       	rjmp	.+26     	; 0x1fda <vfprintf+0x272>
    1fc0:	fb 2d       	mov	r31, r11
    1fc2:	f4 60       	ori	r31, 0x04	; 4
    1fc4:	bf 2e       	mov	r11, r31
    1fc6:	09 c0       	rjmp	.+18     	; 0x1fda <vfprintf+0x272>
    1fc8:	34 fe       	sbrs	r3, 4
    1fca:	0a c0       	rjmp	.+20     	; 0x1fe0 <vfprintf+0x278>
    1fcc:	29 2f       	mov	r18, r25
    1fce:	26 60       	ori	r18, 0x06	; 6
    1fd0:	b2 2e       	mov	r11, r18
    1fd2:	06 c0       	rjmp	.+12     	; 0x1fe0 <vfprintf+0x278>
    1fd4:	28 e0       	ldi	r18, 0x08	; 8
    1fd6:	30 e0       	ldi	r19, 0x00	; 0
    1fd8:	05 c0       	rjmp	.+10     	; 0x1fe4 <vfprintf+0x27c>
    1fda:	20 e1       	ldi	r18, 0x10	; 16
    1fdc:	30 e0       	ldi	r19, 0x00	; 0
    1fde:	02 c0       	rjmp	.+4      	; 0x1fe4 <vfprintf+0x27c>
    1fe0:	20 e1       	ldi	r18, 0x10	; 16
    1fe2:	32 e0       	ldi	r19, 0x02	; 2
    1fe4:	f8 01       	movw	r30, r16
    1fe6:	b7 fe       	sbrs	r11, 7
    1fe8:	07 c0       	rjmp	.+14     	; 0x1ff8 <vfprintf+0x290>
    1fea:	60 81       	ld	r22, Z
    1fec:	71 81       	ldd	r23, Z+1	; 0x01
    1fee:	82 81       	ldd	r24, Z+2	; 0x02
    1ff0:	93 81       	ldd	r25, Z+3	; 0x03
    1ff2:	0c 5f       	subi	r16, 0xFC	; 252
    1ff4:	1f 4f       	sbci	r17, 0xFF	; 255
    1ff6:	06 c0       	rjmp	.+12     	; 0x2004 <vfprintf+0x29c>
    1ff8:	60 81       	ld	r22, Z
    1ffa:	71 81       	ldd	r23, Z+1	; 0x01
    1ffc:	80 e0       	ldi	r24, 0x00	; 0
    1ffe:	90 e0       	ldi	r25, 0x00	; 0
    2000:	0e 5f       	subi	r16, 0xFE	; 254
    2002:	1f 4f       	sbci	r17, 0xFF	; 255
    2004:	a3 01       	movw	r20, r6
    2006:	0e 94 19 13 	call	0x2632	; 0x2632 <__ultoa_invert>
    200a:	88 2e       	mov	r8, r24
    200c:	86 18       	sub	r8, r6
    200e:	fb 2d       	mov	r31, r11
    2010:	ff 77       	andi	r31, 0x7F	; 127
    2012:	3f 2e       	mov	r3, r31
    2014:	36 fe       	sbrs	r3, 6
    2016:	0d c0       	rjmp	.+26     	; 0x2032 <vfprintf+0x2ca>
    2018:	23 2d       	mov	r18, r3
    201a:	2e 7f       	andi	r18, 0xFE	; 254
    201c:	a2 2e       	mov	r10, r18
    201e:	89 14       	cp	r8, r9
    2020:	58 f4       	brcc	.+22     	; 0x2038 <vfprintf+0x2d0>
    2022:	34 fe       	sbrs	r3, 4
    2024:	0b c0       	rjmp	.+22     	; 0x203c <vfprintf+0x2d4>
    2026:	32 fc       	sbrc	r3, 2
    2028:	09 c0       	rjmp	.+18     	; 0x203c <vfprintf+0x2d4>
    202a:	83 2d       	mov	r24, r3
    202c:	8e 7e       	andi	r24, 0xEE	; 238
    202e:	a8 2e       	mov	r10, r24
    2030:	05 c0       	rjmp	.+10     	; 0x203c <vfprintf+0x2d4>
    2032:	b8 2c       	mov	r11, r8
    2034:	a3 2c       	mov	r10, r3
    2036:	03 c0       	rjmp	.+6      	; 0x203e <vfprintf+0x2d6>
    2038:	b8 2c       	mov	r11, r8
    203a:	01 c0       	rjmp	.+2      	; 0x203e <vfprintf+0x2d6>
    203c:	b9 2c       	mov	r11, r9
    203e:	a4 fe       	sbrs	r10, 4
    2040:	0f c0       	rjmp	.+30     	; 0x2060 <vfprintf+0x2f8>
    2042:	fe 01       	movw	r30, r28
    2044:	e8 0d       	add	r30, r8
    2046:	f1 1d       	adc	r31, r1
    2048:	80 81       	ld	r24, Z
    204a:	80 33       	cpi	r24, 0x30	; 48
    204c:	21 f4       	brne	.+8      	; 0x2056 <vfprintf+0x2ee>
    204e:	9a 2d       	mov	r25, r10
    2050:	99 7e       	andi	r25, 0xE9	; 233
    2052:	a9 2e       	mov	r10, r25
    2054:	09 c0       	rjmp	.+18     	; 0x2068 <vfprintf+0x300>
    2056:	a2 fe       	sbrs	r10, 2
    2058:	06 c0       	rjmp	.+12     	; 0x2066 <vfprintf+0x2fe>
    205a:	b3 94       	inc	r11
    205c:	b3 94       	inc	r11
    205e:	04 c0       	rjmp	.+8      	; 0x2068 <vfprintf+0x300>
    2060:	8a 2d       	mov	r24, r10
    2062:	86 78       	andi	r24, 0x86	; 134
    2064:	09 f0       	breq	.+2      	; 0x2068 <vfprintf+0x300>
    2066:	b3 94       	inc	r11
    2068:	a3 fc       	sbrc	r10, 3
    206a:	11 c0       	rjmp	.+34     	; 0x208e <vfprintf+0x326>
    206c:	a0 fe       	sbrs	r10, 0
    206e:	06 c0       	rjmp	.+12     	; 0x207c <vfprintf+0x314>
    2070:	b2 14       	cp	r11, r2
    2072:	88 f4       	brcc	.+34     	; 0x2096 <vfprintf+0x32e>
    2074:	28 0c       	add	r2, r8
    2076:	92 2c       	mov	r9, r2
    2078:	9b 18       	sub	r9, r11
    207a:	0e c0       	rjmp	.+28     	; 0x2098 <vfprintf+0x330>
    207c:	b2 14       	cp	r11, r2
    207e:	60 f4       	brcc	.+24     	; 0x2098 <vfprintf+0x330>
    2080:	b6 01       	movw	r22, r12
    2082:	80 e2       	ldi	r24, 0x20	; 32
    2084:	90 e0       	ldi	r25, 0x00	; 0
    2086:	0e 94 dd 12 	call	0x25ba	; 0x25ba <fputc>
    208a:	b3 94       	inc	r11
    208c:	f7 cf       	rjmp	.-18     	; 0x207c <vfprintf+0x314>
    208e:	b2 14       	cp	r11, r2
    2090:	18 f4       	brcc	.+6      	; 0x2098 <vfprintf+0x330>
    2092:	2b 18       	sub	r2, r11
    2094:	02 c0       	rjmp	.+4      	; 0x209a <vfprintf+0x332>
    2096:	98 2c       	mov	r9, r8
    2098:	21 2c       	mov	r2, r1
    209a:	a4 fe       	sbrs	r10, 4
    209c:	10 c0       	rjmp	.+32     	; 0x20be <vfprintf+0x356>
    209e:	b6 01       	movw	r22, r12
    20a0:	80 e3       	ldi	r24, 0x30	; 48
    20a2:	90 e0       	ldi	r25, 0x00	; 0
    20a4:	0e 94 dd 12 	call	0x25ba	; 0x25ba <fputc>
    20a8:	a2 fe       	sbrs	r10, 2
    20aa:	17 c0       	rjmp	.+46     	; 0x20da <vfprintf+0x372>
    20ac:	a1 fc       	sbrc	r10, 1
    20ae:	03 c0       	rjmp	.+6      	; 0x20b6 <vfprintf+0x34e>
    20b0:	88 e7       	ldi	r24, 0x78	; 120
    20b2:	90 e0       	ldi	r25, 0x00	; 0
    20b4:	02 c0       	rjmp	.+4      	; 0x20ba <vfprintf+0x352>
    20b6:	88 e5       	ldi	r24, 0x58	; 88
    20b8:	90 e0       	ldi	r25, 0x00	; 0
    20ba:	b6 01       	movw	r22, r12
    20bc:	0c c0       	rjmp	.+24     	; 0x20d6 <vfprintf+0x36e>
    20be:	8a 2d       	mov	r24, r10
    20c0:	86 78       	andi	r24, 0x86	; 134
    20c2:	59 f0       	breq	.+22     	; 0x20da <vfprintf+0x372>
    20c4:	a1 fe       	sbrs	r10, 1
    20c6:	02 c0       	rjmp	.+4      	; 0x20cc <vfprintf+0x364>
    20c8:	8b e2       	ldi	r24, 0x2B	; 43
    20ca:	01 c0       	rjmp	.+2      	; 0x20ce <vfprintf+0x366>
    20cc:	80 e2       	ldi	r24, 0x20	; 32
    20ce:	a7 fc       	sbrc	r10, 7
    20d0:	8d e2       	ldi	r24, 0x2D	; 45
    20d2:	b6 01       	movw	r22, r12
    20d4:	90 e0       	ldi	r25, 0x00	; 0
    20d6:	0e 94 dd 12 	call	0x25ba	; 0x25ba <fputc>
    20da:	89 14       	cp	r8, r9
    20dc:	38 f4       	brcc	.+14     	; 0x20ec <vfprintf+0x384>
    20de:	b6 01       	movw	r22, r12
    20e0:	80 e3       	ldi	r24, 0x30	; 48
    20e2:	90 e0       	ldi	r25, 0x00	; 0
    20e4:	0e 94 dd 12 	call	0x25ba	; 0x25ba <fputc>
    20e8:	9a 94       	dec	r9
    20ea:	f7 cf       	rjmp	.-18     	; 0x20da <vfprintf+0x372>
    20ec:	8a 94       	dec	r8
    20ee:	f3 01       	movw	r30, r6
    20f0:	e8 0d       	add	r30, r8
    20f2:	f1 1d       	adc	r31, r1
    20f4:	80 81       	ld	r24, Z
    20f6:	b6 01       	movw	r22, r12
    20f8:	90 e0       	ldi	r25, 0x00	; 0
    20fa:	0e 94 dd 12 	call	0x25ba	; 0x25ba <fputc>
    20fe:	81 10       	cpse	r8, r1
    2100:	f5 cf       	rjmp	.-22     	; 0x20ec <vfprintf+0x384>
    2102:	22 20       	and	r2, r2
    2104:	09 f4       	brne	.+2      	; 0x2108 <vfprintf+0x3a0>
    2106:	42 ce       	rjmp	.-892    	; 0x1d8c <vfprintf+0x24>
    2108:	b6 01       	movw	r22, r12
    210a:	80 e2       	ldi	r24, 0x20	; 32
    210c:	90 e0       	ldi	r25, 0x00	; 0
    210e:	0e 94 dd 12 	call	0x25ba	; 0x25ba <fputc>
    2112:	2a 94       	dec	r2
    2114:	f6 cf       	rjmp	.-20     	; 0x2102 <vfprintf+0x39a>
    2116:	f6 01       	movw	r30, r12
    2118:	86 81       	ldd	r24, Z+6	; 0x06
    211a:	97 81       	ldd	r25, Z+7	; 0x07
    211c:	02 c0       	rjmp	.+4      	; 0x2122 <vfprintf+0x3ba>
    211e:	8f ef       	ldi	r24, 0xFF	; 255
    2120:	9f ef       	ldi	r25, 0xFF	; 255
    2122:	2b 96       	adiw	r28, 0x0b	; 11
    2124:	e2 e1       	ldi	r30, 0x12	; 18
    2126:	0c 94 90 13 	jmp	0x2720	; 0x2720 <__epilogue_restores__>

0000212a <dtoa_prf>:
    212a:	a9 e0       	ldi	r26, 0x09	; 9
    212c:	b0 e0       	ldi	r27, 0x00	; 0
    212e:	eb e9       	ldi	r30, 0x9B	; 155
    2130:	f0 e1       	ldi	r31, 0x10	; 16
    2132:	0c 94 7d 13 	jmp	0x26fa	; 0x26fa <__prologue_saves__+0xc>
    2136:	6a 01       	movw	r12, r20
    2138:	12 2f       	mov	r17, r18
    213a:	b0 2e       	mov	r11, r16
    213c:	2b e3       	ldi	r18, 0x3B	; 59
    213e:	20 17       	cp	r18, r16
    2140:	20 f0       	brcs	.+8      	; 0x214a <dtoa_prf+0x20>
    2142:	ff 24       	eor	r15, r15
    2144:	f3 94       	inc	r15
    2146:	f0 0e       	add	r15, r16
    2148:	02 c0       	rjmp	.+4      	; 0x214e <dtoa_prf+0x24>
    214a:	2c e3       	ldi	r18, 0x3C	; 60
    214c:	f2 2e       	mov	r15, r18
    214e:	0f 2d       	mov	r16, r15
    2150:	27 e0       	ldi	r18, 0x07	; 7
    2152:	ae 01       	movw	r20, r28
    2154:	4f 5f       	subi	r20, 0xFF	; 255
    2156:	5f 4f       	sbci	r21, 0xFF	; 255
    2158:	0e 94 ef 11 	call	0x23de	; 0x23de <__ftoa_engine>
    215c:	bc 01       	movw	r22, r24
    215e:	49 81       	ldd	r20, Y+1	; 0x01
    2160:	84 2f       	mov	r24, r20
    2162:	89 70       	andi	r24, 0x09	; 9
    2164:	81 30       	cpi	r24, 0x01	; 1
    2166:	31 f0       	breq	.+12     	; 0x2174 <dtoa_prf+0x4a>
    2168:	e1 fc       	sbrc	r14, 1
    216a:	06 c0       	rjmp	.+12     	; 0x2178 <dtoa_prf+0x4e>
    216c:	e0 fe       	sbrs	r14, 0
    216e:	06 c0       	rjmp	.+12     	; 0x217c <dtoa_prf+0x52>
    2170:	90 e2       	ldi	r25, 0x20	; 32
    2172:	05 c0       	rjmp	.+10     	; 0x217e <dtoa_prf+0x54>
    2174:	9d e2       	ldi	r25, 0x2D	; 45
    2176:	03 c0       	rjmp	.+6      	; 0x217e <dtoa_prf+0x54>
    2178:	9b e2       	ldi	r25, 0x2B	; 43
    217a:	01 c0       	rjmp	.+2      	; 0x217e <dtoa_prf+0x54>
    217c:	90 e0       	ldi	r25, 0x00	; 0
    217e:	5e 2d       	mov	r21, r14
    2180:	50 71       	andi	r21, 0x10	; 16
    2182:	43 ff       	sbrs	r20, 3
    2184:	3c c0       	rjmp	.+120    	; 0x21fe <dtoa_prf+0xd4>
    2186:	91 11       	cpse	r25, r1
    2188:	02 c0       	rjmp	.+4      	; 0x218e <dtoa_prf+0x64>
    218a:	83 e0       	ldi	r24, 0x03	; 3
    218c:	01 c0       	rjmp	.+2      	; 0x2190 <dtoa_prf+0x66>
    218e:	84 e0       	ldi	r24, 0x04	; 4
    2190:	81 17       	cp	r24, r17
    2192:	18 f4       	brcc	.+6      	; 0x219a <dtoa_prf+0x70>
    2194:	21 2f       	mov	r18, r17
    2196:	28 1b       	sub	r18, r24
    2198:	01 c0       	rjmp	.+2      	; 0x219c <dtoa_prf+0x72>
    219a:	20 e0       	ldi	r18, 0x00	; 0
    219c:	51 11       	cpse	r21, r1
    219e:	0b c0       	rjmp	.+22     	; 0x21b6 <dtoa_prf+0x8c>
    21a0:	f6 01       	movw	r30, r12
    21a2:	82 2f       	mov	r24, r18
    21a4:	30 e2       	ldi	r19, 0x20	; 32
    21a6:	88 23       	and	r24, r24
    21a8:	19 f0       	breq	.+6      	; 0x21b0 <dtoa_prf+0x86>
    21aa:	31 93       	st	Z+, r19
    21ac:	81 50       	subi	r24, 0x01	; 1
    21ae:	fb cf       	rjmp	.-10     	; 0x21a6 <dtoa_prf+0x7c>
    21b0:	c2 0e       	add	r12, r18
    21b2:	d1 1c       	adc	r13, r1
    21b4:	20 e0       	ldi	r18, 0x00	; 0
    21b6:	99 23       	and	r25, r25
    21b8:	29 f0       	breq	.+10     	; 0x21c4 <dtoa_prf+0x9a>
    21ba:	d6 01       	movw	r26, r12
    21bc:	9c 93       	st	X, r25
    21be:	f6 01       	movw	r30, r12
    21c0:	31 96       	adiw	r30, 0x01	; 1
    21c2:	6f 01       	movw	r12, r30
    21c4:	c6 01       	movw	r24, r12
    21c6:	03 96       	adiw	r24, 0x03	; 3
    21c8:	e2 fe       	sbrs	r14, 2
    21ca:	0a c0       	rjmp	.+20     	; 0x21e0 <dtoa_prf+0xb6>
    21cc:	3e e4       	ldi	r19, 0x4E	; 78
    21ce:	d6 01       	movw	r26, r12
    21d0:	3c 93       	st	X, r19
    21d2:	41 e4       	ldi	r20, 0x41	; 65
    21d4:	11 96       	adiw	r26, 0x01	; 1
    21d6:	4c 93       	st	X, r20
    21d8:	11 97       	sbiw	r26, 0x01	; 1
    21da:	12 96       	adiw	r26, 0x02	; 2
    21dc:	3c 93       	st	X, r19
    21de:	06 c0       	rjmp	.+12     	; 0x21ec <dtoa_prf+0xc2>
    21e0:	3e e6       	ldi	r19, 0x6E	; 110
    21e2:	f6 01       	movw	r30, r12
    21e4:	30 83       	st	Z, r19
    21e6:	41 e6       	ldi	r20, 0x61	; 97
    21e8:	41 83       	std	Z+1, r20	; 0x01
    21ea:	32 83       	std	Z+2, r19	; 0x02
    21ec:	fc 01       	movw	r30, r24
    21ee:	32 2f       	mov	r19, r18
    21f0:	40 e2       	ldi	r20, 0x20	; 32
    21f2:	33 23       	and	r19, r19
    21f4:	09 f4       	brne	.+2      	; 0x21f8 <dtoa_prf+0xce>
    21f6:	42 c0       	rjmp	.+132    	; 0x227c <dtoa_prf+0x152>
    21f8:	41 93       	st	Z+, r20
    21fa:	31 50       	subi	r19, 0x01	; 1
    21fc:	fa cf       	rjmp	.-12     	; 0x21f2 <dtoa_prf+0xc8>
    21fe:	42 ff       	sbrs	r20, 2
    2200:	44 c0       	rjmp	.+136    	; 0x228a <dtoa_prf+0x160>
    2202:	91 11       	cpse	r25, r1
    2204:	02 c0       	rjmp	.+4      	; 0x220a <dtoa_prf+0xe0>
    2206:	83 e0       	ldi	r24, 0x03	; 3
    2208:	01 c0       	rjmp	.+2      	; 0x220c <dtoa_prf+0xe2>
    220a:	84 e0       	ldi	r24, 0x04	; 4
    220c:	81 17       	cp	r24, r17
    220e:	18 f4       	brcc	.+6      	; 0x2216 <dtoa_prf+0xec>
    2210:	21 2f       	mov	r18, r17
    2212:	28 1b       	sub	r18, r24
    2214:	01 c0       	rjmp	.+2      	; 0x2218 <dtoa_prf+0xee>
    2216:	20 e0       	ldi	r18, 0x00	; 0
    2218:	51 11       	cpse	r21, r1
    221a:	0b c0       	rjmp	.+22     	; 0x2232 <dtoa_prf+0x108>
    221c:	f6 01       	movw	r30, r12
    221e:	82 2f       	mov	r24, r18
    2220:	30 e2       	ldi	r19, 0x20	; 32
    2222:	88 23       	and	r24, r24
    2224:	19 f0       	breq	.+6      	; 0x222c <dtoa_prf+0x102>
    2226:	31 93       	st	Z+, r19
    2228:	81 50       	subi	r24, 0x01	; 1
    222a:	fb cf       	rjmp	.-10     	; 0x2222 <dtoa_prf+0xf8>
    222c:	c2 0e       	add	r12, r18
    222e:	d1 1c       	adc	r13, r1
    2230:	20 e0       	ldi	r18, 0x00	; 0
    2232:	99 23       	and	r25, r25
    2234:	29 f0       	breq	.+10     	; 0x2240 <dtoa_prf+0x116>
    2236:	d6 01       	movw	r26, r12
    2238:	9c 93       	st	X, r25
    223a:	f6 01       	movw	r30, r12
    223c:	31 96       	adiw	r30, 0x01	; 1
    223e:	6f 01       	movw	r12, r30
    2240:	c6 01       	movw	r24, r12
    2242:	03 96       	adiw	r24, 0x03	; 3
    2244:	e2 fe       	sbrs	r14, 2
    2246:	0b c0       	rjmp	.+22     	; 0x225e <dtoa_prf+0x134>
    2248:	39 e4       	ldi	r19, 0x49	; 73
    224a:	d6 01       	movw	r26, r12
    224c:	3c 93       	st	X, r19
    224e:	3e e4       	ldi	r19, 0x4E	; 78
    2250:	11 96       	adiw	r26, 0x01	; 1
    2252:	3c 93       	st	X, r19
    2254:	11 97       	sbiw	r26, 0x01	; 1
    2256:	36 e4       	ldi	r19, 0x46	; 70
    2258:	12 96       	adiw	r26, 0x02	; 2
    225a:	3c 93       	st	X, r19
    225c:	07 c0       	rjmp	.+14     	; 0x226c <dtoa_prf+0x142>
    225e:	39 e6       	ldi	r19, 0x69	; 105
    2260:	f6 01       	movw	r30, r12
    2262:	30 83       	st	Z, r19
    2264:	3e e6       	ldi	r19, 0x6E	; 110
    2266:	31 83       	std	Z+1, r19	; 0x01
    2268:	36 e6       	ldi	r19, 0x66	; 102
    226a:	32 83       	std	Z+2, r19	; 0x02
    226c:	fc 01       	movw	r30, r24
    226e:	32 2f       	mov	r19, r18
    2270:	40 e2       	ldi	r20, 0x20	; 32
    2272:	33 23       	and	r19, r19
    2274:	19 f0       	breq	.+6      	; 0x227c <dtoa_prf+0x152>
    2276:	41 93       	st	Z+, r20
    2278:	31 50       	subi	r19, 0x01	; 1
    227a:	fb cf       	rjmp	.-10     	; 0x2272 <dtoa_prf+0x148>
    227c:	fc 01       	movw	r30, r24
    227e:	e2 0f       	add	r30, r18
    2280:	f1 1d       	adc	r31, r1
    2282:	10 82       	st	Z, r1
    2284:	8e ef       	ldi	r24, 0xFE	; 254
    2286:	9f ef       	ldi	r25, 0xFF	; 255
    2288:	a6 c0       	rjmp	.+332    	; 0x23d6 <dtoa_prf+0x2ac>
    228a:	21 e0       	ldi	r18, 0x01	; 1
    228c:	30 e0       	ldi	r19, 0x00	; 0
    228e:	91 11       	cpse	r25, r1
    2290:	02 c0       	rjmp	.+4      	; 0x2296 <dtoa_prf+0x16c>
    2292:	20 e0       	ldi	r18, 0x00	; 0
    2294:	30 e0       	ldi	r19, 0x00	; 0
    2296:	16 16       	cp	r1, r22
    2298:	17 06       	cpc	r1, r23
    229a:	1c f4       	brge	.+6      	; 0x22a2 <dtoa_prf+0x178>
    229c:	fb 01       	movw	r30, r22
    229e:	31 96       	adiw	r30, 0x01	; 1
    22a0:	02 c0       	rjmp	.+4      	; 0x22a6 <dtoa_prf+0x17c>
    22a2:	e1 e0       	ldi	r30, 0x01	; 1
    22a4:	f0 e0       	ldi	r31, 0x00	; 0
    22a6:	2e 0f       	add	r18, r30
    22a8:	3f 1f       	adc	r19, r31
    22aa:	bb 20       	and	r11, r11
    22ac:	21 f0       	breq	.+8      	; 0x22b6 <dtoa_prf+0x18c>
    22ae:	eb 2d       	mov	r30, r11
    22b0:	f0 e0       	ldi	r31, 0x00	; 0
    22b2:	31 96       	adiw	r30, 0x01	; 1
    22b4:	02 c0       	rjmp	.+4      	; 0x22ba <dtoa_prf+0x190>
    22b6:	e0 e0       	ldi	r30, 0x00	; 0
    22b8:	f0 e0       	ldi	r31, 0x00	; 0
    22ba:	2e 0f       	add	r18, r30
    22bc:	3f 1f       	adc	r19, r31
    22be:	e1 2f       	mov	r30, r17
    22c0:	f0 e0       	ldi	r31, 0x00	; 0
    22c2:	2e 17       	cp	r18, r30
    22c4:	3f 07       	cpc	r19, r31
    22c6:	1c f4       	brge	.+6      	; 0x22ce <dtoa_prf+0x1a4>
    22c8:	12 1b       	sub	r17, r18
    22ca:	21 2f       	mov	r18, r17
    22cc:	01 c0       	rjmp	.+2      	; 0x22d0 <dtoa_prf+0x1a6>
    22ce:	20 e0       	ldi	r18, 0x00	; 0
    22d0:	8e 2d       	mov	r24, r14
    22d2:	88 71       	andi	r24, 0x18	; 24
    22d4:	59 f4       	brne	.+22     	; 0x22ec <dtoa_prf+0x1c2>
    22d6:	f6 01       	movw	r30, r12
    22d8:	82 2f       	mov	r24, r18
    22da:	30 e2       	ldi	r19, 0x20	; 32
    22dc:	88 23       	and	r24, r24
    22de:	19 f0       	breq	.+6      	; 0x22e6 <dtoa_prf+0x1bc>
    22e0:	31 93       	st	Z+, r19
    22e2:	81 50       	subi	r24, 0x01	; 1
    22e4:	fb cf       	rjmp	.-10     	; 0x22dc <dtoa_prf+0x1b2>
    22e6:	c2 0e       	add	r12, r18
    22e8:	d1 1c       	adc	r13, r1
    22ea:	20 e0       	ldi	r18, 0x00	; 0
    22ec:	99 23       	and	r25, r25
    22ee:	29 f0       	breq	.+10     	; 0x22fa <dtoa_prf+0x1d0>
    22f0:	d6 01       	movw	r26, r12
    22f2:	9c 93       	st	X, r25
    22f4:	f6 01       	movw	r30, r12
    22f6:	31 96       	adiw	r30, 0x01	; 1
    22f8:	6f 01       	movw	r12, r30
    22fa:	51 11       	cpse	r21, r1
    22fc:	0b c0       	rjmp	.+22     	; 0x2314 <dtoa_prf+0x1ea>
    22fe:	f6 01       	movw	r30, r12
    2300:	82 2f       	mov	r24, r18
    2302:	90 e3       	ldi	r25, 0x30	; 48
    2304:	88 23       	and	r24, r24
    2306:	19 f0       	breq	.+6      	; 0x230e <dtoa_prf+0x1e4>
    2308:	91 93       	st	Z+, r25
    230a:	81 50       	subi	r24, 0x01	; 1
    230c:	fb cf       	rjmp	.-10     	; 0x2304 <dtoa_prf+0x1da>
    230e:	c2 0e       	add	r12, r18
    2310:	d1 1c       	adc	r13, r1
    2312:	20 e0       	ldi	r18, 0x00	; 0
    2314:	0f 2d       	mov	r16, r15
    2316:	06 0f       	add	r16, r22
    2318:	9a 81       	ldd	r25, Y+2	; 0x02
    231a:	34 2f       	mov	r19, r20
    231c:	30 71       	andi	r19, 0x10	; 16
    231e:	44 ff       	sbrs	r20, 4
    2320:	03 c0       	rjmp	.+6      	; 0x2328 <dtoa_prf+0x1fe>
    2322:	91 33       	cpi	r25, 0x31	; 49
    2324:	09 f4       	brne	.+2      	; 0x2328 <dtoa_prf+0x1fe>
    2326:	01 50       	subi	r16, 0x01	; 1
    2328:	10 16       	cp	r1, r16
    232a:	24 f4       	brge	.+8      	; 0x2334 <dtoa_prf+0x20a>
    232c:	09 30       	cpi	r16, 0x09	; 9
    232e:	18 f0       	brcs	.+6      	; 0x2336 <dtoa_prf+0x20c>
    2330:	08 e0       	ldi	r16, 0x08	; 8
    2332:	01 c0       	rjmp	.+2      	; 0x2336 <dtoa_prf+0x20c>
    2334:	01 e0       	ldi	r16, 0x01	; 1
    2336:	ab 01       	movw	r20, r22
    2338:	77 ff       	sbrs	r23, 7
    233a:	02 c0       	rjmp	.+4      	; 0x2340 <dtoa_prf+0x216>
    233c:	40 e0       	ldi	r20, 0x00	; 0
    233e:	50 e0       	ldi	r21, 0x00	; 0
    2340:	fb 01       	movw	r30, r22
    2342:	e4 1b       	sub	r30, r20
    2344:	f5 0b       	sbc	r31, r21
    2346:	a1 e0       	ldi	r26, 0x01	; 1
    2348:	b0 e0       	ldi	r27, 0x00	; 0
    234a:	ac 0f       	add	r26, r28
    234c:	bd 1f       	adc	r27, r29
    234e:	ea 0f       	add	r30, r26
    2350:	fb 1f       	adc	r31, r27
    2352:	8e e2       	ldi	r24, 0x2E	; 46
    2354:	a8 2e       	mov	r10, r24
    2356:	4b 01       	movw	r8, r22
    2358:	80 1a       	sub	r8, r16
    235a:	91 08       	sbc	r9, r1
    235c:	0b 2d       	mov	r16, r11
    235e:	10 e0       	ldi	r17, 0x00	; 0
    2360:	11 95       	neg	r17
    2362:	01 95       	neg	r16
    2364:	11 09       	sbc	r17, r1
    2366:	4f 3f       	cpi	r20, 0xFF	; 255
    2368:	bf ef       	ldi	r27, 0xFF	; 255
    236a:	5b 07       	cpc	r21, r27
    236c:	21 f4       	brne	.+8      	; 0x2376 <dtoa_prf+0x24c>
    236e:	d6 01       	movw	r26, r12
    2370:	ac 92       	st	X, r10
    2372:	11 96       	adiw	r26, 0x01	; 1
    2374:	6d 01       	movw	r12, r26
    2376:	64 17       	cp	r22, r20
    2378:	75 07       	cpc	r23, r21
    237a:	2c f0       	brlt	.+10     	; 0x2386 <dtoa_prf+0x25c>
    237c:	84 16       	cp	r8, r20
    237e:	95 06       	cpc	r9, r21
    2380:	14 f4       	brge	.+4      	; 0x2386 <dtoa_prf+0x25c>
    2382:	81 81       	ldd	r24, Z+1	; 0x01
    2384:	01 c0       	rjmp	.+2      	; 0x2388 <dtoa_prf+0x25e>
    2386:	80 e3       	ldi	r24, 0x30	; 48
    2388:	41 50       	subi	r20, 0x01	; 1
    238a:	51 09       	sbc	r21, r1
    238c:	31 96       	adiw	r30, 0x01	; 1
    238e:	d6 01       	movw	r26, r12
    2390:	11 96       	adiw	r26, 0x01	; 1
    2392:	7d 01       	movw	r14, r26
    2394:	40 17       	cp	r20, r16
    2396:	51 07       	cpc	r21, r17
    2398:	24 f0       	brlt	.+8      	; 0x23a2 <dtoa_prf+0x278>
    239a:	d6 01       	movw	r26, r12
    239c:	8c 93       	st	X, r24
    239e:	67 01       	movw	r12, r14
    23a0:	e2 cf       	rjmp	.-60     	; 0x2366 <dtoa_prf+0x23c>
    23a2:	64 17       	cp	r22, r20
    23a4:	75 07       	cpc	r23, r21
    23a6:	39 f4       	brne	.+14     	; 0x23b6 <dtoa_prf+0x28c>
    23a8:	96 33       	cpi	r25, 0x36	; 54
    23aa:	20 f4       	brcc	.+8      	; 0x23b4 <dtoa_prf+0x28a>
    23ac:	95 33       	cpi	r25, 0x35	; 53
    23ae:	19 f4       	brne	.+6      	; 0x23b6 <dtoa_prf+0x28c>
    23b0:	31 11       	cpse	r19, r1
    23b2:	01 c0       	rjmp	.+2      	; 0x23b6 <dtoa_prf+0x28c>
    23b4:	81 e3       	ldi	r24, 0x31	; 49
    23b6:	f6 01       	movw	r30, r12
    23b8:	80 83       	st	Z, r24
    23ba:	f7 01       	movw	r30, r14
    23bc:	82 2f       	mov	r24, r18
    23be:	90 e2       	ldi	r25, 0x20	; 32
    23c0:	88 23       	and	r24, r24
    23c2:	19 f0       	breq	.+6      	; 0x23ca <dtoa_prf+0x2a0>
    23c4:	91 93       	st	Z+, r25
    23c6:	81 50       	subi	r24, 0x01	; 1
    23c8:	fb cf       	rjmp	.-10     	; 0x23c0 <dtoa_prf+0x296>
    23ca:	f7 01       	movw	r30, r14
    23cc:	e2 0f       	add	r30, r18
    23ce:	f1 1d       	adc	r31, r1
    23d0:	10 82       	st	Z, r1
    23d2:	80 e0       	ldi	r24, 0x00	; 0
    23d4:	90 e0       	ldi	r25, 0x00	; 0
    23d6:	29 96       	adiw	r28, 0x09	; 9
    23d8:	ec e0       	ldi	r30, 0x0C	; 12
    23da:	0c 94 96 13 	jmp	0x272c	; 0x272c <__epilogue_restores__+0xc>

000023de <__ftoa_engine>:
    23de:	28 30       	cpi	r18, 0x08	; 8
    23e0:	08 f0       	brcs	.+2      	; 0x23e4 <__ftoa_engine+0x6>
    23e2:	27 e0       	ldi	r18, 0x07	; 7
    23e4:	33 27       	eor	r19, r19
    23e6:	da 01       	movw	r26, r20
    23e8:	99 0f       	add	r25, r25
    23ea:	31 1d       	adc	r19, r1
    23ec:	87 fd       	sbrc	r24, 7
    23ee:	91 60       	ori	r25, 0x01	; 1
    23f0:	00 96       	adiw	r24, 0x00	; 0
    23f2:	61 05       	cpc	r22, r1
    23f4:	71 05       	cpc	r23, r1
    23f6:	39 f4       	brne	.+14     	; 0x2406 <__ftoa_engine+0x28>
    23f8:	32 60       	ori	r19, 0x02	; 2
    23fa:	2e 5f       	subi	r18, 0xFE	; 254
    23fc:	3d 93       	st	X+, r19
    23fe:	30 e3       	ldi	r19, 0x30	; 48
    2400:	2a 95       	dec	r18
    2402:	e1 f7       	brne	.-8      	; 0x23fc <__ftoa_engine+0x1e>
    2404:	08 95       	ret
    2406:	9f 3f       	cpi	r25, 0xFF	; 255
    2408:	30 f0       	brcs	.+12     	; 0x2416 <__ftoa_engine+0x38>
    240a:	80 38       	cpi	r24, 0x80	; 128
    240c:	71 05       	cpc	r23, r1
    240e:	61 05       	cpc	r22, r1
    2410:	09 f0       	breq	.+2      	; 0x2414 <__ftoa_engine+0x36>
    2412:	3c 5f       	subi	r19, 0xFC	; 252
    2414:	3c 5f       	subi	r19, 0xFC	; 252
    2416:	3d 93       	st	X+, r19
    2418:	91 30       	cpi	r25, 0x01	; 1
    241a:	08 f0       	brcs	.+2      	; 0x241e <__ftoa_engine+0x40>
    241c:	80 68       	ori	r24, 0x80	; 128
    241e:	91 1d       	adc	r25, r1
    2420:	df 93       	push	r29
    2422:	cf 93       	push	r28
    2424:	1f 93       	push	r17
    2426:	0f 93       	push	r16
    2428:	ff 92       	push	r15
    242a:	ef 92       	push	r14
    242c:	19 2f       	mov	r17, r25
    242e:	98 7f       	andi	r25, 0xF8	; 248
    2430:	96 95       	lsr	r25
    2432:	e9 2f       	mov	r30, r25
    2434:	96 95       	lsr	r25
    2436:	96 95       	lsr	r25
    2438:	e9 0f       	add	r30, r25
    243a:	ff 27       	eor	r31, r31
    243c:	e4 5e       	subi	r30, 0xE4	; 228
    243e:	fe 4f       	sbci	r31, 0xFE	; 254
    2440:	99 27       	eor	r25, r25
    2442:	33 27       	eor	r19, r19
    2444:	ee 24       	eor	r14, r14
    2446:	ff 24       	eor	r15, r15
    2448:	a7 01       	movw	r20, r14
    244a:	e7 01       	movw	r28, r14
    244c:	05 90       	lpm	r0, Z+
    244e:	08 94       	sec
    2450:	07 94       	ror	r0
    2452:	28 f4       	brcc	.+10     	; 0x245e <__ftoa_engine+0x80>
    2454:	36 0f       	add	r19, r22
    2456:	e7 1e       	adc	r14, r23
    2458:	f8 1e       	adc	r15, r24
    245a:	49 1f       	adc	r20, r25
    245c:	51 1d       	adc	r21, r1
    245e:	66 0f       	add	r22, r22
    2460:	77 1f       	adc	r23, r23
    2462:	88 1f       	adc	r24, r24
    2464:	99 1f       	adc	r25, r25
    2466:	06 94       	lsr	r0
    2468:	a1 f7       	brne	.-24     	; 0x2452 <__ftoa_engine+0x74>
    246a:	05 90       	lpm	r0, Z+
    246c:	07 94       	ror	r0
    246e:	28 f4       	brcc	.+10     	; 0x247a <__ftoa_engine+0x9c>
    2470:	e7 0e       	add	r14, r23
    2472:	f8 1e       	adc	r15, r24
    2474:	49 1f       	adc	r20, r25
    2476:	56 1f       	adc	r21, r22
    2478:	c1 1d       	adc	r28, r1
    247a:	77 0f       	add	r23, r23
    247c:	88 1f       	adc	r24, r24
    247e:	99 1f       	adc	r25, r25
    2480:	66 1f       	adc	r22, r22
    2482:	06 94       	lsr	r0
    2484:	a1 f7       	brne	.-24     	; 0x246e <__ftoa_engine+0x90>
    2486:	05 90       	lpm	r0, Z+
    2488:	07 94       	ror	r0
    248a:	28 f4       	brcc	.+10     	; 0x2496 <__ftoa_engine+0xb8>
    248c:	f8 0e       	add	r15, r24
    248e:	49 1f       	adc	r20, r25
    2490:	56 1f       	adc	r21, r22
    2492:	c7 1f       	adc	r28, r23
    2494:	d1 1d       	adc	r29, r1
    2496:	88 0f       	add	r24, r24
    2498:	99 1f       	adc	r25, r25
    249a:	66 1f       	adc	r22, r22
    249c:	77 1f       	adc	r23, r23
    249e:	06 94       	lsr	r0
    24a0:	a1 f7       	brne	.-24     	; 0x248a <__ftoa_engine+0xac>
    24a2:	05 90       	lpm	r0, Z+
    24a4:	07 94       	ror	r0
    24a6:	20 f4       	brcc	.+8      	; 0x24b0 <__ftoa_engine+0xd2>
    24a8:	49 0f       	add	r20, r25
    24aa:	56 1f       	adc	r21, r22
    24ac:	c7 1f       	adc	r28, r23
    24ae:	d8 1f       	adc	r29, r24
    24b0:	99 0f       	add	r25, r25
    24b2:	66 1f       	adc	r22, r22
    24b4:	77 1f       	adc	r23, r23
    24b6:	88 1f       	adc	r24, r24
    24b8:	06 94       	lsr	r0
    24ba:	a9 f7       	brne	.-22     	; 0x24a6 <__ftoa_engine+0xc8>
    24bc:	84 91       	lpm	r24, Z
    24be:	10 95       	com	r17
    24c0:	17 70       	andi	r17, 0x07	; 7
    24c2:	41 f0       	breq	.+16     	; 0x24d4 <__ftoa_engine+0xf6>
    24c4:	d6 95       	lsr	r29
    24c6:	c7 95       	ror	r28
    24c8:	57 95       	ror	r21
    24ca:	47 95       	ror	r20
    24cc:	f7 94       	ror	r15
    24ce:	e7 94       	ror	r14
    24d0:	1a 95       	dec	r17
    24d2:	c1 f7       	brne	.-16     	; 0x24c4 <__ftoa_engine+0xe6>
    24d4:	e2 ec       	ldi	r30, 0xC2	; 194
    24d6:	f0 e0       	ldi	r31, 0x00	; 0
    24d8:	68 94       	set
    24da:	15 90       	lpm	r1, Z+
    24dc:	15 91       	lpm	r17, Z+
    24de:	35 91       	lpm	r19, Z+
    24e0:	65 91       	lpm	r22, Z+
    24e2:	95 91       	lpm	r25, Z+
    24e4:	05 90       	lpm	r0, Z+
    24e6:	7f e2       	ldi	r23, 0x2F	; 47
    24e8:	73 95       	inc	r23
    24ea:	e1 18       	sub	r14, r1
    24ec:	f1 0a       	sbc	r15, r17
    24ee:	43 0b       	sbc	r20, r19
    24f0:	56 0b       	sbc	r21, r22
    24f2:	c9 0b       	sbc	r28, r25
    24f4:	d0 09       	sbc	r29, r0
    24f6:	c0 f7       	brcc	.-16     	; 0x24e8 <__ftoa_engine+0x10a>
    24f8:	e1 0c       	add	r14, r1
    24fa:	f1 1e       	adc	r15, r17
    24fc:	43 1f       	adc	r20, r19
    24fe:	56 1f       	adc	r21, r22
    2500:	c9 1f       	adc	r28, r25
    2502:	d0 1d       	adc	r29, r0
    2504:	7e f4       	brtc	.+30     	; 0x2524 <__ftoa_engine+0x146>
    2506:	70 33       	cpi	r23, 0x30	; 48
    2508:	11 f4       	brne	.+4      	; 0x250e <__ftoa_engine+0x130>
    250a:	8a 95       	dec	r24
    250c:	e6 cf       	rjmp	.-52     	; 0x24da <__ftoa_engine+0xfc>
    250e:	e8 94       	clt
    2510:	01 50       	subi	r16, 0x01	; 1
    2512:	30 f0       	brcs	.+12     	; 0x2520 <__ftoa_engine+0x142>
    2514:	08 0f       	add	r16, r24
    2516:	0a f4       	brpl	.+2      	; 0x251a <__ftoa_engine+0x13c>
    2518:	00 27       	eor	r16, r16
    251a:	02 17       	cp	r16, r18
    251c:	08 f4       	brcc	.+2      	; 0x2520 <__ftoa_engine+0x142>
    251e:	20 2f       	mov	r18, r16
    2520:	23 95       	inc	r18
    2522:	02 2f       	mov	r16, r18
    2524:	7a 33       	cpi	r23, 0x3A	; 58
    2526:	28 f0       	brcs	.+10     	; 0x2532 <__ftoa_engine+0x154>
    2528:	79 e3       	ldi	r23, 0x39	; 57
    252a:	7d 93       	st	X+, r23
    252c:	2a 95       	dec	r18
    252e:	e9 f7       	brne	.-6      	; 0x252a <__ftoa_engine+0x14c>
    2530:	10 c0       	rjmp	.+32     	; 0x2552 <__ftoa_engine+0x174>
    2532:	7d 93       	st	X+, r23
    2534:	2a 95       	dec	r18
    2536:	89 f6       	brne	.-94     	; 0x24da <__ftoa_engine+0xfc>
    2538:	06 94       	lsr	r0
    253a:	97 95       	ror	r25
    253c:	67 95       	ror	r22
    253e:	37 95       	ror	r19
    2540:	17 95       	ror	r17
    2542:	17 94       	ror	r1
    2544:	e1 18       	sub	r14, r1
    2546:	f1 0a       	sbc	r15, r17
    2548:	43 0b       	sbc	r20, r19
    254a:	56 0b       	sbc	r21, r22
    254c:	c9 0b       	sbc	r28, r25
    254e:	d0 09       	sbc	r29, r0
    2550:	98 f0       	brcs	.+38     	; 0x2578 <__ftoa_engine+0x19a>
    2552:	23 95       	inc	r18
    2554:	7e 91       	ld	r23, -X
    2556:	73 95       	inc	r23
    2558:	7a 33       	cpi	r23, 0x3A	; 58
    255a:	08 f0       	brcs	.+2      	; 0x255e <__ftoa_engine+0x180>
    255c:	70 e3       	ldi	r23, 0x30	; 48
    255e:	7c 93       	st	X, r23
    2560:	20 13       	cpse	r18, r16
    2562:	b8 f7       	brcc	.-18     	; 0x2552 <__ftoa_engine+0x174>
    2564:	7e 91       	ld	r23, -X
    2566:	70 61       	ori	r23, 0x10	; 16
    2568:	7d 93       	st	X+, r23
    256a:	30 f0       	brcs	.+12     	; 0x2578 <__ftoa_engine+0x19a>
    256c:	83 95       	inc	r24
    256e:	71 e3       	ldi	r23, 0x31	; 49
    2570:	7d 93       	st	X+, r23
    2572:	70 e3       	ldi	r23, 0x30	; 48
    2574:	2a 95       	dec	r18
    2576:	e1 f7       	brne	.-8      	; 0x2570 <__ftoa_engine+0x192>
    2578:	11 24       	eor	r1, r1
    257a:	ef 90       	pop	r14
    257c:	ff 90       	pop	r15
    257e:	0f 91       	pop	r16
    2580:	1f 91       	pop	r17
    2582:	cf 91       	pop	r28
    2584:	df 91       	pop	r29
    2586:	99 27       	eor	r25, r25
    2588:	87 fd       	sbrc	r24, 7
    258a:	90 95       	com	r25
    258c:	08 95       	ret

0000258e <strnlen_P>:
    258e:	fc 01       	movw	r30, r24
    2590:	05 90       	lpm	r0, Z+
    2592:	61 50       	subi	r22, 0x01	; 1
    2594:	70 40       	sbci	r23, 0x00	; 0
    2596:	01 10       	cpse	r0, r1
    2598:	d8 f7       	brcc	.-10     	; 0x2590 <strnlen_P+0x2>
    259a:	80 95       	com	r24
    259c:	90 95       	com	r25
    259e:	8e 0f       	add	r24, r30
    25a0:	9f 1f       	adc	r25, r31
    25a2:	08 95       	ret

000025a4 <strnlen>:
    25a4:	fc 01       	movw	r30, r24
    25a6:	61 50       	subi	r22, 0x01	; 1
    25a8:	70 40       	sbci	r23, 0x00	; 0
    25aa:	01 90       	ld	r0, Z+
    25ac:	01 10       	cpse	r0, r1
    25ae:	d8 f7       	brcc	.-10     	; 0x25a6 <strnlen+0x2>
    25b0:	80 95       	com	r24
    25b2:	90 95       	com	r25
    25b4:	8e 0f       	add	r24, r30
    25b6:	9f 1f       	adc	r25, r31
    25b8:	08 95       	ret

000025ba <fputc>:
    25ba:	0f 93       	push	r16
    25bc:	1f 93       	push	r17
    25be:	cf 93       	push	r28
    25c0:	df 93       	push	r29
    25c2:	fb 01       	movw	r30, r22
    25c4:	23 81       	ldd	r18, Z+3	; 0x03
    25c6:	21 fd       	sbrc	r18, 1
    25c8:	03 c0       	rjmp	.+6      	; 0x25d0 <fputc+0x16>
    25ca:	8f ef       	ldi	r24, 0xFF	; 255
    25cc:	9f ef       	ldi	r25, 0xFF	; 255
    25ce:	2c c0       	rjmp	.+88     	; 0x2628 <fputc+0x6e>
    25d0:	22 ff       	sbrs	r18, 2
    25d2:	16 c0       	rjmp	.+44     	; 0x2600 <fputc+0x46>
    25d4:	46 81       	ldd	r20, Z+6	; 0x06
    25d6:	57 81       	ldd	r21, Z+7	; 0x07
    25d8:	24 81       	ldd	r18, Z+4	; 0x04
    25da:	35 81       	ldd	r19, Z+5	; 0x05
    25dc:	42 17       	cp	r20, r18
    25de:	53 07       	cpc	r21, r19
    25e0:	44 f4       	brge	.+16     	; 0x25f2 <fputc+0x38>
    25e2:	a0 81       	ld	r26, Z
    25e4:	b1 81       	ldd	r27, Z+1	; 0x01
    25e6:	9d 01       	movw	r18, r26
    25e8:	2f 5f       	subi	r18, 0xFF	; 255
    25ea:	3f 4f       	sbci	r19, 0xFF	; 255
    25ec:	20 83       	st	Z, r18
    25ee:	31 83       	std	Z+1, r19	; 0x01
    25f0:	8c 93       	st	X, r24
    25f2:	26 81       	ldd	r18, Z+6	; 0x06
    25f4:	37 81       	ldd	r19, Z+7	; 0x07
    25f6:	2f 5f       	subi	r18, 0xFF	; 255
    25f8:	3f 4f       	sbci	r19, 0xFF	; 255
    25fa:	26 83       	std	Z+6, r18	; 0x06
    25fc:	37 83       	std	Z+7, r19	; 0x07
    25fe:	14 c0       	rjmp	.+40     	; 0x2628 <fputc+0x6e>
    2600:	8b 01       	movw	r16, r22
    2602:	ec 01       	movw	r28, r24
    2604:	fb 01       	movw	r30, r22
    2606:	00 84       	ldd	r0, Z+8	; 0x08
    2608:	f1 85       	ldd	r31, Z+9	; 0x09
    260a:	e0 2d       	mov	r30, r0
    260c:	09 95       	icall
    260e:	89 2b       	or	r24, r25
    2610:	e1 f6       	brne	.-72     	; 0x25ca <fputc+0x10>
    2612:	d8 01       	movw	r26, r16
    2614:	16 96       	adiw	r26, 0x06	; 6
    2616:	8d 91       	ld	r24, X+
    2618:	9c 91       	ld	r25, X
    261a:	17 97       	sbiw	r26, 0x07	; 7
    261c:	01 96       	adiw	r24, 0x01	; 1
    261e:	16 96       	adiw	r26, 0x06	; 6
    2620:	8d 93       	st	X+, r24
    2622:	9c 93       	st	X, r25
    2624:	17 97       	sbiw	r26, 0x07	; 7
    2626:	ce 01       	movw	r24, r28
    2628:	df 91       	pop	r29
    262a:	cf 91       	pop	r28
    262c:	1f 91       	pop	r17
    262e:	0f 91       	pop	r16
    2630:	08 95       	ret

00002632 <__ultoa_invert>:
    2632:	fa 01       	movw	r30, r20
    2634:	aa 27       	eor	r26, r26
    2636:	28 30       	cpi	r18, 0x08	; 8
    2638:	51 f1       	breq	.+84     	; 0x268e <__ultoa_invert+0x5c>
    263a:	20 31       	cpi	r18, 0x10	; 16
    263c:	81 f1       	breq	.+96     	; 0x269e <__ultoa_invert+0x6c>
    263e:	e8 94       	clt
    2640:	6f 93       	push	r22
    2642:	6e 7f       	andi	r22, 0xFE	; 254
    2644:	6e 5f       	subi	r22, 0xFE	; 254
    2646:	7f 4f       	sbci	r23, 0xFF	; 255
    2648:	8f 4f       	sbci	r24, 0xFF	; 255
    264a:	9f 4f       	sbci	r25, 0xFF	; 255
    264c:	af 4f       	sbci	r26, 0xFF	; 255
    264e:	b1 e0       	ldi	r27, 0x01	; 1
    2650:	3e d0       	rcall	.+124    	; 0x26ce <__ultoa_invert+0x9c>
    2652:	b4 e0       	ldi	r27, 0x04	; 4
    2654:	3c d0       	rcall	.+120    	; 0x26ce <__ultoa_invert+0x9c>
    2656:	67 0f       	add	r22, r23
    2658:	78 1f       	adc	r23, r24
    265a:	89 1f       	adc	r24, r25
    265c:	9a 1f       	adc	r25, r26
    265e:	a1 1d       	adc	r26, r1
    2660:	68 0f       	add	r22, r24
    2662:	79 1f       	adc	r23, r25
    2664:	8a 1f       	adc	r24, r26
    2666:	91 1d       	adc	r25, r1
    2668:	a1 1d       	adc	r26, r1
    266a:	6a 0f       	add	r22, r26
    266c:	71 1d       	adc	r23, r1
    266e:	81 1d       	adc	r24, r1
    2670:	91 1d       	adc	r25, r1
    2672:	a1 1d       	adc	r26, r1
    2674:	20 d0       	rcall	.+64     	; 0x26b6 <__ultoa_invert+0x84>
    2676:	09 f4       	brne	.+2      	; 0x267a <__ultoa_invert+0x48>
    2678:	68 94       	set
    267a:	3f 91       	pop	r19
    267c:	2a e0       	ldi	r18, 0x0A	; 10
    267e:	26 9f       	mul	r18, r22
    2680:	11 24       	eor	r1, r1
    2682:	30 19       	sub	r19, r0
    2684:	30 5d       	subi	r19, 0xD0	; 208
    2686:	31 93       	st	Z+, r19
    2688:	de f6       	brtc	.-74     	; 0x2640 <__ultoa_invert+0xe>
    268a:	cf 01       	movw	r24, r30
    268c:	08 95       	ret
    268e:	46 2f       	mov	r20, r22
    2690:	47 70       	andi	r20, 0x07	; 7
    2692:	40 5d       	subi	r20, 0xD0	; 208
    2694:	41 93       	st	Z+, r20
    2696:	b3 e0       	ldi	r27, 0x03	; 3
    2698:	0f d0       	rcall	.+30     	; 0x26b8 <__ultoa_invert+0x86>
    269a:	c9 f7       	brne	.-14     	; 0x268e <__ultoa_invert+0x5c>
    269c:	f6 cf       	rjmp	.-20     	; 0x268a <__ultoa_invert+0x58>
    269e:	46 2f       	mov	r20, r22
    26a0:	4f 70       	andi	r20, 0x0F	; 15
    26a2:	40 5d       	subi	r20, 0xD0	; 208
    26a4:	4a 33       	cpi	r20, 0x3A	; 58
    26a6:	18 f0       	brcs	.+6      	; 0x26ae <__ultoa_invert+0x7c>
    26a8:	49 5d       	subi	r20, 0xD9	; 217
    26aa:	31 fd       	sbrc	r19, 1
    26ac:	40 52       	subi	r20, 0x20	; 32
    26ae:	41 93       	st	Z+, r20
    26b0:	02 d0       	rcall	.+4      	; 0x26b6 <__ultoa_invert+0x84>
    26b2:	a9 f7       	brne	.-22     	; 0x269e <__ultoa_invert+0x6c>
    26b4:	ea cf       	rjmp	.-44     	; 0x268a <__ultoa_invert+0x58>
    26b6:	b4 e0       	ldi	r27, 0x04	; 4
    26b8:	a6 95       	lsr	r26
    26ba:	97 95       	ror	r25
    26bc:	87 95       	ror	r24
    26be:	77 95       	ror	r23
    26c0:	67 95       	ror	r22
    26c2:	ba 95       	dec	r27
    26c4:	c9 f7       	brne	.-14     	; 0x26b8 <__ultoa_invert+0x86>
    26c6:	00 97       	sbiw	r24, 0x00	; 0
    26c8:	61 05       	cpc	r22, r1
    26ca:	71 05       	cpc	r23, r1
    26cc:	08 95       	ret
    26ce:	9b 01       	movw	r18, r22
    26d0:	ac 01       	movw	r20, r24
    26d2:	0a 2e       	mov	r0, r26
    26d4:	06 94       	lsr	r0
    26d6:	57 95       	ror	r21
    26d8:	47 95       	ror	r20
    26da:	37 95       	ror	r19
    26dc:	27 95       	ror	r18
    26de:	ba 95       	dec	r27
    26e0:	c9 f7       	brne	.-14     	; 0x26d4 <__ultoa_invert+0xa2>
    26e2:	62 0f       	add	r22, r18
    26e4:	73 1f       	adc	r23, r19
    26e6:	84 1f       	adc	r24, r20
    26e8:	95 1f       	adc	r25, r21
    26ea:	a0 1d       	adc	r26, r0
    26ec:	08 95       	ret

000026ee <__prologue_saves__>:
    26ee:	2f 92       	push	r2
    26f0:	3f 92       	push	r3
    26f2:	4f 92       	push	r4
    26f4:	5f 92       	push	r5
    26f6:	6f 92       	push	r6
    26f8:	7f 92       	push	r7
    26fa:	8f 92       	push	r8
    26fc:	9f 92       	push	r9
    26fe:	af 92       	push	r10
    2700:	bf 92       	push	r11
    2702:	cf 92       	push	r12
    2704:	df 92       	push	r13
    2706:	ef 92       	push	r14
    2708:	ff 92       	push	r15
    270a:	0f 93       	push	r16
    270c:	1f 93       	push	r17
    270e:	cf 93       	push	r28
    2710:	df 93       	push	r29
    2712:	cd b7       	in	r28, 0x3d	; 61
    2714:	de b7       	in	r29, 0x3e	; 62
    2716:	ca 1b       	sub	r28, r26
    2718:	db 0b       	sbc	r29, r27
    271a:	cd bf       	out	0x3d, r28	; 61
    271c:	de bf       	out	0x3e, r29	; 62
    271e:	09 94       	ijmp

00002720 <__epilogue_restores__>:
    2720:	2a 88       	ldd	r2, Y+18	; 0x12
    2722:	39 88       	ldd	r3, Y+17	; 0x11
    2724:	48 88       	ldd	r4, Y+16	; 0x10
    2726:	5f 84       	ldd	r5, Y+15	; 0x0f
    2728:	6e 84       	ldd	r6, Y+14	; 0x0e
    272a:	7d 84       	ldd	r7, Y+13	; 0x0d
    272c:	8c 84       	ldd	r8, Y+12	; 0x0c
    272e:	9b 84       	ldd	r9, Y+11	; 0x0b
    2730:	aa 84       	ldd	r10, Y+10	; 0x0a
    2732:	b9 84       	ldd	r11, Y+9	; 0x09
    2734:	c8 84       	ldd	r12, Y+8	; 0x08
    2736:	df 80       	ldd	r13, Y+7	; 0x07
    2738:	ee 80       	ldd	r14, Y+6	; 0x06
    273a:	fd 80       	ldd	r15, Y+5	; 0x05
    273c:	0c 81       	ldd	r16, Y+4	; 0x04
    273e:	1b 81       	ldd	r17, Y+3	; 0x03
    2740:	aa 81       	ldd	r26, Y+2	; 0x02
    2742:	b9 81       	ldd	r27, Y+1	; 0x01
    2744:	ce 0f       	add	r28, r30
    2746:	d1 1d       	adc	r29, r1
    2748:	cd bf       	out	0x3d, r28	; 61
    274a:	de bf       	out	0x3e, r29	; 62
    274c:	ed 01       	movw	r28, r26
    274e:	08 95       	ret

00002750 <_exit>:
    2750:	f8 94       	cli

00002752 <__stop_program>:
    2752:	ff cf       	rjmp	.-2      	; 0x2752 <__stop_program>
