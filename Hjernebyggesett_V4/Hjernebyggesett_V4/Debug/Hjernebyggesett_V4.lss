
Hjernebyggesett_V4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000016  00803800  0000242c  000024e0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000023c0  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000006c  0000a3c0  000023c0  00002474  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .bss          00000055  00803816  00803816  000024f6  2**0
                  ALLOC
  4 .comment      0000005c  00000000  00000000  000024f6  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002554  2**2
                  CONTENTS, READONLY
  6 .debug_aranges 000004c8  00000000  00000000  00002598  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00008612  00000000  00000000  00002a60  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000036dc  00000000  00000000  0000b072  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000028d4  00000000  00000000  0000e74e  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000890  00000000  00000000  00011024  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000349b  00000000  00000000  000118b4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000173f  00000000  00000000  00014d4f  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000340  00000000  00000000  0001648e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 de 00 	jmp	0x1bc	; 0x1bc <__ctors_end>
       4:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
       8:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
       c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      10:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      14:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      18:	0c 94 77 05 	jmp	0xaee	; 0xaee <__vector_6>
      1c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      20:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      24:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      28:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      2c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      30:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      34:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      38:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      3c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      40:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      44:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      48:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      4c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      50:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      54:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      58:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      5c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      60:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      64:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      68:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      6c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      70:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      74:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      78:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      7c:	07 63       	ori	r16, 0x37	; 55
      7e:	42 36       	cpi	r20, 0x62	; 98
      80:	b7 9b       	sbis	0x16, 7	; 22
      82:	d8 a7       	std	Y+40, r29	; 0x28
      84:	1a 39       	cpi	r17, 0x9A	; 154
      86:	68 56       	subi	r22, 0x68	; 104
      88:	18 ae       	std	Y+56, r1	; 0x38
      8a:	ba ab       	std	Y+50, r27	; 0x32
      8c:	55 8c       	ldd	r5, Z+29	; 0x1d
      8e:	1d 3c       	cpi	r17, 0xCD	; 205
      90:	b7 cc       	rjmp	.-1682   	; 0xfffffa00 <__eeprom_end+0xff7efa00>
      92:	57 63       	ori	r21, 0x37	; 55
      94:	bd 6d       	ori	r27, 0xDD	; 221
      96:	ed fd       	.word	0xfded	; ????
      98:	75 3e       	cpi	r23, 0xE5	; 229
      9a:	f6 17       	cp	r31, r22
      9c:	72 31       	cpi	r23, 0x12	; 18
      9e:	bf 00       	.word	0x00bf	; ????
      a0:	00 00       	nop
      a2:	80 3f       	cpi	r24, 0xF0	; 240
      a4:	05 a8       	ldd	r0, Z+53	; 0x35
      a6:	4c cd       	rjmp	.-1384   	; 0xfffffb40 <__eeprom_end+0xff7efb40>
      a8:	b2 d4       	rcall	.+2404   	; 0xa0e <tinyDendrite_update_signals+0xbc>
      aa:	4e b9       	out	0x0e, r20	; 14
      ac:	38 36       	cpi	r19, 0x68	; 104
      ae:	a9 02       	muls	r26, r25
      b0:	0c 50       	subi	r16, 0x0C	; 12
      b2:	b9 91       	ld	r27, Y+
      b4:	86 88       	ldd	r8, Z+22	; 0x16
      b6:	08 3c       	cpi	r16, 0xC8	; 200
      b8:	a6 aa       	std	Z+54, r10	; 0x36
      ba:	aa 2a       	or	r10, r26
      bc:	be 00       	.word	0x00be	; ????
      be:	00 00       	nop
      c0:	80 3f       	cpi	r24, 0xF0	; 240

000000c2 <__trampolines_end>:
      c2:	00 40       	sbci	r16, 0x00	; 0
      c4:	7a 10       	cpse	r7, r10
      c6:	f3 5a       	subi	r31, 0xA3	; 163
      c8:	00 a0       	ldd	r0, Z+32	; 0x20
      ca:	72 4e       	sbci	r23, 0xE2	; 226
      cc:	18 09       	sbc	r17, r8
      ce:	00 10       	cpse	r0, r0
      d0:	a5 d4       	rcall	.+2378   	; 0xa1c <tinyDendrite_update_signals+0xca>
      d2:	e8 00       	.word	0x00e8	; ????
      d4:	00 e8       	ldi	r16, 0x80	; 128
      d6:	76 48       	sbci	r23, 0x86	; 134
      d8:	17 00       	.word	0x0017	; ????
      da:	00 e4       	ldi	r16, 0x40	; 64
      dc:	0b 54       	subi	r16, 0x4B	; 75
      de:	02 00       	.word	0x0002	; ????
      e0:	00 ca       	rjmp	.-3072   	; 0xfffff4e2 <__eeprom_end+0xff7ef4e2>
      e2:	9a 3b       	cpi	r25, 0xBA	; 186
      e4:	00 00       	nop
      e6:	00 e1       	ldi	r16, 0x10	; 16
      e8:	f5 05       	cpc	r31, r5
      ea:	00 00       	nop
      ec:	80 96       	adiw	r24, 0x20	; 32
      ee:	98 00       	.word	0x0098	; ????
      f0:	00 00       	nop
      f2:	40 42       	sbci	r20, 0x20	; 32
      f4:	0f 00       	.word	0x000f	; ????
      f6:	00 00       	nop
      f8:	a0 86       	std	Z+8, r10	; 0x08
      fa:	01 00       	.word	0x0001	; ????
      fc:	00 00       	nop
      fe:	10 27       	eor	r17, r16
     100:	00 00       	nop
     102:	00 00       	nop
     104:	e8 03       	fmulsu	r22, r16
     106:	00 00       	nop
     108:	00 00       	nop
     10a:	64 00       	.word	0x0064	; ????
     10c:	00 00       	nop
     10e:	00 00       	nop
     110:	0a 00       	.word	0x000a	; ????
     112:	00 00       	nop
     114:	00 00       	nop
     116:	01 00       	.word	0x0001	; ????
     118:	00 00       	nop
     11a:	00 00       	nop
     11c:	2c 76       	andi	r18, 0x6C	; 108
     11e:	d8 88       	ldd	r13, Y+16	; 0x10
     120:	dc 67       	ori	r29, 0x7C	; 124
     122:	4f 08       	sbc	r4, r15
     124:	23 df       	rcall	.-442    	; 0xffffff6c <__eeprom_end+0xff7eff6c>
     126:	c1 df       	rcall	.-126    	; 0xaa <__SREG__+0x6b>
     128:	ae 59       	subi	r26, 0x9E	; 158
     12a:	e1 b1       	in	r30, 0x01	; 1
     12c:	b7 96       	adiw	r30, 0x27	; 39
     12e:	e5 e3       	ldi	r30, 0x35	; 53
     130:	e4 53       	subi	r30, 0x34	; 52
     132:	c6 3a       	cpi	r28, 0xA6	; 166
     134:	e6 51       	subi	r30, 0x16	; 22
     136:	99 76       	andi	r25, 0x69	; 105
     138:	96 e8       	ldi	r25, 0x86	; 134
     13a:	e6 c2       	rjmp	.+1484   	; 0x708 <tinyAxon_update_potential+0x138>
     13c:	84 26       	eor	r8, r20
     13e:	eb 89       	ldd	r30, Y+19	; 0x13
     140:	8c 9b       	sbis	0x11, 4	; 17
     142:	62 ed       	ldi	r22, 0xD2	; 210
     144:	40 7c       	andi	r20, 0xC0	; 192
     146:	6f fc       	.word	0xfc6f	; ????
     148:	ef bc       	out	0x2f, r14	; 47
     14a:	9c 9f       	mul	r25, r28
     14c:	40 f2       	brcs	.-112    	; 0xde <__trampolines_end+0x1c>
     14e:	ba a5       	ldd	r27, Y+42	; 0x2a
     150:	6f a5       	ldd	r22, Y+47	; 0x2f
     152:	f4 90       	lpm	r15, Z
     154:	05 5a       	subi	r16, 0xA5	; 165
     156:	2a f7       	brpl	.-54     	; 0x122 <__trampolines_end+0x60>
     158:	5c 93       	st	X, r21
     15a:	6b 6c       	ori	r22, 0xCB	; 203
     15c:	f9 67       	ori	r31, 0x79	; 121
     15e:	6d c1       	rjmp	.+730    	; 0x43a <system_init+0x28>
     160:	1b fc       	.word	0xfc1b	; ????
     162:	e0 e4       	ldi	r30, 0x40	; 64
     164:	0d 47       	sbci	r16, 0x7D	; 125
     166:	fe f5       	brtc	.+126    	; 0x1e6 <.do_clear_bss_loop>
     168:	20 e6       	ldi	r18, 0x60	; 96
     16a:	b5 00       	.word	0x00b5	; ????
     16c:	d0 ed       	ldi	r29, 0xD0	; 208
     16e:	90 2e       	mov	r9, r16
     170:	03 00       	.word	0x0003	; ????
     172:	94 35       	cpi	r25, 0x54	; 84
     174:	77 05       	cpc	r23, r7
     176:	00 80       	ld	r0, Z
     178:	84 1e       	adc	r8, r20
     17a:	08 00       	.word	0x0008	; ????
     17c:	00 20       	and	r0, r0
     17e:	4e 0a       	sbc	r4, r30
     180:	00 00       	nop
     182:	00 c8       	rjmp	.-4096   	; 0xfffff184 <__eeprom_end+0xff7ef184>
     184:	0c 33       	cpi	r16, 0x3C	; 60
     186:	33 33       	cpi	r19, 0x33	; 51
     188:	33 0f       	add	r19, r19
     18a:	98 6e       	ori	r25, 0xE8	; 232
     18c:	12 83       	std	Z+2, r17	; 0x02
     18e:	11 41       	sbci	r17, 0x11	; 17
     190:	ef 8d       	ldd	r30, Y+31	; 0x1f
     192:	21 14       	cp	r2, r1
     194:	89 3b       	cpi	r24, 0xB9	; 185
     196:	e6 55       	subi	r30, 0x56	; 86
     198:	16 cf       	rjmp	.-468    	; 0xffffffc6 <__eeprom_end+0xff7effc6>
     19a:	fe e6       	ldi	r31, 0x6E	; 110
     19c:	db 18       	sub	r13, r11
     19e:	d1 84       	ldd	r13, Z+9	; 0x09
     1a0:	4b 38       	cpi	r20, 0x8B	; 139
     1a2:	1b f7       	brvc	.-58     	; 0x16a <__trampolines_end+0xa8>
     1a4:	7c 1d       	adc	r23, r12
     1a6:	90 1d       	adc	r25, r0
     1a8:	a4 bb       	out	0x14, r26	; 20
     1aa:	e4 24       	eor	r14, r4
     1ac:	20 32       	cpi	r18, 0x20	; 32
     1ae:	84 72       	andi	r24, 0x24	; 36
     1b0:	5e 22       	and	r5, r30
     1b2:	81 00       	.word	0x0081	; ????
     1b4:	c9 f1       	breq	.+114    	; 0x228 <main+0x28>
     1b6:	24 ec       	ldi	r18, 0xC4	; 196
     1b8:	a1 e5       	ldi	r26, 0x51	; 81
     1ba:	3d 27       	eor	r19, r29

000001bc <__ctors_end>:
     1bc:	11 24       	eor	r1, r1
     1be:	1f be       	out	0x3f, r1	; 63
     1c0:	cf ef       	ldi	r28, 0xFF	; 255
     1c2:	cd bf       	out	0x3d, r28	; 61
     1c4:	df e3       	ldi	r29, 0x3F	; 63
     1c6:	de bf       	out	0x3e, r29	; 62

000001c8 <__do_copy_data>:
     1c8:	18 e3       	ldi	r17, 0x38	; 56
     1ca:	a0 e0       	ldi	r26, 0x00	; 0
     1cc:	b8 e3       	ldi	r27, 0x38	; 56
     1ce:	ec e2       	ldi	r30, 0x2C	; 44
     1d0:	f4 e2       	ldi	r31, 0x24	; 36
     1d2:	02 c0       	rjmp	.+4      	; 0x1d8 <__do_copy_data+0x10>
     1d4:	05 90       	lpm	r0, Z+
     1d6:	0d 92       	st	X+, r0
     1d8:	a6 31       	cpi	r26, 0x16	; 22
     1da:	b1 07       	cpc	r27, r17
     1dc:	d9 f7       	brne	.-10     	; 0x1d4 <__do_copy_data+0xc>

000001de <__do_clear_bss>:
     1de:	28 e3       	ldi	r18, 0x38	; 56
     1e0:	a6 e1       	ldi	r26, 0x16	; 22
     1e2:	b8 e3       	ldi	r27, 0x38	; 56
     1e4:	01 c0       	rjmp	.+2      	; 0x1e8 <.do_clear_bss_start>

000001e6 <.do_clear_bss_loop>:
     1e6:	1d 92       	st	X+, r1

000001e8 <.do_clear_bss_start>:
     1e8:	ab 36       	cpi	r26, 0x6B	; 107
     1ea:	b2 07       	cpc	r27, r18
     1ec:	e1 f7       	brne	.-8      	; 0x1e6 <.do_clear_bss_loop>
     1ee:	0e 94 00 01 	call	0x200	; 0x200 <main>
     1f2:	0c 94 de 11 	jmp	0x23bc	; 0x23bc <_exit>

000001f6 <__bad_interrupt>:
     1f6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000001fa <atmel_start_init>:
/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
	system_init();
     1fa:	0e 94 09 02 	call	0x412	; 0x412 <system_init>
     1fe:	08 95       	ret

00000200 <main>:

int main(void)
{	
	
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
     200:	0e 94 fd 00 	call	0x1fa	; 0x1fa <atmel_start_init>
	For some reason, instead of the reference voltage being 4.32v, it is 3.3v. 
	A plausible explanation is that the microchip does not up the voltage, so that if the microchip is only ever 
	supplied with 3.3v, it will output 3.3v as the max.
	*/
	
	VREF.CTRLA |= VREF_ADC0REFSEL_2V5_gc;
     204:	e0 ea       	ldi	r30, 0xA0	; 160
     206:	f0 e0       	ldi	r31, 0x00	; 0
     208:	80 81       	ld	r24, Z
     20a:	80 62       	ori	r24, 0x20	; 32
     20c:	80 83       	st	Z, r24
	VREF.CTRLA |= VREF_DAC0REFSEL_4V34_gc;
     20e:	80 81       	ld	r24, Z
     210:	83 60       	ori	r24, 0x03	; 3
     212:	80 83       	st	Z, r24
	 
	while (1)
	{
		// We don't want to update the neuron too often because of various reasons. The tinyISR_getflag is set every ms, and so the loop is only run once every ms.  
		if(tinyISR_getflag())
     214:	0e 94 a5 05 	call	0xb4a	; 0xb4a <tinyISR_getflag>
     218:	88 23       	and	r24, r24
     21a:	e1 f3       	breq	.-8      	; 0x214 <main+0x14>
		{
			
			if(tinyCharge_is_connected_to_charger()){
     21c:	0e 94 01 04 	call	0x802	; 0x802 <tinyCharge_is_connected_to_charger>
     220:	88 23       	and	r24, r24
     222:	59 f0       	breq	.+22     	; 0x23a <main+0x3a>
				// Charge loop
				
				if(tinyCharge_is_fully_charged()){
     224:	0e 94 04 04 	call	0x808	; 0x808 <tinyCharge_is_fully_charged>
     228:	88 23       	and	r24, r24
     22a:	21 f0       	breq	.+8      	; 0x234 <main+0x34>
					tinyLED_set_color(OUT_LED, CHARGING_DONE_COLOR);
     22c:	63 e0       	ldi	r22, 0x03	; 3
     22e:	80 e0       	ldi	r24, 0x00	; 0
     230:	0e 94 bc 05 	call	0xb78	; 0xb78 <tinyLED_set_color>
				}				
				// We check the Dendrites in order to detect if we have stopped charging
				tinyDendrite_update_signals();
     234:	0e 94 a9 04 	call	0x952	; 0x952 <tinyDendrite_update_signals>
     238:	0d c0       	rjmp	.+26     	; 0x254 <main+0x54>
			}
			else{
				// Main loop			
				
				// Set LED
				if(tinyLED_get_color(OUT_LED) == OFF){
     23a:	80 e0       	ldi	r24, 0x00	; 0
     23c:	0e 94 c5 05 	call	0xb8a	; 0xb8a <tinyLED_get_color>
     240:	81 11       	cpse	r24, r1
     242:	04 c0       	rjmp	.+8      	; 0x24c <main+0x4c>
					tinyLED_set_color_mode(OUT_LED, PING_COLOR, PING);
     244:	43 e0       	ldi	r20, 0x03	; 3
     246:	62 e0       	ldi	r22, 0x02	; 2
     248:	0e 94 cd 05 	call	0xb9a	; 0xb9a <tinyLED_set_color_mode>
				}
				
				// Update button	
				tinyButton_update();
     24c:	0e 94 a2 03 	call	0x744	; 0x744 <tinyButton_update>
				
				// Update the potential (This is where most of the important stuff happens)
				tinyPotential_update();
     250:	0e 94 e0 07 	call	0xfc0	; 0xfc0 <tinyPotential_update>
			}
			// Update LED
			tinyLED_update();
     254:	0e 94 0d 06 	call	0xc1a	; 0xc1a <tinyLED_update>
				
			// Switch transistors
			tinyCharge_set_transistors();
     258:	0e 94 29 04 	call	0x852	; 0x852 <tinyCharge_set_transistors>
			
			// Prepare for next cycle
			tinyISR_setflag(false);
     25c:	80 e0       	ldi	r24, 0x00	; 0
     25e:	0e 94 a2 05 	call	0xb44	; 0xb44 <tinyISR_setflag>
			tinyDebugger_send_uint32("time", tinyTime_now());
     262:	0e 94 c3 08 	call	0x1186	; 0x1186 <tinyTime_now>
     266:	ab 01       	movw	r20, r22
     268:	bc 01       	movw	r22, r24
     26a:	80 ec       	ldi	r24, 0xC0	; 192
     26c:	93 ea       	ldi	r25, 0xA3	; 163
     26e:	0e 94 31 04 	call	0x862	; 0x862 <tinyDebugger_send_uint32>
			tinyDebugger_end_line();
     272:	0e 94 98 04 	call	0x930	; 0x930 <tinyDebugger_end_line>
     276:	ce cf       	rjmp	.-100    	; 0x214 <main+0x14>

00000278 <ADC_0_init>:
 * \return Conversion result read from the ADC_0 ADC module
 */
adc_result_t ADC_0_get_conversion_result(void)
{
	return (ADC1.RES);
}
     278:	85 e0       	ldi	r24, 0x05	; 5
     27a:	80 93 40 06 	sts	0x0640, r24	; 0x800640 <__TEXT_REGION_LENGTH__+0x700640>
     27e:	80 e0       	ldi	r24, 0x00	; 0
     280:	08 95       	ret

00000282 <ADC_0_is_conversion_done>:
     282:	80 91 4b 06 	lds	r24, 0x064B	; 0x80064b <__TEXT_REGION_LENGTH__+0x70064b>
     286:	81 70       	andi	r24, 0x01	; 1
     288:	08 95       	ret

0000028a <ADC_0_get_conversion>:
 *
 * \return Nothing
 */
void ADC_0_start_conversion(adc_1_channel_t channel)
{
	ADC1.MUXPOS  = channel;
     28a:	e0 e4       	ldi	r30, 0x40	; 64
     28c:	f6 e0       	ldi	r31, 0x06	; 6
     28e:	86 83       	std	Z+6, r24	; 0x06
	ADC1.COMMAND = ADC_STCONV_bm;
     290:	81 e0       	ldi	r24, 0x01	; 1
     292:	80 87       	std	Z+8, r24	; 0x08
adc_result_t ADC_0_get_conversion(adc_1_channel_t channel)
{
	adc_result_t res;

	ADC_0_start_conversion(channel);
	while (!ADC_0_is_conversion_done())
     294:	0e 94 41 01 	call	0x282	; 0x282 <ADC_0_is_conversion_done>
     298:	88 23       	and	r24, r24
     29a:	e1 f3       	breq	.-8      	; 0x294 <ADC_0_get_conversion+0xa>
 *
 * \return Conversion result read from the ADC_0 ADC module
 */
adc_result_t ADC_0_get_conversion_result(void)
{
	return (ADC1.RES);
     29c:	e0 e4       	ldi	r30, 0x40	; 64
     29e:	f6 e0       	ldi	r31, 0x06	; 6
     2a0:	20 89       	ldd	r18, Z+16	; 0x10
     2a2:	31 89       	ldd	r19, Z+17	; 0x11

	ADC_0_start_conversion(channel);
	while (!ADC_0_is_conversion_done())
		;
	res = ADC_0_get_conversion_result();
	ADC1.INTFLAGS |= ADC_RESRDY_bm;
     2a4:	93 85       	ldd	r25, Z+11	; 0x0b
     2a6:	91 60       	ori	r25, 0x01	; 1
     2a8:	93 87       	std	Z+11, r25	; 0x0b
	return res;
}
     2aa:	c9 01       	movw	r24, r18
     2ac:	08 95       	ret

000002ae <BOD_init>:
	//		 | BOD_VLMCFG_BELOW_gc; /* Interrupt when supply goes below VLM level */

	// BOD.VLMCTRLA = BOD_VLMLVL_5ABOVE_gc; /* VLM threshold 5% above BOD level */

	return 0;
}
     2ae:	80 e0       	ldi	r24, 0x00	; 0
     2b0:	08 95       	ret

000002b2 <DIGITAL_GLUE_LOGIC_0_init>:

	// Enable Protected register, peripheral must be disabled (ENABLE=0, in TCD.LUT0CTRLA).

	// CCL.SEQCTRL0 = CCL_SEQSEL_DISABLE_gc /* Sequential logic disabled */;

	CCL.TRUTH0 = 168; /* Truth 0: 168 */
     2b2:	e0 ec       	ldi	r30, 0xC0	; 192
     2b4:	f1 e0       	ldi	r31, 0x01	; 1
     2b6:	28 ea       	ldi	r18, 0xA8	; 168
     2b8:	20 87       	std	Z+8, r18	; 0x08

	CCL.LUT0CTRLC = CCL_INSEL2_TCA0_gc /* TCA0 WO2 input source */;
     2ba:	98 e0       	ldi	r25, 0x08	; 8
     2bc:	97 83       	std	Z+7, r25	; 0x07

	CCL.LUT0CTRLB = CCL_INSEL0_SPI0_gc /* SPI0 SCK source */
     2be:	8b eb       	ldi	r24, 0xBB	; 187
     2c0:	86 83       	std	Z+6, r24	; 0x06
	                | CCL_INSEL1_SPI0_gc /* SPI0 MOSI input source */;

	CCL.LUT0CTRLA = 0 << CCL_CLKSRC_bp       /* Clock Source Selection: disabled */
     2c2:	39 e0       	ldi	r19, 0x09	; 9
     2c4:	35 83       	std	Z+5, r19	; 0x05
	                | CCL_EDGEDET_DIS_gc     /* Edge detector is disabled */
	                | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	                | 1 << CCL_ENABLE_bp     /* LUT Enable: enabled */
	                | 1 << CCL_OUTEN_bp;     /* Output Enable: enabled */

	CCL.TRUTH1 = 168; /* Truth 1: 168 */
     2c6:	24 87       	std	Z+12, r18	; 0x0c

	CCL.LUT1CTRLC = CCL_INSEL2_TCA0_gc /* TCA0 WO2 input source */;
     2c8:	93 87       	std	Z+11, r25	; 0x0b

	CCL.LUT1CTRLB = CCL_INSEL0_SPI0_gc /* SPI0 SCK source */
     2ca:	82 87       	std	Z+10, r24	; 0x0a
	//		 | CCL_EDGEDET_DIS_gc /* Edge detector is disabled */
	//		 | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	//		 | 0 << CCL_ENABLE_bp /* LUT Enable: disabled */
	//		 | 0 << CCL_OUTEN_bp; /* Output Enable: disabled */

	CCL.CTRLA = 1 << CCL_ENABLE_bp      /* Enable: enabled */
     2cc:	81 e4       	ldi	r24, 0x41	; 65
     2ce:	80 83       	st	Z, r24
	            | 1 << CCL_RUNSTDBY_bp; /* Run in Standby: enabled */

	return 0;
}
     2d0:	80 e0       	ldi	r24, 0x00	; 0
     2d2:	08 95       	ret

000002d4 <CLKCTRL_init>:
 *       on calling convention. The memory model is not visible to the
 *       preprocessor, so it must be defined in the Assembler preprocessor directives.
 */
static inline void ccp_write_io(void *addr, uint8_t value)
{
	protected_write_io(addr, CCP_IOREG_gc, value);
     2d4:	47 e0       	ldi	r20, 0x07	; 7
     2d6:	68 ed       	ldi	r22, 0xD8	; 216
     2d8:	8c e7       	ldi	r24, 0x7C	; 124
     2da:	90 e0       	ldi	r25, 0x00	; 0
     2dc:	0e 94 36 02 	call	0x46c	; 0x46c <protected_write_io>
     2e0:	41 e0       	ldi	r20, 0x01	; 1
     2e2:	68 ed       	ldi	r22, 0xD8	; 216
     2e4:	81 e6       	ldi	r24, 0x61	; 97
     2e6:	90 e0       	ldi	r25, 0x00	; 0
     2e8:	0e 94 36 02 	call	0x46c	; 0x46c <protected_write_io>
	//		 | 0 << CLKCTRL_CLKOUT_bp /* System clock out: disabled */);

	// ccp_write_io((void*)&(CLKCTRL.MCLKLOCK),0 << CLKCTRL_LOCKEN_bp /* lock enable: disabled */);

	return 0;
}
     2ec:	80 e0       	ldi	r24, 0x00	; 0
     2ee:	08 95       	ret

000002f0 <CPUINT_init>:

	// CPUINT.LVL0PRI = 0x0 << CPUINT_LVL0PRI_gp; /* Interrupt Level Priority: 0x0 */

	// CPUINT.LVL1VEC = 0x0 << CPUINT_LVL1VEC_gp; /* Interrupt Vector with High Priority: 0x0 */

	ENABLE_INTERRUPTS();
     2f0:	78 94       	sei

	return 0;
}
     2f2:	80 e0       	ldi	r24, 0x00	; 0
     2f4:	08 95       	ret

000002f6 <DAC_0_init>:
 *
 * \return Nothing
 */
void DAC_0_disable()
{
	DAC0.CTRLA &= ~DAC_ENABLE_bm;
     2f6:	81 e4       	ldi	r24, 0x41	; 65
     2f8:	80 93 a0 06 	sts	0x06A0, r24	; 0x8006a0 <__TEXT_REGION_LENGTH__+0x7006a0>
     2fc:	80 e0       	ldi	r24, 0x00	; 0
     2fe:	08 95       	ret

00000300 <DAC_0_set_output>:
 *
 * \return Nothing
 */
void DAC_0_set_output(dac_resolution_t value)
{
	DAC0.DATA = value;
     300:	80 93 a1 06 	sts	0x06A1, r24	; 0x8006a1 <__TEXT_REGION_LENGTH__+0x7006a1>
     304:	08 95       	ret

00000306 <mcu_init>:
#ifdef __cplusplus
extern "C" {
#endif

void mcu_init(void)
{
     306:	e0 e1       	ldi	r30, 0x10	; 16
     308:	f4 e0       	ldi	r31, 0x04	; 4
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     30a:	80 81       	ld	r24, Z
     30c:	88 60       	ori	r24, 0x08	; 8
     30e:	81 93       	st	Z+, r24
	 * disables all peripherals to save power. Driver shall enable
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
     310:	e8 31       	cpi	r30, 0x18	; 24
     312:	84 e0       	ldi	r24, 0x04	; 4
     314:	f8 07       	cpc	r31, r24
     316:	c9 f7       	brne	.-14     	; 0x30a <mcu_init+0x4>
     318:	e0 e3       	ldi	r30, 0x30	; 48
     31a:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     31c:	80 81       	ld	r24, Z
     31e:	88 60       	ori	r24, 0x08	; 8
     320:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     322:	e8 33       	cpi	r30, 0x38	; 56
     324:	84 e0       	ldi	r24, 0x04	; 4
     326:	f8 07       	cpc	r31, r24
     328:	c9 f7       	brne	.-14     	; 0x31c <mcu_init+0x16>
     32a:	e0 e5       	ldi	r30, 0x50	; 80
     32c:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     32e:	80 81       	ld	r24, Z
     330:	88 60       	ori	r24, 0x08	; 8
     332:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     334:	e8 35       	cpi	r30, 0x58	; 88
     336:	84 e0       	ldi	r24, 0x04	; 4
     338:	f8 07       	cpc	r31, r24
     33a:	c9 f7       	brne	.-14     	; 0x32e <mcu_init+0x28>
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}
}
     33c:	08 95       	ret

0000033e <ADC_0_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     33e:	e5 e1       	ldi	r30, 0x15	; 21
     340:	f4 e0       	ldi	r31, 0x04	; 4
     342:	80 81       	ld	r24, Z
     344:	88 7f       	andi	r24, 0xF8	; 248
     346:	84 60       	ori	r24, 0x04	; 4
     348:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     34a:	80 81       	ld	r24, Z
     34c:	87 7f       	andi	r24, 0xF7	; 247
     34e:	80 83       	st	Z, r24
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     350:	e7 e1       	ldi	r30, 0x17	; 23
     352:	f4 e0       	ldi	r31, 0x04	; 4
     354:	80 81       	ld	r24, Z
     356:	88 7f       	andi	r24, 0xF8	; 248
     358:	84 60       	ori	r24, 0x04	; 4
     35a:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     35c:	80 81       	ld	r24, Z
     35e:	87 7f       	andi	r24, 0xF7	; 247
     360:	80 83       	st	Z, r24
 */
static inline void PORTC_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     362:	e0 e5       	ldi	r30, 0x50	; 80
     364:	f4 e0       	ldi	r31, 0x04	; 4
     366:	80 81       	ld	r24, Z
     368:	88 7f       	andi	r24, 0xF8	; 248
     36a:	84 60       	ori	r24, 0x04	; 4
     36c:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     36e:	80 81       	ld	r24, Z
     370:	87 7f       	andi	r24, 0xF7	; 247
     372:	80 83       	st	Z, r24
 */
static inline void PORTC_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     374:	e1 e5       	ldi	r30, 0x51	; 81
     376:	f4 e0       	ldi	r31, 0x04	; 4
     378:	80 81       	ld	r24, Z
     37a:	88 7f       	andi	r24, 0xF8	; 248
     37c:	84 60       	ori	r24, 0x04	; 4
     37e:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     380:	80 81       	ld	r24, Z
     382:	87 7f       	andi	r24, 0xF7	; 247
     384:	80 83       	st	Z, r24
 */
static inline void PORTC_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     386:	e3 e5       	ldi	r30, 0x53	; 83
     388:	f4 e0       	ldi	r31, 0x04	; 4
     38a:	80 81       	ld	r24, Z
     38c:	88 7f       	andi	r24, 0xF8	; 248
     38e:	84 60       	ori	r24, 0x04	; 4
     390:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     392:	80 81       	ld	r24, Z
     394:	87 7f       	andi	r24, 0xF7	; 247
     396:	80 83       	st	Z, r24
	// Disable digital input buffer
	DEN4_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	DEN4_PIN_set_pull_mode(PORT_PULL_OFF);

	ADC_0_init();
     398:	0e 94 3c 01 	call	0x278	; 0x278 <ADC_0_init>
     39c:	08 95       	ret

0000039e <USART_0_initialization>:
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     39e:	23 98       	cbi	0x04, 3	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     3a0:	e3 e3       	ldi	r30, 0x33	; 51
     3a2:	f4 e0       	ldi	r31, 0x04	; 4
     3a4:	80 81       	ld	r24, Z
     3a6:	87 7f       	andi	r24, 0xF7	; 247
     3a8:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     3aa:	22 9a       	sbi	0x04, 2	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     3ac:	2a 98       	cbi	0x05, 2	; 5
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	USART_0_init();
     3ae:	0e 94 70 02 	call	0x4e0	; 0x4e0 <USART_0_init>
     3b2:	08 95       	ret

000003b4 <TIMER_0_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     3b4:	25 9a       	sbi	0x04, 5	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     3b6:	2d 98       	cbi	0x05, 5	; 5
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLC |= PORTMUX_TCA02_bm;
     3b8:	e0 e0       	ldi	r30, 0x00	; 0
     3ba:	f2 e0       	ldi	r31, 0x02	; 2
     3bc:	82 81       	ldd	r24, Z+2	; 0x02
     3be:	84 60       	ori	r24, 0x04	; 4
     3c0:	82 83       	std	Z+2, r24	; 0x02

	TIMER_0_init();
     3c2:	0e 94 60 02 	call	0x4c0	; 0x4c0 <TIMER_0_init>
     3c6:	08 95       	ret

000003c8 <DIGITAL_GLUE_LOGIC_0_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     3c8:	24 9a       	sbi	0x04, 4	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     3ca:	2c 98       	cbi	0x05, 4	; 5
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLA |= PORTMUX_LUT0_bm;
     3cc:	e0 e0       	ldi	r30, 0x00	; 0
     3ce:	f2 e0       	ldi	r31, 0x02	; 2
     3d0:	80 81       	ld	r24, Z
     3d2:	80 61       	ori	r24, 0x10	; 16
     3d4:	80 83       	st	Z, r24

	DIGITAL_GLUE_LOGIC_0_init();
     3d6:	0e 94 59 01 	call	0x2b2	; 0x2b2 <DIGITAL_GLUE_LOGIC_0_init>
     3da:	08 95       	ret

000003dc <SPI_0_initialization>:
 */
static inline void PORTA_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
     3dc:	02 98       	cbi	0x00, 2	; 0
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     3de:	e2 e1       	ldi	r30, 0x12	; 18
     3e0:	f4 e0       	ldi	r31, 0x04	; 4
     3e2:	80 81       	ld	r24, Z
     3e4:	87 7f       	andi	r24, 0xF7	; 247
     3e6:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     3e8:	01 9a       	sbi	0x00, 1	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     3ea:	09 98       	cbi	0x01, 1	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     3ec:	03 9a       	sbi	0x00, 3	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     3ee:	0b 98       	cbi	0x01, 3	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     3f0:	04 9a       	sbi	0x00, 4	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     3f2:	0c 98       	cbi	0x01, 4	; 1
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	SPI_0_init();
     3f4:	0e 94 58 02 	call	0x4b0	; 0x4b0 <SPI_0_init>
     3f8:	08 95       	ret

000003fa <DAC_0_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     3fa:	e6 e1       	ldi	r30, 0x16	; 22
     3fc:	f4 e0       	ldi	r31, 0x04	; 4
     3fe:	80 81       	ld	r24, Z
     400:	88 7f       	andi	r24, 0xF8	; 248
     402:	84 60       	ori	r24, 0x04	; 4
     404:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     406:	80 81       	ld	r24, Z
     408:	87 7f       	andi	r24, 0xF7	; 247
     40a:	80 83       	st	Z, r24
	// Disable digital input buffer
	AXON_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	AXON_PIN_set_pull_mode(PORT_PULL_OFF);

	DAC_0_init();
     40c:	0e 94 7b 01 	call	0x2f6	; 0x2f6 <DAC_0_init>
     410:	08 95       	ret

00000412 <system_init>:
/**
 * \brief System initialization
 */
void system_init()
{
	mcu_init();
     412:	0e 94 83 01 	call	0x306	; 0x306 <mcu_init>
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     416:	26 98       	cbi	0x04, 6	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     418:	e6 e3       	ldi	r30, 0x36	; 54
     41a:	f4 e0       	ldi	r31, 0x04	; 4
     41c:	80 81       	ld	r24, Z
     41e:	87 7f       	andi	r24, 0xF7	; 247
     420:	80 83       	st	Z, r24
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     422:	27 98       	cbi	0x04, 7	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     424:	e7 e3       	ldi	r30, 0x37	; 55
     426:	f4 e0       	ldi	r31, 0x04	; 4
     428:	80 81       	ld	r24, Z
     42a:	87 7f       	andi	r24, 0xF7	; 247
     42c:	80 83       	st	Z, r24
 */
static inline void PORTC_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
     42e:	42 98       	cbi	0x08, 2	; 8
static inline void PORTC_set_pin_pull_mode(const uint8_t pin, const enum port_pull_mode pull_mode)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
     430:	e2 e5       	ldi	r30, 0x52	; 82
     432:	f4 e0       	ldi	r31, 0x04	; 4
     434:	80 81       	ld	r24, Z
     436:	88 60       	ori	r24, 0x08	; 8
     438:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTC.DIR |= (1 << pin);
     43a:	45 9a       	sbi	0x08, 5	; 8
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     43c:	4d 9a       	sbi	0x09, 5	; 9
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    true);

	CLKCTRL_init();
     43e:	0e 94 6a 01 	call	0x2d4	; 0x2d4 <CLKCTRL_init>

	RTC_0_init();
     442:	0e 94 3a 02 	call	0x474	; 0x474 <RTC_0_init>

	ADC_0_initialization();
     446:	0e 94 9f 01 	call	0x33e	; 0x33e <ADC_0_initialization>

	USART_0_initialization();
     44a:	0e 94 cf 01 	call	0x39e	; 0x39e <USART_0_initialization>

	TIMER_0_initialization();
     44e:	0e 94 da 01 	call	0x3b4	; 0x3b4 <TIMER_0_initialization>

	DIGITAL_GLUE_LOGIC_0_initialization();
     452:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <DIGITAL_GLUE_LOGIC_0_initialization>

	SPI_0_initialization();
     456:	0e 94 ee 01 	call	0x3dc	; 0x3dc <SPI_0_initialization>

	DAC_0_initialization();
     45a:	0e 94 fd 01 	call	0x3fa	; 0x3fa <DAC_0_initialization>

	CPUINT_init();
     45e:	0e 94 78 01 	call	0x2f0	; 0x2f0 <CPUINT_init>

	SLPCTRL_init();
     462:	0e 94 56 02 	call	0x4ac	; 0x4ac <SLPCTRL_init>

	BOD_init();
     466:	0e 94 57 01 	call	0x2ae	; 0x2ae <BOD_init>
     46a:	08 95       	ret

0000046c <protected_write_io>:
#if defined(__GNUC__)
  
#ifdef RAMPZ
	out     _SFR_IO_ADDR(RAMPZ), r1         // Clear bits 23:16 of Z
#endif
	movw    r30, r24                // Load addr into Z
     46c:	fc 01       	movw	r30, r24
	out     CCP, r22                // Start CCP handshake
     46e:	64 bf       	out	0x34, r22	; 52
	st      Z, r20                  // Write value to I/O register
     470:	40 83       	st	Z, r20
	ret                             // Return to caller
     472:	08 95       	ret

00000474 <RTC_0_init>:
 * \return Initialization status.
 */
int8_t RTC_0_init()
{

	while (RTC.STATUS > 0) { /* Wait for all register to be synchronized */
     474:	e0 e4       	ldi	r30, 0x40	; 64
     476:	f1 e0       	ldi	r31, 0x01	; 1
     478:	81 81       	ldd	r24, Z+1	; 0x01
     47a:	81 11       	cpse	r24, r1
     47c:	fd cf       	rjmp	.-6      	; 0x478 <RTC_0_init+0x4>
	}

	// RTC.CMP = 0x0; /* Compare: 0x0 */

	RTC.CNT = 0x20; /* Counter: 0x20 */
     47e:	e0 e4       	ldi	r30, 0x40	; 64
     480:	f1 e0       	ldi	r31, 0x01	; 1
     482:	80 e2       	ldi	r24, 0x20	; 32
     484:	90 e0       	ldi	r25, 0x00	; 0
     486:	80 87       	std	Z+8, r24	; 0x08
     488:	91 87       	std	Z+9, r25	; 0x09

	RTC.CTRLA = RTC_PRESCALER_DIV1_gc   /* 1 */
     48a:	81 e8       	ldi	r24, 0x81	; 129
     48c:	80 83       	st	Z, r24
	            | 1 << RTC_RTCEN_bp     /* Enable: enabled */
	            | 1 << RTC_RUNSTDBY_bp; /* Run In Standby: enabled */

	RTC.PER = 0x20 / TIMESCALE; /* Period: 0x20 */
     48e:	80 e8       	ldi	r24, 0x80	; 128
     490:	92 e0       	ldi	r25, 0x02	; 2
     492:	82 87       	std	Z+10, r24	; 0x0a
     494:	93 87       	std	Z+11, r25	; 0x0b

	// RTC.CLKSEL = RTC_CLKSEL_INT32K_gc; /* 32KHz Internal Ultra Low Power Oscillator (OSCULP32K) */

	RTC.DBGCTRL = 1 << RTC_DBGRUN_bp; /* Run in debug: enabled */
     496:	81 e0       	ldi	r24, 0x01	; 1
     498:	85 83       	std	Z+5, r24	; 0x05

	RTC.INTCTRL = 0 << RTC_CMP_bp    /* Compare Match Interrupt enable: disabled */
     49a:	82 83       	std	Z+2, r24	; 0x02
	              | 1 << RTC_OVF_bp; /* Overflow Interrupt enable: enabled */

	while (RTC.PITSTATUS > 0) { /* Wait for all register to be synchronized */
     49c:	81 89       	ldd	r24, Z+17	; 0x11
     49e:	81 11       	cpse	r24, r1
     4a0:	fd cf       	rjmp	.-6      	; 0x49c <RTC_0_init+0x28>
	}

	RTC.PITCTRLA = RTC_PERIOD_OFF_gc    /* Off */
     4a2:	81 e0       	ldi	r24, 0x01	; 1
     4a4:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <__TEXT_REGION_LENGTH__+0x700150>
	// RTC.PITDBGCTRL = 0 << RTC_DBGRUN_bp; /* Run in debug: disabled */

	// RTC.PITINTCTRL = 0 << RTC_PI_bp; /* Periodic Interrupt: disabled */

	return 0;
}
     4a8:	80 e0       	ldi	r24, 0x00	; 0
     4aa:	08 95       	ret

000004ac <SLPCTRL_init>:

	// SLPCTRL.CTRLA = 0 << SLPCTRL_SEN_bp /* Sleep enable: disabled */
	//		 | SLPCTRL_SMODE_IDLE_gc; /* Idle mode */

	return 0;
}
     4ac:	80 e0       	ldi	r24, 0x00	; 0
     4ae:	08 95       	ret

000004b0 <SPI_0_init>:
 * \return Initialization status
 */
int8_t SPI_0_init()
{

	SPI0.CTRLA = 0 << SPI_CLK2X_bp     /* Enable Double Speed: disabled */
     4b0:	e0 e2       	ldi	r30, 0x20	; 32
     4b2:	f8 e0       	ldi	r31, 0x08	; 8
     4b4:	83 e2       	ldi	r24, 0x23	; 35
     4b6:	80 83       	st	Z, r24
	             | 0 << SPI_DORD_bp    /* Data Order Setting: disabled */
	             | 1 << SPI_ENABLE_bp  /* Enable Module: enabled */
	             | 1 << SPI_MASTER_bp  /* SPI module in master mode */
	             | SPI_PRESC_DIV16_gc; /* System Clock / 16 */

	SPI0.CTRLB = 0 << SPI_BUFEN_bp   /* Buffer Mode Enable: disabled */
     4b8:	84 e0       	ldi	r24, 0x04	; 4
     4ba:	81 83       	std	Z+1, r24	; 0x01
	//		 | 0 << SPI_RXCIE_bp /* Receive Complete Interrupt Enable: disabled */
	//		 | 0 << SPI_SSIE_bp /* Slave Select Trigger Interrupt Enable: disabled */
	//		 | 0 << SPI_TXCIE_bp; /* Transfer Complete Interrupt Enable: disabled */

	return 0;
}
     4bc:	80 e0       	ldi	r24, 0x00	; 0
     4be:	08 95       	ret

000004c0 <TIMER_0_init>:

	// TCA0.SINGLE.CMP0 = 0x0; /* Compare Register 0: 0x0 */

	// TCA0.SINGLE.CMP1 = 0x0; /* Compare Register 1: 0x0 */

	TCA0.SINGLE.CMP2 = 0x4; /* Compare Register 2: 0x4 */
     4c0:	e0 e0       	ldi	r30, 0x00	; 0
     4c2:	fa e0       	ldi	r31, 0x0A	; 10
     4c4:	84 e0       	ldi	r24, 0x04	; 4
     4c6:	90 e0       	ldi	r25, 0x00	; 0
     4c8:	84 a7       	std	Z+44, r24	; 0x2c
     4ca:	95 a7       	std	Z+45, r25	; 0x2d

	// TCA0.SINGLE.CNT = 0x0; /* Count: 0x0 */

	TCA0.SINGLE.CTRLB = 0 << TCA_SINGLE_ALUPD_bp            /* Auto Lock Update: disabled */
     4cc:	83 e4       	ldi	r24, 0x43	; 67
     4ce:	81 83       	std	Z+1, r24	; 0x01
	                    | 0 << TCA_SINGLE_CMP0EN_bp         /* Compare 0 Enable: disabled */
	                    | 0 << TCA_SINGLE_CMP1EN_bp         /* Compare 1 Enable: disabled */
	                    | 1 << TCA_SINGLE_CMP2EN_bp         /* Compare 2 Enable: enabled */
	                    | TCA_SINGLE_WGMODE_SINGLESLOPE_gc; /*  */

	TCA0.SINGLE.CTRLC = 0 << TCA_SINGLE_CMP0OV_bp    /* Compare 0 Waveform Output Value: disabled */
     4d0:	84 e0       	ldi	r24, 0x04	; 4
     4d2:	82 83       	std	Z+2, r24	; 0x02
	// TCA0.SINGLE.INTCTRL = 0 << TCA_SINGLE_CMP0_bp /* Compare 0 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP1_bp /* Compare 1 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP2_bp /* Compare 2 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_OVF_bp; /* Overflow Interrupt: disabled */

	TCA0.SINGLE.PER = 0x7; /* Period: 0x7 */
     4d4:	87 e0       	ldi	r24, 0x07	; 7
     4d6:	90 e0       	ldi	r25, 0x00	; 0
     4d8:	86 a3       	std	Z+38, r24	; 0x26
     4da:	97 a3       	std	Z+39, r25	; 0x27

	// TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV1_gc /* System Clock */
	//		 | 0 << TCA_SINGLE_ENABLE_bp; /* Module Enable: disabled */

	return 0;
}
     4dc:	80 e0       	ldi	r24, 0x00	; 0
     4de:	08 95       	ret

000004e0 <USART_0_init>:
uint8_t USART_0_read()
{
	while (!(USART0.STATUS & USART_RXCIF_bm))
		;
	return USART0.RXDATAL;
}
     4e0:	e0 e0       	ldi	r30, 0x00	; 0
     4e2:	f8 e0       	ldi	r31, 0x08	; 8
     4e4:	87 e4       	ldi	r24, 0x47	; 71
     4e6:	90 e1       	ldi	r25, 0x10	; 16
     4e8:	80 87       	std	Z+8, r24	; 0x08
     4ea:	91 87       	std	Z+9, r25	; 0x09
     4ec:	80 ec       	ldi	r24, 0xC0	; 192
     4ee:	86 83       	std	Z+6, r24	; 0x06
     4f0:	80 e0       	ldi	r24, 0x00	; 0
     4f2:	98 e3       	ldi	r25, 0x38	; 56
     4f4:	80 93 67 38 	sts	0x3867, r24	; 0x803867 <__iob+0x2>
     4f8:	90 93 68 38 	sts	0x3868, r25	; 0x803868 <__iob+0x3>
     4fc:	80 e0       	ldi	r24, 0x00	; 0
     4fe:	08 95       	ret

00000500 <USART_0_write>:
 *
 * \return Nothing
 */
void USART_0_write(const uint8_t data)
{
	while (!(USART0.STATUS & USART_DREIF_bm))
     500:	e0 e0       	ldi	r30, 0x00	; 0
     502:	f8 e0       	ldi	r31, 0x08	; 8
     504:	94 81       	ldd	r25, Z+4	; 0x04
     506:	95 ff       	sbrs	r25, 5
     508:	fd cf       	rjmp	.-6      	; 0x504 <USART_0_write+0x4>
		;
	USART0.TXDATAL = data;
     50a:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <__TEXT_REGION_LENGTH__+0x700802>
     50e:	08 95       	ret

00000510 <USART_0_printCHAR>:

#if defined(__GNUC__)

int USART_0_printCHAR(char character, FILE *stream)
{
	USART_0_write(character);
     510:	0e 94 80 02 	call	0x500	; 0x500 <USART_0_write>
	return 0;
}
     514:	80 e0       	ldi	r24, 0x00	; 0
     516:	90 e0       	ldi	r25, 0x00	; 0
     518:	08 95       	ret

0000051a <tinyAxon_add_pulse>:
{
	// We want to check each slot in the pulse_queue, and
	// if we find an empty slot (0), we add a pulse.
	for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
	{
		if(pulse_queue[i] == 0){
     51a:	20 91 17 38 	lds	r18, 0x3817	; 0x803817 <pulse_queue>
     51e:	30 91 18 38 	lds	r19, 0x3818	; 0x803818 <pulse_queue+0x1>
     522:	23 2b       	or	r18, r19
     524:	51 f0       	breq	.+20     	; 0x53a <tinyAxon_add_pulse+0x20>
     526:	e9 e1       	ldi	r30, 0x19	; 25
     528:	f8 e3       	ldi	r31, 0x38	; 56
     52a:	21 e0       	ldi	r18, 0x01	; 1
     52c:	30 e0       	ldi	r19, 0x00	; 0
     52e:	b9 01       	movw	r22, r18
     530:	41 91       	ld	r20, Z+
     532:	51 91       	ld	r21, Z+
     534:	45 2b       	or	r20, r21
     536:	81 f4       	brne	.+32     	; 0x558 <tinyAxon_add_pulse+0x3e>
     538:	02 c0       	rjmp	.+4      	; 0x53e <tinyAxon_add_pulse+0x24>
     53a:	60 e0       	ldi	r22, 0x00	; 0
     53c:	70 e0       	ldi	r23, 0x00	; 0
			pulse_queue[i] = new_pulse;
     53e:	66 0f       	add	r22, r22
     540:	77 1f       	adc	r23, r23
     542:	fb 01       	movw	r30, r22
     544:	e9 5e       	subi	r30, 0xE9	; 233
     546:	f7 4c       	sbci	r31, 0xC7	; 199
     548:	80 83       	st	Z, r24
     54a:	91 83       	std	Z+1, r25	; 0x01
			pulses_in_queue++;
     54c:	80 91 2b 38 	lds	r24, 0x382B	; 0x80382b <pulses_in_queue>
     550:	8f 5f       	subi	r24, 0xFF	; 255
     552:	80 93 2b 38 	sts	0x382B, r24	; 0x80382b <pulses_in_queue>
			// We return so we only ever add one
			break;
     556:	08 95       	ret
     558:	2f 5f       	subi	r18, 0xFF	; 255
     55a:	3f 4f       	sbci	r19, 0xFF	; 255
*/
static void tinyAxon_add_pulse(uint16_t new_pulse)
{
	// We want to check each slot in the pulse_queue, and
	// if we find an empty slot (0), we add a pulse.
	for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
     55c:	2a 30       	cpi	r18, 0x0A	; 10
     55e:	31 05       	cpc	r19, r1
     560:	31 f7       	brne	.-52     	; 0x52e <tinyAxon_add_pulse+0x14>
     562:	08 95       	ret

00000564 <find_newest_pulse>:
uint8_t find_newest_pulse() {
	uint16_t max;
	uint8_t current_index = 0;
	uint8_t return_index = 0;
	
	max = pulse_queue[current_index];
     564:	40 91 17 38 	lds	r20, 0x3817	; 0x803817 <pulse_queue>
     568:	50 91 18 38 	lds	r21, 0x3818	; 0x803818 <pulse_queue+0x1>
     56c:	e9 e1       	ldi	r30, 0x19	; 25
     56e:	f8 e3       	ldi	r31, 0x38	; 56
	
// This function will be used with pulse_queue to find the newest pulse
uint8_t find_newest_pulse() {
	uint16_t max;
	uint8_t current_index = 0;
	uint8_t return_index = 0;
     570:	80 e0       	ldi	r24, 0x00	; 0
	
	max = pulse_queue[current_index];
	
	for (current_index = 1; current_index < MAX_NUMBER_OF_PULSES; current_index++) {
     572:	91 e0       	ldi	r25, 0x01	; 1
		if (pulse_queue[current_index] > max) {
     574:	21 91       	ld	r18, Z+
     576:	31 91       	ld	r19, Z+
     578:	42 17       	cp	r20, r18
     57a:	53 07       	cpc	r21, r19
     57c:	10 f4       	brcc	.+4      	; 0x582 <find_newest_pulse+0x1e>
     57e:	89 2f       	mov	r24, r25
			return_index = current_index;
			max = pulse_queue[current_index];
     580:	a9 01       	movw	r20, r18
	uint8_t current_index = 0;
	uint8_t return_index = 0;
	
	max = pulse_queue[current_index];
	
	for (current_index = 1; current_index < MAX_NUMBER_OF_PULSES; current_index++) {
     582:	9f 5f       	subi	r25, 0xFF	; 255
     584:	9a 30       	cpi	r25, 0x0A	; 10
     586:	b1 f7       	brne	.-20     	; 0x574 <find_newest_pulse+0x10>
			return_index = current_index;
			max = pulse_queue[current_index];
		}
	}
	return return_index;
}
     588:	08 95       	ret

0000058a <tinyAxon_remove_pulse>:

/*
If the potential is very low, we want to try to remove a pulse.
*/
bool tinyAxon_remove_pulse(void)
{
     58a:	cf 93       	push	r28
	// We want to return a bool indicating whether or not a pulse actually was removed.
	if(pulses_in_queue == 0){
     58c:	c0 91 2b 38 	lds	r28, 0x382B	; 0x80382b <pulses_in_queue>
     590:	cc 23       	and	r28, r28
     592:	c9 f0       	breq	.+50     	; 0x5c6 <tinyAxon_remove_pulse+0x3c>
		//There was no pulse to remove.
		return false;
	}
	else{
		// If we are to remove a pulse, we want to remove the one that will fire last.
		uint8_t pulse_index = find_newest_pulse();
     594:	0e 94 b2 02 	call	0x564	; 0x564 <find_newest_pulse>
		uint16_t newest_pulse = pulse_queue[pulse_index];
     598:	90 e0       	ldi	r25, 0x00	; 0
     59a:	fc 01       	movw	r30, r24
     59c:	ee 0f       	add	r30, r30
     59e:	ff 1f       	adc	r31, r31
     5a0:	e9 5e       	subi	r30, 0xE9	; 233
     5a2:	f7 4c       	sbci	r31, 0xC7	; 199
	
		// Now we want to check if the pulse is too far away to be affected by the low potential, or close enough that we decide to remove it.
		// (When we say that the pulse is too far away, it refers to the biological process of how the potential spreads from Dendrites to axon).
		if(newest_pulse > PULSE_NO_RETURN_TIME){
     5a4:	20 81       	ld	r18, Z
     5a6:	31 81       	ldd	r19, Z+1	; 0x01
     5a8:	2d 33       	cpi	r18, 0x3D	; 61
     5aa:	31 05       	cpc	r19, r1
     5ac:	70 f0       	brcs	.+28     	; 0x5ca <tinyAxon_remove_pulse+0x40>
			// We decided to remove the pulse
			pulse_queue[pulse_index] = 0;
     5ae:	88 0f       	add	r24, r24
     5b0:	99 1f       	adc	r25, r25
     5b2:	fc 01       	movw	r30, r24
     5b4:	e9 5e       	subi	r30, 0xE9	; 233
     5b6:	f7 4c       	sbci	r31, 0xC7	; 199
     5b8:	10 82       	st	Z, r1
     5ba:	11 82       	std	Z+1, r1	; 0x01
			pulses_in_queue--;
     5bc:	c1 50       	subi	r28, 0x01	; 1
     5be:	c0 93 2b 38 	sts	0x382B, r28	; 0x80382b <pulses_in_queue>
			return true;
     5c2:	81 e0       	ldi	r24, 0x01	; 1
     5c4:	03 c0       	rjmp	.+6      	; 0x5cc <tinyAxon_remove_pulse+0x42>
bool tinyAxon_remove_pulse(void)
{
	// We want to return a bool indicating whether or not a pulse actually was removed.
	if(pulses_in_queue == 0){
		//There was no pulse to remove.
		return false;
     5c6:	80 e0       	ldi	r24, 0x00	; 0
     5c8:	01 c0       	rjmp	.+2      	; 0x5cc <tinyAxon_remove_pulse+0x42>
			pulses_in_queue--;
			return true;
		}
		// Here we have found that there is a pulse queued, but it is old enough to let pass anyway, so now we need to put it back into the queue.
		else{
			return false;
     5ca:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     5cc:	cf 91       	pop	r28
     5ce:	08 95       	ret

000005d0 <tinyAxon_update_potential>:
/*
Decides whether or not the axon should fire
If the axon does fire, the potential is reduced
*/
double tinyAxon_update_potential(double potential)
{	
     5d0:	cf 92       	push	r12
     5d2:	df 92       	push	r13
     5d4:	ef 92       	push	r14
     5d6:	ff 92       	push	r15
     5d8:	6b 01       	movw	r12, r22
     5da:	7c 01       	movw	r14, r24
	//While the neuron has enough potential to fire, we want to fire more
	while (potential > THRESHOLD_POTENTIAL)
     5dc:	20 e0       	ldi	r18, 0x00	; 0
     5de:	30 e0       	ldi	r19, 0x00	; 0
     5e0:	48 ec       	ldi	r20, 0xC8	; 200
     5e2:	51 e4       	ldi	r21, 0x41	; 65
     5e4:	0e 94 11 0b 	call	0x1622	; 0x1622 <__gesf2>
     5e8:	18 16       	cp	r1, r24
     5ea:	bc f5       	brge	.+110    	; 0x65a <tinyAxon_update_potential+0x8a>
	{
		// We have to check if there are already queued pulses, so that the frequency never exceeds FIRE_DELAY
		if(pulses_in_queue>0){
     5ec:	80 91 2b 38 	lds	r24, 0x382B	; 0x80382b <pulses_in_queue>
     5f0:	88 23       	and	r24, r24
     5f2:	b1 f0       	breq	.+44     	; 0x620 <tinyAxon_update_potential+0x50>
			uint16_t newest_pulse = pulse_queue[find_newest_pulse()];
     5f4:	0e 94 b2 02 	call	0x564	; 0x564 <find_newest_pulse>
     5f8:	e8 2f       	mov	r30, r24
     5fa:	f0 e0       	ldi	r31, 0x00	; 0
     5fc:	ee 0f       	add	r30, r30
     5fe:	ff 1f       	adc	r31, r31
     600:	e9 5e       	subi	r30, 0xE9	; 233
     602:	f7 4c       	sbci	r31, 0xC7	; 199
			
			// There is at least one pulse in the queue, and it is so close, that we need to offset the new pulse, so that we keep at least
			// one FIRE_DELAY between each pulse
			if(newest_pulse + FIRE_DELAY > TRAVLE_DELAY){
     604:	80 81       	ld	r24, Z
     606:	91 81       	ldd	r25, Z+1	; 0x01
     608:	c2 96       	adiw	r24, 0x32	; 50
     60a:	85 36       	cpi	r24, 0x65	; 101
     60c:	91 05       	cpc	r25, r1
     60e:	18 f0       	brcs	.+6      	; 0x616 <tinyAxon_update_potential+0x46>
				tinyAxon_add_pulse(newest_pulse + FIRE_DELAY);
     610:	0e 94 8d 02 	call	0x51a	; 0x51a <tinyAxon_add_pulse>
     614:	09 c0       	rjmp	.+18     	; 0x628 <tinyAxon_update_potential+0x58>
			}
			// There is at least one pulse in the queue, but it's far enough away to ignore
			else{
				tinyAxon_add_pulse(TRAVLE_DELAY);
     616:	84 e6       	ldi	r24, 0x64	; 100
     618:	90 e0       	ldi	r25, 0x00	; 0
     61a:	0e 94 8d 02 	call	0x51a	; 0x51a <tinyAxon_add_pulse>
     61e:	04 c0       	rjmp	.+8      	; 0x628 <tinyAxon_update_potential+0x58>
			}
		}
		// There are no pulses in the queue, so we add a pulse as normal
		else{
			tinyAxon_add_pulse(TRAVLE_DELAY);		
     620:	84 e6       	ldi	r24, 0x64	; 100
     622:	90 e0       	ldi	r25, 0x00	; 0
     624:	0e 94 8d 02 	call	0x51a	; 0x51a <tinyAxon_add_pulse>
		}
		
		potential += POSTFIRE_POTENTIAL_REACTION; // This is usually defined as a negative value, don't be confused by the +=
     628:	20 e0       	ldi	r18, 0x00	; 0
     62a:	30 e0       	ldi	r19, 0x00	; 0
     62c:	40 ef       	ldi	r20, 0xF0	; 240
     62e:	51 e4       	ldi	r21, 0x41	; 65
     630:	c7 01       	movw	r24, r14
     632:	b6 01       	movw	r22, r12
     634:	0e 94 cc 08 	call	0x1198	; 0x1198 <__subsf3>
     638:	6b 01       	movw	r12, r22
     63a:	7c 01       	movw	r14, r24
		
		tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
     63c:	44 e0       	ldi	r20, 0x04	; 4
     63e:	63 e0       	ldi	r22, 0x03	; 3
     640:	81 e0       	ldi	r24, 0x01	; 1
     642:	0e 94 cd 05 	call	0xb9a	; 0xb9a <tinyLED_set_color_mode>
If the axon does fire, the potential is reduced
*/
double tinyAxon_update_potential(double potential)
{	
	//While the neuron has enough potential to fire, we want to fire more
	while (potential > THRESHOLD_POTENTIAL)
     646:	20 e0       	ldi	r18, 0x00	; 0
     648:	30 e0       	ldi	r19, 0x00	; 0
     64a:	48 ec       	ldi	r20, 0xC8	; 200
     64c:	51 e4       	ldi	r21, 0x41	; 65
     64e:	c7 01       	movw	r24, r14
     650:	b6 01       	movw	r22, r12
     652:	0e 94 11 0b 	call	0x1622	; 0x1622 <__gesf2>
     656:	18 16       	cp	r1, r24
     658:	4c f2       	brlt	.-110    	; 0x5ec <tinyAxon_update_potential+0x1c>
		
		tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
	}
	
	// If the neuron has a very low potential, we want to remove a pulse from the queue (if there is one)
	if(potential < -THRESHOLD_POTENTIAL && pulses_in_queue > 0) // Perhaps this should be a separate variable? For now, we will just simply use -THRESHOLD_POTENTIAL
     65a:	20 e0       	ldi	r18, 0x00	; 0
     65c:	30 e0       	ldi	r19, 0x00	; 0
     65e:	48 ec       	ldi	r20, 0xC8	; 200
     660:	51 ec       	ldi	r21, 0xC1	; 193
     662:	c7 01       	movw	r24, r14
     664:	b6 01       	movw	r22, r12
     666:	0e 94 39 09 	call	0x1272	; 0x1272 <__cmpsf2>
     66a:	88 23       	and	r24, r24
     66c:	0c f0       	brlt	.+2      	; 0x670 <tinyAxon_update_potential+0xa0>
     66e:	4b c0       	rjmp	.+150    	; 0x706 <tinyAxon_update_potential+0x136>
     670:	80 91 2b 38 	lds	r24, 0x382B	; 0x80382b <pulses_in_queue>
     674:	88 23       	and	r24, r24
     676:	19 f1       	breq	.+70     	; 0x6be <tinyAxon_update_potential+0xee>
	{
		// The neurons potential is low enough to attempt to remove a queued fire (Fire less)
		if(tinyAxon_remove_pulse())
     678:	0e 94 c5 02 	call	0x58a	; 0x58a <tinyAxon_remove_pulse>
     67c:	88 23       	and	r24, r24
     67e:	09 f4       	brne	.+2      	; 0x682 <tinyAxon_update_potential+0xb2>
     680:	42 c0       	rjmp	.+132    	; 0x706 <tinyAxon_update_potential+0x136>
		{
			// The potential has evened out a bit
			potential += THRESHOLD_POTENTIAL;
     682:	20 e0       	ldi	r18, 0x00	; 0
     684:	30 e0       	ldi	r19, 0x00	; 0
     686:	48 ec       	ldi	r20, 0xC8	; 200
     688:	51 e4       	ldi	r21, 0x41	; 65
     68a:	c7 01       	movw	r24, r14
     68c:	b6 01       	movw	r22, r12
     68e:	0e 94 cd 08 	call	0x119a	; 0x119a <__addsf3>
     692:	6b 01       	movw	r12, r22
     694:	7c 01       	movw	r14, r24
     696:	37 c0       	rjmp	.+110    	; 0x706 <tinyAxon_update_potential+0x136>
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
	{
		for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
		{
			if(pulse_queue[i] != 0){
     698:	80 81       	ld	r24, Z
     69a:	91 81       	ldd	r25, Z+1	; 0x01
     69c:	00 97       	sbiw	r24, 0x00	; 0
     69e:	39 f0       	breq	.+14     	; 0x6ae <tinyAxon_update_potential+0xde>
				pulse_queue[i]--;
     6a0:	01 97       	sbiw	r24, 0x01	; 1
     6a2:	80 83       	st	Z, r24
     6a4:	91 83       	std	Z+1, r25	; 0x01
				
				// If the time went from 1 to 0, we fire the axon
				if(pulse_queue[i] == 0){
     6a6:	89 2b       	or	r24, r25
     6a8:	11 f4       	brne	.+4      	; 0x6ae <tinyAxon_update_potential+0xde>
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
	pulses_in_queue--;
     6aa:	41 50       	subi	r20, 0x01	; 1
Function to set firing.
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
     6ac:	51 e0       	ldi	r21, 0x01	; 1
     6ae:	32 96       	adiw	r30, 0x02	; 2
	}
	
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
	{
		for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
     6b0:	e2 17       	cp	r30, r18
     6b2:	f3 07       	cpc	r31, r19
     6b4:	89 f7       	brne	.-30     	; 0x698 <tinyAxon_update_potential+0xc8>
     6b6:	50 93 2c 38 	sts	0x382C, r21	; 0x80382c <tinyAxon_should_fire>
     6ba:	40 93 2b 38 	sts	0x382B, r20	; 0x80382b <pulses_in_queue>
The function should set the DAC to fire for two
update cycles once the pulse flag is set high.
*/
static void tinyAxon_update_pulse_transmitter(void)
{
	if (tinyAxon_should_fire)
     6be:	80 91 2c 38 	lds	r24, 0x382C	; 0x80382c <tinyAxon_should_fire>
     6c2:	88 23       	and	r24, r24
     6c4:	91 f0       	breq	.+36     	; 0x6ea <tinyAxon_update_potential+0x11a>
	{
		tinyAxon_should_fire = false;
     6c6:	10 92 2c 38 	sts	0x382C, r1	; 0x80382c <tinyAxon_should_fire>
		tinyAxon_has_fired = true;
     6ca:	81 e0       	ldi	r24, 0x01	; 1
     6cc:	80 93 2d 38 	sts	0x382D, r24	; 0x80382d <tinyAxon_has_fired>
*/
static void tinyAxon_start_sending_pulse()
{
	if (NEURONTYPE == EXCITATORY_NEURON)
	{
		DAC_0_set_output(EXCITATORY_NEURON_OUTPUT);
     6d0:	8f ef       	ldi	r24, 0xFF	; 255
     6d2:	90 e0       	ldi	r25, 0x00	; 0
     6d4:	0e 94 80 01 	call	0x300	; 0x300 <DAC_0_set_output>
		axonOutputValue=EXCITATORY_NEURON_OUTPUT;
     6d8:	8f ef       	ldi	r24, 0xFF	; 255
     6da:	80 93 16 38 	sts	0x3816, r24	; 0x803816 <__data_end>
	{
		DAC_0_set_output(INHIBITORY_NEURON_OUTPUT);
		axonOutputValue=INHIBITORY_NEURON_OUTPUT;
	}
	
	tinyLED_set_color_mode(OUT_LED, WHITE, FLASH_ONCE);
     6de:	44 e0       	ldi	r20, 0x04	; 4
     6e0:	64 e0       	ldi	r22, 0x04	; 4
     6e2:	80 e0       	ldi	r24, 0x00	; 0
     6e4:	0e 94 cd 05 	call	0xb9a	; 0xb9a <tinyLED_set_color_mode>
     6e8:	19 c0       	rjmp	.+50     	; 0x71c <tinyAxon_update_potential+0x14c>
		tinyAxon_should_fire = false;
		tinyAxon_has_fired = true;
		
		tinyAxon_start_sending_pulse();
	}
	else if (tinyAxon_has_fired)
     6ea:	80 91 2d 38 	lds	r24, 0x382D	; 0x80382d <tinyAxon_has_fired>
     6ee:	88 23       	and	r24, r24
     6f0:	19 f0       	breq	.+6      	; 0x6f8 <tinyAxon_update_potential+0x128>
	{
		tinyAxon_has_fired = false;
     6f2:	10 92 2d 38 	sts	0x382D, r1	; 0x80382d <tinyAxon_has_fired>
     6f6:	12 c0       	rjmp	.+36     	; 0x71c <tinyAxon_update_potential+0x14c>
	tinyLED_set_color_mode(OUT_LED, WHITE, FLASH_ONCE);
}

static void tinyAxon_stop_sending_pulse()
{
	DAC_0_set_output(NO_SIGNAL_OUTPUT);
     6f8:	80 e0       	ldi	r24, 0x00	; 0
     6fa:	90 e0       	ldi	r25, 0x00	; 0
     6fc:	0e 94 80 01 	call	0x300	; 0x300 <DAC_0_set_output>
	axonOutputValue=NO_SIGNAL_OUTPUT;
     700:	10 92 16 38 	sts	0x3816, r1	; 0x803816 <__data_end>
     704:	0b c0       	rjmp	.+22     	; 0x71c <tinyAxon_update_potential+0x14c>
			potential += THRESHOLD_POTENTIAL;
		}
	}
	
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
     706:	40 91 2b 38 	lds	r20, 0x382B	; 0x80382b <pulses_in_queue>
     70a:	44 23       	and	r20, r20
     70c:	c1 f2       	breq	.-80     	; 0x6be <tinyAxon_update_potential+0xee>
     70e:	50 91 2c 38 	lds	r21, 0x382C	; 0x80382c <tinyAxon_should_fire>
     712:	e7 e1       	ldi	r30, 0x17	; 23
     714:	f8 e3       	ldi	r31, 0x38	; 56
     716:	2b e2       	ldi	r18, 0x2B	; 43
     718:	38 e3       	ldi	r19, 0x38	; 56
     71a:	be cf       	rjmp	.-132    	; 0x698 <tinyAxon_update_potential+0xc8>
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTB_get_pin_level(const uint8_t pin)
{
	return VPORTB.IN & (1 << pin);
     71c:	86 b1       	in	r24, 0x06	; 6
	// We need to check if the axon is connected to a charger. We do this by checking the AXON_CHECK_PIN. If it is hight while the axon is not firing, it must be connected to a charger
	if(AXON_CHECK_PIN_get_level() && !tinyAxon_should_fire){
		//tinyCharge_set_charging_mode(true);
	}
	
	tinyDebugger_send_uint8("Axon", axonOutputValue);
     71e:	60 91 16 38 	lds	r22, 0x3816	; 0x803816 <__data_end>
     722:	85 ec       	ldi	r24, 0xC5	; 197
     724:	93 ea       	ldi	r25, 0xA3	; 163
     726:	0e 94 47 04 	call	0x88e	; 0x88e <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("Pulses", pulses_in_queue);
     72a:	60 91 2b 38 	lds	r22, 0x382B	; 0x80382b <pulses_in_queue>
     72e:	8a ec       	ldi	r24, 0xCA	; 202
     730:	93 ea       	ldi	r25, 0xA3	; 163
     732:	0e 94 47 04 	call	0x88e	; 0x88e <tinyDebugger_send_uint8>
	
	return potential;
}
     736:	c7 01       	movw	r24, r14
     738:	b6 01       	movw	r22, r12
     73a:	ff 90       	pop	r15
     73c:	ef 90       	pop	r14
     73e:	df 90       	pop	r13
     740:	cf 90       	pop	r12
     742:	08 95       	ret

00000744 <tinyButton_update>:
/*
If the button has been let go, we change button_press to true. This only lasts one cycle, before it is set to false again.
If the button is held down for longer than PULSEMODE_BUTTON_PRESS_TIME, we toggle the pulse mode state.
*/
void tinyButton_update(void)
{
     744:	0f 93       	push	r16
     746:	1f 93       	push	r17
     748:	cf 93       	push	r28
     74a:	df 93       	push	r29
	button_press = false;
     74c:	10 92 32 38 	sts	0x3832, r1	; 0x803832 <button_press>
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTC_get_pin_level(const uint8_t pin)
{
	return VPORTC.IN & (1 << pin);
     750:	8a b1       	in	r24, 0x0a	; 10
	_Bool button_is_pushed_down = !BUTTON_PIN_get_level(); // The digital port will be read as low if the button is pushed down.
     752:	d1 e0       	ldi	r29, 0x01	; 1
     754:	c8 2f       	mov	r28, r24
     756:	c4 70       	andi	r28, 0x04	; 4
     758:	82 fd       	sbrc	r24, 2
     75a:	d0 e0       	ldi	r29, 0x00	; 0

	if (button_is_pushed_down && !button_was_pushed_down)
     75c:	c1 11       	cpse	r28, r1
     75e:	36 c0       	rjmp	.+108    	; 0x7cc <tinyButton_update+0x88>
     760:	80 91 33 38 	lds	r24, 0x3833	; 0x803833 <button_was_pushed_down>
     764:	81 11       	cpse	r24, r1
     766:	0e c0       	rjmp	.+28     	; 0x784 <tinyButton_update+0x40>
	{
		tinyButton_start_time = tinyTime_now();
     768:	0e 94 c3 08 	call	0x1186	; 0x1186 <tinyTime_now>
     76c:	60 93 2e 38 	sts	0x382E, r22	; 0x80382e <tinyButton_start_time>
     770:	70 93 2f 38 	sts	0x382F, r23	; 0x80382f <tinyButton_start_time+0x1>
     774:	80 93 30 38 	sts	0x3830, r24	; 0x803830 <tinyButton_start_time+0x2>
     778:	90 93 31 38 	sts	0x3831, r25	; 0x803831 <tinyButton_start_time+0x3>
	}
	if (button_is_pushed_down && button_was_pushed_down)
     77c:	80 91 33 38 	lds	r24, 0x3833	; 0x803833 <button_was_pushed_down>
     780:	88 23       	and	r24, r24
     782:	69 f1       	breq	.+90     	; 0x7de <tinyButton_update+0x9a>
	{
		if ((tinyTime_now() - tinyButton_start_time) > PULSEMODE_BUTTON_PRESS_TIME)
     784:	0e 94 c3 08 	call	0x1186	; 0x1186 <tinyTime_now>
     788:	00 91 2e 38 	lds	r16, 0x382E	; 0x80382e <tinyButton_start_time>
     78c:	10 91 2f 38 	lds	r17, 0x382F	; 0x80382f <tinyButton_start_time+0x1>
     790:	20 91 30 38 	lds	r18, 0x3830	; 0x803830 <tinyButton_start_time+0x2>
     794:	30 91 31 38 	lds	r19, 0x3831	; 0x803831 <tinyButton_start_time+0x3>
     798:	60 1b       	sub	r22, r16
     79a:	71 0b       	sbc	r23, r17
     79c:	82 0b       	sbc	r24, r18
     79e:	93 0b       	sbc	r25, r19
     7a0:	0e 94 19 0a 	call	0x1432	; 0x1432 <__floatunsisf>
     7a4:	20 e0       	ldi	r18, 0x00	; 0
     7a6:	30 e0       	ldi	r19, 0x00	; 0
     7a8:	48 ec       	ldi	r20, 0xC8	; 200
     7aa:	52 e4       	ldi	r21, 0x42	; 66
     7ac:	0e 94 11 0b 	call	0x1622	; 0x1622 <__gesf2>
     7b0:	18 16       	cp	r1, r24
     7b2:	64 f4       	brge	.+24     	; 0x7cc <tinyButton_update+0x88>
		{
			tinyPulse_toggle_pulse_mode();
     7b4:	0e 94 70 08 	call	0x10e0	; 0x10e0 <tinyPulse_toggle_pulse_mode>
			tinyButton_start_time = tinyTime_now();
     7b8:	0e 94 c3 08 	call	0x1186	; 0x1186 <tinyTime_now>
     7bc:	60 93 2e 38 	sts	0x382E, r22	; 0x80382e <tinyButton_start_time>
     7c0:	70 93 2f 38 	sts	0x382F, r23	; 0x80382f <tinyButton_start_time+0x1>
     7c4:	80 93 30 38 	sts	0x3830, r24	; 0x803830 <tinyButton_start_time+0x2>
     7c8:	90 93 31 38 	sts	0x3831, r25	; 0x803831 <tinyButton_start_time+0x3>
		}
	}
	if (!button_is_pushed_down && button_was_pushed_down)
     7cc:	cc 23       	and	r28, r28
     7ce:	39 f0       	breq	.+14     	; 0x7de <tinyButton_update+0x9a>
     7d0:	80 91 33 38 	lds	r24, 0x3833	; 0x803833 <button_was_pushed_down>
     7d4:	88 23       	and	r24, r24
     7d6:	19 f0       	breq	.+6      	; 0x7de <tinyButton_update+0x9a>
	{
		button_press = true;
     7d8:	81 e0       	ldi	r24, 0x01	; 1
     7da:	80 93 32 38 	sts	0x3832, r24	; 0x803832 <button_press>
	}
	button_was_pushed_down = button_is_pushed_down;
     7de:	d0 93 33 38 	sts	0x3833, r29	; 0x803833 <button_was_pushed_down>
}
     7e2:	df 91       	pop	r29
     7e4:	cf 91       	pop	r28
     7e6:	1f 91       	pop	r17
     7e8:	0f 91       	pop	r16
     7ea:	08 95       	ret

000007ec <tinyButton_update_potential>:

double tinyButton_update_potential(double potential){
	if(button_press){
     7ec:	20 91 32 38 	lds	r18, 0x3832	; 0x803832 <button_press>
     7f0:	22 23       	and	r18, r18
     7f2:	31 f0       	breq	.+12     	; 0x800 <tinyButton_update_potential+0x14>
		potential += BUTTON_PRESS_REACTION;
     7f4:	20 e0       	ldi	r18, 0x00	; 0
     7f6:	30 e0       	ldi	r19, 0x00	; 0
     7f8:	40 ed       	ldi	r20, 0xD0	; 208
     7fa:	51 e4       	ldi	r21, 0x41	; 65
     7fc:	0e 94 cd 08 	call	0x119a	; 0x119a <__addsf3>
	}
	return potential;
}
     800:	08 95       	ret

00000802 <tinyCharge_is_connected_to_charger>:

_Bool connected_to_charger;

_Bool tinyCharge_is_connected_to_charger(){
	return connected_to_charger;
}
     802:	80 91 58 38 	lds	r24, 0x3858	; 0x803858 <connected_to_charger>
     806:	08 95       	ret

00000808 <tinyCharge_is_fully_charged>:
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTB_get_pin_level(const uint8_t pin)
{
	return VPORTB.IN & (1 << pin);
     808:	86 b1       	in	r24, 0x06	; 6

_Bool tinyCharge_is_fully_charged(){
	return CHARGING_STATUS_PIN_get_level();
}
     80a:	86 fb       	bst	r24, 6
     80c:	88 27       	eor	r24, r24
     80e:	80 f9       	bld	r24, 0
     810:	08 95       	ret

00000812 <tinyCharge_switch_mode>:
	}
}

void tinyCharge_switch_mode(){
	
	if(connected_to_charger){
     812:	80 91 58 38 	lds	r24, 0x3858	; 0x803858 <connected_to_charger>
     816:	88 23       	and	r24, r24
     818:	51 f0       	breq	.+20     	; 0x82e <tinyCharge_switch_mode+0x1c>
		// Switch from main to charging mode
		
		// Set LED
		tinyLED_set_color(OUT_LED, OFF);
     81a:	60 e0       	ldi	r22, 0x00	; 0
     81c:	80 e0       	ldi	r24, 0x00	; 0
     81e:	0e 94 bc 05 	call	0xb78	; 0xb78 <tinyLED_set_color>
		tinyLED_set_color_mode(INN_LED, CHARGING_COLOR, SWING);
     822:	42 e0       	ldi	r20, 0x02	; 2
     824:	61 e0       	ldi	r22, 0x01	; 1
     826:	81 e0       	ldi	r24, 0x01	; 1
     828:	0e 94 cd 05 	call	0xb9a	; 0xb9a <tinyLED_set_color_mode>
     82c:	08 95       	ret
	}
	else{
		// Switch from charge to main mode
		
		// Set LED
		tinyLED_set_color(OUT_LED, OFF);
     82e:	60 e0       	ldi	r22, 0x00	; 0
     830:	80 e0       	ldi	r24, 0x00	; 0
     832:	0e 94 bc 05 	call	0xb78	; 0xb78 <tinyLED_set_color>
		tinyLED_set_color(INN_LED, OFF);
     836:	60 e0       	ldi	r22, 0x00	; 0
     838:	81 e0       	ldi	r24, 0x01	; 1
     83a:	0e 94 bc 05 	call	0xb78	; 0xb78 <tinyLED_set_color>
     83e:	08 95       	ret

00000840 <tinyCharge_set_charging_mode>:
_Bool tinyCharge_is_fully_charged(){
	return CHARGING_STATUS_PIN_get_level();
}

void tinyCharge_set_charging_mode(_Bool charging_status){
	if(charging_status != connected_to_charger){
     840:	90 91 58 38 	lds	r25, 0x3858	; 0x803858 <connected_to_charger>
     844:	98 17       	cp	r25, r24
     846:	21 f0       	breq	.+8      	; 0x850 <tinyCharge_set_charging_mode+0x10>
		connected_to_charger = charging_status;
     848:	80 93 58 38 	sts	0x3858, r24	; 0x803858 <connected_to_charger>
		tinyCharge_switch_mode();
     84c:	0e 94 09 04 	call	0x812	; 0x812 <tinyCharge_switch_mode>
     850:	08 95       	ret

00000852 <tinyCharge_set_transistors>:
	}
}


void tinyCharge_set_transistors(){
	if(connected_to_charger){
     852:	80 91 58 38 	lds	r24, 0x3858	; 0x803858 <connected_to_charger>
     856:	88 23       	and	r24, r24
     858:	11 f0       	breq	.+4      	; 0x85e <tinyCharge_set_transistors+0xc>
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
	} else {
		VPORTC.OUT &= ~(1 << pin);
     85a:	4d 98       	cbi	0x09, 5	; 9
     85c:	08 95       	ret
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     85e:	4d 9a       	sbi	0x09, 5	; 9
     860:	08 95       	ret

00000862 <tinyDebugger_send_uint32>:
		printf("%s:%5s\t", name, number);
	}
}
void tinyDebugger_send_string(const char* name, char * value){
	if(DEBUGGING && tinyDebugger_send_message){
		printf("%s:%s\t", name, value);
     862:	20 91 0e 38 	lds	r18, 0x380E	; 0x80380e <tinyDebugger_send_message>
     866:	22 23       	and	r18, r18
     868:	89 f0       	breq	.+34     	; 0x88c <tinyDebugger_send_uint32+0x2a>
     86a:	7f 93       	push	r23
     86c:	6f 93       	push	r22
     86e:	5f 93       	push	r21
     870:	4f 93       	push	r20
     872:	9f 93       	push	r25
     874:	8f 93       	push	r24
     876:	89 ed       	ldi	r24, 0xD9	; 217
     878:	93 ea       	ldi	r25, 0xA3	; 163
     87a:	9f 93       	push	r25
     87c:	8f 93       	push	r24
     87e:	0e 94 a4 0c 	call	0x1948	; 0x1948 <printf>
     882:	8d b7       	in	r24, 0x3d	; 61
     884:	9e b7       	in	r25, 0x3e	; 62
     886:	08 96       	adiw	r24, 0x08	; 8
     888:	8d bf       	out	0x3d, r24	; 61
     88a:	9e bf       	out	0x3e, r25	; 62
     88c:	08 95       	ret

0000088e <tinyDebugger_send_uint8>:
     88e:	20 91 0e 38 	lds	r18, 0x380E	; 0x80380e <tinyDebugger_send_message>
     892:	22 23       	and	r18, r18
     894:	81 f0       	breq	.+32     	; 0x8b6 <tinyDebugger_send_uint8+0x28>
     896:	1f 92       	push	r1
     898:	6f 93       	push	r22
     89a:	9f 93       	push	r25
     89c:	8f 93       	push	r24
     89e:	82 ee       	ldi	r24, 0xE2	; 226
     8a0:	93 ea       	ldi	r25, 0xA3	; 163
     8a2:	9f 93       	push	r25
     8a4:	8f 93       	push	r24
     8a6:	0e 94 a4 0c 	call	0x1948	; 0x1948 <printf>
     8aa:	0f 90       	pop	r0
     8ac:	0f 90       	pop	r0
     8ae:	0f 90       	pop	r0
     8b0:	0f 90       	pop	r0
     8b2:	0f 90       	pop	r0
     8b4:	0f 90       	pop	r0
     8b6:	08 95       	ret

000008b8 <tinyDebugger_send_double>:
     8b8:	cf 92       	push	r12
     8ba:	df 92       	push	r13
     8bc:	ef 92       	push	r14
     8be:	ff 92       	push	r15
     8c0:	0f 93       	push	r16
     8c2:	1f 93       	push	r17
     8c4:	cf 93       	push	r28
     8c6:	df 93       	push	r29
     8c8:	cd b7       	in	r28, 0x3d	; 61
     8ca:	de b7       	in	r29, 0x3e	; 62
     8cc:	64 97       	sbiw	r28, 0x14	; 20
     8ce:	cd bf       	out	0x3d, r28	; 61
     8d0:	de bf       	out	0x3e, r29	; 62
     8d2:	38 2f       	mov	r19, r24
     8d4:	e9 2f       	mov	r30, r25
     8d6:	20 91 0e 38 	lds	r18, 0x380E	; 0x80380e <tinyDebugger_send_message>
     8da:	22 23       	and	r18, r18
     8dc:	e9 f0       	breq	.+58     	; 0x918 <tinyDebugger_send_double+0x60>
     8de:	cb 01       	movw	r24, r22
     8e0:	ba 01       	movw	r22, r20
     8e2:	ee 2e       	mov	r14, r30
     8e4:	f3 2e       	mov	r15, r19
     8e6:	9e 01       	movw	r18, r28
     8e8:	2f 5f       	subi	r18, 0xFF	; 255
     8ea:	3f 4f       	sbci	r19, 0xFF	; 255
     8ec:	69 01       	movw	r12, r18
     8ee:	89 01       	movw	r16, r18
     8f0:	21 e0       	ldi	r18, 0x01	; 1
     8f2:	41 e0       	ldi	r20, 0x01	; 1
     8f4:	0e 94 84 0c 	call	0x1908	; 0x1908 <dtostrf>
     8f8:	df 92       	push	r13
     8fa:	cf 92       	push	r12
     8fc:	ef 92       	push	r14
     8fe:	ff 92       	push	r15
     900:	8a ee       	ldi	r24, 0xEA	; 234
     902:	93 ea       	ldi	r25, 0xA3	; 163
     904:	9f 93       	push	r25
     906:	8f 93       	push	r24
     908:	0e 94 a4 0c 	call	0x1948	; 0x1948 <printf>
     90c:	0f 90       	pop	r0
     90e:	0f 90       	pop	r0
     910:	0f 90       	pop	r0
     912:	0f 90       	pop	r0
     914:	0f 90       	pop	r0
     916:	0f 90       	pop	r0
     918:	64 96       	adiw	r28, 0x14	; 20
     91a:	cd bf       	out	0x3d, r28	; 61
     91c:	de bf       	out	0x3e, r29	; 62
     91e:	df 91       	pop	r29
     920:	cf 91       	pop	r28
     922:	1f 91       	pop	r17
     924:	0f 91       	pop	r16
     926:	ff 90       	pop	r15
     928:	ef 90       	pop	r14
     92a:	df 90       	pop	r13
     92c:	cf 90       	pop	r12
     92e:	08 95       	ret

00000930 <tinyDebugger_end_line>:
	}
}
void tinyDebugger_end_line(){
	if(DEBUGGING && tinyDebugger_send_message){
     930:	80 91 0e 38 	lds	r24, 0x380E	; 0x80380e <tinyDebugger_send_message>
     934:	88 23       	and	r24, r24
     936:	21 f0       	breq	.+8      	; 0x940 <tinyDebugger_end_line+0x10>
		printf("\r\n");
     938:	89 ef       	ldi	r24, 0xF9	; 249
     93a:	93 ea       	ldi	r25, 0xA3	; 163
     93c:	0e 94 ba 0c 	call	0x1974	; 0x1974 <puts>
	}
	tinyDebugger_print_attempts++;
     940:	80 91 34 38 	lds	r24, 0x3834	; 0x803834 <tinyDebugger_print_attempts>
     944:	8f 5f       	subi	r24, 0xFF	; 255
     946:	80 93 34 38 	sts	0x3834, r24	; 0x803834 <tinyDebugger_print_attempts>
	tinyDebugger_send_message = tinyDebugger_print_attempts%DEBUG_EVERY == 0;
     94a:	81 e0       	ldi	r24, 0x01	; 1
     94c:	80 93 0e 38 	sts	0x380E, r24	; 0x80380e <tinyDebugger_send_message>
     950:	08 95       	ret

00000952 <tinyDendrite_update_signals>:
/*
This function converts the 8 bit value from the ADC into one of the signal types defined in DendriteSignal
We also update the charging state
*/
void tinyDendrite_update_signals(void)
{
     952:	af 92       	push	r10
     954:	bf 92       	push	r11
     956:	cf 92       	push	r12
     958:	df 92       	push	r13
     95a:	ef 92       	push	r14
     95c:	ff 92       	push	r15
     95e:	0f 93       	push	r16
     960:	1f 93       	push	r17
     962:	cf 93       	push	r28
     964:	df 93       	push	r29
     966:	cf e0       	ldi	r28, 0x0F	; 15
     968:	d8 e3       	ldi	r29, 0x38	; 56
     96a:	0f e3       	ldi	r16, 0x3F	; 63
     96c:	18 e3       	ldi	r17, 0x38	; 56
     96e:	0f 2e       	mov	r0, r31
     970:	f4 e1       	ldi	r31, 0x14	; 20
     972:	cf 2e       	mov	r12, r31
     974:	f8 e3       	ldi	r31, 0x38	; 56
     976:	df 2e       	mov	r13, r31
     978:	f0 2d       	mov	r31, r0
     97a:	78 01       	movw	r14, r16
*/
static void tinyDendrite_read_signals(void)
{
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_values[i] = ADC_0_get_conversion(Dendrite_ports[i]);
     97c:	89 91       	ld	r24, Y+
     97e:	0e 94 45 01 	call	0x28a	; 0x28a <ADC_0_get_conversion>
     982:	d7 01       	movw	r26, r14
     984:	8d 93       	st	X+, r24
     986:	7d 01       	movw	r14, r26
/*
This function reads the voltage at the Dendrite inputs with the ADC
*/
static void tinyDendrite_read_signals(void)
{
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
     988:	cc 15       	cp	r28, r12
     98a:	dd 05       	cpc	r29, r13
     98c:	b9 f7       	brne	.-18     	; 0x97c <tinyDendrite_update_signals+0x2a>
	{
		tinyDendrite_values[i] = ADC_0_get_conversion(Dendrite_ports[i]);
	}
	tinyDebugger_send_uint8("D1", tinyDendrite_values[0]);
     98e:	cf e3       	ldi	r28, 0x3F	; 63
     990:	d8 e3       	ldi	r29, 0x38	; 56
     992:	68 81       	ld	r22, Y
     994:	8b ef       	ldi	r24, 0xFB	; 251
     996:	93 ea       	ldi	r25, 0xA3	; 163
     998:	0e 94 47 04 	call	0x88e	; 0x88e <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D2", tinyDendrite_values[1]);
     99c:	69 81       	ldd	r22, Y+1	; 0x01
     99e:	8e ef       	ldi	r24, 0xFE	; 254
     9a0:	93 ea       	ldi	r25, 0xA3	; 163
     9a2:	0e 94 47 04 	call	0x88e	; 0x88e <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D3", tinyDendrite_values[2]);
     9a6:	6a 81       	ldd	r22, Y+2	; 0x02
     9a8:	81 e0       	ldi	r24, 0x01	; 1
     9aa:	94 ea       	ldi	r25, 0xA4	; 164
     9ac:	0e 94 47 04 	call	0x88e	; 0x88e <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D4", tinyDendrite_values[3]);
     9b0:	6b 81       	ldd	r22, Y+3	; 0x03
     9b2:	84 e0       	ldi	r24, 0x04	; 4
     9b4:	94 ea       	ldi	r25, 0xA4	; 164
     9b6:	0e 94 47 04 	call	0x88e	; 0x88e <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D5", tinyDendrite_values[4]);
     9ba:	6c 81       	ldd	r22, Y+4	; 0x04
     9bc:	87 e0       	ldi	r24, 0x07	; 7
     9be:	94 ea       	ldi	r25, 0xA4	; 164
     9c0:	0e 94 47 04 	call	0x88e	; 0x88e <tinyDebugger_send_uint8>
     9c4:	ea e3       	ldi	r30, 0x3A	; 58
     9c6:	f8 e3       	ldi	r31, 0x38	; 56
     9c8:	c5 e3       	ldi	r28, 0x35	; 53
     9ca:	d8 e3       	ldi	r29, 0x38	; 56
     9cc:	4f e3       	ldi	r20, 0x3F	; 63
     9ce:	58 e3       	ldi	r21, 0x38	; 56
{
	
	//Read the analog voltage values on each of the Dendrites
	tinyDendrite_read_signals();
	
	_Bool charging = false;
     9d0:	80 e0       	ldi	r24, 0x00	; 0
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     9d2:	31 e0       	ldi	r19, 0x01	; 1
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
		}
		else if (tinyDendrite_values[i] > HIGH_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
     9d4:	0f 2e       	mov	r0, r31
     9d6:	f3 e0       	ldi	r31, 0x03	; 3
     9d8:	cf 2e       	mov	r12, r31
     9da:	f0 2d       	mov	r31, r0
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     9dc:	68 94       	set
     9de:	dd 24       	eor	r13, r13
     9e0:	d1 f8       	bld	r13, 1
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     9e2:	68 94       	set
     9e4:	ee 24       	eor	r14, r14
     9e6:	e2 f8       	bld	r14, 2
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     9e8:	0f 2e       	mov	r0, r31
     9ea:	f6 e0       	ldi	r31, 0x06	; 6
     9ec:	ff 2e       	mov	r15, r31
     9ee:	f0 2d       	mov	r31, r0
			tinyDendrite_current_signals[i] = CHARGING;
			charging = true;
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     9f0:	75 e0       	ldi	r23, 0x05	; 5
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = CHARGING;
     9f2:	67 e0       	ldi	r22, 0x07	; 7
     9f4:	5f 01       	movw	r10, r30
	
	_Bool charging = false;
	
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
     9f6:	90 81       	ld	r25, Z
     9f8:	99 93       	st	Y+, r25
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
     9fa:	d8 01       	movw	r26, r16
     9fc:	2d 91       	ld	r18, X+
     9fe:	8d 01       	movw	r16, r26
     a00:	29 3e       	cpi	r18, 0xE9	; 233
     a02:	18 f0       	brcs	.+6      	; 0xa0a <tinyDendrite_update_signals+0xb8>
		{
			tinyDendrite_current_signals[i] = CHARGING;
     a04:	60 83       	st	Z, r22
			charging = true;
     a06:	83 2f       	mov	r24, r19
     a08:	19 c0       	rjmp	.+50     	; 0xa3c <tinyDendrite_update_signals+0xea>
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
     a0a:	28 3c       	cpi	r18, 0xC8	; 200
     a0c:	10 f0       	brcs	.+4      	; 0xa12 <tinyDendrite_update_signals+0xc0>
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     a0e:	70 83       	st	Z, r23
     a10:	15 c0       	rjmp	.+42     	; 0xa3c <tinyDendrite_update_signals+0xea>
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
     a12:	27 3a       	cpi	r18, 0xA7	; 167
     a14:	10 f0       	brcs	.+4      	; 0xa1a <tinyDendrite_update_signals+0xc8>
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     a16:	f0 82       	st	Z, r15
     a18:	11 c0       	rjmp	.+34     	; 0xa3c <tinyDendrite_update_signals+0xea>
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
     a1a:	25 38       	cpi	r18, 0x85	; 133
     a1c:	10 f0       	brcs	.+4      	; 0xa22 <tinyDendrite_update_signals+0xd0>
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     a1e:	e0 82       	st	Z, r14
     a20:	0d c0       	rjmp	.+26     	; 0xa3c <tinyDendrite_update_signals+0xea>
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
     a22:	24 36       	cpi	r18, 0x64	; 100
     a24:	10 f0       	brcs	.+4      	; 0xa2a <tinyDendrite_update_signals+0xd8>
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     a26:	d0 82       	st	Z, r13
     a28:	09 c0       	rjmp	.+18     	; 0xa3c <tinyDendrite_update_signals+0xea>
		}
		else if (tinyDendrite_values[i] > HIGH_INHIB_THRESHOLD)
     a2a:	23 34       	cpi	r18, 0x43	; 67
     a2c:	10 f0       	brcs	.+4      	; 0xa32 <tinyDendrite_update_signals+0xe0>
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
     a2e:	c0 82       	st	Z, r12
     a30:	05 c0       	rjmp	.+10     	; 0xa3c <tinyDendrite_update_signals+0xea>
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
     a32:	22 32       	cpi	r18, 0x22	; 34
     a34:	10 f0       	brcs	.+4      	; 0xa3a <tinyDendrite_update_signals+0xe8>
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     a36:	30 83       	st	Z, r19
     a38:	01 c0       	rjmp	.+2      	; 0xa3c <tinyDendrite_update_signals+0xea>
		}
		else
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     a3a:	10 82       	st	Z, r1
		}
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
     a3c:	d5 01       	movw	r26, r10
     a3e:	2c 91       	ld	r18, X
     a40:	92 13       	cpse	r25, r18
     a42:	01 c0       	rjmp	.+2      	; 0xa46 <tinyDendrite_update_signals+0xf4>
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     a44:	1c 92       	st	X, r1
     a46:	31 96       	adiw	r30, 0x01	; 1
	//Read the analog voltage values on each of the Dendrites
	tinyDendrite_read_signals();
	
	_Bool charging = false;
	
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
     a48:	e4 17       	cp	r30, r20
     a4a:	f5 07       	cpc	r31, r21
     a4c:	99 f6       	brne	.-90     	; 0x9f4 <tinyDendrite_update_signals+0xa2>
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
		}
	}
	tinyCharge_set_charging_mode(charging);
     a4e:	0e 94 20 04 	call	0x840	; 0x840 <tinyCharge_set_charging_mode>
}
     a52:	df 91       	pop	r29
     a54:	cf 91       	pop	r28
     a56:	1f 91       	pop	r17
     a58:	0f 91       	pop	r16
     a5a:	ff 90       	pop	r15
     a5c:	ef 90       	pop	r14
     a5e:	df 90       	pop	r13
     a60:	cf 90       	pop	r12
     a62:	bf 90       	pop	r11
     a64:	af 90       	pop	r10
     a66:	08 95       	ret

00000a68 <tinyDendrite_get_potential>:
outside. It uses the previously declared functions to return the potential.
*/
int16_t tinyDendrite_get_potential()
{
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
     a68:	0e 94 a9 04 	call	0x952	; 0x952 <tinyDendrite_update_signals>
     a6c:	ea e3       	ldi	r30, 0x3A	; 58
     a6e:	f8 e3       	ldi	r31, 0x38	; 56
     a70:	4f e3       	ldi	r20, 0x3F	; 63
     a72:	58 e3       	ldi	r21, 0x38	; 56
	
	int16_t return_potential_val = 0;
     a74:	20 e0       	ldi	r18, 0x00	; 0
     a76:	30 e0       	ldi	r19, 0x00	; 0
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		switch(tinyDendrite_current_signals[i])
     a78:	91 91       	ld	r25, Z+
     a7a:	93 30       	cpi	r25, 0x03	; 3
     a7c:	a1 f0       	breq	.+40     	; 0xaa6 <tinyDendrite_get_potential+0x3e>
     a7e:	28 f4       	brcc	.+10     	; 0xa8a <tinyDendrite_get_potential+0x22>
     a80:	91 30       	cpi	r25, 0x01	; 1
     a82:	b9 f0       	breq	.+46     	; 0xab2 <tinyDendrite_get_potential+0x4a>
     a84:	92 30       	cpi	r25, 0x02	; 2
     a86:	91 f0       	breq	.+36     	; 0xaac <tinyDendrite_get_potential+0x44>
     a88:	16 c0       	rjmp	.+44     	; 0xab6 <tinyDendrite_get_potential+0x4e>
     a8a:	95 30       	cpi	r25, 0x05	; 5
     a8c:	31 f0       	breq	.+12     	; 0xa9a <tinyDendrite_get_potential+0x32>
     a8e:	40 f0       	brcs	.+16     	; 0xaa0 <tinyDendrite_get_potential+0x38>
     a90:	96 30       	cpi	r25, 0x06	; 6
     a92:	89 f4       	brne	.+34     	; 0xab6 <tinyDendrite_get_potential+0x4e>
		{
			case NO_SIGNAL:
				return_potential_val += NO_SIGNAL_REACTION;
				break;
			case HIGH_EXCITE:
				return_potential_val += HIGH_EXCITE_REACTION;
     a94:	2c 5c       	subi	r18, 0xCC	; 204
     a96:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     a98:	0e c0       	rjmp	.+28     	; 0xab6 <tinyDendrite_get_potential+0x4e>
			case NORMAL_EXCITE:
				return_potential_val += NORMAL_EXCITE_REACTION;
     a9a:	26 5e       	subi	r18, 0xE6	; 230
     a9c:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     a9e:	0b c0       	rjmp	.+22     	; 0xab6 <tinyDendrite_get_potential+0x4e>
			case LOW_EXCITE:
				return_potential_val += LOW_EXCITE_REACTION;
     aa0:	2c 5e       	subi	r18, 0xEC	; 236
     aa2:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     aa4:	08 c0       	rjmp	.+16     	; 0xab6 <tinyDendrite_get_potential+0x4e>
			case HIGH_INHIB:
				return_potential_val += HIGH_INHIB_REACTION;
     aa6:	22 53       	subi	r18, 0x32	; 50
     aa8:	31 09       	sbc	r19, r1
				break;
     aaa:	05 c0       	rjmp	.+10     	; 0xab6 <tinyDendrite_get_potential+0x4e>
			case NORMAL_INHIB:
				return_potential_val += NORMAL_INHIB_REACTION;
     aac:	2a 51       	subi	r18, 0x1A	; 26
     aae:	31 09       	sbc	r19, r1
				break;
     ab0:	02 c0       	rjmp	.+4      	; 0xab6 <tinyDendrite_get_potential+0x4e>
			case LOW_INHIB:
				return_potential_val += LOW_INHIB_REACTION;
     ab2:	24 51       	subi	r18, 0x14	; 20
     ab4:	31 09       	sbc	r19, r1
{
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
	
	int16_t return_potential_val = 0;
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
     ab6:	e4 17       	cp	r30, r20
     ab8:	f5 07       	cpc	r31, r21
     aba:	f1 f6       	brne	.-68     	; 0xa78 <tinyDendrite_get_potential+0x10>
			default:
				break;
		}
	}
	return return_potential_val;
}
     abc:	c9 01       	movw	r24, r18
     abe:	08 95       	ret

00000ac0 <tinyDendrite_update_potential>:

double tinyDendrite_update_potential(double potential){
     ac0:	cf 92       	push	r12
     ac2:	df 92       	push	r13
     ac4:	ef 92       	push	r14
     ac6:	ff 92       	push	r15
     ac8:	6b 01       	movw	r12, r22
     aca:	7c 01       	movw	r14, r24
	
	int16_t potential_change = tinyDendrite_get_potential();
     acc:	0e 94 34 05 	call	0xa68	; 0xa68 <tinyDendrite_get_potential>
	potential += potential_change;
	return potential;
     ad0:	bc 01       	movw	r22, r24
     ad2:	99 0f       	add	r25, r25
     ad4:	88 0b       	sbc	r24, r24
     ad6:	99 0b       	sbc	r25, r25
     ad8:	0e 94 1b 0a 	call	0x1436	; 0x1436 <__floatsisf>
     adc:	a7 01       	movw	r20, r14
     ade:	96 01       	movw	r18, r12
     ae0:	0e 94 cd 08 	call	0x119a	; 0x119a <__addsf3>
     ae4:	ff 90       	pop	r15
     ae6:	ef 90       	pop	r14
     ae8:	df 90       	pop	r13
     aea:	cf 90       	pop	r12
     aec:	08 95       	ret

00000aee <__vector_6>:
This function is called every time the RTC (Real Time Clock) counter overflows.
With the current settings, it will be called every ms.
The RTC clock runs at 1kHz, and the number of cycles before overflow is set with RTC.PER = someHexValue (e.g. 0x20) in src/rtc.c
*/
ISR(RTC_CNT_vect)
{
     aee:	1f 92       	push	r1
     af0:	0f 92       	push	r0
     af2:	0f b6       	in	r0, 0x3f	; 63
     af4:	0f 92       	push	r0
     af6:	11 24       	eor	r1, r1
     af8:	2f 93       	push	r18
     afa:	3f 93       	push	r19
     afc:	4f 93       	push	r20
     afe:	5f 93       	push	r21
     b00:	6f 93       	push	r22
     b02:	7f 93       	push	r23
     b04:	8f 93       	push	r24
     b06:	9f 93       	push	r25
     b08:	af 93       	push	r26
     b0a:	bf 93       	push	r27
     b0c:	cf 93       	push	r28
     b0e:	ef 93       	push	r30
     b10:	ff 93       	push	r31
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     b12:	c1 e0       	ldi	r28, 0x01	; 1
     b14:	c0 93 44 38 	sts	0x3844, r28	; 0x803844 <tinyISR_interrupt_flag>
{
	// Set flag to let main loop run a new cycle
	tinyISR_setflag(true);
	
	// Timer counter incrementation
	tinyTime_counter_increment();
     b18:	0e 94 af 08 	call	0x115e	; 0x115e <tinyTime_counter_increment>

	/* Overflow interrupt flag has to be cleared manually */
	RTC.INTFLAGS = RTC_OVF_bm;
     b1c:	c0 93 43 01 	sts	0x0143, r28	; 0x800143 <__TEXT_REGION_LENGTH__+0x700143>
}
     b20:	ff 91       	pop	r31
     b22:	ef 91       	pop	r30
     b24:	cf 91       	pop	r28
     b26:	bf 91       	pop	r27
     b28:	af 91       	pop	r26
     b2a:	9f 91       	pop	r25
     b2c:	8f 91       	pop	r24
     b2e:	7f 91       	pop	r23
     b30:	6f 91       	pop	r22
     b32:	5f 91       	pop	r21
     b34:	4f 91       	pop	r20
     b36:	3f 91       	pop	r19
     b38:	2f 91       	pop	r18
     b3a:	0f 90       	pop	r0
     b3c:	0f be       	out	0x3f, r0	; 63
     b3e:	0f 90       	pop	r0
     b40:	1f 90       	pop	r1
     b42:	18 95       	reti

00000b44 <tinyISR_setflag>:
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     b44:	80 93 44 38 	sts	0x3844, r24	; 0x803844 <tinyISR_interrupt_flag>
     b48:	08 95       	ret

00000b4a <tinyISR_getflag>:
}

_Bool tinyISR_getflag(void)
{
	return tinyISR_interrupt_flag;
}
     b4a:	80 91 44 38 	lds	r24, 0x3844	; 0x803844 <tinyISR_interrupt_flag>
     b4e:	08 95       	ret

00000b50 <tinyLED_SPIWriteByte>:
Function used to send a byte over SPI, which in turn gets
translated to the bit-sequence required by the LEDs over the CCL.
*/
static void tinyLED_SPIWriteByte(uint8_t byte)
{
	SPI0.INTFLAGS = SPI0_INTFLAGS; // clear the write collision flag to allow writing
     b50:	90 91 23 08 	lds	r25, 0x0823	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
     b54:	90 93 23 08 	sts	0x0823, r25	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
	TCA0.SINGLE.CNT = 0; // reset TCA counter register to ensure the first rising edge of the PWM is predictable
     b58:	e0 e0       	ldi	r30, 0x00	; 0
     b5a:	fa e0       	ldi	r31, 0x0A	; 10
     b5c:	10 a2       	std	Z+32, r1	; 0x20
     b5e:	11 a2       	std	Z+33, r1	; 0x21
	
	// start TCA
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 1 << TCA_SPLIT_ENABLE_bp;
     b60:	91 e0       	ldi	r25, 0x01	; 1
     b62:	90 83       	st	Z, r25
	SPI0_DATA = byte;
     b64:	80 93 24 08 	sts	0x0824, r24	; 0x800824 <__TEXT_REGION_LENGTH__+0x700824>

	while((SPI0.INTFLAGS & SPI_RXCIE_bm) == 0){} // wait for transfer to complete
     b68:	e0 e2       	ldi	r30, 0x20	; 32
     b6a:	f8 e0       	ldi	r31, 0x08	; 8
     b6c:	83 81       	ldd	r24, Z+3	; 0x03
     b6e:	88 23       	and	r24, r24
     b70:	ec f7       	brge	.-6      	; 0xb6c <tinyLED_SPIWriteByte+0x1c>
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 0 << TCA_SPLIT_ENABLE_bp; //Stop TCA
     b72:	10 92 00 0a 	sts	0x0A00, r1	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
     b76:	08 95       	ret

00000b78 <tinyLED_set_color>:
changes the values in the variables stored in the LED-array.
*/
void tinyLED_set_color_mode(uint8_t LED_id, enum Colors color, enum ColorModes mode)
{
	struct ColorSetting setting = {.color=color, .mode=mode};
	tinyLED_colors[LED_id] = setting;
     b78:	e8 2f       	mov	r30, r24
     b7a:	f0 e0       	ldi	r31, 0x00	; 0
     b7c:	ee 0f       	add	r30, r30
     b7e:	ff 1f       	adc	r31, r31
     b80:	ef 59       	subi	r30, 0x9F	; 159
     b82:	f7 4c       	sbci	r31, 0xC7	; 199
     b84:	60 83       	st	Z, r22
     b86:	11 82       	std	Z+1, r1	; 0x01
     b88:	08 95       	ret

00000b8a <tinyLED_get_color>:
	tinyLED_set_color_mode(LED_id, color, STABLE);
}

enum Colors tinyLED_get_color(uint8_t LED_id)
{
	return tinyLED_colors[LED_id].color;
     b8a:	e8 2f       	mov	r30, r24
     b8c:	f0 e0       	ldi	r31, 0x00	; 0
     b8e:	ee 0f       	add	r30, r30
     b90:	ff 1f       	adc	r31, r31
     b92:	ef 59       	subi	r30, 0x9F	; 159
     b94:	f7 4c       	sbci	r31, 0xC7	; 199
}
     b96:	80 81       	ld	r24, Z
     b98:	08 95       	ret

00000b9a <tinyLED_set_color_mode>:
changes the values in the variables stored in the LED-array.
*/
void tinyLED_set_color_mode(uint8_t LED_id, enum Colors color, enum ColorModes mode)
{
	struct ColorSetting setting = {.color=color, .mode=mode};
	tinyLED_colors[LED_id] = setting;
     b9a:	90 e0       	ldi	r25, 0x00	; 0
     b9c:	fc 01       	movw	r30, r24
     b9e:	ee 0f       	add	r30, r30
     ba0:	ff 1f       	adc	r31, r31
     ba2:	ef 59       	subi	r30, 0x9F	; 159
     ba4:	f7 4c       	sbci	r31, 0xC7	; 199
     ba6:	60 83       	st	Z, r22
     ba8:	41 83       	std	Z+1, r20	; 0x01
	if (mode == FLASH_ONCE)
     baa:	44 30       	cpi	r20, 0x04	; 4
     bac:	29 f4       	brne	.+10     	; 0xbb8 <tinyLED_set_color_mode+0x1e>
	{
		tinyLED_flash_once_time[LED_id] = 1000*FLASH_TIME;
     bae:	fc 01       	movw	r30, r24
     bb0:	e7 5a       	subi	r30, 0xA7	; 167
     bb2:	f7 4c       	sbci	r31, 0xC7	; 199
     bb4:	2a e0       	ldi	r18, 0x0A	; 10
     bb6:	20 83       	st	Z, r18
     bb8:	08 95       	ret

00000bba <tinyLED_RGB_Color_Compare>:
	}
	return rgb_color;
			
};

_Bool tinyLED_RGB_Color_Compare(struct RGB_Color* a, struct RGB_Color* b){
     bba:	dc 01       	movw	r26, r24
     bbc:	fb 01       	movw	r30, r22
	for (int i=0; i<NUMBER_OF_LEDS; i++)
	{
		if(!(a[i].red==b[i].red && a[i].green==b[i].green && a[i].blue==b[i].blue)){
     bbe:	9c 91       	ld	r25, X
     bc0:	80 81       	ld	r24, Z
     bc2:	98 13       	cpse	r25, r24
     bc4:	20 c0       	rjmp	.+64     	; 0xc06 <tinyLED_RGB_Color_Compare+0x4c>
     bc6:	11 96       	adiw	r26, 0x01	; 1
     bc8:	9c 91       	ld	r25, X
     bca:	11 97       	sbiw	r26, 0x01	; 1
     bcc:	81 81       	ldd	r24, Z+1	; 0x01
     bce:	98 13       	cpse	r25, r24
     bd0:	1c c0       	rjmp	.+56     	; 0xc0a <tinyLED_RGB_Color_Compare+0x50>
     bd2:	12 96       	adiw	r26, 0x02	; 2
     bd4:	9c 91       	ld	r25, X
     bd6:	12 97       	sbiw	r26, 0x02	; 2
     bd8:	82 81       	ldd	r24, Z+2	; 0x02
     bda:	98 13       	cpse	r25, r24
     bdc:	18 c0       	rjmp	.+48     	; 0xc0e <tinyLED_RGB_Color_Compare+0x54>
     bde:	13 96       	adiw	r26, 0x03	; 3
     be0:	9c 91       	ld	r25, X
     be2:	13 97       	sbiw	r26, 0x03	; 3
     be4:	83 81       	ldd	r24, Z+3	; 0x03
     be6:	98 13       	cpse	r25, r24
     be8:	14 c0       	rjmp	.+40     	; 0xc12 <tinyLED_RGB_Color_Compare+0x58>
     bea:	14 96       	adiw	r26, 0x04	; 4
     bec:	9c 91       	ld	r25, X
     bee:	14 97       	sbiw	r26, 0x04	; 4
     bf0:	84 81       	ldd	r24, Z+4	; 0x04
     bf2:	98 13       	cpse	r25, r24
     bf4:	10 c0       	rjmp	.+32     	; 0xc16 <tinyLED_RGB_Color_Compare+0x5c>
     bf6:	81 e0       	ldi	r24, 0x01	; 1
     bf8:	15 96       	adiw	r26, 0x05	; 5
     bfa:	2c 91       	ld	r18, X
     bfc:	95 81       	ldd	r25, Z+5	; 0x05
     bfe:	29 17       	cp	r18, r25
     c00:	59 f0       	breq	.+22     	; 0xc18 <tinyLED_RGB_Color_Compare+0x5e>
     c02:	80 e0       	ldi	r24, 0x00	; 0
     c04:	08 95       	ret
			return false;
     c06:	80 e0       	ldi	r24, 0x00	; 0
     c08:	08 95       	ret
     c0a:	80 e0       	ldi	r24, 0x00	; 0
     c0c:	08 95       	ret
     c0e:	80 e0       	ldi	r24, 0x00	; 0
     c10:	08 95       	ret
     c12:	80 e0       	ldi	r24, 0x00	; 0
     c14:	08 95       	ret
     c16:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	return true;
}
     c18:	08 95       	ret

00000c1a <tinyLED_update>:
/*
function to write the current LED-array on to the LEDs and
effectively update the values stored in the LEDs to the values stored in the MCU.
*/
void tinyLED_update(void)
{
     c1a:	2f 92       	push	r2
     c1c:	3f 92       	push	r3
     c1e:	4f 92       	push	r4
     c20:	5f 92       	push	r5
     c22:	6f 92       	push	r6
     c24:	7f 92       	push	r7
     c26:	8f 92       	push	r8
     c28:	9f 92       	push	r9
     c2a:	af 92       	push	r10
     c2c:	bf 92       	push	r11
     c2e:	cf 92       	push	r12
     c30:	df 92       	push	r13
     c32:	ef 92       	push	r14
     c34:	ff 92       	push	r15
     c36:	0f 93       	push	r16
     c38:	1f 93       	push	r17
     c3a:	cf 93       	push	r28
     c3c:	df 93       	push	r29
     c3e:	cd b7       	in	r28, 0x3d	; 61
     c40:	de b7       	in	r29, 0x3e	; 62
     c42:	6e 97       	sbiw	r28, 0x1e	; 30
     c44:	cd bf       	out	0x3d, r28	; 61
     c46:	de bf       	out	0x3e, r29	; 62
			
	uint32_t now = tinyTime_now();
     c48:	0e 94 c3 08 	call	0x1186	; 0x1186 <tinyTime_now>
     c4c:	6b 01       	movw	r12, r22
     c4e:	7c 01       	movw	r14, r24
	double sinValue = 1+sin((double)now/(100*M_PI/SWING_RATE));
     c50:	0e 94 19 0a 	call	0x1432	; 0x1432 <__floatunsisf>
     c54:	22 ed       	ldi	r18, 0xD2	; 210
     c56:	33 e5       	ldi	r19, 0x53	; 83
     c58:	4b ef       	ldi	r20, 0xFB	; 251
     c5a:	51 e4       	ldi	r21, 0x41	; 65
     c5c:	0e 94 3e 09 	call	0x127c	; 0x127c <__divsf3>
     c60:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <sin>
     c64:	20 e0       	ldi	r18, 0x00	; 0
     c66:	30 e0       	ldi	r19, 0x00	; 0
     c68:	40 e8       	ldi	r20, 0x80	; 128
     c6a:	5f e3       	ldi	r21, 0x3F	; 63
     c6c:	0e 94 cd 08 	call	0x119a	; 0x119a <__addsf3>
     c70:	69 87       	std	Y+9, r22	; 0x09
     c72:	7a 87       	std	Y+10, r23	; 0x0a
     c74:	8b 87       	std	Y+11, r24	; 0x0b
     c76:	9c 87       	std	Y+12, r25	; 0x0c
	_Bool flash_on = now%(uint32_t)(1000/FLASH_RATE)   <   500/FLASH_RATE;
     c78:	c7 01       	movw	r24, r14
     c7a:	b6 01       	movw	r22, r12
     c7c:	22 e3       	ldi	r18, 0x32	; 50
     c7e:	30 e0       	ldi	r19, 0x00	; 0
     c80:	40 e0       	ldi	r20, 0x00	; 0
     c82:	50 e0       	ldi	r21, 0x00	; 0
     c84:	0e 94 62 0c 	call	0x18c4	; 0x18c4 <__udivmodsi4>
     c88:	0e 94 19 0a 	call	0x1432	; 0x1432 <__floatunsisf>
     c8c:	20 e0       	ldi	r18, 0x00	; 0
     c8e:	30 e0       	ldi	r19, 0x00	; 0
     c90:	48 ec       	ldi	r20, 0xC8	; 200
     c92:	51 e4       	ldi	r21, 0x41	; 65
     c94:	0e 94 39 09 	call	0x1272	; 0x1272 <__cmpsf2>
     c98:	88 1f       	adc	r24, r24
     c9a:	88 27       	eor	r24, r24
     c9c:	88 1f       	adc	r24, r24
     c9e:	8f 83       	std	Y+7, r24	; 0x07
	_Bool ping_on = now%(uint32_t)(1000/PING_RATE)   <   1000*FLASH_TIME;
     ca0:	c7 01       	movw	r24, r14
     ca2:	b6 01       	movw	r22, r12
     ca4:	24 ef       	ldi	r18, 0xF4	; 244
     ca6:	31 e0       	ldi	r19, 0x01	; 1
     ca8:	40 e0       	ldi	r20, 0x00	; 0
     caa:	50 e0       	ldi	r21, 0x00	; 0
     cac:	0e 94 62 0c 	call	0x18c4	; 0x18c4 <__udivmodsi4>
     cb0:	0e 94 19 0a 	call	0x1432	; 0x1432 <__floatunsisf>
     cb4:	20 e0       	ldi	r18, 0x00	; 0
     cb6:	30 e0       	ldi	r19, 0x00	; 0
     cb8:	40 e2       	ldi	r20, 0x20	; 32
     cba:	51 e4       	ldi	r21, 0x41	; 65
     cbc:	0e 94 39 09 	call	0x1272	; 0x1272 <__cmpsf2>
     cc0:	88 1f       	adc	r24, r24
     cc2:	88 27       	eor	r24, r24
     cc4:	88 1f       	adc	r24, r24
     cc6:	01 e6       	ldi	r16, 0x61	; 97
     cc8:	18 e3       	ldi	r17, 0x38	; 56
     cca:	9e 01       	movw	r18, r28
     ccc:	2f 5f       	subi	r18, 0xFF	; 255
     cce:	3f 4f       	sbci	r19, 0xFF	; 255
     cd0:	0f 2e       	mov	r0, r31
     cd2:	f9 e5       	ldi	r31, 0x59	; 89
     cd4:	4f 2e       	mov	r4, r31
     cd6:	f8 e3       	ldi	r31, 0x38	; 56
     cd8:	5f 2e       	mov	r5, r31
     cda:	f0 2d       	mov	r31, r0
     cdc:	0f 2e       	mov	r0, r31
     cde:	f5 e6       	ldi	r31, 0x65	; 101
     ce0:	6f 2e       	mov	r6, r31
     ce2:	f8 e3       	ldi	r31, 0x38	; 56
     ce4:	7f 2e       	mov	r7, r31
     ce6:	f0 2d       	mov	r31, r0
     ce8:	19 01       	movw	r2, r18
			case SWING:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*sinValue, rgb_colors[i].green*sinValue, rgb_colors[i].blue*sinValue};
				break;
			case PING:
				// in the line below, fmin will either return 1 or 0, so each rgb color is either 0 or 255*PING_BRIGHTNESS
				rgb_colors[i] = (struct RGB_Color){255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].red)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].green)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].blue)*ping_on};
     cea:	88 2e       	mov	r8, r24
     cec:	91 2c       	mov	r9, r1
     cee:	a1 2c       	mov	r10, r1
     cf0:	b1 2c       	mov	r11, r1
     cf2:	2d 87       	std	Y+13, r18	; 0x0d
     cf4:	3e 87       	std	Y+14, r19	; 0x0e
     cf6:	df 80       	ldd	r13, Y+7	; 0x07
     cf8:	f8 01       	movw	r30, r16
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 0 << TCA_SPLIT_ENABLE_bp; //Stop TCA
}

static struct RGB_Color tinyLED_enum_to_RGB_Color(enum Colors color){
	struct RGB_Color rgb_color;
	switch(color)
     cfa:	80 81       	ld	r24, Z
     cfc:	82 30       	cpi	r24, 0x02	; 2
     cfe:	a1 f0       	breq	.+40     	; 0xd28 <tinyLED_update+0x10e>
     d00:	18 f4       	brcc	.+6      	; 0xd08 <tinyLED_update+0xee>
     d02:	81 30       	cpi	r24, 0x01	; 1
     d04:	31 f0       	breq	.+12     	; 0xd12 <tinyLED_update+0xf8>
     d06:	21 c0       	rjmp	.+66     	; 0xd4a <tinyLED_update+0x130>
     d08:	83 30       	cpi	r24, 0x03	; 3
     d0a:	39 f0       	breq	.+14     	; 0xd1a <tinyLED_update+0x100>
     d0c:	84 30       	cpi	r24, 0x04	; 4
     d0e:	99 f0       	breq	.+38     	; 0xd36 <tinyLED_update+0x11c>
     d10:	1c c0       	rjmp	.+56     	; 0xd4a <tinyLED_update+0x130>
	{
		case OFF:
			rgb_color = (struct RGB_Color){0, 0, 0};
			break;
		case RED:
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 0, 0};
     d12:	f1 2c       	mov	r15, r1
     d14:	e1 2c       	mov	r14, r1
     d16:	69 e1       	ldi	r22, 0x19	; 25
     d18:	1b c0       	rjmp	.+54     	; 0xd50 <tinyLED_update+0x136>
			break;
		case GREEN:
			rgb_color = (struct RGB_Color){0, 255*LED_BRIGHTNESS, 0};
     d1a:	f1 2c       	mov	r15, r1
     d1c:	0f 2e       	mov	r0, r31
     d1e:	f9 e1       	ldi	r31, 0x19	; 25
     d20:	ef 2e       	mov	r14, r31
     d22:	f0 2d       	mov	r31, r0
     d24:	60 e0       	ldi	r22, 0x00	; 0
     d26:	14 c0       	rjmp	.+40     	; 0xd50 <tinyLED_update+0x136>
			break;
		case BLUE:
			rgb_color = (struct RGB_Color){0, 0, 255*LED_BRIGHTNESS};
     d28:	0f 2e       	mov	r0, r31
     d2a:	f9 e1       	ldi	r31, 0x19	; 25
     d2c:	ff 2e       	mov	r15, r31
     d2e:	f0 2d       	mov	r31, r0
     d30:	e1 2c       	mov	r14, r1
     d32:	60 e0       	ldi	r22, 0x00	; 0
     d34:	0d c0       	rjmp	.+26     	; 0xd50 <tinyLED_update+0x136>
			// Should the /3 be there? This requires testing.
			// After testing, findings were that at 0.1 brightness, one would see the three LEDs instead of one white led
			// We try with /2 instead.
			// We find that the best results come from not dividing by anything. At leasts in the lower brightness settings, and that
			// is where we suspect it will be most of the time.
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS};
     d36:	0f 2e       	mov	r0, r31
     d38:	f9 e1       	ldi	r31, 0x19	; 25
     d3a:	ff 2e       	mov	r15, r31
     d3c:	f0 2d       	mov	r31, r0
     d3e:	0f 2e       	mov	r0, r31
     d40:	f9 e1       	ldi	r31, 0x19	; 25
     d42:	ef 2e       	mov	r14, r31
     d44:	f0 2d       	mov	r31, r0
     d46:	69 e1       	ldi	r22, 0x19	; 25
     d48:	03 c0       	rjmp	.+6      	; 0xd50 <tinyLED_update+0x136>
static struct RGB_Color tinyLED_enum_to_RGB_Color(enum Colors color){
	struct RGB_Color rgb_color;
	switch(color)
	{
		case OFF:
			rgb_color = (struct RGB_Color){0, 0, 0};
     d4a:	f1 2c       	mov	r15, r1
     d4c:	e1 2c       	mov	r14, r1
     d4e:	60 e0       	ldi	r22, 0x00	; 0
     d50:	2f 82       	std	Y+7, r2	; 0x07
     d52:	38 86       	std	Y+8, r3	; 0x08
	
		
	for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
	{		
		// Convert enum to RGB_Color
		rgb_colors[i] = tinyLED_enum_to_RGB_Color(tinyLED_colors[i].color);
     d54:	d1 01       	movw	r26, r2
     d56:	6c 93       	st	X, r22
     d58:	11 96       	adiw	r26, 0x01	; 1
     d5a:	ec 92       	st	X, r14
     d5c:	11 97       	sbiw	r26, 0x01	; 1
     d5e:	12 96       	adiw	r26, 0x02	; 2
     d60:	fc 92       	st	X, r15
			
		// Adjust colors according to mode
		switch(tinyLED_colors[i].mode)
     d62:	81 81       	ldd	r24, Z+1	; 0x01
     d64:	82 30       	cpi	r24, 0x02	; 2
     d66:	d1 f0       	breq	.+52     	; 0xd9c <tinyLED_update+0x182>
     d68:	18 f4       	brcc	.+6      	; 0xd70 <tinyLED_update+0x156>
     d6a:	81 30       	cpi	r24, 0x01	; 1
     d6c:	41 f0       	breq	.+16     	; 0xd7e <tinyLED_update+0x164>
     d6e:	cd c0       	rjmp	.+410    	; 0xf0a <tinyLED_update+0x2f0>
     d70:	83 30       	cpi	r24, 0x03	; 3
     d72:	09 f4       	brne	.+2      	; 0xd76 <tinyLED_update+0x15c>
     d74:	44 c0       	rjmp	.+136    	; 0xdfe <tinyLED_update+0x1e4>
     d76:	84 30       	cpi	r24, 0x04	; 4
     d78:	09 f4       	brne	.+2      	; 0xd7c <tinyLED_update+0x162>
     d7a:	bf c0       	rjmp	.+382    	; 0xefa <tinyLED_update+0x2e0>
     d7c:	c6 c0       	rjmp	.+396    	; 0xf0a <tinyLED_update+0x2f0>
		{
			case STABLE:
				break;
			case FLASH:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*flash_on, rgb_colors[i].green*flash_on, rgb_colors[i].blue*flash_on};
     d7e:	d6 9e       	mul	r13, r22
     d80:	60 2d       	mov	r22, r0
     d82:	11 24       	eor	r1, r1
     d84:	ef 81       	ldd	r30, Y+7	; 0x07
     d86:	f8 85       	ldd	r31, Y+8	; 0x08
     d88:	60 83       	st	Z, r22
     d8a:	de 9c       	mul	r13, r14
     d8c:	e0 2c       	mov	r14, r0
     d8e:	11 24       	eor	r1, r1
     d90:	e1 82       	std	Z+1, r14	; 0x01
     d92:	df 9c       	mul	r13, r15
     d94:	f0 2c       	mov	r15, r0
     d96:	11 24       	eor	r1, r1
     d98:	f2 82       	std	Z+2, r15	; 0x02
				break;
     d9a:	b7 c0       	rjmp	.+366    	; 0xf0a <tinyLED_update+0x2f0>
			case SWING:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*sinValue, rgb_colors[i].green*sinValue, rgb_colors[i].blue*sinValue};
     d9c:	70 e0       	ldi	r23, 0x00	; 0
     d9e:	80 e0       	ldi	r24, 0x00	; 0
     da0:	90 e0       	ldi	r25, 0x00	; 0
     da2:	0e 94 1b 0a 	call	0x1436	; 0x1436 <__floatsisf>
     da6:	29 85       	ldd	r18, Y+9	; 0x09
     da8:	3a 85       	ldd	r19, Y+10	; 0x0a
     daa:	4b 85       	ldd	r20, Y+11	; 0x0b
     dac:	5c 85       	ldd	r21, Y+12	; 0x0c
     dae:	0e 94 8c 0b 	call	0x1718	; 0x1718 <__mulsf3>
     db2:	0e 94 ea 09 	call	0x13d4	; 0x13d4 <__fixunssfsi>
     db6:	d1 01       	movw	r26, r2
     db8:	6c 93       	st	X, r22
     dba:	6e 2d       	mov	r22, r14
     dbc:	70 e0       	ldi	r23, 0x00	; 0
     dbe:	80 e0       	ldi	r24, 0x00	; 0
     dc0:	90 e0       	ldi	r25, 0x00	; 0
     dc2:	0e 94 1b 0a 	call	0x1436	; 0x1436 <__floatsisf>
     dc6:	29 85       	ldd	r18, Y+9	; 0x09
     dc8:	3a 85       	ldd	r19, Y+10	; 0x0a
     dca:	4b 85       	ldd	r20, Y+11	; 0x0b
     dcc:	5c 85       	ldd	r21, Y+12	; 0x0c
     dce:	0e 94 8c 0b 	call	0x1718	; 0x1718 <__mulsf3>
     dd2:	0e 94 ea 09 	call	0x13d4	; 0x13d4 <__fixunssfsi>
     dd6:	f1 01       	movw	r30, r2
     dd8:	61 83       	std	Z+1, r22	; 0x01
     dda:	6f 2d       	mov	r22, r15
     ddc:	70 e0       	ldi	r23, 0x00	; 0
     dde:	80 e0       	ldi	r24, 0x00	; 0
     de0:	90 e0       	ldi	r25, 0x00	; 0
     de2:	0e 94 1b 0a 	call	0x1436	; 0x1436 <__floatsisf>
     de6:	29 85       	ldd	r18, Y+9	; 0x09
     de8:	3a 85       	ldd	r19, Y+10	; 0x0a
     dea:	4b 85       	ldd	r20, Y+11	; 0x0b
     dec:	5c 85       	ldd	r21, Y+12	; 0x0c
     dee:	0e 94 8c 0b 	call	0x1718	; 0x1718 <__mulsf3>
     df2:	0e 94 ea 09 	call	0x13d4	; 0x13d4 <__fixunssfsi>
     df6:	d1 01       	movw	r26, r2
     df8:	12 96       	adiw	r26, 0x02	; 2
     dfa:	6c 93       	st	X, r22
				break;
     dfc:	86 c0       	rjmp	.+268    	; 0xf0a <tinyLED_update+0x2f0>
			case PING:
				// in the line below, fmin will either return 1 or 0, so each rgb color is either 0 or 255*PING_BRIGHTNESS
				rgb_colors[i] = (struct RGB_Color){255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].red)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].green)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].blue)*ping_on};
     dfe:	70 e0       	ldi	r23, 0x00	; 0
     e00:	80 e0       	ldi	r24, 0x00	; 0
     e02:	90 e0       	ldi	r25, 0x00	; 0
     e04:	0e 94 19 0a 	call	0x1432	; 0x1432 <__floatunsisf>
     e08:	9b 01       	movw	r18, r22
     e0a:	ac 01       	movw	r20, r24
     e0c:	60 e0       	ldi	r22, 0x00	; 0
     e0e:	70 e0       	ldi	r23, 0x00	; 0
     e10:	80 e8       	ldi	r24, 0x80	; 128
     e12:	9f e3       	ldi	r25, 0x3F	; 63
     e14:	0e 94 56 0a 	call	0x14ac	; 0x14ac <fmin>
     e18:	6b 8b       	std	Y+19, r22	; 0x13
     e1a:	7c 8b       	std	Y+20, r23	; 0x14
     e1c:	8d 8b       	std	Y+21, r24	; 0x15
     e1e:	9e 8b       	std	Y+22, r25	; 0x16
     e20:	c5 01       	movw	r24, r10
     e22:	b4 01       	movw	r22, r8
     e24:	0e 94 1b 0a 	call	0x1436	; 0x1436 <__floatsisf>
     e28:	6f 87       	std	Y+15, r22	; 0x0f
     e2a:	78 8b       	std	Y+16, r23	; 0x10
     e2c:	89 8b       	std	Y+17, r24	; 0x11
     e2e:	9a 8b       	std	Y+18, r25	; 0x12
     e30:	6e 2d       	mov	r22, r14
     e32:	70 e0       	ldi	r23, 0x00	; 0
     e34:	80 e0       	ldi	r24, 0x00	; 0
     e36:	90 e0       	ldi	r25, 0x00	; 0
     e38:	0e 94 19 0a 	call	0x1432	; 0x1432 <__floatunsisf>
     e3c:	9b 01       	movw	r18, r22
     e3e:	ac 01       	movw	r20, r24
     e40:	60 e0       	ldi	r22, 0x00	; 0
     e42:	70 e0       	ldi	r23, 0x00	; 0
     e44:	80 e8       	ldi	r24, 0x80	; 128
     e46:	9f e3       	ldi	r25, 0x3F	; 63
     e48:	0e 94 56 0a 	call	0x14ac	; 0x14ac <fmin>
     e4c:	6f 8b       	std	Y+23, r22	; 0x17
     e4e:	78 8f       	std	Y+24, r23	; 0x18
     e50:	89 8f       	std	Y+25, r24	; 0x19
     e52:	9a 8f       	std	Y+26, r25	; 0x1a
     e54:	6f 2d       	mov	r22, r15
     e56:	70 e0       	ldi	r23, 0x00	; 0
     e58:	80 e0       	ldi	r24, 0x00	; 0
     e5a:	90 e0       	ldi	r25, 0x00	; 0
     e5c:	0e 94 19 0a 	call	0x1432	; 0x1432 <__floatunsisf>
     e60:	9b 01       	movw	r18, r22
     e62:	ac 01       	movw	r20, r24
     e64:	60 e0       	ldi	r22, 0x00	; 0
     e66:	70 e0       	ldi	r23, 0x00	; 0
     e68:	80 e8       	ldi	r24, 0x80	; 128
     e6a:	9f e3       	ldi	r25, 0x3F	; 63
     e6c:	0e 94 56 0a 	call	0x14ac	; 0x14ac <fmin>
     e70:	6b 8f       	std	Y+27, r22	; 0x1b
     e72:	7c 8f       	std	Y+28, r23	; 0x1c
     e74:	8d 8f       	std	Y+29, r24	; 0x1d
     e76:	9e 8f       	std	Y+30, r25	; 0x1e
     e78:	23 e3       	ldi	r18, 0x33	; 51
     e7a:	33 e3       	ldi	r19, 0x33	; 51
     e7c:	43 ea       	ldi	r20, 0xA3	; 163
     e7e:	50 e4       	ldi	r21, 0x40	; 64
     e80:	6b 89       	ldd	r22, Y+19	; 0x13
     e82:	7c 89       	ldd	r23, Y+20	; 0x14
     e84:	8d 89       	ldd	r24, Y+21	; 0x15
     e86:	9e 89       	ldd	r25, Y+22	; 0x16
     e88:	0e 94 8c 0b 	call	0x1718	; 0x1718 <__mulsf3>
     e8c:	2f 85       	ldd	r18, Y+15	; 0x0f
     e8e:	38 89       	ldd	r19, Y+16	; 0x10
     e90:	49 89       	ldd	r20, Y+17	; 0x11
     e92:	5a 89       	ldd	r21, Y+18	; 0x12
     e94:	0e 94 8c 0b 	call	0x1718	; 0x1718 <__mulsf3>
     e98:	0e 94 ea 09 	call	0x13d4	; 0x13d4 <__fixunssfsi>
     e9c:	ef 81       	ldd	r30, Y+7	; 0x07
     e9e:	f8 85       	ldd	r31, Y+8	; 0x08
     ea0:	60 83       	st	Z, r22
     ea2:	23 e3       	ldi	r18, 0x33	; 51
     ea4:	33 e3       	ldi	r19, 0x33	; 51
     ea6:	43 ea       	ldi	r20, 0xA3	; 163
     ea8:	50 e4       	ldi	r21, 0x40	; 64
     eaa:	6f 89       	ldd	r22, Y+23	; 0x17
     eac:	78 8d       	ldd	r23, Y+24	; 0x18
     eae:	89 8d       	ldd	r24, Y+25	; 0x19
     eb0:	9a 8d       	ldd	r25, Y+26	; 0x1a
     eb2:	0e 94 8c 0b 	call	0x1718	; 0x1718 <__mulsf3>
     eb6:	2f 85       	ldd	r18, Y+15	; 0x0f
     eb8:	38 89       	ldd	r19, Y+16	; 0x10
     eba:	49 89       	ldd	r20, Y+17	; 0x11
     ebc:	5a 89       	ldd	r21, Y+18	; 0x12
     ebe:	0e 94 8c 0b 	call	0x1718	; 0x1718 <__mulsf3>
     ec2:	0e 94 ea 09 	call	0x13d4	; 0x13d4 <__fixunssfsi>
     ec6:	af 81       	ldd	r26, Y+7	; 0x07
     ec8:	b8 85       	ldd	r27, Y+8	; 0x08
     eca:	11 96       	adiw	r26, 0x01	; 1
     ecc:	6c 93       	st	X, r22
     ece:	23 e3       	ldi	r18, 0x33	; 51
     ed0:	33 e3       	ldi	r19, 0x33	; 51
     ed2:	43 ea       	ldi	r20, 0xA3	; 163
     ed4:	50 e4       	ldi	r21, 0x40	; 64
     ed6:	6b 8d       	ldd	r22, Y+27	; 0x1b
     ed8:	7c 8d       	ldd	r23, Y+28	; 0x1c
     eda:	8d 8d       	ldd	r24, Y+29	; 0x1d
     edc:	9e 8d       	ldd	r25, Y+30	; 0x1e
     ede:	0e 94 8c 0b 	call	0x1718	; 0x1718 <__mulsf3>
     ee2:	2f 85       	ldd	r18, Y+15	; 0x0f
     ee4:	38 89       	ldd	r19, Y+16	; 0x10
     ee6:	49 89       	ldd	r20, Y+17	; 0x11
     ee8:	5a 89       	ldd	r21, Y+18	; 0x12
     eea:	0e 94 8c 0b 	call	0x1718	; 0x1718 <__mulsf3>
     eee:	0e 94 ea 09 	call	0x13d4	; 0x13d4 <__fixunssfsi>
     ef2:	ef 81       	ldd	r30, Y+7	; 0x07
     ef4:	f8 85       	ldd	r31, Y+8	; 0x08
     ef6:	62 83       	std	Z+2, r22	; 0x02
				break;
     ef8:	08 c0       	rjmp	.+16     	; 0xf0a <tinyLED_update+0x2f0>
			case FLASH_ONCE:
				if(tinyLED_flash_once_time[i]>0){
     efa:	d2 01       	movw	r26, r4
     efc:	8c 91       	ld	r24, X
     efe:	88 23       	and	r24, r24
     f00:	19 f0       	breq	.+6      	; 0xf08 <tinyLED_update+0x2ee>
					rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red, rgb_colors[i].green, rgb_colors[i].blue};
					tinyLED_flash_once_time[i]--;
     f02:	81 50       	subi	r24, 0x01	; 1
     f04:	8c 93       	st	X, r24
     f06:	01 c0       	rjmp	.+2      	; 0xf0a <tinyLED_update+0x2f0>
				}
				else{
					tinyLED_colors[i].color = OFF;
     f08:	10 82       	st	Z, r1
     f0a:	0e 5f       	subi	r16, 0xFE	; 254
     f0c:	1f 4f       	sbci	r17, 0xFF	; 255
     f0e:	b3 e0       	ldi	r27, 0x03	; 3
     f10:	2b 0e       	add	r2, r27
     f12:	31 1c       	adc	r3, r1
     f14:	ef ef       	ldi	r30, 0xFF	; 255
     f16:	4e 1a       	sub	r4, r30
     f18:	5e 0a       	sbc	r5, r30
	_Bool flash_on = now%(uint32_t)(1000/FLASH_RATE)   <   500/FLASH_RATE;
	_Bool ping_on = now%(uint32_t)(1000/PING_RATE)   <   1000*FLASH_TIME;
	struct RGB_Color rgb_colors[NUMBER_OF_LEDS];
	
		
	for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
     f1a:	06 15       	cp	r16, r6
     f1c:	17 05       	cpc	r17, r7
     f1e:	09 f0       	breq	.+2      	; 0xf22 <tinyLED_update+0x308>
     f20:	eb ce       	rjmp	.-554    	; 0xcf8 <tinyLED_update+0xde>
     f22:	cd 84       	ldd	r12, Y+13	; 0x0d
     f24:	de 84       	ldd	r13, Y+14	; 0x0e
				break;
		}
	}
	
	// We only write to the LEDs if there is something to change. (In SWING mode, we update the LEDs every cycle)
	if(!tinyLED_RGB_Color_Compare(&rgb_colors, &tinyLED_old_colors)){
     f26:	6b e5       	ldi	r22, 0x5B	; 91
     f28:	78 e3       	ldi	r23, 0x38	; 56
     f2a:	ce 01       	movw	r24, r28
     f2c:	01 96       	adiw	r24, 0x01	; 1
     f2e:	0e 94 dd 05 	call	0xbba	; 0xbba <tinyLED_RGB_Color_Compare>
     f32:	81 11       	cpse	r24, r1
     f34:	2f c0       	rjmp	.+94     	; 0xf94 <tinyLED_update+0x37a>
     f36:	0b e5       	ldi	r16, 0x5B	; 91
     f38:	18 e3       	ldi	r17, 0x38	; 56
     f3a:	7e 01       	movw	r14, r28
     f3c:	f7 e0       	ldi	r31, 0x07	; 7
     f3e:	ef 0e       	add	r14, r31
     f40:	f1 1c       	adc	r15, r1
		for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
		{
			// Write to LEDs
			//For some reason, the data-bus to the LEDs is serialized as GRB
			//which means the 24-bit data-bus will look like [Green[0:7], Red[0:7], Blue[0:7]]
			tinyLED_SPIWriteByte(rgb_colors[i].green);
     f42:	d6 01       	movw	r26, r12
     f44:	11 96       	adiw	r26, 0x01	; 1
     f46:	8c 91       	ld	r24, X
     f48:	0e 94 a8 05 	call	0xb50	; 0xb50 <tinyLED_SPIWriteByte>
			tinyLED_SPIWriteByte(rgb_colors[i].red);
     f4c:	f6 01       	movw	r30, r12
     f4e:	80 81       	ld	r24, Z
     f50:	0e 94 a8 05 	call	0xb50	; 0xb50 <tinyLED_SPIWriteByte>
			tinyLED_SPIWriteByte(rgb_colors[i].blue);
     f54:	d6 01       	movw	r26, r12
     f56:	12 96       	adiw	r26, 0x02	; 2
     f58:	8c 91       	ld	r24, X
     f5a:	0e 94 a8 05 	call	0xb50	; 0xb50 <tinyLED_SPIWriteByte>
			tinyLED_old_colors[i] = rgb_colors[i];
     f5e:	f6 01       	movw	r30, r12
     f60:	81 91       	ld	r24, Z+
     f62:	91 91       	ld	r25, Z+
     f64:	a1 91       	ld	r26, Z+
     f66:	6f 01       	movw	r12, r30
     f68:	f8 01       	movw	r30, r16
     f6a:	81 93       	st	Z+, r24
     f6c:	91 93       	st	Z+, r25
     f6e:	a1 93       	st	Z+, r26
     f70:	8f 01       	movw	r16, r30
		}
	}
	
	// We only write to the LEDs if there is something to change. (In SWING mode, we update the LEDs every cycle)
	if(!tinyLED_RGB_Color_Compare(&rgb_colors, &tinyLED_old_colors)){
		for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
     f72:	ce 14       	cp	r12, r14
     f74:	df 04       	cpc	r13, r15
     f76:	29 f7       	brne	.-54     	; 0xf42 <tinyLED_update+0x328>
			tinyLED_SPIWriteByte(rgb_colors[i].green);
			tinyLED_SPIWriteByte(rgb_colors[i].red);
			tinyLED_SPIWriteByte(rgb_colors[i].blue);
			tinyLED_old_colors[i] = rgb_colors[i];
	}
		tinyDebugger_send_uint8("LED1 color", tinyLED_colors[0].color);
     f78:	01 e6       	ldi	r16, 0x61	; 97
     f7a:	18 e3       	ldi	r17, 0x38	; 56
     f7c:	d8 01       	movw	r26, r16
     f7e:	6c 91       	ld	r22, X
     f80:	8a e0       	ldi	r24, 0x0A	; 10
     f82:	94 ea       	ldi	r25, 0xA4	; 164
     f84:	0e 94 47 04 	call	0x88e	; 0x88e <tinyDebugger_send_uint8>
		tinyDebugger_send_uint8("LED2 color", tinyLED_colors[1].color);
     f88:	f8 01       	movw	r30, r16
     f8a:	62 81       	ldd	r22, Z+2	; 0x02
     f8c:	85 e1       	ldi	r24, 0x15	; 21
     f8e:	94 ea       	ldi	r25, 0xA4	; 164
     f90:	0e 94 47 04 	call	0x88e	; 0x88e <tinyDebugger_send_uint8>
	}
}
     f94:	6e 96       	adiw	r28, 0x1e	; 30
     f96:	cd bf       	out	0x3d, r28	; 61
     f98:	de bf       	out	0x3e, r29	; 62
     f9a:	df 91       	pop	r29
     f9c:	cf 91       	pop	r28
     f9e:	1f 91       	pop	r17
     fa0:	0f 91       	pop	r16
     fa2:	ff 90       	pop	r15
     fa4:	ef 90       	pop	r14
     fa6:	df 90       	pop	r13
     fa8:	cf 90       	pop	r12
     faa:	bf 90       	pop	r11
     fac:	af 90       	pop	r10
     fae:	9f 90       	pop	r9
     fb0:	8f 90       	pop	r8
     fb2:	7f 90       	pop	r7
     fb4:	6f 90       	pop	r6
     fb6:	5f 90       	pop	r5
     fb8:	4f 90       	pop	r4
     fba:	3f 90       	pop	r3
     fbc:	2f 90       	pop	r2
     fbe:	08 95       	ret

00000fc0 <tinyPotential_update>:

/*
Update the potential
*/
void tinyPotential_update()
{
     fc0:	cf 92       	push	r12
     fc2:	df 92       	push	r13
     fc4:	ef 92       	push	r14
     fc6:	ff 92       	push	r15
Function to decay the potential towards 0
*/
static void tinyPotential_decay()
{
		
	uint8_t time_since_last_update = tinyTime_now() - previous_update_time;
     fc8:	0e 94 c3 08 	call	0x1186	; 0x1186 <tinyTime_now>
	tinyPotential_potential *= (exp(-((float)time_since_last_update/(float)TINYPOTENTIAL_TIME_CONST)));
     fcc:	80 91 45 38 	lds	r24, 0x3845	; 0x803845 <previous_update_time>
     fd0:	68 1b       	sub	r22, r24
     fd2:	70 e0       	ldi	r23, 0x00	; 0
     fd4:	80 e0       	ldi	r24, 0x00	; 0
     fd6:	90 e0       	ldi	r25, 0x00	; 0
     fd8:	0e 94 19 0a 	call	0x1432	; 0x1432 <__floatunsisf>
     fdc:	20 e0       	ldi	r18, 0x00	; 0
     fde:	30 e0       	ldi	r19, 0x00	; 0
     fe0:	48 ec       	ldi	r20, 0xC8	; 200
     fe2:	52 e4       	ldi	r21, 0x42	; 66
     fe4:	0e 94 3e 09 	call	0x127c	; 0x127c <__divsf3>
     fe8:	90 58       	subi	r25, 0x80	; 128
     fea:	0e 94 b8 09 	call	0x1370	; 0x1370 <exp>
     fee:	20 91 49 38 	lds	r18, 0x3849	; 0x803849 <tinyPotential_potential>
     ff2:	30 91 4a 38 	lds	r19, 0x384A	; 0x80384a <tinyPotential_potential+0x1>
     ff6:	40 91 4b 38 	lds	r20, 0x384B	; 0x80384b <tinyPotential_potential+0x2>
     ffa:	50 91 4c 38 	lds	r21, 0x384C	; 0x80384c <tinyPotential_potential+0x3>
     ffe:	0e 94 8c 0b 	call	0x1718	; 0x1718 <__mulsf3>
    1002:	6b 01       	movw	r12, r22
    1004:	7c 01       	movw	r14, r24
	if(fabs(tinyPotential_potential)<0.1){
    1006:	9f 77       	andi	r25, 0x7F	; 127
    1008:	2d ec       	ldi	r18, 0xCD	; 205
    100a:	3c ec       	ldi	r19, 0xCC	; 204
    100c:	4c ec       	ldi	r20, 0xCC	; 204
    100e:	5d e3       	ldi	r21, 0x3D	; 61
    1010:	0e 94 39 09 	call	0x1272	; 0x1272 <__cmpsf2>
    1014:	88 23       	and	r24, r24
    1016:	4c f0       	brlt	.+18     	; 0x102a <tinyPotential_update+0x6a>
*/
static void tinyPotential_decay()
{
		
	uint8_t time_since_last_update = tinyTime_now() - previous_update_time;
	tinyPotential_potential *= (exp(-((float)time_since_last_update/(float)TINYPOTENTIAL_TIME_CONST)));
    1018:	c0 92 49 38 	sts	0x3849, r12	; 0x803849 <tinyPotential_potential>
    101c:	d0 92 4a 38 	sts	0x384A, r13	; 0x80384a <tinyPotential_potential+0x1>
    1020:	e0 92 4b 38 	sts	0x384B, r14	; 0x80384b <tinyPotential_potential+0x2>
    1024:	f0 92 4c 38 	sts	0x384C, r15	; 0x80384c <tinyPotential_potential+0x3>
    1028:	08 c0       	rjmp	.+16     	; 0x103a <tinyPotential_update+0x7a>
	if(fabs(tinyPotential_potential)<0.1){
		tinyPotential_potential=0;
    102a:	10 92 49 38 	sts	0x3849, r1	; 0x803849 <tinyPotential_potential>
    102e:	10 92 4a 38 	sts	0x384A, r1	; 0x80384a <tinyPotential_potential+0x1>
    1032:	10 92 4b 38 	sts	0x384B, r1	; 0x80384b <tinyPotential_potential+0x2>
    1036:	10 92 4c 38 	sts	0x384C, r1	; 0x80384c <tinyPotential_potential+0x3>
	}
	previous_update_time = tinyTime_now();
    103a:	0e 94 c3 08 	call	0x1186	; 0x1186 <tinyTime_now>
    103e:	60 93 45 38 	sts	0x3845, r22	; 0x803845 <previous_update_time>
    1042:	70 93 46 38 	sts	0x3846, r23	; 0x803846 <previous_update_time+0x1>
    1046:	80 93 47 38 	sts	0x3847, r24	; 0x803847 <previous_update_time+0x2>
    104a:	90 93 48 38 	sts	0x3848, r25	; 0x803848 <previous_update_time+0x3>
void tinyPotential_update()
{
	//Some of the potential in the neuron has decayed away
	tinyPotential_decay();
	// Update potential with values from Dendrites
	tinyPotential_potential = tinyDendrite_update_potential(tinyPotential_potential);
    104e:	60 91 49 38 	lds	r22, 0x3849	; 0x803849 <tinyPotential_potential>
    1052:	70 91 4a 38 	lds	r23, 0x384A	; 0x80384a <tinyPotential_potential+0x1>
    1056:	80 91 4b 38 	lds	r24, 0x384B	; 0x80384b <tinyPotential_potential+0x2>
    105a:	90 91 4c 38 	lds	r25, 0x384C	; 0x80384c <tinyPotential_potential+0x3>
    105e:	0e 94 60 05 	call	0xac0	; 0xac0 <tinyDendrite_update_potential>
    1062:	ab 01       	movw	r20, r22
    1064:	bc 01       	movw	r22, r24
    1066:	40 93 49 38 	sts	0x3849, r20	; 0x803849 <tinyPotential_potential>
    106a:	50 93 4a 38 	sts	0x384A, r21	; 0x80384a <tinyPotential_potential+0x1>
    106e:	60 93 4b 38 	sts	0x384B, r22	; 0x80384b <tinyPotential_potential+0x2>
    1072:	70 93 4c 38 	sts	0x384C, r23	; 0x80384c <tinyPotential_potential+0x3>
	tinyDebugger_send_double("DendP", tinyPotential_potential);
    1076:	80 e2       	ldi	r24, 0x20	; 32
    1078:	94 ea       	ldi	r25, 0xA4	; 164
    107a:	0e 94 5c 04 	call	0x8b8	; 0x8b8 <tinyDebugger_send_double>
	
	// Update potential from button press
	tinyPotential_potential = tinyButton_update_potential(tinyPotential_potential);
    107e:	60 91 49 38 	lds	r22, 0x3849	; 0x803849 <tinyPotential_potential>
    1082:	70 91 4a 38 	lds	r23, 0x384A	; 0x80384a <tinyPotential_potential+0x1>
    1086:	80 91 4b 38 	lds	r24, 0x384B	; 0x80384b <tinyPotential_potential+0x2>
    108a:	90 91 4c 38 	lds	r25, 0x384C	; 0x80384c <tinyPotential_potential+0x3>
    108e:	0e 94 f6 03 	call	0x7ec	; 0x7ec <tinyButton_update_potential>
    1092:	60 93 49 38 	sts	0x3849, r22	; 0x803849 <tinyPotential_potential>
    1096:	70 93 4a 38 	sts	0x384A, r23	; 0x80384a <tinyPotential_potential+0x1>
    109a:	80 93 4b 38 	sts	0x384B, r24	; 0x80384b <tinyPotential_potential+0x2>
    109e:	90 93 4c 38 	sts	0x384C, r25	; 0x80384c <tinyPotential_potential+0x3>
	
	// Update potential with values from spontaneous pulse.
	tinyPotential_potential = tinyPulse_update_potential(tinyPotential_potential);
    10a2:	0e 94 77 08 	call	0x10ee	; 0x10ee <tinyPulse_update_potential>
    10a6:	60 93 49 38 	sts	0x3849, r22	; 0x803849 <tinyPotential_potential>
    10aa:	70 93 4a 38 	sts	0x384A, r23	; 0x80384a <tinyPotential_potential+0x1>
    10ae:	80 93 4b 38 	sts	0x384B, r24	; 0x80384b <tinyPotential_potential+0x2>
    10b2:	90 93 4c 38 	sts	0x384C, r25	; 0x80384c <tinyPotential_potential+0x3>
	
	// Let the axon affect the potential
	// This is also where we decide whether or not the axon should fire
	tinyPotential_potential = tinyAxon_update_potential(tinyPotential_potential);
    10b6:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <tinyAxon_update_potential>
    10ba:	ab 01       	movw	r20, r22
    10bc:	bc 01       	movw	r22, r24
    10be:	40 93 49 38 	sts	0x3849, r20	; 0x803849 <tinyPotential_potential>
    10c2:	50 93 4a 38 	sts	0x384A, r21	; 0x80384a <tinyPotential_potential+0x1>
    10c6:	60 93 4b 38 	sts	0x384B, r22	; 0x80384b <tinyPotential_potential+0x2>
    10ca:	70 93 4c 38 	sts	0x384C, r23	; 0x80384c <tinyPotential_potential+0x3>
	tinyDebugger_send_double("AxonP", tinyPotential_potential);
    10ce:	86 e2       	ldi	r24, 0x26	; 38
    10d0:	94 ea       	ldi	r25, 0xA4	; 164
    10d2:	0e 94 5c 04 	call	0x8b8	; 0x8b8 <tinyDebugger_send_double>
}
    10d6:	ff 90       	pop	r15
    10d8:	ef 90       	pop	r14
    10da:	df 90       	pop	r13
    10dc:	cf 90       	pop	r12
    10de:	08 95       	ret

000010e0 <tinyPulse_toggle_pulse_mode>:
uint32_t time_of_last_pulse = 0;
uint16_t time_since_last_pulse = 0;
uint16_t ideal_time_between_pulses = 1000/PULSEMODE_FREQUENCY;

void tinyPulse_toggle_pulse_mode(){
	pulse_mode = !pulse_mode;
    10e0:	90 91 53 38 	lds	r25, 0x3853	; 0x803853 <pulse_mode>
    10e4:	81 e0       	ldi	r24, 0x01	; 1
    10e6:	89 27       	eor	r24, r25
    10e8:	80 93 53 38 	sts	0x3853, r24	; 0x803853 <pulse_mode>
    10ec:	08 95       	ret

000010ee <tinyPulse_update_potential>:
}

double tinyPulse_update_potential(double potential){
    10ee:	cf 92       	push	r12
    10f0:	df 92       	push	r13
    10f2:	ef 92       	push	r14
    10f4:	ff 92       	push	r15
    10f6:	6b 01       	movw	r12, r22
    10f8:	7c 01       	movw	r14, r24
	if(pulse_mode){
    10fa:	80 91 53 38 	lds	r24, 0x3853	; 0x803853 <pulse_mode>
    10fe:	88 23       	and	r24, r24
    1100:	39 f1       	breq	.+78     	; 0x1150 <tinyPulse_update_potential+0x62>
		
		time_since_last_pulse = tinyTime_now() - time_of_last_pulse;
    1102:	0e 94 c3 08 	call	0x1186	; 0x1186 <tinyTime_now>
    1106:	20 91 4f 38 	lds	r18, 0x384F	; 0x80384f <time_of_last_pulse>
    110a:	30 91 50 38 	lds	r19, 0x3850	; 0x803850 <time_of_last_pulse+0x1>
    110e:	62 1b       	sub	r22, r18
    1110:	73 0b       	sbc	r23, r19
    1112:	60 93 4d 38 	sts	0x384D, r22	; 0x80384d <time_since_last_pulse>
    1116:	70 93 4e 38 	sts	0x384E, r23	; 0x80384e <time_since_last_pulse+0x1>
		
		if(time_since_last_pulse >= ideal_time_between_pulses){
    111a:	80 91 14 38 	lds	r24, 0x3814	; 0x803814 <ideal_time_between_pulses>
    111e:	90 91 15 38 	lds	r25, 0x3815	; 0x803815 <ideal_time_between_pulses+0x1>
    1122:	68 17       	cp	r22, r24
    1124:	79 07       	cpc	r23, r25
    1126:	a0 f0       	brcs	.+40     	; 0x1150 <tinyPulse_update_potential+0x62>
			// This isn't actually a button press. You could have a separate variable for this, but it seems unnecessary.
			potential += BUTTON_PRESS_REACTION;
    1128:	20 e0       	ldi	r18, 0x00	; 0
    112a:	30 e0       	ldi	r19, 0x00	; 0
    112c:	40 ed       	ldi	r20, 0xD0	; 208
    112e:	51 e4       	ldi	r21, 0x41	; 65
    1130:	c7 01       	movw	r24, r14
    1132:	b6 01       	movw	r22, r12
    1134:	0e 94 cd 08 	call	0x119a	; 0x119a <__addsf3>
    1138:	6b 01       	movw	r12, r22
    113a:	7c 01       	movw	r14, r24
			time_of_last_pulse = tinyTime_now();			
    113c:	0e 94 c3 08 	call	0x1186	; 0x1186 <tinyTime_now>
    1140:	60 93 4f 38 	sts	0x384F, r22	; 0x80384f <time_of_last_pulse>
    1144:	70 93 50 38 	sts	0x3850, r23	; 0x803850 <time_of_last_pulse+0x1>
    1148:	80 93 51 38 	sts	0x3851, r24	; 0x803851 <time_of_last_pulse+0x2>
    114c:	90 93 52 38 	sts	0x3852, r25	; 0x803852 <time_of_last_pulse+0x3>
		}
	}
	return potential;
}
    1150:	c7 01       	movw	r24, r14
    1152:	b6 01       	movw	r22, r12
    1154:	ff 90       	pop	r15
    1156:	ef 90       	pop	r14
    1158:	df 90       	pop	r13
    115a:	cf 90       	pop	r12
    115c:	08 95       	ret

0000115e <tinyTime_counter_increment>:
If the Interrupt Service Routine is clocked by a crystal oscillator
it gives a very precise timer-counter.
*/
void tinyTime_counter_increment(void)
{
	time_counter++;
    115e:	80 91 54 38 	lds	r24, 0x3854	; 0x803854 <time_counter>
    1162:	90 91 55 38 	lds	r25, 0x3855	; 0x803855 <time_counter+0x1>
    1166:	a0 91 56 38 	lds	r26, 0x3856	; 0x803856 <time_counter+0x2>
    116a:	b0 91 57 38 	lds	r27, 0x3857	; 0x803857 <time_counter+0x3>
    116e:	01 96       	adiw	r24, 0x01	; 1
    1170:	a1 1d       	adc	r26, r1
    1172:	b1 1d       	adc	r27, r1
    1174:	80 93 54 38 	sts	0x3854, r24	; 0x803854 <time_counter>
    1178:	90 93 55 38 	sts	0x3855, r25	; 0x803855 <time_counter+0x1>
    117c:	a0 93 56 38 	sts	0x3856, r26	; 0x803856 <time_counter+0x2>
    1180:	b0 93 57 38 	sts	0x3857, r27	; 0x803857 <time_counter+0x3>
    1184:	08 95       	ret

00001186 <tinyTime_now>:
/*
This function is callable by external libraries to give them the counted time so far.
*/
uint32_t tinyTime_now(void)
{
	return time_counter;
    1186:	60 91 54 38 	lds	r22, 0x3854	; 0x803854 <time_counter>
    118a:	70 91 55 38 	lds	r23, 0x3855	; 0x803855 <time_counter+0x1>
    118e:	80 91 56 38 	lds	r24, 0x3856	; 0x803856 <time_counter+0x2>
    1192:	90 91 57 38 	lds	r25, 0x3857	; 0x803857 <time_counter+0x3>
    1196:	08 95       	ret

00001198 <__subsf3>:
    1198:	50 58       	subi	r21, 0x80	; 128

0000119a <__addsf3>:
    119a:	bb 27       	eor	r27, r27
    119c:	aa 27       	eor	r26, r26
    119e:	0e 94 e4 08 	call	0x11c8	; 0x11c8 <__addsf3x>
    11a2:	0c 94 d7 0a 	jmp	0x15ae	; 0x15ae <__fp_round>
    11a6:	0e 94 c9 0a 	call	0x1592	; 0x1592 <__fp_pscA>
    11aa:	38 f0       	brcs	.+14     	; 0x11ba <__addsf3+0x20>
    11ac:	0e 94 d0 0a 	call	0x15a0	; 0x15a0 <__fp_pscB>
    11b0:	20 f0       	brcs	.+8      	; 0x11ba <__addsf3+0x20>
    11b2:	39 f4       	brne	.+14     	; 0x11c2 <__addsf3+0x28>
    11b4:	9f 3f       	cpi	r25, 0xFF	; 255
    11b6:	19 f4       	brne	.+6      	; 0x11be <__addsf3+0x24>
    11b8:	26 f4       	brtc	.+8      	; 0x11c2 <__addsf3+0x28>
    11ba:	0c 94 9f 0a 	jmp	0x153e	; 0x153e <__fp_nan>
    11be:	0e f4       	brtc	.+2      	; 0x11c2 <__addsf3+0x28>
    11c0:	e0 95       	com	r30
    11c2:	e7 fb       	bst	r30, 7
    11c4:	0c 94 99 0a 	jmp	0x1532	; 0x1532 <__fp_inf>

000011c8 <__addsf3x>:
    11c8:	e9 2f       	mov	r30, r25
    11ca:	0e 94 e8 0a 	call	0x15d0	; 0x15d0 <__fp_split3>
    11ce:	58 f3       	brcs	.-42     	; 0x11a6 <__addsf3+0xc>
    11d0:	ba 17       	cp	r27, r26
    11d2:	62 07       	cpc	r22, r18
    11d4:	73 07       	cpc	r23, r19
    11d6:	84 07       	cpc	r24, r20
    11d8:	95 07       	cpc	r25, r21
    11da:	20 f0       	brcs	.+8      	; 0x11e4 <__addsf3x+0x1c>
    11dc:	79 f4       	brne	.+30     	; 0x11fc <__addsf3x+0x34>
    11de:	a6 f5       	brtc	.+104    	; 0x1248 <__addsf3x+0x80>
    11e0:	0c 94 0a 0b 	jmp	0x1614	; 0x1614 <__fp_zero>
    11e4:	0e f4       	brtc	.+2      	; 0x11e8 <__addsf3x+0x20>
    11e6:	e0 95       	com	r30
    11e8:	0b 2e       	mov	r0, r27
    11ea:	ba 2f       	mov	r27, r26
    11ec:	a0 2d       	mov	r26, r0
    11ee:	0b 01       	movw	r0, r22
    11f0:	b9 01       	movw	r22, r18
    11f2:	90 01       	movw	r18, r0
    11f4:	0c 01       	movw	r0, r24
    11f6:	ca 01       	movw	r24, r20
    11f8:	a0 01       	movw	r20, r0
    11fa:	11 24       	eor	r1, r1
    11fc:	ff 27       	eor	r31, r31
    11fe:	59 1b       	sub	r21, r25
    1200:	99 f0       	breq	.+38     	; 0x1228 <__addsf3x+0x60>
    1202:	59 3f       	cpi	r21, 0xF9	; 249
    1204:	50 f4       	brcc	.+20     	; 0x121a <__addsf3x+0x52>
    1206:	50 3e       	cpi	r21, 0xE0	; 224
    1208:	68 f1       	brcs	.+90     	; 0x1264 <__addsf3x+0x9c>
    120a:	1a 16       	cp	r1, r26
    120c:	f0 40       	sbci	r31, 0x00	; 0
    120e:	a2 2f       	mov	r26, r18
    1210:	23 2f       	mov	r18, r19
    1212:	34 2f       	mov	r19, r20
    1214:	44 27       	eor	r20, r20
    1216:	58 5f       	subi	r21, 0xF8	; 248
    1218:	f3 cf       	rjmp	.-26     	; 0x1200 <__addsf3x+0x38>
    121a:	46 95       	lsr	r20
    121c:	37 95       	ror	r19
    121e:	27 95       	ror	r18
    1220:	a7 95       	ror	r26
    1222:	f0 40       	sbci	r31, 0x00	; 0
    1224:	53 95       	inc	r21
    1226:	c9 f7       	brne	.-14     	; 0x121a <__addsf3x+0x52>
    1228:	7e f4       	brtc	.+30     	; 0x1248 <__addsf3x+0x80>
    122a:	1f 16       	cp	r1, r31
    122c:	ba 0b       	sbc	r27, r26
    122e:	62 0b       	sbc	r22, r18
    1230:	73 0b       	sbc	r23, r19
    1232:	84 0b       	sbc	r24, r20
    1234:	ba f0       	brmi	.+46     	; 0x1264 <__addsf3x+0x9c>
    1236:	91 50       	subi	r25, 0x01	; 1
    1238:	a1 f0       	breq	.+40     	; 0x1262 <__addsf3x+0x9a>
    123a:	ff 0f       	add	r31, r31
    123c:	bb 1f       	adc	r27, r27
    123e:	66 1f       	adc	r22, r22
    1240:	77 1f       	adc	r23, r23
    1242:	88 1f       	adc	r24, r24
    1244:	c2 f7       	brpl	.-16     	; 0x1236 <__addsf3x+0x6e>
    1246:	0e c0       	rjmp	.+28     	; 0x1264 <__addsf3x+0x9c>
    1248:	ba 0f       	add	r27, r26
    124a:	62 1f       	adc	r22, r18
    124c:	73 1f       	adc	r23, r19
    124e:	84 1f       	adc	r24, r20
    1250:	48 f4       	brcc	.+18     	; 0x1264 <__addsf3x+0x9c>
    1252:	87 95       	ror	r24
    1254:	77 95       	ror	r23
    1256:	67 95       	ror	r22
    1258:	b7 95       	ror	r27
    125a:	f7 95       	ror	r31
    125c:	9e 3f       	cpi	r25, 0xFE	; 254
    125e:	08 f0       	brcs	.+2      	; 0x1262 <__addsf3x+0x9a>
    1260:	b0 cf       	rjmp	.-160    	; 0x11c2 <__addsf3+0x28>
    1262:	93 95       	inc	r25
    1264:	88 0f       	add	r24, r24
    1266:	08 f0       	brcs	.+2      	; 0x126a <__addsf3x+0xa2>
    1268:	99 27       	eor	r25, r25
    126a:	ee 0f       	add	r30, r30
    126c:	97 95       	ror	r25
    126e:	87 95       	ror	r24
    1270:	08 95       	ret

00001272 <__cmpsf2>:
    1272:	0e 94 75 0a 	call	0x14ea	; 0x14ea <__fp_cmp>
    1276:	08 f4       	brcc	.+2      	; 0x127a <__cmpsf2+0x8>
    1278:	81 e0       	ldi	r24, 0x01	; 1
    127a:	08 95       	ret

0000127c <__divsf3>:
    127c:	0e 94 52 09 	call	0x12a4	; 0x12a4 <__divsf3x>
    1280:	0c 94 d7 0a 	jmp	0x15ae	; 0x15ae <__fp_round>
    1284:	0e 94 d0 0a 	call	0x15a0	; 0x15a0 <__fp_pscB>
    1288:	58 f0       	brcs	.+22     	; 0x12a0 <__divsf3+0x24>
    128a:	0e 94 c9 0a 	call	0x1592	; 0x1592 <__fp_pscA>
    128e:	40 f0       	brcs	.+16     	; 0x12a0 <__divsf3+0x24>
    1290:	29 f4       	brne	.+10     	; 0x129c <__divsf3+0x20>
    1292:	5f 3f       	cpi	r21, 0xFF	; 255
    1294:	29 f0       	breq	.+10     	; 0x12a0 <__divsf3+0x24>
    1296:	0c 94 99 0a 	jmp	0x1532	; 0x1532 <__fp_inf>
    129a:	51 11       	cpse	r21, r1
    129c:	0c 94 0b 0b 	jmp	0x1616	; 0x1616 <__fp_szero>
    12a0:	0c 94 9f 0a 	jmp	0x153e	; 0x153e <__fp_nan>

000012a4 <__divsf3x>:
    12a4:	0e 94 e8 0a 	call	0x15d0	; 0x15d0 <__fp_split3>
    12a8:	68 f3       	brcs	.-38     	; 0x1284 <__divsf3+0x8>

000012aa <__divsf3_pse>:
    12aa:	99 23       	and	r25, r25
    12ac:	b1 f3       	breq	.-20     	; 0x129a <__divsf3+0x1e>
    12ae:	55 23       	and	r21, r21
    12b0:	91 f3       	breq	.-28     	; 0x1296 <__divsf3+0x1a>
    12b2:	95 1b       	sub	r25, r21
    12b4:	55 0b       	sbc	r21, r21
    12b6:	bb 27       	eor	r27, r27
    12b8:	aa 27       	eor	r26, r26
    12ba:	62 17       	cp	r22, r18
    12bc:	73 07       	cpc	r23, r19
    12be:	84 07       	cpc	r24, r20
    12c0:	38 f0       	brcs	.+14     	; 0x12d0 <__divsf3_pse+0x26>
    12c2:	9f 5f       	subi	r25, 0xFF	; 255
    12c4:	5f 4f       	sbci	r21, 0xFF	; 255
    12c6:	22 0f       	add	r18, r18
    12c8:	33 1f       	adc	r19, r19
    12ca:	44 1f       	adc	r20, r20
    12cc:	aa 1f       	adc	r26, r26
    12ce:	a9 f3       	breq	.-22     	; 0x12ba <__divsf3_pse+0x10>
    12d0:	35 d0       	rcall	.+106    	; 0x133c <__divsf3_pse+0x92>
    12d2:	0e 2e       	mov	r0, r30
    12d4:	3a f0       	brmi	.+14     	; 0x12e4 <__divsf3_pse+0x3a>
    12d6:	e0 e8       	ldi	r30, 0x80	; 128
    12d8:	32 d0       	rcall	.+100    	; 0x133e <__divsf3_pse+0x94>
    12da:	91 50       	subi	r25, 0x01	; 1
    12dc:	50 40       	sbci	r21, 0x00	; 0
    12de:	e6 95       	lsr	r30
    12e0:	00 1c       	adc	r0, r0
    12e2:	ca f7       	brpl	.-14     	; 0x12d6 <__divsf3_pse+0x2c>
    12e4:	2b d0       	rcall	.+86     	; 0x133c <__divsf3_pse+0x92>
    12e6:	fe 2f       	mov	r31, r30
    12e8:	29 d0       	rcall	.+82     	; 0x133c <__divsf3_pse+0x92>
    12ea:	66 0f       	add	r22, r22
    12ec:	77 1f       	adc	r23, r23
    12ee:	88 1f       	adc	r24, r24
    12f0:	bb 1f       	adc	r27, r27
    12f2:	26 17       	cp	r18, r22
    12f4:	37 07       	cpc	r19, r23
    12f6:	48 07       	cpc	r20, r24
    12f8:	ab 07       	cpc	r26, r27
    12fa:	b0 e8       	ldi	r27, 0x80	; 128
    12fc:	09 f0       	breq	.+2      	; 0x1300 <__divsf3_pse+0x56>
    12fe:	bb 0b       	sbc	r27, r27
    1300:	80 2d       	mov	r24, r0
    1302:	bf 01       	movw	r22, r30
    1304:	ff 27       	eor	r31, r31
    1306:	93 58       	subi	r25, 0x83	; 131
    1308:	5f 4f       	sbci	r21, 0xFF	; 255
    130a:	3a f0       	brmi	.+14     	; 0x131a <__divsf3_pse+0x70>
    130c:	9e 3f       	cpi	r25, 0xFE	; 254
    130e:	51 05       	cpc	r21, r1
    1310:	78 f0       	brcs	.+30     	; 0x1330 <__divsf3_pse+0x86>
    1312:	0c 94 99 0a 	jmp	0x1532	; 0x1532 <__fp_inf>
    1316:	0c 94 0b 0b 	jmp	0x1616	; 0x1616 <__fp_szero>
    131a:	5f 3f       	cpi	r21, 0xFF	; 255
    131c:	e4 f3       	brlt	.-8      	; 0x1316 <__divsf3_pse+0x6c>
    131e:	98 3e       	cpi	r25, 0xE8	; 232
    1320:	d4 f3       	brlt	.-12     	; 0x1316 <__divsf3_pse+0x6c>
    1322:	86 95       	lsr	r24
    1324:	77 95       	ror	r23
    1326:	67 95       	ror	r22
    1328:	b7 95       	ror	r27
    132a:	f7 95       	ror	r31
    132c:	9f 5f       	subi	r25, 0xFF	; 255
    132e:	c9 f7       	brne	.-14     	; 0x1322 <__divsf3_pse+0x78>
    1330:	88 0f       	add	r24, r24
    1332:	91 1d       	adc	r25, r1
    1334:	96 95       	lsr	r25
    1336:	87 95       	ror	r24
    1338:	97 f9       	bld	r25, 7
    133a:	08 95       	ret
    133c:	e1 e0       	ldi	r30, 0x01	; 1
    133e:	66 0f       	add	r22, r22
    1340:	77 1f       	adc	r23, r23
    1342:	88 1f       	adc	r24, r24
    1344:	bb 1f       	adc	r27, r27
    1346:	62 17       	cp	r22, r18
    1348:	73 07       	cpc	r23, r19
    134a:	84 07       	cpc	r24, r20
    134c:	ba 07       	cpc	r27, r26
    134e:	20 f0       	brcs	.+8      	; 0x1358 <__divsf3_pse+0xae>
    1350:	62 1b       	sub	r22, r18
    1352:	73 0b       	sbc	r23, r19
    1354:	84 0b       	sbc	r24, r20
    1356:	ba 0b       	sbc	r27, r26
    1358:	ee 1f       	adc	r30, r30
    135a:	88 f7       	brcc	.-30     	; 0x133e <__divsf3_pse+0x94>
    135c:	e0 95       	com	r30
    135e:	08 95       	ret
    1360:	29 f4       	brne	.+10     	; 0x136c <__divsf3_pse+0xc2>
    1362:	16 f0       	brts	.+4      	; 0x1368 <__divsf3_pse+0xbe>
    1364:	0c 94 99 0a 	jmp	0x1532	; 0x1532 <__fp_inf>
    1368:	0c 94 0a 0b 	jmp	0x1614	; 0x1614 <__fp_zero>
    136c:	0c 94 9f 0a 	jmp	0x153e	; 0x153e <__fp_nan>

00001370 <exp>:
    1370:	0e 94 f0 0a 	call	0x15e0	; 0x15e0 <__fp_splitA>
    1374:	a8 f3       	brcs	.-22     	; 0x1360 <__divsf3_pse+0xb6>
    1376:	96 38       	cpi	r25, 0x86	; 134
    1378:	a0 f7       	brcc	.-24     	; 0x1362 <__divsf3_pse+0xb8>
    137a:	07 f8       	bld	r0, 7
    137c:	0f 92       	push	r0
    137e:	e8 94       	clt
    1380:	2b e3       	ldi	r18, 0x3B	; 59
    1382:	3a ea       	ldi	r19, 0xAA	; 170
    1384:	48 eb       	ldi	r20, 0xB8	; 184
    1386:	5f e7       	ldi	r21, 0x7F	; 127
    1388:	0e 94 a2 0b 	call	0x1744	; 0x1744 <__mulsf3_pse>
    138c:	0f 92       	push	r0
    138e:	0f 92       	push	r0
    1390:	0f 92       	push	r0
    1392:	4d b7       	in	r20, 0x3d	; 61
    1394:	5e b7       	in	r21, 0x3e	; 62
    1396:	0f 92       	push	r0
    1398:	0e 94 58 0b 	call	0x16b0	; 0x16b0 <modf>
    139c:	ec e7       	ldi	r30, 0x7C	; 124
    139e:	f0 e0       	ldi	r31, 0x00	; 0
    13a0:	0e 94 a2 0a 	call	0x1544	; 0x1544 <__fp_powser>
    13a4:	4f 91       	pop	r20
    13a6:	5f 91       	pop	r21
    13a8:	ef 91       	pop	r30
    13aa:	ff 91       	pop	r31
    13ac:	e5 95       	asr	r30
    13ae:	ee 1f       	adc	r30, r30
    13b0:	ff 1f       	adc	r31, r31
    13b2:	49 f0       	breq	.+18     	; 0x13c6 <exp+0x56>
    13b4:	fe 57       	subi	r31, 0x7E	; 126
    13b6:	e0 68       	ori	r30, 0x80	; 128
    13b8:	44 27       	eor	r20, r20
    13ba:	ee 0f       	add	r30, r30
    13bc:	44 1f       	adc	r20, r20
    13be:	fa 95       	dec	r31
    13c0:	e1 f7       	brne	.-8      	; 0x13ba <exp+0x4a>
    13c2:	41 95       	neg	r20
    13c4:	55 0b       	sbc	r21, r21
    13c6:	0e 94 22 0b 	call	0x1644	; 0x1644 <ldexp>
    13ca:	0f 90       	pop	r0
    13cc:	07 fe       	sbrs	r0, 7
    13ce:	0c 94 16 0b 	jmp	0x162c	; 0x162c <inverse>
    13d2:	08 95       	ret

000013d4 <__fixunssfsi>:
    13d4:	0e 94 f0 0a 	call	0x15e0	; 0x15e0 <__fp_splitA>
    13d8:	88 f0       	brcs	.+34     	; 0x13fc <__fixunssfsi+0x28>
    13da:	9f 57       	subi	r25, 0x7F	; 127
    13dc:	98 f0       	brcs	.+38     	; 0x1404 <__fixunssfsi+0x30>
    13de:	b9 2f       	mov	r27, r25
    13e0:	99 27       	eor	r25, r25
    13e2:	b7 51       	subi	r27, 0x17	; 23
    13e4:	b0 f0       	brcs	.+44     	; 0x1412 <__fixunssfsi+0x3e>
    13e6:	e1 f0       	breq	.+56     	; 0x1420 <__fixunssfsi+0x4c>
    13e8:	66 0f       	add	r22, r22
    13ea:	77 1f       	adc	r23, r23
    13ec:	88 1f       	adc	r24, r24
    13ee:	99 1f       	adc	r25, r25
    13f0:	1a f0       	brmi	.+6      	; 0x13f8 <__fixunssfsi+0x24>
    13f2:	ba 95       	dec	r27
    13f4:	c9 f7       	brne	.-14     	; 0x13e8 <__fixunssfsi+0x14>
    13f6:	14 c0       	rjmp	.+40     	; 0x1420 <__fixunssfsi+0x4c>
    13f8:	b1 30       	cpi	r27, 0x01	; 1
    13fa:	91 f0       	breq	.+36     	; 0x1420 <__fixunssfsi+0x4c>
    13fc:	0e 94 0a 0b 	call	0x1614	; 0x1614 <__fp_zero>
    1400:	b1 e0       	ldi	r27, 0x01	; 1
    1402:	08 95       	ret
    1404:	0c 94 0a 0b 	jmp	0x1614	; 0x1614 <__fp_zero>
    1408:	67 2f       	mov	r22, r23
    140a:	78 2f       	mov	r23, r24
    140c:	88 27       	eor	r24, r24
    140e:	b8 5f       	subi	r27, 0xF8	; 248
    1410:	39 f0       	breq	.+14     	; 0x1420 <__fixunssfsi+0x4c>
    1412:	b9 3f       	cpi	r27, 0xF9	; 249
    1414:	cc f3       	brlt	.-14     	; 0x1408 <__fixunssfsi+0x34>
    1416:	86 95       	lsr	r24
    1418:	77 95       	ror	r23
    141a:	67 95       	ror	r22
    141c:	b3 95       	inc	r27
    141e:	d9 f7       	brne	.-10     	; 0x1416 <__fixunssfsi+0x42>
    1420:	3e f4       	brtc	.+14     	; 0x1430 <__fixunssfsi+0x5c>
    1422:	90 95       	com	r25
    1424:	80 95       	com	r24
    1426:	70 95       	com	r23
    1428:	61 95       	neg	r22
    142a:	7f 4f       	sbci	r23, 0xFF	; 255
    142c:	8f 4f       	sbci	r24, 0xFF	; 255
    142e:	9f 4f       	sbci	r25, 0xFF	; 255
    1430:	08 95       	ret

00001432 <__floatunsisf>:
    1432:	e8 94       	clt
    1434:	09 c0       	rjmp	.+18     	; 0x1448 <__floatsisf+0x12>

00001436 <__floatsisf>:
    1436:	97 fb       	bst	r25, 7
    1438:	3e f4       	brtc	.+14     	; 0x1448 <__floatsisf+0x12>
    143a:	90 95       	com	r25
    143c:	80 95       	com	r24
    143e:	70 95       	com	r23
    1440:	61 95       	neg	r22
    1442:	7f 4f       	sbci	r23, 0xFF	; 255
    1444:	8f 4f       	sbci	r24, 0xFF	; 255
    1446:	9f 4f       	sbci	r25, 0xFF	; 255
    1448:	99 23       	and	r25, r25
    144a:	a9 f0       	breq	.+42     	; 0x1476 <__floatsisf+0x40>
    144c:	f9 2f       	mov	r31, r25
    144e:	96 e9       	ldi	r25, 0x96	; 150
    1450:	bb 27       	eor	r27, r27
    1452:	93 95       	inc	r25
    1454:	f6 95       	lsr	r31
    1456:	87 95       	ror	r24
    1458:	77 95       	ror	r23
    145a:	67 95       	ror	r22
    145c:	b7 95       	ror	r27
    145e:	f1 11       	cpse	r31, r1
    1460:	f8 cf       	rjmp	.-16     	; 0x1452 <__floatsisf+0x1c>
    1462:	fa f4       	brpl	.+62     	; 0x14a2 <__floatsisf+0x6c>
    1464:	bb 0f       	add	r27, r27
    1466:	11 f4       	brne	.+4      	; 0x146c <__floatsisf+0x36>
    1468:	60 ff       	sbrs	r22, 0
    146a:	1b c0       	rjmp	.+54     	; 0x14a2 <__floatsisf+0x6c>
    146c:	6f 5f       	subi	r22, 0xFF	; 255
    146e:	7f 4f       	sbci	r23, 0xFF	; 255
    1470:	8f 4f       	sbci	r24, 0xFF	; 255
    1472:	9f 4f       	sbci	r25, 0xFF	; 255
    1474:	16 c0       	rjmp	.+44     	; 0x14a2 <__floatsisf+0x6c>
    1476:	88 23       	and	r24, r24
    1478:	11 f0       	breq	.+4      	; 0x147e <__floatsisf+0x48>
    147a:	96 e9       	ldi	r25, 0x96	; 150
    147c:	11 c0       	rjmp	.+34     	; 0x14a0 <__floatsisf+0x6a>
    147e:	77 23       	and	r23, r23
    1480:	21 f0       	breq	.+8      	; 0x148a <__floatsisf+0x54>
    1482:	9e e8       	ldi	r25, 0x8E	; 142
    1484:	87 2f       	mov	r24, r23
    1486:	76 2f       	mov	r23, r22
    1488:	05 c0       	rjmp	.+10     	; 0x1494 <__floatsisf+0x5e>
    148a:	66 23       	and	r22, r22
    148c:	71 f0       	breq	.+28     	; 0x14aa <__floatsisf+0x74>
    148e:	96 e8       	ldi	r25, 0x86	; 134
    1490:	86 2f       	mov	r24, r22
    1492:	70 e0       	ldi	r23, 0x00	; 0
    1494:	60 e0       	ldi	r22, 0x00	; 0
    1496:	2a f0       	brmi	.+10     	; 0x14a2 <__floatsisf+0x6c>
    1498:	9a 95       	dec	r25
    149a:	66 0f       	add	r22, r22
    149c:	77 1f       	adc	r23, r23
    149e:	88 1f       	adc	r24, r24
    14a0:	da f7       	brpl	.-10     	; 0x1498 <__floatsisf+0x62>
    14a2:	88 0f       	add	r24, r24
    14a4:	96 95       	lsr	r25
    14a6:	87 95       	ror	r24
    14a8:	97 f9       	bld	r25, 7
    14aa:	08 95       	ret

000014ac <fmin>:
    14ac:	99 0f       	add	r25, r25
    14ae:	bb 0b       	sbc	r27, r27
    14b0:	55 0f       	add	r21, r21
    14b2:	aa 0b       	sbc	r26, r26
    14b4:	e0 e8       	ldi	r30, 0x80	; 128
    14b6:	fe ef       	ldi	r31, 0xFE	; 254
    14b8:	16 16       	cp	r1, r22
    14ba:	17 06       	cpc	r1, r23
    14bc:	e8 07       	cpc	r30, r24
    14be:	f9 07       	cpc	r31, r25
    14c0:	70 f0       	brcs	.+28     	; 0x14de <fmin+0x32>
    14c2:	12 16       	cp	r1, r18
    14c4:	13 06       	cpc	r1, r19
    14c6:	e4 07       	cpc	r30, r20
    14c8:	f5 07       	cpc	r31, r21
    14ca:	60 f0       	brcs	.+24     	; 0x14e4 <fmin+0x38>
    14cc:	ba 17       	cp	r27, r26
    14ce:	54 f0       	brlt	.+20     	; 0x14e4 <fmin+0x38>
    14d0:	31 f4       	brne	.+12     	; 0x14de <fmin+0x32>
    14d2:	26 17       	cp	r18, r22
    14d4:	37 07       	cpc	r19, r23
    14d6:	48 07       	cpc	r20, r24
    14d8:	59 07       	cpc	r21, r25
    14da:	a7 95       	ror	r26
    14dc:	1b f4       	brvc	.+6      	; 0x14e4 <fmin+0x38>
    14de:	b9 01       	movw	r22, r18
    14e0:	ca 01       	movw	r24, r20
    14e2:	ba 2f       	mov	r27, r26
    14e4:	b6 95       	lsr	r27
    14e6:	97 95       	ror	r25
    14e8:	08 95       	ret

000014ea <__fp_cmp>:
    14ea:	99 0f       	add	r25, r25
    14ec:	00 08       	sbc	r0, r0
    14ee:	55 0f       	add	r21, r21
    14f0:	aa 0b       	sbc	r26, r26
    14f2:	e0 e8       	ldi	r30, 0x80	; 128
    14f4:	fe ef       	ldi	r31, 0xFE	; 254
    14f6:	16 16       	cp	r1, r22
    14f8:	17 06       	cpc	r1, r23
    14fa:	e8 07       	cpc	r30, r24
    14fc:	f9 07       	cpc	r31, r25
    14fe:	c0 f0       	brcs	.+48     	; 0x1530 <__fp_cmp+0x46>
    1500:	12 16       	cp	r1, r18
    1502:	13 06       	cpc	r1, r19
    1504:	e4 07       	cpc	r30, r20
    1506:	f5 07       	cpc	r31, r21
    1508:	98 f0       	brcs	.+38     	; 0x1530 <__fp_cmp+0x46>
    150a:	62 1b       	sub	r22, r18
    150c:	73 0b       	sbc	r23, r19
    150e:	84 0b       	sbc	r24, r20
    1510:	95 0b       	sbc	r25, r21
    1512:	39 f4       	brne	.+14     	; 0x1522 <__fp_cmp+0x38>
    1514:	0a 26       	eor	r0, r26
    1516:	61 f0       	breq	.+24     	; 0x1530 <__fp_cmp+0x46>
    1518:	23 2b       	or	r18, r19
    151a:	24 2b       	or	r18, r20
    151c:	25 2b       	or	r18, r21
    151e:	21 f4       	brne	.+8      	; 0x1528 <__fp_cmp+0x3e>
    1520:	08 95       	ret
    1522:	0a 26       	eor	r0, r26
    1524:	09 f4       	brne	.+2      	; 0x1528 <__fp_cmp+0x3e>
    1526:	a1 40       	sbci	r26, 0x01	; 1
    1528:	a6 95       	lsr	r26
    152a:	8f ef       	ldi	r24, 0xFF	; 255
    152c:	81 1d       	adc	r24, r1
    152e:	81 1d       	adc	r24, r1
    1530:	08 95       	ret

00001532 <__fp_inf>:
    1532:	97 f9       	bld	r25, 7
    1534:	9f 67       	ori	r25, 0x7F	; 127
    1536:	80 e8       	ldi	r24, 0x80	; 128
    1538:	70 e0       	ldi	r23, 0x00	; 0
    153a:	60 e0       	ldi	r22, 0x00	; 0
    153c:	08 95       	ret

0000153e <__fp_nan>:
    153e:	9f ef       	ldi	r25, 0xFF	; 255
    1540:	80 ec       	ldi	r24, 0xC0	; 192
    1542:	08 95       	ret

00001544 <__fp_powser>:
    1544:	df 93       	push	r29
    1546:	cf 93       	push	r28
    1548:	1f 93       	push	r17
    154a:	0f 93       	push	r16
    154c:	ff 92       	push	r15
    154e:	ef 92       	push	r14
    1550:	df 92       	push	r13
    1552:	7b 01       	movw	r14, r22
    1554:	8c 01       	movw	r16, r24
    1556:	68 94       	set
    1558:	06 c0       	rjmp	.+12     	; 0x1566 <__fp_powser+0x22>
    155a:	da 2e       	mov	r13, r26
    155c:	ef 01       	movw	r28, r30
    155e:	0e 94 9f 0b 	call	0x173e	; 0x173e <__mulsf3x>
    1562:	fe 01       	movw	r30, r28
    1564:	e8 94       	clt
    1566:	a5 91       	lpm	r26, Z+
    1568:	25 91       	lpm	r18, Z+
    156a:	35 91       	lpm	r19, Z+
    156c:	45 91       	lpm	r20, Z+
    156e:	55 91       	lpm	r21, Z+
    1570:	a6 f3       	brts	.-24     	; 0x155a <__fp_powser+0x16>
    1572:	ef 01       	movw	r28, r30
    1574:	0e 94 e4 08 	call	0x11c8	; 0x11c8 <__addsf3x>
    1578:	fe 01       	movw	r30, r28
    157a:	97 01       	movw	r18, r14
    157c:	a8 01       	movw	r20, r16
    157e:	da 94       	dec	r13
    1580:	69 f7       	brne	.-38     	; 0x155c <__fp_powser+0x18>
    1582:	df 90       	pop	r13
    1584:	ef 90       	pop	r14
    1586:	ff 90       	pop	r15
    1588:	0f 91       	pop	r16
    158a:	1f 91       	pop	r17
    158c:	cf 91       	pop	r28
    158e:	df 91       	pop	r29
    1590:	08 95       	ret

00001592 <__fp_pscA>:
    1592:	00 24       	eor	r0, r0
    1594:	0a 94       	dec	r0
    1596:	16 16       	cp	r1, r22
    1598:	17 06       	cpc	r1, r23
    159a:	18 06       	cpc	r1, r24
    159c:	09 06       	cpc	r0, r25
    159e:	08 95       	ret

000015a0 <__fp_pscB>:
    15a0:	00 24       	eor	r0, r0
    15a2:	0a 94       	dec	r0
    15a4:	12 16       	cp	r1, r18
    15a6:	13 06       	cpc	r1, r19
    15a8:	14 06       	cpc	r1, r20
    15aa:	05 06       	cpc	r0, r21
    15ac:	08 95       	ret

000015ae <__fp_round>:
    15ae:	09 2e       	mov	r0, r25
    15b0:	03 94       	inc	r0
    15b2:	00 0c       	add	r0, r0
    15b4:	11 f4       	brne	.+4      	; 0x15ba <__fp_round+0xc>
    15b6:	88 23       	and	r24, r24
    15b8:	52 f0       	brmi	.+20     	; 0x15ce <__fp_round+0x20>
    15ba:	bb 0f       	add	r27, r27
    15bc:	40 f4       	brcc	.+16     	; 0x15ce <__fp_round+0x20>
    15be:	bf 2b       	or	r27, r31
    15c0:	11 f4       	brne	.+4      	; 0x15c6 <__fp_round+0x18>
    15c2:	60 ff       	sbrs	r22, 0
    15c4:	04 c0       	rjmp	.+8      	; 0x15ce <__fp_round+0x20>
    15c6:	6f 5f       	subi	r22, 0xFF	; 255
    15c8:	7f 4f       	sbci	r23, 0xFF	; 255
    15ca:	8f 4f       	sbci	r24, 0xFF	; 255
    15cc:	9f 4f       	sbci	r25, 0xFF	; 255
    15ce:	08 95       	ret

000015d0 <__fp_split3>:
    15d0:	57 fd       	sbrc	r21, 7
    15d2:	90 58       	subi	r25, 0x80	; 128
    15d4:	44 0f       	add	r20, r20
    15d6:	55 1f       	adc	r21, r21
    15d8:	59 f0       	breq	.+22     	; 0x15f0 <__fp_splitA+0x10>
    15da:	5f 3f       	cpi	r21, 0xFF	; 255
    15dc:	71 f0       	breq	.+28     	; 0x15fa <__fp_splitA+0x1a>
    15de:	47 95       	ror	r20

000015e0 <__fp_splitA>:
    15e0:	88 0f       	add	r24, r24
    15e2:	97 fb       	bst	r25, 7
    15e4:	99 1f       	adc	r25, r25
    15e6:	61 f0       	breq	.+24     	; 0x1600 <__fp_splitA+0x20>
    15e8:	9f 3f       	cpi	r25, 0xFF	; 255
    15ea:	79 f0       	breq	.+30     	; 0x160a <__fp_splitA+0x2a>
    15ec:	87 95       	ror	r24
    15ee:	08 95       	ret
    15f0:	12 16       	cp	r1, r18
    15f2:	13 06       	cpc	r1, r19
    15f4:	14 06       	cpc	r1, r20
    15f6:	55 1f       	adc	r21, r21
    15f8:	f2 cf       	rjmp	.-28     	; 0x15de <__fp_split3+0xe>
    15fa:	46 95       	lsr	r20
    15fc:	f1 df       	rcall	.-30     	; 0x15e0 <__fp_splitA>
    15fe:	08 c0       	rjmp	.+16     	; 0x1610 <__fp_splitA+0x30>
    1600:	16 16       	cp	r1, r22
    1602:	17 06       	cpc	r1, r23
    1604:	18 06       	cpc	r1, r24
    1606:	99 1f       	adc	r25, r25
    1608:	f1 cf       	rjmp	.-30     	; 0x15ec <__fp_splitA+0xc>
    160a:	86 95       	lsr	r24
    160c:	71 05       	cpc	r23, r1
    160e:	61 05       	cpc	r22, r1
    1610:	08 94       	sec
    1612:	08 95       	ret

00001614 <__fp_zero>:
    1614:	e8 94       	clt

00001616 <__fp_szero>:
    1616:	bb 27       	eor	r27, r27
    1618:	66 27       	eor	r22, r22
    161a:	77 27       	eor	r23, r23
    161c:	cb 01       	movw	r24, r22
    161e:	97 f9       	bld	r25, 7
    1620:	08 95       	ret

00001622 <__gesf2>:
    1622:	0e 94 75 0a 	call	0x14ea	; 0x14ea <__fp_cmp>
    1626:	08 f4       	brcc	.+2      	; 0x162a <__gesf2+0x8>
    1628:	8f ef       	ldi	r24, 0xFF	; 255
    162a:	08 95       	ret

0000162c <inverse>:
    162c:	9b 01       	movw	r18, r22
    162e:	ac 01       	movw	r20, r24
    1630:	60 e0       	ldi	r22, 0x00	; 0
    1632:	70 e0       	ldi	r23, 0x00	; 0
    1634:	80 e8       	ldi	r24, 0x80	; 128
    1636:	9f e3       	ldi	r25, 0x3F	; 63
    1638:	0c 94 3e 09 	jmp	0x127c	; 0x127c <__divsf3>
    163c:	0c 94 99 0a 	jmp	0x1532	; 0x1532 <__fp_inf>
    1640:	0c 94 01 0c 	jmp	0x1802	; 0x1802 <__fp_mpack>

00001644 <ldexp>:
    1644:	0e 94 f0 0a 	call	0x15e0	; 0x15e0 <__fp_splitA>
    1648:	d8 f3       	brcs	.-10     	; 0x1640 <inverse+0x14>
    164a:	99 23       	and	r25, r25
    164c:	c9 f3       	breq	.-14     	; 0x1640 <inverse+0x14>
    164e:	94 0f       	add	r25, r20
    1650:	51 1d       	adc	r21, r1
    1652:	a3 f3       	brvs	.-24     	; 0x163c <inverse+0x10>
    1654:	91 50       	subi	r25, 0x01	; 1
    1656:	50 40       	sbci	r21, 0x00	; 0
    1658:	94 f0       	brlt	.+36     	; 0x167e <ldexp+0x3a>
    165a:	59 f0       	breq	.+22     	; 0x1672 <ldexp+0x2e>
    165c:	88 23       	and	r24, r24
    165e:	32 f0       	brmi	.+12     	; 0x166c <ldexp+0x28>
    1660:	66 0f       	add	r22, r22
    1662:	77 1f       	adc	r23, r23
    1664:	88 1f       	adc	r24, r24
    1666:	91 50       	subi	r25, 0x01	; 1
    1668:	50 40       	sbci	r21, 0x00	; 0
    166a:	c1 f7       	brne	.-16     	; 0x165c <ldexp+0x18>
    166c:	9e 3f       	cpi	r25, 0xFE	; 254
    166e:	51 05       	cpc	r21, r1
    1670:	2c f7       	brge	.-54     	; 0x163c <inverse+0x10>
    1672:	88 0f       	add	r24, r24
    1674:	91 1d       	adc	r25, r1
    1676:	96 95       	lsr	r25
    1678:	87 95       	ror	r24
    167a:	97 f9       	bld	r25, 7
    167c:	08 95       	ret
    167e:	5f 3f       	cpi	r21, 0xFF	; 255
    1680:	ac f0       	brlt	.+42     	; 0x16ac <ldexp+0x68>
    1682:	98 3e       	cpi	r25, 0xE8	; 232
    1684:	9c f0       	brlt	.+38     	; 0x16ac <ldexp+0x68>
    1686:	bb 27       	eor	r27, r27
    1688:	86 95       	lsr	r24
    168a:	77 95       	ror	r23
    168c:	67 95       	ror	r22
    168e:	b7 95       	ror	r27
    1690:	08 f4       	brcc	.+2      	; 0x1694 <ldexp+0x50>
    1692:	b1 60       	ori	r27, 0x01	; 1
    1694:	93 95       	inc	r25
    1696:	c1 f7       	brne	.-16     	; 0x1688 <ldexp+0x44>
    1698:	bb 0f       	add	r27, r27
    169a:	58 f7       	brcc	.-42     	; 0x1672 <ldexp+0x2e>
    169c:	11 f4       	brne	.+4      	; 0x16a2 <ldexp+0x5e>
    169e:	60 ff       	sbrs	r22, 0
    16a0:	e8 cf       	rjmp	.-48     	; 0x1672 <ldexp+0x2e>
    16a2:	6f 5f       	subi	r22, 0xFF	; 255
    16a4:	7f 4f       	sbci	r23, 0xFF	; 255
    16a6:	8f 4f       	sbci	r24, 0xFF	; 255
    16a8:	9f 4f       	sbci	r25, 0xFF	; 255
    16aa:	e3 cf       	rjmp	.-58     	; 0x1672 <ldexp+0x2e>
    16ac:	0c 94 0b 0b 	jmp	0x1616	; 0x1616 <__fp_szero>

000016b0 <modf>:
    16b0:	fa 01       	movw	r30, r20
    16b2:	dc 01       	movw	r26, r24
    16b4:	aa 0f       	add	r26, r26
    16b6:	bb 1f       	adc	r27, r27
    16b8:	9b 01       	movw	r18, r22
    16ba:	ac 01       	movw	r20, r24
    16bc:	bf 57       	subi	r27, 0x7F	; 127
    16be:	28 f4       	brcc	.+10     	; 0x16ca <modf+0x1a>
    16c0:	22 27       	eor	r18, r18
    16c2:	33 27       	eor	r19, r19
    16c4:	44 27       	eor	r20, r20
    16c6:	50 78       	andi	r21, 0x80	; 128
    16c8:	20 c0       	rjmp	.+64     	; 0x170a <modf+0x5a>
    16ca:	b7 51       	subi	r27, 0x17	; 23
    16cc:	90 f4       	brcc	.+36     	; 0x16f2 <modf+0x42>
    16ce:	ab 2f       	mov	r26, r27
    16d0:	00 24       	eor	r0, r0
    16d2:	46 95       	lsr	r20
    16d4:	37 95       	ror	r19
    16d6:	27 95       	ror	r18
    16d8:	01 1c       	adc	r0, r1
    16da:	a3 95       	inc	r26
    16dc:	d2 f3       	brmi	.-12     	; 0x16d2 <modf+0x22>
    16de:	00 20       	and	r0, r0
    16e0:	71 f0       	breq	.+28     	; 0x16fe <modf+0x4e>
    16e2:	22 0f       	add	r18, r18
    16e4:	33 1f       	adc	r19, r19
    16e6:	44 1f       	adc	r20, r20
    16e8:	b3 95       	inc	r27
    16ea:	da f3       	brmi	.-10     	; 0x16e2 <modf+0x32>
    16ec:	0e d0       	rcall	.+28     	; 0x170a <modf+0x5a>
    16ee:	0c 94 cc 08 	jmp	0x1198	; 0x1198 <__subsf3>
    16f2:	61 30       	cpi	r22, 0x01	; 1
    16f4:	71 05       	cpc	r23, r1
    16f6:	a0 e8       	ldi	r26, 0x80	; 128
    16f8:	8a 07       	cpc	r24, r26
    16fa:	b9 46       	sbci	r27, 0x69	; 105
    16fc:	30 f4       	brcc	.+12     	; 0x170a <modf+0x5a>
    16fe:	9b 01       	movw	r18, r22
    1700:	ac 01       	movw	r20, r24
    1702:	66 27       	eor	r22, r22
    1704:	77 27       	eor	r23, r23
    1706:	88 27       	eor	r24, r24
    1708:	90 78       	andi	r25, 0x80	; 128
    170a:	30 96       	adiw	r30, 0x00	; 0
    170c:	21 f0       	breq	.+8      	; 0x1716 <modf+0x66>
    170e:	20 83       	st	Z, r18
    1710:	31 83       	std	Z+1, r19	; 0x01
    1712:	42 83       	std	Z+2, r20	; 0x02
    1714:	53 83       	std	Z+3, r21	; 0x03
    1716:	08 95       	ret

00001718 <__mulsf3>:
    1718:	0e 94 9f 0b 	call	0x173e	; 0x173e <__mulsf3x>
    171c:	0c 94 d7 0a 	jmp	0x15ae	; 0x15ae <__fp_round>
    1720:	0e 94 c9 0a 	call	0x1592	; 0x1592 <__fp_pscA>
    1724:	38 f0       	brcs	.+14     	; 0x1734 <__mulsf3+0x1c>
    1726:	0e 94 d0 0a 	call	0x15a0	; 0x15a0 <__fp_pscB>
    172a:	20 f0       	brcs	.+8      	; 0x1734 <__mulsf3+0x1c>
    172c:	95 23       	and	r25, r21
    172e:	11 f0       	breq	.+4      	; 0x1734 <__mulsf3+0x1c>
    1730:	0c 94 99 0a 	jmp	0x1532	; 0x1532 <__fp_inf>
    1734:	0c 94 9f 0a 	jmp	0x153e	; 0x153e <__fp_nan>
    1738:	11 24       	eor	r1, r1
    173a:	0c 94 0b 0b 	jmp	0x1616	; 0x1616 <__fp_szero>

0000173e <__mulsf3x>:
    173e:	0e 94 e8 0a 	call	0x15d0	; 0x15d0 <__fp_split3>
    1742:	70 f3       	brcs	.-36     	; 0x1720 <__mulsf3+0x8>

00001744 <__mulsf3_pse>:
    1744:	95 9f       	mul	r25, r21
    1746:	c1 f3       	breq	.-16     	; 0x1738 <__mulsf3+0x20>
    1748:	95 0f       	add	r25, r21
    174a:	50 e0       	ldi	r21, 0x00	; 0
    174c:	55 1f       	adc	r21, r21
    174e:	62 9f       	mul	r22, r18
    1750:	f0 01       	movw	r30, r0
    1752:	72 9f       	mul	r23, r18
    1754:	bb 27       	eor	r27, r27
    1756:	f0 0d       	add	r31, r0
    1758:	b1 1d       	adc	r27, r1
    175a:	63 9f       	mul	r22, r19
    175c:	aa 27       	eor	r26, r26
    175e:	f0 0d       	add	r31, r0
    1760:	b1 1d       	adc	r27, r1
    1762:	aa 1f       	adc	r26, r26
    1764:	64 9f       	mul	r22, r20
    1766:	66 27       	eor	r22, r22
    1768:	b0 0d       	add	r27, r0
    176a:	a1 1d       	adc	r26, r1
    176c:	66 1f       	adc	r22, r22
    176e:	82 9f       	mul	r24, r18
    1770:	22 27       	eor	r18, r18
    1772:	b0 0d       	add	r27, r0
    1774:	a1 1d       	adc	r26, r1
    1776:	62 1f       	adc	r22, r18
    1778:	73 9f       	mul	r23, r19
    177a:	b0 0d       	add	r27, r0
    177c:	a1 1d       	adc	r26, r1
    177e:	62 1f       	adc	r22, r18
    1780:	83 9f       	mul	r24, r19
    1782:	a0 0d       	add	r26, r0
    1784:	61 1d       	adc	r22, r1
    1786:	22 1f       	adc	r18, r18
    1788:	74 9f       	mul	r23, r20
    178a:	33 27       	eor	r19, r19
    178c:	a0 0d       	add	r26, r0
    178e:	61 1d       	adc	r22, r1
    1790:	23 1f       	adc	r18, r19
    1792:	84 9f       	mul	r24, r20
    1794:	60 0d       	add	r22, r0
    1796:	21 1d       	adc	r18, r1
    1798:	82 2f       	mov	r24, r18
    179a:	76 2f       	mov	r23, r22
    179c:	6a 2f       	mov	r22, r26
    179e:	11 24       	eor	r1, r1
    17a0:	9f 57       	subi	r25, 0x7F	; 127
    17a2:	50 40       	sbci	r21, 0x00	; 0
    17a4:	9a f0       	brmi	.+38     	; 0x17cc <__mulsf3_pse+0x88>
    17a6:	f1 f0       	breq	.+60     	; 0x17e4 <__mulsf3_pse+0xa0>
    17a8:	88 23       	and	r24, r24
    17aa:	4a f0       	brmi	.+18     	; 0x17be <__mulsf3_pse+0x7a>
    17ac:	ee 0f       	add	r30, r30
    17ae:	ff 1f       	adc	r31, r31
    17b0:	bb 1f       	adc	r27, r27
    17b2:	66 1f       	adc	r22, r22
    17b4:	77 1f       	adc	r23, r23
    17b6:	88 1f       	adc	r24, r24
    17b8:	91 50       	subi	r25, 0x01	; 1
    17ba:	50 40       	sbci	r21, 0x00	; 0
    17bc:	a9 f7       	brne	.-22     	; 0x17a8 <__mulsf3_pse+0x64>
    17be:	9e 3f       	cpi	r25, 0xFE	; 254
    17c0:	51 05       	cpc	r21, r1
    17c2:	80 f0       	brcs	.+32     	; 0x17e4 <__mulsf3_pse+0xa0>
    17c4:	0c 94 99 0a 	jmp	0x1532	; 0x1532 <__fp_inf>
    17c8:	0c 94 0b 0b 	jmp	0x1616	; 0x1616 <__fp_szero>
    17cc:	5f 3f       	cpi	r21, 0xFF	; 255
    17ce:	e4 f3       	brlt	.-8      	; 0x17c8 <__mulsf3_pse+0x84>
    17d0:	98 3e       	cpi	r25, 0xE8	; 232
    17d2:	d4 f3       	brlt	.-12     	; 0x17c8 <__mulsf3_pse+0x84>
    17d4:	86 95       	lsr	r24
    17d6:	77 95       	ror	r23
    17d8:	67 95       	ror	r22
    17da:	b7 95       	ror	r27
    17dc:	f7 95       	ror	r31
    17de:	e7 95       	ror	r30
    17e0:	9f 5f       	subi	r25, 0xFF	; 255
    17e2:	c1 f7       	brne	.-16     	; 0x17d4 <__mulsf3_pse+0x90>
    17e4:	fe 2b       	or	r31, r30
    17e6:	88 0f       	add	r24, r24
    17e8:	91 1d       	adc	r25, r1
    17ea:	96 95       	lsr	r25
    17ec:	87 95       	ror	r24
    17ee:	97 f9       	bld	r25, 7
    17f0:	08 95       	ret

000017f2 <sin>:
    17f2:	9f 93       	push	r25
    17f4:	0e 94 11 0c 	call	0x1822	; 0x1822 <__fp_rempio2>
    17f8:	0f 90       	pop	r0
    17fa:	07 fc       	sbrc	r0, 7
    17fc:	ee 5f       	subi	r30, 0xFE	; 254
    17fe:	0c 94 3a 0c 	jmp	0x1874	; 0x1874 <__fp_sinus>

00001802 <__fp_mpack>:
    1802:	9f 3f       	cpi	r25, 0xFF	; 255
    1804:	31 f0       	breq	.+12     	; 0x1812 <__fp_mpack_finite+0xc>

00001806 <__fp_mpack_finite>:
    1806:	91 50       	subi	r25, 0x01	; 1
    1808:	20 f4       	brcc	.+8      	; 0x1812 <__fp_mpack_finite+0xc>
    180a:	87 95       	ror	r24
    180c:	77 95       	ror	r23
    180e:	67 95       	ror	r22
    1810:	b7 95       	ror	r27
    1812:	88 0f       	add	r24, r24
    1814:	91 1d       	adc	r25, r1
    1816:	96 95       	lsr	r25
    1818:	87 95       	ror	r24
    181a:	97 f9       	bld	r25, 7
    181c:	08 95       	ret
    181e:	0c 94 9f 0a 	jmp	0x153e	; 0x153e <__fp_nan>

00001822 <__fp_rempio2>:
    1822:	0e 94 f0 0a 	call	0x15e0	; 0x15e0 <__fp_splitA>
    1826:	d8 f3       	brcs	.-10     	; 0x181e <__fp_mpack_finite+0x18>
    1828:	e8 94       	clt
    182a:	e0 e0       	ldi	r30, 0x00	; 0
    182c:	bb 27       	eor	r27, r27
    182e:	9f 57       	subi	r25, 0x7F	; 127
    1830:	f0 f0       	brcs	.+60     	; 0x186e <__fp_rempio2+0x4c>
    1832:	2a ed       	ldi	r18, 0xDA	; 218
    1834:	3f e0       	ldi	r19, 0x0F	; 15
    1836:	49 ec       	ldi	r20, 0xC9	; 201
    1838:	06 c0       	rjmp	.+12     	; 0x1846 <__fp_rempio2+0x24>
    183a:	ee 0f       	add	r30, r30
    183c:	bb 0f       	add	r27, r27
    183e:	66 1f       	adc	r22, r22
    1840:	77 1f       	adc	r23, r23
    1842:	88 1f       	adc	r24, r24
    1844:	28 f0       	brcs	.+10     	; 0x1850 <__fp_rempio2+0x2e>
    1846:	b2 3a       	cpi	r27, 0xA2	; 162
    1848:	62 07       	cpc	r22, r18
    184a:	73 07       	cpc	r23, r19
    184c:	84 07       	cpc	r24, r20
    184e:	28 f0       	brcs	.+10     	; 0x185a <__fp_rempio2+0x38>
    1850:	b2 5a       	subi	r27, 0xA2	; 162
    1852:	62 0b       	sbc	r22, r18
    1854:	73 0b       	sbc	r23, r19
    1856:	84 0b       	sbc	r24, r20
    1858:	e3 95       	inc	r30
    185a:	9a 95       	dec	r25
    185c:	72 f7       	brpl	.-36     	; 0x183a <__fp_rempio2+0x18>
    185e:	80 38       	cpi	r24, 0x80	; 128
    1860:	30 f4       	brcc	.+12     	; 0x186e <__fp_rempio2+0x4c>
    1862:	9a 95       	dec	r25
    1864:	bb 0f       	add	r27, r27
    1866:	66 1f       	adc	r22, r22
    1868:	77 1f       	adc	r23, r23
    186a:	88 1f       	adc	r24, r24
    186c:	d2 f7       	brpl	.-12     	; 0x1862 <__fp_rempio2+0x40>
    186e:	90 48       	sbci	r25, 0x80	; 128
    1870:	0c 94 03 0c 	jmp	0x1806	; 0x1806 <__fp_mpack_finite>

00001874 <__fp_sinus>:
    1874:	ef 93       	push	r30
    1876:	e0 ff       	sbrs	r30, 0
    1878:	07 c0       	rjmp	.+14     	; 0x1888 <__fp_sinus+0x14>
    187a:	a2 ea       	ldi	r26, 0xA2	; 162
    187c:	2a ed       	ldi	r18, 0xDA	; 218
    187e:	3f e0       	ldi	r19, 0x0F	; 15
    1880:	49 ec       	ldi	r20, 0xC9	; 201
    1882:	5f eb       	ldi	r21, 0xBF	; 191
    1884:	0e 94 e4 08 	call	0x11c8	; 0x11c8 <__addsf3x>
    1888:	0e 94 d7 0a 	call	0x15ae	; 0x15ae <__fp_round>
    188c:	0f 90       	pop	r0
    188e:	03 94       	inc	r0
    1890:	01 fc       	sbrc	r0, 1
    1892:	90 58       	subi	r25, 0x80	; 128
    1894:	e4 ea       	ldi	r30, 0xA4	; 164
    1896:	f0 e0       	ldi	r31, 0x00	; 0
    1898:	0c 94 4e 0c 	jmp	0x189c	; 0x189c <__fp_powsodd>

0000189c <__fp_powsodd>:
    189c:	9f 93       	push	r25
    189e:	8f 93       	push	r24
    18a0:	7f 93       	push	r23
    18a2:	6f 93       	push	r22
    18a4:	ff 93       	push	r31
    18a6:	ef 93       	push	r30
    18a8:	9b 01       	movw	r18, r22
    18aa:	ac 01       	movw	r20, r24
    18ac:	0e 94 8c 0b 	call	0x1718	; 0x1718 <__mulsf3>
    18b0:	ef 91       	pop	r30
    18b2:	ff 91       	pop	r31
    18b4:	0e 94 a2 0a 	call	0x1544	; 0x1544 <__fp_powser>
    18b8:	2f 91       	pop	r18
    18ba:	3f 91       	pop	r19
    18bc:	4f 91       	pop	r20
    18be:	5f 91       	pop	r21
    18c0:	0c 94 8c 0b 	jmp	0x1718	; 0x1718 <__mulsf3>

000018c4 <__udivmodsi4>:
    18c4:	a1 e2       	ldi	r26, 0x21	; 33
    18c6:	1a 2e       	mov	r1, r26
    18c8:	aa 1b       	sub	r26, r26
    18ca:	bb 1b       	sub	r27, r27
    18cc:	fd 01       	movw	r30, r26
    18ce:	0d c0       	rjmp	.+26     	; 0x18ea <__udivmodsi4_ep>

000018d0 <__udivmodsi4_loop>:
    18d0:	aa 1f       	adc	r26, r26
    18d2:	bb 1f       	adc	r27, r27
    18d4:	ee 1f       	adc	r30, r30
    18d6:	ff 1f       	adc	r31, r31
    18d8:	a2 17       	cp	r26, r18
    18da:	b3 07       	cpc	r27, r19
    18dc:	e4 07       	cpc	r30, r20
    18de:	f5 07       	cpc	r31, r21
    18e0:	20 f0       	brcs	.+8      	; 0x18ea <__udivmodsi4_ep>
    18e2:	a2 1b       	sub	r26, r18
    18e4:	b3 0b       	sbc	r27, r19
    18e6:	e4 0b       	sbc	r30, r20
    18e8:	f5 0b       	sbc	r31, r21

000018ea <__udivmodsi4_ep>:
    18ea:	66 1f       	adc	r22, r22
    18ec:	77 1f       	adc	r23, r23
    18ee:	88 1f       	adc	r24, r24
    18f0:	99 1f       	adc	r25, r25
    18f2:	1a 94       	dec	r1
    18f4:	69 f7       	brne	.-38     	; 0x18d0 <__udivmodsi4_loop>
    18f6:	60 95       	com	r22
    18f8:	70 95       	com	r23
    18fa:	80 95       	com	r24
    18fc:	90 95       	com	r25
    18fe:	9b 01       	movw	r18, r22
    1900:	ac 01       	movw	r20, r24
    1902:	bd 01       	movw	r22, r26
    1904:	cf 01       	movw	r24, r30
    1906:	08 95       	ret

00001908 <dtostrf>:
    1908:	ef 92       	push	r14
    190a:	0f 93       	push	r16
    190c:	1f 93       	push	r17
    190e:	cf 93       	push	r28
    1910:	df 93       	push	r29
    1912:	e8 01       	movw	r28, r16
    1914:	47 fd       	sbrc	r20, 7
    1916:	02 c0       	rjmp	.+4      	; 0x191c <dtostrf+0x14>
    1918:	34 e0       	ldi	r19, 0x04	; 4
    191a:	01 c0       	rjmp	.+2      	; 0x191e <dtostrf+0x16>
    191c:	34 e1       	ldi	r19, 0x14	; 20
    191e:	04 2e       	mov	r0, r20
    1920:	00 0c       	add	r0, r0
    1922:	55 0b       	sbc	r21, r21
    1924:	57 ff       	sbrs	r21, 7
    1926:	03 c0       	rjmp	.+6      	; 0x192e <dtostrf+0x26>
    1928:	51 95       	neg	r21
    192a:	41 95       	neg	r20
    192c:	51 09       	sbc	r21, r1
    192e:	e3 2e       	mov	r14, r19
    1930:	02 2f       	mov	r16, r18
    1932:	24 2f       	mov	r18, r20
    1934:	ae 01       	movw	r20, r28
    1936:	0e 94 cb 0e 	call	0x1d96	; 0x1d96 <dtoa_prf>
    193a:	ce 01       	movw	r24, r28
    193c:	df 91       	pop	r29
    193e:	cf 91       	pop	r28
    1940:	1f 91       	pop	r17
    1942:	0f 91       	pop	r16
    1944:	ef 90       	pop	r14
    1946:	08 95       	ret

00001948 <printf>:
    1948:	a0 e0       	ldi	r26, 0x00	; 0
    194a:	b0 e0       	ldi	r27, 0x00	; 0
    194c:	ea ea       	ldi	r30, 0xAA	; 170
    194e:	fc e0       	ldi	r31, 0x0C	; 12
    1950:	0c 94 bd 11 	jmp	0x237a	; 0x237a <__prologue_saves__+0x20>
    1954:	ae 01       	movw	r20, r28
    1956:	4b 5f       	subi	r20, 0xFB	; 251
    1958:	5f 4f       	sbci	r21, 0xFF	; 255
    195a:	fa 01       	movw	r30, r20
    195c:	61 91       	ld	r22, Z+
    195e:	71 91       	ld	r23, Z+
    1960:	af 01       	movw	r20, r30
    1962:	80 91 67 38 	lds	r24, 0x3867	; 0x803867 <__iob+0x2>
    1966:	90 91 68 38 	lds	r25, 0x3868	; 0x803868 <__iob+0x3>
    196a:	0e 94 ea 0c 	call	0x19d4	; 0x19d4 <vfprintf>
    196e:	e2 e0       	ldi	r30, 0x02	; 2
    1970:	0c 94 d6 11 	jmp	0x23ac	; 0x23ac <__epilogue_restores__+0x20>

00001974 <puts>:
    1974:	0f 93       	push	r16
    1976:	1f 93       	push	r17
    1978:	cf 93       	push	r28
    197a:	df 93       	push	r29
    197c:	e0 91 67 38 	lds	r30, 0x3867	; 0x803867 <__iob+0x2>
    1980:	f0 91 68 38 	lds	r31, 0x3868	; 0x803868 <__iob+0x3>
    1984:	23 81       	ldd	r18, Z+3	; 0x03
    1986:	21 ff       	sbrs	r18, 1
    1988:	1b c0       	rjmp	.+54     	; 0x19c0 <puts+0x4c>
    198a:	8c 01       	movw	r16, r24
    198c:	d0 e0       	ldi	r29, 0x00	; 0
    198e:	c0 e0       	ldi	r28, 0x00	; 0
    1990:	f8 01       	movw	r30, r16
    1992:	81 91       	ld	r24, Z+
    1994:	8f 01       	movw	r16, r30
    1996:	60 91 67 38 	lds	r22, 0x3867	; 0x803867 <__iob+0x2>
    199a:	70 91 68 38 	lds	r23, 0x3868	; 0x803868 <__iob+0x3>
    199e:	db 01       	movw	r26, r22
    19a0:	18 96       	adiw	r26, 0x08	; 8
    19a2:	ed 91       	ld	r30, X+
    19a4:	fc 91       	ld	r31, X
    19a6:	19 97       	sbiw	r26, 0x09	; 9
    19a8:	88 23       	and	r24, r24
    19aa:	31 f0       	breq	.+12     	; 0x19b8 <puts+0x44>
    19ac:	09 95       	icall
    19ae:	89 2b       	or	r24, r25
    19b0:	79 f3       	breq	.-34     	; 0x1990 <puts+0x1c>
    19b2:	df ef       	ldi	r29, 0xFF	; 255
    19b4:	cf ef       	ldi	r28, 0xFF	; 255
    19b6:	ec cf       	rjmp	.-40     	; 0x1990 <puts+0x1c>
    19b8:	8a e0       	ldi	r24, 0x0A	; 10
    19ba:	09 95       	icall
    19bc:	89 2b       	or	r24, r25
    19be:	19 f0       	breq	.+6      	; 0x19c6 <puts+0x52>
    19c0:	8f ef       	ldi	r24, 0xFF	; 255
    19c2:	9f ef       	ldi	r25, 0xFF	; 255
    19c4:	02 c0       	rjmp	.+4      	; 0x19ca <puts+0x56>
    19c6:	8d 2f       	mov	r24, r29
    19c8:	9c 2f       	mov	r25, r28
    19ca:	df 91       	pop	r29
    19cc:	cf 91       	pop	r28
    19ce:	1f 91       	pop	r17
    19d0:	0f 91       	pop	r16
    19d2:	08 95       	ret

000019d4 <vfprintf>:
    19d4:	ab e0       	ldi	r26, 0x0B	; 11
    19d6:	b0 e0       	ldi	r27, 0x00	; 0
    19d8:	e0 ef       	ldi	r30, 0xF0	; 240
    19da:	fc e0       	ldi	r31, 0x0C	; 12
    19dc:	0c 94 ad 11 	jmp	0x235a	; 0x235a <__prologue_saves__>
    19e0:	6c 01       	movw	r12, r24
    19e2:	7b 01       	movw	r14, r22
    19e4:	8a 01       	movw	r16, r20
    19e6:	fc 01       	movw	r30, r24
    19e8:	16 82       	std	Z+6, r1	; 0x06
    19ea:	17 82       	std	Z+7, r1	; 0x07
    19ec:	83 81       	ldd	r24, Z+3	; 0x03
    19ee:	81 ff       	sbrs	r24, 1
    19f0:	cc c1       	rjmp	.+920    	; 0x1d8a <vfprintf+0x3b6>
    19f2:	ce 01       	movw	r24, r28
    19f4:	01 96       	adiw	r24, 0x01	; 1
    19f6:	3c 01       	movw	r6, r24
    19f8:	f6 01       	movw	r30, r12
    19fa:	93 81       	ldd	r25, Z+3	; 0x03
    19fc:	f7 01       	movw	r30, r14
    19fe:	93 fd       	sbrc	r25, 3
    1a00:	85 91       	lpm	r24, Z+
    1a02:	93 ff       	sbrs	r25, 3
    1a04:	81 91       	ld	r24, Z+
    1a06:	7f 01       	movw	r14, r30
    1a08:	88 23       	and	r24, r24
    1a0a:	09 f4       	brne	.+2      	; 0x1a0e <vfprintf+0x3a>
    1a0c:	ba c1       	rjmp	.+884    	; 0x1d82 <vfprintf+0x3ae>
    1a0e:	85 32       	cpi	r24, 0x25	; 37
    1a10:	39 f4       	brne	.+14     	; 0x1a20 <vfprintf+0x4c>
    1a12:	93 fd       	sbrc	r25, 3
    1a14:	85 91       	lpm	r24, Z+
    1a16:	93 ff       	sbrs	r25, 3
    1a18:	81 91       	ld	r24, Z+
    1a1a:	7f 01       	movw	r14, r30
    1a1c:	85 32       	cpi	r24, 0x25	; 37
    1a1e:	29 f4       	brne	.+10     	; 0x1a2a <vfprintf+0x56>
    1a20:	b6 01       	movw	r22, r12
    1a22:	90 e0       	ldi	r25, 0x00	; 0
    1a24:	0e 94 13 11 	call	0x2226	; 0x2226 <fputc>
    1a28:	e7 cf       	rjmp	.-50     	; 0x19f8 <vfprintf+0x24>
    1a2a:	91 2c       	mov	r9, r1
    1a2c:	21 2c       	mov	r2, r1
    1a2e:	31 2c       	mov	r3, r1
    1a30:	ff e1       	ldi	r31, 0x1F	; 31
    1a32:	f3 15       	cp	r31, r3
    1a34:	d8 f0       	brcs	.+54     	; 0x1a6c <vfprintf+0x98>
    1a36:	8b 32       	cpi	r24, 0x2B	; 43
    1a38:	79 f0       	breq	.+30     	; 0x1a58 <vfprintf+0x84>
    1a3a:	38 f4       	brcc	.+14     	; 0x1a4a <vfprintf+0x76>
    1a3c:	80 32       	cpi	r24, 0x20	; 32
    1a3e:	79 f0       	breq	.+30     	; 0x1a5e <vfprintf+0x8a>
    1a40:	83 32       	cpi	r24, 0x23	; 35
    1a42:	a1 f4       	brne	.+40     	; 0x1a6c <vfprintf+0x98>
    1a44:	23 2d       	mov	r18, r3
    1a46:	20 61       	ori	r18, 0x10	; 16
    1a48:	1d c0       	rjmp	.+58     	; 0x1a84 <vfprintf+0xb0>
    1a4a:	8d 32       	cpi	r24, 0x2D	; 45
    1a4c:	61 f0       	breq	.+24     	; 0x1a66 <vfprintf+0x92>
    1a4e:	80 33       	cpi	r24, 0x30	; 48
    1a50:	69 f4       	brne	.+26     	; 0x1a6c <vfprintf+0x98>
    1a52:	23 2d       	mov	r18, r3
    1a54:	21 60       	ori	r18, 0x01	; 1
    1a56:	16 c0       	rjmp	.+44     	; 0x1a84 <vfprintf+0xb0>
    1a58:	83 2d       	mov	r24, r3
    1a5a:	82 60       	ori	r24, 0x02	; 2
    1a5c:	38 2e       	mov	r3, r24
    1a5e:	e3 2d       	mov	r30, r3
    1a60:	e4 60       	ori	r30, 0x04	; 4
    1a62:	3e 2e       	mov	r3, r30
    1a64:	2a c0       	rjmp	.+84     	; 0x1aba <vfprintf+0xe6>
    1a66:	f3 2d       	mov	r31, r3
    1a68:	f8 60       	ori	r31, 0x08	; 8
    1a6a:	1d c0       	rjmp	.+58     	; 0x1aa6 <vfprintf+0xd2>
    1a6c:	37 fc       	sbrc	r3, 7
    1a6e:	2d c0       	rjmp	.+90     	; 0x1aca <vfprintf+0xf6>
    1a70:	20 ed       	ldi	r18, 0xD0	; 208
    1a72:	28 0f       	add	r18, r24
    1a74:	2a 30       	cpi	r18, 0x0A	; 10
    1a76:	40 f0       	brcs	.+16     	; 0x1a88 <vfprintf+0xb4>
    1a78:	8e 32       	cpi	r24, 0x2E	; 46
    1a7a:	b9 f4       	brne	.+46     	; 0x1aaa <vfprintf+0xd6>
    1a7c:	36 fc       	sbrc	r3, 6
    1a7e:	81 c1       	rjmp	.+770    	; 0x1d82 <vfprintf+0x3ae>
    1a80:	23 2d       	mov	r18, r3
    1a82:	20 64       	ori	r18, 0x40	; 64
    1a84:	32 2e       	mov	r3, r18
    1a86:	19 c0       	rjmp	.+50     	; 0x1aba <vfprintf+0xe6>
    1a88:	36 fe       	sbrs	r3, 6
    1a8a:	06 c0       	rjmp	.+12     	; 0x1a98 <vfprintf+0xc4>
    1a8c:	8a e0       	ldi	r24, 0x0A	; 10
    1a8e:	98 9e       	mul	r9, r24
    1a90:	20 0d       	add	r18, r0
    1a92:	11 24       	eor	r1, r1
    1a94:	92 2e       	mov	r9, r18
    1a96:	11 c0       	rjmp	.+34     	; 0x1aba <vfprintf+0xe6>
    1a98:	ea e0       	ldi	r30, 0x0A	; 10
    1a9a:	2e 9e       	mul	r2, r30
    1a9c:	20 0d       	add	r18, r0
    1a9e:	11 24       	eor	r1, r1
    1aa0:	22 2e       	mov	r2, r18
    1aa2:	f3 2d       	mov	r31, r3
    1aa4:	f0 62       	ori	r31, 0x20	; 32
    1aa6:	3f 2e       	mov	r3, r31
    1aa8:	08 c0       	rjmp	.+16     	; 0x1aba <vfprintf+0xe6>
    1aaa:	8c 36       	cpi	r24, 0x6C	; 108
    1aac:	21 f4       	brne	.+8      	; 0x1ab6 <vfprintf+0xe2>
    1aae:	83 2d       	mov	r24, r3
    1ab0:	80 68       	ori	r24, 0x80	; 128
    1ab2:	38 2e       	mov	r3, r24
    1ab4:	02 c0       	rjmp	.+4      	; 0x1aba <vfprintf+0xe6>
    1ab6:	88 36       	cpi	r24, 0x68	; 104
    1ab8:	41 f4       	brne	.+16     	; 0x1aca <vfprintf+0xf6>
    1aba:	f7 01       	movw	r30, r14
    1abc:	93 fd       	sbrc	r25, 3
    1abe:	85 91       	lpm	r24, Z+
    1ac0:	93 ff       	sbrs	r25, 3
    1ac2:	81 91       	ld	r24, Z+
    1ac4:	7f 01       	movw	r14, r30
    1ac6:	81 11       	cpse	r24, r1
    1ac8:	b3 cf       	rjmp	.-154    	; 0x1a30 <vfprintf+0x5c>
    1aca:	98 2f       	mov	r25, r24
    1acc:	9f 7d       	andi	r25, 0xDF	; 223
    1ace:	95 54       	subi	r25, 0x45	; 69
    1ad0:	93 30       	cpi	r25, 0x03	; 3
    1ad2:	28 f4       	brcc	.+10     	; 0x1ade <vfprintf+0x10a>
    1ad4:	0c 5f       	subi	r16, 0xFC	; 252
    1ad6:	1f 4f       	sbci	r17, 0xFF	; 255
    1ad8:	9f e3       	ldi	r25, 0x3F	; 63
    1ada:	99 83       	std	Y+1, r25	; 0x01
    1adc:	0d c0       	rjmp	.+26     	; 0x1af8 <vfprintf+0x124>
    1ade:	83 36       	cpi	r24, 0x63	; 99
    1ae0:	31 f0       	breq	.+12     	; 0x1aee <vfprintf+0x11a>
    1ae2:	83 37       	cpi	r24, 0x73	; 115
    1ae4:	71 f0       	breq	.+28     	; 0x1b02 <vfprintf+0x12e>
    1ae6:	83 35       	cpi	r24, 0x53	; 83
    1ae8:	09 f0       	breq	.+2      	; 0x1aec <vfprintf+0x118>
    1aea:	59 c0       	rjmp	.+178    	; 0x1b9e <vfprintf+0x1ca>
    1aec:	21 c0       	rjmp	.+66     	; 0x1b30 <vfprintf+0x15c>
    1aee:	f8 01       	movw	r30, r16
    1af0:	80 81       	ld	r24, Z
    1af2:	89 83       	std	Y+1, r24	; 0x01
    1af4:	0e 5f       	subi	r16, 0xFE	; 254
    1af6:	1f 4f       	sbci	r17, 0xFF	; 255
    1af8:	88 24       	eor	r8, r8
    1afa:	83 94       	inc	r8
    1afc:	91 2c       	mov	r9, r1
    1afe:	53 01       	movw	r10, r6
    1b00:	13 c0       	rjmp	.+38     	; 0x1b28 <vfprintf+0x154>
    1b02:	28 01       	movw	r4, r16
    1b04:	f2 e0       	ldi	r31, 0x02	; 2
    1b06:	4f 0e       	add	r4, r31
    1b08:	51 1c       	adc	r5, r1
    1b0a:	f8 01       	movw	r30, r16
    1b0c:	a0 80       	ld	r10, Z
    1b0e:	b1 80       	ldd	r11, Z+1	; 0x01
    1b10:	36 fe       	sbrs	r3, 6
    1b12:	03 c0       	rjmp	.+6      	; 0x1b1a <vfprintf+0x146>
    1b14:	69 2d       	mov	r22, r9
    1b16:	70 e0       	ldi	r23, 0x00	; 0
    1b18:	02 c0       	rjmp	.+4      	; 0x1b1e <vfprintf+0x14a>
    1b1a:	6f ef       	ldi	r22, 0xFF	; 255
    1b1c:	7f ef       	ldi	r23, 0xFF	; 255
    1b1e:	c5 01       	movw	r24, r10
    1b20:	0e 94 08 11 	call	0x2210	; 0x2210 <strnlen>
    1b24:	4c 01       	movw	r8, r24
    1b26:	82 01       	movw	r16, r4
    1b28:	f3 2d       	mov	r31, r3
    1b2a:	ff 77       	andi	r31, 0x7F	; 127
    1b2c:	3f 2e       	mov	r3, r31
    1b2e:	16 c0       	rjmp	.+44     	; 0x1b5c <vfprintf+0x188>
    1b30:	28 01       	movw	r4, r16
    1b32:	22 e0       	ldi	r18, 0x02	; 2
    1b34:	42 0e       	add	r4, r18
    1b36:	51 1c       	adc	r5, r1
    1b38:	f8 01       	movw	r30, r16
    1b3a:	a0 80       	ld	r10, Z
    1b3c:	b1 80       	ldd	r11, Z+1	; 0x01
    1b3e:	36 fe       	sbrs	r3, 6
    1b40:	03 c0       	rjmp	.+6      	; 0x1b48 <vfprintf+0x174>
    1b42:	69 2d       	mov	r22, r9
    1b44:	70 e0       	ldi	r23, 0x00	; 0
    1b46:	02 c0       	rjmp	.+4      	; 0x1b4c <vfprintf+0x178>
    1b48:	6f ef       	ldi	r22, 0xFF	; 255
    1b4a:	7f ef       	ldi	r23, 0xFF	; 255
    1b4c:	c5 01       	movw	r24, r10
    1b4e:	0e 94 fd 10 	call	0x21fa	; 0x21fa <strnlen_P>
    1b52:	4c 01       	movw	r8, r24
    1b54:	f3 2d       	mov	r31, r3
    1b56:	f0 68       	ori	r31, 0x80	; 128
    1b58:	3f 2e       	mov	r3, r31
    1b5a:	82 01       	movw	r16, r4
    1b5c:	33 fc       	sbrc	r3, 3
    1b5e:	1b c0       	rjmp	.+54     	; 0x1b96 <vfprintf+0x1c2>
    1b60:	82 2d       	mov	r24, r2
    1b62:	90 e0       	ldi	r25, 0x00	; 0
    1b64:	88 16       	cp	r8, r24
    1b66:	99 06       	cpc	r9, r25
    1b68:	b0 f4       	brcc	.+44     	; 0x1b96 <vfprintf+0x1c2>
    1b6a:	b6 01       	movw	r22, r12
    1b6c:	80 e2       	ldi	r24, 0x20	; 32
    1b6e:	90 e0       	ldi	r25, 0x00	; 0
    1b70:	0e 94 13 11 	call	0x2226	; 0x2226 <fputc>
    1b74:	2a 94       	dec	r2
    1b76:	f4 cf       	rjmp	.-24     	; 0x1b60 <vfprintf+0x18c>
    1b78:	f5 01       	movw	r30, r10
    1b7a:	37 fc       	sbrc	r3, 7
    1b7c:	85 91       	lpm	r24, Z+
    1b7e:	37 fe       	sbrs	r3, 7
    1b80:	81 91       	ld	r24, Z+
    1b82:	5f 01       	movw	r10, r30
    1b84:	b6 01       	movw	r22, r12
    1b86:	90 e0       	ldi	r25, 0x00	; 0
    1b88:	0e 94 13 11 	call	0x2226	; 0x2226 <fputc>
    1b8c:	21 10       	cpse	r2, r1
    1b8e:	2a 94       	dec	r2
    1b90:	21 e0       	ldi	r18, 0x01	; 1
    1b92:	82 1a       	sub	r8, r18
    1b94:	91 08       	sbc	r9, r1
    1b96:	81 14       	cp	r8, r1
    1b98:	91 04       	cpc	r9, r1
    1b9a:	71 f7       	brne	.-36     	; 0x1b78 <vfprintf+0x1a4>
    1b9c:	e8 c0       	rjmp	.+464    	; 0x1d6e <vfprintf+0x39a>
    1b9e:	84 36       	cpi	r24, 0x64	; 100
    1ba0:	11 f0       	breq	.+4      	; 0x1ba6 <vfprintf+0x1d2>
    1ba2:	89 36       	cpi	r24, 0x69	; 105
    1ba4:	41 f5       	brne	.+80     	; 0x1bf6 <vfprintf+0x222>
    1ba6:	f8 01       	movw	r30, r16
    1ba8:	37 fe       	sbrs	r3, 7
    1baa:	07 c0       	rjmp	.+14     	; 0x1bba <vfprintf+0x1e6>
    1bac:	60 81       	ld	r22, Z
    1bae:	71 81       	ldd	r23, Z+1	; 0x01
    1bb0:	82 81       	ldd	r24, Z+2	; 0x02
    1bb2:	93 81       	ldd	r25, Z+3	; 0x03
    1bb4:	0c 5f       	subi	r16, 0xFC	; 252
    1bb6:	1f 4f       	sbci	r17, 0xFF	; 255
    1bb8:	08 c0       	rjmp	.+16     	; 0x1bca <vfprintf+0x1f6>
    1bba:	60 81       	ld	r22, Z
    1bbc:	71 81       	ldd	r23, Z+1	; 0x01
    1bbe:	07 2e       	mov	r0, r23
    1bc0:	00 0c       	add	r0, r0
    1bc2:	88 0b       	sbc	r24, r24
    1bc4:	99 0b       	sbc	r25, r25
    1bc6:	0e 5f       	subi	r16, 0xFE	; 254
    1bc8:	1f 4f       	sbci	r17, 0xFF	; 255
    1bca:	f3 2d       	mov	r31, r3
    1bcc:	ff 76       	andi	r31, 0x6F	; 111
    1bce:	3f 2e       	mov	r3, r31
    1bd0:	97 ff       	sbrs	r25, 7
    1bd2:	09 c0       	rjmp	.+18     	; 0x1be6 <vfprintf+0x212>
    1bd4:	90 95       	com	r25
    1bd6:	80 95       	com	r24
    1bd8:	70 95       	com	r23
    1bda:	61 95       	neg	r22
    1bdc:	7f 4f       	sbci	r23, 0xFF	; 255
    1bde:	8f 4f       	sbci	r24, 0xFF	; 255
    1be0:	9f 4f       	sbci	r25, 0xFF	; 255
    1be2:	f0 68       	ori	r31, 0x80	; 128
    1be4:	3f 2e       	mov	r3, r31
    1be6:	2a e0       	ldi	r18, 0x0A	; 10
    1be8:	30 e0       	ldi	r19, 0x00	; 0
    1bea:	a3 01       	movw	r20, r6
    1bec:	0e 94 4f 11 	call	0x229e	; 0x229e <__ultoa_invert>
    1bf0:	88 2e       	mov	r8, r24
    1bf2:	86 18       	sub	r8, r6
    1bf4:	45 c0       	rjmp	.+138    	; 0x1c80 <vfprintf+0x2ac>
    1bf6:	85 37       	cpi	r24, 0x75	; 117
    1bf8:	31 f4       	brne	.+12     	; 0x1c06 <vfprintf+0x232>
    1bfa:	23 2d       	mov	r18, r3
    1bfc:	2f 7e       	andi	r18, 0xEF	; 239
    1bfe:	b2 2e       	mov	r11, r18
    1c00:	2a e0       	ldi	r18, 0x0A	; 10
    1c02:	30 e0       	ldi	r19, 0x00	; 0
    1c04:	25 c0       	rjmp	.+74     	; 0x1c50 <vfprintf+0x27c>
    1c06:	93 2d       	mov	r25, r3
    1c08:	99 7f       	andi	r25, 0xF9	; 249
    1c0a:	b9 2e       	mov	r11, r25
    1c0c:	8f 36       	cpi	r24, 0x6F	; 111
    1c0e:	c1 f0       	breq	.+48     	; 0x1c40 <vfprintf+0x26c>
    1c10:	18 f4       	brcc	.+6      	; 0x1c18 <vfprintf+0x244>
    1c12:	88 35       	cpi	r24, 0x58	; 88
    1c14:	79 f0       	breq	.+30     	; 0x1c34 <vfprintf+0x260>
    1c16:	b5 c0       	rjmp	.+362    	; 0x1d82 <vfprintf+0x3ae>
    1c18:	80 37       	cpi	r24, 0x70	; 112
    1c1a:	19 f0       	breq	.+6      	; 0x1c22 <vfprintf+0x24e>
    1c1c:	88 37       	cpi	r24, 0x78	; 120
    1c1e:	21 f0       	breq	.+8      	; 0x1c28 <vfprintf+0x254>
    1c20:	b0 c0       	rjmp	.+352    	; 0x1d82 <vfprintf+0x3ae>
    1c22:	e9 2f       	mov	r30, r25
    1c24:	e0 61       	ori	r30, 0x10	; 16
    1c26:	be 2e       	mov	r11, r30
    1c28:	b4 fe       	sbrs	r11, 4
    1c2a:	0d c0       	rjmp	.+26     	; 0x1c46 <vfprintf+0x272>
    1c2c:	fb 2d       	mov	r31, r11
    1c2e:	f4 60       	ori	r31, 0x04	; 4
    1c30:	bf 2e       	mov	r11, r31
    1c32:	09 c0       	rjmp	.+18     	; 0x1c46 <vfprintf+0x272>
    1c34:	34 fe       	sbrs	r3, 4
    1c36:	0a c0       	rjmp	.+20     	; 0x1c4c <vfprintf+0x278>
    1c38:	29 2f       	mov	r18, r25
    1c3a:	26 60       	ori	r18, 0x06	; 6
    1c3c:	b2 2e       	mov	r11, r18
    1c3e:	06 c0       	rjmp	.+12     	; 0x1c4c <vfprintf+0x278>
    1c40:	28 e0       	ldi	r18, 0x08	; 8
    1c42:	30 e0       	ldi	r19, 0x00	; 0
    1c44:	05 c0       	rjmp	.+10     	; 0x1c50 <vfprintf+0x27c>
    1c46:	20 e1       	ldi	r18, 0x10	; 16
    1c48:	30 e0       	ldi	r19, 0x00	; 0
    1c4a:	02 c0       	rjmp	.+4      	; 0x1c50 <vfprintf+0x27c>
    1c4c:	20 e1       	ldi	r18, 0x10	; 16
    1c4e:	32 e0       	ldi	r19, 0x02	; 2
    1c50:	f8 01       	movw	r30, r16
    1c52:	b7 fe       	sbrs	r11, 7
    1c54:	07 c0       	rjmp	.+14     	; 0x1c64 <vfprintf+0x290>
    1c56:	60 81       	ld	r22, Z
    1c58:	71 81       	ldd	r23, Z+1	; 0x01
    1c5a:	82 81       	ldd	r24, Z+2	; 0x02
    1c5c:	93 81       	ldd	r25, Z+3	; 0x03
    1c5e:	0c 5f       	subi	r16, 0xFC	; 252
    1c60:	1f 4f       	sbci	r17, 0xFF	; 255
    1c62:	06 c0       	rjmp	.+12     	; 0x1c70 <vfprintf+0x29c>
    1c64:	60 81       	ld	r22, Z
    1c66:	71 81       	ldd	r23, Z+1	; 0x01
    1c68:	80 e0       	ldi	r24, 0x00	; 0
    1c6a:	90 e0       	ldi	r25, 0x00	; 0
    1c6c:	0e 5f       	subi	r16, 0xFE	; 254
    1c6e:	1f 4f       	sbci	r17, 0xFF	; 255
    1c70:	a3 01       	movw	r20, r6
    1c72:	0e 94 4f 11 	call	0x229e	; 0x229e <__ultoa_invert>
    1c76:	88 2e       	mov	r8, r24
    1c78:	86 18       	sub	r8, r6
    1c7a:	fb 2d       	mov	r31, r11
    1c7c:	ff 77       	andi	r31, 0x7F	; 127
    1c7e:	3f 2e       	mov	r3, r31
    1c80:	36 fe       	sbrs	r3, 6
    1c82:	0d c0       	rjmp	.+26     	; 0x1c9e <vfprintf+0x2ca>
    1c84:	23 2d       	mov	r18, r3
    1c86:	2e 7f       	andi	r18, 0xFE	; 254
    1c88:	a2 2e       	mov	r10, r18
    1c8a:	89 14       	cp	r8, r9
    1c8c:	58 f4       	brcc	.+22     	; 0x1ca4 <vfprintf+0x2d0>
    1c8e:	34 fe       	sbrs	r3, 4
    1c90:	0b c0       	rjmp	.+22     	; 0x1ca8 <vfprintf+0x2d4>
    1c92:	32 fc       	sbrc	r3, 2
    1c94:	09 c0       	rjmp	.+18     	; 0x1ca8 <vfprintf+0x2d4>
    1c96:	83 2d       	mov	r24, r3
    1c98:	8e 7e       	andi	r24, 0xEE	; 238
    1c9a:	a8 2e       	mov	r10, r24
    1c9c:	05 c0       	rjmp	.+10     	; 0x1ca8 <vfprintf+0x2d4>
    1c9e:	b8 2c       	mov	r11, r8
    1ca0:	a3 2c       	mov	r10, r3
    1ca2:	03 c0       	rjmp	.+6      	; 0x1caa <vfprintf+0x2d6>
    1ca4:	b8 2c       	mov	r11, r8
    1ca6:	01 c0       	rjmp	.+2      	; 0x1caa <vfprintf+0x2d6>
    1ca8:	b9 2c       	mov	r11, r9
    1caa:	a4 fe       	sbrs	r10, 4
    1cac:	0f c0       	rjmp	.+30     	; 0x1ccc <vfprintf+0x2f8>
    1cae:	fe 01       	movw	r30, r28
    1cb0:	e8 0d       	add	r30, r8
    1cb2:	f1 1d       	adc	r31, r1
    1cb4:	80 81       	ld	r24, Z
    1cb6:	80 33       	cpi	r24, 0x30	; 48
    1cb8:	21 f4       	brne	.+8      	; 0x1cc2 <vfprintf+0x2ee>
    1cba:	9a 2d       	mov	r25, r10
    1cbc:	99 7e       	andi	r25, 0xE9	; 233
    1cbe:	a9 2e       	mov	r10, r25
    1cc0:	09 c0       	rjmp	.+18     	; 0x1cd4 <vfprintf+0x300>
    1cc2:	a2 fe       	sbrs	r10, 2
    1cc4:	06 c0       	rjmp	.+12     	; 0x1cd2 <vfprintf+0x2fe>
    1cc6:	b3 94       	inc	r11
    1cc8:	b3 94       	inc	r11
    1cca:	04 c0       	rjmp	.+8      	; 0x1cd4 <vfprintf+0x300>
    1ccc:	8a 2d       	mov	r24, r10
    1cce:	86 78       	andi	r24, 0x86	; 134
    1cd0:	09 f0       	breq	.+2      	; 0x1cd4 <vfprintf+0x300>
    1cd2:	b3 94       	inc	r11
    1cd4:	a3 fc       	sbrc	r10, 3
    1cd6:	11 c0       	rjmp	.+34     	; 0x1cfa <vfprintf+0x326>
    1cd8:	a0 fe       	sbrs	r10, 0
    1cda:	06 c0       	rjmp	.+12     	; 0x1ce8 <vfprintf+0x314>
    1cdc:	b2 14       	cp	r11, r2
    1cde:	88 f4       	brcc	.+34     	; 0x1d02 <vfprintf+0x32e>
    1ce0:	28 0c       	add	r2, r8
    1ce2:	92 2c       	mov	r9, r2
    1ce4:	9b 18       	sub	r9, r11
    1ce6:	0e c0       	rjmp	.+28     	; 0x1d04 <vfprintf+0x330>
    1ce8:	b2 14       	cp	r11, r2
    1cea:	60 f4       	brcc	.+24     	; 0x1d04 <vfprintf+0x330>
    1cec:	b6 01       	movw	r22, r12
    1cee:	80 e2       	ldi	r24, 0x20	; 32
    1cf0:	90 e0       	ldi	r25, 0x00	; 0
    1cf2:	0e 94 13 11 	call	0x2226	; 0x2226 <fputc>
    1cf6:	b3 94       	inc	r11
    1cf8:	f7 cf       	rjmp	.-18     	; 0x1ce8 <vfprintf+0x314>
    1cfa:	b2 14       	cp	r11, r2
    1cfc:	18 f4       	brcc	.+6      	; 0x1d04 <vfprintf+0x330>
    1cfe:	2b 18       	sub	r2, r11
    1d00:	02 c0       	rjmp	.+4      	; 0x1d06 <vfprintf+0x332>
    1d02:	98 2c       	mov	r9, r8
    1d04:	21 2c       	mov	r2, r1
    1d06:	a4 fe       	sbrs	r10, 4
    1d08:	10 c0       	rjmp	.+32     	; 0x1d2a <vfprintf+0x356>
    1d0a:	b6 01       	movw	r22, r12
    1d0c:	80 e3       	ldi	r24, 0x30	; 48
    1d0e:	90 e0       	ldi	r25, 0x00	; 0
    1d10:	0e 94 13 11 	call	0x2226	; 0x2226 <fputc>
    1d14:	a2 fe       	sbrs	r10, 2
    1d16:	17 c0       	rjmp	.+46     	; 0x1d46 <vfprintf+0x372>
    1d18:	a1 fc       	sbrc	r10, 1
    1d1a:	03 c0       	rjmp	.+6      	; 0x1d22 <vfprintf+0x34e>
    1d1c:	88 e7       	ldi	r24, 0x78	; 120
    1d1e:	90 e0       	ldi	r25, 0x00	; 0
    1d20:	02 c0       	rjmp	.+4      	; 0x1d26 <vfprintf+0x352>
    1d22:	88 e5       	ldi	r24, 0x58	; 88
    1d24:	90 e0       	ldi	r25, 0x00	; 0
    1d26:	b6 01       	movw	r22, r12
    1d28:	0c c0       	rjmp	.+24     	; 0x1d42 <vfprintf+0x36e>
    1d2a:	8a 2d       	mov	r24, r10
    1d2c:	86 78       	andi	r24, 0x86	; 134
    1d2e:	59 f0       	breq	.+22     	; 0x1d46 <vfprintf+0x372>
    1d30:	a1 fe       	sbrs	r10, 1
    1d32:	02 c0       	rjmp	.+4      	; 0x1d38 <vfprintf+0x364>
    1d34:	8b e2       	ldi	r24, 0x2B	; 43
    1d36:	01 c0       	rjmp	.+2      	; 0x1d3a <vfprintf+0x366>
    1d38:	80 e2       	ldi	r24, 0x20	; 32
    1d3a:	a7 fc       	sbrc	r10, 7
    1d3c:	8d e2       	ldi	r24, 0x2D	; 45
    1d3e:	b6 01       	movw	r22, r12
    1d40:	90 e0       	ldi	r25, 0x00	; 0
    1d42:	0e 94 13 11 	call	0x2226	; 0x2226 <fputc>
    1d46:	89 14       	cp	r8, r9
    1d48:	38 f4       	brcc	.+14     	; 0x1d58 <vfprintf+0x384>
    1d4a:	b6 01       	movw	r22, r12
    1d4c:	80 e3       	ldi	r24, 0x30	; 48
    1d4e:	90 e0       	ldi	r25, 0x00	; 0
    1d50:	0e 94 13 11 	call	0x2226	; 0x2226 <fputc>
    1d54:	9a 94       	dec	r9
    1d56:	f7 cf       	rjmp	.-18     	; 0x1d46 <vfprintf+0x372>
    1d58:	8a 94       	dec	r8
    1d5a:	f3 01       	movw	r30, r6
    1d5c:	e8 0d       	add	r30, r8
    1d5e:	f1 1d       	adc	r31, r1
    1d60:	80 81       	ld	r24, Z
    1d62:	b6 01       	movw	r22, r12
    1d64:	90 e0       	ldi	r25, 0x00	; 0
    1d66:	0e 94 13 11 	call	0x2226	; 0x2226 <fputc>
    1d6a:	81 10       	cpse	r8, r1
    1d6c:	f5 cf       	rjmp	.-22     	; 0x1d58 <vfprintf+0x384>
    1d6e:	22 20       	and	r2, r2
    1d70:	09 f4       	brne	.+2      	; 0x1d74 <vfprintf+0x3a0>
    1d72:	42 ce       	rjmp	.-892    	; 0x19f8 <vfprintf+0x24>
    1d74:	b6 01       	movw	r22, r12
    1d76:	80 e2       	ldi	r24, 0x20	; 32
    1d78:	90 e0       	ldi	r25, 0x00	; 0
    1d7a:	0e 94 13 11 	call	0x2226	; 0x2226 <fputc>
    1d7e:	2a 94       	dec	r2
    1d80:	f6 cf       	rjmp	.-20     	; 0x1d6e <vfprintf+0x39a>
    1d82:	f6 01       	movw	r30, r12
    1d84:	86 81       	ldd	r24, Z+6	; 0x06
    1d86:	97 81       	ldd	r25, Z+7	; 0x07
    1d88:	02 c0       	rjmp	.+4      	; 0x1d8e <vfprintf+0x3ba>
    1d8a:	8f ef       	ldi	r24, 0xFF	; 255
    1d8c:	9f ef       	ldi	r25, 0xFF	; 255
    1d8e:	2b 96       	adiw	r28, 0x0b	; 11
    1d90:	e2 e1       	ldi	r30, 0x12	; 18
    1d92:	0c 94 c6 11 	jmp	0x238c	; 0x238c <__epilogue_restores__>

00001d96 <dtoa_prf>:
    1d96:	a9 e0       	ldi	r26, 0x09	; 9
    1d98:	b0 e0       	ldi	r27, 0x00	; 0
    1d9a:	e1 ed       	ldi	r30, 0xD1	; 209
    1d9c:	fe e0       	ldi	r31, 0x0E	; 14
    1d9e:	0c 94 b3 11 	jmp	0x2366	; 0x2366 <__prologue_saves__+0xc>
    1da2:	6a 01       	movw	r12, r20
    1da4:	12 2f       	mov	r17, r18
    1da6:	b0 2e       	mov	r11, r16
    1da8:	2b e3       	ldi	r18, 0x3B	; 59
    1daa:	20 17       	cp	r18, r16
    1dac:	20 f0       	brcs	.+8      	; 0x1db6 <dtoa_prf+0x20>
    1dae:	ff 24       	eor	r15, r15
    1db0:	f3 94       	inc	r15
    1db2:	f0 0e       	add	r15, r16
    1db4:	02 c0       	rjmp	.+4      	; 0x1dba <dtoa_prf+0x24>
    1db6:	2c e3       	ldi	r18, 0x3C	; 60
    1db8:	f2 2e       	mov	r15, r18
    1dba:	0f 2d       	mov	r16, r15
    1dbc:	27 e0       	ldi	r18, 0x07	; 7
    1dbe:	ae 01       	movw	r20, r28
    1dc0:	4f 5f       	subi	r20, 0xFF	; 255
    1dc2:	5f 4f       	sbci	r21, 0xFF	; 255
    1dc4:	0e 94 25 10 	call	0x204a	; 0x204a <__ftoa_engine>
    1dc8:	bc 01       	movw	r22, r24
    1dca:	49 81       	ldd	r20, Y+1	; 0x01
    1dcc:	84 2f       	mov	r24, r20
    1dce:	89 70       	andi	r24, 0x09	; 9
    1dd0:	81 30       	cpi	r24, 0x01	; 1
    1dd2:	31 f0       	breq	.+12     	; 0x1de0 <dtoa_prf+0x4a>
    1dd4:	e1 fc       	sbrc	r14, 1
    1dd6:	06 c0       	rjmp	.+12     	; 0x1de4 <dtoa_prf+0x4e>
    1dd8:	e0 fe       	sbrs	r14, 0
    1dda:	06 c0       	rjmp	.+12     	; 0x1de8 <dtoa_prf+0x52>
    1ddc:	90 e2       	ldi	r25, 0x20	; 32
    1dde:	05 c0       	rjmp	.+10     	; 0x1dea <dtoa_prf+0x54>
    1de0:	9d e2       	ldi	r25, 0x2D	; 45
    1de2:	03 c0       	rjmp	.+6      	; 0x1dea <dtoa_prf+0x54>
    1de4:	9b e2       	ldi	r25, 0x2B	; 43
    1de6:	01 c0       	rjmp	.+2      	; 0x1dea <dtoa_prf+0x54>
    1de8:	90 e0       	ldi	r25, 0x00	; 0
    1dea:	5e 2d       	mov	r21, r14
    1dec:	50 71       	andi	r21, 0x10	; 16
    1dee:	43 ff       	sbrs	r20, 3
    1df0:	3c c0       	rjmp	.+120    	; 0x1e6a <dtoa_prf+0xd4>
    1df2:	91 11       	cpse	r25, r1
    1df4:	02 c0       	rjmp	.+4      	; 0x1dfa <dtoa_prf+0x64>
    1df6:	83 e0       	ldi	r24, 0x03	; 3
    1df8:	01 c0       	rjmp	.+2      	; 0x1dfc <dtoa_prf+0x66>
    1dfa:	84 e0       	ldi	r24, 0x04	; 4
    1dfc:	81 17       	cp	r24, r17
    1dfe:	18 f4       	brcc	.+6      	; 0x1e06 <dtoa_prf+0x70>
    1e00:	21 2f       	mov	r18, r17
    1e02:	28 1b       	sub	r18, r24
    1e04:	01 c0       	rjmp	.+2      	; 0x1e08 <dtoa_prf+0x72>
    1e06:	20 e0       	ldi	r18, 0x00	; 0
    1e08:	51 11       	cpse	r21, r1
    1e0a:	0b c0       	rjmp	.+22     	; 0x1e22 <dtoa_prf+0x8c>
    1e0c:	f6 01       	movw	r30, r12
    1e0e:	82 2f       	mov	r24, r18
    1e10:	30 e2       	ldi	r19, 0x20	; 32
    1e12:	88 23       	and	r24, r24
    1e14:	19 f0       	breq	.+6      	; 0x1e1c <dtoa_prf+0x86>
    1e16:	31 93       	st	Z+, r19
    1e18:	81 50       	subi	r24, 0x01	; 1
    1e1a:	fb cf       	rjmp	.-10     	; 0x1e12 <dtoa_prf+0x7c>
    1e1c:	c2 0e       	add	r12, r18
    1e1e:	d1 1c       	adc	r13, r1
    1e20:	20 e0       	ldi	r18, 0x00	; 0
    1e22:	99 23       	and	r25, r25
    1e24:	29 f0       	breq	.+10     	; 0x1e30 <dtoa_prf+0x9a>
    1e26:	d6 01       	movw	r26, r12
    1e28:	9c 93       	st	X, r25
    1e2a:	f6 01       	movw	r30, r12
    1e2c:	31 96       	adiw	r30, 0x01	; 1
    1e2e:	6f 01       	movw	r12, r30
    1e30:	c6 01       	movw	r24, r12
    1e32:	03 96       	adiw	r24, 0x03	; 3
    1e34:	e2 fe       	sbrs	r14, 2
    1e36:	0a c0       	rjmp	.+20     	; 0x1e4c <dtoa_prf+0xb6>
    1e38:	3e e4       	ldi	r19, 0x4E	; 78
    1e3a:	d6 01       	movw	r26, r12
    1e3c:	3c 93       	st	X, r19
    1e3e:	41 e4       	ldi	r20, 0x41	; 65
    1e40:	11 96       	adiw	r26, 0x01	; 1
    1e42:	4c 93       	st	X, r20
    1e44:	11 97       	sbiw	r26, 0x01	; 1
    1e46:	12 96       	adiw	r26, 0x02	; 2
    1e48:	3c 93       	st	X, r19
    1e4a:	06 c0       	rjmp	.+12     	; 0x1e58 <dtoa_prf+0xc2>
    1e4c:	3e e6       	ldi	r19, 0x6E	; 110
    1e4e:	f6 01       	movw	r30, r12
    1e50:	30 83       	st	Z, r19
    1e52:	41 e6       	ldi	r20, 0x61	; 97
    1e54:	41 83       	std	Z+1, r20	; 0x01
    1e56:	32 83       	std	Z+2, r19	; 0x02
    1e58:	fc 01       	movw	r30, r24
    1e5a:	32 2f       	mov	r19, r18
    1e5c:	40 e2       	ldi	r20, 0x20	; 32
    1e5e:	33 23       	and	r19, r19
    1e60:	09 f4       	brne	.+2      	; 0x1e64 <dtoa_prf+0xce>
    1e62:	42 c0       	rjmp	.+132    	; 0x1ee8 <dtoa_prf+0x152>
    1e64:	41 93       	st	Z+, r20
    1e66:	31 50       	subi	r19, 0x01	; 1
    1e68:	fa cf       	rjmp	.-12     	; 0x1e5e <dtoa_prf+0xc8>
    1e6a:	42 ff       	sbrs	r20, 2
    1e6c:	44 c0       	rjmp	.+136    	; 0x1ef6 <dtoa_prf+0x160>
    1e6e:	91 11       	cpse	r25, r1
    1e70:	02 c0       	rjmp	.+4      	; 0x1e76 <dtoa_prf+0xe0>
    1e72:	83 e0       	ldi	r24, 0x03	; 3
    1e74:	01 c0       	rjmp	.+2      	; 0x1e78 <dtoa_prf+0xe2>
    1e76:	84 e0       	ldi	r24, 0x04	; 4
    1e78:	81 17       	cp	r24, r17
    1e7a:	18 f4       	brcc	.+6      	; 0x1e82 <dtoa_prf+0xec>
    1e7c:	21 2f       	mov	r18, r17
    1e7e:	28 1b       	sub	r18, r24
    1e80:	01 c0       	rjmp	.+2      	; 0x1e84 <dtoa_prf+0xee>
    1e82:	20 e0       	ldi	r18, 0x00	; 0
    1e84:	51 11       	cpse	r21, r1
    1e86:	0b c0       	rjmp	.+22     	; 0x1e9e <dtoa_prf+0x108>
    1e88:	f6 01       	movw	r30, r12
    1e8a:	82 2f       	mov	r24, r18
    1e8c:	30 e2       	ldi	r19, 0x20	; 32
    1e8e:	88 23       	and	r24, r24
    1e90:	19 f0       	breq	.+6      	; 0x1e98 <dtoa_prf+0x102>
    1e92:	31 93       	st	Z+, r19
    1e94:	81 50       	subi	r24, 0x01	; 1
    1e96:	fb cf       	rjmp	.-10     	; 0x1e8e <dtoa_prf+0xf8>
    1e98:	c2 0e       	add	r12, r18
    1e9a:	d1 1c       	adc	r13, r1
    1e9c:	20 e0       	ldi	r18, 0x00	; 0
    1e9e:	99 23       	and	r25, r25
    1ea0:	29 f0       	breq	.+10     	; 0x1eac <dtoa_prf+0x116>
    1ea2:	d6 01       	movw	r26, r12
    1ea4:	9c 93       	st	X, r25
    1ea6:	f6 01       	movw	r30, r12
    1ea8:	31 96       	adiw	r30, 0x01	; 1
    1eaa:	6f 01       	movw	r12, r30
    1eac:	c6 01       	movw	r24, r12
    1eae:	03 96       	adiw	r24, 0x03	; 3
    1eb0:	e2 fe       	sbrs	r14, 2
    1eb2:	0b c0       	rjmp	.+22     	; 0x1eca <dtoa_prf+0x134>
    1eb4:	39 e4       	ldi	r19, 0x49	; 73
    1eb6:	d6 01       	movw	r26, r12
    1eb8:	3c 93       	st	X, r19
    1eba:	3e e4       	ldi	r19, 0x4E	; 78
    1ebc:	11 96       	adiw	r26, 0x01	; 1
    1ebe:	3c 93       	st	X, r19
    1ec0:	11 97       	sbiw	r26, 0x01	; 1
    1ec2:	36 e4       	ldi	r19, 0x46	; 70
    1ec4:	12 96       	adiw	r26, 0x02	; 2
    1ec6:	3c 93       	st	X, r19
    1ec8:	07 c0       	rjmp	.+14     	; 0x1ed8 <dtoa_prf+0x142>
    1eca:	39 e6       	ldi	r19, 0x69	; 105
    1ecc:	f6 01       	movw	r30, r12
    1ece:	30 83       	st	Z, r19
    1ed0:	3e e6       	ldi	r19, 0x6E	; 110
    1ed2:	31 83       	std	Z+1, r19	; 0x01
    1ed4:	36 e6       	ldi	r19, 0x66	; 102
    1ed6:	32 83       	std	Z+2, r19	; 0x02
    1ed8:	fc 01       	movw	r30, r24
    1eda:	32 2f       	mov	r19, r18
    1edc:	40 e2       	ldi	r20, 0x20	; 32
    1ede:	33 23       	and	r19, r19
    1ee0:	19 f0       	breq	.+6      	; 0x1ee8 <dtoa_prf+0x152>
    1ee2:	41 93       	st	Z+, r20
    1ee4:	31 50       	subi	r19, 0x01	; 1
    1ee6:	fb cf       	rjmp	.-10     	; 0x1ede <dtoa_prf+0x148>
    1ee8:	fc 01       	movw	r30, r24
    1eea:	e2 0f       	add	r30, r18
    1eec:	f1 1d       	adc	r31, r1
    1eee:	10 82       	st	Z, r1
    1ef0:	8e ef       	ldi	r24, 0xFE	; 254
    1ef2:	9f ef       	ldi	r25, 0xFF	; 255
    1ef4:	a6 c0       	rjmp	.+332    	; 0x2042 <dtoa_prf+0x2ac>
    1ef6:	21 e0       	ldi	r18, 0x01	; 1
    1ef8:	30 e0       	ldi	r19, 0x00	; 0
    1efa:	91 11       	cpse	r25, r1
    1efc:	02 c0       	rjmp	.+4      	; 0x1f02 <dtoa_prf+0x16c>
    1efe:	20 e0       	ldi	r18, 0x00	; 0
    1f00:	30 e0       	ldi	r19, 0x00	; 0
    1f02:	16 16       	cp	r1, r22
    1f04:	17 06       	cpc	r1, r23
    1f06:	1c f4       	brge	.+6      	; 0x1f0e <dtoa_prf+0x178>
    1f08:	fb 01       	movw	r30, r22
    1f0a:	31 96       	adiw	r30, 0x01	; 1
    1f0c:	02 c0       	rjmp	.+4      	; 0x1f12 <dtoa_prf+0x17c>
    1f0e:	e1 e0       	ldi	r30, 0x01	; 1
    1f10:	f0 e0       	ldi	r31, 0x00	; 0
    1f12:	2e 0f       	add	r18, r30
    1f14:	3f 1f       	adc	r19, r31
    1f16:	bb 20       	and	r11, r11
    1f18:	21 f0       	breq	.+8      	; 0x1f22 <dtoa_prf+0x18c>
    1f1a:	eb 2d       	mov	r30, r11
    1f1c:	f0 e0       	ldi	r31, 0x00	; 0
    1f1e:	31 96       	adiw	r30, 0x01	; 1
    1f20:	02 c0       	rjmp	.+4      	; 0x1f26 <dtoa_prf+0x190>
    1f22:	e0 e0       	ldi	r30, 0x00	; 0
    1f24:	f0 e0       	ldi	r31, 0x00	; 0
    1f26:	2e 0f       	add	r18, r30
    1f28:	3f 1f       	adc	r19, r31
    1f2a:	e1 2f       	mov	r30, r17
    1f2c:	f0 e0       	ldi	r31, 0x00	; 0
    1f2e:	2e 17       	cp	r18, r30
    1f30:	3f 07       	cpc	r19, r31
    1f32:	1c f4       	brge	.+6      	; 0x1f3a <dtoa_prf+0x1a4>
    1f34:	12 1b       	sub	r17, r18
    1f36:	21 2f       	mov	r18, r17
    1f38:	01 c0       	rjmp	.+2      	; 0x1f3c <dtoa_prf+0x1a6>
    1f3a:	20 e0       	ldi	r18, 0x00	; 0
    1f3c:	8e 2d       	mov	r24, r14
    1f3e:	88 71       	andi	r24, 0x18	; 24
    1f40:	59 f4       	brne	.+22     	; 0x1f58 <dtoa_prf+0x1c2>
    1f42:	f6 01       	movw	r30, r12
    1f44:	82 2f       	mov	r24, r18
    1f46:	30 e2       	ldi	r19, 0x20	; 32
    1f48:	88 23       	and	r24, r24
    1f4a:	19 f0       	breq	.+6      	; 0x1f52 <dtoa_prf+0x1bc>
    1f4c:	31 93       	st	Z+, r19
    1f4e:	81 50       	subi	r24, 0x01	; 1
    1f50:	fb cf       	rjmp	.-10     	; 0x1f48 <dtoa_prf+0x1b2>
    1f52:	c2 0e       	add	r12, r18
    1f54:	d1 1c       	adc	r13, r1
    1f56:	20 e0       	ldi	r18, 0x00	; 0
    1f58:	99 23       	and	r25, r25
    1f5a:	29 f0       	breq	.+10     	; 0x1f66 <dtoa_prf+0x1d0>
    1f5c:	d6 01       	movw	r26, r12
    1f5e:	9c 93       	st	X, r25
    1f60:	f6 01       	movw	r30, r12
    1f62:	31 96       	adiw	r30, 0x01	; 1
    1f64:	6f 01       	movw	r12, r30
    1f66:	51 11       	cpse	r21, r1
    1f68:	0b c0       	rjmp	.+22     	; 0x1f80 <dtoa_prf+0x1ea>
    1f6a:	f6 01       	movw	r30, r12
    1f6c:	82 2f       	mov	r24, r18
    1f6e:	90 e3       	ldi	r25, 0x30	; 48
    1f70:	88 23       	and	r24, r24
    1f72:	19 f0       	breq	.+6      	; 0x1f7a <dtoa_prf+0x1e4>
    1f74:	91 93       	st	Z+, r25
    1f76:	81 50       	subi	r24, 0x01	; 1
    1f78:	fb cf       	rjmp	.-10     	; 0x1f70 <dtoa_prf+0x1da>
    1f7a:	c2 0e       	add	r12, r18
    1f7c:	d1 1c       	adc	r13, r1
    1f7e:	20 e0       	ldi	r18, 0x00	; 0
    1f80:	0f 2d       	mov	r16, r15
    1f82:	06 0f       	add	r16, r22
    1f84:	9a 81       	ldd	r25, Y+2	; 0x02
    1f86:	34 2f       	mov	r19, r20
    1f88:	30 71       	andi	r19, 0x10	; 16
    1f8a:	44 ff       	sbrs	r20, 4
    1f8c:	03 c0       	rjmp	.+6      	; 0x1f94 <dtoa_prf+0x1fe>
    1f8e:	91 33       	cpi	r25, 0x31	; 49
    1f90:	09 f4       	brne	.+2      	; 0x1f94 <dtoa_prf+0x1fe>
    1f92:	01 50       	subi	r16, 0x01	; 1
    1f94:	10 16       	cp	r1, r16
    1f96:	24 f4       	brge	.+8      	; 0x1fa0 <dtoa_prf+0x20a>
    1f98:	09 30       	cpi	r16, 0x09	; 9
    1f9a:	18 f0       	brcs	.+6      	; 0x1fa2 <dtoa_prf+0x20c>
    1f9c:	08 e0       	ldi	r16, 0x08	; 8
    1f9e:	01 c0       	rjmp	.+2      	; 0x1fa2 <dtoa_prf+0x20c>
    1fa0:	01 e0       	ldi	r16, 0x01	; 1
    1fa2:	ab 01       	movw	r20, r22
    1fa4:	77 ff       	sbrs	r23, 7
    1fa6:	02 c0       	rjmp	.+4      	; 0x1fac <dtoa_prf+0x216>
    1fa8:	40 e0       	ldi	r20, 0x00	; 0
    1faa:	50 e0       	ldi	r21, 0x00	; 0
    1fac:	fb 01       	movw	r30, r22
    1fae:	e4 1b       	sub	r30, r20
    1fb0:	f5 0b       	sbc	r31, r21
    1fb2:	a1 e0       	ldi	r26, 0x01	; 1
    1fb4:	b0 e0       	ldi	r27, 0x00	; 0
    1fb6:	ac 0f       	add	r26, r28
    1fb8:	bd 1f       	adc	r27, r29
    1fba:	ea 0f       	add	r30, r26
    1fbc:	fb 1f       	adc	r31, r27
    1fbe:	8e e2       	ldi	r24, 0x2E	; 46
    1fc0:	a8 2e       	mov	r10, r24
    1fc2:	4b 01       	movw	r8, r22
    1fc4:	80 1a       	sub	r8, r16
    1fc6:	91 08       	sbc	r9, r1
    1fc8:	0b 2d       	mov	r16, r11
    1fca:	10 e0       	ldi	r17, 0x00	; 0
    1fcc:	11 95       	neg	r17
    1fce:	01 95       	neg	r16
    1fd0:	11 09       	sbc	r17, r1
    1fd2:	4f 3f       	cpi	r20, 0xFF	; 255
    1fd4:	bf ef       	ldi	r27, 0xFF	; 255
    1fd6:	5b 07       	cpc	r21, r27
    1fd8:	21 f4       	brne	.+8      	; 0x1fe2 <dtoa_prf+0x24c>
    1fda:	d6 01       	movw	r26, r12
    1fdc:	ac 92       	st	X, r10
    1fde:	11 96       	adiw	r26, 0x01	; 1
    1fe0:	6d 01       	movw	r12, r26
    1fe2:	64 17       	cp	r22, r20
    1fe4:	75 07       	cpc	r23, r21
    1fe6:	2c f0       	brlt	.+10     	; 0x1ff2 <dtoa_prf+0x25c>
    1fe8:	84 16       	cp	r8, r20
    1fea:	95 06       	cpc	r9, r21
    1fec:	14 f4       	brge	.+4      	; 0x1ff2 <dtoa_prf+0x25c>
    1fee:	81 81       	ldd	r24, Z+1	; 0x01
    1ff0:	01 c0       	rjmp	.+2      	; 0x1ff4 <dtoa_prf+0x25e>
    1ff2:	80 e3       	ldi	r24, 0x30	; 48
    1ff4:	41 50       	subi	r20, 0x01	; 1
    1ff6:	51 09       	sbc	r21, r1
    1ff8:	31 96       	adiw	r30, 0x01	; 1
    1ffa:	d6 01       	movw	r26, r12
    1ffc:	11 96       	adiw	r26, 0x01	; 1
    1ffe:	7d 01       	movw	r14, r26
    2000:	40 17       	cp	r20, r16
    2002:	51 07       	cpc	r21, r17
    2004:	24 f0       	brlt	.+8      	; 0x200e <dtoa_prf+0x278>
    2006:	d6 01       	movw	r26, r12
    2008:	8c 93       	st	X, r24
    200a:	67 01       	movw	r12, r14
    200c:	e2 cf       	rjmp	.-60     	; 0x1fd2 <dtoa_prf+0x23c>
    200e:	64 17       	cp	r22, r20
    2010:	75 07       	cpc	r23, r21
    2012:	39 f4       	brne	.+14     	; 0x2022 <dtoa_prf+0x28c>
    2014:	96 33       	cpi	r25, 0x36	; 54
    2016:	20 f4       	brcc	.+8      	; 0x2020 <dtoa_prf+0x28a>
    2018:	95 33       	cpi	r25, 0x35	; 53
    201a:	19 f4       	brne	.+6      	; 0x2022 <dtoa_prf+0x28c>
    201c:	31 11       	cpse	r19, r1
    201e:	01 c0       	rjmp	.+2      	; 0x2022 <dtoa_prf+0x28c>
    2020:	81 e3       	ldi	r24, 0x31	; 49
    2022:	f6 01       	movw	r30, r12
    2024:	80 83       	st	Z, r24
    2026:	f7 01       	movw	r30, r14
    2028:	82 2f       	mov	r24, r18
    202a:	90 e2       	ldi	r25, 0x20	; 32
    202c:	88 23       	and	r24, r24
    202e:	19 f0       	breq	.+6      	; 0x2036 <dtoa_prf+0x2a0>
    2030:	91 93       	st	Z+, r25
    2032:	81 50       	subi	r24, 0x01	; 1
    2034:	fb cf       	rjmp	.-10     	; 0x202c <dtoa_prf+0x296>
    2036:	f7 01       	movw	r30, r14
    2038:	e2 0f       	add	r30, r18
    203a:	f1 1d       	adc	r31, r1
    203c:	10 82       	st	Z, r1
    203e:	80 e0       	ldi	r24, 0x00	; 0
    2040:	90 e0       	ldi	r25, 0x00	; 0
    2042:	29 96       	adiw	r28, 0x09	; 9
    2044:	ec e0       	ldi	r30, 0x0C	; 12
    2046:	0c 94 cc 11 	jmp	0x2398	; 0x2398 <__epilogue_restores__+0xc>

0000204a <__ftoa_engine>:
    204a:	28 30       	cpi	r18, 0x08	; 8
    204c:	08 f0       	brcs	.+2      	; 0x2050 <__ftoa_engine+0x6>
    204e:	27 e0       	ldi	r18, 0x07	; 7
    2050:	33 27       	eor	r19, r19
    2052:	da 01       	movw	r26, r20
    2054:	99 0f       	add	r25, r25
    2056:	31 1d       	adc	r19, r1
    2058:	87 fd       	sbrc	r24, 7
    205a:	91 60       	ori	r25, 0x01	; 1
    205c:	00 96       	adiw	r24, 0x00	; 0
    205e:	61 05       	cpc	r22, r1
    2060:	71 05       	cpc	r23, r1
    2062:	39 f4       	brne	.+14     	; 0x2072 <__ftoa_engine+0x28>
    2064:	32 60       	ori	r19, 0x02	; 2
    2066:	2e 5f       	subi	r18, 0xFE	; 254
    2068:	3d 93       	st	X+, r19
    206a:	30 e3       	ldi	r19, 0x30	; 48
    206c:	2a 95       	dec	r18
    206e:	e1 f7       	brne	.-8      	; 0x2068 <__ftoa_engine+0x1e>
    2070:	08 95       	ret
    2072:	9f 3f       	cpi	r25, 0xFF	; 255
    2074:	30 f0       	brcs	.+12     	; 0x2082 <__ftoa_engine+0x38>
    2076:	80 38       	cpi	r24, 0x80	; 128
    2078:	71 05       	cpc	r23, r1
    207a:	61 05       	cpc	r22, r1
    207c:	09 f0       	breq	.+2      	; 0x2080 <__ftoa_engine+0x36>
    207e:	3c 5f       	subi	r19, 0xFC	; 252
    2080:	3c 5f       	subi	r19, 0xFC	; 252
    2082:	3d 93       	st	X+, r19
    2084:	91 30       	cpi	r25, 0x01	; 1
    2086:	08 f0       	brcs	.+2      	; 0x208a <__ftoa_engine+0x40>
    2088:	80 68       	ori	r24, 0x80	; 128
    208a:	91 1d       	adc	r25, r1
    208c:	df 93       	push	r29
    208e:	cf 93       	push	r28
    2090:	1f 93       	push	r17
    2092:	0f 93       	push	r16
    2094:	ff 92       	push	r15
    2096:	ef 92       	push	r14
    2098:	19 2f       	mov	r17, r25
    209a:	98 7f       	andi	r25, 0xF8	; 248
    209c:	96 95       	lsr	r25
    209e:	e9 2f       	mov	r30, r25
    20a0:	96 95       	lsr	r25
    20a2:	96 95       	lsr	r25
    20a4:	e9 0f       	add	r30, r25
    20a6:	ff 27       	eor	r31, r31
    20a8:	e4 5e       	subi	r30, 0xE4	; 228
    20aa:	fe 4f       	sbci	r31, 0xFE	; 254
    20ac:	99 27       	eor	r25, r25
    20ae:	33 27       	eor	r19, r19
    20b0:	ee 24       	eor	r14, r14
    20b2:	ff 24       	eor	r15, r15
    20b4:	a7 01       	movw	r20, r14
    20b6:	e7 01       	movw	r28, r14
    20b8:	05 90       	lpm	r0, Z+
    20ba:	08 94       	sec
    20bc:	07 94       	ror	r0
    20be:	28 f4       	brcc	.+10     	; 0x20ca <__ftoa_engine+0x80>
    20c0:	36 0f       	add	r19, r22
    20c2:	e7 1e       	adc	r14, r23
    20c4:	f8 1e       	adc	r15, r24
    20c6:	49 1f       	adc	r20, r25
    20c8:	51 1d       	adc	r21, r1
    20ca:	66 0f       	add	r22, r22
    20cc:	77 1f       	adc	r23, r23
    20ce:	88 1f       	adc	r24, r24
    20d0:	99 1f       	adc	r25, r25
    20d2:	06 94       	lsr	r0
    20d4:	a1 f7       	brne	.-24     	; 0x20be <__ftoa_engine+0x74>
    20d6:	05 90       	lpm	r0, Z+
    20d8:	07 94       	ror	r0
    20da:	28 f4       	brcc	.+10     	; 0x20e6 <__ftoa_engine+0x9c>
    20dc:	e7 0e       	add	r14, r23
    20de:	f8 1e       	adc	r15, r24
    20e0:	49 1f       	adc	r20, r25
    20e2:	56 1f       	adc	r21, r22
    20e4:	c1 1d       	adc	r28, r1
    20e6:	77 0f       	add	r23, r23
    20e8:	88 1f       	adc	r24, r24
    20ea:	99 1f       	adc	r25, r25
    20ec:	66 1f       	adc	r22, r22
    20ee:	06 94       	lsr	r0
    20f0:	a1 f7       	brne	.-24     	; 0x20da <__ftoa_engine+0x90>
    20f2:	05 90       	lpm	r0, Z+
    20f4:	07 94       	ror	r0
    20f6:	28 f4       	brcc	.+10     	; 0x2102 <__ftoa_engine+0xb8>
    20f8:	f8 0e       	add	r15, r24
    20fa:	49 1f       	adc	r20, r25
    20fc:	56 1f       	adc	r21, r22
    20fe:	c7 1f       	adc	r28, r23
    2100:	d1 1d       	adc	r29, r1
    2102:	88 0f       	add	r24, r24
    2104:	99 1f       	adc	r25, r25
    2106:	66 1f       	adc	r22, r22
    2108:	77 1f       	adc	r23, r23
    210a:	06 94       	lsr	r0
    210c:	a1 f7       	brne	.-24     	; 0x20f6 <__ftoa_engine+0xac>
    210e:	05 90       	lpm	r0, Z+
    2110:	07 94       	ror	r0
    2112:	20 f4       	brcc	.+8      	; 0x211c <__ftoa_engine+0xd2>
    2114:	49 0f       	add	r20, r25
    2116:	56 1f       	adc	r21, r22
    2118:	c7 1f       	adc	r28, r23
    211a:	d8 1f       	adc	r29, r24
    211c:	99 0f       	add	r25, r25
    211e:	66 1f       	adc	r22, r22
    2120:	77 1f       	adc	r23, r23
    2122:	88 1f       	adc	r24, r24
    2124:	06 94       	lsr	r0
    2126:	a9 f7       	brne	.-22     	; 0x2112 <__ftoa_engine+0xc8>
    2128:	84 91       	lpm	r24, Z
    212a:	10 95       	com	r17
    212c:	17 70       	andi	r17, 0x07	; 7
    212e:	41 f0       	breq	.+16     	; 0x2140 <__ftoa_engine+0xf6>
    2130:	d6 95       	lsr	r29
    2132:	c7 95       	ror	r28
    2134:	57 95       	ror	r21
    2136:	47 95       	ror	r20
    2138:	f7 94       	ror	r15
    213a:	e7 94       	ror	r14
    213c:	1a 95       	dec	r17
    213e:	c1 f7       	brne	.-16     	; 0x2130 <__ftoa_engine+0xe6>
    2140:	e2 ec       	ldi	r30, 0xC2	; 194
    2142:	f0 e0       	ldi	r31, 0x00	; 0
    2144:	68 94       	set
    2146:	15 90       	lpm	r1, Z+
    2148:	15 91       	lpm	r17, Z+
    214a:	35 91       	lpm	r19, Z+
    214c:	65 91       	lpm	r22, Z+
    214e:	95 91       	lpm	r25, Z+
    2150:	05 90       	lpm	r0, Z+
    2152:	7f e2       	ldi	r23, 0x2F	; 47
    2154:	73 95       	inc	r23
    2156:	e1 18       	sub	r14, r1
    2158:	f1 0a       	sbc	r15, r17
    215a:	43 0b       	sbc	r20, r19
    215c:	56 0b       	sbc	r21, r22
    215e:	c9 0b       	sbc	r28, r25
    2160:	d0 09       	sbc	r29, r0
    2162:	c0 f7       	brcc	.-16     	; 0x2154 <__ftoa_engine+0x10a>
    2164:	e1 0c       	add	r14, r1
    2166:	f1 1e       	adc	r15, r17
    2168:	43 1f       	adc	r20, r19
    216a:	56 1f       	adc	r21, r22
    216c:	c9 1f       	adc	r28, r25
    216e:	d0 1d       	adc	r29, r0
    2170:	7e f4       	brtc	.+30     	; 0x2190 <__ftoa_engine+0x146>
    2172:	70 33       	cpi	r23, 0x30	; 48
    2174:	11 f4       	brne	.+4      	; 0x217a <__ftoa_engine+0x130>
    2176:	8a 95       	dec	r24
    2178:	e6 cf       	rjmp	.-52     	; 0x2146 <__ftoa_engine+0xfc>
    217a:	e8 94       	clt
    217c:	01 50       	subi	r16, 0x01	; 1
    217e:	30 f0       	brcs	.+12     	; 0x218c <__ftoa_engine+0x142>
    2180:	08 0f       	add	r16, r24
    2182:	0a f4       	brpl	.+2      	; 0x2186 <__ftoa_engine+0x13c>
    2184:	00 27       	eor	r16, r16
    2186:	02 17       	cp	r16, r18
    2188:	08 f4       	brcc	.+2      	; 0x218c <__ftoa_engine+0x142>
    218a:	20 2f       	mov	r18, r16
    218c:	23 95       	inc	r18
    218e:	02 2f       	mov	r16, r18
    2190:	7a 33       	cpi	r23, 0x3A	; 58
    2192:	28 f0       	brcs	.+10     	; 0x219e <__ftoa_engine+0x154>
    2194:	79 e3       	ldi	r23, 0x39	; 57
    2196:	7d 93       	st	X+, r23
    2198:	2a 95       	dec	r18
    219a:	e9 f7       	brne	.-6      	; 0x2196 <__ftoa_engine+0x14c>
    219c:	10 c0       	rjmp	.+32     	; 0x21be <__ftoa_engine+0x174>
    219e:	7d 93       	st	X+, r23
    21a0:	2a 95       	dec	r18
    21a2:	89 f6       	brne	.-94     	; 0x2146 <__ftoa_engine+0xfc>
    21a4:	06 94       	lsr	r0
    21a6:	97 95       	ror	r25
    21a8:	67 95       	ror	r22
    21aa:	37 95       	ror	r19
    21ac:	17 95       	ror	r17
    21ae:	17 94       	ror	r1
    21b0:	e1 18       	sub	r14, r1
    21b2:	f1 0a       	sbc	r15, r17
    21b4:	43 0b       	sbc	r20, r19
    21b6:	56 0b       	sbc	r21, r22
    21b8:	c9 0b       	sbc	r28, r25
    21ba:	d0 09       	sbc	r29, r0
    21bc:	98 f0       	brcs	.+38     	; 0x21e4 <__ftoa_engine+0x19a>
    21be:	23 95       	inc	r18
    21c0:	7e 91       	ld	r23, -X
    21c2:	73 95       	inc	r23
    21c4:	7a 33       	cpi	r23, 0x3A	; 58
    21c6:	08 f0       	brcs	.+2      	; 0x21ca <__ftoa_engine+0x180>
    21c8:	70 e3       	ldi	r23, 0x30	; 48
    21ca:	7c 93       	st	X, r23
    21cc:	20 13       	cpse	r18, r16
    21ce:	b8 f7       	brcc	.-18     	; 0x21be <__ftoa_engine+0x174>
    21d0:	7e 91       	ld	r23, -X
    21d2:	70 61       	ori	r23, 0x10	; 16
    21d4:	7d 93       	st	X+, r23
    21d6:	30 f0       	brcs	.+12     	; 0x21e4 <__ftoa_engine+0x19a>
    21d8:	83 95       	inc	r24
    21da:	71 e3       	ldi	r23, 0x31	; 49
    21dc:	7d 93       	st	X+, r23
    21de:	70 e3       	ldi	r23, 0x30	; 48
    21e0:	2a 95       	dec	r18
    21e2:	e1 f7       	brne	.-8      	; 0x21dc <__ftoa_engine+0x192>
    21e4:	11 24       	eor	r1, r1
    21e6:	ef 90       	pop	r14
    21e8:	ff 90       	pop	r15
    21ea:	0f 91       	pop	r16
    21ec:	1f 91       	pop	r17
    21ee:	cf 91       	pop	r28
    21f0:	df 91       	pop	r29
    21f2:	99 27       	eor	r25, r25
    21f4:	87 fd       	sbrc	r24, 7
    21f6:	90 95       	com	r25
    21f8:	08 95       	ret

000021fa <strnlen_P>:
    21fa:	fc 01       	movw	r30, r24
    21fc:	05 90       	lpm	r0, Z+
    21fe:	61 50       	subi	r22, 0x01	; 1
    2200:	70 40       	sbci	r23, 0x00	; 0
    2202:	01 10       	cpse	r0, r1
    2204:	d8 f7       	brcc	.-10     	; 0x21fc <strnlen_P+0x2>
    2206:	80 95       	com	r24
    2208:	90 95       	com	r25
    220a:	8e 0f       	add	r24, r30
    220c:	9f 1f       	adc	r25, r31
    220e:	08 95       	ret

00002210 <strnlen>:
    2210:	fc 01       	movw	r30, r24
    2212:	61 50       	subi	r22, 0x01	; 1
    2214:	70 40       	sbci	r23, 0x00	; 0
    2216:	01 90       	ld	r0, Z+
    2218:	01 10       	cpse	r0, r1
    221a:	d8 f7       	brcc	.-10     	; 0x2212 <strnlen+0x2>
    221c:	80 95       	com	r24
    221e:	90 95       	com	r25
    2220:	8e 0f       	add	r24, r30
    2222:	9f 1f       	adc	r25, r31
    2224:	08 95       	ret

00002226 <fputc>:
    2226:	0f 93       	push	r16
    2228:	1f 93       	push	r17
    222a:	cf 93       	push	r28
    222c:	df 93       	push	r29
    222e:	fb 01       	movw	r30, r22
    2230:	23 81       	ldd	r18, Z+3	; 0x03
    2232:	21 fd       	sbrc	r18, 1
    2234:	03 c0       	rjmp	.+6      	; 0x223c <fputc+0x16>
    2236:	8f ef       	ldi	r24, 0xFF	; 255
    2238:	9f ef       	ldi	r25, 0xFF	; 255
    223a:	2c c0       	rjmp	.+88     	; 0x2294 <fputc+0x6e>
    223c:	22 ff       	sbrs	r18, 2
    223e:	16 c0       	rjmp	.+44     	; 0x226c <fputc+0x46>
    2240:	46 81       	ldd	r20, Z+6	; 0x06
    2242:	57 81       	ldd	r21, Z+7	; 0x07
    2244:	24 81       	ldd	r18, Z+4	; 0x04
    2246:	35 81       	ldd	r19, Z+5	; 0x05
    2248:	42 17       	cp	r20, r18
    224a:	53 07       	cpc	r21, r19
    224c:	44 f4       	brge	.+16     	; 0x225e <fputc+0x38>
    224e:	a0 81       	ld	r26, Z
    2250:	b1 81       	ldd	r27, Z+1	; 0x01
    2252:	9d 01       	movw	r18, r26
    2254:	2f 5f       	subi	r18, 0xFF	; 255
    2256:	3f 4f       	sbci	r19, 0xFF	; 255
    2258:	20 83       	st	Z, r18
    225a:	31 83       	std	Z+1, r19	; 0x01
    225c:	8c 93       	st	X, r24
    225e:	26 81       	ldd	r18, Z+6	; 0x06
    2260:	37 81       	ldd	r19, Z+7	; 0x07
    2262:	2f 5f       	subi	r18, 0xFF	; 255
    2264:	3f 4f       	sbci	r19, 0xFF	; 255
    2266:	26 83       	std	Z+6, r18	; 0x06
    2268:	37 83       	std	Z+7, r19	; 0x07
    226a:	14 c0       	rjmp	.+40     	; 0x2294 <fputc+0x6e>
    226c:	8b 01       	movw	r16, r22
    226e:	ec 01       	movw	r28, r24
    2270:	fb 01       	movw	r30, r22
    2272:	00 84       	ldd	r0, Z+8	; 0x08
    2274:	f1 85       	ldd	r31, Z+9	; 0x09
    2276:	e0 2d       	mov	r30, r0
    2278:	09 95       	icall
    227a:	89 2b       	or	r24, r25
    227c:	e1 f6       	brne	.-72     	; 0x2236 <fputc+0x10>
    227e:	d8 01       	movw	r26, r16
    2280:	16 96       	adiw	r26, 0x06	; 6
    2282:	8d 91       	ld	r24, X+
    2284:	9c 91       	ld	r25, X
    2286:	17 97       	sbiw	r26, 0x07	; 7
    2288:	01 96       	adiw	r24, 0x01	; 1
    228a:	16 96       	adiw	r26, 0x06	; 6
    228c:	8d 93       	st	X+, r24
    228e:	9c 93       	st	X, r25
    2290:	17 97       	sbiw	r26, 0x07	; 7
    2292:	ce 01       	movw	r24, r28
    2294:	df 91       	pop	r29
    2296:	cf 91       	pop	r28
    2298:	1f 91       	pop	r17
    229a:	0f 91       	pop	r16
    229c:	08 95       	ret

0000229e <__ultoa_invert>:
    229e:	fa 01       	movw	r30, r20
    22a0:	aa 27       	eor	r26, r26
    22a2:	28 30       	cpi	r18, 0x08	; 8
    22a4:	51 f1       	breq	.+84     	; 0x22fa <__ultoa_invert+0x5c>
    22a6:	20 31       	cpi	r18, 0x10	; 16
    22a8:	81 f1       	breq	.+96     	; 0x230a <__ultoa_invert+0x6c>
    22aa:	e8 94       	clt
    22ac:	6f 93       	push	r22
    22ae:	6e 7f       	andi	r22, 0xFE	; 254
    22b0:	6e 5f       	subi	r22, 0xFE	; 254
    22b2:	7f 4f       	sbci	r23, 0xFF	; 255
    22b4:	8f 4f       	sbci	r24, 0xFF	; 255
    22b6:	9f 4f       	sbci	r25, 0xFF	; 255
    22b8:	af 4f       	sbci	r26, 0xFF	; 255
    22ba:	b1 e0       	ldi	r27, 0x01	; 1
    22bc:	3e d0       	rcall	.+124    	; 0x233a <__ultoa_invert+0x9c>
    22be:	b4 e0       	ldi	r27, 0x04	; 4
    22c0:	3c d0       	rcall	.+120    	; 0x233a <__ultoa_invert+0x9c>
    22c2:	67 0f       	add	r22, r23
    22c4:	78 1f       	adc	r23, r24
    22c6:	89 1f       	adc	r24, r25
    22c8:	9a 1f       	adc	r25, r26
    22ca:	a1 1d       	adc	r26, r1
    22cc:	68 0f       	add	r22, r24
    22ce:	79 1f       	adc	r23, r25
    22d0:	8a 1f       	adc	r24, r26
    22d2:	91 1d       	adc	r25, r1
    22d4:	a1 1d       	adc	r26, r1
    22d6:	6a 0f       	add	r22, r26
    22d8:	71 1d       	adc	r23, r1
    22da:	81 1d       	adc	r24, r1
    22dc:	91 1d       	adc	r25, r1
    22de:	a1 1d       	adc	r26, r1
    22e0:	20 d0       	rcall	.+64     	; 0x2322 <__ultoa_invert+0x84>
    22e2:	09 f4       	brne	.+2      	; 0x22e6 <__ultoa_invert+0x48>
    22e4:	68 94       	set
    22e6:	3f 91       	pop	r19
    22e8:	2a e0       	ldi	r18, 0x0A	; 10
    22ea:	26 9f       	mul	r18, r22
    22ec:	11 24       	eor	r1, r1
    22ee:	30 19       	sub	r19, r0
    22f0:	30 5d       	subi	r19, 0xD0	; 208
    22f2:	31 93       	st	Z+, r19
    22f4:	de f6       	brtc	.-74     	; 0x22ac <__ultoa_invert+0xe>
    22f6:	cf 01       	movw	r24, r30
    22f8:	08 95       	ret
    22fa:	46 2f       	mov	r20, r22
    22fc:	47 70       	andi	r20, 0x07	; 7
    22fe:	40 5d       	subi	r20, 0xD0	; 208
    2300:	41 93       	st	Z+, r20
    2302:	b3 e0       	ldi	r27, 0x03	; 3
    2304:	0f d0       	rcall	.+30     	; 0x2324 <__ultoa_invert+0x86>
    2306:	c9 f7       	brne	.-14     	; 0x22fa <__ultoa_invert+0x5c>
    2308:	f6 cf       	rjmp	.-20     	; 0x22f6 <__ultoa_invert+0x58>
    230a:	46 2f       	mov	r20, r22
    230c:	4f 70       	andi	r20, 0x0F	; 15
    230e:	40 5d       	subi	r20, 0xD0	; 208
    2310:	4a 33       	cpi	r20, 0x3A	; 58
    2312:	18 f0       	brcs	.+6      	; 0x231a <__ultoa_invert+0x7c>
    2314:	49 5d       	subi	r20, 0xD9	; 217
    2316:	31 fd       	sbrc	r19, 1
    2318:	40 52       	subi	r20, 0x20	; 32
    231a:	41 93       	st	Z+, r20
    231c:	02 d0       	rcall	.+4      	; 0x2322 <__ultoa_invert+0x84>
    231e:	a9 f7       	brne	.-22     	; 0x230a <__ultoa_invert+0x6c>
    2320:	ea cf       	rjmp	.-44     	; 0x22f6 <__ultoa_invert+0x58>
    2322:	b4 e0       	ldi	r27, 0x04	; 4
    2324:	a6 95       	lsr	r26
    2326:	97 95       	ror	r25
    2328:	87 95       	ror	r24
    232a:	77 95       	ror	r23
    232c:	67 95       	ror	r22
    232e:	ba 95       	dec	r27
    2330:	c9 f7       	brne	.-14     	; 0x2324 <__ultoa_invert+0x86>
    2332:	00 97       	sbiw	r24, 0x00	; 0
    2334:	61 05       	cpc	r22, r1
    2336:	71 05       	cpc	r23, r1
    2338:	08 95       	ret
    233a:	9b 01       	movw	r18, r22
    233c:	ac 01       	movw	r20, r24
    233e:	0a 2e       	mov	r0, r26
    2340:	06 94       	lsr	r0
    2342:	57 95       	ror	r21
    2344:	47 95       	ror	r20
    2346:	37 95       	ror	r19
    2348:	27 95       	ror	r18
    234a:	ba 95       	dec	r27
    234c:	c9 f7       	brne	.-14     	; 0x2340 <__ultoa_invert+0xa2>
    234e:	62 0f       	add	r22, r18
    2350:	73 1f       	adc	r23, r19
    2352:	84 1f       	adc	r24, r20
    2354:	95 1f       	adc	r25, r21
    2356:	a0 1d       	adc	r26, r0
    2358:	08 95       	ret

0000235a <__prologue_saves__>:
    235a:	2f 92       	push	r2
    235c:	3f 92       	push	r3
    235e:	4f 92       	push	r4
    2360:	5f 92       	push	r5
    2362:	6f 92       	push	r6
    2364:	7f 92       	push	r7
    2366:	8f 92       	push	r8
    2368:	9f 92       	push	r9
    236a:	af 92       	push	r10
    236c:	bf 92       	push	r11
    236e:	cf 92       	push	r12
    2370:	df 92       	push	r13
    2372:	ef 92       	push	r14
    2374:	ff 92       	push	r15
    2376:	0f 93       	push	r16
    2378:	1f 93       	push	r17
    237a:	cf 93       	push	r28
    237c:	df 93       	push	r29
    237e:	cd b7       	in	r28, 0x3d	; 61
    2380:	de b7       	in	r29, 0x3e	; 62
    2382:	ca 1b       	sub	r28, r26
    2384:	db 0b       	sbc	r29, r27
    2386:	cd bf       	out	0x3d, r28	; 61
    2388:	de bf       	out	0x3e, r29	; 62
    238a:	09 94       	ijmp

0000238c <__epilogue_restores__>:
    238c:	2a 88       	ldd	r2, Y+18	; 0x12
    238e:	39 88       	ldd	r3, Y+17	; 0x11
    2390:	48 88       	ldd	r4, Y+16	; 0x10
    2392:	5f 84       	ldd	r5, Y+15	; 0x0f
    2394:	6e 84       	ldd	r6, Y+14	; 0x0e
    2396:	7d 84       	ldd	r7, Y+13	; 0x0d
    2398:	8c 84       	ldd	r8, Y+12	; 0x0c
    239a:	9b 84       	ldd	r9, Y+11	; 0x0b
    239c:	aa 84       	ldd	r10, Y+10	; 0x0a
    239e:	b9 84       	ldd	r11, Y+9	; 0x09
    23a0:	c8 84       	ldd	r12, Y+8	; 0x08
    23a2:	df 80       	ldd	r13, Y+7	; 0x07
    23a4:	ee 80       	ldd	r14, Y+6	; 0x06
    23a6:	fd 80       	ldd	r15, Y+5	; 0x05
    23a8:	0c 81       	ldd	r16, Y+4	; 0x04
    23aa:	1b 81       	ldd	r17, Y+3	; 0x03
    23ac:	aa 81       	ldd	r26, Y+2	; 0x02
    23ae:	b9 81       	ldd	r27, Y+1	; 0x01
    23b0:	ce 0f       	add	r28, r30
    23b2:	d1 1d       	adc	r29, r1
    23b4:	cd bf       	out	0x3d, r28	; 61
    23b6:	de bf       	out	0x3e, r29	; 62
    23b8:	ed 01       	movw	r28, r26
    23ba:	08 95       	ret

000023bc <_exit>:
    23bc:	f8 94       	cli

000023be <__stop_program>:
    23be:	ff cf       	rjmp	.-2      	; 0x23be <__stop_program>
