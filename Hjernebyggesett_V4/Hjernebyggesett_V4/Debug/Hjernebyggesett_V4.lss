
Hjernebyggesett_V4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000016  00803800  00001a72  00001b26  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001a48  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000002a  00009a48  00001a48  00001afc  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .bss          0000007d  00803816  00803816  00001b3c  2**0
                  ALLOC
  4 .comment      00000030  00000000  00000000  00001b3c  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001b6c  2**2
                  CONTENTS, READONLY
  6 .debug_aranges 00000560  00000000  00000000  00001bb0  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00008c7e  00000000  00000000  00002110  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00003739  00000000  00000000  0000ad8e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00002c9a  00000000  00000000  0000e4c7  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000960  00000000  00000000  00011164  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000036dc  00000000  00000000  00011ac4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00001626  00000000  00000000  000151a0  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 000003c8  00000000  00000000  000167c6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 61 00 	jmp	0xc2	; 0xc2 <__ctors_end>
       4:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
       8:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
       c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      10:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      14:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      18:	0c 94 5c 05 	jmp	0xab8	; 0xab8 <__vector_6>
      1c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      20:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      24:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      28:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      2c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      30:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      34:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      38:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      3c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      40:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      44:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      48:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      4c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      50:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      54:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      58:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      5c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      60:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      64:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      68:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      6c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      70:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      74:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      78:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      7c:	07 63       	ori	r16, 0x37	; 55
      7e:	42 36       	cpi	r20, 0x62	; 98
      80:	b7 9b       	sbis	0x16, 7	; 22
      82:	d8 a7       	std	Y+40, r29	; 0x28
      84:	1a 39       	cpi	r17, 0x9A	; 154
      86:	68 56       	subi	r22, 0x68	; 104
      88:	18 ae       	std	Y+56, r1	; 0x38
      8a:	ba ab       	std	Y+50, r27	; 0x32
      8c:	55 8c       	ldd	r5, Z+29	; 0x1d
      8e:	1d 3c       	cpi	r17, 0xCD	; 205
      90:	b7 cc       	rjmp	.-1682   	; 0xfffffa00 <__eeprom_end+0xff7efa00>
      92:	57 63       	ori	r21, 0x37	; 55
      94:	bd 6d       	ori	r27, 0xDD	; 221
      96:	ed fd       	.word	0xfded	; ????
      98:	75 3e       	cpi	r23, 0xE5	; 229
      9a:	f6 17       	cp	r31, r22
      9c:	72 31       	cpi	r23, 0x12	; 18
      9e:	bf 00       	.word	0x00bf	; ????
      a0:	00 00       	nop
      a2:	80 3f       	cpi	r24, 0xF0	; 240
      a4:	05 a8       	ldd	r0, Z+53	; 0x35
      a6:	4c cd       	rjmp	.-1384   	; 0xfffffb40 <__eeprom_end+0xff7efb40>
      a8:	b2 d4       	rcall	.+2404   	; 0xa0e <tinyDendrite_get_potential+0x30>
      aa:	4e b9       	out	0x0e, r20	; 14
      ac:	38 36       	cpi	r19, 0x68	; 104
      ae:	a9 02       	muls	r26, r25
      b0:	0c 50       	subi	r16, 0x0C	; 12
      b2:	b9 91       	ld	r27, Y+
      b4:	86 88       	ldd	r8, Z+22	; 0x16
      b6:	08 3c       	cpi	r16, 0xC8	; 200
      b8:	a6 aa       	std	Z+54, r10	; 0x36
      ba:	aa 2a       	or	r10, r26
      bc:	be 00       	.word	0x00be	; ????
      be:	00 00       	nop
      c0:	80 3f       	cpi	r24, 0xF0	; 240

000000c2 <__ctors_end>:
      c2:	11 24       	eor	r1, r1
      c4:	1f be       	out	0x3f, r1	; 63
      c6:	cf ef       	ldi	r28, 0xFF	; 255
      c8:	cd bf       	out	0x3d, r28	; 61
      ca:	df e3       	ldi	r29, 0x3F	; 63
      cc:	de bf       	out	0x3e, r29	; 62

000000ce <__do_copy_data>:
      ce:	18 e3       	ldi	r17, 0x38	; 56
      d0:	a0 e0       	ldi	r26, 0x00	; 0
      d2:	b8 e3       	ldi	r27, 0x38	; 56
      d4:	e2 e7       	ldi	r30, 0x72	; 114
      d6:	fa e1       	ldi	r31, 0x1A	; 26
      d8:	02 c0       	rjmp	.+4      	; 0xde <__do_copy_data+0x10>
      da:	05 90       	lpm	r0, Z+
      dc:	0d 92       	st	X+, r0
      de:	a6 31       	cpi	r26, 0x16	; 22
      e0:	b1 07       	cpc	r27, r17
      e2:	d9 f7       	brne	.-10     	; 0xda <__do_copy_data+0xc>

000000e4 <__do_clear_bss>:
      e4:	28 e3       	ldi	r18, 0x38	; 56
      e6:	a6 e1       	ldi	r26, 0x16	; 22
      e8:	b8 e3       	ldi	r27, 0x38	; 56
      ea:	01 c0       	rjmp	.+2      	; 0xee <.do_clear_bss_start>

000000ec <.do_clear_bss_loop>:
      ec:	1d 92       	st	X+, r1

000000ee <.do_clear_bss_start>:
      ee:	a3 39       	cpi	r26, 0x93	; 147
      f0:	b2 07       	cpc	r27, r18
      f2:	e1 f7       	brne	.-8      	; 0xec <.do_clear_bss_loop>
      f4:	0e 94 83 00 	call	0x106	; 0x106 <main>
      f8:	0c 94 22 0d 	jmp	0x1a44	; 0x1a44 <_exit>

000000fc <__bad_interrupt>:
      fc:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000100 <atmel_start_init>:
/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
	system_init();
     100:	0e 94 a9 01 	call	0x352	; 0x352 <system_init>
     104:	08 95       	ret

00000106 <main>:

int main(void)
{	
	
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
     106:	0e 94 80 00 	call	0x100	; 0x100 <atmel_start_init>
	Setting this value will mean that the ADC (Analog to Digital Converter) will read 4.32v as 255, and 0v as 0.
	For some reason, instead of the reference voltage being 4.32v, it is 3.3v. 
	A plausible explanation is that the microchip does not up the voltage, so that if the microchip is only ever 
	supplied with 3.3v, it will output 3.3v as the max.
	*/
	VREF.CTRLA |= VREF_DAC0REFSEL_4V34_gc;
     10a:	e0 ea       	ldi	r30, 0xA0	; 160
     10c:	f0 e0       	ldi	r31, 0x00	; 0
     10e:	80 81       	ld	r24, Z
     110:	83 60       	ori	r24, 0x03	; 3
     112:	80 83       	st	Z, r24
	
	//tinyTester_test();
	
	tinySleep_prepare_sleep();
     114:	0e 94 3b 09 	call	0x1276	; 0x1276 <tinySleep_prepare_sleep>
	
	tinySleep_enter_sleep();
     118:	0e 94 44 09 	call	0x1288	; 0x1288 <tinySleep_enter_sleep>
	
	while (1)
	{
		// We don't want to update the neuron too often because of various reasons. The tinyISR_getflag is set every ms, and so the loop is only run once every ms.  
		if(tinyISR_getflag())
     11c:	0e 94 8a 05 	call	0xb14	; 0xb14 <tinyISR_getflag>
     120:	88 23       	and	r24, r24
     122:	e1 f3       	breq	.-8      	; 0x11c <main+0x16>
		{
			//Testing sleep mode
			//tinySleep_enter_sleep();
			tinyCharge_update_charging_mode();
     124:	0e 94 fe 03 	call	0x7fc	; 0x7fc <tinyCharge_update_charging_mode>
			
			if(tinyCharge_is_connected_to_charger()){
     128:	0e 94 c3 03 	call	0x786	; 0x786 <tinyCharge_is_connected_to_charger>
     12c:	88 23       	and	r24, r24
     12e:	b9 f0       	breq	.+46     	; 0x15e <main+0x58>
				// Charge loop
				
				if(tinyCharge_is_fully_charged()){
     130:	0e 94 c6 03 	call	0x78c	; 0x78c <tinyCharge_is_fully_charged>
     134:	88 23       	and	r24, r24
     136:	49 f0       	breq	.+18     	; 0x14a <main+0x44>
					// When the neuron is connected to a charger, and fully charged:
					tinyLED_set_color(INN_LED, CHARGING_DONE_COLOR);
     138:	63 e0       	ldi	r22, 0x03	; 3
     13a:	80 e0       	ldi	r24, 0x00	; 0
     13c:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <tinyLED_set_color>
					tinyLED_set_color(OUT_LED, LED_OFF);
     140:	60 e0       	ldi	r22, 0x00	; 0
     142:	81 e0       	ldi	r24, 0x01	; 1
     144:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <tinyLED_set_color>
     148:	11 c0       	rjmp	.+34     	; 0x16c <main+0x66>
				}
				else{
					// When the neuron is charging and is not fully charged
					tinyLED_set_color_mode(OUT_LED, CHARGING_COLOR, SWING);
     14a:	43 e0       	ldi	r20, 0x03	; 3
     14c:	61 e0       	ldi	r22, 0x01	; 1
     14e:	81 e0       	ldi	r24, 0x01	; 1
     150:	0e 94 bb 05 	call	0xb76	; 0xb76 <tinyLED_set_color_mode>
					tinyLED_set_color(INN_LED, LED_OFF);
     154:	60 e0       	ldi	r22, 0x00	; 0
     156:	80 e0       	ldi	r24, 0x00	; 0
     158:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <tinyLED_set_color>
     15c:	07 c0       	rjmp	.+14     	; 0x16c <main+0x66>
				// Main loop			
				
				// Set LED
				// If the out led is turned LED_OFF, and the ping color is not disabled,
				// we turn on ping mode
				if(tinyLED_get_color(OUT_LED) == LED_OFF && PING_COLOR != LED_OFF){
     15e:	81 e0       	ldi	r24, 0x01	; 1
     160:	0e 94 b3 05 	call	0xb66	; 0xb66 <tinyLED_get_color>
					tinyLED_set_color_mode(OUT_LED, PING_COLOR, PING);
				}				
				
				// Update button	
				tinyButton_update();
     164:	0e 94 5d 03 	call	0x6ba	; 0x6ba <tinyButton_update>
				
				// Update the potential (This is where most of the important stuff happens)
				tinyPotential_update();
     168:	0e 94 57 08 	call	0x10ae	; 0x10ae <tinyPotential_update>
			}
			
			// Update LED
			tinyLED_update();
     16c:	0e 94 25 06 	call	0xc4a	; 0xc4a <tinyLED_update>
				
			// Switch transistors
			tinyCharge_set_transistors();
     170:	0e 94 38 04 	call	0x870	; 0x870 <tinyCharge_set_transistors>
			
			// Prepare for next cycle
			tinyISR_setflag(false);
     174:	80 e0       	ldi	r24, 0x00	; 0
     176:	0e 94 87 05 	call	0xb0e	; 0xb0e <tinyISR_setflag>
			tinyDebugger_send_uint32("time", tinyTime_now());
     17a:	0e 94 61 09 	call	0x12c2	; 0x12c2 <tinyTime_now>
     17e:	ab 01       	movw	r20, r22
     180:	bc 01       	movw	r22, r24
     182:	88 e4       	ldi	r24, 0x48	; 72
     184:	9a e9       	ldi	r25, 0x9A	; 154
     186:	0e 94 42 04 	call	0x884	; 0x884 <tinyDebugger_send_uint32>
			tinyDebugger_end_line();
     18a:	0e 94 45 04 	call	0x88a	; 0x88a <tinyDebugger_end_line>
     18e:	c6 cf       	rjmp	.-116    	; 0x11c <main+0x16>

00000190 <ADC_0_init>:
 * \return Conversion result read from the ADC_0 ADC module
 */
adc_result_t ADC_0_get_conversion_result(void)
{
	return (ADC1.RES);
}
     190:	e0 e4       	ldi	r30, 0x40	; 64
     192:	f6 e0       	ldi	r31, 0x06	; 6
     194:	80 e1       	ldi	r24, 0x10	; 16
     196:	82 83       	std	Z+2, r24	; 0x02
     198:	85 e0       	ldi	r24, 0x05	; 5
     19a:	80 83       	st	Z, r24
     19c:	80 e0       	ldi	r24, 0x00	; 0
     19e:	08 95       	ret

000001a0 <ADC_0_is_conversion_done>:
     1a0:	80 91 4b 06 	lds	r24, 0x064B	; 0x80064b <__TEXT_REGION_LENGTH__+0x70064b>
     1a4:	81 70       	andi	r24, 0x01	; 1
     1a6:	08 95       	ret

000001a8 <ADC_0_get_conversion>:
 *
 * \return Nothing
 */
void ADC_0_start_conversion(adc_1_channel_t channel)
{
	ADC1.MUXPOS  = channel;
     1a8:	e0 e4       	ldi	r30, 0x40	; 64
     1aa:	f6 e0       	ldi	r31, 0x06	; 6
     1ac:	86 83       	std	Z+6, r24	; 0x06
	ADC1.COMMAND = ADC_STCONV_bm;
     1ae:	81 e0       	ldi	r24, 0x01	; 1
     1b0:	80 87       	std	Z+8, r24	; 0x08
adc_result_t ADC_0_get_conversion(adc_1_channel_t channel)
{
	adc_result_t res;

	ADC_0_start_conversion(channel);
	while (!ADC_0_is_conversion_done())
     1b2:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <ADC_0_is_conversion_done>
     1b6:	88 23       	and	r24, r24
     1b8:	e1 f3       	breq	.-8      	; 0x1b2 <ADC_0_get_conversion+0xa>
 *
 * \return Conversion result read from the ADC_0 ADC module
 */
adc_result_t ADC_0_get_conversion_result(void)
{
	return (ADC1.RES);
     1ba:	e0 e4       	ldi	r30, 0x40	; 64
     1bc:	f6 e0       	ldi	r31, 0x06	; 6
     1be:	20 89       	ldd	r18, Z+16	; 0x10
     1c0:	31 89       	ldd	r19, Z+17	; 0x11

	ADC_0_start_conversion(channel);
	while (!ADC_0_is_conversion_done())
		;
	res = ADC_0_get_conversion_result();
	ADC1.INTFLAGS |= ADC_RESRDY_bm;
     1c2:	93 85       	ldd	r25, Z+11	; 0x0b
     1c4:	91 60       	ori	r25, 0x01	; 1
     1c6:	93 87       	std	Z+11, r25	; 0x0b
	return res;
}
     1c8:	c9 01       	movw	r24, r18
     1ca:	08 95       	ret

000001cc <BOD_init>:
	//		 | BOD_VLMCFG_BELOW_gc; /* Interrupt when supply goes below VLM level */

	// BOD.VLMCTRLA = BOD_VLMLVL_5ABOVE_gc; /* VLM threshold 5% above BOD level */

	return 0;
}
     1cc:	80 e0       	ldi	r24, 0x00	; 0
     1ce:	08 95       	ret

000001d0 <DIGITAL_GLUE_LOGIC_0_init>:

	// Enable Protected register, peripheral must be disabled (ENABLE=0, in TCD.LUT0CTRLA).

	// CCL.SEQCTRL0 = CCL_SEQSEL_DISABLE_gc /* Sequential logic disabled */;

	CCL.TRUTH0 = 168; /* Truth 0: 168 */
     1d0:	e0 ec       	ldi	r30, 0xC0	; 192
     1d2:	f1 e0       	ldi	r31, 0x01	; 1
     1d4:	28 ea       	ldi	r18, 0xA8	; 168
     1d6:	20 87       	std	Z+8, r18	; 0x08

	CCL.LUT0CTRLC = CCL_INSEL2_TCA0_gc /* TCA0 WO2 input source */;
     1d8:	98 e0       	ldi	r25, 0x08	; 8
     1da:	97 83       	std	Z+7, r25	; 0x07

	CCL.LUT0CTRLB = CCL_INSEL0_SPI0_gc /* SPI0 SCK source */
     1dc:	8b eb       	ldi	r24, 0xBB	; 187
     1de:	86 83       	std	Z+6, r24	; 0x06
	                | CCL_INSEL1_SPI0_gc /* SPI0 MOSI input source */;

	CCL.LUT0CTRLA = 0 << CCL_CLKSRC_bp       /* Clock Source Selection: disabled */
     1e0:	39 e0       	ldi	r19, 0x09	; 9
     1e2:	35 83       	std	Z+5, r19	; 0x05
	                | CCL_EDGEDET_DIS_gc     /* Edge detector is disabled */
	                | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	                | 1 << CCL_ENABLE_bp     /* LUT Enable: enabled */
	                | 1 << CCL_OUTEN_bp;     /* Output Enable: enabled */

	CCL.TRUTH1 = 168; /* Truth 1: 168 */
     1e4:	24 87       	std	Z+12, r18	; 0x0c

	CCL.LUT1CTRLC = CCL_INSEL2_TCA0_gc /* TCA0 WO2 input source */;
     1e6:	93 87       	std	Z+11, r25	; 0x0b

	CCL.LUT1CTRLB = CCL_INSEL0_SPI0_gc /* SPI0 SCK source */
     1e8:	82 87       	std	Z+10, r24	; 0x0a
	//		 | CCL_EDGEDET_DIS_gc /* Edge detector is disabled */
	//		 | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	//		 | 0 << CCL_ENABLE_bp /* LUT Enable: disabled */
	//		 | 0 << CCL_OUTEN_bp; /* Output Enable: disabled */

	CCL.CTRLA = 1 << CCL_ENABLE_bp      /* Enable: enabled */
     1ea:	81 e4       	ldi	r24, 0x41	; 65
     1ec:	80 83       	st	Z, r24
	            | 1 << CCL_RUNSTDBY_bp; /* Run in Standby: enabled */

	return 0;
}
     1ee:	80 e0       	ldi	r24, 0x00	; 0
     1f0:	08 95       	ret

000001f2 <CLKCTRL_init>:
 *       on calling convention. The memory model is not visible to the
 *       preprocessor, so it must be defined in the Assembler preprocessor directives.
 */
static inline void ccp_write_io(void *addr, uint8_t value)
{
	protected_write_io(addr, CCP_IOREG_gc, value);
     1f2:	47 e0       	ldi	r20, 0x07	; 7
     1f4:	68 ed       	ldi	r22, 0xD8	; 216
     1f6:	8c e7       	ldi	r24, 0x7C	; 124
     1f8:	90 e0       	ldi	r25, 0x00	; 0
     1fa:	0e 94 d8 01 	call	0x3b0	; 0x3b0 <protected_write_io>
     1fe:	41 e0       	ldi	r20, 0x01	; 1
     200:	68 ed       	ldi	r22, 0xD8	; 216
     202:	81 e6       	ldi	r24, 0x61	; 97
     204:	90 e0       	ldi	r25, 0x00	; 0
     206:	0e 94 d8 01 	call	0x3b0	; 0x3b0 <protected_write_io>
	//		 | 0 << CLKCTRL_CLKOUT_bp /* System clock out: disabled */);

	// ccp_write_io((void*)&(CLKCTRL.MCLKLOCK),0 << CLKCTRL_LOCKEN_bp /* lock enable: disabled */);

	return 0;
}
     20a:	80 e0       	ldi	r24, 0x00	; 0
     20c:	08 95       	ret

0000020e <CPUINT_init>:

	// CPUINT.LVL0PRI = 0x0 << CPUINT_LVL0PRI_gp; /* Interrupt Level Priority: 0x0 */

	// CPUINT.LVL1VEC = 0x0 << CPUINT_LVL1VEC_gp; /* Interrupt Vector with High Priority: 0x0 */

	ENABLE_INTERRUPTS();
     20e:	78 94       	sei

	return 0;
}
     210:	80 e0       	ldi	r24, 0x00	; 0
     212:	08 95       	ret

00000214 <DAC_0_init>:
int8_t DAC_0_init()
{

	// DAC0.DATA = 0x0; /* DATA Register: 0x0 */

	DAC0.CTRLA = 1 << DAC_ENABLE_bp      /* DAC Enable: enabled */
     214:	81 e4       	ldi	r24, 0x41	; 65
     216:	80 93 a0 06 	sts	0x06A0, r24	; 0x8006a0 <__TEXT_REGION_LENGTH__+0x7006a0>
	             | 1 << DAC_OUTEN_bp     /* Output Buffer Enable: enabled */
	             | 0 << DAC_RUNSTDBY_bp; /* Run in Standby Mode: disabled */

	return 0;
}
     21a:	80 e0       	ldi	r24, 0x00	; 0
     21c:	08 95       	ret

0000021e <DAC_0_uninit>:
int8_t DAC_0_uninit()
{

	// DAC0.DATA = 0x0; /* DATA Register: 0x0 */

	DAC0.CTRLA = 1 << DAC_ENABLE_bp      /* DAC Enable: enabled */
     21e:	81 e0       	ldi	r24, 0x01	; 1
     220:	80 93 a0 06 	sts	0x06A0, r24	; 0x8006a0 <__TEXT_REGION_LENGTH__+0x7006a0>
	| 0 << DAC_OUTEN_bp     /* Output Buffer Enable: disabled */
	| 0 << DAC_RUNSTDBY_bp; /* Run in Standby Mode: disabled */

	return 0;
}
     224:	80 e0       	ldi	r24, 0x00	; 0
     226:	08 95       	ret

00000228 <DAC_0_enable>:
 *
 * \return Nothing
 */
void DAC_0_enable()
{
	DAC0.CTRLA |= DAC_ENABLE_bm;
     228:	e0 ea       	ldi	r30, 0xA0	; 160
     22a:	f6 e0       	ldi	r31, 0x06	; 6
     22c:	80 81       	ld	r24, Z
     22e:	81 60       	ori	r24, 0x01	; 1
     230:	80 83       	st	Z, r24
     232:	08 95       	ret

00000234 <DAC_0_disable>:
 *
 * \return Nothing
 */
void DAC_0_disable()
{
	DAC0.CTRLA &= ~DAC_ENABLE_bm;
     234:	e0 ea       	ldi	r30, 0xA0	; 160
     236:	f6 e0       	ldi	r31, 0x06	; 6
     238:	80 81       	ld	r24, Z
     23a:	8e 7f       	andi	r24, 0xFE	; 254
     23c:	80 83       	st	Z, r24
     23e:	08 95       	ret

00000240 <DAC_0_set_output>:
 *
 * \return Nothing
 */
void DAC_0_set_output(dac_resolution_t value)
{
	DAC0.DATA = value;
     240:	80 93 a1 06 	sts	0x06A1, r24	; 0x8006a1 <__TEXT_REGION_LENGTH__+0x7006a1>
     244:	08 95       	ret

00000246 <mcu_init>:
#ifdef __cplusplus
extern "C" {
#endif

void mcu_init(void)
{
     246:	e0 e1       	ldi	r30, 0x10	; 16
     248:	f4 e0       	ldi	r31, 0x04	; 4
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     24a:	80 81       	ld	r24, Z
     24c:	88 60       	ori	r24, 0x08	; 8
     24e:	81 93       	st	Z+, r24
	 * disables all peripherals to save power. Driver shall enable
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
     250:	e8 31       	cpi	r30, 0x18	; 24
     252:	84 e0       	ldi	r24, 0x04	; 4
     254:	f8 07       	cpc	r31, r24
     256:	c9 f7       	brne	.-14     	; 0x24a <mcu_init+0x4>
     258:	e0 e3       	ldi	r30, 0x30	; 48
     25a:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     25c:	80 81       	ld	r24, Z
     25e:	88 60       	ori	r24, 0x08	; 8
     260:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     262:	e8 33       	cpi	r30, 0x38	; 56
     264:	84 e0       	ldi	r24, 0x04	; 4
     266:	f8 07       	cpc	r31, r24
     268:	c9 f7       	brne	.-14     	; 0x25c <mcu_init+0x16>
     26a:	e0 e5       	ldi	r30, 0x50	; 80
     26c:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     26e:	80 81       	ld	r24, Z
     270:	88 60       	ori	r24, 0x08	; 8
     272:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     274:	e8 35       	cpi	r30, 0x58	; 88
     276:	84 e0       	ldi	r24, 0x04	; 4
     278:	f8 07       	cpc	r31, r24
     27a:	c9 f7       	brne	.-14     	; 0x26e <mcu_init+0x28>
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}
}
     27c:	08 95       	ret

0000027e <ADC_0_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     27e:	e5 e1       	ldi	r30, 0x15	; 21
     280:	f4 e0       	ldi	r31, 0x04	; 4
     282:	80 81       	ld	r24, Z
     284:	88 7f       	andi	r24, 0xF8	; 248
     286:	84 60       	ori	r24, 0x04	; 4
     288:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     28a:	80 81       	ld	r24, Z
     28c:	87 7f       	andi	r24, 0xF7	; 247
     28e:	80 83       	st	Z, r24
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     290:	e7 e1       	ldi	r30, 0x17	; 23
     292:	f4 e0       	ldi	r31, 0x04	; 4
     294:	80 81       	ld	r24, Z
     296:	88 7f       	andi	r24, 0xF8	; 248
     298:	84 60       	ori	r24, 0x04	; 4
     29a:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     29c:	80 81       	ld	r24, Z
     29e:	87 7f       	andi	r24, 0xF7	; 247
     2a0:	80 83       	st	Z, r24
 */
static inline void PORTC_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     2a2:	e0 e5       	ldi	r30, 0x50	; 80
     2a4:	f4 e0       	ldi	r31, 0x04	; 4
     2a6:	80 81       	ld	r24, Z
     2a8:	88 7f       	andi	r24, 0xF8	; 248
     2aa:	84 60       	ori	r24, 0x04	; 4
     2ac:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2ae:	80 81       	ld	r24, Z
     2b0:	87 7f       	andi	r24, 0xF7	; 247
     2b2:	80 83       	st	Z, r24
 */
static inline void PORTC_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     2b4:	e1 e5       	ldi	r30, 0x51	; 81
     2b6:	f4 e0       	ldi	r31, 0x04	; 4
     2b8:	80 81       	ld	r24, Z
     2ba:	88 7f       	andi	r24, 0xF8	; 248
     2bc:	84 60       	ori	r24, 0x04	; 4
     2be:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2c0:	80 81       	ld	r24, Z
     2c2:	87 7f       	andi	r24, 0xF7	; 247
     2c4:	80 83       	st	Z, r24
 */
static inline void PORTC_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     2c6:	e3 e5       	ldi	r30, 0x53	; 83
     2c8:	f4 e0       	ldi	r31, 0x04	; 4
     2ca:	80 81       	ld	r24, Z
     2cc:	88 7f       	andi	r24, 0xF8	; 248
     2ce:	84 60       	ori	r24, 0x04	; 4
     2d0:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2d2:	80 81       	ld	r24, Z
     2d4:	87 7f       	andi	r24, 0xF7	; 247
     2d6:	80 83       	st	Z, r24
	// Disable digital input buffer
	DEN4_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	DEN4_PIN_set_pull_mode(PORT_PULL_OFF);

	ADC_0_init();
     2d8:	0e 94 c8 00 	call	0x190	; 0x190 <ADC_0_init>
     2dc:	08 95       	ret

000002de <USART_0_initialization>:
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     2de:	23 98       	cbi	0x04, 3	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2e0:	e3 e3       	ldi	r30, 0x33	; 51
     2e2:	f4 e0       	ldi	r31, 0x04	; 4
     2e4:	80 81       	ld	r24, Z
     2e6:	87 7f       	andi	r24, 0xF7	; 247
     2e8:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     2ea:	22 9a       	sbi	0x04, 2	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     2ec:	2a 98       	cbi	0x05, 2	; 5
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	USART_0_init();
     2ee:	0e 94 10 02 	call	0x420	; 0x420 <USART_0_init>
     2f2:	08 95       	ret

000002f4 <TIMER_0_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     2f4:	25 9a       	sbi	0x04, 5	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     2f6:	2d 98       	cbi	0x05, 5	; 5
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLC |= PORTMUX_TCA02_bm;
     2f8:	e0 e0       	ldi	r30, 0x00	; 0
     2fa:	f2 e0       	ldi	r31, 0x02	; 2
     2fc:	82 81       	ldd	r24, Z+2	; 0x02
     2fe:	84 60       	ori	r24, 0x04	; 4
     300:	82 83       	std	Z+2, r24	; 0x02

	TIMER_0_init();
     302:	0e 94 00 02 	call	0x400	; 0x400 <TIMER_0_init>
     306:	08 95       	ret

00000308 <DIGITAL_GLUE_LOGIC_0_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     308:	24 9a       	sbi	0x04, 4	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     30a:	2c 98       	cbi	0x05, 4	; 5
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLA |= PORTMUX_LUT0_bm;
     30c:	e0 e0       	ldi	r30, 0x00	; 0
     30e:	f2 e0       	ldi	r31, 0x02	; 2
     310:	80 81       	ld	r24, Z
     312:	80 61       	ori	r24, 0x10	; 16
     314:	80 83       	st	Z, r24

	DIGITAL_GLUE_LOGIC_0_init();
     316:	0e 94 e8 00 	call	0x1d0	; 0x1d0 <DIGITAL_GLUE_LOGIC_0_init>
     31a:	08 95       	ret

0000031c <SPI_0_initialization>:
 */
static inline void PORTA_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
     31c:	02 98       	cbi	0x00, 2	; 0
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     31e:	e2 e1       	ldi	r30, 0x12	; 18
     320:	f4 e0       	ldi	r31, 0x04	; 4
     322:	80 81       	ld	r24, Z
     324:	87 7f       	andi	r24, 0xF7	; 247
     326:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     328:	01 9a       	sbi	0x00, 1	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     32a:	09 98       	cbi	0x01, 1	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     32c:	03 9a       	sbi	0x00, 3	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     32e:	0b 98       	cbi	0x01, 3	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     330:	04 9a       	sbi	0x00, 4	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     332:	0c 98       	cbi	0x01, 4	; 1
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	SPI_0_init();
     334:	0e 94 f8 01 	call	0x3f0	; 0x3f0 <SPI_0_init>
     338:	08 95       	ret

0000033a <DAC_0_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     33a:	e6 e1       	ldi	r30, 0x16	; 22
     33c:	f4 e0       	ldi	r31, 0x04	; 4
     33e:	80 81       	ld	r24, Z
     340:	88 7f       	andi	r24, 0xF8	; 248
     342:	84 60       	ori	r24, 0x04	; 4
     344:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     346:	80 81       	ld	r24, Z
     348:	87 7f       	andi	r24, 0xF7	; 247
     34a:	80 83       	st	Z, r24
	// Disable digital input buffer
	AXON_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	AXON_PIN_set_pull_mode(PORT_PULL_OFF);

	DAC_0_init();
     34c:	0e 94 0a 01 	call	0x214	; 0x214 <DAC_0_init>
     350:	08 95       	ret

00000352 <system_init>:
/**
 * \brief System initialization
 */
void system_init()
{
	mcu_init();
     352:	0e 94 23 01 	call	0x246	; 0x246 <mcu_init>
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     356:	21 9a       	sbi	0x04, 1	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     358:	29 98       	cbi	0x05, 1	; 5
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     35a:	26 98       	cbi	0x04, 6	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     35c:	e6 e3       	ldi	r30, 0x36	; 54
     35e:	f4 e0       	ldi	r31, 0x04	; 4
     360:	80 81       	ld	r24, Z
     362:	87 7f       	andi	r24, 0xF7	; 247
     364:	80 83       	st	Z, r24
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     366:	27 98       	cbi	0x04, 7	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     368:	e7 e3       	ldi	r30, 0x37	; 55
     36a:	f4 e0       	ldi	r31, 0x04	; 4
     36c:	80 81       	ld	r24, Z
     36e:	87 7f       	andi	r24, 0xF7	; 247
     370:	80 83       	st	Z, r24
 */
static inline void PORTC_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
     372:	42 98       	cbi	0x08, 2	; 8
static inline void PORTC_set_pin_pull_mode(const uint8_t pin, const enum port_pull_mode pull_mode)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
     374:	e2 e5       	ldi	r30, 0x52	; 82
     376:	f4 e0       	ldi	r31, 0x04	; 4
     378:	80 81       	ld	r24, Z
     37a:	88 60       	ori	r24, 0x08	; 8
     37c:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTC.DIR |= (1 << pin);
     37e:	45 9a       	sbi	0x08, 5	; 8
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     380:	4d 9a       	sbi	0x09, 5	; 9
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    true);

	CLKCTRL_init();
     382:	0e 94 f9 00 	call	0x1f2	; 0x1f2 <CLKCTRL_init>

	RTC_0_init();
     386:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <RTC_0_init>

	ADC_0_initialization();
     38a:	0e 94 3f 01 	call	0x27e	; 0x27e <ADC_0_initialization>

	USART_0_initialization();
     38e:	0e 94 6f 01 	call	0x2de	; 0x2de <USART_0_initialization>

	TIMER_0_initialization();
     392:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <TIMER_0_initialization>

	DIGITAL_GLUE_LOGIC_0_initialization();
     396:	0e 94 84 01 	call	0x308	; 0x308 <DIGITAL_GLUE_LOGIC_0_initialization>

	SPI_0_initialization();
     39a:	0e 94 8e 01 	call	0x31c	; 0x31c <SPI_0_initialization>

	DAC_0_initialization();
     39e:	0e 94 9d 01 	call	0x33a	; 0x33a <DAC_0_initialization>

	CPUINT_init();
     3a2:	0e 94 07 01 	call	0x20e	; 0x20e <CPUINT_init>

	SLPCTRL_init();
     3a6:	0e 94 f6 01 	call	0x3ec	; 0x3ec <SLPCTRL_init>

	BOD_init();
     3aa:	0e 94 e6 00 	call	0x1cc	; 0x1cc <BOD_init>
     3ae:	08 95       	ret

000003b0 <protected_write_io>:
#if defined(__GNUC__)
  
#ifdef RAMPZ
	out     _SFR_IO_ADDR(RAMPZ), r1         // Clear bits 23:16 of Z
#endif
	movw    r30, r24                // Load addr into Z
     3b0:	fc 01       	movw	r30, r24
	out     CCP, r22                // Start CCP handshake
     3b2:	64 bf       	out	0x34, r22	; 52
	st      Z, r20                  // Write value to I/O register
     3b4:	40 83       	st	Z, r20
	ret                             // Return to caller
     3b6:	08 95       	ret

000003b8 <RTC_0_init>:
 * \return Initialization status.
 */
int8_t RTC_0_init()
{

	while (RTC.STATUS > 0) { /* Wait for all register to be synchronized */
     3b8:	e0 e4       	ldi	r30, 0x40	; 64
     3ba:	f1 e0       	ldi	r31, 0x01	; 1
     3bc:	81 81       	ldd	r24, Z+1	; 0x01
     3be:	81 11       	cpse	r24, r1
     3c0:	fd cf       	rjmp	.-6      	; 0x3bc <RTC_0_init+0x4>
	}

	// RTC.CMP = 0x0; /* Compare: 0x0 */

	RTC.CNT = 0x20; /* Counter: 0x20 */
     3c2:	e0 e4       	ldi	r30, 0x40	; 64
     3c4:	f1 e0       	ldi	r31, 0x01	; 1
     3c6:	80 e2       	ldi	r24, 0x20	; 32
     3c8:	90 e0       	ldi	r25, 0x00	; 0
     3ca:	80 87       	std	Z+8, r24	; 0x08
     3cc:	91 87       	std	Z+9, r25	; 0x09

	RTC.CTRLA = RTC_PRESCALER_DIV1_gc   /* 1 */
     3ce:	21 e8       	ldi	r18, 0x81	; 129
     3d0:	20 83       	st	Z, r18
	            | 1 << RTC_RTCEN_bp     /* Enable: enabled */
	            | 1 << RTC_RUNSTDBY_bp; /* Run In Standby: enabled */

	RTC.PER = 0x20 / TIMESCALE; /* Period: 0x20 */
     3d2:	82 87       	std	Z+10, r24	; 0x0a
     3d4:	93 87       	std	Z+11, r25	; 0x0b

	// RTC.CLKSEL = RTC_CLKSEL_INT32K_gc; /* 32KHz Internal Ultra Low Power Oscillator (OSCULP32K) */

	RTC.DBGCTRL = 1 << RTC_DBGRUN_bp; /* Run in debug: enabled */
     3d6:	81 e0       	ldi	r24, 0x01	; 1
     3d8:	85 83       	std	Z+5, r24	; 0x05

	RTC.INTCTRL = 0 << RTC_CMP_bp    /* Compare Match Interrupt enable: disabled */
     3da:	82 83       	std	Z+2, r24	; 0x02
	              | 1 << RTC_OVF_bp; /* Overflow Interrupt enable: enabled */

	while (RTC.PITSTATUS > 0) { /* Wait for all register to be synchronized */
     3dc:	81 89       	ldd	r24, Z+17	; 0x11
     3de:	81 11       	cpse	r24, r1
     3e0:	fd cf       	rjmp	.-6      	; 0x3dc <RTC_0_init+0x24>
	}

	RTC.PITCTRLA = RTC_PERIOD_OFF_gc    /* Off */
     3e2:	81 e0       	ldi	r24, 0x01	; 1
     3e4:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <__TEXT_REGION_LENGTH__+0x700150>
	// RTC.PITDBGCTRL = 0 << RTC_DBGRUN_bp; /* Run in debug: disabled */

	// RTC.PITINTCTRL = 0 << RTC_PI_bp; /* Periodic Interrupt: disabled */

	return 0;
}
     3e8:	80 e0       	ldi	r24, 0x00	; 0
     3ea:	08 95       	ret

000003ec <SLPCTRL_init>:

	// SLPCTRL.CTRLA = 0 << SLPCTRL_SEN_bp /* Sleep enable: disabled */
	//		 | SLPCTRL_SMODE_IDLE_gc; /* Idle mode */

	return 0;
}
     3ec:	80 e0       	ldi	r24, 0x00	; 0
     3ee:	08 95       	ret

000003f0 <SPI_0_init>:
 * \return Initialization status
 */
int8_t SPI_0_init()
{

	SPI0.CTRLA = 0 << SPI_CLK2X_bp     /* Enable Double Speed: disabled */
     3f0:	e0 e2       	ldi	r30, 0x20	; 32
     3f2:	f8 e0       	ldi	r31, 0x08	; 8
     3f4:	83 e2       	ldi	r24, 0x23	; 35
     3f6:	80 83       	st	Z, r24
	             | 0 << SPI_DORD_bp    /* Data Order Setting: disabled */
	             | 1 << SPI_ENABLE_bp  /* Enable Module: enabled */
	             | 1 << SPI_MASTER_bp  /* SPI module in master mode */
	             | SPI_PRESC_DIV16_gc; /* System Clock / 16 */

	SPI0.CTRLB = 0 << SPI_BUFEN_bp   /* Buffer Mode Enable: disabled */
     3f8:	84 e0       	ldi	r24, 0x04	; 4
     3fa:	81 83       	std	Z+1, r24	; 0x01
	//		 | 0 << SPI_RXCIE_bp /* Receive Complete Interrupt Enable: disabled */
	//		 | 0 << SPI_SSIE_bp /* Slave Select Trigger Interrupt Enable: disabled */
	//		 | 0 << SPI_TXCIE_bp; /* Transfer Complete Interrupt Enable: disabled */

	return 0;
}
     3fc:	80 e0       	ldi	r24, 0x00	; 0
     3fe:	08 95       	ret

00000400 <TIMER_0_init>:

	// TCA0.SINGLE.CMP0 = 0x0; /* Compare Register 0: 0x0 */

	// TCA0.SINGLE.CMP1 = 0x0; /* Compare Register 1: 0x0 */

	TCA0.SINGLE.CMP2 = 0x4; /* Compare Register 2: 0x4 */
     400:	e0 e0       	ldi	r30, 0x00	; 0
     402:	fa e0       	ldi	r31, 0x0A	; 10
     404:	84 e0       	ldi	r24, 0x04	; 4
     406:	90 e0       	ldi	r25, 0x00	; 0
     408:	84 a7       	std	Z+44, r24	; 0x2c
     40a:	95 a7       	std	Z+45, r25	; 0x2d

	// TCA0.SINGLE.CNT = 0x0; /* Count: 0x0 */

	TCA0.SINGLE.CTRLB = 0 << TCA_SINGLE_ALUPD_bp            /* Auto Lock Update: disabled */
     40c:	83 e4       	ldi	r24, 0x43	; 67
     40e:	81 83       	std	Z+1, r24	; 0x01
	                    | 0 << TCA_SINGLE_CMP0EN_bp         /* Compare 0 Enable: disabled */
	                    | 0 << TCA_SINGLE_CMP1EN_bp         /* Compare 1 Enable: disabled */
	                    | 1 << TCA_SINGLE_CMP2EN_bp         /* Compare 2 Enable: enabled */
	                    | TCA_SINGLE_WGMODE_SINGLESLOPE_gc; /*  */

	TCA0.SINGLE.CTRLC = 0 << TCA_SINGLE_CMP0OV_bp    /* Compare 0 Waveform Output Value: disabled */
     410:	84 e0       	ldi	r24, 0x04	; 4
     412:	82 83       	std	Z+2, r24	; 0x02
	// TCA0.SINGLE.INTCTRL = 0 << TCA_SINGLE_CMP0_bp /* Compare 0 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP1_bp /* Compare 1 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP2_bp /* Compare 2 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_OVF_bp; /* Overflow Interrupt: disabled */

	TCA0.SINGLE.PER = 0x7; /* Period: 0x7 */
     414:	87 e0       	ldi	r24, 0x07	; 7
     416:	90 e0       	ldi	r25, 0x00	; 0
     418:	86 a3       	std	Z+38, r24	; 0x26
     41a:	97 a3       	std	Z+39, r25	; 0x27

	// TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV1_gc /* System Clock */
	//		 | 0 << TCA_SINGLE_ENABLE_bp; /* Module Enable: disabled */

	return 0;
}
     41c:	80 e0       	ldi	r24, 0x00	; 0
     41e:	08 95       	ret

00000420 <USART_0_init>:
uint8_t USART_0_read()
{
	while (!(USART0.STATUS & USART_RXCIF_bm))
		;
	return USART0.RXDATAL;
}
     420:	e0 e0       	ldi	r30, 0x00	; 0
     422:	f8 e0       	ldi	r31, 0x08	; 8
     424:	8b e5       	ldi	r24, 0x5B	; 91
     426:	91 e0       	ldi	r25, 0x01	; 1
     428:	80 87       	std	Z+8, r24	; 0x08
     42a:	91 87       	std	Z+9, r25	; 0x09
     42c:	80 ec       	ldi	r24, 0xC0	; 192
     42e:	86 83       	std	Z+6, r24	; 0x06
     430:	80 e0       	ldi	r24, 0x00	; 0
     432:	98 e3       	ldi	r25, 0x38	; 56
     434:	80 93 8f 38 	sts	0x388F, r24	; 0x80388f <__iob+0x2>
     438:	90 93 90 38 	sts	0x3890, r25	; 0x803890 <__iob+0x3>
     43c:	80 e0       	ldi	r24, 0x00	; 0
     43e:	08 95       	ret

00000440 <USART_0_write>:
 *
 * \return Nothing
 */
void USART_0_write(const uint8_t data)
{
	while (!(USART0.STATUS & USART_DREIF_bm))
     440:	e0 e0       	ldi	r30, 0x00	; 0
     442:	f8 e0       	ldi	r31, 0x08	; 8
     444:	94 81       	ldd	r25, Z+4	; 0x04
     446:	95 ff       	sbrs	r25, 5
     448:	fd cf       	rjmp	.-6      	; 0x444 <USART_0_write+0x4>
		;
	USART0.TXDATAL = data;
     44a:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <__TEXT_REGION_LENGTH__+0x700802>
     44e:	08 95       	ret

00000450 <USART_0_printCHAR>:

#if defined(__GNUC__)

int USART_0_printCHAR(char character, FILE *stream)
{
	USART_0_write(character);
     450:	0e 94 20 02 	call	0x440	; 0x440 <USART_0_write>
	return 0;
}
     454:	80 e0       	ldi	r24, 0x00	; 0
     456:	90 e0       	ldi	r25, 0x00	; 0
     458:	08 95       	ret

0000045a <tinyAxon_add_pulse>:
{
	// We want to check each slot in the pulse_queue, and
	// if we find an empty slot (0), we add a pulse.
	for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
	{
		if(pulse_queue[i] == 0){
     45a:	20 91 16 38 	lds	r18, 0x3816	; 0x803816 <__data_end>
     45e:	30 91 17 38 	lds	r19, 0x3817	; 0x803817 <__data_end+0x1>
     462:	23 2b       	or	r18, r19
     464:	51 f0       	breq	.+20     	; 0x47a <tinyAxon_add_pulse+0x20>
     466:	e8 e1       	ldi	r30, 0x18	; 24
     468:	f8 e3       	ldi	r31, 0x38	; 56
     46a:	21 e0       	ldi	r18, 0x01	; 1
     46c:	30 e0       	ldi	r19, 0x00	; 0
     46e:	b9 01       	movw	r22, r18
     470:	41 91       	ld	r20, Z+
     472:	51 91       	ld	r21, Z+
     474:	45 2b       	or	r20, r21
     476:	81 f4       	brne	.+32     	; 0x498 <tinyAxon_add_pulse+0x3e>
     478:	02 c0       	rjmp	.+4      	; 0x47e <tinyAxon_add_pulse+0x24>
     47a:	60 e0       	ldi	r22, 0x00	; 0
     47c:	70 e0       	ldi	r23, 0x00	; 0
			pulse_queue[i] = new_pulse;
     47e:	66 0f       	add	r22, r22
     480:	77 1f       	adc	r23, r23
     482:	fb 01       	movw	r30, r22
     484:	ea 5e       	subi	r30, 0xEA	; 234
     486:	f7 4c       	sbci	r31, 0xC7	; 199
     488:	80 83       	st	Z, r24
     48a:	91 83       	std	Z+1, r25	; 0x01
			pulses_in_queue++;
     48c:	80 91 2a 38 	lds	r24, 0x382A	; 0x80382a <pulses_in_queue>
     490:	8f 5f       	subi	r24, 0xFF	; 255
     492:	80 93 2a 38 	sts	0x382A, r24	; 0x80382a <pulses_in_queue>
			// We return so we only ever add one
			break;
     496:	08 95       	ret
     498:	2f 5f       	subi	r18, 0xFF	; 255
     49a:	3f 4f       	sbci	r19, 0xFF	; 255
*/
static void tinyAxon_add_pulse(uint16_t new_pulse)
{
	// We want to check each slot in the pulse_queue, and
	// if we find an empty slot (0), we add a pulse.
	for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
     49c:	2a 30       	cpi	r18, 0x0A	; 10
     49e:	31 05       	cpc	r19, r1
     4a0:	31 f7       	brne	.-52     	; 0x46e <tinyAxon_add_pulse+0x14>
     4a2:	08 95       	ret

000004a4 <tinyAxon_is_firing>:
// DAC has no DAC_0_get_output, so we keep track of this here.
uint8_t axonOutputValue = 0;


_Bool tinyAxon_is_firing(){
	return axonOutputValue != NO_SIGNAL_OUTPUT;
     4a4:	81 e0       	ldi	r24, 0x01	; 1
     4a6:	90 91 2b 38 	lds	r25, 0x382B	; 0x80382b <axonOutputValue>
     4aa:	91 11       	cpse	r25, r1
     4ac:	01 c0       	rjmp	.+2      	; 0x4b0 <tinyAxon_is_firing+0xc>
     4ae:	80 e0       	ldi	r24, 0x00	; 0
}
     4b0:	08 95       	ret

000004b2 <find_newest_pulse>:
uint8_t find_newest_pulse() {
	uint16_t max;
	uint8_t current_index = 0;
	uint8_t return_index = 0;
	
	max = pulse_queue[current_index];
     4b2:	40 91 16 38 	lds	r20, 0x3816	; 0x803816 <__data_end>
     4b6:	50 91 17 38 	lds	r21, 0x3817	; 0x803817 <__data_end+0x1>
     4ba:	e8 e1       	ldi	r30, 0x18	; 24
     4bc:	f8 e3       	ldi	r31, 0x38	; 56
	
// This function will be used with pulse_queue to find the newest pulse
uint8_t find_newest_pulse() {
	uint16_t max;
	uint8_t current_index = 0;
	uint8_t return_index = 0;
     4be:	80 e0       	ldi	r24, 0x00	; 0
	
	max = pulse_queue[current_index];
	
	for (current_index = 1; current_index < MAX_NUMBER_OF_PULSES; current_index++) {
     4c0:	91 e0       	ldi	r25, 0x01	; 1
		if (pulse_queue[current_index] > max) {
     4c2:	21 91       	ld	r18, Z+
     4c4:	31 91       	ld	r19, Z+
     4c6:	42 17       	cp	r20, r18
     4c8:	53 07       	cpc	r21, r19
     4ca:	10 f4       	brcc	.+4      	; 0x4d0 <find_newest_pulse+0x1e>
     4cc:	89 2f       	mov	r24, r25
			return_index = current_index;
			max = pulse_queue[current_index];
     4ce:	a9 01       	movw	r20, r18
	uint8_t current_index = 0;
	uint8_t return_index = 0;
	
	max = pulse_queue[current_index];
	
	for (current_index = 1; current_index < MAX_NUMBER_OF_PULSES; current_index++) {
     4d0:	9f 5f       	subi	r25, 0xFF	; 255
     4d2:	9a 30       	cpi	r25, 0x0A	; 10
     4d4:	b1 f7       	brne	.-20     	; 0x4c2 <find_newest_pulse+0x10>
			return_index = current_index;
			max = pulse_queue[current_index];
		}
	}
	return return_index;
}
     4d6:	08 95       	ret

000004d8 <tinyAxon_stop_sending_pulse>:
	tinyLED_set_color_mode(OUT_LED, WHITE, FLASH_ONCE);
}

void tinyAxon_stop_sending_pulse()
{
	DAC_0_set_output(NO_SIGNAL_OUTPUT);
     4d8:	80 e0       	ldi	r24, 0x00	; 0
     4da:	90 e0       	ldi	r25, 0x00	; 0
     4dc:	0e 94 20 01 	call	0x240	; 0x240 <DAC_0_set_output>
	axonOutputValue=NO_SIGNAL_OUTPUT;
     4e0:	10 92 2b 38 	sts	0x382B, r1	; 0x80382b <axonOutputValue>
     4e4:	08 95       	ret

000004e6 <tinyAxon_remove_pulse>:

/*
If the potential is very low, we want to try to remove a pulse.
*/
bool tinyAxon_remove_pulse(void)
{
     4e6:	cf 93       	push	r28
	// We want to return a bool indicating whether or not a pulse actually was removed.
	if(pulses_in_queue == 0){
     4e8:	c0 91 2a 38 	lds	r28, 0x382A	; 0x80382a <pulses_in_queue>
     4ec:	cc 23       	and	r28, r28
     4ee:	c9 f0       	breq	.+50     	; 0x522 <tinyAxon_remove_pulse+0x3c>
		//There was no pulse to remove.
		return false;
	}
	else{
		// If we are to remove a pulse, we want to remove the one that will fire last.
		uint8_t pulse_index = find_newest_pulse();
     4f0:	0e 94 59 02 	call	0x4b2	; 0x4b2 <find_newest_pulse>
		uint16_t newest_pulse = pulse_queue[pulse_index];
     4f4:	90 e0       	ldi	r25, 0x00	; 0
     4f6:	fc 01       	movw	r30, r24
     4f8:	ee 0f       	add	r30, r30
     4fa:	ff 1f       	adc	r31, r31
     4fc:	ea 5e       	subi	r30, 0xEA	; 234
     4fe:	f7 4c       	sbci	r31, 0xC7	; 199
	
		// Now we want to check if the pulse is too far away to be affected by the low potential, or close enough that we decide to remove it.
		// (When we say that the pulse is too far away, it refers to the biological process of how the potential spreads from Dendrites to axon).
		if(newest_pulse > PULSE_NO_RETURN_TIME){
     500:	20 81       	ld	r18, Z
     502:	31 81       	ldd	r19, Z+1	; 0x01
     504:	2d 33       	cpi	r18, 0x3D	; 61
     506:	31 05       	cpc	r19, r1
     508:	70 f0       	brcs	.+28     	; 0x526 <tinyAxon_remove_pulse+0x40>
			// We decided to remove the pulse
			pulse_queue[pulse_index] = 0;
     50a:	88 0f       	add	r24, r24
     50c:	99 1f       	adc	r25, r25
     50e:	fc 01       	movw	r30, r24
     510:	ea 5e       	subi	r30, 0xEA	; 234
     512:	f7 4c       	sbci	r31, 0xC7	; 199
     514:	10 82       	st	Z, r1
     516:	11 82       	std	Z+1, r1	; 0x01
			pulses_in_queue--;
     518:	c1 50       	subi	r28, 0x01	; 1
     51a:	c0 93 2a 38 	sts	0x382A, r28	; 0x80382a <pulses_in_queue>
			return true;
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	03 c0       	rjmp	.+6      	; 0x528 <tinyAxon_remove_pulse+0x42>
bool tinyAxon_remove_pulse(void)
{
	// We want to return a bool indicating whether or not a pulse actually was removed.
	if(pulses_in_queue == 0){
		//There was no pulse to remove.
		return false;
     522:	80 e0       	ldi	r24, 0x00	; 0
     524:	01 c0       	rjmp	.+2      	; 0x528 <tinyAxon_remove_pulse+0x42>
			pulses_in_queue--;
			return true;
		}
		// Here we have found that there is a pulse queued, but it is old enough to let pass anyway, so now we need to put it back into the queue.
		else{
			return false;
     526:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     528:	cf 91       	pop	r28
     52a:	08 95       	ret

0000052c <tinyAxon_update_potential>:
/*
Decides whether or not the axon should fire
If the axon does fire, the potential is reduced
*/
double tinyAxon_update_potential(double potential)
{	
     52c:	cf 92       	push	r12
     52e:	df 92       	push	r13
     530:	ef 92       	push	r14
     532:	ff 92       	push	r15
     534:	6b 01       	movw	r12, r22
     536:	7c 01       	movw	r14, r24
	//While the neuron has enough potential to fire, we want to fire more
	while (potential >= THRESHOLD_POTENTIAL)
     538:	20 e0       	ldi	r18, 0x00	; 0
     53a:	30 e0       	ldi	r19, 0x00	; 0
     53c:	48 ec       	ldi	r20, 0xC8	; 200
     53e:	51 e4       	ldi	r21, 0x41	; 65
     540:	0e 94 af 0b 	call	0x175e	; 0x175e <__gesf2>
     544:	88 23       	and	r24, r24
     546:	bc f1       	brlt	.+110    	; 0x5b6 <tinyAxon_update_potential+0x8a>
	{
		// We have to check if there are already queued pulses, so that the frequency never exceeds FIRE_DELAY
		if(pulses_in_queue>0){
     548:	80 91 2a 38 	lds	r24, 0x382A	; 0x80382a <pulses_in_queue>
     54c:	88 23       	and	r24, r24
     54e:	b1 f0       	breq	.+44     	; 0x57c <tinyAxon_update_potential+0x50>
			uint16_t newest_pulse = pulse_queue[find_newest_pulse()];
     550:	0e 94 59 02 	call	0x4b2	; 0x4b2 <find_newest_pulse>
     554:	e8 2f       	mov	r30, r24
     556:	f0 e0       	ldi	r31, 0x00	; 0
     558:	ee 0f       	add	r30, r30
     55a:	ff 1f       	adc	r31, r31
     55c:	ea 5e       	subi	r30, 0xEA	; 234
     55e:	f7 4c       	sbci	r31, 0xC7	; 199
			
			// There is at least one pulse in the queue, and it is "so close", that we need to offset the new pulse, so that we keep at least
			// one FIRE_DELAY between each pulse
			if(newest_pulse + FIRE_DELAY > TRAVLE_DELAY){
     560:	80 81       	ld	r24, Z
     562:	91 81       	ldd	r25, Z+1	; 0x01
     564:	0a 96       	adiw	r24, 0x0a	; 10
     566:	85 36       	cpi	r24, 0x65	; 101
     568:	91 05       	cpc	r25, r1
     56a:	18 f0       	brcs	.+6      	; 0x572 <tinyAxon_update_potential+0x46>
				tinyAxon_add_pulse(newest_pulse + FIRE_DELAY);
     56c:	0e 94 2d 02 	call	0x45a	; 0x45a <tinyAxon_add_pulse>
     570:	09 c0       	rjmp	.+18     	; 0x584 <tinyAxon_update_potential+0x58>
			}
			// There is at least one pulse in the queue, but it's "far enough away" to ignore
			else{
				tinyAxon_add_pulse(TRAVLE_DELAY);
     572:	84 e6       	ldi	r24, 0x64	; 100
     574:	90 e0       	ldi	r25, 0x00	; 0
     576:	0e 94 2d 02 	call	0x45a	; 0x45a <tinyAxon_add_pulse>
     57a:	04 c0       	rjmp	.+8      	; 0x584 <tinyAxon_update_potential+0x58>
			}
		}
		// There are no pulses in the queue, so we add a pulse as normal
		else{
			tinyAxon_add_pulse(TRAVLE_DELAY);		
     57c:	84 e6       	ldi	r24, 0x64	; 100
     57e:	90 e0       	ldi	r25, 0x00	; 0
     580:	0e 94 2d 02 	call	0x45a	; 0x45a <tinyAxon_add_pulse>
		}
		
		potential += POSTFIRE_POTENTIAL_REACTION; // This is usually defined as a negative value, don't be confused by the +=
     584:	20 e0       	ldi	r18, 0x00	; 0
     586:	30 e0       	ldi	r19, 0x00	; 0
     588:	48 ec       	ldi	r20, 0xC8	; 200
     58a:	51 e4       	ldi	r21, 0x41	; 65
     58c:	c7 01       	movw	r24, r14
     58e:	b6 01       	movw	r22, r12
     590:	0e 94 6a 09 	call	0x12d4	; 0x12d4 <__subsf3>
     594:	6b 01       	movw	r12, r22
     596:	7c 01       	movw	r14, r24
		
		tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
     598:	45 e0       	ldi	r20, 0x05	; 5
     59a:	63 e0       	ldi	r22, 0x03	; 3
     59c:	80 e0       	ldi	r24, 0x00	; 0
     59e:	0e 94 bb 05 	call	0xb76	; 0xb76 <tinyLED_set_color_mode>
If the axon does fire, the potential is reduced
*/
double tinyAxon_update_potential(double potential)
{	
	//While the neuron has enough potential to fire, we want to fire more
	while (potential >= THRESHOLD_POTENTIAL)
     5a2:	20 e0       	ldi	r18, 0x00	; 0
     5a4:	30 e0       	ldi	r19, 0x00	; 0
     5a6:	48 ec       	ldi	r20, 0xC8	; 200
     5a8:	51 e4       	ldi	r21, 0x41	; 65
     5aa:	c7 01       	movw	r24, r14
     5ac:	b6 01       	movw	r22, r12
     5ae:	0e 94 af 0b 	call	0x175e	; 0x175e <__gesf2>
     5b2:	88 23       	and	r24, r24
     5b4:	4c f6       	brge	.-110    	; 0x548 <tinyAxon_update_potential+0x1c>
		
		tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
	}
	
	// If the neuron has a very low potential, we want to remove a pulse from the queue (if there is one)
	if(potential < -THRESHOLD_POTENTIAL)
     5b6:	20 e0       	ldi	r18, 0x00	; 0
     5b8:	30 e0       	ldi	r19, 0x00	; 0
     5ba:	48 ec       	ldi	r20, 0xC8	; 200
     5bc:	51 ec       	ldi	r21, 0xC1	; 193
     5be:	c7 01       	movw	r24, r14
     5c0:	b6 01       	movw	r22, r12
     5c2:	0e 94 d7 09 	call	0x13ae	; 0x13ae <__cmpsf2>
     5c6:	88 23       	and	r24, r24
     5c8:	0c f0       	brlt	.+2      	; 0x5cc <tinyAxon_update_potential+0xa0>
     5ca:	46 c0       	rjmp	.+140    	; 0x658 <tinyAxon_update_potential+0x12c>
	{
		if(pulses_in_queue > 0) // Perhaps this should be a separate variable? For now, we will just simply use -THRESHOLD_POTENTIAL
     5cc:	80 91 2a 38 	lds	r24, 0x382A	; 0x80382a <pulses_in_queue>
     5d0:	88 23       	and	r24, r24
     5d2:	11 f1       	breq	.+68     	; 0x618 <tinyAxon_update_potential+0xec>
		{
			// The neurons potential is low enough to attempt to remove a queued fire (Fire less)
			if(tinyAxon_remove_pulse())
     5d4:	0e 94 73 02 	call	0x4e6	; 0x4e6 <tinyAxon_remove_pulse>
     5d8:	88 23       	and	r24, r24
     5da:	f1 f1       	breq	.+124    	; 0x658 <tinyAxon_update_potential+0x12c>
			{
				// The potential has evened out a bit
				potential += THRESHOLD_POTENTIAL;
     5dc:	20 e0       	ldi	r18, 0x00	; 0
     5de:	30 e0       	ldi	r19, 0x00	; 0
     5e0:	48 ec       	ldi	r20, 0xC8	; 200
     5e2:	51 e4       	ldi	r21, 0x41	; 65
     5e4:	c7 01       	movw	r24, r14
     5e6:	b6 01       	movw	r22, r12
     5e8:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <__addsf3>
     5ec:	6b 01       	movw	r12, r22
     5ee:	7c 01       	movw	r14, r24
     5f0:	33 c0       	rjmp	.+102    	; 0x658 <tinyAxon_update_potential+0x12c>
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
	{
		for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
		{
			if(pulse_queue[i] != 0){
     5f2:	80 81       	ld	r24, Z
     5f4:	91 81       	ldd	r25, Z+1	; 0x01
     5f6:	00 97       	sbiw	r24, 0x00	; 0
     5f8:	39 f0       	breq	.+14     	; 0x608 <tinyAxon_update_potential+0xdc>
				pulse_queue[i]--;
     5fa:	01 97       	sbiw	r24, 0x01	; 1
     5fc:	80 83       	st	Z, r24
     5fe:	91 83       	std	Z+1, r25	; 0x01
				
				// If the time went from 1 to 0, we fire the axon
				if(pulse_queue[i] == 0){
     600:	89 2b       	or	r24, r25
     602:	11 f4       	brne	.+4      	; 0x608 <tinyAxon_update_potential+0xdc>
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
	pulses_in_queue--;
     604:	41 50       	subi	r20, 0x01	; 1
Function to set firing.
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
     606:	51 e0       	ldi	r21, 0x01	; 1
     608:	32 96       	adiw	r30, 0x02	; 2
	}
	
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
	{
		for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
     60a:	e2 17       	cp	r30, r18
     60c:	f3 07       	cpc	r31, r19
     60e:	89 f7       	brne	.-30     	; 0x5f2 <tinyAxon_update_potential+0xc6>
     610:	50 93 2c 38 	sts	0x382C, r21	; 0x80382c <tinyAxon_should_fire>
     614:	40 93 2a 38 	sts	0x382A, r20	; 0x80382a <pulses_in_queue>
The function should set the DAC to fire for two
update cycles once the pulse flag is set high.
*/
static void tinyAxon_update_pulse_transmitter(void)
{
	if (tinyAxon_should_fire)
     618:	80 91 2c 38 	lds	r24, 0x382C	; 0x80382c <tinyAxon_should_fire>
     61c:	88 23       	and	r24, r24
     61e:	91 f0       	breq	.+36     	; 0x644 <tinyAxon_update_potential+0x118>
	{
		tinyAxon_should_fire = false;
     620:	10 92 2c 38 	sts	0x382C, r1	; 0x80382c <tinyAxon_should_fire>
		DAC_0_set_output(EXCITATORY_NEURON_OUTPUT);
		axonOutputValue=EXCITATORY_NEURON_OUTPUT;
	}
	else if(NEURONTYPE == INHIBITORY_NEURON)
	{
		DAC_0_set_output(INHIBITORY_NEURON_OUTPUT);
     624:	80 e8       	ldi	r24, 0x80	; 128
     626:	90 e0       	ldi	r25, 0x00	; 0
     628:	0e 94 20 01 	call	0x240	; 0x240 <DAC_0_set_output>
		axonOutputValue=INHIBITORY_NEURON_OUTPUT;
     62c:	80 e8       	ldi	r24, 0x80	; 128
     62e:	80 93 2b 38 	sts	0x382B, r24	; 0x80382b <axonOutputValue>
	}
	
	tinyLED_set_color_mode(OUT_LED, WHITE, FLASH_ONCE);
     632:	45 e0       	ldi	r20, 0x05	; 5
     634:	65 e0       	ldi	r22, 0x05	; 5
     636:	81 e0       	ldi	r24, 0x01	; 1
     638:	0e 94 bb 05 	call	0xb76	; 0xb76 <tinyLED_set_color_mode>
{
	if (tinyAxon_should_fire)
	{
		tinyAxon_should_fire = false;
		tinyAxon_start_sending_pulse();
		tinyAxon_has_just_fired = true;
     63c:	81 e0       	ldi	r24, 0x01	; 1
     63e:	80 93 2d 38 	sts	0x382D, r24	; 0x80382d <tinyAxon_has_just_fired>
     642:	15 c0       	rjmp	.+42     	; 0x66e <tinyAxon_update_potential+0x142>
		
	}
	else if (tinyAxon_has_just_fired)
     644:	80 91 2d 38 	lds	r24, 0x382D	; 0x80382d <tinyAxon_has_just_fired>
     648:	88 23       	and	r24, r24
     64a:	19 f0       	breq	.+6      	; 0x652 <tinyAxon_update_potential+0x126>
	{
		tinyAxon_has_just_fired = false;
     64c:	10 92 2d 38 	sts	0x382D, r1	; 0x80382d <tinyAxon_has_just_fired>
     650:	0e c0       	rjmp	.+28     	; 0x66e <tinyAxon_update_potential+0x142>
	}
	else if (!tinyAxon_has_just_fired && !tinyAxon_should_fire)
	{
		tinyAxon_stop_sending_pulse();
     652:	0e 94 6c 02 	call	0x4d8	; 0x4d8 <tinyAxon_stop_sending_pulse>
     656:	0b c0       	rjmp	.+22     	; 0x66e <tinyAxon_update_potential+0x142>
			}
		}
	}
	
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
     658:	40 91 2a 38 	lds	r20, 0x382A	; 0x80382a <pulses_in_queue>
     65c:	44 23       	and	r20, r20
     65e:	e1 f2       	breq	.-72     	; 0x618 <tinyAxon_update_potential+0xec>
     660:	50 91 2c 38 	lds	r21, 0x382C	; 0x80382c <tinyAxon_should_fire>
     664:	e6 e1       	ldi	r30, 0x16	; 22
     666:	f8 e3       	ldi	r31, 0x38	; 56
     668:	2a e2       	ldi	r18, 0x2A	; 42
     66a:	38 e3       	ldi	r19, 0x38	; 56
     66c:	c2 cf       	rjmp	.-124    	; 0x5f2 <tinyAxon_update_potential+0xc6>
	}
	
	// Here we set the actual output of the DAC (Digital to Analog Converter)
	tinyAxon_update_pulse_transmitter();
	
	tinyDebugger_send_uint8("Axon", axonOutputValue);
     66e:	60 91 2b 38 	lds	r22, 0x382B	; 0x80382b <axonOutputValue>
     672:	8d e4       	ldi	r24, 0x4D	; 77
     674:	9a e9       	ldi	r25, 0x9A	; 154
     676:	0e 94 43 04 	call	0x886	; 0x886 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("Pulses", pulses_in_queue);
     67a:	60 91 2a 38 	lds	r22, 0x382A	; 0x80382a <pulses_in_queue>
     67e:	82 e5       	ldi	r24, 0x52	; 82
     680:	9a e9       	ldi	r25, 0x9A	; 154
     682:	0e 94 43 04 	call	0x886	; 0x886 <tinyDebugger_send_uint8>
	
	
	return potential;
}
     686:	c7 01       	movw	r24, r14
     688:	b6 01       	movw	r22, r12
     68a:	ff 90       	pop	r15
     68c:	ef 90       	pop	r14
     68e:	df 90       	pop	r13
     690:	cf 90       	pop	r12
     692:	08 95       	ret

00000694 <tinyAxon_check_charge_level>:
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTB_get_pin_level(const uint8_t pin)
{
	return VPORTB.IN & (1 << pin);
     694:	66 b1       	in	r22, 0x06	; 6

_Bool tinyAxon_check_charge_level(void)
{
	// We check the AXON_CHECK_PIN. If it is hight while the axon is not firing, it must be connected to a charger
	
	tinyDebugger_send_uint8("Pulses", AXON_CHECK_PIN_get_level());
     696:	66 1f       	adc	r22, r22
     698:	66 27       	eor	r22, r22
     69a:	66 1f       	adc	r22, r22
     69c:	82 e5       	ldi	r24, 0x52	; 82
     69e:	9a e9       	ldi	r25, 0x9A	; 154
     6a0:	0e 94 43 04 	call	0x886	; 0x886 <tinyDebugger_send_uint8>
	return (AXON_CHECK_PIN_get_level() && !tinyAxon_has_just_fired);
     6a4:	37 9b       	sbis	0x06, 7	; 6
     6a6:	05 c0       	rjmp	.+10     	; 0x6b2 <tinyAxon_check_charge_level+0x1e>
     6a8:	90 91 2d 38 	lds	r25, 0x382D	; 0x80382d <tinyAxon_has_just_fired>
     6ac:	81 e0       	ldi	r24, 0x01	; 1
     6ae:	89 27       	eor	r24, r25
     6b0:	02 c0       	rjmp	.+4      	; 0x6b6 <tinyAxon_check_charge_level+0x22>
     6b2:	80 e0       	ldi	r24, 0x00	; 0
     6b4:	90 e0       	ldi	r25, 0x00	; 0
     6b6:	81 70       	andi	r24, 0x01	; 1
     6b8:	08 95       	ret

000006ba <tinyButton_update>:
/*
If the button has been let go, we change button_press to true. This only lasts one cycle, before it is set to false again.
If the button is held down for longer than PULSEMODE_BUTTON_PRESS_TIME, we toggle the pulse mode state.
*/
void tinyButton_update(void)
{
     6ba:	0f 93       	push	r16
     6bc:	1f 93       	push	r17
     6be:	cf 93       	push	r28
     6c0:	df 93       	push	r29
	button_press = false;
     6c2:	10 92 33 38 	sts	0x3833, r1	; 0x803833 <button_press>
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTC_get_pin_level(const uint8_t pin)
{
	return VPORTC.IN & (1 << pin);
     6c6:	8a b1       	in	r24, 0x0a	; 10
	_Bool button_is_pushed_down = !BUTTON_PIN_get_level(); // The digital port will be read as low if the button is pushed down.
     6c8:	d1 e0       	ldi	r29, 0x01	; 1
     6ca:	c8 2f       	mov	r28, r24
     6cc:	c4 70       	andi	r28, 0x04	; 4
     6ce:	82 fd       	sbrc	r24, 2
     6d0:	d0 e0       	ldi	r29, 0x00	; 0

	if (button_is_pushed_down && !button_was_pushed_down)
     6d2:	c1 11       	cpse	r28, r1
     6d4:	36 c0       	rjmp	.+108    	; 0x742 <tinyButton_update+0x88>
     6d6:	80 91 34 38 	lds	r24, 0x3834	; 0x803834 <button_was_pushed_down>
     6da:	81 11       	cpse	r24, r1
     6dc:	0e c0       	rjmp	.+28     	; 0x6fa <tinyButton_update+0x40>
	{
		tinyButton_start_time = tinyTime_now();
     6de:	0e 94 61 09 	call	0x12c2	; 0x12c2 <tinyTime_now>
     6e2:	60 93 2e 38 	sts	0x382E, r22	; 0x80382e <tinyButton_start_time>
     6e6:	70 93 2f 38 	sts	0x382F, r23	; 0x80382f <tinyButton_start_time+0x1>
     6ea:	80 93 30 38 	sts	0x3830, r24	; 0x803830 <tinyButton_start_time+0x2>
     6ee:	90 93 31 38 	sts	0x3831, r25	; 0x803831 <tinyButton_start_time+0x3>
	}
	if (button_is_pushed_down && button_was_pushed_down)
     6f2:	80 91 34 38 	lds	r24, 0x3834	; 0x803834 <button_was_pushed_down>
     6f6:	88 23       	and	r24, r24
     6f8:	a1 f1       	breq	.+104    	; 0x762 <tinyButton_update+0xa8>
	{
		if ((tinyTime_now() - tinyButton_start_time) > PULSEMODE_BUTTON_PRESS_TIME)
     6fa:	0e 94 61 09 	call	0x12c2	; 0x12c2 <tinyTime_now>
     6fe:	00 91 2e 38 	lds	r16, 0x382E	; 0x80382e <tinyButton_start_time>
     702:	10 91 2f 38 	lds	r17, 0x382F	; 0x80382f <tinyButton_start_time+0x1>
     706:	20 91 30 38 	lds	r18, 0x3830	; 0x803830 <tinyButton_start_time+0x2>
     70a:	30 91 31 38 	lds	r19, 0x3831	; 0x803831 <tinyButton_start_time+0x3>
     70e:	dc 01       	movw	r26, r24
     710:	cb 01       	movw	r24, r22
     712:	80 1b       	sub	r24, r16
     714:	91 0b       	sbc	r25, r17
     716:	a2 0b       	sbc	r26, r18
     718:	b3 0b       	sbc	r27, r19
     71a:	81 3d       	cpi	r24, 0xD1	; 209
     71c:	97 40       	sbci	r25, 0x07	; 7
     71e:	a1 05       	cpc	r26, r1
     720:	b1 05       	cpc	r27, r1
     722:	78 f0       	brcs	.+30     	; 0x742 <tinyButton_update+0x88>
		{
			tinyPulse_toggle_pulse_mode();
     724:	0e 94 e1 08 	call	0x11c2	; 0x11c2 <tinyPulse_toggle_pulse_mode>
			tinyButton_start_time = tinyTime_now();
     728:	0e 94 61 09 	call	0x12c2	; 0x12c2 <tinyTime_now>
     72c:	60 93 2e 38 	sts	0x382E, r22	; 0x80382e <tinyButton_start_time>
     730:	70 93 2f 38 	sts	0x382F, r23	; 0x80382f <tinyButton_start_time+0x1>
     734:	80 93 30 38 	sts	0x3830, r24	; 0x803830 <tinyButton_start_time+0x2>
     738:	90 93 31 38 	sts	0x3831, r25	; 0x803831 <tinyButton_start_time+0x3>
			// We don't want switching to pulse mode to count as a button press, so we ignore the next button press
			ignore_next_button_press = true;
     73c:	81 e0       	ldi	r24, 0x01	; 1
     73e:	80 93 32 38 	sts	0x3832, r24	; 0x803832 <ignore_next_button_press>
		}
	}
	if (!button_is_pushed_down && button_was_pushed_down)
     742:	cc 23       	and	r28, r28
     744:	71 f0       	breq	.+28     	; 0x762 <tinyButton_update+0xa8>
     746:	80 91 34 38 	lds	r24, 0x3834	; 0x803834 <button_was_pushed_down>
     74a:	88 23       	and	r24, r24
     74c:	51 f0       	breq	.+20     	; 0x762 <tinyButton_update+0xa8>
	{
		if(!ignore_next_button_press){
     74e:	80 91 32 38 	lds	r24, 0x3832	; 0x803832 <ignore_next_button_press>
     752:	81 11       	cpse	r24, r1
     754:	04 c0       	rjmp	.+8      	; 0x75e <tinyButton_update+0xa4>
			button_press = true;
     756:	81 e0       	ldi	r24, 0x01	; 1
     758:	80 93 33 38 	sts	0x3833, r24	; 0x803833 <button_press>
     75c:	02 c0       	rjmp	.+4      	; 0x762 <tinyButton_update+0xa8>
		}
		else{
			ignore_next_button_press = false;
     75e:	10 92 32 38 	sts	0x3832, r1	; 0x803832 <ignore_next_button_press>
		}
		
	}
	button_was_pushed_down = button_is_pushed_down;
     762:	d0 93 34 38 	sts	0x3834, r29	; 0x803834 <button_was_pushed_down>
}
     766:	df 91       	pop	r29
     768:	cf 91       	pop	r28
     76a:	1f 91       	pop	r17
     76c:	0f 91       	pop	r16
     76e:	08 95       	ret

00000770 <tinyButton_update_potential>:

double tinyButton_update_potential(double potential){
	if(button_press){
     770:	20 91 33 38 	lds	r18, 0x3833	; 0x803833 <button_press>
     774:	22 23       	and	r18, r18
     776:	31 f0       	breq	.+12     	; 0x784 <tinyButton_update_potential+0x14>
		potential += BUTTON_PRESS_REACTION;
     778:	20 e0       	ldi	r18, 0x00	; 0
     77a:	30 e0       	ldi	r19, 0x00	; 0
     77c:	40 ed       	ldi	r20, 0xD0	; 208
     77e:	51 e4       	ldi	r21, 0x41	; 65
     780:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <__addsf3>
	}
	return potential;
}
     784:	08 95       	ret

00000786 <tinyCharge_is_connected_to_charger>:
*/
uint8_t charge_counter = 0; 

_Bool tinyCharge_is_connected_to_charger(){
	return connected_to_charger;
}
     786:	80 91 5a 38 	lds	r24, 0x385A	; 0x80385a <connected_to_charger>
     78a:	08 95       	ret

0000078c <tinyCharge_is_fully_charged>:
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTB_get_pin_level(const uint8_t pin)
{
	return VPORTB.IN & (1 << pin);
     78c:	86 b1       	in	r24, 0x06	; 6

_Bool tinyCharge_is_fully_charged(){
	return CHARGING_STATUS_PIN_get_level();
}
     78e:	86 fb       	bst	r24, 6
     790:	88 27       	eor	r24, r24
     792:	80 f9       	bld	r24, 0
     794:	08 95       	ret

00000796 <tinyCharge_DAC_dissable>:
void tinyCharge_DAC_dissable(){
	
	// We need some way to disable the DAC to prevent huge current draw when charging (64mA). When there is no code uploaded to the attiny, there is no problem.
	// We're going to try to enable the pin as a dendrite, since they seem to be doing fine. Completely uninitializing the pin probably caused a microchip to be fried.
	
	DAC_0_uninit();
     796:	0e 94 0f 01 	call	0x21e	; 0x21e <DAC_0_uninit>
	DAC_0_disable();
     79a:	0e 94 1a 01 	call	0x234	; 0x234 <DAC_0_disable>
     79e:	08 95       	ret

000007a0 <tinyCharge_DAC_enable>:
void tinyCharge_DAC_enable(){
	
	// We need some way to disable the DAC to prevent huge current draw when charging (64mA). When there is no code uploaded to the attiny, there is no problem.
	// We're going to try to enable the pin as a dendrite, since they seem to be doing fine. Completely uninitializing the pin probably caused a microchip to be fried.
	
	DAC_0_init();
     7a0:	0e 94 0a 01 	call	0x214	; 0x214 <DAC_0_init>
	DAC_0_enable();
     7a4:	0e 94 14 01 	call	0x228	; 0x228 <DAC_0_enable>
     7a8:	08 95       	ret

000007aa <tinyCharge_switch_mode>:
}


void tinyCharge_switch_mode(){
	
	if(connected_to_charger){
     7aa:	80 91 5a 38 	lds	r24, 0x385A	; 0x80385a <connected_to_charger>
     7ae:	88 23       	and	r24, r24
     7b0:	89 f0       	breq	.+34     	; 0x7d4 <tinyCharge_switch_mode+0x2a>
		// Switch from main to charging mode
		
		// Set LED
		tinyLED_set_color_mode(OUT_LED, CHARGING_COLOR, SWING);
     7b2:	43 e0       	ldi	r20, 0x03	; 3
     7b4:	61 e0       	ldi	r22, 0x01	; 1
     7b6:	81 e0       	ldi	r24, 0x01	; 1
     7b8:	0e 94 bb 05 	call	0xb76	; 0xb76 <tinyLED_set_color_mode>
		tinyLED_set_color(INN_LED, LED_OFF);
     7bc:	60 e0       	ldi	r22, 0x00	; 0
     7be:	80 e0       	ldi	r24, 0x00	; 0
     7c0:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <tinyLED_set_color>


		// Stop axon from firing
		// (There is a small chance that the neuron is put into charging mode as it is firing. The axon is then never told to stop firing)
		tinyAxon_stop_sending_pulse();
     7c4:	0e 94 6c 02 	call	0x4d8	; 0x4d8 <tinyAxon_stop_sending_pulse>

		// disable DAC
		tinyCharge_DAC_dissable();
     7c8:	0e 94 cb 03 	call	0x796	; 0x796 <tinyCharge_DAC_dissable>
		
		// We also turn off pulse mode, because it's confusing if it suddenly comes on
		// after it has been charging
		tinyPulse_set_pulse_mode(false);
     7cc:	80 e0       	ldi	r24, 0x00	; 0
     7ce:	0e 94 fd 08 	call	0x11fa	; 0x11fa <tinyPulse_set_pulse_mode>
     7d2:	08 95       	ret
	}
	else{
		// Switch from charge to main mode
		
		// Set LED
		tinyLED_set_color(OUT_LED, LED_OFF);
     7d4:	60 e0       	ldi	r22, 0x00	; 0
     7d6:	81 e0       	ldi	r24, 0x01	; 1
     7d8:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <tinyLED_set_color>
		tinyLED_set_color(INN_LED, LED_OFF);
     7dc:	60 e0       	ldi	r22, 0x00	; 0
     7de:	80 e0       	ldi	r24, 0x00	; 0
     7e0:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <tinyLED_set_color>
		
		// enable DAC
		tinyCharge_DAC_enable();
     7e4:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <tinyCharge_DAC_enable>
     7e8:	08 95       	ret

000007ea <tinyCharge_set_charging_mode>:
	}
}

void tinyCharge_set_charging_mode(_Bool charging_status){
	if(charging_status != connected_to_charger){
     7ea:	90 91 5a 38 	lds	r25, 0x385A	; 0x80385a <connected_to_charger>
     7ee:	98 17       	cp	r25, r24
     7f0:	21 f0       	breq	.+8      	; 0x7fa <tinyCharge_set_charging_mode+0x10>
		connected_to_charger = charging_status;
     7f2:	80 93 5a 38 	sts	0x385A, r24	; 0x80385a <connected_to_charger>
		tinyCharge_switch_mode();
     7f6:	0e 94 d5 03 	call	0x7aa	; 0x7aa <tinyCharge_switch_mode>
     7fa:	08 95       	ret

000007fc <tinyCharge_update_charging_mode>:

/*
Checks if the levels of the dendrites and axon are at charging levels
and updates the mode accordingly
*/
void tinyCharge_update_charging_mode(){
     7fc:	cf 93       	push	r28
	// For complicated reasons, the axon_check_level will be high even when the charger is not connected
	// WHEN the neuron is in charging mode, hence we ignore the axon level when the neuron is in charging mode
	_Bool charging;
	if(connected_to_charger){
     7fe:	80 91 5a 38 	lds	r24, 0x385A	; 0x80385a <connected_to_charger>
     802:	88 23       	and	r24, r24
     804:	21 f0       	breq	.+8      	; 0x80e <tinyCharge_update_charging_mode+0x12>
		charging = tinyDendrite_check_charge_level();
     806:	0e 94 66 04 	call	0x8cc	; 0x8cc <tinyDendrite_check_charge_level>
     80a:	c8 2f       	mov	r28, r24
     80c:	0b c0       	rjmp	.+22     	; 0x824 <tinyCharge_update_charging_mode+0x28>
	} else{
		charging = tinyDendrite_check_charge_level() || tinyAxon_check_charge_level();
     80e:	0e 94 66 04 	call	0x8cc	; 0x8cc <tinyDendrite_check_charge_level>
     812:	81 11       	cpse	r24, r1
     814:	03 c0       	rjmp	.+6      	; 0x81c <tinyCharge_update_charging_mode+0x20>
     816:	0e 94 4a 03 	call	0x694	; 0x694 <tinyAxon_check_charge_level>
     81a:	02 c0       	rjmp	.+4      	; 0x820 <tinyCharge_update_charging_mode+0x24>
     81c:	81 e0       	ldi	r24, 0x01	; 1
     81e:	90 e0       	ldi	r25, 0x00	; 0
     820:	c8 2f       	mov	r28, r24
     822:	c1 70       	andi	r28, 0x01	; 1
	}
	
	// In order to prevent the axon from stimulating itself, we only switch into charging mode when the conditions have been right for several cycles
	if(!connected_to_charger && charging){
     824:	80 91 5a 38 	lds	r24, 0x385A	; 0x80385a <connected_to_charger>
     828:	81 11       	cpse	r24, r1
     82a:	0d c0       	rjmp	.+26     	; 0x846 <tinyCharge_update_charging_mode+0x4a>
     82c:	cc 23       	and	r28, r28
     82e:	d1 f0       	breq	.+52     	; 0x864 <tinyCharge_update_charging_mode+0x68>
		charge_counter++;
     830:	80 91 35 38 	lds	r24, 0x3835	; 0x803835 <charge_counter>
     834:	8f 5f       	subi	r24, 0xFF	; 255
		if(charge_counter > CYCLES_REQUIRED_FOR_CHARGING_MODE_SWITCH){
     836:	8b 30       	cpi	r24, 0x0B	; 11
     838:	90 f0       	brcs	.+36     	; 0x85e <tinyCharge_update_charging_mode+0x62>
			charge_counter = 0;
     83a:	10 92 35 38 	sts	0x3835, r1	; 0x803835 <charge_counter>
			tinyCharge_set_charging_mode(charging);
     83e:	81 e0       	ldi	r24, 0x01	; 1
     840:	0e 94 f5 03 	call	0x7ea	; 0x7ea <tinyCharge_set_charging_mode>
     844:	13 c0       	rjmp	.+38     	; 0x86c <tinyCharge_update_charging_mode+0x70>
		}
	}
	else{
		tinyCharge_set_charging_mode(charging);
     846:	8c 2f       	mov	r24, r28
     848:	0e 94 f5 03 	call	0x7ea	; 0x7ea <tinyCharge_set_charging_mode>
	}
	
	// We have to prevent charge_counters from accumulating over time
	if(!charging && charge_counter>0){
     84c:	c1 11       	cpse	r28, r1
     84e:	0e c0       	rjmp	.+28     	; 0x86c <tinyCharge_update_charging_mode+0x70>
     850:	80 91 35 38 	lds	r24, 0x3835	; 0x803835 <charge_counter>
     854:	88 23       	and	r24, r24
     856:	51 f0       	breq	.+20     	; 0x86c <tinyCharge_update_charging_mode+0x70>
		charge_counter = 0;
     858:	10 92 35 38 	sts	0x3835, r1	; 0x803835 <charge_counter>
	}
	
}
     85c:	07 c0       	rjmp	.+14     	; 0x86c <tinyCharge_update_charging_mode+0x70>
		charging = tinyDendrite_check_charge_level() || tinyAxon_check_charge_level();
	}
	
	// In order to prevent the axon from stimulating itself, we only switch into charging mode when the conditions have been right for several cycles
	if(!connected_to_charger && charging){
		charge_counter++;
     85e:	80 93 35 38 	sts	0x3835, r24	; 0x803835 <charge_counter>
     862:	04 c0       	rjmp	.+8      	; 0x86c <tinyCharge_update_charging_mode+0x70>
			charge_counter = 0;
			tinyCharge_set_charging_mode(charging);
		}
	}
	else{
		tinyCharge_set_charging_mode(charging);
     864:	8c 2f       	mov	r24, r28
     866:	0e 94 f5 03 	call	0x7ea	; 0x7ea <tinyCharge_set_charging_mode>
     86a:	f2 cf       	rjmp	.-28     	; 0x850 <tinyCharge_update_charging_mode+0x54>
	// We have to prevent charge_counters from accumulating over time
	if(!charging && charge_counter>0){
		charge_counter = 0;
	}
	
}
     86c:	cf 91       	pop	r28
     86e:	08 95       	ret

00000870 <tinyCharge_set_transistors>:



void tinyCharge_set_transistors(){
	if(connected_to_charger){
     870:	80 91 5a 38 	lds	r24, 0x385A	; 0x80385a <connected_to_charger>
     874:	88 23       	and	r24, r24
     876:	19 f0       	breq	.+6      	; 0x87e <tinyCharge_set_transistors+0xe>
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
	} else {
		VPORTC.OUT &= ~(1 << pin);
     878:	4d 98       	cbi	0x09, 5	; 9
 *                  false = Pin level set to "low" state
 */
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
     87a:	29 9a       	sbi	0x05, 1	; 5
     87c:	08 95       	ret
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     87e:	4d 9a       	sbi	0x09, 5	; 9
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     880:	29 98       	cbi	0x05, 1	; 5
     882:	08 95       	ret

00000884 <tinyDebugger_send_uint32>:
		char number[20]; // Arbitrary max
		dtostrf(value,1,NUMBER_OF_DECIMALS, number);
		printf("%s:%5s\t", name, number);
	}
}
void tinyDebugger_send_string(const char* name, char * value){
     884:	08 95       	ret

00000886 <tinyDebugger_send_uint8>:
     886:	08 95       	ret

00000888 <tinyDebugger_send_double>:
     888:	08 95       	ret

0000088a <tinyDebugger_end_line>:
	if(DEBUGGING){
		printf("%s:%s\t", name, value);
	}
}
void tinyDebugger_end_line(){
     88a:	08 95       	ret

0000088c <tinyDendrite_read_signals>:
	}
}

uint8_t tinyDendrite_get_value(uint8_t dendrite_number){
	return tinyDendrite_values[dendrite_number];
}
     88c:	ef 92       	push	r14
     88e:	ff 92       	push	r15
     890:	0f 93       	push	r16
     892:	1f 93       	push	r17
     894:	cf 93       	push	r28
     896:	df 93       	push	r29
     898:	ce e0       	ldi	r28, 0x0E	; 14
     89a:	d8 e3       	ldi	r29, 0x38	; 56
     89c:	00 e4       	ldi	r16, 0x40	; 64
     89e:	18 e3       	ldi	r17, 0x38	; 56
     8a0:	0f 2e       	mov	r0, r31
     8a2:	f3 e1       	ldi	r31, 0x13	; 19
     8a4:	ef 2e       	mov	r14, r31
     8a6:	f8 e3       	ldi	r31, 0x38	; 56
     8a8:	ff 2e       	mov	r15, r31
     8aa:	f0 2d       	mov	r31, r0
     8ac:	89 91       	ld	r24, Y+
     8ae:	0e 94 d4 00 	call	0x1a8	; 0x1a8 <ADC_0_get_conversion>
     8b2:	f8 01       	movw	r30, r16
     8b4:	81 93       	st	Z+, r24
     8b6:	8f 01       	movw	r16, r30
     8b8:	ce 15       	cp	r28, r14
     8ba:	df 05       	cpc	r29, r15
     8bc:	b9 f7       	brne	.-18     	; 0x8ac <tinyDendrite_read_signals+0x20>
     8be:	df 91       	pop	r29
     8c0:	cf 91       	pop	r28
     8c2:	1f 91       	pop	r17
     8c4:	0f 91       	pop	r16
     8c6:	ff 90       	pop	r15
     8c8:	ef 90       	pop	r14
     8ca:	08 95       	ret

000008cc <tinyDendrite_check_charge_level>:

_Bool tinyDendrite_check_charge_level(void)
{
     8cc:	cf 93       	push	r28
     8ce:	df 93       	push	r29
	_Bool charging = false;
	
	tinyDendrite_read_signals();
     8d0:	0e 94 46 04 	call	0x88c	; 0x88c <tinyDendrite_read_signals>
     8d4:	eb e3       	ldi	r30, 0x3B	; 59
     8d6:	f8 e3       	ldi	r31, 0x38	; 56
     8d8:	c6 e3       	ldi	r28, 0x36	; 54
     8da:	d8 e3       	ldi	r29, 0x38	; 56
     8dc:	a0 e4       	ldi	r26, 0x40	; 64
     8de:	b8 e3       	ldi	r27, 0x38	; 56
     8e0:	20 e4       	ldi	r18, 0x40	; 64
     8e2:	38 e3       	ldi	r19, 0x38	; 56
	return tinyDendrite_values[dendrite_number];
}

_Bool tinyDendrite_check_charge_level(void)
{
	_Bool charging = false;
     8e4:	80 e0       	ldi	r24, 0x00	; 0
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = CHARGING;
     8e6:	47 e0       	ldi	r20, 0x07	; 7
	_Bool charging = false;
	
	tinyDendrite_read_signals();
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
     8e8:	90 81       	ld	r25, Z
     8ea:	99 93       	st	Y+, r25
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
     8ec:	9d 91       	ld	r25, X+
     8ee:	99 3e       	cpi	r25, 0xE9	; 233
     8f0:	10 f0       	brcs	.+4      	; 0x8f6 <tinyDendrite_check_charge_level+0x2a>
		{
			tinyDendrite_current_signals[i] = CHARGING;
     8f2:	40 83       	st	Z, r20
			charging = true;
     8f4:	81 e0       	ldi	r24, 0x01	; 1
     8f6:	31 96       	adiw	r30, 0x01	; 1
_Bool tinyDendrite_check_charge_level(void)
{
	_Bool charging = false;
	
	tinyDendrite_read_signals();
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
     8f8:	e2 17       	cp	r30, r18
     8fa:	f3 07       	cpc	r31, r19
     8fc:	a9 f7       	brne	.-22     	; 0x8e8 <tinyDendrite_check_charge_level+0x1c>
			tinyDendrite_current_signals[i] = CHARGING;
			charging = true;
		}
	}
	return charging;
}
     8fe:	df 91       	pop	r29
     900:	cf 91       	pop	r28
     902:	08 95       	ret

00000904 <tinyDendrite_update_signals>:

/*
This function converts the 8 bit value from the ADC into one of the signal types defined in DendriteSignal
*/
void tinyDendrite_update_signals(void)
{
     904:	af 92       	push	r10
     906:	bf 92       	push	r11
     908:	df 92       	push	r13
     90a:	ef 92       	push	r14
     90c:	ff 92       	push	r15
     90e:	0f 93       	push	r16
     910:	1f 93       	push	r17
     912:	cf 93       	push	r28
     914:	df 93       	push	r29
	
	// This function does not read the dendrite values! Read_signals must be called somewhere prior to this function!
	// As of writing this, the update_charging_mode function in main runs check_charge_level, so 
	// the tinyDendrite_values are updated when update_signals is called later
	
	tinyDebugger_send_uint8("D1", tinyDendrite_values[0]);
     916:	c0 e4       	ldi	r28, 0x40	; 64
     918:	d8 e3       	ldi	r29, 0x38	; 56
     91a:	68 81       	ld	r22, Y
     91c:	89 e5       	ldi	r24, 0x59	; 89
     91e:	9a e9       	ldi	r25, 0x9A	; 154
     920:	0e 94 43 04 	call	0x886	; 0x886 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D2", tinyDendrite_values[1]);
     924:	69 81       	ldd	r22, Y+1	; 0x01
     926:	8c e5       	ldi	r24, 0x5C	; 92
     928:	9a e9       	ldi	r25, 0x9A	; 154
     92a:	0e 94 43 04 	call	0x886	; 0x886 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D3", tinyDendrite_values[2]);
     92e:	6a 81       	ldd	r22, Y+2	; 0x02
     930:	8f e5       	ldi	r24, 0x5F	; 95
     932:	9a e9       	ldi	r25, 0x9A	; 154
     934:	0e 94 43 04 	call	0x886	; 0x886 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D4", tinyDendrite_values[3]);
     938:	6b 81       	ldd	r22, Y+3	; 0x03
     93a:	82 e6       	ldi	r24, 0x62	; 98
     93c:	9a e9       	ldi	r25, 0x9A	; 154
     93e:	0e 94 43 04 	call	0x886	; 0x886 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D5", tinyDendrite_values[4]);
     942:	6c 81       	ldd	r22, Y+4	; 0x04
     944:	85 e6       	ldi	r24, 0x65	; 101
     946:	9a e9       	ldi	r25, 0x9A	; 154
     948:	0e 94 43 04 	call	0x886	; 0x886 <tinyDebugger_send_uint8>
     94c:	eb e3       	ldi	r30, 0x3B	; 59
     94e:	f8 e3       	ldi	r31, 0x38	; 56
     950:	26 e3       	ldi	r18, 0x36	; 54
     952:	38 e3       	ldi	r19, 0x38	; 56
     954:	40 e4       	ldi	r20, 0x40	; 64
     956:	58 e3       	ldi	r21, 0x38	; 56
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     958:	dd 24       	eor	r13, r13
     95a:	d3 94       	inc	r13
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
		}
		else if (tinyDendrite_values[i] > HIGH_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
     95c:	0f 2e       	mov	r0, r31
     95e:	f3 e0       	ldi	r31, 0x03	; 3
     960:	ef 2e       	mov	r14, r31
     962:	f0 2d       	mov	r31, r0
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     964:	68 94       	set
     966:	ff 24       	eor	r15, r15
     968:	f1 f8       	bld	r15, 1
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     96a:	04 e0       	ldi	r16, 0x04	; 4
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     96c:	16 e0       	ldi	r17, 0x06	; 6
			// been moved to tinyDendrite_check_charging.
			//charging = true;
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     96e:	75 e0       	ldi	r23, 0x05	; 5
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = CHARGING;
     970:	67 e0       	ldi	r22, 0x07	; 7
     972:	5f 01       	movw	r10, r30
	tinyDebugger_send_uint8("D4", tinyDendrite_values[3]);
	tinyDebugger_send_uint8("D5", tinyDendrite_values[4]);
	
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
     974:	80 81       	ld	r24, Z
     976:	d9 01       	movw	r26, r18
     978:	8d 93       	st	X+, r24
     97a:	9d 01       	movw	r18, r26
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
     97c:	99 91       	ld	r25, Y+
     97e:	99 3e       	cpi	r25, 0xE9	; 233
     980:	10 f0       	brcs	.+4      	; 0x986 <tinyDendrite_update_signals+0x82>
		{
			tinyDendrite_current_signals[i] = CHARGING;
     982:	60 83       	st	Z, r22
     984:	19 c0       	rjmp	.+50     	; 0x9b8 <tinyDendrite_update_signals+0xb4>
			// Previously, we used this function to check charging, but this has now
			// been moved to tinyDendrite_check_charging.
			//charging = true;
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
     986:	98 3c       	cpi	r25, 0xC8	; 200
     988:	10 f0       	brcs	.+4      	; 0x98e <tinyDendrite_update_signals+0x8a>
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     98a:	70 83       	st	Z, r23
     98c:	15 c0       	rjmp	.+42     	; 0x9b8 <tinyDendrite_update_signals+0xb4>
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
     98e:	97 3a       	cpi	r25, 0xA7	; 167
     990:	10 f0       	brcs	.+4      	; 0x996 <tinyDendrite_update_signals+0x92>
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     992:	10 83       	st	Z, r17
     994:	11 c0       	rjmp	.+34     	; 0x9b8 <tinyDendrite_update_signals+0xb4>
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
     996:	95 38       	cpi	r25, 0x85	; 133
     998:	10 f0       	brcs	.+4      	; 0x99e <tinyDendrite_update_signals+0x9a>
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     99a:	00 83       	st	Z, r16
     99c:	0d c0       	rjmp	.+26     	; 0x9b8 <tinyDendrite_update_signals+0xb4>
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
     99e:	94 36       	cpi	r25, 0x64	; 100
     9a0:	10 f0       	brcs	.+4      	; 0x9a6 <tinyDendrite_update_signals+0xa2>
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     9a2:	f0 82       	st	Z, r15
     9a4:	09 c0       	rjmp	.+18     	; 0x9b8 <tinyDendrite_update_signals+0xb4>
		}
		else if (tinyDendrite_values[i] > HIGH_INHIB_THRESHOLD)
     9a6:	93 34       	cpi	r25, 0x43	; 67
     9a8:	10 f0       	brcs	.+4      	; 0x9ae <tinyDendrite_update_signals+0xaa>
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
     9aa:	e0 82       	st	Z, r14
     9ac:	05 c0       	rjmp	.+10     	; 0x9b8 <tinyDendrite_update_signals+0xb4>
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
     9ae:	92 32       	cpi	r25, 0x22	; 34
     9b0:	10 f0       	brcs	.+4      	; 0x9b6 <tinyDendrite_update_signals+0xb2>
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     9b2:	d0 82       	st	Z, r13
     9b4:	01 c0       	rjmp	.+2      	; 0x9b8 <tinyDendrite_update_signals+0xb4>
		}
		else
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     9b6:	10 82       	st	Z, r1
		}
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
     9b8:	d5 01       	movw	r26, r10
     9ba:	9c 91       	ld	r25, X
     9bc:	89 13       	cpse	r24, r25
     9be:	01 c0       	rjmp	.+2      	; 0x9c2 <tinyDendrite_update_signals+0xbe>
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     9c0:	1c 92       	st	X, r1
     9c2:	31 96       	adiw	r30, 0x01	; 1
	tinyDebugger_send_uint8("D2", tinyDendrite_values[1]);
	tinyDebugger_send_uint8("D3", tinyDendrite_values[2]);
	tinyDebugger_send_uint8("D4", tinyDendrite_values[3]);
	tinyDebugger_send_uint8("D5", tinyDendrite_values[4]);
	
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
     9c4:	e4 17       	cp	r30, r20
     9c6:	f5 07       	cpc	r31, r21
     9c8:	a1 f6       	brne	.-88     	; 0x972 <tinyDendrite_update_signals+0x6e>
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
		}
	}
}
     9ca:	df 91       	pop	r29
     9cc:	cf 91       	pop	r28
     9ce:	1f 91       	pop	r17
     9d0:	0f 91       	pop	r16
     9d2:	ff 90       	pop	r15
     9d4:	ef 90       	pop	r14
     9d6:	df 90       	pop	r13
     9d8:	bf 90       	pop	r11
     9da:	af 90       	pop	r10
     9dc:	08 95       	ret

000009de <tinyDendrite_get_potential>:
/*
This is the master function of the module that is callable from
outside. It uses the previously declared functions to return the potential.
*/
int16_t tinyDendrite_get_potential()
{
     9de:	ef 92       	push	r14
     9e0:	ff 92       	push	r15
     9e2:	0f 93       	push	r16
     9e4:	1f 93       	push	r17
     9e6:	cf 93       	push	r28
     9e8:	df 93       	push	r29
	if(tinyAxon_is_firing() && IGNORE_INPUT_WHILE_FIRING){
     9ea:	0e 94 52 02 	call	0x4a4	; 0x4a4 <tinyAxon_is_firing>
		
		return NO_SIGNAL_REACTION;
	}
	
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
     9ee:	0e 94 82 04 	call	0x904	; 0x904 <tinyDendrite_update_signals>
     9f2:	cb e3       	ldi	r28, 0x3B	; 59
     9f4:	d8 e3       	ldi	r29, 0x38	; 56
     9f6:	0f 2e       	mov	r0, r31
     9f8:	f0 e4       	ldi	r31, 0x40	; 64
     9fa:	ef 2e       	mov	r14, r31
     9fc:	f8 e3       	ldi	r31, 0x38	; 56
     9fe:	ff 2e       	mov	r15, r31
     a00:	f0 2d       	mov	r31, r0
	
	int16_t return_potential_val = 0;
     a02:	00 e0       	ldi	r16, 0x00	; 0
     a04:	10 e0       	ldi	r17, 0x00	; 0
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		switch(tinyDendrite_current_signals[i])
     a06:	89 91       	ld	r24, Y+
     a08:	83 30       	cpi	r24, 0x03	; 3
     a0a:	01 f1       	breq	.+64     	; 0xa4c <tinyDendrite_get_potential+0x6e>
     a0c:	28 f4       	brcc	.+10     	; 0xa18 <tinyDendrite_get_potential+0x3a>
     a0e:	81 30       	cpi	r24, 0x01	; 1
     a10:	59 f1       	breq	.+86     	; 0xa68 <tinyDendrite_get_potential+0x8a>
     a12:	82 30       	cpi	r24, 0x02	; 2
     a14:	11 f1       	breq	.+68     	; 0xa5a <tinyDendrite_get_potential+0x7c>
     a16:	2e c0       	rjmp	.+92     	; 0xa74 <tinyDendrite_get_potential+0x96>
     a18:	85 30       	cpi	r24, 0x05	; 5
     a1a:	51 f0       	breq	.+20     	; 0xa30 <tinyDendrite_get_potential+0x52>
     a1c:	80 f0       	brcs	.+32     	; 0xa3e <tinyDendrite_get_potential+0x60>
     a1e:	86 30       	cpi	r24, 0x06	; 6
     a20:	49 f5       	brne	.+82     	; 0xa74 <tinyDendrite_get_potential+0x96>
		{
			case NO_SIGNAL:
				return_potential_val += NO_SIGNAL_REACTION;
				break;
			case HIGH_EXCITE:
				return_potential_val += HIGH_EXCITE_REACTION;
     a22:	0c 5c       	subi	r16, 0xCC	; 204
     a24:	1f 4f       	sbci	r17, 0xFF	; 255
				tinyLED_queue_flash(INN_LED, GREEN);
     a26:	63 e0       	ldi	r22, 0x03	; 3
     a28:	80 e0       	ldi	r24, 0x00	; 0
     a2a:	0e 94 a1 05 	call	0xb42	; 0xb42 <tinyLED_queue_flash>
				break;
     a2e:	22 c0       	rjmp	.+68     	; 0xa74 <tinyDendrite_get_potential+0x96>
			case NORMAL_EXCITE:
				return_potential_val += NORMAL_EXCITE_REACTION;
     a30:	07 5e       	subi	r16, 0xE7	; 231
     a32:	1f 4f       	sbci	r17, 0xFF	; 255
				tinyLED_queue_flash(INN_LED, GREEN);
     a34:	63 e0       	ldi	r22, 0x03	; 3
     a36:	80 e0       	ldi	r24, 0x00	; 0
     a38:	0e 94 a1 05 	call	0xb42	; 0xb42 <tinyLED_queue_flash>
				break;
     a3c:	1b c0       	rjmp	.+54     	; 0xa74 <tinyDendrite_get_potential+0x96>
			case LOW_EXCITE:
				return_potential_val += LOW_EXCITE_REACTION;
     a3e:	0c 5e       	subi	r16, 0xEC	; 236
     a40:	1f 4f       	sbci	r17, 0xFF	; 255
				tinyLED_queue_flash(INN_LED, GREEN);
     a42:	63 e0       	ldi	r22, 0x03	; 3
     a44:	80 e0       	ldi	r24, 0x00	; 0
     a46:	0e 94 a1 05 	call	0xb42	; 0xb42 <tinyLED_queue_flash>
				break;
     a4a:	14 c0       	rjmp	.+40     	; 0xa74 <tinyDendrite_get_potential+0x96>
			case HIGH_INHIB:
				return_potential_val += HIGH_INHIB_REACTION;
     a4c:	02 53       	subi	r16, 0x32	; 50
     a4e:	11 09       	sbc	r17, r1
				tinyLED_queue_flash(INN_LED, RED);
     a50:	61 e0       	ldi	r22, 0x01	; 1
     a52:	80 e0       	ldi	r24, 0x00	; 0
     a54:	0e 94 a1 05 	call	0xb42	; 0xb42 <tinyLED_queue_flash>
				break;
     a58:	0d c0       	rjmp	.+26     	; 0xa74 <tinyDendrite_get_potential+0x96>
			case NORMAL_INHIB:
				return_potential_val += NORMAL_INHIB_REACTION;
     a5a:	09 51       	subi	r16, 0x19	; 25
     a5c:	11 09       	sbc	r17, r1
				tinyLED_queue_flash(INN_LED, RED);
     a5e:	61 e0       	ldi	r22, 0x01	; 1
     a60:	80 e0       	ldi	r24, 0x00	; 0
     a62:	0e 94 a1 05 	call	0xb42	; 0xb42 <tinyLED_queue_flash>
				break;
     a66:	06 c0       	rjmp	.+12     	; 0xa74 <tinyDendrite_get_potential+0x96>
			case LOW_INHIB:
				return_potential_val += LOW_INHIB_REACTION;
     a68:	04 51       	subi	r16, 0x14	; 20
     a6a:	11 09       	sbc	r17, r1
				tinyLED_queue_flash(INN_LED, RED);
     a6c:	61 e0       	ldi	r22, 0x01	; 1
     a6e:	80 e0       	ldi	r24, 0x00	; 0
     a70:	0e 94 a1 05 	call	0xb42	; 0xb42 <tinyLED_queue_flash>
	
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
	
	int16_t return_potential_val = 0;
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
     a74:	ce 15       	cp	r28, r14
     a76:	df 05       	cpc	r29, r15
     a78:	31 f6       	brne	.-116    	; 0xa06 <tinyDendrite_get_potential+0x28>
	
	
	
	return return_potential_val;
	
}
     a7a:	c8 01       	movw	r24, r16
     a7c:	df 91       	pop	r29
     a7e:	cf 91       	pop	r28
     a80:	1f 91       	pop	r17
     a82:	0f 91       	pop	r16
     a84:	ff 90       	pop	r15
     a86:	ef 90       	pop	r14
     a88:	08 95       	ret

00000a8a <tinyDendrite_update_potential>:

double tinyDendrite_update_potential(double potential){
     a8a:	cf 92       	push	r12
     a8c:	df 92       	push	r13
     a8e:	ef 92       	push	r14
     a90:	ff 92       	push	r15
     a92:	6b 01       	movw	r12, r22
     a94:	7c 01       	movw	r14, r24
	
	int16_t potential_change = tinyDendrite_get_potential();
     a96:	0e 94 ef 04 	call	0x9de	; 0x9de <tinyDendrite_get_potential>
	potential += potential_change;
	return potential;
     a9a:	bc 01       	movw	r22, r24
     a9c:	99 0f       	add	r25, r25
     a9e:	88 0b       	sbc	r24, r24
     aa0:	99 0b       	sbc	r25, r25
     aa2:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__floatsisf>
     aa6:	a7 01       	movw	r20, r14
     aa8:	96 01       	movw	r18, r12
     aaa:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <__addsf3>
     aae:	ff 90       	pop	r15
     ab0:	ef 90       	pop	r14
     ab2:	df 90       	pop	r13
     ab4:	cf 90       	pop	r12
     ab6:	08 95       	ret

00000ab8 <__vector_6>:
This function is called every time the RTC (Real Time Clock) counter overflows.
With the current settings, it will be called every ms.
The RTC clock runs at 1kHz, and the number of cycles before overflow is set with RTC.PER = someHexValue (e.g. 0x20) in src/rtc.c
*/
ISR(RTC_CNT_vect)
{
     ab8:	1f 92       	push	r1
     aba:	0f 92       	push	r0
     abc:	0f b6       	in	r0, 0x3f	; 63
     abe:	0f 92       	push	r0
     ac0:	11 24       	eor	r1, r1
     ac2:	2f 93       	push	r18
     ac4:	3f 93       	push	r19
     ac6:	4f 93       	push	r20
     ac8:	5f 93       	push	r21
     aca:	6f 93       	push	r22
     acc:	7f 93       	push	r23
     ace:	8f 93       	push	r24
     ad0:	9f 93       	push	r25
     ad2:	af 93       	push	r26
     ad4:	bf 93       	push	r27
     ad6:	cf 93       	push	r28
     ad8:	ef 93       	push	r30
     ada:	ff 93       	push	r31
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     adc:	c1 e0       	ldi	r28, 0x01	; 1
     ade:	c0 93 45 38 	sts	0x3845, r28	; 0x803845 <tinyISR_interrupt_flag>
{
	// Set flag to let main loop run a new cycle
	tinyISR_setflag(true);
	
	// Timer counter incrementation
	tinyTime_counter_increment();
     ae2:	0e 94 4d 09 	call	0x129a	; 0x129a <tinyTime_counter_increment>

	/* Overflow interrupt flag has to be cleared manually */
	RTC.INTFLAGS = RTC_OVF_bm;
     ae6:	c0 93 43 01 	sts	0x0143, r28	; 0x800143 <__TEXT_REGION_LENGTH__+0x700143>
}
     aea:	ff 91       	pop	r31
     aec:	ef 91       	pop	r30
     aee:	cf 91       	pop	r28
     af0:	bf 91       	pop	r27
     af2:	af 91       	pop	r26
     af4:	9f 91       	pop	r25
     af6:	8f 91       	pop	r24
     af8:	7f 91       	pop	r23
     afa:	6f 91       	pop	r22
     afc:	5f 91       	pop	r21
     afe:	4f 91       	pop	r20
     b00:	3f 91       	pop	r19
     b02:	2f 91       	pop	r18
     b04:	0f 90       	pop	r0
     b06:	0f be       	out	0x3f, r0	; 63
     b08:	0f 90       	pop	r0
     b0a:	1f 90       	pop	r1
     b0c:	18 95       	reti

00000b0e <tinyISR_setflag>:
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     b0e:	80 93 45 38 	sts	0x3845, r24	; 0x803845 <tinyISR_interrupt_flag>
     b12:	08 95       	ret

00000b14 <tinyISR_getflag>:
}

_Bool tinyISR_getflag(void)
{
	return tinyISR_interrupt_flag;
}
     b14:	80 91 45 38 	lds	r24, 0x3845	; 0x803845 <tinyISR_interrupt_flag>
     b18:	08 95       	ret

00000b1a <tinyLED_SPIWriteByte>:
Function used to send a byte over SPI, which in turn gets
translated to the bit-sequence required by the LEDs over the CCL.
*/
static void tinyLED_SPIWriteByte(uint8_t byte)
{
	SPI0.INTFLAGS = SPI0_INTFLAGS; // clear the write collision flag to allow writing
     b1a:	90 91 23 08 	lds	r25, 0x0823	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
     b1e:	90 93 23 08 	sts	0x0823, r25	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
	TCA0.SINGLE.CNT = 0; // reset TCA counter register to ensure the first rising edge of the PWM is predictable
     b22:	e0 e0       	ldi	r30, 0x00	; 0
     b24:	fa e0       	ldi	r31, 0x0A	; 10
     b26:	10 a2       	std	Z+32, r1	; 0x20
     b28:	11 a2       	std	Z+33, r1	; 0x21
	
	// start TCA
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 1 << TCA_SPLIT_ENABLE_bp;
     b2a:	91 e0       	ldi	r25, 0x01	; 1
     b2c:	90 83       	st	Z, r25
	SPI0_DATA = byte;
     b2e:	80 93 24 08 	sts	0x0824, r24	; 0x800824 <__TEXT_REGION_LENGTH__+0x700824>

	while((SPI0.INTFLAGS & SPI_RXCIE_bm) == 0){} // wait for transfer to complete
     b32:	e0 e2       	ldi	r30, 0x20	; 32
     b34:	f8 e0       	ldi	r31, 0x08	; 8
     b36:	83 81       	ldd	r24, Z+3	; 0x03
     b38:	88 23       	and	r24, r24
     b3a:	ec f7       	brge	.-6      	; 0xb36 <tinyLED_SPIWriteByte+0x1c>
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 0 << TCA_SPLIT_ENABLE_bp; //Stop TCA
     b3c:	10 92 00 0a 	sts	0x0A00, r1	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
     b40:	08 95       	ret

00000b42 <tinyLED_queue_flash>:
adds a color to the flash queue
*/
void tinyLED_queue_flash(uint8_t LED_id, enum Colors color)
{
	// We ignore a request to queue a flash if the queue is full
	if(flashes_in_queue < 16){
     b42:	90 91 46 38 	lds	r25, 0x3846	; 0x803846 <flashes_in_queue>
     b46:	90 31       	cpi	r25, 0x10	; 16
     b48:	68 f4       	brcc	.+26     	; 0xb64 <tinyLED_queue_flash+0x22>
		flash_queue[flashes_in_queue] = color;
     b4a:	29 2f       	mov	r18, r25
     b4c:	30 e0       	ldi	r19, 0x00	; 0
     b4e:	f9 01       	movw	r30, r18
     b50:	eb 59       	subi	r30, 0x9B	; 155
     b52:	f7 4c       	sbci	r31, 0xC7	; 199
     b54:	60 83       	st	Z, r22
		flash_queue_ids[flashes_in_queue] = LED_id;
     b56:	f9 01       	movw	r30, r18
     b58:	e3 58       	subi	r30, 0x83	; 131
     b5a:	f7 4c       	sbci	r31, 0xC7	; 199
     b5c:	80 83       	st	Z, r24
		flashes_in_queue++;
     b5e:	9f 5f       	subi	r25, 0xFF	; 255
     b60:	90 93 46 38 	sts	0x3846, r25	; 0x803846 <flashes_in_queue>
     b64:	08 95       	ret

00000b66 <tinyLED_get_color>:
	tinyLED_set_color_mode(LED_id, color, STABLE);
}

enum Colors tinyLED_get_color(uint8_t LED_id)
{
	return tinyLED_settings[LED_id].color;
     b66:	e8 2f       	mov	r30, r24
     b68:	f0 e0       	ldi	r31, 0x00	; 0
     b6a:	ee 0f       	add	r30, r30
     b6c:	ff 1f       	adc	r31, r31
     b6e:	eb 58       	subi	r30, 0x8B	; 139
     b70:	f7 4c       	sbci	r31, 0xC7	; 199
}
     b72:	80 81       	ld	r24, Z
     b74:	08 95       	ret

00000b76 <tinyLED_set_color_mode>:
{
	// If we are in pulse mode, we want to stay in pulse mode after we have flashed a light.
	// We do this by storing the previous mode in old settings.
	// However, it can happen that two flashes comes very quickly after one another, that leads
	// to an infinite flash loop, therefore, we only store the settings if it is not flash mode.
	if(tinyLED_settings[LED_id].mode != FLASH_ONCE){
     b76:	90 e0       	ldi	r25, 0x00	; 0
     b78:	fc 01       	movw	r30, r24
     b7a:	ee 0f       	add	r30, r30
     b7c:	ff 1f       	adc	r31, r31
     b7e:	eb 58       	subi	r30, 0x8B	; 139
     b80:	f7 4c       	sbci	r31, 0xC7	; 199
     b82:	51 81       	ldd	r21, Z+1	; 0x01
     b84:	55 30       	cpi	r21, 0x05	; 5
     b86:	61 f0       	breq	.+24     	; 0xba0 <tinyLED_set_color_mode+0x2a>
		// We use two lines to avoid pointer trouble. (I'm not good with pointers)
		tinyLED_old_settings[LED_id].color = tinyLED_settings[LED_id].color;
     b88:	9c 01       	movw	r18, r24
     b8a:	22 0f       	add	r18, r18
     b8c:	33 1f       	adc	r19, r19
     b8e:	f9 01       	movw	r30, r18
     b90:	e7 58       	subi	r30, 0x87	; 135
     b92:	f7 4c       	sbci	r31, 0xC7	; 199
     b94:	d9 01       	movw	r26, r18
     b96:	ab 58       	subi	r26, 0x8B	; 139
     b98:	b7 4c       	sbci	r27, 0xC7	; 199
     b9a:	2c 91       	ld	r18, X
     b9c:	20 83       	st	Z, r18
		tinyLED_old_settings[LED_id].mode = tinyLED_settings[LED_id].mode;
     b9e:	51 83       	std	Z+1, r21	; 0x01
	}
	
	struct ColorSetting new_setting = {.color=color, .mode=mode};
	tinyLED_settings[LED_id] = new_setting;
     ba0:	fc 01       	movw	r30, r24
     ba2:	ee 0f       	add	r30, r30
     ba4:	ff 1f       	adc	r31, r31
     ba6:	eb 58       	subi	r30, 0x8B	; 139
     ba8:	f7 4c       	sbci	r31, 0xC7	; 199
     baa:	60 83       	st	Z, r22
     bac:	41 83       	std	Z+1, r20	; 0x01
	if (mode == FLASH_ONCE)
     bae:	45 30       	cpi	r20, 0x05	; 5
     bb0:	b9 f4       	brne	.+46     	; 0xbe0 <tinyLED_set_color_mode+0x6a>
	{
		// If there is only one flash in the queue, we can let it flash longer
		if(flashes_in_queue>1){
     bb2:	20 91 46 38 	lds	r18, 0x3846	; 0x803846 <flashes_in_queue>
     bb6:	22 30       	cpi	r18, 0x02	; 2
     bb8:	50 f0       	brcs	.+20     	; 0xbce <tinyLED_set_color_mode+0x58>
			tinyLED_flash_once_time[LED_id] = 1000*QUEUE_FLASH_TIME;
     bba:	88 0f       	add	r24, r24
     bbc:	99 1f       	adc	r25, r25
     bbe:	fc 01       	movw	r30, r24
     bc0:	e5 5a       	subi	r30, 0xA5	; 165
     bc2:	f7 4c       	sbci	r31, 0xC7	; 199
     bc4:	84 e6       	ldi	r24, 0x64	; 100
     bc6:	90 e0       	ldi	r25, 0x00	; 0
     bc8:	80 83       	st	Z, r24
     bca:	91 83       	std	Z+1, r25	; 0x01
     bcc:	08 95       	ret
		}
		else{
			tinyLED_flash_once_time[LED_id] = 1000*FLASH_TIME;
     bce:	88 0f       	add	r24, r24
     bd0:	99 1f       	adc	r25, r25
     bd2:	fc 01       	movw	r30, r24
     bd4:	e5 5a       	subi	r30, 0xA5	; 165
     bd6:	f7 4c       	sbci	r31, 0xC7	; 199
     bd8:	88 ec       	ldi	r24, 0xC8	; 200
     bda:	90 e0       	ldi	r25, 0x00	; 0
     bdc:	80 83       	st	Z, r24
     bde:	91 83       	std	Z+1, r25	; 0x01
     be0:	08 95       	ret

00000be2 <tinyLED_set_color>:
/*
changes the values in the variables stored in the LED-array.
*/
void tinyLED_set_color(uint8_t LED_id, enum Colors color)
{
	tinyLED_set_color_mode(LED_id, color, STABLE);
     be2:	40 e0       	ldi	r20, 0x00	; 0
     be4:	0e 94 bb 05 	call	0xb76	; 0xb76 <tinyLED_set_color_mode>
     be8:	08 95       	ret

00000bea <tinyLED_RGB_Color_Compare>:
	return rgb_color;
			
};
// This might be cause of strange light behavior?
//Message		expected 'struct RGB_Color *' but argument is of type 'struct RGB_Color (*)[2]'	Hjernebyggesett_V4	C:\Users\Elias Lundheim\Documents\GitHub\neural\Hjernebyggesett_V4\Hjernebyggesett_V4\tinyLED\tinyLED.c	121
_Bool tinyLED_RGB_Color_Compare(struct RGB_Color (*a)[NUMBER_OF_LEDS], struct RGB_Color (*b)[NUMBER_OF_LEDS]){
     bea:	dc 01       	movw	r26, r24
     bec:	fb 01       	movw	r30, r22
	for (int i=0; i<NUMBER_OF_LEDS; i++)
	{
		if(!((*a)[i].red==(*b)[i].red && (*a)[i].green==(*b)[i].green && (*a)[i].blue==(*b)[i].blue)){
     bee:	9c 91       	ld	r25, X
     bf0:	80 81       	ld	r24, Z
     bf2:	98 13       	cpse	r25, r24
     bf4:	20 c0       	rjmp	.+64     	; 0xc36 <tinyLED_RGB_Color_Compare+0x4c>
     bf6:	11 96       	adiw	r26, 0x01	; 1
     bf8:	9c 91       	ld	r25, X
     bfa:	11 97       	sbiw	r26, 0x01	; 1
     bfc:	81 81       	ldd	r24, Z+1	; 0x01
     bfe:	98 13       	cpse	r25, r24
     c00:	1c c0       	rjmp	.+56     	; 0xc3a <tinyLED_RGB_Color_Compare+0x50>
     c02:	12 96       	adiw	r26, 0x02	; 2
     c04:	9c 91       	ld	r25, X
     c06:	12 97       	sbiw	r26, 0x02	; 2
     c08:	82 81       	ldd	r24, Z+2	; 0x02
     c0a:	98 13       	cpse	r25, r24
     c0c:	18 c0       	rjmp	.+48     	; 0xc3e <tinyLED_RGB_Color_Compare+0x54>
     c0e:	13 96       	adiw	r26, 0x03	; 3
     c10:	9c 91       	ld	r25, X
     c12:	13 97       	sbiw	r26, 0x03	; 3
     c14:	83 81       	ldd	r24, Z+3	; 0x03
     c16:	98 13       	cpse	r25, r24
     c18:	14 c0       	rjmp	.+40     	; 0xc42 <tinyLED_RGB_Color_Compare+0x58>
     c1a:	14 96       	adiw	r26, 0x04	; 4
     c1c:	9c 91       	ld	r25, X
     c1e:	14 97       	sbiw	r26, 0x04	; 4
     c20:	84 81       	ldd	r24, Z+4	; 0x04
     c22:	98 13       	cpse	r25, r24
     c24:	10 c0       	rjmp	.+32     	; 0xc46 <tinyLED_RGB_Color_Compare+0x5c>
     c26:	81 e0       	ldi	r24, 0x01	; 1
     c28:	15 96       	adiw	r26, 0x05	; 5
     c2a:	2c 91       	ld	r18, X
     c2c:	95 81       	ldd	r25, Z+5	; 0x05
     c2e:	29 17       	cp	r18, r25
     c30:	59 f0       	breq	.+22     	; 0xc48 <tinyLED_RGB_Color_Compare+0x5e>
     c32:	80 e0       	ldi	r24, 0x00	; 0
     c34:	08 95       	ret
			return false;
     c36:	80 e0       	ldi	r24, 0x00	; 0
     c38:	08 95       	ret
     c3a:	80 e0       	ldi	r24, 0x00	; 0
     c3c:	08 95       	ret
     c3e:	80 e0       	ldi	r24, 0x00	; 0
     c40:	08 95       	ret
     c42:	80 e0       	ldi	r24, 0x00	; 0
     c44:	08 95       	ret
     c46:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	return true;
}
     c48:	08 95       	ret

00000c4a <tinyLED_update>:
/*
function to write the current LED-array on to the LEDs and
effectively update the values stored in the LEDs to the values stored in the MCU.
*/
void tinyLED_update(void)
{
     c4a:	2f 92       	push	r2
     c4c:	3f 92       	push	r3
     c4e:	4f 92       	push	r4
     c50:	5f 92       	push	r5
     c52:	6f 92       	push	r6
     c54:	7f 92       	push	r7
     c56:	8f 92       	push	r8
     c58:	9f 92       	push	r9
     c5a:	af 92       	push	r10
     c5c:	bf 92       	push	r11
     c5e:	cf 92       	push	r12
     c60:	df 92       	push	r13
     c62:	ef 92       	push	r14
     c64:	ff 92       	push	r15
     c66:	0f 93       	push	r16
     c68:	1f 93       	push	r17
     c6a:	cf 93       	push	r28
     c6c:	df 93       	push	r29
     c6e:	cd b7       	in	r28, 0x3d	; 61
     c70:	de b7       	in	r29, 0x3e	; 62
     c72:	6f 97       	sbiw	r28, 0x1f	; 31
     c74:	cd bf       	out	0x3d, r28	; 61
     c76:	de bf       	out	0x3e, r29	; 62
			
	uint32_t now = tinyTime_now();	
     c78:	0e 94 61 09 	call	0x12c2	; 0x12c2 <tinyTime_now>
     c7c:	6b 01       	movw	r12, r22
     c7e:	7c 01       	movw	r14, r24
	
	// This is a sin curve, but between 0 and 1 instead of -1 and 1
	double sinValue = 0.5+sin((double)now/(100*M_PI/SWING_RATE))/2;
     c80:	0e 94 b7 0a 	call	0x156e	; 0x156e <__floatunsisf>
     c84:	23 e6       	ldi	r18, 0x63	; 99
     c86:	34 e1       	ldi	r19, 0x14	; 20
     c88:	4d e1       	ldi	r20, 0x1D	; 29
     c8a:	54 e4       	ldi	r21, 0x44	; 68
     c8c:	0e 94 dc 09 	call	0x13b8	; 0x13b8 <__divsf3>
     c90:	0e 94 97 0c 	call	0x192e	; 0x192e <sin>
     c94:	20 e0       	ldi	r18, 0x00	; 0
     c96:	30 e0       	ldi	r19, 0x00	; 0
     c98:	40 e0       	ldi	r20, 0x00	; 0
     c9a:	5f e3       	ldi	r21, 0x3F	; 63
     c9c:	0e 94 2a 0c 	call	0x1854	; 0x1854 <__mulsf3>
     ca0:	20 e0       	ldi	r18, 0x00	; 0
     ca2:	30 e0       	ldi	r19, 0x00	; 0
     ca4:	40 e0       	ldi	r20, 0x00	; 0
     ca6:	5f e3       	ldi	r21, 0x3F	; 63
     ca8:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <__addsf3>
     cac:	6f 83       	std	Y+7, r22	; 0x07
     cae:	78 87       	std	Y+8, r23	; 0x08
     cb0:	89 87       	std	Y+9, r24	; 0x09
     cb2:	9a 87       	std	Y+10, r25	; 0x0a
	
	// If FLASH_RATE is one, then that means that the left side of the "<" will just count from 0 to 1000, and flash_on will be true for half of the time
	_Bool flash_on = now%(uint32_t)(1000/FLASH_RATE)  <   500/FLASH_RATE;
     cb4:	c7 01       	movw	r24, r14
     cb6:	b6 01       	movw	r22, r12
     cb8:	28 ee       	ldi	r18, 0xE8	; 232
     cba:	33 e0       	ldi	r19, 0x03	; 3
     cbc:	40 e0       	ldi	r20, 0x00	; 0
     cbe:	50 e0       	ldi	r21, 0x00	; 0
     cc0:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <__udivmodsi4>
     cc4:	22 24       	eor	r2, r2
     cc6:	23 94       	inc	r2
     cc8:	64 3f       	cpi	r22, 0xF4	; 244
     cca:	71 40       	sbci	r23, 0x01	; 1
     ccc:	81 05       	cpc	r24, r1
     cce:	91 05       	cpc	r25, r1
     cd0:	08 f0       	brcs	.+2      	; 0xcd4 <tinyLED_update+0x8a>
     cd2:	21 2c       	mov	r2, r1
	
	// PING_RATE is usually small, so the left side counts to some large number. Since flash_time usually is also quite small,
	// the left side will usually be larger than the right
	_Bool ping_on =  now%(uint32_t)(1000/PING_RATE)   <   1000*FLASH_TIME;
     cd4:	c7 01       	movw	r24, r14
     cd6:	b6 01       	movw	r22, r12
     cd8:	20 e1       	ldi	r18, 0x10	; 16
     cda:	37 e2       	ldi	r19, 0x27	; 39
     cdc:	40 e0       	ldi	r20, 0x00	; 0
     cde:	50 e0       	ldi	r21, 0x00	; 0
     ce0:	0e 94 00 0d 	call	0x1a00	; 0x1a00 <__udivmodsi4>
     ce4:	0e 94 b7 0a 	call	0x156e	; 0x156e <__floatunsisf>
     ce8:	20 e0       	ldi	r18, 0x00	; 0
     cea:	30 e0       	ldi	r19, 0x00	; 0
     cec:	48 e4       	ldi	r20, 0x48	; 72
     cee:	53 e4       	ldi	r21, 0x43	; 67
     cf0:	0e 94 d7 09 	call	0x13ae	; 0x13ae <__cmpsf2>
     cf4:	88 1f       	adc	r24, r24
     cf6:	88 27       	eor	r24, r24
     cf8:	88 1f       	adc	r24, r24
     cfa:	0f 2e       	mov	r0, r31
     cfc:	f5 e7       	ldi	r31, 0x75	; 117
     cfe:	8f 2e       	mov	r8, r31
     d00:	f8 e3       	ldi	r31, 0x38	; 56
     d02:	9f 2e       	mov	r9, r31
     d04:	f0 2d       	mov	r31, r0
     d06:	ae 01       	movw	r20, r28
     d08:	4f 5f       	subi	r20, 0xFF	; 255
     d0a:	5f 4f       	sbci	r21, 0xFF	; 255
     d0c:	6a 01       	movw	r12, r20
     d0e:	0f 2e       	mov	r0, r31
     d10:	f9 e7       	ldi	r31, 0x79	; 121
     d12:	af 2e       	mov	r10, r31
     d14:	f8 e3       	ldi	r31, 0x38	; 56
     d16:	bf 2e       	mov	r11, r31
     d18:	f0 2d       	mov	r31, r0
     d1a:	0f 2e       	mov	r0, r31
     d1c:	fb e5       	ldi	r31, 0x5B	; 91
     d1e:	4f 2e       	mov	r4, r31
     d20:	f8 e3       	ldi	r31, 0x38	; 56
     d22:	5f 2e       	mov	r5, r31
     d24:	f0 2d       	mov	r31, r0
     d26:	3a 01       	movw	r6, r20
	
	// This is where we store all the actual color values we want to send to the LED
	struct RGB_Color rgb_colors[NUMBER_OF_LEDS];
	
		
	for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
     d28:	31 2c       	mov	r3, r1
			case SWING:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*sinValue, rgb_colors[i].green*sinValue, rgb_colors[i].blue*sinValue};
				break;
			case PING:
				// in the line below, fmin will either return 1 or 0, so each rgb color is either 0 or 255*PING_BRIGHTNESS
				rgb_colors[i] = (struct RGB_Color){255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].red)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].green)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].blue)*ping_on};
     d2a:	28 2f       	mov	r18, r24
     d2c:	30 e0       	ldi	r19, 0x00	; 0
     d2e:	40 e0       	ldi	r20, 0x00	; 0
     d30:	50 e0       	ldi	r21, 0x00	; 0
     d32:	28 8b       	std	Y+16, r18	; 0x10
     d34:	39 8b       	std	Y+17, r19	; 0x11
     d36:	4a 8b       	std	Y+18, r20	; 0x12
     d38:	5b 8b       	std	Y+19, r21	; 0x13
     d3a:	2b 86       	std	Y+11, r2	; 0x0b
     d3c:	13 2d       	mov	r17, r3
     d3e:	74 01       	movw	r14, r8
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 0 << TCA_SPLIT_ENABLE_bp; //Stop TCA
}

static struct RGB_Color tinyLED_enum_to_RGB_Color(enum Colors color){
	struct RGB_Color rgb_color;
	switch(color)
     d40:	f4 01       	movw	r30, r8
     d42:	80 81       	ld	r24, Z
     d44:	83 30       	cpi	r24, 0x03	; 3
     d46:	79 f0       	breq	.+30     	; 0xd66 <tinyLED_update+0x11c>
     d48:	28 f4       	brcc	.+10     	; 0xd54 <tinyLED_update+0x10a>
     d4a:	81 30       	cpi	r24, 0x01	; 1
     d4c:	41 f0       	breq	.+16     	; 0xd5e <tinyLED_update+0x114>
     d4e:	82 30       	cpi	r24, 0x02	; 2
     d50:	71 f0       	breq	.+28     	; 0xd6e <tinyLED_update+0x124>
     d52:	19 c0       	rjmp	.+50     	; 0xd86 <tinyLED_update+0x13c>
     d54:	84 30       	cpi	r24, 0x04	; 4
     d56:	79 f0       	breq	.+30     	; 0xd76 <tinyLED_update+0x12c>
     d58:	85 30       	cpi	r24, 0x05	; 5
     d5a:	89 f0       	breq	.+34     	; 0xd7e <tinyLED_update+0x134>
     d5c:	14 c0       	rjmp	.+40     	; 0xd86 <tinyLED_update+0x13c>
	{
		case LED_OFF:
			rgb_color = (struct RGB_Color){0, 0, 0};
			break;
		case RED:
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 0, 0};
     d5e:	80 e0       	ldi	r24, 0x00	; 0
     d60:	90 e0       	ldi	r25, 0x00	; 0
     d62:	29 e1       	ldi	r18, 0x19	; 25
     d64:	13 c0       	rjmp	.+38     	; 0xd8c <tinyLED_update+0x142>
			break;
		case GREEN:
			rgb_color = (struct RGB_Color){0, 255*LED_BRIGHTNESS, 0};
     d66:	80 e0       	ldi	r24, 0x00	; 0
     d68:	99 e1       	ldi	r25, 0x19	; 25
     d6a:	20 e0       	ldi	r18, 0x00	; 0
     d6c:	0f c0       	rjmp	.+30     	; 0xd8c <tinyLED_update+0x142>
			break;
		case BLUE:
			rgb_color = (struct RGB_Color){0, 0, 255*LED_BRIGHTNESS};
     d6e:	89 e1       	ldi	r24, 0x19	; 25
     d70:	90 e0       	ldi	r25, 0x00	; 0
     d72:	20 e0       	ldi	r18, 0x00	; 0
     d74:	0b c0       	rjmp	.+22     	; 0xd8c <tinyLED_update+0x142>
			break;
		case YELLOW:
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS, 0};
     d76:	80 e0       	ldi	r24, 0x00	; 0
     d78:	99 e1       	ldi	r25, 0x19	; 25
     d7a:	29 e1       	ldi	r18, 0x19	; 25
     d7c:	07 c0       	rjmp	.+14     	; 0xd8c <tinyLED_update+0x142>
			// Should the /3 be there? This requires testing.
			// After testing, findings were that at 0.1 brightness, one would see the three LEDs instead of one white led
			// We try with /2 instead.
			// We find that the best results come from not dividing by anything. At leasts in the lower brightness settings, and that
			// is where we suspect it will be most of the time. When we divide, the LEDs are so weak, that they appear as three lights instead of one.
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS};
     d7e:	89 e1       	ldi	r24, 0x19	; 25
     d80:	99 e1       	ldi	r25, 0x19	; 25
     d82:	29 e1       	ldi	r18, 0x19	; 25
     d84:	03 c0       	rjmp	.+6      	; 0xd8c <tinyLED_update+0x142>
static struct RGB_Color tinyLED_enum_to_RGB_Color(enum Colors color){
	struct RGB_Color rgb_color;
	switch(color)
	{
		case LED_OFF:
			rgb_color = (struct RGB_Color){0, 0, 0};
     d86:	80 e0       	ldi	r24, 0x00	; 0
     d88:	90 e0       	ldi	r25, 0x00	; 0
     d8a:	20 e0       	ldi	r18, 0x00	; 0
     d8c:	13 01       	movw	r2, r6
	
		
	for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
	{		
		// Convert enum to RGB_Color
		rgb_colors[i] = tinyLED_enum_to_RGB_Color(tinyLED_settings[i].color);
     d8e:	f3 01       	movw	r30, r6
     d90:	20 83       	st	Z, r18
     d92:	91 83       	std	Z+1, r25	; 0x01
     d94:	82 83       	std	Z+2, r24	; 0x02
		// Check if there is a flash that can be queued
		// Complicated code (bad code): The best implementation would be to have a separate flash queue for each
		// LED, but I can't be bothered to deal with nested arrays. So we check a couple of things
		// It should work well so long as two LEDs aren't being queued to at the same time. If that does happen, 
		// nothing should break, but it will be slower to get the flashes out.
		if (flashes_in_queue>0 && tinyLED_settings[i].mode !=FLASH_ONCE && flash_queue_ids[flashes_in_queue] == i)
     d96:	80 91 46 38 	lds	r24, 0x3846	; 0x803846 <flashes_in_queue>
     d9a:	88 23       	and	r24, r24
     d9c:	c9 f0       	breq	.+50     	; 0xdd0 <tinyLED_update+0x186>
     d9e:	f7 01       	movw	r30, r14
     da0:	91 81       	ldd	r25, Z+1	; 0x01
     da2:	95 30       	cpi	r25, 0x05	; 5
     da4:	09 f4       	brne	.+2      	; 0xda8 <tinyLED_update+0x15e>
     da6:	25 c1       	rjmp	.+586    	; 0xff2 <tinyLED_update+0x3a8>
     da8:	90 e0       	ldi	r25, 0x00	; 0
     daa:	fc 01       	movw	r30, r24
     dac:	e3 58       	subi	r30, 0x83	; 131
     dae:	f7 4c       	sbci	r31, 0xC7	; 199
     db0:	20 81       	ld	r18, Z
     db2:	21 13       	cpse	r18, r17
     db4:	0d c0       	rjmp	.+26     	; 0xdd0 <tinyLED_update+0x186>
		{
			// This implementation is easier, but it means that the last flash into the queue is the first out.
			tinyLED_set_color_mode(flash_queue_ids[flashes_in_queue], flash_queue[flashes_in_queue], FLASH_ONCE);
     db6:	fc 01       	movw	r30, r24
     db8:	eb 59       	subi	r30, 0x9B	; 155
     dba:	f7 4c       	sbci	r31, 0xC7	; 199
     dbc:	45 e0       	ldi	r20, 0x05	; 5
     dbe:	60 81       	ld	r22, Z
     dc0:	81 2f       	mov	r24, r17
     dc2:	0e 94 bb 05 	call	0xb76	; 0xb76 <tinyLED_set_color_mode>
			flashes_in_queue--;
     dc6:	80 91 46 38 	lds	r24, 0x3846	; 0x803846 <flashes_in_queue>
     dca:	81 50       	subi	r24, 0x01	; 1
     dcc:	80 93 46 38 	sts	0x3846, r24	; 0x803846 <flashes_in_queue>
		}
		
		// Adjust colors according to mode
		switch(tinyLED_settings[i].mode)
     dd0:	f7 01       	movw	r30, r14
     dd2:	81 81       	ldd	r24, Z+1	; 0x01
     dd4:	83 30       	cpi	r24, 0x03	; 3
     dd6:	09 f4       	brne	.+2      	; 0xdda <tinyLED_update+0x190>
     dd8:	58 c0       	rjmp	.+176    	; 0xe8a <tinyLED_update+0x240>
     dda:	28 f4       	brcc	.+10     	; 0xde6 <tinyLED_update+0x19c>
     ddc:	81 30       	cpi	r24, 0x01	; 1
     dde:	51 f0       	breq	.+20     	; 0xdf4 <tinyLED_update+0x1aa>
     de0:	82 30       	cpi	r24, 0x02	; 2
     de2:	e1 f1       	breq	.+120    	; 0xe5c <tinyLED_update+0x212>
     de4:	17 c1       	rjmp	.+558    	; 0x1014 <tinyLED_update+0x3ca>
     de6:	84 30       	cpi	r24, 0x04	; 4
     de8:	09 f4       	brne	.+2      	; 0xdec <tinyLED_update+0x1a2>
     dea:	83 c0       	rjmp	.+262    	; 0xef2 <tinyLED_update+0x2a8>
     dec:	85 30       	cpi	r24, 0x05	; 5
     dee:	09 f4       	brne	.+2      	; 0xdf2 <tinyLED_update+0x1a8>
     df0:	00 c1       	rjmp	.+512    	; 0xff2 <tinyLED_update+0x3a8>
     df2:	10 c1       	rjmp	.+544    	; 0x1014 <tinyLED_update+0x3ca>
		{
			case STABLE:
				break;
			case WEAK:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*WEAK_BRIGHTNESS, rgb_colors[i].green*WEAK_BRIGHTNESS, rgb_colors[i].blue*WEAK_BRIGHTNESS};
     df4:	f1 01       	movw	r30, r2
     df6:	61 81       	ldd	r22, Z+1	; 0x01
     df8:	70 e0       	ldi	r23, 0x00	; 0
     dfa:	80 e0       	ldi	r24, 0x00	; 0
     dfc:	90 e0       	ldi	r25, 0x00	; 0
     dfe:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__floatsisf>
     e02:	2d ec       	ldi	r18, 0xCD	; 205
     e04:	3c ec       	ldi	r19, 0xCC	; 204
     e06:	4c ec       	ldi	r20, 0xCC	; 204
     e08:	5d e3       	ldi	r21, 0x3D	; 61
     e0a:	0e 94 2a 0c 	call	0x1854	; 0x1854 <__mulsf3>
     e0e:	0e 94 88 0a 	call	0x1510	; 0x1510 <__fixunssfsi>
     e12:	06 2f       	mov	r16, r22
     e14:	f1 01       	movw	r30, r2
     e16:	62 81       	ldd	r22, Z+2	; 0x02
     e18:	70 e0       	ldi	r23, 0x00	; 0
     e1a:	80 e0       	ldi	r24, 0x00	; 0
     e1c:	90 e0       	ldi	r25, 0x00	; 0
     e1e:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__floatsisf>
     e22:	2d ec       	ldi	r18, 0xCD	; 205
     e24:	3c ec       	ldi	r19, 0xCC	; 204
     e26:	4c ec       	ldi	r20, 0xCC	; 204
     e28:	5d e3       	ldi	r21, 0x3D	; 61
     e2a:	0e 94 2a 0c 	call	0x1854	; 0x1854 <__mulsf3>
     e2e:	0e 94 88 0a 	call	0x1510	; 0x1510 <__fixunssfsi>
     e32:	f6 2e       	mov	r15, r22
     e34:	f1 01       	movw	r30, r2
     e36:	60 81       	ld	r22, Z
     e38:	70 e0       	ldi	r23, 0x00	; 0
     e3a:	80 e0       	ldi	r24, 0x00	; 0
     e3c:	90 e0       	ldi	r25, 0x00	; 0
     e3e:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__floatsisf>
     e42:	2d ec       	ldi	r18, 0xCD	; 205
     e44:	3c ec       	ldi	r19, 0xCC	; 204
     e46:	4c ec       	ldi	r20, 0xCC	; 204
     e48:	5d e3       	ldi	r21, 0x3D	; 61
     e4a:	0e 94 2a 0c 	call	0x1854	; 0x1854 <__mulsf3>
     e4e:	0e 94 88 0a 	call	0x1510	; 0x1510 <__fixunssfsi>
     e52:	f1 01       	movw	r30, r2
     e54:	60 83       	st	Z, r22
     e56:	01 83       	std	Z+1, r16	; 0x01
     e58:	f2 82       	std	Z+2, r15	; 0x02
				break;
     e5a:	dc c0       	rjmp	.+440    	; 0x1014 <tinyLED_update+0x3ca>
			case FLASH:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*flash_on, rgb_colors[i].green*flash_on, rgb_colors[i].blue*flash_on};
     e5c:	f1 01       	movw	r30, r2
     e5e:	91 81       	ldd	r25, Z+1	; 0x01
     e60:	fb 85       	ldd	r31, Y+11	; 0x0b
     e62:	f9 9f       	mul	r31, r25
     e64:	90 2d       	mov	r25, r0
     e66:	11 24       	eor	r1, r1
     e68:	f1 01       	movw	r30, r2
     e6a:	82 81       	ldd	r24, Z+2	; 0x02
     e6c:	fb 85       	ldd	r31, Y+11	; 0x0b
     e6e:	f8 9f       	mul	r31, r24
     e70:	80 2d       	mov	r24, r0
     e72:	11 24       	eor	r1, r1
     e74:	f1 01       	movw	r30, r2
     e76:	20 81       	ld	r18, Z
     e78:	fb 85       	ldd	r31, Y+11	; 0x0b
     e7a:	2f 9f       	mul	r18, r31
     e7c:	20 2d       	mov	r18, r0
     e7e:	11 24       	eor	r1, r1
     e80:	f1 01       	movw	r30, r2
     e82:	20 83       	st	Z, r18
     e84:	91 83       	std	Z+1, r25	; 0x01
     e86:	82 83       	std	Z+2, r24	; 0x02
				break;
     e88:	c5 c0       	rjmp	.+394    	; 0x1014 <tinyLED_update+0x3ca>
			case SWING:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*sinValue, rgb_colors[i].green*sinValue, rgb_colors[i].blue*sinValue};
     e8a:	f1 01       	movw	r30, r2
     e8c:	61 81       	ldd	r22, Z+1	; 0x01
     e8e:	70 e0       	ldi	r23, 0x00	; 0
     e90:	80 e0       	ldi	r24, 0x00	; 0
     e92:	90 e0       	ldi	r25, 0x00	; 0
     e94:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__floatsisf>
     e98:	2f 81       	ldd	r18, Y+7	; 0x07
     e9a:	38 85       	ldd	r19, Y+8	; 0x08
     e9c:	49 85       	ldd	r20, Y+9	; 0x09
     e9e:	5a 85       	ldd	r21, Y+10	; 0x0a
     ea0:	0e 94 2a 0c 	call	0x1854	; 0x1854 <__mulsf3>
     ea4:	0e 94 88 0a 	call	0x1510	; 0x1510 <__fixunssfsi>
     ea8:	06 2f       	mov	r16, r22
     eaa:	f1 01       	movw	r30, r2
     eac:	62 81       	ldd	r22, Z+2	; 0x02
     eae:	70 e0       	ldi	r23, 0x00	; 0
     eb0:	80 e0       	ldi	r24, 0x00	; 0
     eb2:	90 e0       	ldi	r25, 0x00	; 0
     eb4:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__floatsisf>
     eb8:	2f 81       	ldd	r18, Y+7	; 0x07
     eba:	38 85       	ldd	r19, Y+8	; 0x08
     ebc:	49 85       	ldd	r20, Y+9	; 0x09
     ebe:	5a 85       	ldd	r21, Y+10	; 0x0a
     ec0:	0e 94 2a 0c 	call	0x1854	; 0x1854 <__mulsf3>
     ec4:	0e 94 88 0a 	call	0x1510	; 0x1510 <__fixunssfsi>
     ec8:	f6 2e       	mov	r15, r22
     eca:	f1 01       	movw	r30, r2
     ecc:	60 81       	ld	r22, Z
     ece:	70 e0       	ldi	r23, 0x00	; 0
     ed0:	80 e0       	ldi	r24, 0x00	; 0
     ed2:	90 e0       	ldi	r25, 0x00	; 0
     ed4:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__floatsisf>
     ed8:	2f 81       	ldd	r18, Y+7	; 0x07
     eda:	38 85       	ldd	r19, Y+8	; 0x08
     edc:	49 85       	ldd	r20, Y+9	; 0x09
     ede:	5a 85       	ldd	r21, Y+10	; 0x0a
     ee0:	0e 94 2a 0c 	call	0x1854	; 0x1854 <__mulsf3>
     ee4:	0e 94 88 0a 	call	0x1510	; 0x1510 <__fixunssfsi>
     ee8:	f1 01       	movw	r30, r2
     eea:	60 83       	st	Z, r22
     eec:	01 83       	std	Z+1, r16	; 0x01
     eee:	f2 82       	std	Z+2, r15	; 0x02
				break;
     ef0:	91 c0       	rjmp	.+290    	; 0x1014 <tinyLED_update+0x3ca>
			case PING:
				// in the line below, fmin will either return 1 or 0, so each rgb color is either 0 or 255*PING_BRIGHTNESS
				rgb_colors[i] = (struct RGB_Color){255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].red)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].green)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].blue)*ping_on};
     ef2:	f1 01       	movw	r30, r2
     ef4:	60 81       	ld	r22, Z
     ef6:	70 e0       	ldi	r23, 0x00	; 0
     ef8:	80 e0       	ldi	r24, 0x00	; 0
     efa:	90 e0       	ldi	r25, 0x00	; 0
     efc:	0e 94 b7 0a 	call	0x156e	; 0x156e <__floatunsisf>
     f00:	9b 01       	movw	r18, r22
     f02:	ac 01       	movw	r20, r24
     f04:	60 e0       	ldi	r22, 0x00	; 0
     f06:	70 e0       	ldi	r23, 0x00	; 0
     f08:	80 e8       	ldi	r24, 0x80	; 128
     f0a:	9f e3       	ldi	r25, 0x3F	; 63
     f0c:	0e 94 f4 0a 	call	0x15e8	; 0x15e8 <fmin>
     f10:	6c 8b       	std	Y+20, r22	; 0x14
     f12:	7d 8b       	std	Y+21, r23	; 0x15
     f14:	8e 8b       	std	Y+22, r24	; 0x16
     f16:	9f 8b       	std	Y+23, r25	; 0x17
     f18:	68 89       	ldd	r22, Y+16	; 0x10
     f1a:	79 89       	ldd	r23, Y+17	; 0x11
     f1c:	8a 89       	ldd	r24, Y+18	; 0x12
     f1e:	9b 89       	ldd	r25, Y+19	; 0x13
     f20:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__floatsisf>
     f24:	6c 87       	std	Y+12, r22	; 0x0c
     f26:	7d 87       	std	Y+13, r23	; 0x0d
     f28:	8e 87       	std	Y+14, r24	; 0x0e
     f2a:	9f 87       	std	Y+15, r25	; 0x0f
     f2c:	f1 01       	movw	r30, r2
     f2e:	61 81       	ldd	r22, Z+1	; 0x01
     f30:	70 e0       	ldi	r23, 0x00	; 0
     f32:	80 e0       	ldi	r24, 0x00	; 0
     f34:	90 e0       	ldi	r25, 0x00	; 0
     f36:	0e 94 b7 0a 	call	0x156e	; 0x156e <__floatunsisf>
     f3a:	9b 01       	movw	r18, r22
     f3c:	ac 01       	movw	r20, r24
     f3e:	60 e0       	ldi	r22, 0x00	; 0
     f40:	70 e0       	ldi	r23, 0x00	; 0
     f42:	80 e8       	ldi	r24, 0x80	; 128
     f44:	9f e3       	ldi	r25, 0x3F	; 63
     f46:	0e 94 f4 0a 	call	0x15e8	; 0x15e8 <fmin>
     f4a:	68 8f       	std	Y+24, r22	; 0x18
     f4c:	79 8f       	std	Y+25, r23	; 0x19
     f4e:	8a 8f       	std	Y+26, r24	; 0x1a
     f50:	9b 8f       	std	Y+27, r25	; 0x1b
     f52:	f1 01       	movw	r30, r2
     f54:	62 81       	ldd	r22, Z+2	; 0x02
     f56:	70 e0       	ldi	r23, 0x00	; 0
     f58:	80 e0       	ldi	r24, 0x00	; 0
     f5a:	90 e0       	ldi	r25, 0x00	; 0
     f5c:	0e 94 b7 0a 	call	0x156e	; 0x156e <__floatunsisf>
     f60:	9b 01       	movw	r18, r22
     f62:	ac 01       	movw	r20, r24
     f64:	60 e0       	ldi	r22, 0x00	; 0
     f66:	70 e0       	ldi	r23, 0x00	; 0
     f68:	80 e8       	ldi	r24, 0x80	; 128
     f6a:	9f e3       	ldi	r25, 0x3F	; 63
     f6c:	0e 94 f4 0a 	call	0x15e8	; 0x15e8 <fmin>
     f70:	6c 8f       	std	Y+28, r22	; 0x1c
     f72:	7d 8f       	std	Y+29, r23	; 0x1d
     f74:	8e 8f       	std	Y+30, r24	; 0x1e
     f76:	9f 8f       	std	Y+31, r25	; 0x1f
     f78:	23 e3       	ldi	r18, 0x33	; 51
     f7a:	33 e3       	ldi	r19, 0x33	; 51
     f7c:	43 ea       	ldi	r20, 0xA3	; 163
     f7e:	50 e4       	ldi	r21, 0x40	; 64
     f80:	6c 89       	ldd	r22, Y+20	; 0x14
     f82:	7d 89       	ldd	r23, Y+21	; 0x15
     f84:	8e 89       	ldd	r24, Y+22	; 0x16
     f86:	9f 89       	ldd	r25, Y+23	; 0x17
     f88:	0e 94 2a 0c 	call	0x1854	; 0x1854 <__mulsf3>
     f8c:	2c 85       	ldd	r18, Y+12	; 0x0c
     f8e:	3d 85       	ldd	r19, Y+13	; 0x0d
     f90:	4e 85       	ldd	r20, Y+14	; 0x0e
     f92:	5f 85       	ldd	r21, Y+15	; 0x0f
     f94:	0e 94 2a 0c 	call	0x1854	; 0x1854 <__mulsf3>
     f98:	0e 94 88 0a 	call	0x1510	; 0x1510 <__fixunssfsi>
     f9c:	f1 01       	movw	r30, r2
     f9e:	60 83       	st	Z, r22
     fa0:	23 e3       	ldi	r18, 0x33	; 51
     fa2:	33 e3       	ldi	r19, 0x33	; 51
     fa4:	43 ea       	ldi	r20, 0xA3	; 163
     fa6:	50 e4       	ldi	r21, 0x40	; 64
     fa8:	68 8d       	ldd	r22, Y+24	; 0x18
     faa:	79 8d       	ldd	r23, Y+25	; 0x19
     fac:	8a 8d       	ldd	r24, Y+26	; 0x1a
     fae:	9b 8d       	ldd	r25, Y+27	; 0x1b
     fb0:	0e 94 2a 0c 	call	0x1854	; 0x1854 <__mulsf3>
     fb4:	2c 85       	ldd	r18, Y+12	; 0x0c
     fb6:	3d 85       	ldd	r19, Y+13	; 0x0d
     fb8:	4e 85       	ldd	r20, Y+14	; 0x0e
     fba:	5f 85       	ldd	r21, Y+15	; 0x0f
     fbc:	0e 94 2a 0c 	call	0x1854	; 0x1854 <__mulsf3>
     fc0:	0e 94 88 0a 	call	0x1510	; 0x1510 <__fixunssfsi>
     fc4:	f1 01       	movw	r30, r2
     fc6:	61 83       	std	Z+1, r22	; 0x01
     fc8:	23 e3       	ldi	r18, 0x33	; 51
     fca:	33 e3       	ldi	r19, 0x33	; 51
     fcc:	43 ea       	ldi	r20, 0xA3	; 163
     fce:	50 e4       	ldi	r21, 0x40	; 64
     fd0:	6c 8d       	ldd	r22, Y+28	; 0x1c
     fd2:	7d 8d       	ldd	r23, Y+29	; 0x1d
     fd4:	8e 8d       	ldd	r24, Y+30	; 0x1e
     fd6:	9f 8d       	ldd	r25, Y+31	; 0x1f
     fd8:	0e 94 2a 0c 	call	0x1854	; 0x1854 <__mulsf3>
     fdc:	2c 85       	ldd	r18, Y+12	; 0x0c
     fde:	3d 85       	ldd	r19, Y+13	; 0x0d
     fe0:	4e 85       	ldd	r20, Y+14	; 0x0e
     fe2:	5f 85       	ldd	r21, Y+15	; 0x0f
     fe4:	0e 94 2a 0c 	call	0x1854	; 0x1854 <__mulsf3>
     fe8:	0e 94 88 0a 	call	0x1510	; 0x1510 <__fixunssfsi>
     fec:	f1 01       	movw	r30, r2
     fee:	62 83       	std	Z+2, r22	; 0x02
				break;
     ff0:	11 c0       	rjmp	.+34     	; 0x1014 <tinyLED_update+0x3ca>
			case FLASH_ONCE:
				if(tinyLED_flash_once_time[i]>0){
     ff2:	f2 01       	movw	r30, r4
     ff4:	80 81       	ld	r24, Z
     ff6:	91 81       	ldd	r25, Z+1	; 0x01
     ff8:	00 97       	sbiw	r24, 0x00	; 0
     ffa:	21 f0       	breq	.+8      	; 0x1004 <tinyLED_update+0x3ba>
					rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red, rgb_colors[i].green, rgb_colors[i].blue};
					tinyLED_flash_once_time[i]--;
     ffc:	01 97       	sbiw	r24, 0x01	; 1
     ffe:	80 83       	st	Z, r24
    1000:	91 83       	std	Z+1, r25	; 0x01
    1002:	08 c0       	rjmp	.+16     	; 0x1014 <tinyLED_update+0x3ca>
				}
				else{
					// Here we return to the previous color and mode
					tinyLED_settings[i].color = tinyLED_old_settings[i].color;
    1004:	f5 01       	movw	r30, r10
    1006:	80 81       	ld	r24, Z
    1008:	f7 01       	movw	r30, r14
    100a:	80 83       	st	Z, r24
					tinyLED_settings[i].mode = tinyLED_old_settings[i].mode;
    100c:	f5 01       	movw	r30, r10
    100e:	81 81       	ldd	r24, Z+1	; 0x01
    1010:	f7 01       	movw	r30, r14
    1012:	81 83       	std	Z+1, r24	; 0x01
	
	// This is where we store all the actual color values we want to send to the LED
	struct RGB_Color rgb_colors[NUMBER_OF_LEDS];
	
		
	for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
    1014:	1f 5f       	subi	r17, 0xFF	; 255
    1016:	f2 e0       	ldi	r31, 0x02	; 2
    1018:	8f 0e       	add	r8, r31
    101a:	91 1c       	adc	r9, r1
    101c:	23 e0       	ldi	r18, 0x03	; 3
    101e:	62 0e       	add	r6, r18
    1020:	71 1c       	adc	r7, r1
    1022:	32 e0       	ldi	r19, 0x02	; 2
    1024:	a3 0e       	add	r10, r19
    1026:	b1 1c       	adc	r11, r1
    1028:	42 e0       	ldi	r20, 0x02	; 2
    102a:	44 0e       	add	r4, r20
    102c:	51 1c       	adc	r5, r1
    102e:	12 30       	cpi	r17, 0x02	; 2
    1030:	09 f0       	breq	.+2      	; 0x1034 <tinyLED_update+0x3ea>
    1032:	85 ce       	rjmp	.-758    	; 0xd3e <tinyLED_update+0xf4>
				break;
		}
	}
	
	// We only write to the LEDs if there is something to change. (eg. in SWING mode, we update the LEDs almost every cycle)
	if(!tinyLED_RGB_Color_Compare(&rgb_colors, &tinyLED_old_colors)){
    1034:	6f e5       	ldi	r22, 0x5F	; 95
    1036:	78 e3       	ldi	r23, 0x38	; 56
    1038:	ce 01       	movw	r24, r28
    103a:	01 96       	adiw	r24, 0x01	; 1
    103c:	0e 94 f5 05 	call	0xbea	; 0xbea <tinyLED_RGB_Color_Compare>
    1040:	81 11       	cpse	r24, r1
    1042:	1f c0       	rjmp	.+62     	; 0x1082 <tinyLED_update+0x438>
    1044:	0f e5       	ldi	r16, 0x5F	; 95
    1046:	18 e3       	ldi	r17, 0x38	; 56
    1048:	7e 01       	movw	r14, r28
    104a:	57 e0       	ldi	r21, 0x07	; 7
    104c:	e5 0e       	add	r14, r21
    104e:	f1 1c       	adc	r15, r1
		for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
		{
			// Write to LEDs
			//For some reason, the data-bus to the LEDs is serialized as GRB
			//which means the 24-bit data-bus will look like [Green[0:7], Red[0:7], Blue[0:7]]
			tinyLED_SPIWriteByte(rgb_colors[i].green);
    1050:	f6 01       	movw	r30, r12
    1052:	81 81       	ldd	r24, Z+1	; 0x01
    1054:	0e 94 8d 05 	call	0xb1a	; 0xb1a <tinyLED_SPIWriteByte>
			tinyLED_SPIWriteByte(rgb_colors[i].red);
    1058:	f6 01       	movw	r30, r12
    105a:	80 81       	ld	r24, Z
    105c:	0e 94 8d 05 	call	0xb1a	; 0xb1a <tinyLED_SPIWriteByte>
			tinyLED_SPIWriteByte(rgb_colors[i].blue);
    1060:	f6 01       	movw	r30, r12
    1062:	82 81       	ldd	r24, Z+2	; 0x02
    1064:	0e 94 8d 05 	call	0xb1a	; 0xb1a <tinyLED_SPIWriteByte>
			tinyLED_old_colors[i] = rgb_colors[i];
    1068:	f6 01       	movw	r30, r12
    106a:	81 91       	ld	r24, Z+
    106c:	91 91       	ld	r25, Z+
    106e:	a1 91       	ld	r26, Z+
    1070:	6f 01       	movw	r12, r30
    1072:	f8 01       	movw	r30, r16
    1074:	81 93       	st	Z+, r24
    1076:	91 93       	st	Z+, r25
    1078:	a1 93       	st	Z+, r26
    107a:	8f 01       	movw	r16, r30
		}
	}
	
	// We only write to the LEDs if there is something to change. (eg. in SWING mode, we update the LEDs almost every cycle)
	if(!tinyLED_RGB_Color_Compare(&rgb_colors, &tinyLED_old_colors)){
		for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
    107c:	ce 14       	cp	r12, r14
    107e:	df 04       	cpc	r13, r15
    1080:	39 f7       	brne	.-50     	; 0x1050 <tinyLED_update+0x406>
			tinyLED_SPIWriteByte(rgb_colors[i].red);
			tinyLED_SPIWriteByte(rgb_colors[i].blue);
			tinyLED_old_colors[i] = rgb_colors[i];
		}
	}
}
    1082:	6f 96       	adiw	r28, 0x1f	; 31
    1084:	cd bf       	out	0x3d, r28	; 61
    1086:	de bf       	out	0x3e, r29	; 62
    1088:	df 91       	pop	r29
    108a:	cf 91       	pop	r28
    108c:	1f 91       	pop	r17
    108e:	0f 91       	pop	r16
    1090:	ff 90       	pop	r15
    1092:	ef 90       	pop	r14
    1094:	df 90       	pop	r13
    1096:	cf 90       	pop	r12
    1098:	bf 90       	pop	r11
    109a:	af 90       	pop	r10
    109c:	9f 90       	pop	r9
    109e:	8f 90       	pop	r8
    10a0:	7f 90       	pop	r7
    10a2:	6f 90       	pop	r6
    10a4:	5f 90       	pop	r5
    10a6:	4f 90       	pop	r4
    10a8:	3f 90       	pop	r3
    10aa:	2f 90       	pop	r2
    10ac:	08 95       	ret

000010ae <tinyPotential_update>:

/*
Update the potential
*/
void tinyPotential_update()
{
    10ae:	cf 92       	push	r12
    10b0:	df 92       	push	r13
    10b2:	ef 92       	push	r14
    10b4:	ff 92       	push	r15
Function to decay the potential towards 0
*/
static void tinyPotential_decay()
{
		
	uint8_t time_since_last_update = tinyTime_now() - previous_update_time;
    10b6:	0e 94 61 09 	call	0x12c2	; 0x12c2 <tinyTime_now>
	tinyPotential_potential *= (exp(-((float)time_since_last_update/(float)TINYPOTENTIAL_TIME_CONST)));
    10ba:	80 91 47 38 	lds	r24, 0x3847	; 0x803847 <previous_update_time>
    10be:	68 1b       	sub	r22, r24
    10c0:	70 e0       	ldi	r23, 0x00	; 0
    10c2:	80 e0       	ldi	r24, 0x00	; 0
    10c4:	90 e0       	ldi	r25, 0x00	; 0
    10c6:	0e 94 b7 0a 	call	0x156e	; 0x156e <__floatunsisf>
    10ca:	20 e0       	ldi	r18, 0x00	; 0
    10cc:	30 e0       	ldi	r19, 0x00	; 0
    10ce:	48 ec       	ldi	r20, 0xC8	; 200
    10d0:	52 e4       	ldi	r21, 0x42	; 66
    10d2:	0e 94 dc 09 	call	0x13b8	; 0x13b8 <__divsf3>
    10d6:	90 58       	subi	r25, 0x80	; 128
    10d8:	0e 94 56 0a 	call	0x14ac	; 0x14ac <exp>
    10dc:	20 91 4b 38 	lds	r18, 0x384B	; 0x80384b <tinyPotential_potential>
    10e0:	30 91 4c 38 	lds	r19, 0x384C	; 0x80384c <tinyPotential_potential+0x1>
    10e4:	40 91 4d 38 	lds	r20, 0x384D	; 0x80384d <tinyPotential_potential+0x2>
    10e8:	50 91 4e 38 	lds	r21, 0x384E	; 0x80384e <tinyPotential_potential+0x3>
    10ec:	0e 94 2a 0c 	call	0x1854	; 0x1854 <__mulsf3>
    10f0:	6b 01       	movw	r12, r22
    10f2:	7c 01       	movw	r14, r24
	if(fabs(tinyPotential_potential)<POLARIZATION_OFFSET){
    10f4:	9f 77       	andi	r25, 0x7F	; 127
    10f6:	2d ec       	ldi	r18, 0xCD	; 205
    10f8:	3c ec       	ldi	r19, 0xCC	; 204
    10fa:	4c ec       	ldi	r20, 0xCC	; 204
    10fc:	5d e3       	ldi	r21, 0x3D	; 61
    10fe:	0e 94 d7 09 	call	0x13ae	; 0x13ae <__cmpsf2>
    1102:	88 23       	and	r24, r24
    1104:	4c f0       	brlt	.+18     	; 0x1118 <tinyPotential_update+0x6a>
*/
static void tinyPotential_decay()
{
		
	uint8_t time_since_last_update = tinyTime_now() - previous_update_time;
	tinyPotential_potential *= (exp(-((float)time_since_last_update/(float)TINYPOTENTIAL_TIME_CONST)));
    1106:	c0 92 4b 38 	sts	0x384B, r12	; 0x80384b <tinyPotential_potential>
    110a:	d0 92 4c 38 	sts	0x384C, r13	; 0x80384c <tinyPotential_potential+0x1>
    110e:	e0 92 4d 38 	sts	0x384D, r14	; 0x80384d <tinyPotential_potential+0x2>
    1112:	f0 92 4e 38 	sts	0x384E, r15	; 0x80384e <tinyPotential_potential+0x3>
    1116:	08 c0       	rjmp	.+16     	; 0x1128 <tinyPotential_update+0x7a>
	if(fabs(tinyPotential_potential)<POLARIZATION_OFFSET){
		tinyPotential_potential=0;
    1118:	10 92 4b 38 	sts	0x384B, r1	; 0x80384b <tinyPotential_potential>
    111c:	10 92 4c 38 	sts	0x384C, r1	; 0x80384c <tinyPotential_potential+0x1>
    1120:	10 92 4d 38 	sts	0x384D, r1	; 0x80384d <tinyPotential_potential+0x2>
    1124:	10 92 4e 38 	sts	0x384E, r1	; 0x80384e <tinyPotential_potential+0x3>
	}
	previous_update_time = tinyTime_now();
    1128:	0e 94 61 09 	call	0x12c2	; 0x12c2 <tinyTime_now>
    112c:	60 93 47 38 	sts	0x3847, r22	; 0x803847 <previous_update_time>
    1130:	70 93 48 38 	sts	0x3848, r23	; 0x803848 <previous_update_time+0x1>
    1134:	80 93 49 38 	sts	0x3849, r24	; 0x803849 <previous_update_time+0x2>
    1138:	90 93 4a 38 	sts	0x384A, r25	; 0x80384a <previous_update_time+0x3>
void tinyPotential_update()
{
	//Some of the potential in the neuron has decayed away
	tinyPotential_decay();
	// Update potential with values from Dendrites
	tinyPotential_potential = tinyDendrite_update_potential(tinyPotential_potential);
    113c:	60 91 4b 38 	lds	r22, 0x384B	; 0x80384b <tinyPotential_potential>
    1140:	70 91 4c 38 	lds	r23, 0x384C	; 0x80384c <tinyPotential_potential+0x1>
    1144:	80 91 4d 38 	lds	r24, 0x384D	; 0x80384d <tinyPotential_potential+0x2>
    1148:	90 91 4e 38 	lds	r25, 0x384E	; 0x80384e <tinyPotential_potential+0x3>
    114c:	0e 94 45 05 	call	0xa8a	; 0xa8a <tinyDendrite_update_potential>
    1150:	60 93 4b 38 	sts	0x384B, r22	; 0x80384b <tinyPotential_potential>
    1154:	70 93 4c 38 	sts	0x384C, r23	; 0x80384c <tinyPotential_potential+0x1>
    1158:	80 93 4d 38 	sts	0x384D, r24	; 0x80384d <tinyPotential_potential+0x2>
    115c:	90 93 4e 38 	sts	0x384E, r25	; 0x80384e <tinyPotential_potential+0x3>
	
	// Update potential from button press
	tinyPotential_potential = tinyButton_update_potential(tinyPotential_potential);
    1160:	0e 94 b8 03 	call	0x770	; 0x770 <tinyButton_update_potential>
    1164:	60 93 4b 38 	sts	0x384B, r22	; 0x80384b <tinyPotential_potential>
    1168:	70 93 4c 38 	sts	0x384C, r23	; 0x80384c <tinyPotential_potential+0x1>
    116c:	80 93 4d 38 	sts	0x384D, r24	; 0x80384d <tinyPotential_potential+0x2>
    1170:	90 93 4e 38 	sts	0x384E, r25	; 0x80384e <tinyPotential_potential+0x3>
	
	// Update potential with values from spontaneous pulse.
	tinyPotential_potential = tinyPulse_update_potential(tinyPotential_potential);
    1174:	0e 94 03 09 	call	0x1206	; 0x1206 <tinyPulse_update_potential>
    1178:	ab 01       	movw	r20, r22
    117a:	bc 01       	movw	r22, r24
    117c:	40 93 4b 38 	sts	0x384B, r20	; 0x80384b <tinyPotential_potential>
    1180:	50 93 4c 38 	sts	0x384C, r21	; 0x80384c <tinyPotential_potential+0x1>
    1184:	60 93 4d 38 	sts	0x384D, r22	; 0x80384d <tinyPotential_potential+0x2>
    1188:	70 93 4e 38 	sts	0x384E, r23	; 0x80384e <tinyPotential_potential+0x3>
	
	tinyDebugger_send_double("Potential", tinyPotential_potential);
    118c:	88 e6       	ldi	r24, 0x68	; 104
    118e:	9a e9       	ldi	r25, 0x9A	; 154
    1190:	0e 94 44 04 	call	0x888	; 0x888 <tinyDebugger_send_double>
	
	
	// Let the axon affect the potential
	// This is also where we decide whether or not the axon should fire
	tinyPotential_potential = tinyAxon_update_potential(tinyPotential_potential);
    1194:	60 91 4b 38 	lds	r22, 0x384B	; 0x80384b <tinyPotential_potential>
    1198:	70 91 4c 38 	lds	r23, 0x384C	; 0x80384c <tinyPotential_potential+0x1>
    119c:	80 91 4d 38 	lds	r24, 0x384D	; 0x80384d <tinyPotential_potential+0x2>
    11a0:	90 91 4e 38 	lds	r25, 0x384E	; 0x80384e <tinyPotential_potential+0x3>
    11a4:	0e 94 96 02 	call	0x52c	; 0x52c <tinyAxon_update_potential>
    11a8:	60 93 4b 38 	sts	0x384B, r22	; 0x80384b <tinyPotential_potential>
    11ac:	70 93 4c 38 	sts	0x384C, r23	; 0x80384c <tinyPotential_potential+0x1>
    11b0:	80 93 4d 38 	sts	0x384D, r24	; 0x80384d <tinyPotential_potential+0x2>
    11b4:	90 93 4e 38 	sts	0x384E, r25	; 0x80384e <tinyPotential_potential+0x3>
}
    11b8:	ff 90       	pop	r15
    11ba:	ef 90       	pop	r14
    11bc:	df 90       	pop	r13
    11be:	cf 90       	pop	r12
    11c0:	08 95       	ret

000011c2 <tinyPulse_toggle_pulse_mode>:
_Bool tinyPulse_is_in_pulse_mode(){
	return pulse_mode;
}

void tinyPulse_toggle_pulse_mode(){
	pulse_mode = !pulse_mode;
    11c2:	90 91 55 38 	lds	r25, 0x3855	; 0x803855 <pulse_mode>
    11c6:	81 e0       	ldi	r24, 0x01	; 1
    11c8:	89 27       	eor	r24, r25
    11ca:	80 93 55 38 	sts	0x3855, r24	; 0x803855 <pulse_mode>
	
	if(tinyPulse_is_in_pulse_mode()){
    11ce:	88 23       	and	r24, r24
    11d0:	59 f0       	breq	.+22     	; 0x11e8 <tinyPulse_toggle_pulse_mode+0x26>
		tinyLED_set_color_mode(OUT_LED, PULSEMODE_COLOR, WEAK);
    11d2:	41 e0       	ldi	r20, 0x01	; 1
    11d4:	62 e0       	ldi	r22, 0x02	; 2
    11d6:	81 e0       	ldi	r24, 0x01	; 1
    11d8:	0e 94 bb 05 	call	0xb76	; 0xb76 <tinyLED_set_color_mode>
		tinyLED_set_color_mode(INN_LED, PULSEMODE_COLOR, WEAK);
    11dc:	41 e0       	ldi	r20, 0x01	; 1
    11de:	62 e0       	ldi	r22, 0x02	; 2
    11e0:	80 e0       	ldi	r24, 0x00	; 0
    11e2:	0e 94 bb 05 	call	0xb76	; 0xb76 <tinyLED_set_color_mode>
    11e6:	08 95       	ret
	}
	else{
		tinyLED_set_color(OUT_LED, LED_OFF);
    11e8:	60 e0       	ldi	r22, 0x00	; 0
    11ea:	81 e0       	ldi	r24, 0x01	; 1
    11ec:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <tinyLED_set_color>
		tinyLED_set_color(INN_LED, LED_OFF);
    11f0:	60 e0       	ldi	r22, 0x00	; 0
    11f2:	80 e0       	ldi	r24, 0x00	; 0
    11f4:	0e 94 f1 05 	call	0xbe2	; 0xbe2 <tinyLED_set_color>
    11f8:	08 95       	ret

000011fa <tinyPulse_set_pulse_mode>:
	}
}

void tinyPulse_set_pulse_mode(_Bool mode){
	if (pulse_mode != mode)
    11fa:	90 91 55 38 	lds	r25, 0x3855	; 0x803855 <pulse_mode>
    11fe:	98 13       	cpse	r25, r24
	{
		tinyPulse_toggle_pulse_mode();
    1200:	0e 94 e1 08 	call	0x11c2	; 0x11c2 <tinyPulse_toggle_pulse_mode>
    1204:	08 95       	ret

00001206 <tinyPulse_update_potential>:
	}
}

double tinyPulse_update_potential(double potential){
    1206:	cf 92       	push	r12
    1208:	df 92       	push	r13
    120a:	ef 92       	push	r14
    120c:	ff 92       	push	r15
    120e:	6b 01       	movw	r12, r22
    1210:	7c 01       	movw	r14, r24
	if(pulse_mode){
    1212:	80 91 55 38 	lds	r24, 0x3855	; 0x803855 <pulse_mode>
    1216:	88 23       	and	r24, r24
    1218:	39 f1       	breq	.+78     	; 0x1268 <tinyPulse_update_potential+0x62>
		
		time_since_last_pulse = tinyTime_now() - time_of_last_pulse;
    121a:	0e 94 61 09 	call	0x12c2	; 0x12c2 <tinyTime_now>
    121e:	20 91 51 38 	lds	r18, 0x3851	; 0x803851 <time_of_last_pulse>
    1222:	30 91 52 38 	lds	r19, 0x3852	; 0x803852 <time_of_last_pulse+0x1>
    1226:	62 1b       	sub	r22, r18
    1228:	73 0b       	sbc	r23, r19
    122a:	60 93 4f 38 	sts	0x384F, r22	; 0x80384f <time_since_last_pulse>
    122e:	70 93 50 38 	sts	0x3850, r23	; 0x803850 <time_since_last_pulse+0x1>
		
		if(time_since_last_pulse >= ideal_time_between_pulses){
    1232:	80 91 13 38 	lds	r24, 0x3813	; 0x803813 <ideal_time_between_pulses>
    1236:	90 91 14 38 	lds	r25, 0x3814	; 0x803814 <ideal_time_between_pulses+0x1>
    123a:	68 17       	cp	r22, r24
    123c:	79 07       	cpc	r23, r25
    123e:	a0 f0       	brcs	.+40     	; 0x1268 <tinyPulse_update_potential+0x62>
			// This isn't actually a button press. You could have a separate variable for this, but it seems unnecessary.
			potential += BUTTON_PRESS_REACTION;
    1240:	20 e0       	ldi	r18, 0x00	; 0
    1242:	30 e0       	ldi	r19, 0x00	; 0
    1244:	40 ed       	ldi	r20, 0xD0	; 208
    1246:	51 e4       	ldi	r21, 0x41	; 65
    1248:	c7 01       	movw	r24, r14
    124a:	b6 01       	movw	r22, r12
    124c:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <__addsf3>
    1250:	6b 01       	movw	r12, r22
    1252:	7c 01       	movw	r14, r24
			time_of_last_pulse = tinyTime_now();			
    1254:	0e 94 61 09 	call	0x12c2	; 0x12c2 <tinyTime_now>
    1258:	60 93 51 38 	sts	0x3851, r22	; 0x803851 <time_of_last_pulse>
    125c:	70 93 52 38 	sts	0x3852, r23	; 0x803852 <time_of_last_pulse+0x1>
    1260:	80 93 53 38 	sts	0x3853, r24	; 0x803853 <time_of_last_pulse+0x2>
    1264:	90 93 54 38 	sts	0x3854, r25	; 0x803854 <time_of_last_pulse+0x3>
		}
	}
	return potential;
}
    1268:	c7 01       	movw	r24, r14
    126a:	b6 01       	movw	r22, r12
    126c:	ff 90       	pop	r15
    126e:	ef 90       	pop	r14
    1270:	df 90       	pop	r13
    1272:	cf 90       	pop	r12
    1274:	08 95       	ret

00001276 <tinySleep_prepare_sleep>:
  PCMSK |= _BV(PCINT3);                   // Use PB3 as interrupt pin
  ADCSRA &= ~_BV(ADEN);                   // ADC off
  */
  
  //set_sleep_mode(SLEEP_MODE_PWR_DOWN);  // Set sleep mode to POWER DOWN mode
  set_sleep_mode(SLEEP_MODE_IDLE);  // Set sleep mode to POWER DOWN mode
    1276:	e0 e5       	ldi	r30, 0x50	; 80
    1278:	f0 e0       	ldi	r31, 0x00	; 0
    127a:	80 81       	ld	r24, Z
    127c:	89 7f       	andi	r24, 0xF9	; 249
    127e:	80 83       	st	Z, r24
  sleep_enable();
    1280:	80 81       	ld	r24, Z
    1282:	81 60       	ori	r24, 0x01	; 1
    1284:	80 83       	st	Z, r24
    1286:	08 95       	ret

00001288 <tinySleep_enter_sleep>:

void tinySleep_enter_sleep(){

	
  //sleep_bod_disable();
  cli();
    1288:	f8 94       	cli
  sei();
    128a:	78 94       	sei
  sleep_cpu();
    128c:	88 95       	sleep
  sleep_disable();
    128e:	e0 e5       	ldi	r30, 0x50	; 80
    1290:	f0 e0       	ldi	r31, 0x00	; 0
    1292:	80 81       	ld	r24, Z
    1294:	8e 7f       	andi	r24, 0xFE	; 254
    1296:	80 83       	st	Z, r24
    1298:	08 95       	ret

0000129a <tinyTime_counter_increment>:
If the Interrupt Service Routine is clocked by a crystal oscillator
it gives a very precise timer-counter.
*/
void tinyTime_counter_increment(void)
{
	time_counter++;
    129a:	80 91 56 38 	lds	r24, 0x3856	; 0x803856 <time_counter>
    129e:	90 91 57 38 	lds	r25, 0x3857	; 0x803857 <time_counter+0x1>
    12a2:	a0 91 58 38 	lds	r26, 0x3858	; 0x803858 <time_counter+0x2>
    12a6:	b0 91 59 38 	lds	r27, 0x3859	; 0x803859 <time_counter+0x3>
    12aa:	01 96       	adiw	r24, 0x01	; 1
    12ac:	a1 1d       	adc	r26, r1
    12ae:	b1 1d       	adc	r27, r1
    12b0:	80 93 56 38 	sts	0x3856, r24	; 0x803856 <time_counter>
    12b4:	90 93 57 38 	sts	0x3857, r25	; 0x803857 <time_counter+0x1>
    12b8:	a0 93 58 38 	sts	0x3858, r26	; 0x803858 <time_counter+0x2>
    12bc:	b0 93 59 38 	sts	0x3859, r27	; 0x803859 <time_counter+0x3>
    12c0:	08 95       	ret

000012c2 <tinyTime_now>:
/*
This function is callable by external libraries to give them the counted time so far.
*/
uint32_t tinyTime_now(void)
{
	return time_counter;
    12c2:	60 91 56 38 	lds	r22, 0x3856	; 0x803856 <time_counter>
    12c6:	70 91 57 38 	lds	r23, 0x3857	; 0x803857 <time_counter+0x1>
    12ca:	80 91 58 38 	lds	r24, 0x3858	; 0x803858 <time_counter+0x2>
    12ce:	90 91 59 38 	lds	r25, 0x3859	; 0x803859 <time_counter+0x3>
    12d2:	08 95       	ret

000012d4 <__subsf3>:
    12d4:	50 58       	subi	r21, 0x80	; 128

000012d6 <__addsf3>:
    12d6:	bb 27       	eor	r27, r27
    12d8:	aa 27       	eor	r26, r26
    12da:	0e 94 82 09 	call	0x1304	; 0x1304 <__addsf3x>
    12de:	0c 94 75 0b 	jmp	0x16ea	; 0x16ea <__fp_round>
    12e2:	0e 94 67 0b 	call	0x16ce	; 0x16ce <__fp_pscA>
    12e6:	38 f0       	brcs	.+14     	; 0x12f6 <__addsf3+0x20>
    12e8:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <__fp_pscB>
    12ec:	20 f0       	brcs	.+8      	; 0x12f6 <__addsf3+0x20>
    12ee:	39 f4       	brne	.+14     	; 0x12fe <__addsf3+0x28>
    12f0:	9f 3f       	cpi	r25, 0xFF	; 255
    12f2:	19 f4       	brne	.+6      	; 0x12fa <__addsf3+0x24>
    12f4:	26 f4       	brtc	.+8      	; 0x12fe <__addsf3+0x28>
    12f6:	0c 94 3d 0b 	jmp	0x167a	; 0x167a <__fp_nan>
    12fa:	0e f4       	brtc	.+2      	; 0x12fe <__addsf3+0x28>
    12fc:	e0 95       	com	r30
    12fe:	e7 fb       	bst	r30, 7
    1300:	0c 94 37 0b 	jmp	0x166e	; 0x166e <__fp_inf>

00001304 <__addsf3x>:
    1304:	e9 2f       	mov	r30, r25
    1306:	0e 94 86 0b 	call	0x170c	; 0x170c <__fp_split3>
    130a:	58 f3       	brcs	.-42     	; 0x12e2 <__addsf3+0xc>
    130c:	ba 17       	cp	r27, r26
    130e:	62 07       	cpc	r22, r18
    1310:	73 07       	cpc	r23, r19
    1312:	84 07       	cpc	r24, r20
    1314:	95 07       	cpc	r25, r21
    1316:	20 f0       	brcs	.+8      	; 0x1320 <__addsf3x+0x1c>
    1318:	79 f4       	brne	.+30     	; 0x1338 <__addsf3x+0x34>
    131a:	a6 f5       	brtc	.+104    	; 0x1384 <__addsf3x+0x80>
    131c:	0c 94 a8 0b 	jmp	0x1750	; 0x1750 <__fp_zero>
    1320:	0e f4       	brtc	.+2      	; 0x1324 <__addsf3x+0x20>
    1322:	e0 95       	com	r30
    1324:	0b 2e       	mov	r0, r27
    1326:	ba 2f       	mov	r27, r26
    1328:	a0 2d       	mov	r26, r0
    132a:	0b 01       	movw	r0, r22
    132c:	b9 01       	movw	r22, r18
    132e:	90 01       	movw	r18, r0
    1330:	0c 01       	movw	r0, r24
    1332:	ca 01       	movw	r24, r20
    1334:	a0 01       	movw	r20, r0
    1336:	11 24       	eor	r1, r1
    1338:	ff 27       	eor	r31, r31
    133a:	59 1b       	sub	r21, r25
    133c:	99 f0       	breq	.+38     	; 0x1364 <__addsf3x+0x60>
    133e:	59 3f       	cpi	r21, 0xF9	; 249
    1340:	50 f4       	brcc	.+20     	; 0x1356 <__addsf3x+0x52>
    1342:	50 3e       	cpi	r21, 0xE0	; 224
    1344:	68 f1       	brcs	.+90     	; 0x13a0 <__addsf3x+0x9c>
    1346:	1a 16       	cp	r1, r26
    1348:	f0 40       	sbci	r31, 0x00	; 0
    134a:	a2 2f       	mov	r26, r18
    134c:	23 2f       	mov	r18, r19
    134e:	34 2f       	mov	r19, r20
    1350:	44 27       	eor	r20, r20
    1352:	58 5f       	subi	r21, 0xF8	; 248
    1354:	f3 cf       	rjmp	.-26     	; 0x133c <__addsf3x+0x38>
    1356:	46 95       	lsr	r20
    1358:	37 95       	ror	r19
    135a:	27 95       	ror	r18
    135c:	a7 95       	ror	r26
    135e:	f0 40       	sbci	r31, 0x00	; 0
    1360:	53 95       	inc	r21
    1362:	c9 f7       	brne	.-14     	; 0x1356 <__addsf3x+0x52>
    1364:	7e f4       	brtc	.+30     	; 0x1384 <__addsf3x+0x80>
    1366:	1f 16       	cp	r1, r31
    1368:	ba 0b       	sbc	r27, r26
    136a:	62 0b       	sbc	r22, r18
    136c:	73 0b       	sbc	r23, r19
    136e:	84 0b       	sbc	r24, r20
    1370:	ba f0       	brmi	.+46     	; 0x13a0 <__addsf3x+0x9c>
    1372:	91 50       	subi	r25, 0x01	; 1
    1374:	a1 f0       	breq	.+40     	; 0x139e <__addsf3x+0x9a>
    1376:	ff 0f       	add	r31, r31
    1378:	bb 1f       	adc	r27, r27
    137a:	66 1f       	adc	r22, r22
    137c:	77 1f       	adc	r23, r23
    137e:	88 1f       	adc	r24, r24
    1380:	c2 f7       	brpl	.-16     	; 0x1372 <__addsf3x+0x6e>
    1382:	0e c0       	rjmp	.+28     	; 0x13a0 <__addsf3x+0x9c>
    1384:	ba 0f       	add	r27, r26
    1386:	62 1f       	adc	r22, r18
    1388:	73 1f       	adc	r23, r19
    138a:	84 1f       	adc	r24, r20
    138c:	48 f4       	brcc	.+18     	; 0x13a0 <__addsf3x+0x9c>
    138e:	87 95       	ror	r24
    1390:	77 95       	ror	r23
    1392:	67 95       	ror	r22
    1394:	b7 95       	ror	r27
    1396:	f7 95       	ror	r31
    1398:	9e 3f       	cpi	r25, 0xFE	; 254
    139a:	08 f0       	brcs	.+2      	; 0x139e <__addsf3x+0x9a>
    139c:	b0 cf       	rjmp	.-160    	; 0x12fe <__addsf3+0x28>
    139e:	93 95       	inc	r25
    13a0:	88 0f       	add	r24, r24
    13a2:	08 f0       	brcs	.+2      	; 0x13a6 <__addsf3x+0xa2>
    13a4:	99 27       	eor	r25, r25
    13a6:	ee 0f       	add	r30, r30
    13a8:	97 95       	ror	r25
    13aa:	87 95       	ror	r24
    13ac:	08 95       	ret

000013ae <__cmpsf2>:
    13ae:	0e 94 13 0b 	call	0x1626	; 0x1626 <__fp_cmp>
    13b2:	08 f4       	brcc	.+2      	; 0x13b6 <__cmpsf2+0x8>
    13b4:	81 e0       	ldi	r24, 0x01	; 1
    13b6:	08 95       	ret

000013b8 <__divsf3>:
    13b8:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <__divsf3x>
    13bc:	0c 94 75 0b 	jmp	0x16ea	; 0x16ea <__fp_round>
    13c0:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <__fp_pscB>
    13c4:	58 f0       	brcs	.+22     	; 0x13dc <__divsf3+0x24>
    13c6:	0e 94 67 0b 	call	0x16ce	; 0x16ce <__fp_pscA>
    13ca:	40 f0       	brcs	.+16     	; 0x13dc <__divsf3+0x24>
    13cc:	29 f4       	brne	.+10     	; 0x13d8 <__divsf3+0x20>
    13ce:	5f 3f       	cpi	r21, 0xFF	; 255
    13d0:	29 f0       	breq	.+10     	; 0x13dc <__divsf3+0x24>
    13d2:	0c 94 37 0b 	jmp	0x166e	; 0x166e <__fp_inf>
    13d6:	51 11       	cpse	r21, r1
    13d8:	0c 94 a9 0b 	jmp	0x1752	; 0x1752 <__fp_szero>
    13dc:	0c 94 3d 0b 	jmp	0x167a	; 0x167a <__fp_nan>

000013e0 <__divsf3x>:
    13e0:	0e 94 86 0b 	call	0x170c	; 0x170c <__fp_split3>
    13e4:	68 f3       	brcs	.-38     	; 0x13c0 <__divsf3+0x8>

000013e6 <__divsf3_pse>:
    13e6:	99 23       	and	r25, r25
    13e8:	b1 f3       	breq	.-20     	; 0x13d6 <__divsf3+0x1e>
    13ea:	55 23       	and	r21, r21
    13ec:	91 f3       	breq	.-28     	; 0x13d2 <__divsf3+0x1a>
    13ee:	95 1b       	sub	r25, r21
    13f0:	55 0b       	sbc	r21, r21
    13f2:	bb 27       	eor	r27, r27
    13f4:	aa 27       	eor	r26, r26
    13f6:	62 17       	cp	r22, r18
    13f8:	73 07       	cpc	r23, r19
    13fa:	84 07       	cpc	r24, r20
    13fc:	38 f0       	brcs	.+14     	; 0x140c <__divsf3_pse+0x26>
    13fe:	9f 5f       	subi	r25, 0xFF	; 255
    1400:	5f 4f       	sbci	r21, 0xFF	; 255
    1402:	22 0f       	add	r18, r18
    1404:	33 1f       	adc	r19, r19
    1406:	44 1f       	adc	r20, r20
    1408:	aa 1f       	adc	r26, r26
    140a:	a9 f3       	breq	.-22     	; 0x13f6 <__divsf3_pse+0x10>
    140c:	35 d0       	rcall	.+106    	; 0x1478 <__divsf3_pse+0x92>
    140e:	0e 2e       	mov	r0, r30
    1410:	3a f0       	brmi	.+14     	; 0x1420 <__divsf3_pse+0x3a>
    1412:	e0 e8       	ldi	r30, 0x80	; 128
    1414:	32 d0       	rcall	.+100    	; 0x147a <__divsf3_pse+0x94>
    1416:	91 50       	subi	r25, 0x01	; 1
    1418:	50 40       	sbci	r21, 0x00	; 0
    141a:	e6 95       	lsr	r30
    141c:	00 1c       	adc	r0, r0
    141e:	ca f7       	brpl	.-14     	; 0x1412 <__divsf3_pse+0x2c>
    1420:	2b d0       	rcall	.+86     	; 0x1478 <__divsf3_pse+0x92>
    1422:	fe 2f       	mov	r31, r30
    1424:	29 d0       	rcall	.+82     	; 0x1478 <__divsf3_pse+0x92>
    1426:	66 0f       	add	r22, r22
    1428:	77 1f       	adc	r23, r23
    142a:	88 1f       	adc	r24, r24
    142c:	bb 1f       	adc	r27, r27
    142e:	26 17       	cp	r18, r22
    1430:	37 07       	cpc	r19, r23
    1432:	48 07       	cpc	r20, r24
    1434:	ab 07       	cpc	r26, r27
    1436:	b0 e8       	ldi	r27, 0x80	; 128
    1438:	09 f0       	breq	.+2      	; 0x143c <__divsf3_pse+0x56>
    143a:	bb 0b       	sbc	r27, r27
    143c:	80 2d       	mov	r24, r0
    143e:	bf 01       	movw	r22, r30
    1440:	ff 27       	eor	r31, r31
    1442:	93 58       	subi	r25, 0x83	; 131
    1444:	5f 4f       	sbci	r21, 0xFF	; 255
    1446:	3a f0       	brmi	.+14     	; 0x1456 <__divsf3_pse+0x70>
    1448:	9e 3f       	cpi	r25, 0xFE	; 254
    144a:	51 05       	cpc	r21, r1
    144c:	78 f0       	brcs	.+30     	; 0x146c <__divsf3_pse+0x86>
    144e:	0c 94 37 0b 	jmp	0x166e	; 0x166e <__fp_inf>
    1452:	0c 94 a9 0b 	jmp	0x1752	; 0x1752 <__fp_szero>
    1456:	5f 3f       	cpi	r21, 0xFF	; 255
    1458:	e4 f3       	brlt	.-8      	; 0x1452 <__divsf3_pse+0x6c>
    145a:	98 3e       	cpi	r25, 0xE8	; 232
    145c:	d4 f3       	brlt	.-12     	; 0x1452 <__divsf3_pse+0x6c>
    145e:	86 95       	lsr	r24
    1460:	77 95       	ror	r23
    1462:	67 95       	ror	r22
    1464:	b7 95       	ror	r27
    1466:	f7 95       	ror	r31
    1468:	9f 5f       	subi	r25, 0xFF	; 255
    146a:	c9 f7       	brne	.-14     	; 0x145e <__divsf3_pse+0x78>
    146c:	88 0f       	add	r24, r24
    146e:	91 1d       	adc	r25, r1
    1470:	96 95       	lsr	r25
    1472:	87 95       	ror	r24
    1474:	97 f9       	bld	r25, 7
    1476:	08 95       	ret
    1478:	e1 e0       	ldi	r30, 0x01	; 1
    147a:	66 0f       	add	r22, r22
    147c:	77 1f       	adc	r23, r23
    147e:	88 1f       	adc	r24, r24
    1480:	bb 1f       	adc	r27, r27
    1482:	62 17       	cp	r22, r18
    1484:	73 07       	cpc	r23, r19
    1486:	84 07       	cpc	r24, r20
    1488:	ba 07       	cpc	r27, r26
    148a:	20 f0       	brcs	.+8      	; 0x1494 <__divsf3_pse+0xae>
    148c:	62 1b       	sub	r22, r18
    148e:	73 0b       	sbc	r23, r19
    1490:	84 0b       	sbc	r24, r20
    1492:	ba 0b       	sbc	r27, r26
    1494:	ee 1f       	adc	r30, r30
    1496:	88 f7       	brcc	.-30     	; 0x147a <__divsf3_pse+0x94>
    1498:	e0 95       	com	r30
    149a:	08 95       	ret
    149c:	29 f4       	brne	.+10     	; 0x14a8 <__divsf3_pse+0xc2>
    149e:	16 f0       	brts	.+4      	; 0x14a4 <__divsf3_pse+0xbe>
    14a0:	0c 94 37 0b 	jmp	0x166e	; 0x166e <__fp_inf>
    14a4:	0c 94 a8 0b 	jmp	0x1750	; 0x1750 <__fp_zero>
    14a8:	0c 94 3d 0b 	jmp	0x167a	; 0x167a <__fp_nan>

000014ac <exp>:
    14ac:	0e 94 8e 0b 	call	0x171c	; 0x171c <__fp_splitA>
    14b0:	a8 f3       	brcs	.-22     	; 0x149c <__divsf3_pse+0xb6>
    14b2:	96 38       	cpi	r25, 0x86	; 134
    14b4:	a0 f7       	brcc	.-24     	; 0x149e <__divsf3_pse+0xb8>
    14b6:	07 f8       	bld	r0, 7
    14b8:	0f 92       	push	r0
    14ba:	e8 94       	clt
    14bc:	2b e3       	ldi	r18, 0x3B	; 59
    14be:	3a ea       	ldi	r19, 0xAA	; 170
    14c0:	48 eb       	ldi	r20, 0xB8	; 184
    14c2:	5f e7       	ldi	r21, 0x7F	; 127
    14c4:	0e 94 40 0c 	call	0x1880	; 0x1880 <__mulsf3_pse>
    14c8:	0f 92       	push	r0
    14ca:	0f 92       	push	r0
    14cc:	0f 92       	push	r0
    14ce:	4d b7       	in	r20, 0x3d	; 61
    14d0:	5e b7       	in	r21, 0x3e	; 62
    14d2:	0f 92       	push	r0
    14d4:	0e 94 f6 0b 	call	0x17ec	; 0x17ec <modf>
    14d8:	ec e7       	ldi	r30, 0x7C	; 124
    14da:	f0 e0       	ldi	r31, 0x00	; 0
    14dc:	0e 94 40 0b 	call	0x1680	; 0x1680 <__fp_powser>
    14e0:	4f 91       	pop	r20
    14e2:	5f 91       	pop	r21
    14e4:	ef 91       	pop	r30
    14e6:	ff 91       	pop	r31
    14e8:	e5 95       	asr	r30
    14ea:	ee 1f       	adc	r30, r30
    14ec:	ff 1f       	adc	r31, r31
    14ee:	49 f0       	breq	.+18     	; 0x1502 <exp+0x56>
    14f0:	fe 57       	subi	r31, 0x7E	; 126
    14f2:	e0 68       	ori	r30, 0x80	; 128
    14f4:	44 27       	eor	r20, r20
    14f6:	ee 0f       	add	r30, r30
    14f8:	44 1f       	adc	r20, r20
    14fa:	fa 95       	dec	r31
    14fc:	e1 f7       	brne	.-8      	; 0x14f6 <exp+0x4a>
    14fe:	41 95       	neg	r20
    1500:	55 0b       	sbc	r21, r21
    1502:	0e 94 c0 0b 	call	0x1780	; 0x1780 <ldexp>
    1506:	0f 90       	pop	r0
    1508:	07 fe       	sbrs	r0, 7
    150a:	0c 94 b4 0b 	jmp	0x1768	; 0x1768 <inverse>
    150e:	08 95       	ret

00001510 <__fixunssfsi>:
    1510:	0e 94 8e 0b 	call	0x171c	; 0x171c <__fp_splitA>
    1514:	88 f0       	brcs	.+34     	; 0x1538 <__fixunssfsi+0x28>
    1516:	9f 57       	subi	r25, 0x7F	; 127
    1518:	98 f0       	brcs	.+38     	; 0x1540 <__fixunssfsi+0x30>
    151a:	b9 2f       	mov	r27, r25
    151c:	99 27       	eor	r25, r25
    151e:	b7 51       	subi	r27, 0x17	; 23
    1520:	b0 f0       	brcs	.+44     	; 0x154e <__fixunssfsi+0x3e>
    1522:	e1 f0       	breq	.+56     	; 0x155c <__fixunssfsi+0x4c>
    1524:	66 0f       	add	r22, r22
    1526:	77 1f       	adc	r23, r23
    1528:	88 1f       	adc	r24, r24
    152a:	99 1f       	adc	r25, r25
    152c:	1a f0       	brmi	.+6      	; 0x1534 <__fixunssfsi+0x24>
    152e:	ba 95       	dec	r27
    1530:	c9 f7       	brne	.-14     	; 0x1524 <__fixunssfsi+0x14>
    1532:	14 c0       	rjmp	.+40     	; 0x155c <__fixunssfsi+0x4c>
    1534:	b1 30       	cpi	r27, 0x01	; 1
    1536:	91 f0       	breq	.+36     	; 0x155c <__fixunssfsi+0x4c>
    1538:	0e 94 a8 0b 	call	0x1750	; 0x1750 <__fp_zero>
    153c:	b1 e0       	ldi	r27, 0x01	; 1
    153e:	08 95       	ret
    1540:	0c 94 a8 0b 	jmp	0x1750	; 0x1750 <__fp_zero>
    1544:	67 2f       	mov	r22, r23
    1546:	78 2f       	mov	r23, r24
    1548:	88 27       	eor	r24, r24
    154a:	b8 5f       	subi	r27, 0xF8	; 248
    154c:	39 f0       	breq	.+14     	; 0x155c <__fixunssfsi+0x4c>
    154e:	b9 3f       	cpi	r27, 0xF9	; 249
    1550:	cc f3       	brlt	.-14     	; 0x1544 <__fixunssfsi+0x34>
    1552:	86 95       	lsr	r24
    1554:	77 95       	ror	r23
    1556:	67 95       	ror	r22
    1558:	b3 95       	inc	r27
    155a:	d9 f7       	brne	.-10     	; 0x1552 <__fixunssfsi+0x42>
    155c:	3e f4       	brtc	.+14     	; 0x156c <__fixunssfsi+0x5c>
    155e:	90 95       	com	r25
    1560:	80 95       	com	r24
    1562:	70 95       	com	r23
    1564:	61 95       	neg	r22
    1566:	7f 4f       	sbci	r23, 0xFF	; 255
    1568:	8f 4f       	sbci	r24, 0xFF	; 255
    156a:	9f 4f       	sbci	r25, 0xFF	; 255
    156c:	08 95       	ret

0000156e <__floatunsisf>:
    156e:	e8 94       	clt
    1570:	09 c0       	rjmp	.+18     	; 0x1584 <__floatsisf+0x12>

00001572 <__floatsisf>:
    1572:	97 fb       	bst	r25, 7
    1574:	3e f4       	brtc	.+14     	; 0x1584 <__floatsisf+0x12>
    1576:	90 95       	com	r25
    1578:	80 95       	com	r24
    157a:	70 95       	com	r23
    157c:	61 95       	neg	r22
    157e:	7f 4f       	sbci	r23, 0xFF	; 255
    1580:	8f 4f       	sbci	r24, 0xFF	; 255
    1582:	9f 4f       	sbci	r25, 0xFF	; 255
    1584:	99 23       	and	r25, r25
    1586:	a9 f0       	breq	.+42     	; 0x15b2 <__floatsisf+0x40>
    1588:	f9 2f       	mov	r31, r25
    158a:	96 e9       	ldi	r25, 0x96	; 150
    158c:	bb 27       	eor	r27, r27
    158e:	93 95       	inc	r25
    1590:	f6 95       	lsr	r31
    1592:	87 95       	ror	r24
    1594:	77 95       	ror	r23
    1596:	67 95       	ror	r22
    1598:	b7 95       	ror	r27
    159a:	f1 11       	cpse	r31, r1
    159c:	f8 cf       	rjmp	.-16     	; 0x158e <__floatsisf+0x1c>
    159e:	fa f4       	brpl	.+62     	; 0x15de <__floatsisf+0x6c>
    15a0:	bb 0f       	add	r27, r27
    15a2:	11 f4       	brne	.+4      	; 0x15a8 <__floatsisf+0x36>
    15a4:	60 ff       	sbrs	r22, 0
    15a6:	1b c0       	rjmp	.+54     	; 0x15de <__floatsisf+0x6c>
    15a8:	6f 5f       	subi	r22, 0xFF	; 255
    15aa:	7f 4f       	sbci	r23, 0xFF	; 255
    15ac:	8f 4f       	sbci	r24, 0xFF	; 255
    15ae:	9f 4f       	sbci	r25, 0xFF	; 255
    15b0:	16 c0       	rjmp	.+44     	; 0x15de <__floatsisf+0x6c>
    15b2:	88 23       	and	r24, r24
    15b4:	11 f0       	breq	.+4      	; 0x15ba <__floatsisf+0x48>
    15b6:	96 e9       	ldi	r25, 0x96	; 150
    15b8:	11 c0       	rjmp	.+34     	; 0x15dc <__floatsisf+0x6a>
    15ba:	77 23       	and	r23, r23
    15bc:	21 f0       	breq	.+8      	; 0x15c6 <__floatsisf+0x54>
    15be:	9e e8       	ldi	r25, 0x8E	; 142
    15c0:	87 2f       	mov	r24, r23
    15c2:	76 2f       	mov	r23, r22
    15c4:	05 c0       	rjmp	.+10     	; 0x15d0 <__floatsisf+0x5e>
    15c6:	66 23       	and	r22, r22
    15c8:	71 f0       	breq	.+28     	; 0x15e6 <__floatsisf+0x74>
    15ca:	96 e8       	ldi	r25, 0x86	; 134
    15cc:	86 2f       	mov	r24, r22
    15ce:	70 e0       	ldi	r23, 0x00	; 0
    15d0:	60 e0       	ldi	r22, 0x00	; 0
    15d2:	2a f0       	brmi	.+10     	; 0x15de <__floatsisf+0x6c>
    15d4:	9a 95       	dec	r25
    15d6:	66 0f       	add	r22, r22
    15d8:	77 1f       	adc	r23, r23
    15da:	88 1f       	adc	r24, r24
    15dc:	da f7       	brpl	.-10     	; 0x15d4 <__floatsisf+0x62>
    15de:	88 0f       	add	r24, r24
    15e0:	96 95       	lsr	r25
    15e2:	87 95       	ror	r24
    15e4:	97 f9       	bld	r25, 7
    15e6:	08 95       	ret

000015e8 <fmin>:
    15e8:	99 0f       	add	r25, r25
    15ea:	bb 0b       	sbc	r27, r27
    15ec:	55 0f       	add	r21, r21
    15ee:	aa 0b       	sbc	r26, r26
    15f0:	e0 e8       	ldi	r30, 0x80	; 128
    15f2:	fe ef       	ldi	r31, 0xFE	; 254
    15f4:	16 16       	cp	r1, r22
    15f6:	17 06       	cpc	r1, r23
    15f8:	e8 07       	cpc	r30, r24
    15fa:	f9 07       	cpc	r31, r25
    15fc:	70 f0       	brcs	.+28     	; 0x161a <fmin+0x32>
    15fe:	12 16       	cp	r1, r18
    1600:	13 06       	cpc	r1, r19
    1602:	e4 07       	cpc	r30, r20
    1604:	f5 07       	cpc	r31, r21
    1606:	60 f0       	brcs	.+24     	; 0x1620 <fmin+0x38>
    1608:	ba 17       	cp	r27, r26
    160a:	54 f0       	brlt	.+20     	; 0x1620 <fmin+0x38>
    160c:	31 f4       	brne	.+12     	; 0x161a <fmin+0x32>
    160e:	26 17       	cp	r18, r22
    1610:	37 07       	cpc	r19, r23
    1612:	48 07       	cpc	r20, r24
    1614:	59 07       	cpc	r21, r25
    1616:	a7 95       	ror	r26
    1618:	1b f4       	brvc	.+6      	; 0x1620 <fmin+0x38>
    161a:	b9 01       	movw	r22, r18
    161c:	ca 01       	movw	r24, r20
    161e:	ba 2f       	mov	r27, r26
    1620:	b6 95       	lsr	r27
    1622:	97 95       	ror	r25
    1624:	08 95       	ret

00001626 <__fp_cmp>:
    1626:	99 0f       	add	r25, r25
    1628:	00 08       	sbc	r0, r0
    162a:	55 0f       	add	r21, r21
    162c:	aa 0b       	sbc	r26, r26
    162e:	e0 e8       	ldi	r30, 0x80	; 128
    1630:	fe ef       	ldi	r31, 0xFE	; 254
    1632:	16 16       	cp	r1, r22
    1634:	17 06       	cpc	r1, r23
    1636:	e8 07       	cpc	r30, r24
    1638:	f9 07       	cpc	r31, r25
    163a:	c0 f0       	brcs	.+48     	; 0x166c <__fp_cmp+0x46>
    163c:	12 16       	cp	r1, r18
    163e:	13 06       	cpc	r1, r19
    1640:	e4 07       	cpc	r30, r20
    1642:	f5 07       	cpc	r31, r21
    1644:	98 f0       	brcs	.+38     	; 0x166c <__fp_cmp+0x46>
    1646:	62 1b       	sub	r22, r18
    1648:	73 0b       	sbc	r23, r19
    164a:	84 0b       	sbc	r24, r20
    164c:	95 0b       	sbc	r25, r21
    164e:	39 f4       	brne	.+14     	; 0x165e <__fp_cmp+0x38>
    1650:	0a 26       	eor	r0, r26
    1652:	61 f0       	breq	.+24     	; 0x166c <__fp_cmp+0x46>
    1654:	23 2b       	or	r18, r19
    1656:	24 2b       	or	r18, r20
    1658:	25 2b       	or	r18, r21
    165a:	21 f4       	brne	.+8      	; 0x1664 <__fp_cmp+0x3e>
    165c:	08 95       	ret
    165e:	0a 26       	eor	r0, r26
    1660:	09 f4       	brne	.+2      	; 0x1664 <__fp_cmp+0x3e>
    1662:	a1 40       	sbci	r26, 0x01	; 1
    1664:	a6 95       	lsr	r26
    1666:	8f ef       	ldi	r24, 0xFF	; 255
    1668:	81 1d       	adc	r24, r1
    166a:	81 1d       	adc	r24, r1
    166c:	08 95       	ret

0000166e <__fp_inf>:
    166e:	97 f9       	bld	r25, 7
    1670:	9f 67       	ori	r25, 0x7F	; 127
    1672:	80 e8       	ldi	r24, 0x80	; 128
    1674:	70 e0       	ldi	r23, 0x00	; 0
    1676:	60 e0       	ldi	r22, 0x00	; 0
    1678:	08 95       	ret

0000167a <__fp_nan>:
    167a:	9f ef       	ldi	r25, 0xFF	; 255
    167c:	80 ec       	ldi	r24, 0xC0	; 192
    167e:	08 95       	ret

00001680 <__fp_powser>:
    1680:	df 93       	push	r29
    1682:	cf 93       	push	r28
    1684:	1f 93       	push	r17
    1686:	0f 93       	push	r16
    1688:	ff 92       	push	r15
    168a:	ef 92       	push	r14
    168c:	df 92       	push	r13
    168e:	7b 01       	movw	r14, r22
    1690:	8c 01       	movw	r16, r24
    1692:	68 94       	set
    1694:	06 c0       	rjmp	.+12     	; 0x16a2 <__fp_powser+0x22>
    1696:	da 2e       	mov	r13, r26
    1698:	ef 01       	movw	r28, r30
    169a:	0e 94 3d 0c 	call	0x187a	; 0x187a <__mulsf3x>
    169e:	fe 01       	movw	r30, r28
    16a0:	e8 94       	clt
    16a2:	a5 91       	lpm	r26, Z+
    16a4:	25 91       	lpm	r18, Z+
    16a6:	35 91       	lpm	r19, Z+
    16a8:	45 91       	lpm	r20, Z+
    16aa:	55 91       	lpm	r21, Z+
    16ac:	a6 f3       	brts	.-24     	; 0x1696 <__fp_powser+0x16>
    16ae:	ef 01       	movw	r28, r30
    16b0:	0e 94 82 09 	call	0x1304	; 0x1304 <__addsf3x>
    16b4:	fe 01       	movw	r30, r28
    16b6:	97 01       	movw	r18, r14
    16b8:	a8 01       	movw	r20, r16
    16ba:	da 94       	dec	r13
    16bc:	69 f7       	brne	.-38     	; 0x1698 <__fp_powser+0x18>
    16be:	df 90       	pop	r13
    16c0:	ef 90       	pop	r14
    16c2:	ff 90       	pop	r15
    16c4:	0f 91       	pop	r16
    16c6:	1f 91       	pop	r17
    16c8:	cf 91       	pop	r28
    16ca:	df 91       	pop	r29
    16cc:	08 95       	ret

000016ce <__fp_pscA>:
    16ce:	00 24       	eor	r0, r0
    16d0:	0a 94       	dec	r0
    16d2:	16 16       	cp	r1, r22
    16d4:	17 06       	cpc	r1, r23
    16d6:	18 06       	cpc	r1, r24
    16d8:	09 06       	cpc	r0, r25
    16da:	08 95       	ret

000016dc <__fp_pscB>:
    16dc:	00 24       	eor	r0, r0
    16de:	0a 94       	dec	r0
    16e0:	12 16       	cp	r1, r18
    16e2:	13 06       	cpc	r1, r19
    16e4:	14 06       	cpc	r1, r20
    16e6:	05 06       	cpc	r0, r21
    16e8:	08 95       	ret

000016ea <__fp_round>:
    16ea:	09 2e       	mov	r0, r25
    16ec:	03 94       	inc	r0
    16ee:	00 0c       	add	r0, r0
    16f0:	11 f4       	brne	.+4      	; 0x16f6 <__fp_round+0xc>
    16f2:	88 23       	and	r24, r24
    16f4:	52 f0       	brmi	.+20     	; 0x170a <__fp_round+0x20>
    16f6:	bb 0f       	add	r27, r27
    16f8:	40 f4       	brcc	.+16     	; 0x170a <__fp_round+0x20>
    16fa:	bf 2b       	or	r27, r31
    16fc:	11 f4       	brne	.+4      	; 0x1702 <__fp_round+0x18>
    16fe:	60 ff       	sbrs	r22, 0
    1700:	04 c0       	rjmp	.+8      	; 0x170a <__fp_round+0x20>
    1702:	6f 5f       	subi	r22, 0xFF	; 255
    1704:	7f 4f       	sbci	r23, 0xFF	; 255
    1706:	8f 4f       	sbci	r24, 0xFF	; 255
    1708:	9f 4f       	sbci	r25, 0xFF	; 255
    170a:	08 95       	ret

0000170c <__fp_split3>:
    170c:	57 fd       	sbrc	r21, 7
    170e:	90 58       	subi	r25, 0x80	; 128
    1710:	44 0f       	add	r20, r20
    1712:	55 1f       	adc	r21, r21
    1714:	59 f0       	breq	.+22     	; 0x172c <__fp_splitA+0x10>
    1716:	5f 3f       	cpi	r21, 0xFF	; 255
    1718:	71 f0       	breq	.+28     	; 0x1736 <__fp_splitA+0x1a>
    171a:	47 95       	ror	r20

0000171c <__fp_splitA>:
    171c:	88 0f       	add	r24, r24
    171e:	97 fb       	bst	r25, 7
    1720:	99 1f       	adc	r25, r25
    1722:	61 f0       	breq	.+24     	; 0x173c <__fp_splitA+0x20>
    1724:	9f 3f       	cpi	r25, 0xFF	; 255
    1726:	79 f0       	breq	.+30     	; 0x1746 <__fp_splitA+0x2a>
    1728:	87 95       	ror	r24
    172a:	08 95       	ret
    172c:	12 16       	cp	r1, r18
    172e:	13 06       	cpc	r1, r19
    1730:	14 06       	cpc	r1, r20
    1732:	55 1f       	adc	r21, r21
    1734:	f2 cf       	rjmp	.-28     	; 0x171a <__fp_split3+0xe>
    1736:	46 95       	lsr	r20
    1738:	f1 df       	rcall	.-30     	; 0x171c <__fp_splitA>
    173a:	08 c0       	rjmp	.+16     	; 0x174c <__fp_splitA+0x30>
    173c:	16 16       	cp	r1, r22
    173e:	17 06       	cpc	r1, r23
    1740:	18 06       	cpc	r1, r24
    1742:	99 1f       	adc	r25, r25
    1744:	f1 cf       	rjmp	.-30     	; 0x1728 <__fp_splitA+0xc>
    1746:	86 95       	lsr	r24
    1748:	71 05       	cpc	r23, r1
    174a:	61 05       	cpc	r22, r1
    174c:	08 94       	sec
    174e:	08 95       	ret

00001750 <__fp_zero>:
    1750:	e8 94       	clt

00001752 <__fp_szero>:
    1752:	bb 27       	eor	r27, r27
    1754:	66 27       	eor	r22, r22
    1756:	77 27       	eor	r23, r23
    1758:	cb 01       	movw	r24, r22
    175a:	97 f9       	bld	r25, 7
    175c:	08 95       	ret

0000175e <__gesf2>:
    175e:	0e 94 13 0b 	call	0x1626	; 0x1626 <__fp_cmp>
    1762:	08 f4       	brcc	.+2      	; 0x1766 <__gesf2+0x8>
    1764:	8f ef       	ldi	r24, 0xFF	; 255
    1766:	08 95       	ret

00001768 <inverse>:
    1768:	9b 01       	movw	r18, r22
    176a:	ac 01       	movw	r20, r24
    176c:	60 e0       	ldi	r22, 0x00	; 0
    176e:	70 e0       	ldi	r23, 0x00	; 0
    1770:	80 e8       	ldi	r24, 0x80	; 128
    1772:	9f e3       	ldi	r25, 0x3F	; 63
    1774:	0c 94 dc 09 	jmp	0x13b8	; 0x13b8 <__divsf3>
    1778:	0c 94 37 0b 	jmp	0x166e	; 0x166e <__fp_inf>
    177c:	0c 94 9f 0c 	jmp	0x193e	; 0x193e <__fp_mpack>

00001780 <ldexp>:
    1780:	0e 94 8e 0b 	call	0x171c	; 0x171c <__fp_splitA>
    1784:	d8 f3       	brcs	.-10     	; 0x177c <inverse+0x14>
    1786:	99 23       	and	r25, r25
    1788:	c9 f3       	breq	.-14     	; 0x177c <inverse+0x14>
    178a:	94 0f       	add	r25, r20
    178c:	51 1d       	adc	r21, r1
    178e:	a3 f3       	brvs	.-24     	; 0x1778 <inverse+0x10>
    1790:	91 50       	subi	r25, 0x01	; 1
    1792:	50 40       	sbci	r21, 0x00	; 0
    1794:	94 f0       	brlt	.+36     	; 0x17ba <ldexp+0x3a>
    1796:	59 f0       	breq	.+22     	; 0x17ae <ldexp+0x2e>
    1798:	88 23       	and	r24, r24
    179a:	32 f0       	brmi	.+12     	; 0x17a8 <ldexp+0x28>
    179c:	66 0f       	add	r22, r22
    179e:	77 1f       	adc	r23, r23
    17a0:	88 1f       	adc	r24, r24
    17a2:	91 50       	subi	r25, 0x01	; 1
    17a4:	50 40       	sbci	r21, 0x00	; 0
    17a6:	c1 f7       	brne	.-16     	; 0x1798 <ldexp+0x18>
    17a8:	9e 3f       	cpi	r25, 0xFE	; 254
    17aa:	51 05       	cpc	r21, r1
    17ac:	2c f7       	brge	.-54     	; 0x1778 <inverse+0x10>
    17ae:	88 0f       	add	r24, r24
    17b0:	91 1d       	adc	r25, r1
    17b2:	96 95       	lsr	r25
    17b4:	87 95       	ror	r24
    17b6:	97 f9       	bld	r25, 7
    17b8:	08 95       	ret
    17ba:	5f 3f       	cpi	r21, 0xFF	; 255
    17bc:	ac f0       	brlt	.+42     	; 0x17e8 <ldexp+0x68>
    17be:	98 3e       	cpi	r25, 0xE8	; 232
    17c0:	9c f0       	brlt	.+38     	; 0x17e8 <ldexp+0x68>
    17c2:	bb 27       	eor	r27, r27
    17c4:	86 95       	lsr	r24
    17c6:	77 95       	ror	r23
    17c8:	67 95       	ror	r22
    17ca:	b7 95       	ror	r27
    17cc:	08 f4       	brcc	.+2      	; 0x17d0 <ldexp+0x50>
    17ce:	b1 60       	ori	r27, 0x01	; 1
    17d0:	93 95       	inc	r25
    17d2:	c1 f7       	brne	.-16     	; 0x17c4 <ldexp+0x44>
    17d4:	bb 0f       	add	r27, r27
    17d6:	58 f7       	brcc	.-42     	; 0x17ae <ldexp+0x2e>
    17d8:	11 f4       	brne	.+4      	; 0x17de <ldexp+0x5e>
    17da:	60 ff       	sbrs	r22, 0
    17dc:	e8 cf       	rjmp	.-48     	; 0x17ae <ldexp+0x2e>
    17de:	6f 5f       	subi	r22, 0xFF	; 255
    17e0:	7f 4f       	sbci	r23, 0xFF	; 255
    17e2:	8f 4f       	sbci	r24, 0xFF	; 255
    17e4:	9f 4f       	sbci	r25, 0xFF	; 255
    17e6:	e3 cf       	rjmp	.-58     	; 0x17ae <ldexp+0x2e>
    17e8:	0c 94 a9 0b 	jmp	0x1752	; 0x1752 <__fp_szero>

000017ec <modf>:
    17ec:	fa 01       	movw	r30, r20
    17ee:	dc 01       	movw	r26, r24
    17f0:	aa 0f       	add	r26, r26
    17f2:	bb 1f       	adc	r27, r27
    17f4:	9b 01       	movw	r18, r22
    17f6:	ac 01       	movw	r20, r24
    17f8:	bf 57       	subi	r27, 0x7F	; 127
    17fa:	28 f4       	brcc	.+10     	; 0x1806 <modf+0x1a>
    17fc:	22 27       	eor	r18, r18
    17fe:	33 27       	eor	r19, r19
    1800:	44 27       	eor	r20, r20
    1802:	50 78       	andi	r21, 0x80	; 128
    1804:	20 c0       	rjmp	.+64     	; 0x1846 <modf+0x5a>
    1806:	b7 51       	subi	r27, 0x17	; 23
    1808:	90 f4       	brcc	.+36     	; 0x182e <modf+0x42>
    180a:	ab 2f       	mov	r26, r27
    180c:	00 24       	eor	r0, r0
    180e:	46 95       	lsr	r20
    1810:	37 95       	ror	r19
    1812:	27 95       	ror	r18
    1814:	01 1c       	adc	r0, r1
    1816:	a3 95       	inc	r26
    1818:	d2 f3       	brmi	.-12     	; 0x180e <modf+0x22>
    181a:	00 20       	and	r0, r0
    181c:	71 f0       	breq	.+28     	; 0x183a <modf+0x4e>
    181e:	22 0f       	add	r18, r18
    1820:	33 1f       	adc	r19, r19
    1822:	44 1f       	adc	r20, r20
    1824:	b3 95       	inc	r27
    1826:	da f3       	brmi	.-10     	; 0x181e <modf+0x32>
    1828:	0e d0       	rcall	.+28     	; 0x1846 <modf+0x5a>
    182a:	0c 94 6a 09 	jmp	0x12d4	; 0x12d4 <__subsf3>
    182e:	61 30       	cpi	r22, 0x01	; 1
    1830:	71 05       	cpc	r23, r1
    1832:	a0 e8       	ldi	r26, 0x80	; 128
    1834:	8a 07       	cpc	r24, r26
    1836:	b9 46       	sbci	r27, 0x69	; 105
    1838:	30 f4       	brcc	.+12     	; 0x1846 <modf+0x5a>
    183a:	9b 01       	movw	r18, r22
    183c:	ac 01       	movw	r20, r24
    183e:	66 27       	eor	r22, r22
    1840:	77 27       	eor	r23, r23
    1842:	88 27       	eor	r24, r24
    1844:	90 78       	andi	r25, 0x80	; 128
    1846:	30 96       	adiw	r30, 0x00	; 0
    1848:	21 f0       	breq	.+8      	; 0x1852 <modf+0x66>
    184a:	20 83       	st	Z, r18
    184c:	31 83       	std	Z+1, r19	; 0x01
    184e:	42 83       	std	Z+2, r20	; 0x02
    1850:	53 83       	std	Z+3, r21	; 0x03
    1852:	08 95       	ret

00001854 <__mulsf3>:
    1854:	0e 94 3d 0c 	call	0x187a	; 0x187a <__mulsf3x>
    1858:	0c 94 75 0b 	jmp	0x16ea	; 0x16ea <__fp_round>
    185c:	0e 94 67 0b 	call	0x16ce	; 0x16ce <__fp_pscA>
    1860:	38 f0       	brcs	.+14     	; 0x1870 <__mulsf3+0x1c>
    1862:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <__fp_pscB>
    1866:	20 f0       	brcs	.+8      	; 0x1870 <__mulsf3+0x1c>
    1868:	95 23       	and	r25, r21
    186a:	11 f0       	breq	.+4      	; 0x1870 <__mulsf3+0x1c>
    186c:	0c 94 37 0b 	jmp	0x166e	; 0x166e <__fp_inf>
    1870:	0c 94 3d 0b 	jmp	0x167a	; 0x167a <__fp_nan>
    1874:	11 24       	eor	r1, r1
    1876:	0c 94 a9 0b 	jmp	0x1752	; 0x1752 <__fp_szero>

0000187a <__mulsf3x>:
    187a:	0e 94 86 0b 	call	0x170c	; 0x170c <__fp_split3>
    187e:	70 f3       	brcs	.-36     	; 0x185c <__mulsf3+0x8>

00001880 <__mulsf3_pse>:
    1880:	95 9f       	mul	r25, r21
    1882:	c1 f3       	breq	.-16     	; 0x1874 <__mulsf3+0x20>
    1884:	95 0f       	add	r25, r21
    1886:	50 e0       	ldi	r21, 0x00	; 0
    1888:	55 1f       	adc	r21, r21
    188a:	62 9f       	mul	r22, r18
    188c:	f0 01       	movw	r30, r0
    188e:	72 9f       	mul	r23, r18
    1890:	bb 27       	eor	r27, r27
    1892:	f0 0d       	add	r31, r0
    1894:	b1 1d       	adc	r27, r1
    1896:	63 9f       	mul	r22, r19
    1898:	aa 27       	eor	r26, r26
    189a:	f0 0d       	add	r31, r0
    189c:	b1 1d       	adc	r27, r1
    189e:	aa 1f       	adc	r26, r26
    18a0:	64 9f       	mul	r22, r20
    18a2:	66 27       	eor	r22, r22
    18a4:	b0 0d       	add	r27, r0
    18a6:	a1 1d       	adc	r26, r1
    18a8:	66 1f       	adc	r22, r22
    18aa:	82 9f       	mul	r24, r18
    18ac:	22 27       	eor	r18, r18
    18ae:	b0 0d       	add	r27, r0
    18b0:	a1 1d       	adc	r26, r1
    18b2:	62 1f       	adc	r22, r18
    18b4:	73 9f       	mul	r23, r19
    18b6:	b0 0d       	add	r27, r0
    18b8:	a1 1d       	adc	r26, r1
    18ba:	62 1f       	adc	r22, r18
    18bc:	83 9f       	mul	r24, r19
    18be:	a0 0d       	add	r26, r0
    18c0:	61 1d       	adc	r22, r1
    18c2:	22 1f       	adc	r18, r18
    18c4:	74 9f       	mul	r23, r20
    18c6:	33 27       	eor	r19, r19
    18c8:	a0 0d       	add	r26, r0
    18ca:	61 1d       	adc	r22, r1
    18cc:	23 1f       	adc	r18, r19
    18ce:	84 9f       	mul	r24, r20
    18d0:	60 0d       	add	r22, r0
    18d2:	21 1d       	adc	r18, r1
    18d4:	82 2f       	mov	r24, r18
    18d6:	76 2f       	mov	r23, r22
    18d8:	6a 2f       	mov	r22, r26
    18da:	11 24       	eor	r1, r1
    18dc:	9f 57       	subi	r25, 0x7F	; 127
    18de:	50 40       	sbci	r21, 0x00	; 0
    18e0:	9a f0       	brmi	.+38     	; 0x1908 <__mulsf3_pse+0x88>
    18e2:	f1 f0       	breq	.+60     	; 0x1920 <__mulsf3_pse+0xa0>
    18e4:	88 23       	and	r24, r24
    18e6:	4a f0       	brmi	.+18     	; 0x18fa <__mulsf3_pse+0x7a>
    18e8:	ee 0f       	add	r30, r30
    18ea:	ff 1f       	adc	r31, r31
    18ec:	bb 1f       	adc	r27, r27
    18ee:	66 1f       	adc	r22, r22
    18f0:	77 1f       	adc	r23, r23
    18f2:	88 1f       	adc	r24, r24
    18f4:	91 50       	subi	r25, 0x01	; 1
    18f6:	50 40       	sbci	r21, 0x00	; 0
    18f8:	a9 f7       	brne	.-22     	; 0x18e4 <__mulsf3_pse+0x64>
    18fa:	9e 3f       	cpi	r25, 0xFE	; 254
    18fc:	51 05       	cpc	r21, r1
    18fe:	80 f0       	brcs	.+32     	; 0x1920 <__mulsf3_pse+0xa0>
    1900:	0c 94 37 0b 	jmp	0x166e	; 0x166e <__fp_inf>
    1904:	0c 94 a9 0b 	jmp	0x1752	; 0x1752 <__fp_szero>
    1908:	5f 3f       	cpi	r21, 0xFF	; 255
    190a:	e4 f3       	brlt	.-8      	; 0x1904 <__mulsf3_pse+0x84>
    190c:	98 3e       	cpi	r25, 0xE8	; 232
    190e:	d4 f3       	brlt	.-12     	; 0x1904 <__mulsf3_pse+0x84>
    1910:	86 95       	lsr	r24
    1912:	77 95       	ror	r23
    1914:	67 95       	ror	r22
    1916:	b7 95       	ror	r27
    1918:	f7 95       	ror	r31
    191a:	e7 95       	ror	r30
    191c:	9f 5f       	subi	r25, 0xFF	; 255
    191e:	c1 f7       	brne	.-16     	; 0x1910 <__mulsf3_pse+0x90>
    1920:	fe 2b       	or	r31, r30
    1922:	88 0f       	add	r24, r24
    1924:	91 1d       	adc	r25, r1
    1926:	96 95       	lsr	r25
    1928:	87 95       	ror	r24
    192a:	97 f9       	bld	r25, 7
    192c:	08 95       	ret

0000192e <sin>:
    192e:	9f 93       	push	r25
    1930:	0e 94 af 0c 	call	0x195e	; 0x195e <__fp_rempio2>
    1934:	0f 90       	pop	r0
    1936:	07 fc       	sbrc	r0, 7
    1938:	ee 5f       	subi	r30, 0xFE	; 254
    193a:	0c 94 d8 0c 	jmp	0x19b0	; 0x19b0 <__fp_sinus>

0000193e <__fp_mpack>:
    193e:	9f 3f       	cpi	r25, 0xFF	; 255
    1940:	31 f0       	breq	.+12     	; 0x194e <__fp_mpack_finite+0xc>

00001942 <__fp_mpack_finite>:
    1942:	91 50       	subi	r25, 0x01	; 1
    1944:	20 f4       	brcc	.+8      	; 0x194e <__fp_mpack_finite+0xc>
    1946:	87 95       	ror	r24
    1948:	77 95       	ror	r23
    194a:	67 95       	ror	r22
    194c:	b7 95       	ror	r27
    194e:	88 0f       	add	r24, r24
    1950:	91 1d       	adc	r25, r1
    1952:	96 95       	lsr	r25
    1954:	87 95       	ror	r24
    1956:	97 f9       	bld	r25, 7
    1958:	08 95       	ret
    195a:	0c 94 3d 0b 	jmp	0x167a	; 0x167a <__fp_nan>

0000195e <__fp_rempio2>:
    195e:	0e 94 8e 0b 	call	0x171c	; 0x171c <__fp_splitA>
    1962:	d8 f3       	brcs	.-10     	; 0x195a <__fp_mpack_finite+0x18>
    1964:	e8 94       	clt
    1966:	e0 e0       	ldi	r30, 0x00	; 0
    1968:	bb 27       	eor	r27, r27
    196a:	9f 57       	subi	r25, 0x7F	; 127
    196c:	f0 f0       	brcs	.+60     	; 0x19aa <__fp_rempio2+0x4c>
    196e:	2a ed       	ldi	r18, 0xDA	; 218
    1970:	3f e0       	ldi	r19, 0x0F	; 15
    1972:	49 ec       	ldi	r20, 0xC9	; 201
    1974:	06 c0       	rjmp	.+12     	; 0x1982 <__fp_rempio2+0x24>
    1976:	ee 0f       	add	r30, r30
    1978:	bb 0f       	add	r27, r27
    197a:	66 1f       	adc	r22, r22
    197c:	77 1f       	adc	r23, r23
    197e:	88 1f       	adc	r24, r24
    1980:	28 f0       	brcs	.+10     	; 0x198c <__fp_rempio2+0x2e>
    1982:	b2 3a       	cpi	r27, 0xA2	; 162
    1984:	62 07       	cpc	r22, r18
    1986:	73 07       	cpc	r23, r19
    1988:	84 07       	cpc	r24, r20
    198a:	28 f0       	brcs	.+10     	; 0x1996 <__fp_rempio2+0x38>
    198c:	b2 5a       	subi	r27, 0xA2	; 162
    198e:	62 0b       	sbc	r22, r18
    1990:	73 0b       	sbc	r23, r19
    1992:	84 0b       	sbc	r24, r20
    1994:	e3 95       	inc	r30
    1996:	9a 95       	dec	r25
    1998:	72 f7       	brpl	.-36     	; 0x1976 <__fp_rempio2+0x18>
    199a:	80 38       	cpi	r24, 0x80	; 128
    199c:	30 f4       	brcc	.+12     	; 0x19aa <__fp_rempio2+0x4c>
    199e:	9a 95       	dec	r25
    19a0:	bb 0f       	add	r27, r27
    19a2:	66 1f       	adc	r22, r22
    19a4:	77 1f       	adc	r23, r23
    19a6:	88 1f       	adc	r24, r24
    19a8:	d2 f7       	brpl	.-12     	; 0x199e <__fp_rempio2+0x40>
    19aa:	90 48       	sbci	r25, 0x80	; 128
    19ac:	0c 94 a1 0c 	jmp	0x1942	; 0x1942 <__fp_mpack_finite>

000019b0 <__fp_sinus>:
    19b0:	ef 93       	push	r30
    19b2:	e0 ff       	sbrs	r30, 0
    19b4:	07 c0       	rjmp	.+14     	; 0x19c4 <__fp_sinus+0x14>
    19b6:	a2 ea       	ldi	r26, 0xA2	; 162
    19b8:	2a ed       	ldi	r18, 0xDA	; 218
    19ba:	3f e0       	ldi	r19, 0x0F	; 15
    19bc:	49 ec       	ldi	r20, 0xC9	; 201
    19be:	5f eb       	ldi	r21, 0xBF	; 191
    19c0:	0e 94 82 09 	call	0x1304	; 0x1304 <__addsf3x>
    19c4:	0e 94 75 0b 	call	0x16ea	; 0x16ea <__fp_round>
    19c8:	0f 90       	pop	r0
    19ca:	03 94       	inc	r0
    19cc:	01 fc       	sbrc	r0, 1
    19ce:	90 58       	subi	r25, 0x80	; 128
    19d0:	e4 ea       	ldi	r30, 0xA4	; 164
    19d2:	f0 e0       	ldi	r31, 0x00	; 0
    19d4:	0c 94 ec 0c 	jmp	0x19d8	; 0x19d8 <__fp_powsodd>

000019d8 <__fp_powsodd>:
    19d8:	9f 93       	push	r25
    19da:	8f 93       	push	r24
    19dc:	7f 93       	push	r23
    19de:	6f 93       	push	r22
    19e0:	ff 93       	push	r31
    19e2:	ef 93       	push	r30
    19e4:	9b 01       	movw	r18, r22
    19e6:	ac 01       	movw	r20, r24
    19e8:	0e 94 2a 0c 	call	0x1854	; 0x1854 <__mulsf3>
    19ec:	ef 91       	pop	r30
    19ee:	ff 91       	pop	r31
    19f0:	0e 94 40 0b 	call	0x1680	; 0x1680 <__fp_powser>
    19f4:	2f 91       	pop	r18
    19f6:	3f 91       	pop	r19
    19f8:	4f 91       	pop	r20
    19fa:	5f 91       	pop	r21
    19fc:	0c 94 2a 0c 	jmp	0x1854	; 0x1854 <__mulsf3>

00001a00 <__udivmodsi4>:
    1a00:	a1 e2       	ldi	r26, 0x21	; 33
    1a02:	1a 2e       	mov	r1, r26
    1a04:	aa 1b       	sub	r26, r26
    1a06:	bb 1b       	sub	r27, r27
    1a08:	fd 01       	movw	r30, r26
    1a0a:	0d c0       	rjmp	.+26     	; 0x1a26 <__udivmodsi4_ep>

00001a0c <__udivmodsi4_loop>:
    1a0c:	aa 1f       	adc	r26, r26
    1a0e:	bb 1f       	adc	r27, r27
    1a10:	ee 1f       	adc	r30, r30
    1a12:	ff 1f       	adc	r31, r31
    1a14:	a2 17       	cp	r26, r18
    1a16:	b3 07       	cpc	r27, r19
    1a18:	e4 07       	cpc	r30, r20
    1a1a:	f5 07       	cpc	r31, r21
    1a1c:	20 f0       	brcs	.+8      	; 0x1a26 <__udivmodsi4_ep>
    1a1e:	a2 1b       	sub	r26, r18
    1a20:	b3 0b       	sbc	r27, r19
    1a22:	e4 0b       	sbc	r30, r20
    1a24:	f5 0b       	sbc	r31, r21

00001a26 <__udivmodsi4_ep>:
    1a26:	66 1f       	adc	r22, r22
    1a28:	77 1f       	adc	r23, r23
    1a2a:	88 1f       	adc	r24, r24
    1a2c:	99 1f       	adc	r25, r25
    1a2e:	1a 94       	dec	r1
    1a30:	69 f7       	brne	.-38     	; 0x1a0c <__udivmodsi4_loop>
    1a32:	60 95       	com	r22
    1a34:	70 95       	com	r23
    1a36:	80 95       	com	r24
    1a38:	90 95       	com	r25
    1a3a:	9b 01       	movw	r18, r22
    1a3c:	ac 01       	movw	r20, r24
    1a3e:	bd 01       	movw	r22, r26
    1a40:	cf 01       	movw	r24, r30
    1a42:	08 95       	ret

00001a44 <_exit>:
    1a44:	f8 94       	cli

00001a46 <__stop_program>:
    1a46:	ff cf       	rjmp	.-2      	; 0x1a46 <__stop_program>
