
Hjernebyggesett_V4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000016  00803800  00002440  000024f4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000023d4  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000006c  0000a3d4  000023d4  00002488  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .bss          00000055  00803816  00803816  0000250a  2**0
                  ALLOC
  4 .comment      0000005c  00000000  00000000  0000250a  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002568  2**2
                  CONTENTS, READONLY
  6 .debug_aranges 000004d0  00000000  00000000  000025a8  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00008667  00000000  00000000  00002a78  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000036e5  00000000  00000000  0000b0df  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000290b  00000000  00000000  0000e7c4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000008a0  00000000  00000000  000110d0  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00003505  00000000  00000000  00011970  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000173f  00000000  00000000  00014e75  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000348  00000000  00000000  000165b4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 de 00 	jmp	0x1bc	; 0x1bc <__ctors_end>
       4:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
       8:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
       c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      10:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      14:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      18:	0c 94 7b 05 	jmp	0xaf6	; 0xaf6 <__vector_6>
      1c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      20:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      24:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      28:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      2c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      30:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      34:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      38:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      3c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      40:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      44:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      48:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      4c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      50:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      54:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      58:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      5c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      60:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      64:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      68:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      6c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      70:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      74:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      78:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      7c:	07 63       	ori	r16, 0x37	; 55
      7e:	42 36       	cpi	r20, 0x62	; 98
      80:	b7 9b       	sbis	0x16, 7	; 22
      82:	d8 a7       	std	Y+40, r29	; 0x28
      84:	1a 39       	cpi	r17, 0x9A	; 154
      86:	68 56       	subi	r22, 0x68	; 104
      88:	18 ae       	std	Y+56, r1	; 0x38
      8a:	ba ab       	std	Y+50, r27	; 0x32
      8c:	55 8c       	ldd	r5, Z+29	; 0x1d
      8e:	1d 3c       	cpi	r17, 0xCD	; 205
      90:	b7 cc       	rjmp	.-1682   	; 0xfffffa00 <__eeprom_end+0xff7efa00>
      92:	57 63       	ori	r21, 0x37	; 55
      94:	bd 6d       	ori	r27, 0xDD	; 221
      96:	ed fd       	.word	0xfded	; ????
      98:	75 3e       	cpi	r23, 0xE5	; 229
      9a:	f6 17       	cp	r31, r22
      9c:	72 31       	cpi	r23, 0x12	; 18
      9e:	bf 00       	.word	0x00bf	; ????
      a0:	00 00       	nop
      a2:	80 3f       	cpi	r24, 0xF0	; 240
      a4:	05 a8       	ldd	r0, Z+53	; 0x35
      a6:	4c cd       	rjmp	.-1384   	; 0xfffffb40 <__eeprom_end+0xff7efb40>
      a8:	b2 d4       	rcall	.+2404   	; 0xa0e <tinyDendrite_update_signals+0xb4>
      aa:	4e b9       	out	0x0e, r20	; 14
      ac:	38 36       	cpi	r19, 0x68	; 104
      ae:	a9 02       	muls	r26, r25
      b0:	0c 50       	subi	r16, 0x0C	; 12
      b2:	b9 91       	ld	r27, Y+
      b4:	86 88       	ldd	r8, Z+22	; 0x16
      b6:	08 3c       	cpi	r16, 0xC8	; 200
      b8:	a6 aa       	std	Z+54, r10	; 0x36
      ba:	aa 2a       	or	r10, r26
      bc:	be 00       	.word	0x00be	; ????
      be:	00 00       	nop
      c0:	80 3f       	cpi	r24, 0xF0	; 240

000000c2 <__trampolines_end>:
      c2:	00 40       	sbci	r16, 0x00	; 0
      c4:	7a 10       	cpse	r7, r10
      c6:	f3 5a       	subi	r31, 0xA3	; 163
      c8:	00 a0       	ldd	r0, Z+32	; 0x20
      ca:	72 4e       	sbci	r23, 0xE2	; 226
      cc:	18 09       	sbc	r17, r8
      ce:	00 10       	cpse	r0, r0
      d0:	a5 d4       	rcall	.+2378   	; 0xa1c <tinyDendrite_update_signals+0xc2>
      d2:	e8 00       	.word	0x00e8	; ????
      d4:	00 e8       	ldi	r16, 0x80	; 128
      d6:	76 48       	sbci	r23, 0x86	; 134
      d8:	17 00       	.word	0x0017	; ????
      da:	00 e4       	ldi	r16, 0x40	; 64
      dc:	0b 54       	subi	r16, 0x4B	; 75
      de:	02 00       	.word	0x0002	; ????
      e0:	00 ca       	rjmp	.-3072   	; 0xfffff4e2 <__eeprom_end+0xff7ef4e2>
      e2:	9a 3b       	cpi	r25, 0xBA	; 186
      e4:	00 00       	nop
      e6:	00 e1       	ldi	r16, 0x10	; 16
      e8:	f5 05       	cpc	r31, r5
      ea:	00 00       	nop
      ec:	80 96       	adiw	r24, 0x20	; 32
      ee:	98 00       	.word	0x0098	; ????
      f0:	00 00       	nop
      f2:	40 42       	sbci	r20, 0x20	; 32
      f4:	0f 00       	.word	0x000f	; ????
      f6:	00 00       	nop
      f8:	a0 86       	std	Z+8, r10	; 0x08
      fa:	01 00       	.word	0x0001	; ????
      fc:	00 00       	nop
      fe:	10 27       	eor	r17, r16
     100:	00 00       	nop
     102:	00 00       	nop
     104:	e8 03       	fmulsu	r22, r16
     106:	00 00       	nop
     108:	00 00       	nop
     10a:	64 00       	.word	0x0064	; ????
     10c:	00 00       	nop
     10e:	00 00       	nop
     110:	0a 00       	.word	0x000a	; ????
     112:	00 00       	nop
     114:	00 00       	nop
     116:	01 00       	.word	0x0001	; ????
     118:	00 00       	nop
     11a:	00 00       	nop
     11c:	2c 76       	andi	r18, 0x6C	; 108
     11e:	d8 88       	ldd	r13, Y+16	; 0x10
     120:	dc 67       	ori	r29, 0x7C	; 124
     122:	4f 08       	sbc	r4, r15
     124:	23 df       	rcall	.-442    	; 0xffffff6c <__eeprom_end+0xff7eff6c>
     126:	c1 df       	rcall	.-126    	; 0xaa <__SREG__+0x6b>
     128:	ae 59       	subi	r26, 0x9E	; 158
     12a:	e1 b1       	in	r30, 0x01	; 1
     12c:	b7 96       	adiw	r30, 0x27	; 39
     12e:	e5 e3       	ldi	r30, 0x35	; 53
     130:	e4 53       	subi	r30, 0x34	; 52
     132:	c6 3a       	cpi	r28, 0xA6	; 166
     134:	e6 51       	subi	r30, 0x16	; 22
     136:	99 76       	andi	r25, 0x69	; 105
     138:	96 e8       	ldi	r25, 0x86	; 134
     13a:	e6 c2       	rjmp	.+1484   	; 0x708 <tinyAxon_update_potential+0x12a>
     13c:	84 26       	eor	r8, r20
     13e:	eb 89       	ldd	r30, Y+19	; 0x13
     140:	8c 9b       	sbis	0x11, 4	; 17
     142:	62 ed       	ldi	r22, 0xD2	; 210
     144:	40 7c       	andi	r20, 0xC0	; 192
     146:	6f fc       	.word	0xfc6f	; ????
     148:	ef bc       	out	0x2f, r14	; 47
     14a:	9c 9f       	mul	r25, r28
     14c:	40 f2       	brcs	.-112    	; 0xde <__trampolines_end+0x1c>
     14e:	ba a5       	ldd	r27, Y+42	; 0x2a
     150:	6f a5       	ldd	r22, Y+47	; 0x2f
     152:	f4 90       	lpm	r15, Z
     154:	05 5a       	subi	r16, 0xA5	; 165
     156:	2a f7       	brpl	.-54     	; 0x122 <__trampolines_end+0x60>
     158:	5c 93       	st	X, r21
     15a:	6b 6c       	ori	r22, 0xCB	; 203
     15c:	f9 67       	ori	r31, 0x79	; 121
     15e:	6d c1       	rjmp	.+730    	; 0x43a <system_init+0x28>
     160:	1b fc       	.word	0xfc1b	; ????
     162:	e0 e4       	ldi	r30, 0x40	; 64
     164:	0d 47       	sbci	r16, 0x7D	; 125
     166:	fe f5       	brtc	.+126    	; 0x1e6 <.do_clear_bss_loop>
     168:	20 e6       	ldi	r18, 0x60	; 96
     16a:	b5 00       	.word	0x00b5	; ????
     16c:	d0 ed       	ldi	r29, 0xD0	; 208
     16e:	90 2e       	mov	r9, r16
     170:	03 00       	.word	0x0003	; ????
     172:	94 35       	cpi	r25, 0x54	; 84
     174:	77 05       	cpc	r23, r7
     176:	00 80       	ld	r0, Z
     178:	84 1e       	adc	r8, r20
     17a:	08 00       	.word	0x0008	; ????
     17c:	00 20       	and	r0, r0
     17e:	4e 0a       	sbc	r4, r30
     180:	00 00       	nop
     182:	00 c8       	rjmp	.-4096   	; 0xfffff184 <__eeprom_end+0xff7ef184>
     184:	0c 33       	cpi	r16, 0x3C	; 60
     186:	33 33       	cpi	r19, 0x33	; 51
     188:	33 0f       	add	r19, r19
     18a:	98 6e       	ori	r25, 0xE8	; 232
     18c:	12 83       	std	Z+2, r17	; 0x02
     18e:	11 41       	sbci	r17, 0x11	; 17
     190:	ef 8d       	ldd	r30, Y+31	; 0x1f
     192:	21 14       	cp	r2, r1
     194:	89 3b       	cpi	r24, 0xB9	; 185
     196:	e6 55       	subi	r30, 0x56	; 86
     198:	16 cf       	rjmp	.-468    	; 0xffffffc6 <__eeprom_end+0xff7effc6>
     19a:	fe e6       	ldi	r31, 0x6E	; 110
     19c:	db 18       	sub	r13, r11
     19e:	d1 84       	ldd	r13, Z+9	; 0x09
     1a0:	4b 38       	cpi	r20, 0x8B	; 139
     1a2:	1b f7       	brvc	.-58     	; 0x16a <__trampolines_end+0xa8>
     1a4:	7c 1d       	adc	r23, r12
     1a6:	90 1d       	adc	r25, r0
     1a8:	a4 bb       	out	0x14, r26	; 20
     1aa:	e4 24       	eor	r14, r4
     1ac:	20 32       	cpi	r18, 0x20	; 32
     1ae:	84 72       	andi	r24, 0x24	; 36
     1b0:	5e 22       	and	r5, r30
     1b2:	81 00       	.word	0x0081	; ????
     1b4:	c9 f1       	breq	.+114    	; 0x228 <main+0x28>
     1b6:	24 ec       	ldi	r18, 0xC4	; 196
     1b8:	a1 e5       	ldi	r26, 0x51	; 81
     1ba:	3d 27       	eor	r19, r29

000001bc <__ctors_end>:
     1bc:	11 24       	eor	r1, r1
     1be:	1f be       	out	0x3f, r1	; 63
     1c0:	cf ef       	ldi	r28, 0xFF	; 255
     1c2:	cd bf       	out	0x3d, r28	; 61
     1c4:	df e3       	ldi	r29, 0x3F	; 63
     1c6:	de bf       	out	0x3e, r29	; 62

000001c8 <__do_copy_data>:
     1c8:	18 e3       	ldi	r17, 0x38	; 56
     1ca:	a0 e0       	ldi	r26, 0x00	; 0
     1cc:	b8 e3       	ldi	r27, 0x38	; 56
     1ce:	e0 e4       	ldi	r30, 0x40	; 64
     1d0:	f4 e2       	ldi	r31, 0x24	; 36
     1d2:	02 c0       	rjmp	.+4      	; 0x1d8 <__do_copy_data+0x10>
     1d4:	05 90       	lpm	r0, Z+
     1d6:	0d 92       	st	X+, r0
     1d8:	a6 31       	cpi	r26, 0x16	; 22
     1da:	b1 07       	cpc	r27, r17
     1dc:	d9 f7       	brne	.-10     	; 0x1d4 <__do_copy_data+0xc>

000001de <__do_clear_bss>:
     1de:	28 e3       	ldi	r18, 0x38	; 56
     1e0:	a6 e1       	ldi	r26, 0x16	; 22
     1e2:	b8 e3       	ldi	r27, 0x38	; 56
     1e4:	01 c0       	rjmp	.+2      	; 0x1e8 <.do_clear_bss_start>

000001e6 <.do_clear_bss_loop>:
     1e6:	1d 92       	st	X+, r1

000001e8 <.do_clear_bss_start>:
     1e8:	ab 36       	cpi	r26, 0x6B	; 107
     1ea:	b2 07       	cpc	r27, r18
     1ec:	e1 f7       	brne	.-8      	; 0x1e6 <.do_clear_bss_loop>
     1ee:	0e 94 00 01 	call	0x200	; 0x200 <main>
     1f2:	0c 94 e8 11 	jmp	0x23d0	; 0x23d0 <_exit>

000001f6 <__bad_interrupt>:
     1f6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000001fa <atmel_start_init>:
/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
	system_init();
     1fa:	0e 94 09 02 	call	0x412	; 0x412 <system_init>
     1fe:	08 95       	ret

00000200 <main>:

int main(void)
{	
	
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
     200:	0e 94 fd 00 	call	0x1fa	; 0x1fa <atmel_start_init>
	For some reason, instead of the reference voltage being 4.32v, it is 3.3v. 
	A plausible explanation is that the microchip does not up the voltage, so that if the microchip is only ever 
	supplied with 3.3v, it will output 3.3v as the max.
	*/
	
	VREF.CTRLA |= VREF_DAC0REFSEL_4V34_gc;
     204:	e0 ea       	ldi	r30, 0xA0	; 160
     206:	f0 e0       	ldi	r31, 0x00	; 0
     208:	80 81       	ld	r24, Z
     20a:	83 60       	ori	r24, 0x03	; 3
     20c:	80 83       	st	Z, r24
	 
	while (1)
	{
		// We don't want to update the neuron too often because of various reasons. The tinyISR_getflag is set every ms, and so the loop is only run once every ms.  
		if(tinyISR_getflag())
     20e:	0e 94 a9 05 	call	0xb52	; 0xb52 <tinyISR_getflag>
     212:	88 23       	and	r24, r24
     214:	e1 f3       	breq	.-8      	; 0x20e <main+0xe>
		{
			
			if(tinyCharge_is_connected_to_charger()){
     216:	0e 94 03 04 	call	0x806	; 0x806 <tinyCharge_is_connected_to_charger>
     21a:	88 23       	and	r24, r24
     21c:	59 f0       	breq	.+22     	; 0x234 <main+0x34>
				// Charge loop
				
				if(tinyCharge_is_fully_charged()){
     21e:	0e 94 06 04 	call	0x80c	; 0x80c <tinyCharge_is_fully_charged>
     222:	88 23       	and	r24, r24
     224:	21 f0       	breq	.+8      	; 0x22e <main+0x2e>
					tinyLED_set_color(OUT_LED, CHARGING_DONE_COLOR);
     226:	63 e0       	ldi	r22, 0x03	; 3
     228:	80 e0       	ldi	r24, 0x00	; 0
     22a:	0e 94 c0 05 	call	0xb80	; 0xb80 <tinyLED_set_color>
				}				
				// We check the Dendrites in order to detect if we have stopped charging
				tinyDendrite_update_signals();
     22e:	0e 94 ad 04 	call	0x95a	; 0x95a <tinyDendrite_update_signals>
     232:	0d c0       	rjmp	.+26     	; 0x24e <main+0x4e>
			}
			else{
				// Main loop			
				
				// Set LED
				if(tinyLED_get_color(OUT_LED) == OFF){
     234:	80 e0       	ldi	r24, 0x00	; 0
     236:	0e 94 c9 05 	call	0xb92	; 0xb92 <tinyLED_get_color>
     23a:	81 11       	cpse	r24, r1
     23c:	04 c0       	rjmp	.+8      	; 0x246 <main+0x46>
					tinyLED_set_color_mode(OUT_LED, PING_COLOR, PING);
     23e:	43 e0       	ldi	r20, 0x03	; 3
     240:	62 e0       	ldi	r22, 0x02	; 2
     242:	0e 94 d1 05 	call	0xba2	; 0xba2 <tinyLED_set_color_mode>
				}
				
				// Update button	
				tinyButton_update();
     246:	0e 94 a4 03 	call	0x748	; 0x748 <tinyButton_update>
				
				// Update the potential (This is where most of the important stuff happens)
				tinyPotential_update();
     24a:	0e 94 ea 07 	call	0xfd4	; 0xfd4 <tinyPotential_update>
			}
			// Update LED
			tinyLED_update();
     24e:	0e 94 11 06 	call	0xc22	; 0xc22 <tinyLED_update>
				
			// Switch transistors
			tinyCharge_set_transistors();
     252:	0e 94 2d 04 	call	0x85a	; 0x85a <tinyCharge_set_transistors>
			
			// Prepare for next cycle
			tinyISR_setflag(false);
     256:	80 e0       	ldi	r24, 0x00	; 0
     258:	0e 94 a6 05 	call	0xb4c	; 0xb4c <tinyISR_setflag>
			tinyDebugger_send_uint32("time", tinyTime_now());
     25c:	0e 94 cd 08 	call	0x119a	; 0x119a <tinyTime_now>
     260:	ab 01       	movw	r20, r22
     262:	bc 01       	movw	r22, r24
     264:	84 ed       	ldi	r24, 0xD4	; 212
     266:	93 ea       	ldi	r25, 0xA3	; 163
     268:	0e 94 35 04 	call	0x86a	; 0x86a <tinyDebugger_send_uint32>
			tinyDebugger_end_line();
     26c:	0e 94 9c 04 	call	0x938	; 0x938 <tinyDebugger_end_line>
     270:	ce cf       	rjmp	.-100    	; 0x20e <main+0xe>

00000272 <ADC_0_init>:
 * \return Conversion result read from the ADC_0 ADC module
 */
adc_result_t ADC_0_get_conversion_result(void)
{
	return (ADC1.RES);
}
     272:	e0 e4       	ldi	r30, 0x40	; 64
     274:	f6 e0       	ldi	r31, 0x06	; 6
     276:	80 e1       	ldi	r24, 0x10	; 16
     278:	82 83       	std	Z+2, r24	; 0x02
     27a:	85 e0       	ldi	r24, 0x05	; 5
     27c:	80 83       	st	Z, r24
     27e:	80 e0       	ldi	r24, 0x00	; 0
     280:	08 95       	ret

00000282 <ADC_0_is_conversion_done>:
     282:	80 91 4b 06 	lds	r24, 0x064B	; 0x80064b <__TEXT_REGION_LENGTH__+0x70064b>
     286:	81 70       	andi	r24, 0x01	; 1
     288:	08 95       	ret

0000028a <ADC_0_get_conversion>:
 *
 * \return Nothing
 */
void ADC_0_start_conversion(adc_1_channel_t channel)
{
	ADC1.MUXPOS  = channel;
     28a:	e0 e4       	ldi	r30, 0x40	; 64
     28c:	f6 e0       	ldi	r31, 0x06	; 6
     28e:	86 83       	std	Z+6, r24	; 0x06
	ADC1.COMMAND = ADC_STCONV_bm;
     290:	81 e0       	ldi	r24, 0x01	; 1
     292:	80 87       	std	Z+8, r24	; 0x08
adc_result_t ADC_0_get_conversion(adc_1_channel_t channel)
{
	adc_result_t res;

	ADC_0_start_conversion(channel);
	while (!ADC_0_is_conversion_done())
     294:	0e 94 41 01 	call	0x282	; 0x282 <ADC_0_is_conversion_done>
     298:	88 23       	and	r24, r24
     29a:	e1 f3       	breq	.-8      	; 0x294 <ADC_0_get_conversion+0xa>
 *
 * \return Conversion result read from the ADC_0 ADC module
 */
adc_result_t ADC_0_get_conversion_result(void)
{
	return (ADC1.RES);
     29c:	e0 e4       	ldi	r30, 0x40	; 64
     29e:	f6 e0       	ldi	r31, 0x06	; 6
     2a0:	20 89       	ldd	r18, Z+16	; 0x10
     2a2:	31 89       	ldd	r19, Z+17	; 0x11

	ADC_0_start_conversion(channel);
	while (!ADC_0_is_conversion_done())
		;
	res = ADC_0_get_conversion_result();
	ADC1.INTFLAGS |= ADC_RESRDY_bm;
     2a4:	93 85       	ldd	r25, Z+11	; 0x0b
     2a6:	91 60       	ori	r25, 0x01	; 1
     2a8:	93 87       	std	Z+11, r25	; 0x0b
	return res;
}
     2aa:	c9 01       	movw	r24, r18
     2ac:	08 95       	ret

000002ae <BOD_init>:
	//		 | BOD_VLMCFG_BELOW_gc; /* Interrupt when supply goes below VLM level */

	// BOD.VLMCTRLA = BOD_VLMLVL_5ABOVE_gc; /* VLM threshold 5% above BOD level */

	return 0;
}
     2ae:	80 e0       	ldi	r24, 0x00	; 0
     2b0:	08 95       	ret

000002b2 <DIGITAL_GLUE_LOGIC_0_init>:

	// Enable Protected register, peripheral must be disabled (ENABLE=0, in TCD.LUT0CTRLA).

	// CCL.SEQCTRL0 = CCL_SEQSEL_DISABLE_gc /* Sequential logic disabled */;

	CCL.TRUTH0 = 168; /* Truth 0: 168 */
     2b2:	e0 ec       	ldi	r30, 0xC0	; 192
     2b4:	f1 e0       	ldi	r31, 0x01	; 1
     2b6:	28 ea       	ldi	r18, 0xA8	; 168
     2b8:	20 87       	std	Z+8, r18	; 0x08

	CCL.LUT0CTRLC = CCL_INSEL2_TCA0_gc /* TCA0 WO2 input source */;
     2ba:	98 e0       	ldi	r25, 0x08	; 8
     2bc:	97 83       	std	Z+7, r25	; 0x07

	CCL.LUT0CTRLB = CCL_INSEL0_SPI0_gc /* SPI0 SCK source */
     2be:	8b eb       	ldi	r24, 0xBB	; 187
     2c0:	86 83       	std	Z+6, r24	; 0x06
	                | CCL_INSEL1_SPI0_gc /* SPI0 MOSI input source */;

	CCL.LUT0CTRLA = 0 << CCL_CLKSRC_bp       /* Clock Source Selection: disabled */
     2c2:	39 e0       	ldi	r19, 0x09	; 9
     2c4:	35 83       	std	Z+5, r19	; 0x05
	                | CCL_EDGEDET_DIS_gc     /* Edge detector is disabled */
	                | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	                | 1 << CCL_ENABLE_bp     /* LUT Enable: enabled */
	                | 1 << CCL_OUTEN_bp;     /* Output Enable: enabled */

	CCL.TRUTH1 = 168; /* Truth 1: 168 */
     2c6:	24 87       	std	Z+12, r18	; 0x0c

	CCL.LUT1CTRLC = CCL_INSEL2_TCA0_gc /* TCA0 WO2 input source */;
     2c8:	93 87       	std	Z+11, r25	; 0x0b

	CCL.LUT1CTRLB = CCL_INSEL0_SPI0_gc /* SPI0 SCK source */
     2ca:	82 87       	std	Z+10, r24	; 0x0a
	//		 | CCL_EDGEDET_DIS_gc /* Edge detector is disabled */
	//		 | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	//		 | 0 << CCL_ENABLE_bp /* LUT Enable: disabled */
	//		 | 0 << CCL_OUTEN_bp; /* Output Enable: disabled */

	CCL.CTRLA = 1 << CCL_ENABLE_bp      /* Enable: enabled */
     2cc:	81 e4       	ldi	r24, 0x41	; 65
     2ce:	80 83       	st	Z, r24
	            | 1 << CCL_RUNSTDBY_bp; /* Run in Standby: enabled */

	return 0;
}
     2d0:	80 e0       	ldi	r24, 0x00	; 0
     2d2:	08 95       	ret

000002d4 <CLKCTRL_init>:
 *       on calling convention. The memory model is not visible to the
 *       preprocessor, so it must be defined in the Assembler preprocessor directives.
 */
static inline void ccp_write_io(void *addr, uint8_t value)
{
	protected_write_io(addr, CCP_IOREG_gc, value);
     2d4:	47 e0       	ldi	r20, 0x07	; 7
     2d6:	68 ed       	ldi	r22, 0xD8	; 216
     2d8:	8c e7       	ldi	r24, 0x7C	; 124
     2da:	90 e0       	ldi	r25, 0x00	; 0
     2dc:	0e 94 36 02 	call	0x46c	; 0x46c <protected_write_io>
     2e0:	41 e0       	ldi	r20, 0x01	; 1
     2e2:	68 ed       	ldi	r22, 0xD8	; 216
     2e4:	81 e6       	ldi	r24, 0x61	; 97
     2e6:	90 e0       	ldi	r25, 0x00	; 0
     2e8:	0e 94 36 02 	call	0x46c	; 0x46c <protected_write_io>
	//		 | 0 << CLKCTRL_CLKOUT_bp /* System clock out: disabled */);

	// ccp_write_io((void*)&(CLKCTRL.MCLKLOCK),0 << CLKCTRL_LOCKEN_bp /* lock enable: disabled */);

	return 0;
}
     2ec:	80 e0       	ldi	r24, 0x00	; 0
     2ee:	08 95       	ret

000002f0 <CPUINT_init>:

	// CPUINT.LVL0PRI = 0x0 << CPUINT_LVL0PRI_gp; /* Interrupt Level Priority: 0x0 */

	// CPUINT.LVL1VEC = 0x0 << CPUINT_LVL1VEC_gp; /* Interrupt Vector with High Priority: 0x0 */

	ENABLE_INTERRUPTS();
     2f0:	78 94       	sei

	return 0;
}
     2f2:	80 e0       	ldi	r24, 0x00	; 0
     2f4:	08 95       	ret

000002f6 <DAC_0_init>:
 *
 * \return Nothing
 */
void DAC_0_disable()
{
	DAC0.CTRLA &= ~DAC_ENABLE_bm;
     2f6:	81 e4       	ldi	r24, 0x41	; 65
     2f8:	80 93 a0 06 	sts	0x06A0, r24	; 0x8006a0 <__TEXT_REGION_LENGTH__+0x7006a0>
     2fc:	80 e0       	ldi	r24, 0x00	; 0
     2fe:	08 95       	ret

00000300 <DAC_0_set_output>:
 *
 * \return Nothing
 */
void DAC_0_set_output(dac_resolution_t value)
{
	DAC0.DATA = value;
     300:	80 93 a1 06 	sts	0x06A1, r24	; 0x8006a1 <__TEXT_REGION_LENGTH__+0x7006a1>
     304:	08 95       	ret

00000306 <mcu_init>:
#ifdef __cplusplus
extern "C" {
#endif

void mcu_init(void)
{
     306:	e0 e1       	ldi	r30, 0x10	; 16
     308:	f4 e0       	ldi	r31, 0x04	; 4
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     30a:	80 81       	ld	r24, Z
     30c:	88 60       	ori	r24, 0x08	; 8
     30e:	81 93       	st	Z+, r24
	 * disables all peripherals to save power. Driver shall enable
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
     310:	e8 31       	cpi	r30, 0x18	; 24
     312:	84 e0       	ldi	r24, 0x04	; 4
     314:	f8 07       	cpc	r31, r24
     316:	c9 f7       	brne	.-14     	; 0x30a <mcu_init+0x4>
     318:	e0 e3       	ldi	r30, 0x30	; 48
     31a:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     31c:	80 81       	ld	r24, Z
     31e:	88 60       	ori	r24, 0x08	; 8
     320:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     322:	e8 33       	cpi	r30, 0x38	; 56
     324:	84 e0       	ldi	r24, 0x04	; 4
     326:	f8 07       	cpc	r31, r24
     328:	c9 f7       	brne	.-14     	; 0x31c <mcu_init+0x16>
     32a:	e0 e5       	ldi	r30, 0x50	; 80
     32c:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     32e:	80 81       	ld	r24, Z
     330:	88 60       	ori	r24, 0x08	; 8
     332:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     334:	e8 35       	cpi	r30, 0x58	; 88
     336:	84 e0       	ldi	r24, 0x04	; 4
     338:	f8 07       	cpc	r31, r24
     33a:	c9 f7       	brne	.-14     	; 0x32e <mcu_init+0x28>
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}
}
     33c:	08 95       	ret

0000033e <ADC_0_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     33e:	e5 e1       	ldi	r30, 0x15	; 21
     340:	f4 e0       	ldi	r31, 0x04	; 4
     342:	80 81       	ld	r24, Z
     344:	88 7f       	andi	r24, 0xF8	; 248
     346:	84 60       	ori	r24, 0x04	; 4
     348:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     34a:	80 81       	ld	r24, Z
     34c:	87 7f       	andi	r24, 0xF7	; 247
     34e:	80 83       	st	Z, r24
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     350:	e7 e1       	ldi	r30, 0x17	; 23
     352:	f4 e0       	ldi	r31, 0x04	; 4
     354:	80 81       	ld	r24, Z
     356:	88 7f       	andi	r24, 0xF8	; 248
     358:	84 60       	ori	r24, 0x04	; 4
     35a:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     35c:	80 81       	ld	r24, Z
     35e:	87 7f       	andi	r24, 0xF7	; 247
     360:	80 83       	st	Z, r24
 */
static inline void PORTC_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     362:	e0 e5       	ldi	r30, 0x50	; 80
     364:	f4 e0       	ldi	r31, 0x04	; 4
     366:	80 81       	ld	r24, Z
     368:	88 7f       	andi	r24, 0xF8	; 248
     36a:	84 60       	ori	r24, 0x04	; 4
     36c:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     36e:	80 81       	ld	r24, Z
     370:	87 7f       	andi	r24, 0xF7	; 247
     372:	80 83       	st	Z, r24
 */
static inline void PORTC_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     374:	e1 e5       	ldi	r30, 0x51	; 81
     376:	f4 e0       	ldi	r31, 0x04	; 4
     378:	80 81       	ld	r24, Z
     37a:	88 7f       	andi	r24, 0xF8	; 248
     37c:	84 60       	ori	r24, 0x04	; 4
     37e:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     380:	80 81       	ld	r24, Z
     382:	87 7f       	andi	r24, 0xF7	; 247
     384:	80 83       	st	Z, r24
 */
static inline void PORTC_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     386:	e3 e5       	ldi	r30, 0x53	; 83
     388:	f4 e0       	ldi	r31, 0x04	; 4
     38a:	80 81       	ld	r24, Z
     38c:	88 7f       	andi	r24, 0xF8	; 248
     38e:	84 60       	ori	r24, 0x04	; 4
     390:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     392:	80 81       	ld	r24, Z
     394:	87 7f       	andi	r24, 0xF7	; 247
     396:	80 83       	st	Z, r24
	// Disable digital input buffer
	DEN4_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	DEN4_PIN_set_pull_mode(PORT_PULL_OFF);

	ADC_0_init();
     398:	0e 94 39 01 	call	0x272	; 0x272 <ADC_0_init>
     39c:	08 95       	ret

0000039e <USART_0_initialization>:
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     39e:	23 98       	cbi	0x04, 3	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     3a0:	e3 e3       	ldi	r30, 0x33	; 51
     3a2:	f4 e0       	ldi	r31, 0x04	; 4
     3a4:	80 81       	ld	r24, Z
     3a6:	87 7f       	andi	r24, 0xF7	; 247
     3a8:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     3aa:	22 9a       	sbi	0x04, 2	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     3ac:	2a 98       	cbi	0x05, 2	; 5
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	USART_0_init();
     3ae:	0e 94 70 02 	call	0x4e0	; 0x4e0 <USART_0_init>
     3b2:	08 95       	ret

000003b4 <TIMER_0_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     3b4:	25 9a       	sbi	0x04, 5	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     3b6:	2d 98       	cbi	0x05, 5	; 5
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLC |= PORTMUX_TCA02_bm;
     3b8:	e0 e0       	ldi	r30, 0x00	; 0
     3ba:	f2 e0       	ldi	r31, 0x02	; 2
     3bc:	82 81       	ldd	r24, Z+2	; 0x02
     3be:	84 60       	ori	r24, 0x04	; 4
     3c0:	82 83       	std	Z+2, r24	; 0x02

	TIMER_0_init();
     3c2:	0e 94 60 02 	call	0x4c0	; 0x4c0 <TIMER_0_init>
     3c6:	08 95       	ret

000003c8 <DIGITAL_GLUE_LOGIC_0_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     3c8:	24 9a       	sbi	0x04, 4	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     3ca:	2c 98       	cbi	0x05, 4	; 5
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLA |= PORTMUX_LUT0_bm;
     3cc:	e0 e0       	ldi	r30, 0x00	; 0
     3ce:	f2 e0       	ldi	r31, 0x02	; 2
     3d0:	80 81       	ld	r24, Z
     3d2:	80 61       	ori	r24, 0x10	; 16
     3d4:	80 83       	st	Z, r24

	DIGITAL_GLUE_LOGIC_0_init();
     3d6:	0e 94 59 01 	call	0x2b2	; 0x2b2 <DIGITAL_GLUE_LOGIC_0_init>
     3da:	08 95       	ret

000003dc <SPI_0_initialization>:
 */
static inline void PORTA_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
     3dc:	02 98       	cbi	0x00, 2	; 0
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     3de:	e2 e1       	ldi	r30, 0x12	; 18
     3e0:	f4 e0       	ldi	r31, 0x04	; 4
     3e2:	80 81       	ld	r24, Z
     3e4:	87 7f       	andi	r24, 0xF7	; 247
     3e6:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     3e8:	01 9a       	sbi	0x00, 1	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     3ea:	09 98       	cbi	0x01, 1	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     3ec:	03 9a       	sbi	0x00, 3	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     3ee:	0b 98       	cbi	0x01, 3	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     3f0:	04 9a       	sbi	0x00, 4	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     3f2:	0c 98       	cbi	0x01, 4	; 1
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	SPI_0_init();
     3f4:	0e 94 58 02 	call	0x4b0	; 0x4b0 <SPI_0_init>
     3f8:	08 95       	ret

000003fa <DAC_0_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     3fa:	e6 e1       	ldi	r30, 0x16	; 22
     3fc:	f4 e0       	ldi	r31, 0x04	; 4
     3fe:	80 81       	ld	r24, Z
     400:	88 7f       	andi	r24, 0xF8	; 248
     402:	84 60       	ori	r24, 0x04	; 4
     404:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     406:	80 81       	ld	r24, Z
     408:	87 7f       	andi	r24, 0xF7	; 247
     40a:	80 83       	st	Z, r24
	// Disable digital input buffer
	AXON_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	AXON_PIN_set_pull_mode(PORT_PULL_OFF);

	DAC_0_init();
     40c:	0e 94 7b 01 	call	0x2f6	; 0x2f6 <DAC_0_init>
     410:	08 95       	ret

00000412 <system_init>:
/**
 * \brief System initialization
 */
void system_init()
{
	mcu_init();
     412:	0e 94 83 01 	call	0x306	; 0x306 <mcu_init>
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     416:	26 98       	cbi	0x04, 6	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     418:	e6 e3       	ldi	r30, 0x36	; 54
     41a:	f4 e0       	ldi	r31, 0x04	; 4
     41c:	80 81       	ld	r24, Z
     41e:	87 7f       	andi	r24, 0xF7	; 247
     420:	80 83       	st	Z, r24
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     422:	27 98       	cbi	0x04, 7	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     424:	e7 e3       	ldi	r30, 0x37	; 55
     426:	f4 e0       	ldi	r31, 0x04	; 4
     428:	80 81       	ld	r24, Z
     42a:	87 7f       	andi	r24, 0xF7	; 247
     42c:	80 83       	st	Z, r24
 */
static inline void PORTC_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
     42e:	42 98       	cbi	0x08, 2	; 8
static inline void PORTC_set_pin_pull_mode(const uint8_t pin, const enum port_pull_mode pull_mode)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
     430:	e2 e5       	ldi	r30, 0x52	; 82
     432:	f4 e0       	ldi	r31, 0x04	; 4
     434:	80 81       	ld	r24, Z
     436:	88 60       	ori	r24, 0x08	; 8
     438:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTC.DIR |= (1 << pin);
     43a:	45 9a       	sbi	0x08, 5	; 8
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     43c:	4d 9a       	sbi	0x09, 5	; 9
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    true);

	CLKCTRL_init();
     43e:	0e 94 6a 01 	call	0x2d4	; 0x2d4 <CLKCTRL_init>

	RTC_0_init();
     442:	0e 94 3a 02 	call	0x474	; 0x474 <RTC_0_init>

	ADC_0_initialization();
     446:	0e 94 9f 01 	call	0x33e	; 0x33e <ADC_0_initialization>

	USART_0_initialization();
     44a:	0e 94 cf 01 	call	0x39e	; 0x39e <USART_0_initialization>

	TIMER_0_initialization();
     44e:	0e 94 da 01 	call	0x3b4	; 0x3b4 <TIMER_0_initialization>

	DIGITAL_GLUE_LOGIC_0_initialization();
     452:	0e 94 e4 01 	call	0x3c8	; 0x3c8 <DIGITAL_GLUE_LOGIC_0_initialization>

	SPI_0_initialization();
     456:	0e 94 ee 01 	call	0x3dc	; 0x3dc <SPI_0_initialization>

	DAC_0_initialization();
     45a:	0e 94 fd 01 	call	0x3fa	; 0x3fa <DAC_0_initialization>

	CPUINT_init();
     45e:	0e 94 78 01 	call	0x2f0	; 0x2f0 <CPUINT_init>

	SLPCTRL_init();
     462:	0e 94 56 02 	call	0x4ac	; 0x4ac <SLPCTRL_init>

	BOD_init();
     466:	0e 94 57 01 	call	0x2ae	; 0x2ae <BOD_init>
     46a:	08 95       	ret

0000046c <protected_write_io>:
#if defined(__GNUC__)
  
#ifdef RAMPZ
	out     _SFR_IO_ADDR(RAMPZ), r1         // Clear bits 23:16 of Z
#endif
	movw    r30, r24                // Load addr into Z
     46c:	fc 01       	movw	r30, r24
	out     CCP, r22                // Start CCP handshake
     46e:	64 bf       	out	0x34, r22	; 52
	st      Z, r20                  // Write value to I/O register
     470:	40 83       	st	Z, r20
	ret                             // Return to caller
     472:	08 95       	ret

00000474 <RTC_0_init>:
 * \return Initialization status.
 */
int8_t RTC_0_init()
{

	while (RTC.STATUS > 0) { /* Wait for all register to be synchronized */
     474:	e0 e4       	ldi	r30, 0x40	; 64
     476:	f1 e0       	ldi	r31, 0x01	; 1
     478:	81 81       	ldd	r24, Z+1	; 0x01
     47a:	81 11       	cpse	r24, r1
     47c:	fd cf       	rjmp	.-6      	; 0x478 <RTC_0_init+0x4>
	}

	// RTC.CMP = 0x0; /* Compare: 0x0 */

	RTC.CNT = 0x20; /* Counter: 0x20 */
     47e:	e0 e4       	ldi	r30, 0x40	; 64
     480:	f1 e0       	ldi	r31, 0x01	; 1
     482:	80 e2       	ldi	r24, 0x20	; 32
     484:	90 e0       	ldi	r25, 0x00	; 0
     486:	80 87       	std	Z+8, r24	; 0x08
     488:	91 87       	std	Z+9, r25	; 0x09

	RTC.CTRLA = RTC_PRESCALER_DIV1_gc   /* 1 */
     48a:	81 e8       	ldi	r24, 0x81	; 129
     48c:	80 83       	st	Z, r24
	            | 1 << RTC_RTCEN_bp     /* Enable: enabled */
	            | 1 << RTC_RUNSTDBY_bp; /* Run In Standby: enabled */

	RTC.PER = 0x20 / TIMESCALE; /* Period: 0x20 */
     48e:	80 e8       	ldi	r24, 0x80	; 128
     490:	92 e0       	ldi	r25, 0x02	; 2
     492:	82 87       	std	Z+10, r24	; 0x0a
     494:	93 87       	std	Z+11, r25	; 0x0b

	// RTC.CLKSEL = RTC_CLKSEL_INT32K_gc; /* 32KHz Internal Ultra Low Power Oscillator (OSCULP32K) */

	RTC.DBGCTRL = 1 << RTC_DBGRUN_bp; /* Run in debug: enabled */
     496:	81 e0       	ldi	r24, 0x01	; 1
     498:	85 83       	std	Z+5, r24	; 0x05

	RTC.INTCTRL = 0 << RTC_CMP_bp    /* Compare Match Interrupt enable: disabled */
     49a:	82 83       	std	Z+2, r24	; 0x02
	              | 1 << RTC_OVF_bp; /* Overflow Interrupt enable: enabled */

	while (RTC.PITSTATUS > 0) { /* Wait for all register to be synchronized */
     49c:	81 89       	ldd	r24, Z+17	; 0x11
     49e:	81 11       	cpse	r24, r1
     4a0:	fd cf       	rjmp	.-6      	; 0x49c <RTC_0_init+0x28>
	}

	RTC.PITCTRLA = RTC_PERIOD_OFF_gc    /* Off */
     4a2:	81 e0       	ldi	r24, 0x01	; 1
     4a4:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <__TEXT_REGION_LENGTH__+0x700150>
	// RTC.PITDBGCTRL = 0 << RTC_DBGRUN_bp; /* Run in debug: disabled */

	// RTC.PITINTCTRL = 0 << RTC_PI_bp; /* Periodic Interrupt: disabled */

	return 0;
}
     4a8:	80 e0       	ldi	r24, 0x00	; 0
     4aa:	08 95       	ret

000004ac <SLPCTRL_init>:

	// SLPCTRL.CTRLA = 0 << SLPCTRL_SEN_bp /* Sleep enable: disabled */
	//		 | SLPCTRL_SMODE_IDLE_gc; /* Idle mode */

	return 0;
}
     4ac:	80 e0       	ldi	r24, 0x00	; 0
     4ae:	08 95       	ret

000004b0 <SPI_0_init>:
 * \return Initialization status
 */
int8_t SPI_0_init()
{

	SPI0.CTRLA = 0 << SPI_CLK2X_bp     /* Enable Double Speed: disabled */
     4b0:	e0 e2       	ldi	r30, 0x20	; 32
     4b2:	f8 e0       	ldi	r31, 0x08	; 8
     4b4:	83 e2       	ldi	r24, 0x23	; 35
     4b6:	80 83       	st	Z, r24
	             | 0 << SPI_DORD_bp    /* Data Order Setting: disabled */
	             | 1 << SPI_ENABLE_bp  /* Enable Module: enabled */
	             | 1 << SPI_MASTER_bp  /* SPI module in master mode */
	             | SPI_PRESC_DIV16_gc; /* System Clock / 16 */

	SPI0.CTRLB = 0 << SPI_BUFEN_bp   /* Buffer Mode Enable: disabled */
     4b8:	84 e0       	ldi	r24, 0x04	; 4
     4ba:	81 83       	std	Z+1, r24	; 0x01
	//		 | 0 << SPI_RXCIE_bp /* Receive Complete Interrupt Enable: disabled */
	//		 | 0 << SPI_SSIE_bp /* Slave Select Trigger Interrupt Enable: disabled */
	//		 | 0 << SPI_TXCIE_bp; /* Transfer Complete Interrupt Enable: disabled */

	return 0;
}
     4bc:	80 e0       	ldi	r24, 0x00	; 0
     4be:	08 95       	ret

000004c0 <TIMER_0_init>:

	// TCA0.SINGLE.CMP0 = 0x0; /* Compare Register 0: 0x0 */

	// TCA0.SINGLE.CMP1 = 0x0; /* Compare Register 1: 0x0 */

	TCA0.SINGLE.CMP2 = 0x4; /* Compare Register 2: 0x4 */
     4c0:	e0 e0       	ldi	r30, 0x00	; 0
     4c2:	fa e0       	ldi	r31, 0x0A	; 10
     4c4:	84 e0       	ldi	r24, 0x04	; 4
     4c6:	90 e0       	ldi	r25, 0x00	; 0
     4c8:	84 a7       	std	Z+44, r24	; 0x2c
     4ca:	95 a7       	std	Z+45, r25	; 0x2d

	// TCA0.SINGLE.CNT = 0x0; /* Count: 0x0 */

	TCA0.SINGLE.CTRLB = 0 << TCA_SINGLE_ALUPD_bp            /* Auto Lock Update: disabled */
     4cc:	83 e4       	ldi	r24, 0x43	; 67
     4ce:	81 83       	std	Z+1, r24	; 0x01
	                    | 0 << TCA_SINGLE_CMP0EN_bp         /* Compare 0 Enable: disabled */
	                    | 0 << TCA_SINGLE_CMP1EN_bp         /* Compare 1 Enable: disabled */
	                    | 1 << TCA_SINGLE_CMP2EN_bp         /* Compare 2 Enable: enabled */
	                    | TCA_SINGLE_WGMODE_SINGLESLOPE_gc; /*  */

	TCA0.SINGLE.CTRLC = 0 << TCA_SINGLE_CMP0OV_bp    /* Compare 0 Waveform Output Value: disabled */
     4d0:	84 e0       	ldi	r24, 0x04	; 4
     4d2:	82 83       	std	Z+2, r24	; 0x02
	// TCA0.SINGLE.INTCTRL = 0 << TCA_SINGLE_CMP0_bp /* Compare 0 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP1_bp /* Compare 1 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP2_bp /* Compare 2 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_OVF_bp; /* Overflow Interrupt: disabled */

	TCA0.SINGLE.PER = 0x7; /* Period: 0x7 */
     4d4:	87 e0       	ldi	r24, 0x07	; 7
     4d6:	90 e0       	ldi	r25, 0x00	; 0
     4d8:	86 a3       	std	Z+38, r24	; 0x26
     4da:	97 a3       	std	Z+39, r25	; 0x27

	// TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV1_gc /* System Clock */
	//		 | 0 << TCA_SINGLE_ENABLE_bp; /* Module Enable: disabled */

	return 0;
}
     4dc:	80 e0       	ldi	r24, 0x00	; 0
     4de:	08 95       	ret

000004e0 <USART_0_init>:
uint8_t USART_0_read()
{
	while (!(USART0.STATUS & USART_RXCIF_bm))
		;
	return USART0.RXDATAL;
}
     4e0:	e0 e0       	ldi	r30, 0x00	; 0
     4e2:	f8 e0       	ldi	r31, 0x08	; 8
     4e4:	87 e4       	ldi	r24, 0x47	; 71
     4e6:	90 e1       	ldi	r25, 0x10	; 16
     4e8:	80 87       	std	Z+8, r24	; 0x08
     4ea:	91 87       	std	Z+9, r25	; 0x09
     4ec:	80 ec       	ldi	r24, 0xC0	; 192
     4ee:	86 83       	std	Z+6, r24	; 0x06
     4f0:	80 e0       	ldi	r24, 0x00	; 0
     4f2:	98 e3       	ldi	r25, 0x38	; 56
     4f4:	80 93 67 38 	sts	0x3867, r24	; 0x803867 <__iob+0x2>
     4f8:	90 93 68 38 	sts	0x3868, r25	; 0x803868 <__iob+0x3>
     4fc:	80 e0       	ldi	r24, 0x00	; 0
     4fe:	08 95       	ret

00000500 <USART_0_write>:
 *
 * \return Nothing
 */
void USART_0_write(const uint8_t data)
{
	while (!(USART0.STATUS & USART_DREIF_bm))
     500:	e0 e0       	ldi	r30, 0x00	; 0
     502:	f8 e0       	ldi	r31, 0x08	; 8
     504:	94 81       	ldd	r25, Z+4	; 0x04
     506:	95 ff       	sbrs	r25, 5
     508:	fd cf       	rjmp	.-6      	; 0x504 <USART_0_write+0x4>
		;
	USART0.TXDATAL = data;
     50a:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <__TEXT_REGION_LENGTH__+0x700802>
     50e:	08 95       	ret

00000510 <USART_0_printCHAR>:

#if defined(__GNUC__)

int USART_0_printCHAR(char character, FILE *stream)
{
	USART_0_write(character);
     510:	0e 94 80 02 	call	0x500	; 0x500 <USART_0_write>
	return 0;
}
     514:	80 e0       	ldi	r24, 0x00	; 0
     516:	90 e0       	ldi	r25, 0x00	; 0
     518:	08 95       	ret

0000051a <tinyAxon_add_pulse>:
{
	// We want to check each slot in the pulse_queue, and
	// if we find an empty slot (0), we add a pulse.
	for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
	{
		if(pulse_queue[i] == 0){
     51a:	20 91 17 38 	lds	r18, 0x3817	; 0x803817 <pulse_queue>
     51e:	30 91 18 38 	lds	r19, 0x3818	; 0x803818 <pulse_queue+0x1>
     522:	23 2b       	or	r18, r19
     524:	51 f0       	breq	.+20     	; 0x53a <tinyAxon_add_pulse+0x20>
     526:	e9 e1       	ldi	r30, 0x19	; 25
     528:	f8 e3       	ldi	r31, 0x38	; 56
     52a:	21 e0       	ldi	r18, 0x01	; 1
     52c:	30 e0       	ldi	r19, 0x00	; 0
     52e:	b9 01       	movw	r22, r18
     530:	41 91       	ld	r20, Z+
     532:	51 91       	ld	r21, Z+
     534:	45 2b       	or	r20, r21
     536:	81 f4       	brne	.+32     	; 0x558 <tinyAxon_add_pulse+0x3e>
     538:	02 c0       	rjmp	.+4      	; 0x53e <tinyAxon_add_pulse+0x24>
     53a:	60 e0       	ldi	r22, 0x00	; 0
     53c:	70 e0       	ldi	r23, 0x00	; 0
			pulse_queue[i] = new_pulse;
     53e:	66 0f       	add	r22, r22
     540:	77 1f       	adc	r23, r23
     542:	fb 01       	movw	r30, r22
     544:	e9 5e       	subi	r30, 0xE9	; 233
     546:	f7 4c       	sbci	r31, 0xC7	; 199
     548:	80 83       	st	Z, r24
     54a:	91 83       	std	Z+1, r25	; 0x01
			pulses_in_queue++;
     54c:	80 91 2b 38 	lds	r24, 0x382B	; 0x80382b <pulses_in_queue>
     550:	8f 5f       	subi	r24, 0xFF	; 255
     552:	80 93 2b 38 	sts	0x382B, r24	; 0x80382b <pulses_in_queue>
			// We return so we only ever add one
			break;
     556:	08 95       	ret
     558:	2f 5f       	subi	r18, 0xFF	; 255
     55a:	3f 4f       	sbci	r19, 0xFF	; 255
*/
static void tinyAxon_add_pulse(uint16_t new_pulse)
{
	// We want to check each slot in the pulse_queue, and
	// if we find an empty slot (0), we add a pulse.
	for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
     55c:	2a 30       	cpi	r18, 0x0A	; 10
     55e:	31 05       	cpc	r19, r1
     560:	31 f7       	brne	.-52     	; 0x52e <tinyAxon_add_pulse+0x14>
     562:	08 95       	ret

00000564 <find_newest_pulse>:
uint8_t find_newest_pulse() {
	uint16_t max;
	uint8_t current_index = 0;
	uint8_t return_index = 0;
	
	max = pulse_queue[current_index];
     564:	40 91 17 38 	lds	r20, 0x3817	; 0x803817 <pulse_queue>
     568:	50 91 18 38 	lds	r21, 0x3818	; 0x803818 <pulse_queue+0x1>
     56c:	e9 e1       	ldi	r30, 0x19	; 25
     56e:	f8 e3       	ldi	r31, 0x38	; 56
	
// This function will be used with pulse_queue to find the newest pulse
uint8_t find_newest_pulse() {
	uint16_t max;
	uint8_t current_index = 0;
	uint8_t return_index = 0;
     570:	80 e0       	ldi	r24, 0x00	; 0
	
	max = pulse_queue[current_index];
	
	for (current_index = 1; current_index < MAX_NUMBER_OF_PULSES; current_index++) {
     572:	91 e0       	ldi	r25, 0x01	; 1
		if (pulse_queue[current_index] > max) {
     574:	21 91       	ld	r18, Z+
     576:	31 91       	ld	r19, Z+
     578:	42 17       	cp	r20, r18
     57a:	53 07       	cpc	r21, r19
     57c:	10 f4       	brcc	.+4      	; 0x582 <find_newest_pulse+0x1e>
     57e:	89 2f       	mov	r24, r25
			return_index = current_index;
			max = pulse_queue[current_index];
     580:	a9 01       	movw	r20, r18
	uint8_t current_index = 0;
	uint8_t return_index = 0;
	
	max = pulse_queue[current_index];
	
	for (current_index = 1; current_index < MAX_NUMBER_OF_PULSES; current_index++) {
     582:	9f 5f       	subi	r25, 0xFF	; 255
     584:	9a 30       	cpi	r25, 0x0A	; 10
     586:	b1 f7       	brne	.-20     	; 0x574 <find_newest_pulse+0x10>
			return_index = current_index;
			max = pulse_queue[current_index];
		}
	}
	return return_index;
}
     588:	08 95       	ret

0000058a <tinyAxon_stop_sending_pulse>:
	tinyLED_set_color_mode(OUT_LED, WHITE, FLASH_ONCE);
}

void tinyAxon_stop_sending_pulse()
{
	DAC_0_set_output(NO_SIGNAL_OUTPUT);
     58a:	80 e0       	ldi	r24, 0x00	; 0
     58c:	90 e0       	ldi	r25, 0x00	; 0
     58e:	0e 94 80 01 	call	0x300	; 0x300 <DAC_0_set_output>
	axonOutputValue=NO_SIGNAL_OUTPUT;
     592:	10 92 16 38 	sts	0x3816, r1	; 0x803816 <__data_end>
     596:	08 95       	ret

00000598 <tinyAxon_remove_pulse>:

/*
If the potential is very low, we want to try to remove a pulse.
*/
bool tinyAxon_remove_pulse(void)
{
     598:	cf 93       	push	r28
	// We want to return a bool indicating whether or not a pulse actually was removed.
	if(pulses_in_queue == 0){
     59a:	c0 91 2b 38 	lds	r28, 0x382B	; 0x80382b <pulses_in_queue>
     59e:	cc 23       	and	r28, r28
     5a0:	c9 f0       	breq	.+50     	; 0x5d4 <tinyAxon_remove_pulse+0x3c>
		//There was no pulse to remove.
		return false;
	}
	else{
		// If we are to remove a pulse, we want to remove the one that will fire last.
		uint8_t pulse_index = find_newest_pulse();
     5a2:	0e 94 b2 02 	call	0x564	; 0x564 <find_newest_pulse>
		uint16_t newest_pulse = pulse_queue[pulse_index];
     5a6:	90 e0       	ldi	r25, 0x00	; 0
     5a8:	fc 01       	movw	r30, r24
     5aa:	ee 0f       	add	r30, r30
     5ac:	ff 1f       	adc	r31, r31
     5ae:	e9 5e       	subi	r30, 0xE9	; 233
     5b0:	f7 4c       	sbci	r31, 0xC7	; 199
	
		// Now we want to check if the pulse is too far away to be affected by the low potential, or close enough that we decide to remove it.
		// (When we say that the pulse is too far away, it refers to the biological process of how the potential spreads from Dendrites to axon).
		if(newest_pulse > PULSE_NO_RETURN_TIME){
     5b2:	20 81       	ld	r18, Z
     5b4:	31 81       	ldd	r19, Z+1	; 0x01
     5b6:	2d 33       	cpi	r18, 0x3D	; 61
     5b8:	31 05       	cpc	r19, r1
     5ba:	70 f0       	brcs	.+28     	; 0x5d8 <tinyAxon_remove_pulse+0x40>
			// We decided to remove the pulse
			pulse_queue[pulse_index] = 0;
     5bc:	88 0f       	add	r24, r24
     5be:	99 1f       	adc	r25, r25
     5c0:	fc 01       	movw	r30, r24
     5c2:	e9 5e       	subi	r30, 0xE9	; 233
     5c4:	f7 4c       	sbci	r31, 0xC7	; 199
     5c6:	10 82       	st	Z, r1
     5c8:	11 82       	std	Z+1, r1	; 0x01
			pulses_in_queue--;
     5ca:	c1 50       	subi	r28, 0x01	; 1
     5cc:	c0 93 2b 38 	sts	0x382B, r28	; 0x80382b <pulses_in_queue>
			return true;
     5d0:	81 e0       	ldi	r24, 0x01	; 1
     5d2:	03 c0       	rjmp	.+6      	; 0x5da <tinyAxon_remove_pulse+0x42>
bool tinyAxon_remove_pulse(void)
{
	// We want to return a bool indicating whether or not a pulse actually was removed.
	if(pulses_in_queue == 0){
		//There was no pulse to remove.
		return false;
     5d4:	80 e0       	ldi	r24, 0x00	; 0
     5d6:	01 c0       	rjmp	.+2      	; 0x5da <tinyAxon_remove_pulse+0x42>
			pulses_in_queue--;
			return true;
		}
		// Here we have found that there is a pulse queued, but it is old enough to let pass anyway, so now we need to put it back into the queue.
		else{
			return false;
     5d8:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     5da:	cf 91       	pop	r28
     5dc:	08 95       	ret

000005de <tinyAxon_update_potential>:
/*
Decides whether or not the axon should fire
If the axon does fire, the potential is reduced
*/
double tinyAxon_update_potential(double potential)
{	
     5de:	cf 92       	push	r12
     5e0:	df 92       	push	r13
     5e2:	ef 92       	push	r14
     5e4:	ff 92       	push	r15
     5e6:	6b 01       	movw	r12, r22
     5e8:	7c 01       	movw	r14, r24
	//While the neuron has enough potential to fire, we want to fire more
	while (potential > THRESHOLD_POTENTIAL)
     5ea:	20 e0       	ldi	r18, 0x00	; 0
     5ec:	30 e0       	ldi	r19, 0x00	; 0
     5ee:	48 ec       	ldi	r20, 0xC8	; 200
     5f0:	51 e4       	ldi	r21, 0x41	; 65
     5f2:	0e 94 1b 0b 	call	0x1636	; 0x1636 <__gesf2>
     5f6:	18 16       	cp	r1, r24
     5f8:	bc f5       	brge	.+110    	; 0x668 <tinyAxon_update_potential+0x8a>
	{
		// We have to check if there are already queued pulses, so that the frequency never exceeds FIRE_DELAY
		if(pulses_in_queue>0){
     5fa:	80 91 2b 38 	lds	r24, 0x382B	; 0x80382b <pulses_in_queue>
     5fe:	88 23       	and	r24, r24
     600:	b1 f0       	breq	.+44     	; 0x62e <tinyAxon_update_potential+0x50>
			uint16_t newest_pulse = pulse_queue[find_newest_pulse()];
     602:	0e 94 b2 02 	call	0x564	; 0x564 <find_newest_pulse>
     606:	e8 2f       	mov	r30, r24
     608:	f0 e0       	ldi	r31, 0x00	; 0
     60a:	ee 0f       	add	r30, r30
     60c:	ff 1f       	adc	r31, r31
     60e:	e9 5e       	subi	r30, 0xE9	; 233
     610:	f7 4c       	sbci	r31, 0xC7	; 199
			
			// There is at least one pulse in the queue, and it is so close, that we need to offset the new pulse, so that we keep at least
			// one FIRE_DELAY between each pulse
			if(newest_pulse + FIRE_DELAY > TRAVLE_DELAY){
     612:	80 81       	ld	r24, Z
     614:	91 81       	ldd	r25, Z+1	; 0x01
     616:	c2 96       	adiw	r24, 0x32	; 50
     618:	85 36       	cpi	r24, 0x65	; 101
     61a:	91 05       	cpc	r25, r1
     61c:	18 f0       	brcs	.+6      	; 0x624 <tinyAxon_update_potential+0x46>
				tinyAxon_add_pulse(newest_pulse + FIRE_DELAY);
     61e:	0e 94 8d 02 	call	0x51a	; 0x51a <tinyAxon_add_pulse>
     622:	09 c0       	rjmp	.+18     	; 0x636 <tinyAxon_update_potential+0x58>
			}
			// There is at least one pulse in the queue, but it's far enough away to ignore
			else{
				tinyAxon_add_pulse(TRAVLE_DELAY);
     624:	84 e6       	ldi	r24, 0x64	; 100
     626:	90 e0       	ldi	r25, 0x00	; 0
     628:	0e 94 8d 02 	call	0x51a	; 0x51a <tinyAxon_add_pulse>
     62c:	04 c0       	rjmp	.+8      	; 0x636 <tinyAxon_update_potential+0x58>
			}
		}
		// There are no pulses in the queue, so we add a pulse as normal
		else{
			tinyAxon_add_pulse(TRAVLE_DELAY);		
     62e:	84 e6       	ldi	r24, 0x64	; 100
     630:	90 e0       	ldi	r25, 0x00	; 0
     632:	0e 94 8d 02 	call	0x51a	; 0x51a <tinyAxon_add_pulse>
		}
		
		potential += POSTFIRE_POTENTIAL_REACTION; // This is usually defined as a negative value, don't be confused by the +=
     636:	20 e0       	ldi	r18, 0x00	; 0
     638:	30 e0       	ldi	r19, 0x00	; 0
     63a:	40 ef       	ldi	r20, 0xF0	; 240
     63c:	51 e4       	ldi	r21, 0x41	; 65
     63e:	c7 01       	movw	r24, r14
     640:	b6 01       	movw	r22, r12
     642:	0e 94 d6 08 	call	0x11ac	; 0x11ac <__subsf3>
     646:	6b 01       	movw	r12, r22
     648:	7c 01       	movw	r14, r24
		
		tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
     64a:	44 e0       	ldi	r20, 0x04	; 4
     64c:	63 e0       	ldi	r22, 0x03	; 3
     64e:	81 e0       	ldi	r24, 0x01	; 1
     650:	0e 94 d1 05 	call	0xba2	; 0xba2 <tinyLED_set_color_mode>
If the axon does fire, the potential is reduced
*/
double tinyAxon_update_potential(double potential)
{	
	//While the neuron has enough potential to fire, we want to fire more
	while (potential > THRESHOLD_POTENTIAL)
     654:	20 e0       	ldi	r18, 0x00	; 0
     656:	30 e0       	ldi	r19, 0x00	; 0
     658:	48 ec       	ldi	r20, 0xC8	; 200
     65a:	51 e4       	ldi	r21, 0x41	; 65
     65c:	c7 01       	movw	r24, r14
     65e:	b6 01       	movw	r22, r12
     660:	0e 94 1b 0b 	call	0x1636	; 0x1636 <__gesf2>
     664:	18 16       	cp	r1, r24
     666:	4c f2       	brlt	.-110    	; 0x5fa <tinyAxon_update_potential+0x1c>
		
		tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
	}
	
	// If the neuron has a very low potential, we want to remove a pulse from the queue (if there is one)
	if(potential < -THRESHOLD_POTENTIAL && pulses_in_queue > 0) // Perhaps this should be a separate variable? For now, we will just simply use -THRESHOLD_POTENTIAL
     668:	20 e0       	ldi	r18, 0x00	; 0
     66a:	30 e0       	ldi	r19, 0x00	; 0
     66c:	48 ec       	ldi	r20, 0xC8	; 200
     66e:	51 ec       	ldi	r21, 0xC1	; 193
     670:	c7 01       	movw	r24, r14
     672:	b6 01       	movw	r22, r12
     674:	0e 94 43 09 	call	0x1286	; 0x1286 <__cmpsf2>
     678:	88 23       	and	r24, r24
     67a:	0c f0       	brlt	.+2      	; 0x67e <tinyAxon_update_potential+0xa0>
     67c:	46 c0       	rjmp	.+140    	; 0x70a <tinyAxon_update_potential+0x12c>
     67e:	80 91 2b 38 	lds	r24, 0x382B	; 0x80382b <pulses_in_queue>
     682:	88 23       	and	r24, r24
     684:	11 f1       	breq	.+68     	; 0x6ca <tinyAxon_update_potential+0xec>
	{
		// The neurons potential is low enough to attempt to remove a queued fire (Fire less)
		if(tinyAxon_remove_pulse())
     686:	0e 94 cc 02 	call	0x598	; 0x598 <tinyAxon_remove_pulse>
     68a:	88 23       	and	r24, r24
     68c:	f1 f1       	breq	.+124    	; 0x70a <tinyAxon_update_potential+0x12c>
		{
			// The potential has evened out a bit
			potential += THRESHOLD_POTENTIAL;
     68e:	20 e0       	ldi	r18, 0x00	; 0
     690:	30 e0       	ldi	r19, 0x00	; 0
     692:	48 ec       	ldi	r20, 0xC8	; 200
     694:	51 e4       	ldi	r21, 0x41	; 65
     696:	c7 01       	movw	r24, r14
     698:	b6 01       	movw	r22, r12
     69a:	0e 94 d7 08 	call	0x11ae	; 0x11ae <__addsf3>
     69e:	6b 01       	movw	r12, r22
     6a0:	7c 01       	movw	r14, r24
     6a2:	33 c0       	rjmp	.+102    	; 0x70a <tinyAxon_update_potential+0x12c>
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
	{
		for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
		{
			if(pulse_queue[i] != 0){
     6a4:	80 81       	ld	r24, Z
     6a6:	91 81       	ldd	r25, Z+1	; 0x01
     6a8:	00 97       	sbiw	r24, 0x00	; 0
     6aa:	39 f0       	breq	.+14     	; 0x6ba <tinyAxon_update_potential+0xdc>
				pulse_queue[i]--;
     6ac:	01 97       	sbiw	r24, 0x01	; 1
     6ae:	80 83       	st	Z, r24
     6b0:	91 83       	std	Z+1, r25	; 0x01
				
				// If the time went from 1 to 0, we fire the axon
				if(pulse_queue[i] == 0){
     6b2:	89 2b       	or	r24, r25
     6b4:	11 f4       	brne	.+4      	; 0x6ba <tinyAxon_update_potential+0xdc>
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
	pulses_in_queue--;
     6b6:	41 50       	subi	r20, 0x01	; 1
Function to set firing.
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
     6b8:	51 e0       	ldi	r21, 0x01	; 1
     6ba:	32 96       	adiw	r30, 0x02	; 2
	}
	
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
	{
		for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
     6bc:	e2 17       	cp	r30, r18
     6be:	f3 07       	cpc	r31, r19
     6c0:	89 f7       	brne	.-30     	; 0x6a4 <tinyAxon_update_potential+0xc6>
     6c2:	50 93 2c 38 	sts	0x382C, r21	; 0x80382c <tinyAxon_should_fire>
     6c6:	40 93 2b 38 	sts	0x382B, r20	; 0x80382b <pulses_in_queue>
The function should set the DAC to fire for two
update cycles once the pulse flag is set high.
*/
static void tinyAxon_update_pulse_transmitter(void)
{
	if (tinyAxon_should_fire)
     6ca:	80 91 2c 38 	lds	r24, 0x382C	; 0x80382c <tinyAxon_should_fire>
     6ce:	88 23       	and	r24, r24
     6d0:	91 f0       	breq	.+36     	; 0x6f6 <tinyAxon_update_potential+0x118>
	{
		tinyAxon_should_fire = false;
     6d2:	10 92 2c 38 	sts	0x382C, r1	; 0x80382c <tinyAxon_should_fire>
		tinyAxon_has_fired = true;
     6d6:	81 e0       	ldi	r24, 0x01	; 1
     6d8:	80 93 2d 38 	sts	0x382D, r24	; 0x80382d <tinyAxon_has_fired>
*/
static void tinyAxon_start_sending_pulse()
{
	if (NEURONTYPE == EXCITATORY_NEURON)
	{
		DAC_0_set_output(EXCITATORY_NEURON_OUTPUT);
     6dc:	88 ec       	ldi	r24, 0xC8	; 200
     6de:	90 e0       	ldi	r25, 0x00	; 0
     6e0:	0e 94 80 01 	call	0x300	; 0x300 <DAC_0_set_output>
		axonOutputValue=EXCITATORY_NEURON_OUTPUT;
     6e4:	88 ec       	ldi	r24, 0xC8	; 200
     6e6:	80 93 16 38 	sts	0x3816, r24	; 0x803816 <__data_end>
	{
		DAC_0_set_output(INHIBITORY_NEURON_OUTPUT);
		axonOutputValue=INHIBITORY_NEURON_OUTPUT;
	}
	
	tinyLED_set_color_mode(OUT_LED, WHITE, FLASH_ONCE);
     6ea:	44 e0       	ldi	r20, 0x04	; 4
     6ec:	64 e0       	ldi	r22, 0x04	; 4
     6ee:	80 e0       	ldi	r24, 0x00	; 0
     6f0:	0e 94 d1 05 	call	0xba2	; 0xba2 <tinyLED_set_color_mode>
     6f4:	15 c0       	rjmp	.+42     	; 0x720 <tinyAxon_update_potential+0x142>
		tinyAxon_should_fire = false;
		tinyAxon_has_fired = true;
		
		tinyAxon_start_sending_pulse();
	}
	else if (tinyAxon_has_fired)
     6f6:	80 91 2d 38 	lds	r24, 0x382D	; 0x80382d <tinyAxon_has_fired>
     6fa:	88 23       	and	r24, r24
     6fc:	19 f0       	breq	.+6      	; 0x704 <tinyAxon_update_potential+0x126>
	{
		tinyAxon_has_fired = false;
     6fe:	10 92 2d 38 	sts	0x382D, r1	; 0x80382d <tinyAxon_has_fired>
     702:	0e c0       	rjmp	.+28     	; 0x720 <tinyAxon_update_potential+0x142>
	}
	else if (!tinyAxon_has_fired && !tinyAxon_should_fire)
	{
		tinyAxon_stop_sending_pulse();
     704:	0e 94 c5 02 	call	0x58a	; 0x58a <tinyAxon_stop_sending_pulse>
     708:	0b c0       	rjmp	.+22     	; 0x720 <tinyAxon_update_potential+0x142>
			potential += THRESHOLD_POTENTIAL;
		}
	}
	
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
     70a:	40 91 2b 38 	lds	r20, 0x382B	; 0x80382b <pulses_in_queue>
     70e:	44 23       	and	r20, r20
     710:	e1 f2       	breq	.-72     	; 0x6ca <tinyAxon_update_potential+0xec>
     712:	50 91 2c 38 	lds	r21, 0x382C	; 0x80382c <tinyAxon_should_fire>
     716:	e7 e1       	ldi	r30, 0x17	; 23
     718:	f8 e3       	ldi	r31, 0x38	; 56
     71a:	2b e2       	ldi	r18, 0x2B	; 43
     71c:	38 e3       	ldi	r19, 0x38	; 56
     71e:	c2 cf       	rjmp	.-124    	; 0x6a4 <tinyAxon_update_potential+0xc6>
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTB_get_pin_level(const uint8_t pin)
{
	return VPORTB.IN & (1 << pin);
     720:	86 b1       	in	r24, 0x06	; 6
	// We need to check if the axon is connected to a charger. We do this by checking the AXON_CHECK_PIN. If it is hight while the axon is not firing, it must be connected to a charger
	if(AXON_CHECK_PIN_get_level() && !tinyAxon_should_fire){
		//tinyCharge_set_charging_mode(true);
	}
	
	tinyDebugger_send_uint8("Axon", axonOutputValue);
     722:	60 91 16 38 	lds	r22, 0x3816	; 0x803816 <__data_end>
     726:	89 ed       	ldi	r24, 0xD9	; 217
     728:	93 ea       	ldi	r25, 0xA3	; 163
     72a:	0e 94 4b 04 	call	0x896	; 0x896 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("Pulses", pulses_in_queue);
     72e:	60 91 2b 38 	lds	r22, 0x382B	; 0x80382b <pulses_in_queue>
     732:	8e ed       	ldi	r24, 0xDE	; 222
     734:	93 ea       	ldi	r25, 0xA3	; 163
     736:	0e 94 4b 04 	call	0x896	; 0x896 <tinyDebugger_send_uint8>
	
	return potential;
}
     73a:	c7 01       	movw	r24, r14
     73c:	b6 01       	movw	r22, r12
     73e:	ff 90       	pop	r15
     740:	ef 90       	pop	r14
     742:	df 90       	pop	r13
     744:	cf 90       	pop	r12
     746:	08 95       	ret

00000748 <tinyButton_update>:
/*
If the button has been let go, we change button_press to true. This only lasts one cycle, before it is set to false again.
If the button is held down for longer than PULSEMODE_BUTTON_PRESS_TIME, we toggle the pulse mode state.
*/
void tinyButton_update(void)
{
     748:	0f 93       	push	r16
     74a:	1f 93       	push	r17
     74c:	cf 93       	push	r28
     74e:	df 93       	push	r29
	button_press = false;
     750:	10 92 32 38 	sts	0x3832, r1	; 0x803832 <button_press>
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTC_get_pin_level(const uint8_t pin)
{
	return VPORTC.IN & (1 << pin);
     754:	8a b1       	in	r24, 0x0a	; 10
	_Bool button_is_pushed_down = !BUTTON_PIN_get_level(); // The digital port will be read as low if the button is pushed down.
     756:	d1 e0       	ldi	r29, 0x01	; 1
     758:	c8 2f       	mov	r28, r24
     75a:	c4 70       	andi	r28, 0x04	; 4
     75c:	82 fd       	sbrc	r24, 2
     75e:	d0 e0       	ldi	r29, 0x00	; 0

	if (button_is_pushed_down && !button_was_pushed_down)
     760:	c1 11       	cpse	r28, r1
     762:	36 c0       	rjmp	.+108    	; 0x7d0 <tinyButton_update+0x88>
     764:	80 91 33 38 	lds	r24, 0x3833	; 0x803833 <button_was_pushed_down>
     768:	81 11       	cpse	r24, r1
     76a:	0e c0       	rjmp	.+28     	; 0x788 <tinyButton_update+0x40>
	{
		tinyButton_start_time = tinyTime_now();
     76c:	0e 94 cd 08 	call	0x119a	; 0x119a <tinyTime_now>
     770:	60 93 2e 38 	sts	0x382E, r22	; 0x80382e <tinyButton_start_time>
     774:	70 93 2f 38 	sts	0x382F, r23	; 0x80382f <tinyButton_start_time+0x1>
     778:	80 93 30 38 	sts	0x3830, r24	; 0x803830 <tinyButton_start_time+0x2>
     77c:	90 93 31 38 	sts	0x3831, r25	; 0x803831 <tinyButton_start_time+0x3>
	}
	if (button_is_pushed_down && button_was_pushed_down)
     780:	80 91 33 38 	lds	r24, 0x3833	; 0x803833 <button_was_pushed_down>
     784:	88 23       	and	r24, r24
     786:	69 f1       	breq	.+90     	; 0x7e2 <tinyButton_update+0x9a>
	{
		if ((tinyTime_now() - tinyButton_start_time) > PULSEMODE_BUTTON_PRESS_TIME)
     788:	0e 94 cd 08 	call	0x119a	; 0x119a <tinyTime_now>
     78c:	00 91 2e 38 	lds	r16, 0x382E	; 0x80382e <tinyButton_start_time>
     790:	10 91 2f 38 	lds	r17, 0x382F	; 0x80382f <tinyButton_start_time+0x1>
     794:	20 91 30 38 	lds	r18, 0x3830	; 0x803830 <tinyButton_start_time+0x2>
     798:	30 91 31 38 	lds	r19, 0x3831	; 0x803831 <tinyButton_start_time+0x3>
     79c:	60 1b       	sub	r22, r16
     79e:	71 0b       	sbc	r23, r17
     7a0:	82 0b       	sbc	r24, r18
     7a2:	93 0b       	sbc	r25, r19
     7a4:	0e 94 23 0a 	call	0x1446	; 0x1446 <__floatunsisf>
     7a8:	20 e0       	ldi	r18, 0x00	; 0
     7aa:	30 e0       	ldi	r19, 0x00	; 0
     7ac:	48 ec       	ldi	r20, 0xC8	; 200
     7ae:	52 e4       	ldi	r21, 0x42	; 66
     7b0:	0e 94 1b 0b 	call	0x1636	; 0x1636 <__gesf2>
     7b4:	18 16       	cp	r1, r24
     7b6:	64 f4       	brge	.+24     	; 0x7d0 <tinyButton_update+0x88>
		{
			tinyPulse_toggle_pulse_mode();
     7b8:	0e 94 7a 08 	call	0x10f4	; 0x10f4 <tinyPulse_toggle_pulse_mode>
			tinyButton_start_time = tinyTime_now();
     7bc:	0e 94 cd 08 	call	0x119a	; 0x119a <tinyTime_now>
     7c0:	60 93 2e 38 	sts	0x382E, r22	; 0x80382e <tinyButton_start_time>
     7c4:	70 93 2f 38 	sts	0x382F, r23	; 0x80382f <tinyButton_start_time+0x1>
     7c8:	80 93 30 38 	sts	0x3830, r24	; 0x803830 <tinyButton_start_time+0x2>
     7cc:	90 93 31 38 	sts	0x3831, r25	; 0x803831 <tinyButton_start_time+0x3>
		}
	}
	if (!button_is_pushed_down && button_was_pushed_down)
     7d0:	cc 23       	and	r28, r28
     7d2:	39 f0       	breq	.+14     	; 0x7e2 <tinyButton_update+0x9a>
     7d4:	80 91 33 38 	lds	r24, 0x3833	; 0x803833 <button_was_pushed_down>
     7d8:	88 23       	and	r24, r24
     7da:	19 f0       	breq	.+6      	; 0x7e2 <tinyButton_update+0x9a>
	{
		button_press = true;
     7dc:	81 e0       	ldi	r24, 0x01	; 1
     7de:	80 93 32 38 	sts	0x3832, r24	; 0x803832 <button_press>
	}
	button_was_pushed_down = button_is_pushed_down;
     7e2:	d0 93 33 38 	sts	0x3833, r29	; 0x803833 <button_was_pushed_down>
}
     7e6:	df 91       	pop	r29
     7e8:	cf 91       	pop	r28
     7ea:	1f 91       	pop	r17
     7ec:	0f 91       	pop	r16
     7ee:	08 95       	ret

000007f0 <tinyButton_update_potential>:

double tinyButton_update_potential(double potential){
	if(button_press){
     7f0:	20 91 32 38 	lds	r18, 0x3832	; 0x803832 <button_press>
     7f4:	22 23       	and	r18, r18
     7f6:	31 f0       	breq	.+12     	; 0x804 <tinyButton_update_potential+0x14>
		potential += BUTTON_PRESS_REACTION;
     7f8:	20 e0       	ldi	r18, 0x00	; 0
     7fa:	30 e0       	ldi	r19, 0x00	; 0
     7fc:	40 ed       	ldi	r20, 0xD0	; 208
     7fe:	51 e4       	ldi	r21, 0x41	; 65
     800:	0e 94 d7 08 	call	0x11ae	; 0x11ae <__addsf3>
	}
	return potential;
}
     804:	08 95       	ret

00000806 <tinyCharge_is_connected_to_charger>:

_Bool connected_to_charger;

_Bool tinyCharge_is_connected_to_charger(){
	return connected_to_charger;
}
     806:	80 91 58 38 	lds	r24, 0x3858	; 0x803858 <connected_to_charger>
     80a:	08 95       	ret

0000080c <tinyCharge_is_fully_charged>:
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTB_get_pin_level(const uint8_t pin)
{
	return VPORTB.IN & (1 << pin);
     80c:	86 b1       	in	r24, 0x06	; 6

_Bool tinyCharge_is_fully_charged(){
	return CHARGING_STATUS_PIN_get_level();
}
     80e:	86 fb       	bst	r24, 6
     810:	88 27       	eor	r24, r24
     812:	80 f9       	bld	r24, 0
     814:	08 95       	ret

00000816 <tinyCharge_switch_mode>:
	}
}

void tinyCharge_switch_mode(){
	
	if(connected_to_charger){
     816:	80 91 58 38 	lds	r24, 0x3858	; 0x803858 <connected_to_charger>
     81a:	88 23       	and	r24, r24
     81c:	61 f0       	breq	.+24     	; 0x836 <tinyCharge_switch_mode+0x20>
		// Switch from main to charging mode
		
		// Set LED
		tinyLED_set_color(OUT_LED, OFF);
     81e:	60 e0       	ldi	r22, 0x00	; 0
     820:	80 e0       	ldi	r24, 0x00	; 0
     822:	0e 94 c0 05 	call	0xb80	; 0xb80 <tinyLED_set_color>
		tinyLED_set_color_mode(INN_LED, CHARGING_COLOR, SWING);
     826:	42 e0       	ldi	r20, 0x02	; 2
     828:	61 e0       	ldi	r22, 0x01	; 1
     82a:	81 e0       	ldi	r24, 0x01	; 1
     82c:	0e 94 d1 05 	call	0xba2	; 0xba2 <tinyLED_set_color_mode>
		
		// Stop axon from firing
		// (There is a small chance that the neuron is put into charging mode as it is firing. The axon is then never told to stop firing)
		tinyAxon_stop_sending_pulse();
     830:	0e 94 c5 02 	call	0x58a	; 0x58a <tinyAxon_stop_sending_pulse>
     834:	08 95       	ret
	}
	else{
		// Switch from charge to main mode
		
		// Set LED
		tinyLED_set_color(OUT_LED, OFF);
     836:	60 e0       	ldi	r22, 0x00	; 0
     838:	80 e0       	ldi	r24, 0x00	; 0
     83a:	0e 94 c0 05 	call	0xb80	; 0xb80 <tinyLED_set_color>
		tinyLED_set_color(INN_LED, OFF);
     83e:	60 e0       	ldi	r22, 0x00	; 0
     840:	81 e0       	ldi	r24, 0x01	; 1
     842:	0e 94 c0 05 	call	0xb80	; 0xb80 <tinyLED_set_color>
     846:	08 95       	ret

00000848 <tinyCharge_set_charging_mode>:
_Bool tinyCharge_is_fully_charged(){
	return CHARGING_STATUS_PIN_get_level();
}

void tinyCharge_set_charging_mode(_Bool charging_status){
	if(charging_status != connected_to_charger){
     848:	90 91 58 38 	lds	r25, 0x3858	; 0x803858 <connected_to_charger>
     84c:	98 17       	cp	r25, r24
     84e:	21 f0       	breq	.+8      	; 0x858 <tinyCharge_set_charging_mode+0x10>
		connected_to_charger = charging_status;
     850:	80 93 58 38 	sts	0x3858, r24	; 0x803858 <connected_to_charger>
		tinyCharge_switch_mode();
     854:	0e 94 0b 04 	call	0x816	; 0x816 <tinyCharge_switch_mode>
     858:	08 95       	ret

0000085a <tinyCharge_set_transistors>:
	}
}


void tinyCharge_set_transistors(){
	if(connected_to_charger){
     85a:	80 91 58 38 	lds	r24, 0x3858	; 0x803858 <connected_to_charger>
     85e:	88 23       	and	r24, r24
     860:	11 f0       	breq	.+4      	; 0x866 <tinyCharge_set_transistors+0xc>
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
	} else {
		VPORTC.OUT &= ~(1 << pin);
     862:	4d 98       	cbi	0x09, 5	; 9
     864:	08 95       	ret
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     866:	4d 9a       	sbi	0x09, 5	; 9
     868:	08 95       	ret

0000086a <tinyDebugger_send_uint32>:
		printf("%s:%5s\t", name, number);
	}
}
void tinyDebugger_send_string(const char* name, char * value){
	if(DEBUGGING && tinyDebugger_send_message){
		printf("%s:%s\t", name, value);
     86a:	20 91 0e 38 	lds	r18, 0x380E	; 0x80380e <tinyDebugger_send_message>
     86e:	22 23       	and	r18, r18
     870:	89 f0       	breq	.+34     	; 0x894 <tinyDebugger_send_uint32+0x2a>
     872:	7f 93       	push	r23
     874:	6f 93       	push	r22
     876:	5f 93       	push	r21
     878:	4f 93       	push	r20
     87a:	9f 93       	push	r25
     87c:	8f 93       	push	r24
     87e:	8d ee       	ldi	r24, 0xED	; 237
     880:	93 ea       	ldi	r25, 0xA3	; 163
     882:	9f 93       	push	r25
     884:	8f 93       	push	r24
     886:	0e 94 ae 0c 	call	0x195c	; 0x195c <printf>
     88a:	8d b7       	in	r24, 0x3d	; 61
     88c:	9e b7       	in	r25, 0x3e	; 62
     88e:	08 96       	adiw	r24, 0x08	; 8
     890:	8d bf       	out	0x3d, r24	; 61
     892:	9e bf       	out	0x3e, r25	; 62
     894:	08 95       	ret

00000896 <tinyDebugger_send_uint8>:
     896:	20 91 0e 38 	lds	r18, 0x380E	; 0x80380e <tinyDebugger_send_message>
     89a:	22 23       	and	r18, r18
     89c:	81 f0       	breq	.+32     	; 0x8be <tinyDebugger_send_uint8+0x28>
     89e:	1f 92       	push	r1
     8a0:	6f 93       	push	r22
     8a2:	9f 93       	push	r25
     8a4:	8f 93       	push	r24
     8a6:	86 ef       	ldi	r24, 0xF6	; 246
     8a8:	93 ea       	ldi	r25, 0xA3	; 163
     8aa:	9f 93       	push	r25
     8ac:	8f 93       	push	r24
     8ae:	0e 94 ae 0c 	call	0x195c	; 0x195c <printf>
     8b2:	0f 90       	pop	r0
     8b4:	0f 90       	pop	r0
     8b6:	0f 90       	pop	r0
     8b8:	0f 90       	pop	r0
     8ba:	0f 90       	pop	r0
     8bc:	0f 90       	pop	r0
     8be:	08 95       	ret

000008c0 <tinyDebugger_send_double>:
     8c0:	cf 92       	push	r12
     8c2:	df 92       	push	r13
     8c4:	ef 92       	push	r14
     8c6:	ff 92       	push	r15
     8c8:	0f 93       	push	r16
     8ca:	1f 93       	push	r17
     8cc:	cf 93       	push	r28
     8ce:	df 93       	push	r29
     8d0:	cd b7       	in	r28, 0x3d	; 61
     8d2:	de b7       	in	r29, 0x3e	; 62
     8d4:	64 97       	sbiw	r28, 0x14	; 20
     8d6:	cd bf       	out	0x3d, r28	; 61
     8d8:	de bf       	out	0x3e, r29	; 62
     8da:	38 2f       	mov	r19, r24
     8dc:	e9 2f       	mov	r30, r25
     8de:	20 91 0e 38 	lds	r18, 0x380E	; 0x80380e <tinyDebugger_send_message>
     8e2:	22 23       	and	r18, r18
     8e4:	e9 f0       	breq	.+58     	; 0x920 <tinyDebugger_send_double+0x60>
     8e6:	cb 01       	movw	r24, r22
     8e8:	ba 01       	movw	r22, r20
     8ea:	ee 2e       	mov	r14, r30
     8ec:	f3 2e       	mov	r15, r19
     8ee:	9e 01       	movw	r18, r28
     8f0:	2f 5f       	subi	r18, 0xFF	; 255
     8f2:	3f 4f       	sbci	r19, 0xFF	; 255
     8f4:	69 01       	movw	r12, r18
     8f6:	89 01       	movw	r16, r18
     8f8:	21 e0       	ldi	r18, 0x01	; 1
     8fa:	41 e0       	ldi	r20, 0x01	; 1
     8fc:	0e 94 8e 0c 	call	0x191c	; 0x191c <dtostrf>
     900:	df 92       	push	r13
     902:	cf 92       	push	r12
     904:	ef 92       	push	r14
     906:	ff 92       	push	r15
     908:	8e ef       	ldi	r24, 0xFE	; 254
     90a:	93 ea       	ldi	r25, 0xA3	; 163
     90c:	9f 93       	push	r25
     90e:	8f 93       	push	r24
     910:	0e 94 ae 0c 	call	0x195c	; 0x195c <printf>
     914:	0f 90       	pop	r0
     916:	0f 90       	pop	r0
     918:	0f 90       	pop	r0
     91a:	0f 90       	pop	r0
     91c:	0f 90       	pop	r0
     91e:	0f 90       	pop	r0
     920:	64 96       	adiw	r28, 0x14	; 20
     922:	cd bf       	out	0x3d, r28	; 61
     924:	de bf       	out	0x3e, r29	; 62
     926:	df 91       	pop	r29
     928:	cf 91       	pop	r28
     92a:	1f 91       	pop	r17
     92c:	0f 91       	pop	r16
     92e:	ff 90       	pop	r15
     930:	ef 90       	pop	r14
     932:	df 90       	pop	r13
     934:	cf 90       	pop	r12
     936:	08 95       	ret

00000938 <tinyDebugger_end_line>:
	}
}
void tinyDebugger_end_line(){
	if(DEBUGGING && tinyDebugger_send_message){
     938:	80 91 0e 38 	lds	r24, 0x380E	; 0x80380e <tinyDebugger_send_message>
     93c:	88 23       	and	r24, r24
     93e:	21 f0       	breq	.+8      	; 0x948 <tinyDebugger_end_line+0x10>
		printf("\r\n");
     940:	8d e0       	ldi	r24, 0x0D	; 13
     942:	94 ea       	ldi	r25, 0xA4	; 164
     944:	0e 94 c4 0c 	call	0x1988	; 0x1988 <puts>
	}
	tinyDebugger_print_attempts++;
     948:	80 91 34 38 	lds	r24, 0x3834	; 0x803834 <tinyDebugger_print_attempts>
     94c:	8f 5f       	subi	r24, 0xFF	; 255
     94e:	80 93 34 38 	sts	0x3834, r24	; 0x803834 <tinyDebugger_print_attempts>
	tinyDebugger_send_message = tinyDebugger_print_attempts%DEBUG_EVERY == 0;
     952:	81 e0       	ldi	r24, 0x01	; 1
     954:	80 93 0e 38 	sts	0x380E, r24	; 0x80380e <tinyDebugger_send_message>
     958:	08 95       	ret

0000095a <tinyDendrite_update_signals>:
/*
This function converts the 8 bit value from the ADC into one of the signal types defined in DendriteSignal
We also update the charging state
*/
void tinyDendrite_update_signals(void)
{
     95a:	af 92       	push	r10
     95c:	bf 92       	push	r11
     95e:	cf 92       	push	r12
     960:	df 92       	push	r13
     962:	ef 92       	push	r14
     964:	ff 92       	push	r15
     966:	0f 93       	push	r16
     968:	1f 93       	push	r17
     96a:	cf 93       	push	r28
     96c:	df 93       	push	r29
     96e:	cf e0       	ldi	r28, 0x0F	; 15
     970:	d8 e3       	ldi	r29, 0x38	; 56
     972:	0f e3       	ldi	r16, 0x3F	; 63
     974:	18 e3       	ldi	r17, 0x38	; 56
     976:	0f 2e       	mov	r0, r31
     978:	f4 e1       	ldi	r31, 0x14	; 20
     97a:	cf 2e       	mov	r12, r31
     97c:	f8 e3       	ldi	r31, 0x38	; 56
     97e:	df 2e       	mov	r13, r31
     980:	f0 2d       	mov	r31, r0
     982:	78 01       	movw	r14, r16
*/
static void tinyDendrite_read_signals(void)
{
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_values[i] = ADC_0_get_conversion(Dendrite_ports[i]);
     984:	89 91       	ld	r24, Y+
     986:	0e 94 45 01 	call	0x28a	; 0x28a <ADC_0_get_conversion>
     98a:	d7 01       	movw	r26, r14
     98c:	8d 93       	st	X+, r24
     98e:	7d 01       	movw	r14, r26
/*
This function reads the voltage at the Dendrite inputs with the ADC
*/
static void tinyDendrite_read_signals(void)
{
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
     990:	cc 15       	cp	r28, r12
     992:	dd 05       	cpc	r29, r13
     994:	b9 f7       	brne	.-18     	; 0x984 <tinyDendrite_update_signals+0x2a>
	{
		tinyDendrite_values[i] = ADC_0_get_conversion(Dendrite_ports[i]);
	}
	tinyDebugger_send_uint8("D1", tinyDendrite_values[0]);
     996:	cf e3       	ldi	r28, 0x3F	; 63
     998:	d8 e3       	ldi	r29, 0x38	; 56
     99a:	68 81       	ld	r22, Y
     99c:	8f e0       	ldi	r24, 0x0F	; 15
     99e:	94 ea       	ldi	r25, 0xA4	; 164
     9a0:	0e 94 4b 04 	call	0x896	; 0x896 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D2", tinyDendrite_values[1]);
     9a4:	69 81       	ldd	r22, Y+1	; 0x01
     9a6:	82 e1       	ldi	r24, 0x12	; 18
     9a8:	94 ea       	ldi	r25, 0xA4	; 164
     9aa:	0e 94 4b 04 	call	0x896	; 0x896 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D3", tinyDendrite_values[2]);
     9ae:	6a 81       	ldd	r22, Y+2	; 0x02
     9b0:	85 e1       	ldi	r24, 0x15	; 21
     9b2:	94 ea       	ldi	r25, 0xA4	; 164
     9b4:	0e 94 4b 04 	call	0x896	; 0x896 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D4", tinyDendrite_values[3]);
     9b8:	6b 81       	ldd	r22, Y+3	; 0x03
     9ba:	88 e1       	ldi	r24, 0x18	; 24
     9bc:	94 ea       	ldi	r25, 0xA4	; 164
     9be:	0e 94 4b 04 	call	0x896	; 0x896 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D5", tinyDendrite_values[4]);
     9c2:	6c 81       	ldd	r22, Y+4	; 0x04
     9c4:	8b e1       	ldi	r24, 0x1B	; 27
     9c6:	94 ea       	ldi	r25, 0xA4	; 164
     9c8:	0e 94 4b 04 	call	0x896	; 0x896 <tinyDebugger_send_uint8>
     9cc:	ea e3       	ldi	r30, 0x3A	; 58
     9ce:	f8 e3       	ldi	r31, 0x38	; 56
     9d0:	c5 e3       	ldi	r28, 0x35	; 53
     9d2:	d8 e3       	ldi	r29, 0x38	; 56
     9d4:	4f e3       	ldi	r20, 0x3F	; 63
     9d6:	58 e3       	ldi	r21, 0x38	; 56
{
	
	//Read the analog voltage values on each of the Dendrites
	tinyDendrite_read_signals();
	
	_Bool charging = false;
     9d8:	80 e0       	ldi	r24, 0x00	; 0
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     9da:	31 e0       	ldi	r19, 0x01	; 1
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
		}
		else if (tinyDendrite_values[i] > HIGH_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
     9dc:	0f 2e       	mov	r0, r31
     9de:	f3 e0       	ldi	r31, 0x03	; 3
     9e0:	cf 2e       	mov	r12, r31
     9e2:	f0 2d       	mov	r31, r0
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     9e4:	68 94       	set
     9e6:	dd 24       	eor	r13, r13
     9e8:	d1 f8       	bld	r13, 1
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     9ea:	68 94       	set
     9ec:	ee 24       	eor	r14, r14
     9ee:	e2 f8       	bld	r14, 2
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     9f0:	0f 2e       	mov	r0, r31
     9f2:	f6 e0       	ldi	r31, 0x06	; 6
     9f4:	ff 2e       	mov	r15, r31
     9f6:	f0 2d       	mov	r31, r0
			tinyDendrite_current_signals[i] = CHARGING;
			charging = true;
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     9f8:	75 e0       	ldi	r23, 0x05	; 5
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = CHARGING;
     9fa:	67 e0       	ldi	r22, 0x07	; 7
     9fc:	5f 01       	movw	r10, r30
	
	_Bool charging = false;
	
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
     9fe:	90 81       	ld	r25, Z
     a00:	99 93       	st	Y+, r25
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
     a02:	d8 01       	movw	r26, r16
     a04:	2d 91       	ld	r18, X+
     a06:	8d 01       	movw	r16, r26
     a08:	29 3e       	cpi	r18, 0xE9	; 233
     a0a:	18 f0       	brcs	.+6      	; 0xa12 <tinyDendrite_update_signals+0xb8>
		{
			tinyDendrite_current_signals[i] = CHARGING;
     a0c:	60 83       	st	Z, r22
			charging = true;
     a0e:	83 2f       	mov	r24, r19
     a10:	19 c0       	rjmp	.+50     	; 0xa44 <tinyDendrite_update_signals+0xea>
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
     a12:	28 3c       	cpi	r18, 0xC8	; 200
     a14:	10 f0       	brcs	.+4      	; 0xa1a <tinyDendrite_update_signals+0xc0>
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     a16:	70 83       	st	Z, r23
     a18:	15 c0       	rjmp	.+42     	; 0xa44 <tinyDendrite_update_signals+0xea>
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
     a1a:	27 3a       	cpi	r18, 0xA7	; 167
     a1c:	10 f0       	brcs	.+4      	; 0xa22 <tinyDendrite_update_signals+0xc8>
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     a1e:	f0 82       	st	Z, r15
     a20:	11 c0       	rjmp	.+34     	; 0xa44 <tinyDendrite_update_signals+0xea>
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
     a22:	25 38       	cpi	r18, 0x85	; 133
     a24:	10 f0       	brcs	.+4      	; 0xa2a <tinyDendrite_update_signals+0xd0>
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     a26:	e0 82       	st	Z, r14
     a28:	0d c0       	rjmp	.+26     	; 0xa44 <tinyDendrite_update_signals+0xea>
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
     a2a:	24 36       	cpi	r18, 0x64	; 100
     a2c:	10 f0       	brcs	.+4      	; 0xa32 <tinyDendrite_update_signals+0xd8>
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     a2e:	d0 82       	st	Z, r13
     a30:	09 c0       	rjmp	.+18     	; 0xa44 <tinyDendrite_update_signals+0xea>
		}
		else if (tinyDendrite_values[i] > HIGH_INHIB_THRESHOLD)
     a32:	23 34       	cpi	r18, 0x43	; 67
     a34:	10 f0       	brcs	.+4      	; 0xa3a <tinyDendrite_update_signals+0xe0>
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
     a36:	c0 82       	st	Z, r12
     a38:	05 c0       	rjmp	.+10     	; 0xa44 <tinyDendrite_update_signals+0xea>
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
     a3a:	22 32       	cpi	r18, 0x22	; 34
     a3c:	10 f0       	brcs	.+4      	; 0xa42 <tinyDendrite_update_signals+0xe8>
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     a3e:	30 83       	st	Z, r19
     a40:	01 c0       	rjmp	.+2      	; 0xa44 <tinyDendrite_update_signals+0xea>
		}
		else
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     a42:	10 82       	st	Z, r1
		}
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
     a44:	d5 01       	movw	r26, r10
     a46:	2c 91       	ld	r18, X
     a48:	92 13       	cpse	r25, r18
     a4a:	01 c0       	rjmp	.+2      	; 0xa4e <tinyDendrite_update_signals+0xf4>
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     a4c:	1c 92       	st	X, r1
     a4e:	31 96       	adiw	r30, 0x01	; 1
	//Read the analog voltage values on each of the Dendrites
	tinyDendrite_read_signals();
	
	_Bool charging = false;
	
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
     a50:	e4 17       	cp	r30, r20
     a52:	f5 07       	cpc	r31, r21
     a54:	99 f6       	brne	.-90     	; 0x9fc <tinyDendrite_update_signals+0xa2>
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
		}
	}
	tinyCharge_set_charging_mode(charging);
     a56:	0e 94 24 04 	call	0x848	; 0x848 <tinyCharge_set_charging_mode>
}
     a5a:	df 91       	pop	r29
     a5c:	cf 91       	pop	r28
     a5e:	1f 91       	pop	r17
     a60:	0f 91       	pop	r16
     a62:	ff 90       	pop	r15
     a64:	ef 90       	pop	r14
     a66:	df 90       	pop	r13
     a68:	cf 90       	pop	r12
     a6a:	bf 90       	pop	r11
     a6c:	af 90       	pop	r10
     a6e:	08 95       	ret

00000a70 <tinyDendrite_get_potential>:
outside. It uses the previously declared functions to return the potential.
*/
int16_t tinyDendrite_get_potential()
{
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
     a70:	0e 94 ad 04 	call	0x95a	; 0x95a <tinyDendrite_update_signals>
     a74:	ea e3       	ldi	r30, 0x3A	; 58
     a76:	f8 e3       	ldi	r31, 0x38	; 56
     a78:	4f e3       	ldi	r20, 0x3F	; 63
     a7a:	58 e3       	ldi	r21, 0x38	; 56
	
	int16_t return_potential_val = 0;
     a7c:	20 e0       	ldi	r18, 0x00	; 0
     a7e:	30 e0       	ldi	r19, 0x00	; 0
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		switch(tinyDendrite_current_signals[i])
     a80:	91 91       	ld	r25, Z+
     a82:	93 30       	cpi	r25, 0x03	; 3
     a84:	a1 f0       	breq	.+40     	; 0xaae <tinyDendrite_get_potential+0x3e>
     a86:	28 f4       	brcc	.+10     	; 0xa92 <tinyDendrite_get_potential+0x22>
     a88:	91 30       	cpi	r25, 0x01	; 1
     a8a:	b9 f0       	breq	.+46     	; 0xaba <tinyDendrite_get_potential+0x4a>
     a8c:	92 30       	cpi	r25, 0x02	; 2
     a8e:	91 f0       	breq	.+36     	; 0xab4 <tinyDendrite_get_potential+0x44>
     a90:	16 c0       	rjmp	.+44     	; 0xabe <tinyDendrite_get_potential+0x4e>
     a92:	95 30       	cpi	r25, 0x05	; 5
     a94:	31 f0       	breq	.+12     	; 0xaa2 <tinyDendrite_get_potential+0x32>
     a96:	40 f0       	brcs	.+16     	; 0xaa8 <tinyDendrite_get_potential+0x38>
     a98:	96 30       	cpi	r25, 0x06	; 6
     a9a:	89 f4       	brne	.+34     	; 0xabe <tinyDendrite_get_potential+0x4e>
		{
			case NO_SIGNAL:
				return_potential_val += NO_SIGNAL_REACTION;
				break;
			case HIGH_EXCITE:
				return_potential_val += HIGH_EXCITE_REACTION;
     a9c:	2c 5c       	subi	r18, 0xCC	; 204
     a9e:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     aa0:	0e c0       	rjmp	.+28     	; 0xabe <tinyDendrite_get_potential+0x4e>
			case NORMAL_EXCITE:
				return_potential_val += NORMAL_EXCITE_REACTION;
     aa2:	26 5e       	subi	r18, 0xE6	; 230
     aa4:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     aa6:	0b c0       	rjmp	.+22     	; 0xabe <tinyDendrite_get_potential+0x4e>
			case LOW_EXCITE:
				return_potential_val += LOW_EXCITE_REACTION;
     aa8:	2c 5e       	subi	r18, 0xEC	; 236
     aaa:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     aac:	08 c0       	rjmp	.+16     	; 0xabe <tinyDendrite_get_potential+0x4e>
			case HIGH_INHIB:
				return_potential_val += HIGH_INHIB_REACTION;
     aae:	22 53       	subi	r18, 0x32	; 50
     ab0:	31 09       	sbc	r19, r1
				break;
     ab2:	05 c0       	rjmp	.+10     	; 0xabe <tinyDendrite_get_potential+0x4e>
			case NORMAL_INHIB:
				return_potential_val += NORMAL_INHIB_REACTION;
     ab4:	2a 51       	subi	r18, 0x1A	; 26
     ab6:	31 09       	sbc	r19, r1
				break;
     ab8:	02 c0       	rjmp	.+4      	; 0xabe <tinyDendrite_get_potential+0x4e>
			case LOW_INHIB:
				return_potential_val += LOW_INHIB_REACTION;
     aba:	24 51       	subi	r18, 0x14	; 20
     abc:	31 09       	sbc	r19, r1
{
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
	
	int16_t return_potential_val = 0;
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
     abe:	e4 17       	cp	r30, r20
     ac0:	f5 07       	cpc	r31, r21
     ac2:	f1 f6       	brne	.-68     	; 0xa80 <tinyDendrite_get_potential+0x10>
			default:
				break;
		}
	}
	return return_potential_val;
}
     ac4:	c9 01       	movw	r24, r18
     ac6:	08 95       	ret

00000ac8 <tinyDendrite_update_potential>:

double tinyDendrite_update_potential(double potential){
     ac8:	cf 92       	push	r12
     aca:	df 92       	push	r13
     acc:	ef 92       	push	r14
     ace:	ff 92       	push	r15
     ad0:	6b 01       	movw	r12, r22
     ad2:	7c 01       	movw	r14, r24
	
	int16_t potential_change = tinyDendrite_get_potential();
     ad4:	0e 94 38 05 	call	0xa70	; 0xa70 <tinyDendrite_get_potential>
	potential += potential_change;
	return potential;
     ad8:	bc 01       	movw	r22, r24
     ada:	99 0f       	add	r25, r25
     adc:	88 0b       	sbc	r24, r24
     ade:	99 0b       	sbc	r25, r25
     ae0:	0e 94 25 0a 	call	0x144a	; 0x144a <__floatsisf>
     ae4:	a7 01       	movw	r20, r14
     ae6:	96 01       	movw	r18, r12
     ae8:	0e 94 d7 08 	call	0x11ae	; 0x11ae <__addsf3>
     aec:	ff 90       	pop	r15
     aee:	ef 90       	pop	r14
     af0:	df 90       	pop	r13
     af2:	cf 90       	pop	r12
     af4:	08 95       	ret

00000af6 <__vector_6>:
This function is called every time the RTC (Real Time Clock) counter overflows.
With the current settings, it will be called every ms.
The RTC clock runs at 1kHz, and the number of cycles before overflow is set with RTC.PER = someHexValue (e.g. 0x20) in src/rtc.c
*/
ISR(RTC_CNT_vect)
{
     af6:	1f 92       	push	r1
     af8:	0f 92       	push	r0
     afa:	0f b6       	in	r0, 0x3f	; 63
     afc:	0f 92       	push	r0
     afe:	11 24       	eor	r1, r1
     b00:	2f 93       	push	r18
     b02:	3f 93       	push	r19
     b04:	4f 93       	push	r20
     b06:	5f 93       	push	r21
     b08:	6f 93       	push	r22
     b0a:	7f 93       	push	r23
     b0c:	8f 93       	push	r24
     b0e:	9f 93       	push	r25
     b10:	af 93       	push	r26
     b12:	bf 93       	push	r27
     b14:	cf 93       	push	r28
     b16:	ef 93       	push	r30
     b18:	ff 93       	push	r31
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     b1a:	c1 e0       	ldi	r28, 0x01	; 1
     b1c:	c0 93 44 38 	sts	0x3844, r28	; 0x803844 <tinyISR_interrupt_flag>
{
	// Set flag to let main loop run a new cycle
	tinyISR_setflag(true);
	
	// Timer counter incrementation
	tinyTime_counter_increment();
     b20:	0e 94 b9 08 	call	0x1172	; 0x1172 <tinyTime_counter_increment>

	/* Overflow interrupt flag has to be cleared manually */
	RTC.INTFLAGS = RTC_OVF_bm;
     b24:	c0 93 43 01 	sts	0x0143, r28	; 0x800143 <__TEXT_REGION_LENGTH__+0x700143>
}
     b28:	ff 91       	pop	r31
     b2a:	ef 91       	pop	r30
     b2c:	cf 91       	pop	r28
     b2e:	bf 91       	pop	r27
     b30:	af 91       	pop	r26
     b32:	9f 91       	pop	r25
     b34:	8f 91       	pop	r24
     b36:	7f 91       	pop	r23
     b38:	6f 91       	pop	r22
     b3a:	5f 91       	pop	r21
     b3c:	4f 91       	pop	r20
     b3e:	3f 91       	pop	r19
     b40:	2f 91       	pop	r18
     b42:	0f 90       	pop	r0
     b44:	0f be       	out	0x3f, r0	; 63
     b46:	0f 90       	pop	r0
     b48:	1f 90       	pop	r1
     b4a:	18 95       	reti

00000b4c <tinyISR_setflag>:
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     b4c:	80 93 44 38 	sts	0x3844, r24	; 0x803844 <tinyISR_interrupt_flag>
     b50:	08 95       	ret

00000b52 <tinyISR_getflag>:
}

_Bool tinyISR_getflag(void)
{
	return tinyISR_interrupt_flag;
}
     b52:	80 91 44 38 	lds	r24, 0x3844	; 0x803844 <tinyISR_interrupt_flag>
     b56:	08 95       	ret

00000b58 <tinyLED_SPIWriteByte>:
Function used to send a byte over SPI, which in turn gets
translated to the bit-sequence required by the LEDs over the CCL.
*/
static void tinyLED_SPIWriteByte(uint8_t byte)
{
	SPI0.INTFLAGS = SPI0_INTFLAGS; // clear the write collision flag to allow writing
     b58:	90 91 23 08 	lds	r25, 0x0823	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
     b5c:	90 93 23 08 	sts	0x0823, r25	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
	TCA0.SINGLE.CNT = 0; // reset TCA counter register to ensure the first rising edge of the PWM is predictable
     b60:	e0 e0       	ldi	r30, 0x00	; 0
     b62:	fa e0       	ldi	r31, 0x0A	; 10
     b64:	10 a2       	std	Z+32, r1	; 0x20
     b66:	11 a2       	std	Z+33, r1	; 0x21
	
	// start TCA
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 1 << TCA_SPLIT_ENABLE_bp;
     b68:	91 e0       	ldi	r25, 0x01	; 1
     b6a:	90 83       	st	Z, r25
	SPI0_DATA = byte;
     b6c:	80 93 24 08 	sts	0x0824, r24	; 0x800824 <__TEXT_REGION_LENGTH__+0x700824>

	while((SPI0.INTFLAGS & SPI_RXCIE_bm) == 0){} // wait for transfer to complete
     b70:	e0 e2       	ldi	r30, 0x20	; 32
     b72:	f8 e0       	ldi	r31, 0x08	; 8
     b74:	83 81       	ldd	r24, Z+3	; 0x03
     b76:	88 23       	and	r24, r24
     b78:	ec f7       	brge	.-6      	; 0xb74 <tinyLED_SPIWriteByte+0x1c>
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 0 << TCA_SPLIT_ENABLE_bp; //Stop TCA
     b7a:	10 92 00 0a 	sts	0x0A00, r1	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
     b7e:	08 95       	ret

00000b80 <tinyLED_set_color>:
changes the values in the variables stored in the LED-array.
*/
void tinyLED_set_color_mode(uint8_t LED_id, enum Colors color, enum ColorModes mode)
{
	struct ColorSetting setting = {.color=color, .mode=mode};
	tinyLED_colors[LED_id] = setting;
     b80:	e8 2f       	mov	r30, r24
     b82:	f0 e0       	ldi	r31, 0x00	; 0
     b84:	ee 0f       	add	r30, r30
     b86:	ff 1f       	adc	r31, r31
     b88:	ef 59       	subi	r30, 0x9F	; 159
     b8a:	f7 4c       	sbci	r31, 0xC7	; 199
     b8c:	60 83       	st	Z, r22
     b8e:	11 82       	std	Z+1, r1	; 0x01
     b90:	08 95       	ret

00000b92 <tinyLED_get_color>:
	tinyLED_set_color_mode(LED_id, color, STABLE);
}

enum Colors tinyLED_get_color(uint8_t LED_id)
{
	return tinyLED_colors[LED_id].color;
     b92:	e8 2f       	mov	r30, r24
     b94:	f0 e0       	ldi	r31, 0x00	; 0
     b96:	ee 0f       	add	r30, r30
     b98:	ff 1f       	adc	r31, r31
     b9a:	ef 59       	subi	r30, 0x9F	; 159
     b9c:	f7 4c       	sbci	r31, 0xC7	; 199
}
     b9e:	80 81       	ld	r24, Z
     ba0:	08 95       	ret

00000ba2 <tinyLED_set_color_mode>:
changes the values in the variables stored in the LED-array.
*/
void tinyLED_set_color_mode(uint8_t LED_id, enum Colors color, enum ColorModes mode)
{
	struct ColorSetting setting = {.color=color, .mode=mode};
	tinyLED_colors[LED_id] = setting;
     ba2:	90 e0       	ldi	r25, 0x00	; 0
     ba4:	fc 01       	movw	r30, r24
     ba6:	ee 0f       	add	r30, r30
     ba8:	ff 1f       	adc	r31, r31
     baa:	ef 59       	subi	r30, 0x9F	; 159
     bac:	f7 4c       	sbci	r31, 0xC7	; 199
     bae:	60 83       	st	Z, r22
     bb0:	41 83       	std	Z+1, r20	; 0x01
	if (mode == FLASH_ONCE)
     bb2:	44 30       	cpi	r20, 0x04	; 4
     bb4:	29 f4       	brne	.+10     	; 0xbc0 <tinyLED_set_color_mode+0x1e>
	{
		tinyLED_flash_once_time[LED_id] = 1000*FLASH_TIME;
     bb6:	fc 01       	movw	r30, r24
     bb8:	e7 5a       	subi	r30, 0xA7	; 167
     bba:	f7 4c       	sbci	r31, 0xC7	; 199
     bbc:	2a e0       	ldi	r18, 0x0A	; 10
     bbe:	20 83       	st	Z, r18
     bc0:	08 95       	ret

00000bc2 <tinyLED_RGB_Color_Compare>:
	}
	return rgb_color;
			
};

_Bool tinyLED_RGB_Color_Compare(struct RGB_Color* a, struct RGB_Color* b){
     bc2:	dc 01       	movw	r26, r24
     bc4:	fb 01       	movw	r30, r22
	for (int i=0; i<NUMBER_OF_LEDS; i++)
	{
		if(!(a[i].red==b[i].red && a[i].green==b[i].green && a[i].blue==b[i].blue)){
     bc6:	9c 91       	ld	r25, X
     bc8:	80 81       	ld	r24, Z
     bca:	98 13       	cpse	r25, r24
     bcc:	20 c0       	rjmp	.+64     	; 0xc0e <tinyLED_RGB_Color_Compare+0x4c>
     bce:	11 96       	adiw	r26, 0x01	; 1
     bd0:	9c 91       	ld	r25, X
     bd2:	11 97       	sbiw	r26, 0x01	; 1
     bd4:	81 81       	ldd	r24, Z+1	; 0x01
     bd6:	98 13       	cpse	r25, r24
     bd8:	1c c0       	rjmp	.+56     	; 0xc12 <tinyLED_RGB_Color_Compare+0x50>
     bda:	12 96       	adiw	r26, 0x02	; 2
     bdc:	9c 91       	ld	r25, X
     bde:	12 97       	sbiw	r26, 0x02	; 2
     be0:	82 81       	ldd	r24, Z+2	; 0x02
     be2:	98 13       	cpse	r25, r24
     be4:	18 c0       	rjmp	.+48     	; 0xc16 <tinyLED_RGB_Color_Compare+0x54>
     be6:	13 96       	adiw	r26, 0x03	; 3
     be8:	9c 91       	ld	r25, X
     bea:	13 97       	sbiw	r26, 0x03	; 3
     bec:	83 81       	ldd	r24, Z+3	; 0x03
     bee:	98 13       	cpse	r25, r24
     bf0:	14 c0       	rjmp	.+40     	; 0xc1a <tinyLED_RGB_Color_Compare+0x58>
     bf2:	14 96       	adiw	r26, 0x04	; 4
     bf4:	9c 91       	ld	r25, X
     bf6:	14 97       	sbiw	r26, 0x04	; 4
     bf8:	84 81       	ldd	r24, Z+4	; 0x04
     bfa:	98 13       	cpse	r25, r24
     bfc:	10 c0       	rjmp	.+32     	; 0xc1e <tinyLED_RGB_Color_Compare+0x5c>
     bfe:	81 e0       	ldi	r24, 0x01	; 1
     c00:	15 96       	adiw	r26, 0x05	; 5
     c02:	2c 91       	ld	r18, X
     c04:	95 81       	ldd	r25, Z+5	; 0x05
     c06:	29 17       	cp	r18, r25
     c08:	59 f0       	breq	.+22     	; 0xc20 <tinyLED_RGB_Color_Compare+0x5e>
     c0a:	80 e0       	ldi	r24, 0x00	; 0
     c0c:	08 95       	ret
			return false;
     c0e:	80 e0       	ldi	r24, 0x00	; 0
     c10:	08 95       	ret
     c12:	80 e0       	ldi	r24, 0x00	; 0
     c14:	08 95       	ret
     c16:	80 e0       	ldi	r24, 0x00	; 0
     c18:	08 95       	ret
     c1a:	80 e0       	ldi	r24, 0x00	; 0
     c1c:	08 95       	ret
     c1e:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	return true;
}
     c20:	08 95       	ret

00000c22 <tinyLED_update>:
/*
function to write the current LED-array on to the LEDs and
effectively update the values stored in the LEDs to the values stored in the MCU.
*/
void tinyLED_update(void)
{
     c22:	2f 92       	push	r2
     c24:	3f 92       	push	r3
     c26:	4f 92       	push	r4
     c28:	5f 92       	push	r5
     c2a:	6f 92       	push	r6
     c2c:	7f 92       	push	r7
     c2e:	8f 92       	push	r8
     c30:	9f 92       	push	r9
     c32:	af 92       	push	r10
     c34:	bf 92       	push	r11
     c36:	cf 92       	push	r12
     c38:	df 92       	push	r13
     c3a:	ef 92       	push	r14
     c3c:	ff 92       	push	r15
     c3e:	0f 93       	push	r16
     c40:	1f 93       	push	r17
     c42:	cf 93       	push	r28
     c44:	df 93       	push	r29
     c46:	cd b7       	in	r28, 0x3d	; 61
     c48:	de b7       	in	r29, 0x3e	; 62
     c4a:	6e 97       	sbiw	r28, 0x1e	; 30
     c4c:	cd bf       	out	0x3d, r28	; 61
     c4e:	de bf       	out	0x3e, r29	; 62
			
	uint32_t now = tinyTime_now();
     c50:	0e 94 cd 08 	call	0x119a	; 0x119a <tinyTime_now>
     c54:	6b 01       	movw	r12, r22
     c56:	7c 01       	movw	r14, r24
	
	// This is a sin curve, but between 0 and 1 instead of -1 and 1
	double sinValue = 1+sin((double)now/(100*M_PI/SWING_RATE))/2;
     c58:	0e 94 23 0a 	call	0x1446	; 0x1446 <__floatunsisf>
     c5c:	22 ed       	ldi	r18, 0xD2	; 210
     c5e:	33 e5       	ldi	r19, 0x53	; 83
     c60:	4b ef       	ldi	r20, 0xFB	; 251
     c62:	51 e4       	ldi	r21, 0x41	; 65
     c64:	0e 94 48 09 	call	0x1290	; 0x1290 <__divsf3>
     c68:	0e 94 03 0c 	call	0x1806	; 0x1806 <sin>
     c6c:	20 e0       	ldi	r18, 0x00	; 0
     c6e:	30 e0       	ldi	r19, 0x00	; 0
     c70:	40 e0       	ldi	r20, 0x00	; 0
     c72:	5f e3       	ldi	r21, 0x3F	; 63
     c74:	0e 94 96 0b 	call	0x172c	; 0x172c <__mulsf3>
     c78:	20 e0       	ldi	r18, 0x00	; 0
     c7a:	30 e0       	ldi	r19, 0x00	; 0
     c7c:	40 e8       	ldi	r20, 0x80	; 128
     c7e:	5f e3       	ldi	r21, 0x3F	; 63
     c80:	0e 94 d7 08 	call	0x11ae	; 0x11ae <__addsf3>
     c84:	69 87       	std	Y+9, r22	; 0x09
     c86:	7a 87       	std	Y+10, r23	; 0x0a
     c88:	8b 87       	std	Y+11, r24	; 0x0b
     c8a:	9c 87       	std	Y+12, r25	; 0x0c
	
	// If FLASH_RATE is one, then that means that the left side of the "<" will just count from 0 to 1000, and flash_on will be true for half of the time
	_Bool flash_on = now%(uint32_t)(1000/FLASH_RATE)  <   500/FLASH_RATE;
     c8c:	c7 01       	movw	r24, r14
     c8e:	b6 01       	movw	r22, r12
     c90:	22 e3       	ldi	r18, 0x32	; 50
     c92:	30 e0       	ldi	r19, 0x00	; 0
     c94:	40 e0       	ldi	r20, 0x00	; 0
     c96:	50 e0       	ldi	r21, 0x00	; 0
     c98:	0e 94 6c 0c 	call	0x18d8	; 0x18d8 <__udivmodsi4>
     c9c:	0e 94 23 0a 	call	0x1446	; 0x1446 <__floatunsisf>
     ca0:	20 e0       	ldi	r18, 0x00	; 0
     ca2:	30 e0       	ldi	r19, 0x00	; 0
     ca4:	48 ec       	ldi	r20, 0xC8	; 200
     ca6:	51 e4       	ldi	r21, 0x41	; 65
     ca8:	0e 94 43 09 	call	0x1286	; 0x1286 <__cmpsf2>
     cac:	88 1f       	adc	r24, r24
     cae:	88 27       	eor	r24, r24
     cb0:	88 1f       	adc	r24, r24
     cb2:	8f 83       	std	Y+7, r24	; 0x07
	
	// PING_RATE is usually small, so the left side counts to some large number. Since flash_time usually is also quite small,
	// the left side will usually be larger than the right
	_Bool ping_on =  now%(uint32_t)(1000/PING_RATE)   <   1000*FLASH_TIME;
     cb4:	c7 01       	movw	r24, r14
     cb6:	b6 01       	movw	r22, r12
     cb8:	24 ef       	ldi	r18, 0xF4	; 244
     cba:	31 e0       	ldi	r19, 0x01	; 1
     cbc:	40 e0       	ldi	r20, 0x00	; 0
     cbe:	50 e0       	ldi	r21, 0x00	; 0
     cc0:	0e 94 6c 0c 	call	0x18d8	; 0x18d8 <__udivmodsi4>
     cc4:	0e 94 23 0a 	call	0x1446	; 0x1446 <__floatunsisf>
     cc8:	20 e0       	ldi	r18, 0x00	; 0
     cca:	30 e0       	ldi	r19, 0x00	; 0
     ccc:	40 e2       	ldi	r20, 0x20	; 32
     cce:	51 e4       	ldi	r21, 0x41	; 65
     cd0:	0e 94 43 09 	call	0x1286	; 0x1286 <__cmpsf2>
     cd4:	88 1f       	adc	r24, r24
     cd6:	88 27       	eor	r24, r24
     cd8:	88 1f       	adc	r24, r24
     cda:	01 e6       	ldi	r16, 0x61	; 97
     cdc:	18 e3       	ldi	r17, 0x38	; 56
     cde:	9e 01       	movw	r18, r28
     ce0:	2f 5f       	subi	r18, 0xFF	; 255
     ce2:	3f 4f       	sbci	r19, 0xFF	; 255
     ce4:	0f 2e       	mov	r0, r31
     ce6:	f9 e5       	ldi	r31, 0x59	; 89
     ce8:	4f 2e       	mov	r4, r31
     cea:	f8 e3       	ldi	r31, 0x38	; 56
     cec:	5f 2e       	mov	r5, r31
     cee:	f0 2d       	mov	r31, r0
     cf0:	0f 2e       	mov	r0, r31
     cf2:	f5 e6       	ldi	r31, 0x65	; 101
     cf4:	6f 2e       	mov	r6, r31
     cf6:	f8 e3       	ldi	r31, 0x38	; 56
     cf8:	7f 2e       	mov	r7, r31
     cfa:	f0 2d       	mov	r31, r0
     cfc:	19 01       	movw	r2, r18
			case SWING:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*sinValue, rgb_colors[i].green*sinValue, rgb_colors[i].blue*sinValue};
				break;
			case PING:
				// in the line below, fmin will either return 1 or 0, so each rgb color is either 0 or 255*PING_BRIGHTNESS
				rgb_colors[i] = (struct RGB_Color){255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].red)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].green)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].blue)*ping_on};
     cfe:	88 2e       	mov	r8, r24
     d00:	91 2c       	mov	r9, r1
     d02:	a1 2c       	mov	r10, r1
     d04:	b1 2c       	mov	r11, r1
     d06:	2d 87       	std	Y+13, r18	; 0x0d
     d08:	3e 87       	std	Y+14, r19	; 0x0e
     d0a:	df 80       	ldd	r13, Y+7	; 0x07
     d0c:	f8 01       	movw	r30, r16
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 0 << TCA_SPLIT_ENABLE_bp; //Stop TCA
}

static struct RGB_Color tinyLED_enum_to_RGB_Color(enum Colors color){
	struct RGB_Color rgb_color;
	switch(color)
     d0e:	80 81       	ld	r24, Z
     d10:	82 30       	cpi	r24, 0x02	; 2
     d12:	a1 f0       	breq	.+40     	; 0xd3c <tinyLED_update+0x11a>
     d14:	18 f4       	brcc	.+6      	; 0xd1c <tinyLED_update+0xfa>
     d16:	81 30       	cpi	r24, 0x01	; 1
     d18:	31 f0       	breq	.+12     	; 0xd26 <tinyLED_update+0x104>
     d1a:	21 c0       	rjmp	.+66     	; 0xd5e <tinyLED_update+0x13c>
     d1c:	83 30       	cpi	r24, 0x03	; 3
     d1e:	39 f0       	breq	.+14     	; 0xd2e <tinyLED_update+0x10c>
     d20:	84 30       	cpi	r24, 0x04	; 4
     d22:	99 f0       	breq	.+38     	; 0xd4a <tinyLED_update+0x128>
     d24:	1c c0       	rjmp	.+56     	; 0xd5e <tinyLED_update+0x13c>
	{
		case OFF:
			rgb_color = (struct RGB_Color){0, 0, 0};
			break;
		case RED:
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 0, 0};
     d26:	f1 2c       	mov	r15, r1
     d28:	e1 2c       	mov	r14, r1
     d2a:	69 e1       	ldi	r22, 0x19	; 25
     d2c:	1b c0       	rjmp	.+54     	; 0xd64 <tinyLED_update+0x142>
			break;
		case GREEN:
			rgb_color = (struct RGB_Color){0, 255*LED_BRIGHTNESS, 0};
     d2e:	f1 2c       	mov	r15, r1
     d30:	0f 2e       	mov	r0, r31
     d32:	f9 e1       	ldi	r31, 0x19	; 25
     d34:	ef 2e       	mov	r14, r31
     d36:	f0 2d       	mov	r31, r0
     d38:	60 e0       	ldi	r22, 0x00	; 0
     d3a:	14 c0       	rjmp	.+40     	; 0xd64 <tinyLED_update+0x142>
			break;
		case BLUE:
			rgb_color = (struct RGB_Color){0, 0, 255*LED_BRIGHTNESS};
     d3c:	0f 2e       	mov	r0, r31
     d3e:	f9 e1       	ldi	r31, 0x19	; 25
     d40:	ff 2e       	mov	r15, r31
     d42:	f0 2d       	mov	r31, r0
     d44:	e1 2c       	mov	r14, r1
     d46:	60 e0       	ldi	r22, 0x00	; 0
     d48:	0d c0       	rjmp	.+26     	; 0xd64 <tinyLED_update+0x142>
			// Should the /3 be there? This requires testing.
			// After testing, findings were that at 0.1 brightness, one would see the three LEDs instead of one white led
			// We try with /2 instead.
			// We find that the best results come from not dividing by anything. At leasts in the lower brightness settings, and that
			// is where we suspect it will be most of the time. When we divide, the LEDs are so weak, that they appear as three lights instead of one.
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS};
     d4a:	0f 2e       	mov	r0, r31
     d4c:	f9 e1       	ldi	r31, 0x19	; 25
     d4e:	ff 2e       	mov	r15, r31
     d50:	f0 2d       	mov	r31, r0
     d52:	0f 2e       	mov	r0, r31
     d54:	f9 e1       	ldi	r31, 0x19	; 25
     d56:	ef 2e       	mov	r14, r31
     d58:	f0 2d       	mov	r31, r0
     d5a:	69 e1       	ldi	r22, 0x19	; 25
     d5c:	03 c0       	rjmp	.+6      	; 0xd64 <tinyLED_update+0x142>
static struct RGB_Color tinyLED_enum_to_RGB_Color(enum Colors color){
	struct RGB_Color rgb_color;
	switch(color)
	{
		case OFF:
			rgb_color = (struct RGB_Color){0, 0, 0};
     d5e:	f1 2c       	mov	r15, r1
     d60:	e1 2c       	mov	r14, r1
     d62:	60 e0       	ldi	r22, 0x00	; 0
     d64:	2f 82       	std	Y+7, r2	; 0x07
     d66:	38 86       	std	Y+8, r3	; 0x08
	
		
	for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
	{		
		// Convert enum to RGB_Color
		rgb_colors[i] = tinyLED_enum_to_RGB_Color(tinyLED_colors[i].color);
     d68:	d1 01       	movw	r26, r2
     d6a:	6c 93       	st	X, r22
     d6c:	11 96       	adiw	r26, 0x01	; 1
     d6e:	ec 92       	st	X, r14
     d70:	11 97       	sbiw	r26, 0x01	; 1
     d72:	12 96       	adiw	r26, 0x02	; 2
     d74:	fc 92       	st	X, r15
			
		// Adjust colors according to mode
		switch(tinyLED_colors[i].mode)
     d76:	81 81       	ldd	r24, Z+1	; 0x01
     d78:	82 30       	cpi	r24, 0x02	; 2
     d7a:	d1 f0       	breq	.+52     	; 0xdb0 <tinyLED_update+0x18e>
     d7c:	18 f4       	brcc	.+6      	; 0xd84 <tinyLED_update+0x162>
     d7e:	81 30       	cpi	r24, 0x01	; 1
     d80:	41 f0       	breq	.+16     	; 0xd92 <tinyLED_update+0x170>
     d82:	cd c0       	rjmp	.+410    	; 0xf1e <tinyLED_update+0x2fc>
     d84:	83 30       	cpi	r24, 0x03	; 3
     d86:	09 f4       	brne	.+2      	; 0xd8a <tinyLED_update+0x168>
     d88:	44 c0       	rjmp	.+136    	; 0xe12 <tinyLED_update+0x1f0>
     d8a:	84 30       	cpi	r24, 0x04	; 4
     d8c:	09 f4       	brne	.+2      	; 0xd90 <tinyLED_update+0x16e>
     d8e:	bf c0       	rjmp	.+382    	; 0xf0e <tinyLED_update+0x2ec>
     d90:	c6 c0       	rjmp	.+396    	; 0xf1e <tinyLED_update+0x2fc>
		{
			case STABLE:
				break;
			case FLASH:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*flash_on, rgb_colors[i].green*flash_on, rgb_colors[i].blue*flash_on};
     d92:	d6 9e       	mul	r13, r22
     d94:	60 2d       	mov	r22, r0
     d96:	11 24       	eor	r1, r1
     d98:	ef 81       	ldd	r30, Y+7	; 0x07
     d9a:	f8 85       	ldd	r31, Y+8	; 0x08
     d9c:	60 83       	st	Z, r22
     d9e:	de 9c       	mul	r13, r14
     da0:	e0 2c       	mov	r14, r0
     da2:	11 24       	eor	r1, r1
     da4:	e1 82       	std	Z+1, r14	; 0x01
     da6:	df 9c       	mul	r13, r15
     da8:	f0 2c       	mov	r15, r0
     daa:	11 24       	eor	r1, r1
     dac:	f2 82       	std	Z+2, r15	; 0x02
				break;
     dae:	b7 c0       	rjmp	.+366    	; 0xf1e <tinyLED_update+0x2fc>
			case SWING:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*sinValue, rgb_colors[i].green*sinValue, rgb_colors[i].blue*sinValue};
     db0:	70 e0       	ldi	r23, 0x00	; 0
     db2:	80 e0       	ldi	r24, 0x00	; 0
     db4:	90 e0       	ldi	r25, 0x00	; 0
     db6:	0e 94 25 0a 	call	0x144a	; 0x144a <__floatsisf>
     dba:	29 85       	ldd	r18, Y+9	; 0x09
     dbc:	3a 85       	ldd	r19, Y+10	; 0x0a
     dbe:	4b 85       	ldd	r20, Y+11	; 0x0b
     dc0:	5c 85       	ldd	r21, Y+12	; 0x0c
     dc2:	0e 94 96 0b 	call	0x172c	; 0x172c <__mulsf3>
     dc6:	0e 94 f4 09 	call	0x13e8	; 0x13e8 <__fixunssfsi>
     dca:	d1 01       	movw	r26, r2
     dcc:	6c 93       	st	X, r22
     dce:	6e 2d       	mov	r22, r14
     dd0:	70 e0       	ldi	r23, 0x00	; 0
     dd2:	80 e0       	ldi	r24, 0x00	; 0
     dd4:	90 e0       	ldi	r25, 0x00	; 0
     dd6:	0e 94 25 0a 	call	0x144a	; 0x144a <__floatsisf>
     dda:	29 85       	ldd	r18, Y+9	; 0x09
     ddc:	3a 85       	ldd	r19, Y+10	; 0x0a
     dde:	4b 85       	ldd	r20, Y+11	; 0x0b
     de0:	5c 85       	ldd	r21, Y+12	; 0x0c
     de2:	0e 94 96 0b 	call	0x172c	; 0x172c <__mulsf3>
     de6:	0e 94 f4 09 	call	0x13e8	; 0x13e8 <__fixunssfsi>
     dea:	f1 01       	movw	r30, r2
     dec:	61 83       	std	Z+1, r22	; 0x01
     dee:	6f 2d       	mov	r22, r15
     df0:	70 e0       	ldi	r23, 0x00	; 0
     df2:	80 e0       	ldi	r24, 0x00	; 0
     df4:	90 e0       	ldi	r25, 0x00	; 0
     df6:	0e 94 25 0a 	call	0x144a	; 0x144a <__floatsisf>
     dfa:	29 85       	ldd	r18, Y+9	; 0x09
     dfc:	3a 85       	ldd	r19, Y+10	; 0x0a
     dfe:	4b 85       	ldd	r20, Y+11	; 0x0b
     e00:	5c 85       	ldd	r21, Y+12	; 0x0c
     e02:	0e 94 96 0b 	call	0x172c	; 0x172c <__mulsf3>
     e06:	0e 94 f4 09 	call	0x13e8	; 0x13e8 <__fixunssfsi>
     e0a:	d1 01       	movw	r26, r2
     e0c:	12 96       	adiw	r26, 0x02	; 2
     e0e:	6c 93       	st	X, r22
				break;
     e10:	86 c0       	rjmp	.+268    	; 0xf1e <tinyLED_update+0x2fc>
			case PING:
				// in the line below, fmin will either return 1 or 0, so each rgb color is either 0 or 255*PING_BRIGHTNESS
				rgb_colors[i] = (struct RGB_Color){255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].red)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].green)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].blue)*ping_on};
     e12:	70 e0       	ldi	r23, 0x00	; 0
     e14:	80 e0       	ldi	r24, 0x00	; 0
     e16:	90 e0       	ldi	r25, 0x00	; 0
     e18:	0e 94 23 0a 	call	0x1446	; 0x1446 <__floatunsisf>
     e1c:	9b 01       	movw	r18, r22
     e1e:	ac 01       	movw	r20, r24
     e20:	60 e0       	ldi	r22, 0x00	; 0
     e22:	70 e0       	ldi	r23, 0x00	; 0
     e24:	80 e8       	ldi	r24, 0x80	; 128
     e26:	9f e3       	ldi	r25, 0x3F	; 63
     e28:	0e 94 60 0a 	call	0x14c0	; 0x14c0 <fmin>
     e2c:	6b 8b       	std	Y+19, r22	; 0x13
     e2e:	7c 8b       	std	Y+20, r23	; 0x14
     e30:	8d 8b       	std	Y+21, r24	; 0x15
     e32:	9e 8b       	std	Y+22, r25	; 0x16
     e34:	c5 01       	movw	r24, r10
     e36:	b4 01       	movw	r22, r8
     e38:	0e 94 25 0a 	call	0x144a	; 0x144a <__floatsisf>
     e3c:	6f 87       	std	Y+15, r22	; 0x0f
     e3e:	78 8b       	std	Y+16, r23	; 0x10
     e40:	89 8b       	std	Y+17, r24	; 0x11
     e42:	9a 8b       	std	Y+18, r25	; 0x12
     e44:	6e 2d       	mov	r22, r14
     e46:	70 e0       	ldi	r23, 0x00	; 0
     e48:	80 e0       	ldi	r24, 0x00	; 0
     e4a:	90 e0       	ldi	r25, 0x00	; 0
     e4c:	0e 94 23 0a 	call	0x1446	; 0x1446 <__floatunsisf>
     e50:	9b 01       	movw	r18, r22
     e52:	ac 01       	movw	r20, r24
     e54:	60 e0       	ldi	r22, 0x00	; 0
     e56:	70 e0       	ldi	r23, 0x00	; 0
     e58:	80 e8       	ldi	r24, 0x80	; 128
     e5a:	9f e3       	ldi	r25, 0x3F	; 63
     e5c:	0e 94 60 0a 	call	0x14c0	; 0x14c0 <fmin>
     e60:	6f 8b       	std	Y+23, r22	; 0x17
     e62:	78 8f       	std	Y+24, r23	; 0x18
     e64:	89 8f       	std	Y+25, r24	; 0x19
     e66:	9a 8f       	std	Y+26, r25	; 0x1a
     e68:	6f 2d       	mov	r22, r15
     e6a:	70 e0       	ldi	r23, 0x00	; 0
     e6c:	80 e0       	ldi	r24, 0x00	; 0
     e6e:	90 e0       	ldi	r25, 0x00	; 0
     e70:	0e 94 23 0a 	call	0x1446	; 0x1446 <__floatunsisf>
     e74:	9b 01       	movw	r18, r22
     e76:	ac 01       	movw	r20, r24
     e78:	60 e0       	ldi	r22, 0x00	; 0
     e7a:	70 e0       	ldi	r23, 0x00	; 0
     e7c:	80 e8       	ldi	r24, 0x80	; 128
     e7e:	9f e3       	ldi	r25, 0x3F	; 63
     e80:	0e 94 60 0a 	call	0x14c0	; 0x14c0 <fmin>
     e84:	6b 8f       	std	Y+27, r22	; 0x1b
     e86:	7c 8f       	std	Y+28, r23	; 0x1c
     e88:	8d 8f       	std	Y+29, r24	; 0x1d
     e8a:	9e 8f       	std	Y+30, r25	; 0x1e
     e8c:	23 e3       	ldi	r18, 0x33	; 51
     e8e:	33 e3       	ldi	r19, 0x33	; 51
     e90:	43 ea       	ldi	r20, 0xA3	; 163
     e92:	50 e4       	ldi	r21, 0x40	; 64
     e94:	6b 89       	ldd	r22, Y+19	; 0x13
     e96:	7c 89       	ldd	r23, Y+20	; 0x14
     e98:	8d 89       	ldd	r24, Y+21	; 0x15
     e9a:	9e 89       	ldd	r25, Y+22	; 0x16
     e9c:	0e 94 96 0b 	call	0x172c	; 0x172c <__mulsf3>
     ea0:	2f 85       	ldd	r18, Y+15	; 0x0f
     ea2:	38 89       	ldd	r19, Y+16	; 0x10
     ea4:	49 89       	ldd	r20, Y+17	; 0x11
     ea6:	5a 89       	ldd	r21, Y+18	; 0x12
     ea8:	0e 94 96 0b 	call	0x172c	; 0x172c <__mulsf3>
     eac:	0e 94 f4 09 	call	0x13e8	; 0x13e8 <__fixunssfsi>
     eb0:	ef 81       	ldd	r30, Y+7	; 0x07
     eb2:	f8 85       	ldd	r31, Y+8	; 0x08
     eb4:	60 83       	st	Z, r22
     eb6:	23 e3       	ldi	r18, 0x33	; 51
     eb8:	33 e3       	ldi	r19, 0x33	; 51
     eba:	43 ea       	ldi	r20, 0xA3	; 163
     ebc:	50 e4       	ldi	r21, 0x40	; 64
     ebe:	6f 89       	ldd	r22, Y+23	; 0x17
     ec0:	78 8d       	ldd	r23, Y+24	; 0x18
     ec2:	89 8d       	ldd	r24, Y+25	; 0x19
     ec4:	9a 8d       	ldd	r25, Y+26	; 0x1a
     ec6:	0e 94 96 0b 	call	0x172c	; 0x172c <__mulsf3>
     eca:	2f 85       	ldd	r18, Y+15	; 0x0f
     ecc:	38 89       	ldd	r19, Y+16	; 0x10
     ece:	49 89       	ldd	r20, Y+17	; 0x11
     ed0:	5a 89       	ldd	r21, Y+18	; 0x12
     ed2:	0e 94 96 0b 	call	0x172c	; 0x172c <__mulsf3>
     ed6:	0e 94 f4 09 	call	0x13e8	; 0x13e8 <__fixunssfsi>
     eda:	af 81       	ldd	r26, Y+7	; 0x07
     edc:	b8 85       	ldd	r27, Y+8	; 0x08
     ede:	11 96       	adiw	r26, 0x01	; 1
     ee0:	6c 93       	st	X, r22
     ee2:	23 e3       	ldi	r18, 0x33	; 51
     ee4:	33 e3       	ldi	r19, 0x33	; 51
     ee6:	43 ea       	ldi	r20, 0xA3	; 163
     ee8:	50 e4       	ldi	r21, 0x40	; 64
     eea:	6b 8d       	ldd	r22, Y+27	; 0x1b
     eec:	7c 8d       	ldd	r23, Y+28	; 0x1c
     eee:	8d 8d       	ldd	r24, Y+29	; 0x1d
     ef0:	9e 8d       	ldd	r25, Y+30	; 0x1e
     ef2:	0e 94 96 0b 	call	0x172c	; 0x172c <__mulsf3>
     ef6:	2f 85       	ldd	r18, Y+15	; 0x0f
     ef8:	38 89       	ldd	r19, Y+16	; 0x10
     efa:	49 89       	ldd	r20, Y+17	; 0x11
     efc:	5a 89       	ldd	r21, Y+18	; 0x12
     efe:	0e 94 96 0b 	call	0x172c	; 0x172c <__mulsf3>
     f02:	0e 94 f4 09 	call	0x13e8	; 0x13e8 <__fixunssfsi>
     f06:	ef 81       	ldd	r30, Y+7	; 0x07
     f08:	f8 85       	ldd	r31, Y+8	; 0x08
     f0a:	62 83       	std	Z+2, r22	; 0x02
				break;
     f0c:	08 c0       	rjmp	.+16     	; 0xf1e <tinyLED_update+0x2fc>
			case FLASH_ONCE:
				if(tinyLED_flash_once_time[i]>0){
     f0e:	d2 01       	movw	r26, r4
     f10:	8c 91       	ld	r24, X
     f12:	88 23       	and	r24, r24
     f14:	19 f0       	breq	.+6      	; 0xf1c <tinyLED_update+0x2fa>
					rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red, rgb_colors[i].green, rgb_colors[i].blue};
					tinyLED_flash_once_time[i]--;
     f16:	81 50       	subi	r24, 0x01	; 1
     f18:	8c 93       	st	X, r24
     f1a:	01 c0       	rjmp	.+2      	; 0xf1e <tinyLED_update+0x2fc>
				}
				else{
					tinyLED_colors[i].color = OFF;
     f1c:	10 82       	st	Z, r1
     f1e:	0e 5f       	subi	r16, 0xFE	; 254
     f20:	1f 4f       	sbci	r17, 0xFF	; 255
     f22:	b3 e0       	ldi	r27, 0x03	; 3
     f24:	2b 0e       	add	r2, r27
     f26:	31 1c       	adc	r3, r1
     f28:	ef ef       	ldi	r30, 0xFF	; 255
     f2a:	4e 1a       	sub	r4, r30
     f2c:	5e 0a       	sbc	r5, r30
	
	// This is where we store all the actual color values we want to send to the LED
	struct RGB_Color rgb_colors[NUMBER_OF_LEDS];
	
		
	for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
     f2e:	06 15       	cp	r16, r6
     f30:	17 05       	cpc	r17, r7
     f32:	09 f0       	breq	.+2      	; 0xf36 <tinyLED_update+0x314>
     f34:	eb ce       	rjmp	.-554    	; 0xd0c <tinyLED_update+0xea>
     f36:	cd 84       	ldd	r12, Y+13	; 0x0d
     f38:	de 84       	ldd	r13, Y+14	; 0x0e
				break;
		}
	}
	
	// We only write to the LEDs if there is something to change. (In SWING mode, we update the LEDs every cycle)
	if(!tinyLED_RGB_Color_Compare(&rgb_colors, &tinyLED_old_colors)){
     f3a:	6b e5       	ldi	r22, 0x5B	; 91
     f3c:	78 e3       	ldi	r23, 0x38	; 56
     f3e:	ce 01       	movw	r24, r28
     f40:	01 96       	adiw	r24, 0x01	; 1
     f42:	0e 94 e1 05 	call	0xbc2	; 0xbc2 <tinyLED_RGB_Color_Compare>
     f46:	81 11       	cpse	r24, r1
     f48:	2f c0       	rjmp	.+94     	; 0xfa8 <tinyLED_update+0x386>
     f4a:	0b e5       	ldi	r16, 0x5B	; 91
     f4c:	18 e3       	ldi	r17, 0x38	; 56
     f4e:	7e 01       	movw	r14, r28
     f50:	f7 e0       	ldi	r31, 0x07	; 7
     f52:	ef 0e       	add	r14, r31
     f54:	f1 1c       	adc	r15, r1
		for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
		{
			// Write to LEDs
			//For some reason, the data-bus to the LEDs is serialized as GRB
			//which means the 24-bit data-bus will look like [Green[0:7], Red[0:7], Blue[0:7]]
			tinyLED_SPIWriteByte(rgb_colors[i].green);
     f56:	d6 01       	movw	r26, r12
     f58:	11 96       	adiw	r26, 0x01	; 1
     f5a:	8c 91       	ld	r24, X
     f5c:	0e 94 ac 05 	call	0xb58	; 0xb58 <tinyLED_SPIWriteByte>
			tinyLED_SPIWriteByte(rgb_colors[i].red);
     f60:	f6 01       	movw	r30, r12
     f62:	80 81       	ld	r24, Z
     f64:	0e 94 ac 05 	call	0xb58	; 0xb58 <tinyLED_SPIWriteByte>
			tinyLED_SPIWriteByte(rgb_colors[i].blue);
     f68:	d6 01       	movw	r26, r12
     f6a:	12 96       	adiw	r26, 0x02	; 2
     f6c:	8c 91       	ld	r24, X
     f6e:	0e 94 ac 05 	call	0xb58	; 0xb58 <tinyLED_SPIWriteByte>
			tinyLED_old_colors[i] = rgb_colors[i];
     f72:	f6 01       	movw	r30, r12
     f74:	81 91       	ld	r24, Z+
     f76:	91 91       	ld	r25, Z+
     f78:	a1 91       	ld	r26, Z+
     f7a:	6f 01       	movw	r12, r30
     f7c:	f8 01       	movw	r30, r16
     f7e:	81 93       	st	Z+, r24
     f80:	91 93       	st	Z+, r25
     f82:	a1 93       	st	Z+, r26
     f84:	8f 01       	movw	r16, r30
		}
	}
	
	// We only write to the LEDs if there is something to change. (In SWING mode, we update the LEDs every cycle)
	if(!tinyLED_RGB_Color_Compare(&rgb_colors, &tinyLED_old_colors)){
		for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
     f86:	ce 14       	cp	r12, r14
     f88:	df 04       	cpc	r13, r15
     f8a:	29 f7       	brne	.-54     	; 0xf56 <tinyLED_update+0x334>
			tinyLED_SPIWriteByte(rgb_colors[i].green);
			tinyLED_SPIWriteByte(rgb_colors[i].red);
			tinyLED_SPIWriteByte(rgb_colors[i].blue);
			tinyLED_old_colors[i] = rgb_colors[i];
	}
		tinyDebugger_send_uint8("LED1 color", tinyLED_colors[0].color);
     f8c:	01 e6       	ldi	r16, 0x61	; 97
     f8e:	18 e3       	ldi	r17, 0x38	; 56
     f90:	d8 01       	movw	r26, r16
     f92:	6c 91       	ld	r22, X
     f94:	8e e1       	ldi	r24, 0x1E	; 30
     f96:	94 ea       	ldi	r25, 0xA4	; 164
     f98:	0e 94 4b 04 	call	0x896	; 0x896 <tinyDebugger_send_uint8>
		tinyDebugger_send_uint8("LED2 color", tinyLED_colors[1].color);
     f9c:	f8 01       	movw	r30, r16
     f9e:	62 81       	ldd	r22, Z+2	; 0x02
     fa0:	89 e2       	ldi	r24, 0x29	; 41
     fa2:	94 ea       	ldi	r25, 0xA4	; 164
     fa4:	0e 94 4b 04 	call	0x896	; 0x896 <tinyDebugger_send_uint8>
	}
}
     fa8:	6e 96       	adiw	r28, 0x1e	; 30
     faa:	cd bf       	out	0x3d, r28	; 61
     fac:	de bf       	out	0x3e, r29	; 62
     fae:	df 91       	pop	r29
     fb0:	cf 91       	pop	r28
     fb2:	1f 91       	pop	r17
     fb4:	0f 91       	pop	r16
     fb6:	ff 90       	pop	r15
     fb8:	ef 90       	pop	r14
     fba:	df 90       	pop	r13
     fbc:	cf 90       	pop	r12
     fbe:	bf 90       	pop	r11
     fc0:	af 90       	pop	r10
     fc2:	9f 90       	pop	r9
     fc4:	8f 90       	pop	r8
     fc6:	7f 90       	pop	r7
     fc8:	6f 90       	pop	r6
     fca:	5f 90       	pop	r5
     fcc:	4f 90       	pop	r4
     fce:	3f 90       	pop	r3
     fd0:	2f 90       	pop	r2
     fd2:	08 95       	ret

00000fd4 <tinyPotential_update>:

/*
Update the potential
*/
void tinyPotential_update()
{
     fd4:	cf 92       	push	r12
     fd6:	df 92       	push	r13
     fd8:	ef 92       	push	r14
     fda:	ff 92       	push	r15
Function to decay the potential towards 0
*/
static void tinyPotential_decay()
{
		
	uint8_t time_since_last_update = tinyTime_now() - previous_update_time;
     fdc:	0e 94 cd 08 	call	0x119a	; 0x119a <tinyTime_now>
	tinyPotential_potential *= (exp(-((float)time_since_last_update/(float)TINYPOTENTIAL_TIME_CONST)));
     fe0:	80 91 45 38 	lds	r24, 0x3845	; 0x803845 <previous_update_time>
     fe4:	68 1b       	sub	r22, r24
     fe6:	70 e0       	ldi	r23, 0x00	; 0
     fe8:	80 e0       	ldi	r24, 0x00	; 0
     fea:	90 e0       	ldi	r25, 0x00	; 0
     fec:	0e 94 23 0a 	call	0x1446	; 0x1446 <__floatunsisf>
     ff0:	20 e0       	ldi	r18, 0x00	; 0
     ff2:	30 e0       	ldi	r19, 0x00	; 0
     ff4:	48 ec       	ldi	r20, 0xC8	; 200
     ff6:	52 e4       	ldi	r21, 0x42	; 66
     ff8:	0e 94 48 09 	call	0x1290	; 0x1290 <__divsf3>
     ffc:	90 58       	subi	r25, 0x80	; 128
     ffe:	0e 94 c2 09 	call	0x1384	; 0x1384 <exp>
    1002:	20 91 49 38 	lds	r18, 0x3849	; 0x803849 <tinyPotential_potential>
    1006:	30 91 4a 38 	lds	r19, 0x384A	; 0x80384a <tinyPotential_potential+0x1>
    100a:	40 91 4b 38 	lds	r20, 0x384B	; 0x80384b <tinyPotential_potential+0x2>
    100e:	50 91 4c 38 	lds	r21, 0x384C	; 0x80384c <tinyPotential_potential+0x3>
    1012:	0e 94 96 0b 	call	0x172c	; 0x172c <__mulsf3>
    1016:	6b 01       	movw	r12, r22
    1018:	7c 01       	movw	r14, r24
	if(fabs(tinyPotential_potential)<0.1){
    101a:	9f 77       	andi	r25, 0x7F	; 127
    101c:	2d ec       	ldi	r18, 0xCD	; 205
    101e:	3c ec       	ldi	r19, 0xCC	; 204
    1020:	4c ec       	ldi	r20, 0xCC	; 204
    1022:	5d e3       	ldi	r21, 0x3D	; 61
    1024:	0e 94 43 09 	call	0x1286	; 0x1286 <__cmpsf2>
    1028:	88 23       	and	r24, r24
    102a:	4c f0       	brlt	.+18     	; 0x103e <tinyPotential_update+0x6a>
*/
static void tinyPotential_decay()
{
		
	uint8_t time_since_last_update = tinyTime_now() - previous_update_time;
	tinyPotential_potential *= (exp(-((float)time_since_last_update/(float)TINYPOTENTIAL_TIME_CONST)));
    102c:	c0 92 49 38 	sts	0x3849, r12	; 0x803849 <tinyPotential_potential>
    1030:	d0 92 4a 38 	sts	0x384A, r13	; 0x80384a <tinyPotential_potential+0x1>
    1034:	e0 92 4b 38 	sts	0x384B, r14	; 0x80384b <tinyPotential_potential+0x2>
    1038:	f0 92 4c 38 	sts	0x384C, r15	; 0x80384c <tinyPotential_potential+0x3>
    103c:	08 c0       	rjmp	.+16     	; 0x104e <tinyPotential_update+0x7a>
	if(fabs(tinyPotential_potential)<0.1){
		tinyPotential_potential=0;
    103e:	10 92 49 38 	sts	0x3849, r1	; 0x803849 <tinyPotential_potential>
    1042:	10 92 4a 38 	sts	0x384A, r1	; 0x80384a <tinyPotential_potential+0x1>
    1046:	10 92 4b 38 	sts	0x384B, r1	; 0x80384b <tinyPotential_potential+0x2>
    104a:	10 92 4c 38 	sts	0x384C, r1	; 0x80384c <tinyPotential_potential+0x3>
	}
	previous_update_time = tinyTime_now();
    104e:	0e 94 cd 08 	call	0x119a	; 0x119a <tinyTime_now>
    1052:	60 93 45 38 	sts	0x3845, r22	; 0x803845 <previous_update_time>
    1056:	70 93 46 38 	sts	0x3846, r23	; 0x803846 <previous_update_time+0x1>
    105a:	80 93 47 38 	sts	0x3847, r24	; 0x803847 <previous_update_time+0x2>
    105e:	90 93 48 38 	sts	0x3848, r25	; 0x803848 <previous_update_time+0x3>
void tinyPotential_update()
{
	//Some of the potential in the neuron has decayed away
	tinyPotential_decay();
	// Update potential with values from Dendrites
	tinyPotential_potential = tinyDendrite_update_potential(tinyPotential_potential);
    1062:	60 91 49 38 	lds	r22, 0x3849	; 0x803849 <tinyPotential_potential>
    1066:	70 91 4a 38 	lds	r23, 0x384A	; 0x80384a <tinyPotential_potential+0x1>
    106a:	80 91 4b 38 	lds	r24, 0x384B	; 0x80384b <tinyPotential_potential+0x2>
    106e:	90 91 4c 38 	lds	r25, 0x384C	; 0x80384c <tinyPotential_potential+0x3>
    1072:	0e 94 64 05 	call	0xac8	; 0xac8 <tinyDendrite_update_potential>
    1076:	ab 01       	movw	r20, r22
    1078:	bc 01       	movw	r22, r24
    107a:	40 93 49 38 	sts	0x3849, r20	; 0x803849 <tinyPotential_potential>
    107e:	50 93 4a 38 	sts	0x384A, r21	; 0x80384a <tinyPotential_potential+0x1>
    1082:	60 93 4b 38 	sts	0x384B, r22	; 0x80384b <tinyPotential_potential+0x2>
    1086:	70 93 4c 38 	sts	0x384C, r23	; 0x80384c <tinyPotential_potential+0x3>
	tinyDebugger_send_double("DendP", tinyPotential_potential);
    108a:	84 e3       	ldi	r24, 0x34	; 52
    108c:	94 ea       	ldi	r25, 0xA4	; 164
    108e:	0e 94 60 04 	call	0x8c0	; 0x8c0 <tinyDebugger_send_double>
	
	// Update potential from button press
	tinyPotential_potential = tinyButton_update_potential(tinyPotential_potential);
    1092:	60 91 49 38 	lds	r22, 0x3849	; 0x803849 <tinyPotential_potential>
    1096:	70 91 4a 38 	lds	r23, 0x384A	; 0x80384a <tinyPotential_potential+0x1>
    109a:	80 91 4b 38 	lds	r24, 0x384B	; 0x80384b <tinyPotential_potential+0x2>
    109e:	90 91 4c 38 	lds	r25, 0x384C	; 0x80384c <tinyPotential_potential+0x3>
    10a2:	0e 94 f8 03 	call	0x7f0	; 0x7f0 <tinyButton_update_potential>
    10a6:	60 93 49 38 	sts	0x3849, r22	; 0x803849 <tinyPotential_potential>
    10aa:	70 93 4a 38 	sts	0x384A, r23	; 0x80384a <tinyPotential_potential+0x1>
    10ae:	80 93 4b 38 	sts	0x384B, r24	; 0x80384b <tinyPotential_potential+0x2>
    10b2:	90 93 4c 38 	sts	0x384C, r25	; 0x80384c <tinyPotential_potential+0x3>
	
	// Update potential with values from spontaneous pulse.
	tinyPotential_potential = tinyPulse_update_potential(tinyPotential_potential);
    10b6:	0e 94 81 08 	call	0x1102	; 0x1102 <tinyPulse_update_potential>
    10ba:	60 93 49 38 	sts	0x3849, r22	; 0x803849 <tinyPotential_potential>
    10be:	70 93 4a 38 	sts	0x384A, r23	; 0x80384a <tinyPotential_potential+0x1>
    10c2:	80 93 4b 38 	sts	0x384B, r24	; 0x80384b <tinyPotential_potential+0x2>
    10c6:	90 93 4c 38 	sts	0x384C, r25	; 0x80384c <tinyPotential_potential+0x3>
	
	// Let the axon affect the potential
	// This is also where we decide whether or not the axon should fire
	tinyPotential_potential = tinyAxon_update_potential(tinyPotential_potential);
    10ca:	0e 94 ef 02 	call	0x5de	; 0x5de <tinyAxon_update_potential>
    10ce:	ab 01       	movw	r20, r22
    10d0:	bc 01       	movw	r22, r24
    10d2:	40 93 49 38 	sts	0x3849, r20	; 0x803849 <tinyPotential_potential>
    10d6:	50 93 4a 38 	sts	0x384A, r21	; 0x80384a <tinyPotential_potential+0x1>
    10da:	60 93 4b 38 	sts	0x384B, r22	; 0x80384b <tinyPotential_potential+0x2>
    10de:	70 93 4c 38 	sts	0x384C, r23	; 0x80384c <tinyPotential_potential+0x3>
	tinyDebugger_send_double("AxonP", tinyPotential_potential);
    10e2:	8a e3       	ldi	r24, 0x3A	; 58
    10e4:	94 ea       	ldi	r25, 0xA4	; 164
    10e6:	0e 94 60 04 	call	0x8c0	; 0x8c0 <tinyDebugger_send_double>
}
    10ea:	ff 90       	pop	r15
    10ec:	ef 90       	pop	r14
    10ee:	df 90       	pop	r13
    10f0:	cf 90       	pop	r12
    10f2:	08 95       	ret

000010f4 <tinyPulse_toggle_pulse_mode>:
uint32_t time_of_last_pulse = 0;
uint16_t time_since_last_pulse = 0;
uint16_t ideal_time_between_pulses = 1000/PULSEMODE_FREQUENCY;

void tinyPulse_toggle_pulse_mode(){
	pulse_mode = !pulse_mode;
    10f4:	90 91 53 38 	lds	r25, 0x3853	; 0x803853 <pulse_mode>
    10f8:	81 e0       	ldi	r24, 0x01	; 1
    10fa:	89 27       	eor	r24, r25
    10fc:	80 93 53 38 	sts	0x3853, r24	; 0x803853 <pulse_mode>
    1100:	08 95       	ret

00001102 <tinyPulse_update_potential>:
}

double tinyPulse_update_potential(double potential){
    1102:	cf 92       	push	r12
    1104:	df 92       	push	r13
    1106:	ef 92       	push	r14
    1108:	ff 92       	push	r15
    110a:	6b 01       	movw	r12, r22
    110c:	7c 01       	movw	r14, r24
	if(pulse_mode){
    110e:	80 91 53 38 	lds	r24, 0x3853	; 0x803853 <pulse_mode>
    1112:	88 23       	and	r24, r24
    1114:	39 f1       	breq	.+78     	; 0x1164 <tinyPulse_update_potential+0x62>
		
		time_since_last_pulse = tinyTime_now() - time_of_last_pulse;
    1116:	0e 94 cd 08 	call	0x119a	; 0x119a <tinyTime_now>
    111a:	20 91 4f 38 	lds	r18, 0x384F	; 0x80384f <time_of_last_pulse>
    111e:	30 91 50 38 	lds	r19, 0x3850	; 0x803850 <time_of_last_pulse+0x1>
    1122:	62 1b       	sub	r22, r18
    1124:	73 0b       	sbc	r23, r19
    1126:	60 93 4d 38 	sts	0x384D, r22	; 0x80384d <time_since_last_pulse>
    112a:	70 93 4e 38 	sts	0x384E, r23	; 0x80384e <time_since_last_pulse+0x1>
		
		if(time_since_last_pulse >= ideal_time_between_pulses){
    112e:	80 91 14 38 	lds	r24, 0x3814	; 0x803814 <ideal_time_between_pulses>
    1132:	90 91 15 38 	lds	r25, 0x3815	; 0x803815 <ideal_time_between_pulses+0x1>
    1136:	68 17       	cp	r22, r24
    1138:	79 07       	cpc	r23, r25
    113a:	a0 f0       	brcs	.+40     	; 0x1164 <tinyPulse_update_potential+0x62>
			// This isn't actually a button press. You could have a separate variable for this, but it seems unnecessary.
			potential += BUTTON_PRESS_REACTION;
    113c:	20 e0       	ldi	r18, 0x00	; 0
    113e:	30 e0       	ldi	r19, 0x00	; 0
    1140:	40 ed       	ldi	r20, 0xD0	; 208
    1142:	51 e4       	ldi	r21, 0x41	; 65
    1144:	c7 01       	movw	r24, r14
    1146:	b6 01       	movw	r22, r12
    1148:	0e 94 d7 08 	call	0x11ae	; 0x11ae <__addsf3>
    114c:	6b 01       	movw	r12, r22
    114e:	7c 01       	movw	r14, r24
			time_of_last_pulse = tinyTime_now();			
    1150:	0e 94 cd 08 	call	0x119a	; 0x119a <tinyTime_now>
    1154:	60 93 4f 38 	sts	0x384F, r22	; 0x80384f <time_of_last_pulse>
    1158:	70 93 50 38 	sts	0x3850, r23	; 0x803850 <time_of_last_pulse+0x1>
    115c:	80 93 51 38 	sts	0x3851, r24	; 0x803851 <time_of_last_pulse+0x2>
    1160:	90 93 52 38 	sts	0x3852, r25	; 0x803852 <time_of_last_pulse+0x3>
		}
	}
	return potential;
}
    1164:	c7 01       	movw	r24, r14
    1166:	b6 01       	movw	r22, r12
    1168:	ff 90       	pop	r15
    116a:	ef 90       	pop	r14
    116c:	df 90       	pop	r13
    116e:	cf 90       	pop	r12
    1170:	08 95       	ret

00001172 <tinyTime_counter_increment>:
If the Interrupt Service Routine is clocked by a crystal oscillator
it gives a very precise timer-counter.
*/
void tinyTime_counter_increment(void)
{
	time_counter++;
    1172:	80 91 54 38 	lds	r24, 0x3854	; 0x803854 <time_counter>
    1176:	90 91 55 38 	lds	r25, 0x3855	; 0x803855 <time_counter+0x1>
    117a:	a0 91 56 38 	lds	r26, 0x3856	; 0x803856 <time_counter+0x2>
    117e:	b0 91 57 38 	lds	r27, 0x3857	; 0x803857 <time_counter+0x3>
    1182:	01 96       	adiw	r24, 0x01	; 1
    1184:	a1 1d       	adc	r26, r1
    1186:	b1 1d       	adc	r27, r1
    1188:	80 93 54 38 	sts	0x3854, r24	; 0x803854 <time_counter>
    118c:	90 93 55 38 	sts	0x3855, r25	; 0x803855 <time_counter+0x1>
    1190:	a0 93 56 38 	sts	0x3856, r26	; 0x803856 <time_counter+0x2>
    1194:	b0 93 57 38 	sts	0x3857, r27	; 0x803857 <time_counter+0x3>
    1198:	08 95       	ret

0000119a <tinyTime_now>:
/*
This function is callable by external libraries to give them the counted time so far.
*/
uint32_t tinyTime_now(void)
{
	return time_counter;
    119a:	60 91 54 38 	lds	r22, 0x3854	; 0x803854 <time_counter>
    119e:	70 91 55 38 	lds	r23, 0x3855	; 0x803855 <time_counter+0x1>
    11a2:	80 91 56 38 	lds	r24, 0x3856	; 0x803856 <time_counter+0x2>
    11a6:	90 91 57 38 	lds	r25, 0x3857	; 0x803857 <time_counter+0x3>
    11aa:	08 95       	ret

000011ac <__subsf3>:
    11ac:	50 58       	subi	r21, 0x80	; 128

000011ae <__addsf3>:
    11ae:	bb 27       	eor	r27, r27
    11b0:	aa 27       	eor	r26, r26
    11b2:	0e 94 ee 08 	call	0x11dc	; 0x11dc <__addsf3x>
    11b6:	0c 94 e1 0a 	jmp	0x15c2	; 0x15c2 <__fp_round>
    11ba:	0e 94 d3 0a 	call	0x15a6	; 0x15a6 <__fp_pscA>
    11be:	38 f0       	brcs	.+14     	; 0x11ce <__addsf3+0x20>
    11c0:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <__fp_pscB>
    11c4:	20 f0       	brcs	.+8      	; 0x11ce <__addsf3+0x20>
    11c6:	39 f4       	brne	.+14     	; 0x11d6 <__addsf3+0x28>
    11c8:	9f 3f       	cpi	r25, 0xFF	; 255
    11ca:	19 f4       	brne	.+6      	; 0x11d2 <__addsf3+0x24>
    11cc:	26 f4       	brtc	.+8      	; 0x11d6 <__addsf3+0x28>
    11ce:	0c 94 a9 0a 	jmp	0x1552	; 0x1552 <__fp_nan>
    11d2:	0e f4       	brtc	.+2      	; 0x11d6 <__addsf3+0x28>
    11d4:	e0 95       	com	r30
    11d6:	e7 fb       	bst	r30, 7
    11d8:	0c 94 a3 0a 	jmp	0x1546	; 0x1546 <__fp_inf>

000011dc <__addsf3x>:
    11dc:	e9 2f       	mov	r30, r25
    11de:	0e 94 f2 0a 	call	0x15e4	; 0x15e4 <__fp_split3>
    11e2:	58 f3       	brcs	.-42     	; 0x11ba <__addsf3+0xc>
    11e4:	ba 17       	cp	r27, r26
    11e6:	62 07       	cpc	r22, r18
    11e8:	73 07       	cpc	r23, r19
    11ea:	84 07       	cpc	r24, r20
    11ec:	95 07       	cpc	r25, r21
    11ee:	20 f0       	brcs	.+8      	; 0x11f8 <__addsf3x+0x1c>
    11f0:	79 f4       	brne	.+30     	; 0x1210 <__addsf3x+0x34>
    11f2:	a6 f5       	brtc	.+104    	; 0x125c <__addsf3x+0x80>
    11f4:	0c 94 14 0b 	jmp	0x1628	; 0x1628 <__fp_zero>
    11f8:	0e f4       	brtc	.+2      	; 0x11fc <__addsf3x+0x20>
    11fa:	e0 95       	com	r30
    11fc:	0b 2e       	mov	r0, r27
    11fe:	ba 2f       	mov	r27, r26
    1200:	a0 2d       	mov	r26, r0
    1202:	0b 01       	movw	r0, r22
    1204:	b9 01       	movw	r22, r18
    1206:	90 01       	movw	r18, r0
    1208:	0c 01       	movw	r0, r24
    120a:	ca 01       	movw	r24, r20
    120c:	a0 01       	movw	r20, r0
    120e:	11 24       	eor	r1, r1
    1210:	ff 27       	eor	r31, r31
    1212:	59 1b       	sub	r21, r25
    1214:	99 f0       	breq	.+38     	; 0x123c <__addsf3x+0x60>
    1216:	59 3f       	cpi	r21, 0xF9	; 249
    1218:	50 f4       	brcc	.+20     	; 0x122e <__addsf3x+0x52>
    121a:	50 3e       	cpi	r21, 0xE0	; 224
    121c:	68 f1       	brcs	.+90     	; 0x1278 <__addsf3x+0x9c>
    121e:	1a 16       	cp	r1, r26
    1220:	f0 40       	sbci	r31, 0x00	; 0
    1222:	a2 2f       	mov	r26, r18
    1224:	23 2f       	mov	r18, r19
    1226:	34 2f       	mov	r19, r20
    1228:	44 27       	eor	r20, r20
    122a:	58 5f       	subi	r21, 0xF8	; 248
    122c:	f3 cf       	rjmp	.-26     	; 0x1214 <__addsf3x+0x38>
    122e:	46 95       	lsr	r20
    1230:	37 95       	ror	r19
    1232:	27 95       	ror	r18
    1234:	a7 95       	ror	r26
    1236:	f0 40       	sbci	r31, 0x00	; 0
    1238:	53 95       	inc	r21
    123a:	c9 f7       	brne	.-14     	; 0x122e <__addsf3x+0x52>
    123c:	7e f4       	brtc	.+30     	; 0x125c <__addsf3x+0x80>
    123e:	1f 16       	cp	r1, r31
    1240:	ba 0b       	sbc	r27, r26
    1242:	62 0b       	sbc	r22, r18
    1244:	73 0b       	sbc	r23, r19
    1246:	84 0b       	sbc	r24, r20
    1248:	ba f0       	brmi	.+46     	; 0x1278 <__addsf3x+0x9c>
    124a:	91 50       	subi	r25, 0x01	; 1
    124c:	a1 f0       	breq	.+40     	; 0x1276 <__addsf3x+0x9a>
    124e:	ff 0f       	add	r31, r31
    1250:	bb 1f       	adc	r27, r27
    1252:	66 1f       	adc	r22, r22
    1254:	77 1f       	adc	r23, r23
    1256:	88 1f       	adc	r24, r24
    1258:	c2 f7       	brpl	.-16     	; 0x124a <__addsf3x+0x6e>
    125a:	0e c0       	rjmp	.+28     	; 0x1278 <__addsf3x+0x9c>
    125c:	ba 0f       	add	r27, r26
    125e:	62 1f       	adc	r22, r18
    1260:	73 1f       	adc	r23, r19
    1262:	84 1f       	adc	r24, r20
    1264:	48 f4       	brcc	.+18     	; 0x1278 <__addsf3x+0x9c>
    1266:	87 95       	ror	r24
    1268:	77 95       	ror	r23
    126a:	67 95       	ror	r22
    126c:	b7 95       	ror	r27
    126e:	f7 95       	ror	r31
    1270:	9e 3f       	cpi	r25, 0xFE	; 254
    1272:	08 f0       	brcs	.+2      	; 0x1276 <__addsf3x+0x9a>
    1274:	b0 cf       	rjmp	.-160    	; 0x11d6 <__addsf3+0x28>
    1276:	93 95       	inc	r25
    1278:	88 0f       	add	r24, r24
    127a:	08 f0       	brcs	.+2      	; 0x127e <__addsf3x+0xa2>
    127c:	99 27       	eor	r25, r25
    127e:	ee 0f       	add	r30, r30
    1280:	97 95       	ror	r25
    1282:	87 95       	ror	r24
    1284:	08 95       	ret

00001286 <__cmpsf2>:
    1286:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <__fp_cmp>
    128a:	08 f4       	brcc	.+2      	; 0x128e <__cmpsf2+0x8>
    128c:	81 e0       	ldi	r24, 0x01	; 1
    128e:	08 95       	ret

00001290 <__divsf3>:
    1290:	0e 94 5c 09 	call	0x12b8	; 0x12b8 <__divsf3x>
    1294:	0c 94 e1 0a 	jmp	0x15c2	; 0x15c2 <__fp_round>
    1298:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <__fp_pscB>
    129c:	58 f0       	brcs	.+22     	; 0x12b4 <__divsf3+0x24>
    129e:	0e 94 d3 0a 	call	0x15a6	; 0x15a6 <__fp_pscA>
    12a2:	40 f0       	brcs	.+16     	; 0x12b4 <__divsf3+0x24>
    12a4:	29 f4       	brne	.+10     	; 0x12b0 <__divsf3+0x20>
    12a6:	5f 3f       	cpi	r21, 0xFF	; 255
    12a8:	29 f0       	breq	.+10     	; 0x12b4 <__divsf3+0x24>
    12aa:	0c 94 a3 0a 	jmp	0x1546	; 0x1546 <__fp_inf>
    12ae:	51 11       	cpse	r21, r1
    12b0:	0c 94 15 0b 	jmp	0x162a	; 0x162a <__fp_szero>
    12b4:	0c 94 a9 0a 	jmp	0x1552	; 0x1552 <__fp_nan>

000012b8 <__divsf3x>:
    12b8:	0e 94 f2 0a 	call	0x15e4	; 0x15e4 <__fp_split3>
    12bc:	68 f3       	brcs	.-38     	; 0x1298 <__divsf3+0x8>

000012be <__divsf3_pse>:
    12be:	99 23       	and	r25, r25
    12c0:	b1 f3       	breq	.-20     	; 0x12ae <__divsf3+0x1e>
    12c2:	55 23       	and	r21, r21
    12c4:	91 f3       	breq	.-28     	; 0x12aa <__divsf3+0x1a>
    12c6:	95 1b       	sub	r25, r21
    12c8:	55 0b       	sbc	r21, r21
    12ca:	bb 27       	eor	r27, r27
    12cc:	aa 27       	eor	r26, r26
    12ce:	62 17       	cp	r22, r18
    12d0:	73 07       	cpc	r23, r19
    12d2:	84 07       	cpc	r24, r20
    12d4:	38 f0       	brcs	.+14     	; 0x12e4 <__divsf3_pse+0x26>
    12d6:	9f 5f       	subi	r25, 0xFF	; 255
    12d8:	5f 4f       	sbci	r21, 0xFF	; 255
    12da:	22 0f       	add	r18, r18
    12dc:	33 1f       	adc	r19, r19
    12de:	44 1f       	adc	r20, r20
    12e0:	aa 1f       	adc	r26, r26
    12e2:	a9 f3       	breq	.-22     	; 0x12ce <__divsf3_pse+0x10>
    12e4:	35 d0       	rcall	.+106    	; 0x1350 <__divsf3_pse+0x92>
    12e6:	0e 2e       	mov	r0, r30
    12e8:	3a f0       	brmi	.+14     	; 0x12f8 <__divsf3_pse+0x3a>
    12ea:	e0 e8       	ldi	r30, 0x80	; 128
    12ec:	32 d0       	rcall	.+100    	; 0x1352 <__divsf3_pse+0x94>
    12ee:	91 50       	subi	r25, 0x01	; 1
    12f0:	50 40       	sbci	r21, 0x00	; 0
    12f2:	e6 95       	lsr	r30
    12f4:	00 1c       	adc	r0, r0
    12f6:	ca f7       	brpl	.-14     	; 0x12ea <__divsf3_pse+0x2c>
    12f8:	2b d0       	rcall	.+86     	; 0x1350 <__divsf3_pse+0x92>
    12fa:	fe 2f       	mov	r31, r30
    12fc:	29 d0       	rcall	.+82     	; 0x1350 <__divsf3_pse+0x92>
    12fe:	66 0f       	add	r22, r22
    1300:	77 1f       	adc	r23, r23
    1302:	88 1f       	adc	r24, r24
    1304:	bb 1f       	adc	r27, r27
    1306:	26 17       	cp	r18, r22
    1308:	37 07       	cpc	r19, r23
    130a:	48 07       	cpc	r20, r24
    130c:	ab 07       	cpc	r26, r27
    130e:	b0 e8       	ldi	r27, 0x80	; 128
    1310:	09 f0       	breq	.+2      	; 0x1314 <__divsf3_pse+0x56>
    1312:	bb 0b       	sbc	r27, r27
    1314:	80 2d       	mov	r24, r0
    1316:	bf 01       	movw	r22, r30
    1318:	ff 27       	eor	r31, r31
    131a:	93 58       	subi	r25, 0x83	; 131
    131c:	5f 4f       	sbci	r21, 0xFF	; 255
    131e:	3a f0       	brmi	.+14     	; 0x132e <__divsf3_pse+0x70>
    1320:	9e 3f       	cpi	r25, 0xFE	; 254
    1322:	51 05       	cpc	r21, r1
    1324:	78 f0       	brcs	.+30     	; 0x1344 <__divsf3_pse+0x86>
    1326:	0c 94 a3 0a 	jmp	0x1546	; 0x1546 <__fp_inf>
    132a:	0c 94 15 0b 	jmp	0x162a	; 0x162a <__fp_szero>
    132e:	5f 3f       	cpi	r21, 0xFF	; 255
    1330:	e4 f3       	brlt	.-8      	; 0x132a <__divsf3_pse+0x6c>
    1332:	98 3e       	cpi	r25, 0xE8	; 232
    1334:	d4 f3       	brlt	.-12     	; 0x132a <__divsf3_pse+0x6c>
    1336:	86 95       	lsr	r24
    1338:	77 95       	ror	r23
    133a:	67 95       	ror	r22
    133c:	b7 95       	ror	r27
    133e:	f7 95       	ror	r31
    1340:	9f 5f       	subi	r25, 0xFF	; 255
    1342:	c9 f7       	brne	.-14     	; 0x1336 <__divsf3_pse+0x78>
    1344:	88 0f       	add	r24, r24
    1346:	91 1d       	adc	r25, r1
    1348:	96 95       	lsr	r25
    134a:	87 95       	ror	r24
    134c:	97 f9       	bld	r25, 7
    134e:	08 95       	ret
    1350:	e1 e0       	ldi	r30, 0x01	; 1
    1352:	66 0f       	add	r22, r22
    1354:	77 1f       	adc	r23, r23
    1356:	88 1f       	adc	r24, r24
    1358:	bb 1f       	adc	r27, r27
    135a:	62 17       	cp	r22, r18
    135c:	73 07       	cpc	r23, r19
    135e:	84 07       	cpc	r24, r20
    1360:	ba 07       	cpc	r27, r26
    1362:	20 f0       	brcs	.+8      	; 0x136c <__divsf3_pse+0xae>
    1364:	62 1b       	sub	r22, r18
    1366:	73 0b       	sbc	r23, r19
    1368:	84 0b       	sbc	r24, r20
    136a:	ba 0b       	sbc	r27, r26
    136c:	ee 1f       	adc	r30, r30
    136e:	88 f7       	brcc	.-30     	; 0x1352 <__divsf3_pse+0x94>
    1370:	e0 95       	com	r30
    1372:	08 95       	ret
    1374:	29 f4       	brne	.+10     	; 0x1380 <__divsf3_pse+0xc2>
    1376:	16 f0       	brts	.+4      	; 0x137c <__divsf3_pse+0xbe>
    1378:	0c 94 a3 0a 	jmp	0x1546	; 0x1546 <__fp_inf>
    137c:	0c 94 14 0b 	jmp	0x1628	; 0x1628 <__fp_zero>
    1380:	0c 94 a9 0a 	jmp	0x1552	; 0x1552 <__fp_nan>

00001384 <exp>:
    1384:	0e 94 fa 0a 	call	0x15f4	; 0x15f4 <__fp_splitA>
    1388:	a8 f3       	brcs	.-22     	; 0x1374 <__divsf3_pse+0xb6>
    138a:	96 38       	cpi	r25, 0x86	; 134
    138c:	a0 f7       	brcc	.-24     	; 0x1376 <__divsf3_pse+0xb8>
    138e:	07 f8       	bld	r0, 7
    1390:	0f 92       	push	r0
    1392:	e8 94       	clt
    1394:	2b e3       	ldi	r18, 0x3B	; 59
    1396:	3a ea       	ldi	r19, 0xAA	; 170
    1398:	48 eb       	ldi	r20, 0xB8	; 184
    139a:	5f e7       	ldi	r21, 0x7F	; 127
    139c:	0e 94 ac 0b 	call	0x1758	; 0x1758 <__mulsf3_pse>
    13a0:	0f 92       	push	r0
    13a2:	0f 92       	push	r0
    13a4:	0f 92       	push	r0
    13a6:	4d b7       	in	r20, 0x3d	; 61
    13a8:	5e b7       	in	r21, 0x3e	; 62
    13aa:	0f 92       	push	r0
    13ac:	0e 94 62 0b 	call	0x16c4	; 0x16c4 <modf>
    13b0:	ec e7       	ldi	r30, 0x7C	; 124
    13b2:	f0 e0       	ldi	r31, 0x00	; 0
    13b4:	0e 94 ac 0a 	call	0x1558	; 0x1558 <__fp_powser>
    13b8:	4f 91       	pop	r20
    13ba:	5f 91       	pop	r21
    13bc:	ef 91       	pop	r30
    13be:	ff 91       	pop	r31
    13c0:	e5 95       	asr	r30
    13c2:	ee 1f       	adc	r30, r30
    13c4:	ff 1f       	adc	r31, r31
    13c6:	49 f0       	breq	.+18     	; 0x13da <exp+0x56>
    13c8:	fe 57       	subi	r31, 0x7E	; 126
    13ca:	e0 68       	ori	r30, 0x80	; 128
    13cc:	44 27       	eor	r20, r20
    13ce:	ee 0f       	add	r30, r30
    13d0:	44 1f       	adc	r20, r20
    13d2:	fa 95       	dec	r31
    13d4:	e1 f7       	brne	.-8      	; 0x13ce <exp+0x4a>
    13d6:	41 95       	neg	r20
    13d8:	55 0b       	sbc	r21, r21
    13da:	0e 94 2c 0b 	call	0x1658	; 0x1658 <ldexp>
    13de:	0f 90       	pop	r0
    13e0:	07 fe       	sbrs	r0, 7
    13e2:	0c 94 20 0b 	jmp	0x1640	; 0x1640 <inverse>
    13e6:	08 95       	ret

000013e8 <__fixunssfsi>:
    13e8:	0e 94 fa 0a 	call	0x15f4	; 0x15f4 <__fp_splitA>
    13ec:	88 f0       	brcs	.+34     	; 0x1410 <__fixunssfsi+0x28>
    13ee:	9f 57       	subi	r25, 0x7F	; 127
    13f0:	98 f0       	brcs	.+38     	; 0x1418 <__fixunssfsi+0x30>
    13f2:	b9 2f       	mov	r27, r25
    13f4:	99 27       	eor	r25, r25
    13f6:	b7 51       	subi	r27, 0x17	; 23
    13f8:	b0 f0       	brcs	.+44     	; 0x1426 <__fixunssfsi+0x3e>
    13fa:	e1 f0       	breq	.+56     	; 0x1434 <__fixunssfsi+0x4c>
    13fc:	66 0f       	add	r22, r22
    13fe:	77 1f       	adc	r23, r23
    1400:	88 1f       	adc	r24, r24
    1402:	99 1f       	adc	r25, r25
    1404:	1a f0       	brmi	.+6      	; 0x140c <__fixunssfsi+0x24>
    1406:	ba 95       	dec	r27
    1408:	c9 f7       	brne	.-14     	; 0x13fc <__fixunssfsi+0x14>
    140a:	14 c0       	rjmp	.+40     	; 0x1434 <__fixunssfsi+0x4c>
    140c:	b1 30       	cpi	r27, 0x01	; 1
    140e:	91 f0       	breq	.+36     	; 0x1434 <__fixunssfsi+0x4c>
    1410:	0e 94 14 0b 	call	0x1628	; 0x1628 <__fp_zero>
    1414:	b1 e0       	ldi	r27, 0x01	; 1
    1416:	08 95       	ret
    1418:	0c 94 14 0b 	jmp	0x1628	; 0x1628 <__fp_zero>
    141c:	67 2f       	mov	r22, r23
    141e:	78 2f       	mov	r23, r24
    1420:	88 27       	eor	r24, r24
    1422:	b8 5f       	subi	r27, 0xF8	; 248
    1424:	39 f0       	breq	.+14     	; 0x1434 <__fixunssfsi+0x4c>
    1426:	b9 3f       	cpi	r27, 0xF9	; 249
    1428:	cc f3       	brlt	.-14     	; 0x141c <__fixunssfsi+0x34>
    142a:	86 95       	lsr	r24
    142c:	77 95       	ror	r23
    142e:	67 95       	ror	r22
    1430:	b3 95       	inc	r27
    1432:	d9 f7       	brne	.-10     	; 0x142a <__fixunssfsi+0x42>
    1434:	3e f4       	brtc	.+14     	; 0x1444 <__fixunssfsi+0x5c>
    1436:	90 95       	com	r25
    1438:	80 95       	com	r24
    143a:	70 95       	com	r23
    143c:	61 95       	neg	r22
    143e:	7f 4f       	sbci	r23, 0xFF	; 255
    1440:	8f 4f       	sbci	r24, 0xFF	; 255
    1442:	9f 4f       	sbci	r25, 0xFF	; 255
    1444:	08 95       	ret

00001446 <__floatunsisf>:
    1446:	e8 94       	clt
    1448:	09 c0       	rjmp	.+18     	; 0x145c <__floatsisf+0x12>

0000144a <__floatsisf>:
    144a:	97 fb       	bst	r25, 7
    144c:	3e f4       	brtc	.+14     	; 0x145c <__floatsisf+0x12>
    144e:	90 95       	com	r25
    1450:	80 95       	com	r24
    1452:	70 95       	com	r23
    1454:	61 95       	neg	r22
    1456:	7f 4f       	sbci	r23, 0xFF	; 255
    1458:	8f 4f       	sbci	r24, 0xFF	; 255
    145a:	9f 4f       	sbci	r25, 0xFF	; 255
    145c:	99 23       	and	r25, r25
    145e:	a9 f0       	breq	.+42     	; 0x148a <__floatsisf+0x40>
    1460:	f9 2f       	mov	r31, r25
    1462:	96 e9       	ldi	r25, 0x96	; 150
    1464:	bb 27       	eor	r27, r27
    1466:	93 95       	inc	r25
    1468:	f6 95       	lsr	r31
    146a:	87 95       	ror	r24
    146c:	77 95       	ror	r23
    146e:	67 95       	ror	r22
    1470:	b7 95       	ror	r27
    1472:	f1 11       	cpse	r31, r1
    1474:	f8 cf       	rjmp	.-16     	; 0x1466 <__floatsisf+0x1c>
    1476:	fa f4       	brpl	.+62     	; 0x14b6 <__floatsisf+0x6c>
    1478:	bb 0f       	add	r27, r27
    147a:	11 f4       	brne	.+4      	; 0x1480 <__floatsisf+0x36>
    147c:	60 ff       	sbrs	r22, 0
    147e:	1b c0       	rjmp	.+54     	; 0x14b6 <__floatsisf+0x6c>
    1480:	6f 5f       	subi	r22, 0xFF	; 255
    1482:	7f 4f       	sbci	r23, 0xFF	; 255
    1484:	8f 4f       	sbci	r24, 0xFF	; 255
    1486:	9f 4f       	sbci	r25, 0xFF	; 255
    1488:	16 c0       	rjmp	.+44     	; 0x14b6 <__floatsisf+0x6c>
    148a:	88 23       	and	r24, r24
    148c:	11 f0       	breq	.+4      	; 0x1492 <__floatsisf+0x48>
    148e:	96 e9       	ldi	r25, 0x96	; 150
    1490:	11 c0       	rjmp	.+34     	; 0x14b4 <__floatsisf+0x6a>
    1492:	77 23       	and	r23, r23
    1494:	21 f0       	breq	.+8      	; 0x149e <__floatsisf+0x54>
    1496:	9e e8       	ldi	r25, 0x8E	; 142
    1498:	87 2f       	mov	r24, r23
    149a:	76 2f       	mov	r23, r22
    149c:	05 c0       	rjmp	.+10     	; 0x14a8 <__floatsisf+0x5e>
    149e:	66 23       	and	r22, r22
    14a0:	71 f0       	breq	.+28     	; 0x14be <__floatsisf+0x74>
    14a2:	96 e8       	ldi	r25, 0x86	; 134
    14a4:	86 2f       	mov	r24, r22
    14a6:	70 e0       	ldi	r23, 0x00	; 0
    14a8:	60 e0       	ldi	r22, 0x00	; 0
    14aa:	2a f0       	brmi	.+10     	; 0x14b6 <__floatsisf+0x6c>
    14ac:	9a 95       	dec	r25
    14ae:	66 0f       	add	r22, r22
    14b0:	77 1f       	adc	r23, r23
    14b2:	88 1f       	adc	r24, r24
    14b4:	da f7       	brpl	.-10     	; 0x14ac <__floatsisf+0x62>
    14b6:	88 0f       	add	r24, r24
    14b8:	96 95       	lsr	r25
    14ba:	87 95       	ror	r24
    14bc:	97 f9       	bld	r25, 7
    14be:	08 95       	ret

000014c0 <fmin>:
    14c0:	99 0f       	add	r25, r25
    14c2:	bb 0b       	sbc	r27, r27
    14c4:	55 0f       	add	r21, r21
    14c6:	aa 0b       	sbc	r26, r26
    14c8:	e0 e8       	ldi	r30, 0x80	; 128
    14ca:	fe ef       	ldi	r31, 0xFE	; 254
    14cc:	16 16       	cp	r1, r22
    14ce:	17 06       	cpc	r1, r23
    14d0:	e8 07       	cpc	r30, r24
    14d2:	f9 07       	cpc	r31, r25
    14d4:	70 f0       	brcs	.+28     	; 0x14f2 <fmin+0x32>
    14d6:	12 16       	cp	r1, r18
    14d8:	13 06       	cpc	r1, r19
    14da:	e4 07       	cpc	r30, r20
    14dc:	f5 07       	cpc	r31, r21
    14de:	60 f0       	brcs	.+24     	; 0x14f8 <fmin+0x38>
    14e0:	ba 17       	cp	r27, r26
    14e2:	54 f0       	brlt	.+20     	; 0x14f8 <fmin+0x38>
    14e4:	31 f4       	brne	.+12     	; 0x14f2 <fmin+0x32>
    14e6:	26 17       	cp	r18, r22
    14e8:	37 07       	cpc	r19, r23
    14ea:	48 07       	cpc	r20, r24
    14ec:	59 07       	cpc	r21, r25
    14ee:	a7 95       	ror	r26
    14f0:	1b f4       	brvc	.+6      	; 0x14f8 <fmin+0x38>
    14f2:	b9 01       	movw	r22, r18
    14f4:	ca 01       	movw	r24, r20
    14f6:	ba 2f       	mov	r27, r26
    14f8:	b6 95       	lsr	r27
    14fa:	97 95       	ror	r25
    14fc:	08 95       	ret

000014fe <__fp_cmp>:
    14fe:	99 0f       	add	r25, r25
    1500:	00 08       	sbc	r0, r0
    1502:	55 0f       	add	r21, r21
    1504:	aa 0b       	sbc	r26, r26
    1506:	e0 e8       	ldi	r30, 0x80	; 128
    1508:	fe ef       	ldi	r31, 0xFE	; 254
    150a:	16 16       	cp	r1, r22
    150c:	17 06       	cpc	r1, r23
    150e:	e8 07       	cpc	r30, r24
    1510:	f9 07       	cpc	r31, r25
    1512:	c0 f0       	brcs	.+48     	; 0x1544 <__fp_cmp+0x46>
    1514:	12 16       	cp	r1, r18
    1516:	13 06       	cpc	r1, r19
    1518:	e4 07       	cpc	r30, r20
    151a:	f5 07       	cpc	r31, r21
    151c:	98 f0       	brcs	.+38     	; 0x1544 <__fp_cmp+0x46>
    151e:	62 1b       	sub	r22, r18
    1520:	73 0b       	sbc	r23, r19
    1522:	84 0b       	sbc	r24, r20
    1524:	95 0b       	sbc	r25, r21
    1526:	39 f4       	brne	.+14     	; 0x1536 <__fp_cmp+0x38>
    1528:	0a 26       	eor	r0, r26
    152a:	61 f0       	breq	.+24     	; 0x1544 <__fp_cmp+0x46>
    152c:	23 2b       	or	r18, r19
    152e:	24 2b       	or	r18, r20
    1530:	25 2b       	or	r18, r21
    1532:	21 f4       	brne	.+8      	; 0x153c <__fp_cmp+0x3e>
    1534:	08 95       	ret
    1536:	0a 26       	eor	r0, r26
    1538:	09 f4       	brne	.+2      	; 0x153c <__fp_cmp+0x3e>
    153a:	a1 40       	sbci	r26, 0x01	; 1
    153c:	a6 95       	lsr	r26
    153e:	8f ef       	ldi	r24, 0xFF	; 255
    1540:	81 1d       	adc	r24, r1
    1542:	81 1d       	adc	r24, r1
    1544:	08 95       	ret

00001546 <__fp_inf>:
    1546:	97 f9       	bld	r25, 7
    1548:	9f 67       	ori	r25, 0x7F	; 127
    154a:	80 e8       	ldi	r24, 0x80	; 128
    154c:	70 e0       	ldi	r23, 0x00	; 0
    154e:	60 e0       	ldi	r22, 0x00	; 0
    1550:	08 95       	ret

00001552 <__fp_nan>:
    1552:	9f ef       	ldi	r25, 0xFF	; 255
    1554:	80 ec       	ldi	r24, 0xC0	; 192
    1556:	08 95       	ret

00001558 <__fp_powser>:
    1558:	df 93       	push	r29
    155a:	cf 93       	push	r28
    155c:	1f 93       	push	r17
    155e:	0f 93       	push	r16
    1560:	ff 92       	push	r15
    1562:	ef 92       	push	r14
    1564:	df 92       	push	r13
    1566:	7b 01       	movw	r14, r22
    1568:	8c 01       	movw	r16, r24
    156a:	68 94       	set
    156c:	06 c0       	rjmp	.+12     	; 0x157a <__fp_powser+0x22>
    156e:	da 2e       	mov	r13, r26
    1570:	ef 01       	movw	r28, r30
    1572:	0e 94 a9 0b 	call	0x1752	; 0x1752 <__mulsf3x>
    1576:	fe 01       	movw	r30, r28
    1578:	e8 94       	clt
    157a:	a5 91       	lpm	r26, Z+
    157c:	25 91       	lpm	r18, Z+
    157e:	35 91       	lpm	r19, Z+
    1580:	45 91       	lpm	r20, Z+
    1582:	55 91       	lpm	r21, Z+
    1584:	a6 f3       	brts	.-24     	; 0x156e <__fp_powser+0x16>
    1586:	ef 01       	movw	r28, r30
    1588:	0e 94 ee 08 	call	0x11dc	; 0x11dc <__addsf3x>
    158c:	fe 01       	movw	r30, r28
    158e:	97 01       	movw	r18, r14
    1590:	a8 01       	movw	r20, r16
    1592:	da 94       	dec	r13
    1594:	69 f7       	brne	.-38     	; 0x1570 <__fp_powser+0x18>
    1596:	df 90       	pop	r13
    1598:	ef 90       	pop	r14
    159a:	ff 90       	pop	r15
    159c:	0f 91       	pop	r16
    159e:	1f 91       	pop	r17
    15a0:	cf 91       	pop	r28
    15a2:	df 91       	pop	r29
    15a4:	08 95       	ret

000015a6 <__fp_pscA>:
    15a6:	00 24       	eor	r0, r0
    15a8:	0a 94       	dec	r0
    15aa:	16 16       	cp	r1, r22
    15ac:	17 06       	cpc	r1, r23
    15ae:	18 06       	cpc	r1, r24
    15b0:	09 06       	cpc	r0, r25
    15b2:	08 95       	ret

000015b4 <__fp_pscB>:
    15b4:	00 24       	eor	r0, r0
    15b6:	0a 94       	dec	r0
    15b8:	12 16       	cp	r1, r18
    15ba:	13 06       	cpc	r1, r19
    15bc:	14 06       	cpc	r1, r20
    15be:	05 06       	cpc	r0, r21
    15c0:	08 95       	ret

000015c2 <__fp_round>:
    15c2:	09 2e       	mov	r0, r25
    15c4:	03 94       	inc	r0
    15c6:	00 0c       	add	r0, r0
    15c8:	11 f4       	brne	.+4      	; 0x15ce <__fp_round+0xc>
    15ca:	88 23       	and	r24, r24
    15cc:	52 f0       	brmi	.+20     	; 0x15e2 <__fp_round+0x20>
    15ce:	bb 0f       	add	r27, r27
    15d0:	40 f4       	brcc	.+16     	; 0x15e2 <__fp_round+0x20>
    15d2:	bf 2b       	or	r27, r31
    15d4:	11 f4       	brne	.+4      	; 0x15da <__fp_round+0x18>
    15d6:	60 ff       	sbrs	r22, 0
    15d8:	04 c0       	rjmp	.+8      	; 0x15e2 <__fp_round+0x20>
    15da:	6f 5f       	subi	r22, 0xFF	; 255
    15dc:	7f 4f       	sbci	r23, 0xFF	; 255
    15de:	8f 4f       	sbci	r24, 0xFF	; 255
    15e0:	9f 4f       	sbci	r25, 0xFF	; 255
    15e2:	08 95       	ret

000015e4 <__fp_split3>:
    15e4:	57 fd       	sbrc	r21, 7
    15e6:	90 58       	subi	r25, 0x80	; 128
    15e8:	44 0f       	add	r20, r20
    15ea:	55 1f       	adc	r21, r21
    15ec:	59 f0       	breq	.+22     	; 0x1604 <__fp_splitA+0x10>
    15ee:	5f 3f       	cpi	r21, 0xFF	; 255
    15f0:	71 f0       	breq	.+28     	; 0x160e <__fp_splitA+0x1a>
    15f2:	47 95       	ror	r20

000015f4 <__fp_splitA>:
    15f4:	88 0f       	add	r24, r24
    15f6:	97 fb       	bst	r25, 7
    15f8:	99 1f       	adc	r25, r25
    15fa:	61 f0       	breq	.+24     	; 0x1614 <__fp_splitA+0x20>
    15fc:	9f 3f       	cpi	r25, 0xFF	; 255
    15fe:	79 f0       	breq	.+30     	; 0x161e <__fp_splitA+0x2a>
    1600:	87 95       	ror	r24
    1602:	08 95       	ret
    1604:	12 16       	cp	r1, r18
    1606:	13 06       	cpc	r1, r19
    1608:	14 06       	cpc	r1, r20
    160a:	55 1f       	adc	r21, r21
    160c:	f2 cf       	rjmp	.-28     	; 0x15f2 <__fp_split3+0xe>
    160e:	46 95       	lsr	r20
    1610:	f1 df       	rcall	.-30     	; 0x15f4 <__fp_splitA>
    1612:	08 c0       	rjmp	.+16     	; 0x1624 <__fp_splitA+0x30>
    1614:	16 16       	cp	r1, r22
    1616:	17 06       	cpc	r1, r23
    1618:	18 06       	cpc	r1, r24
    161a:	99 1f       	adc	r25, r25
    161c:	f1 cf       	rjmp	.-30     	; 0x1600 <__fp_splitA+0xc>
    161e:	86 95       	lsr	r24
    1620:	71 05       	cpc	r23, r1
    1622:	61 05       	cpc	r22, r1
    1624:	08 94       	sec
    1626:	08 95       	ret

00001628 <__fp_zero>:
    1628:	e8 94       	clt

0000162a <__fp_szero>:
    162a:	bb 27       	eor	r27, r27
    162c:	66 27       	eor	r22, r22
    162e:	77 27       	eor	r23, r23
    1630:	cb 01       	movw	r24, r22
    1632:	97 f9       	bld	r25, 7
    1634:	08 95       	ret

00001636 <__gesf2>:
    1636:	0e 94 7f 0a 	call	0x14fe	; 0x14fe <__fp_cmp>
    163a:	08 f4       	brcc	.+2      	; 0x163e <__gesf2+0x8>
    163c:	8f ef       	ldi	r24, 0xFF	; 255
    163e:	08 95       	ret

00001640 <inverse>:
    1640:	9b 01       	movw	r18, r22
    1642:	ac 01       	movw	r20, r24
    1644:	60 e0       	ldi	r22, 0x00	; 0
    1646:	70 e0       	ldi	r23, 0x00	; 0
    1648:	80 e8       	ldi	r24, 0x80	; 128
    164a:	9f e3       	ldi	r25, 0x3F	; 63
    164c:	0c 94 48 09 	jmp	0x1290	; 0x1290 <__divsf3>
    1650:	0c 94 a3 0a 	jmp	0x1546	; 0x1546 <__fp_inf>
    1654:	0c 94 0b 0c 	jmp	0x1816	; 0x1816 <__fp_mpack>

00001658 <ldexp>:
    1658:	0e 94 fa 0a 	call	0x15f4	; 0x15f4 <__fp_splitA>
    165c:	d8 f3       	brcs	.-10     	; 0x1654 <inverse+0x14>
    165e:	99 23       	and	r25, r25
    1660:	c9 f3       	breq	.-14     	; 0x1654 <inverse+0x14>
    1662:	94 0f       	add	r25, r20
    1664:	51 1d       	adc	r21, r1
    1666:	a3 f3       	brvs	.-24     	; 0x1650 <inverse+0x10>
    1668:	91 50       	subi	r25, 0x01	; 1
    166a:	50 40       	sbci	r21, 0x00	; 0
    166c:	94 f0       	brlt	.+36     	; 0x1692 <ldexp+0x3a>
    166e:	59 f0       	breq	.+22     	; 0x1686 <ldexp+0x2e>
    1670:	88 23       	and	r24, r24
    1672:	32 f0       	brmi	.+12     	; 0x1680 <ldexp+0x28>
    1674:	66 0f       	add	r22, r22
    1676:	77 1f       	adc	r23, r23
    1678:	88 1f       	adc	r24, r24
    167a:	91 50       	subi	r25, 0x01	; 1
    167c:	50 40       	sbci	r21, 0x00	; 0
    167e:	c1 f7       	brne	.-16     	; 0x1670 <ldexp+0x18>
    1680:	9e 3f       	cpi	r25, 0xFE	; 254
    1682:	51 05       	cpc	r21, r1
    1684:	2c f7       	brge	.-54     	; 0x1650 <inverse+0x10>
    1686:	88 0f       	add	r24, r24
    1688:	91 1d       	adc	r25, r1
    168a:	96 95       	lsr	r25
    168c:	87 95       	ror	r24
    168e:	97 f9       	bld	r25, 7
    1690:	08 95       	ret
    1692:	5f 3f       	cpi	r21, 0xFF	; 255
    1694:	ac f0       	brlt	.+42     	; 0x16c0 <ldexp+0x68>
    1696:	98 3e       	cpi	r25, 0xE8	; 232
    1698:	9c f0       	brlt	.+38     	; 0x16c0 <ldexp+0x68>
    169a:	bb 27       	eor	r27, r27
    169c:	86 95       	lsr	r24
    169e:	77 95       	ror	r23
    16a0:	67 95       	ror	r22
    16a2:	b7 95       	ror	r27
    16a4:	08 f4       	brcc	.+2      	; 0x16a8 <ldexp+0x50>
    16a6:	b1 60       	ori	r27, 0x01	; 1
    16a8:	93 95       	inc	r25
    16aa:	c1 f7       	brne	.-16     	; 0x169c <ldexp+0x44>
    16ac:	bb 0f       	add	r27, r27
    16ae:	58 f7       	brcc	.-42     	; 0x1686 <ldexp+0x2e>
    16b0:	11 f4       	brne	.+4      	; 0x16b6 <ldexp+0x5e>
    16b2:	60 ff       	sbrs	r22, 0
    16b4:	e8 cf       	rjmp	.-48     	; 0x1686 <ldexp+0x2e>
    16b6:	6f 5f       	subi	r22, 0xFF	; 255
    16b8:	7f 4f       	sbci	r23, 0xFF	; 255
    16ba:	8f 4f       	sbci	r24, 0xFF	; 255
    16bc:	9f 4f       	sbci	r25, 0xFF	; 255
    16be:	e3 cf       	rjmp	.-58     	; 0x1686 <ldexp+0x2e>
    16c0:	0c 94 15 0b 	jmp	0x162a	; 0x162a <__fp_szero>

000016c4 <modf>:
    16c4:	fa 01       	movw	r30, r20
    16c6:	dc 01       	movw	r26, r24
    16c8:	aa 0f       	add	r26, r26
    16ca:	bb 1f       	adc	r27, r27
    16cc:	9b 01       	movw	r18, r22
    16ce:	ac 01       	movw	r20, r24
    16d0:	bf 57       	subi	r27, 0x7F	; 127
    16d2:	28 f4       	brcc	.+10     	; 0x16de <modf+0x1a>
    16d4:	22 27       	eor	r18, r18
    16d6:	33 27       	eor	r19, r19
    16d8:	44 27       	eor	r20, r20
    16da:	50 78       	andi	r21, 0x80	; 128
    16dc:	20 c0       	rjmp	.+64     	; 0x171e <modf+0x5a>
    16de:	b7 51       	subi	r27, 0x17	; 23
    16e0:	90 f4       	brcc	.+36     	; 0x1706 <modf+0x42>
    16e2:	ab 2f       	mov	r26, r27
    16e4:	00 24       	eor	r0, r0
    16e6:	46 95       	lsr	r20
    16e8:	37 95       	ror	r19
    16ea:	27 95       	ror	r18
    16ec:	01 1c       	adc	r0, r1
    16ee:	a3 95       	inc	r26
    16f0:	d2 f3       	brmi	.-12     	; 0x16e6 <modf+0x22>
    16f2:	00 20       	and	r0, r0
    16f4:	71 f0       	breq	.+28     	; 0x1712 <modf+0x4e>
    16f6:	22 0f       	add	r18, r18
    16f8:	33 1f       	adc	r19, r19
    16fa:	44 1f       	adc	r20, r20
    16fc:	b3 95       	inc	r27
    16fe:	da f3       	brmi	.-10     	; 0x16f6 <modf+0x32>
    1700:	0e d0       	rcall	.+28     	; 0x171e <modf+0x5a>
    1702:	0c 94 d6 08 	jmp	0x11ac	; 0x11ac <__subsf3>
    1706:	61 30       	cpi	r22, 0x01	; 1
    1708:	71 05       	cpc	r23, r1
    170a:	a0 e8       	ldi	r26, 0x80	; 128
    170c:	8a 07       	cpc	r24, r26
    170e:	b9 46       	sbci	r27, 0x69	; 105
    1710:	30 f4       	brcc	.+12     	; 0x171e <modf+0x5a>
    1712:	9b 01       	movw	r18, r22
    1714:	ac 01       	movw	r20, r24
    1716:	66 27       	eor	r22, r22
    1718:	77 27       	eor	r23, r23
    171a:	88 27       	eor	r24, r24
    171c:	90 78       	andi	r25, 0x80	; 128
    171e:	30 96       	adiw	r30, 0x00	; 0
    1720:	21 f0       	breq	.+8      	; 0x172a <modf+0x66>
    1722:	20 83       	st	Z, r18
    1724:	31 83       	std	Z+1, r19	; 0x01
    1726:	42 83       	std	Z+2, r20	; 0x02
    1728:	53 83       	std	Z+3, r21	; 0x03
    172a:	08 95       	ret

0000172c <__mulsf3>:
    172c:	0e 94 a9 0b 	call	0x1752	; 0x1752 <__mulsf3x>
    1730:	0c 94 e1 0a 	jmp	0x15c2	; 0x15c2 <__fp_round>
    1734:	0e 94 d3 0a 	call	0x15a6	; 0x15a6 <__fp_pscA>
    1738:	38 f0       	brcs	.+14     	; 0x1748 <__mulsf3+0x1c>
    173a:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <__fp_pscB>
    173e:	20 f0       	brcs	.+8      	; 0x1748 <__mulsf3+0x1c>
    1740:	95 23       	and	r25, r21
    1742:	11 f0       	breq	.+4      	; 0x1748 <__mulsf3+0x1c>
    1744:	0c 94 a3 0a 	jmp	0x1546	; 0x1546 <__fp_inf>
    1748:	0c 94 a9 0a 	jmp	0x1552	; 0x1552 <__fp_nan>
    174c:	11 24       	eor	r1, r1
    174e:	0c 94 15 0b 	jmp	0x162a	; 0x162a <__fp_szero>

00001752 <__mulsf3x>:
    1752:	0e 94 f2 0a 	call	0x15e4	; 0x15e4 <__fp_split3>
    1756:	70 f3       	brcs	.-36     	; 0x1734 <__mulsf3+0x8>

00001758 <__mulsf3_pse>:
    1758:	95 9f       	mul	r25, r21
    175a:	c1 f3       	breq	.-16     	; 0x174c <__mulsf3+0x20>
    175c:	95 0f       	add	r25, r21
    175e:	50 e0       	ldi	r21, 0x00	; 0
    1760:	55 1f       	adc	r21, r21
    1762:	62 9f       	mul	r22, r18
    1764:	f0 01       	movw	r30, r0
    1766:	72 9f       	mul	r23, r18
    1768:	bb 27       	eor	r27, r27
    176a:	f0 0d       	add	r31, r0
    176c:	b1 1d       	adc	r27, r1
    176e:	63 9f       	mul	r22, r19
    1770:	aa 27       	eor	r26, r26
    1772:	f0 0d       	add	r31, r0
    1774:	b1 1d       	adc	r27, r1
    1776:	aa 1f       	adc	r26, r26
    1778:	64 9f       	mul	r22, r20
    177a:	66 27       	eor	r22, r22
    177c:	b0 0d       	add	r27, r0
    177e:	a1 1d       	adc	r26, r1
    1780:	66 1f       	adc	r22, r22
    1782:	82 9f       	mul	r24, r18
    1784:	22 27       	eor	r18, r18
    1786:	b0 0d       	add	r27, r0
    1788:	a1 1d       	adc	r26, r1
    178a:	62 1f       	adc	r22, r18
    178c:	73 9f       	mul	r23, r19
    178e:	b0 0d       	add	r27, r0
    1790:	a1 1d       	adc	r26, r1
    1792:	62 1f       	adc	r22, r18
    1794:	83 9f       	mul	r24, r19
    1796:	a0 0d       	add	r26, r0
    1798:	61 1d       	adc	r22, r1
    179a:	22 1f       	adc	r18, r18
    179c:	74 9f       	mul	r23, r20
    179e:	33 27       	eor	r19, r19
    17a0:	a0 0d       	add	r26, r0
    17a2:	61 1d       	adc	r22, r1
    17a4:	23 1f       	adc	r18, r19
    17a6:	84 9f       	mul	r24, r20
    17a8:	60 0d       	add	r22, r0
    17aa:	21 1d       	adc	r18, r1
    17ac:	82 2f       	mov	r24, r18
    17ae:	76 2f       	mov	r23, r22
    17b0:	6a 2f       	mov	r22, r26
    17b2:	11 24       	eor	r1, r1
    17b4:	9f 57       	subi	r25, 0x7F	; 127
    17b6:	50 40       	sbci	r21, 0x00	; 0
    17b8:	9a f0       	brmi	.+38     	; 0x17e0 <__mulsf3_pse+0x88>
    17ba:	f1 f0       	breq	.+60     	; 0x17f8 <__mulsf3_pse+0xa0>
    17bc:	88 23       	and	r24, r24
    17be:	4a f0       	brmi	.+18     	; 0x17d2 <__mulsf3_pse+0x7a>
    17c0:	ee 0f       	add	r30, r30
    17c2:	ff 1f       	adc	r31, r31
    17c4:	bb 1f       	adc	r27, r27
    17c6:	66 1f       	adc	r22, r22
    17c8:	77 1f       	adc	r23, r23
    17ca:	88 1f       	adc	r24, r24
    17cc:	91 50       	subi	r25, 0x01	; 1
    17ce:	50 40       	sbci	r21, 0x00	; 0
    17d0:	a9 f7       	brne	.-22     	; 0x17bc <__mulsf3_pse+0x64>
    17d2:	9e 3f       	cpi	r25, 0xFE	; 254
    17d4:	51 05       	cpc	r21, r1
    17d6:	80 f0       	brcs	.+32     	; 0x17f8 <__mulsf3_pse+0xa0>
    17d8:	0c 94 a3 0a 	jmp	0x1546	; 0x1546 <__fp_inf>
    17dc:	0c 94 15 0b 	jmp	0x162a	; 0x162a <__fp_szero>
    17e0:	5f 3f       	cpi	r21, 0xFF	; 255
    17e2:	e4 f3       	brlt	.-8      	; 0x17dc <__mulsf3_pse+0x84>
    17e4:	98 3e       	cpi	r25, 0xE8	; 232
    17e6:	d4 f3       	brlt	.-12     	; 0x17dc <__mulsf3_pse+0x84>
    17e8:	86 95       	lsr	r24
    17ea:	77 95       	ror	r23
    17ec:	67 95       	ror	r22
    17ee:	b7 95       	ror	r27
    17f0:	f7 95       	ror	r31
    17f2:	e7 95       	ror	r30
    17f4:	9f 5f       	subi	r25, 0xFF	; 255
    17f6:	c1 f7       	brne	.-16     	; 0x17e8 <__mulsf3_pse+0x90>
    17f8:	fe 2b       	or	r31, r30
    17fa:	88 0f       	add	r24, r24
    17fc:	91 1d       	adc	r25, r1
    17fe:	96 95       	lsr	r25
    1800:	87 95       	ror	r24
    1802:	97 f9       	bld	r25, 7
    1804:	08 95       	ret

00001806 <sin>:
    1806:	9f 93       	push	r25
    1808:	0e 94 1b 0c 	call	0x1836	; 0x1836 <__fp_rempio2>
    180c:	0f 90       	pop	r0
    180e:	07 fc       	sbrc	r0, 7
    1810:	ee 5f       	subi	r30, 0xFE	; 254
    1812:	0c 94 44 0c 	jmp	0x1888	; 0x1888 <__fp_sinus>

00001816 <__fp_mpack>:
    1816:	9f 3f       	cpi	r25, 0xFF	; 255
    1818:	31 f0       	breq	.+12     	; 0x1826 <__fp_mpack_finite+0xc>

0000181a <__fp_mpack_finite>:
    181a:	91 50       	subi	r25, 0x01	; 1
    181c:	20 f4       	brcc	.+8      	; 0x1826 <__fp_mpack_finite+0xc>
    181e:	87 95       	ror	r24
    1820:	77 95       	ror	r23
    1822:	67 95       	ror	r22
    1824:	b7 95       	ror	r27
    1826:	88 0f       	add	r24, r24
    1828:	91 1d       	adc	r25, r1
    182a:	96 95       	lsr	r25
    182c:	87 95       	ror	r24
    182e:	97 f9       	bld	r25, 7
    1830:	08 95       	ret
    1832:	0c 94 a9 0a 	jmp	0x1552	; 0x1552 <__fp_nan>

00001836 <__fp_rempio2>:
    1836:	0e 94 fa 0a 	call	0x15f4	; 0x15f4 <__fp_splitA>
    183a:	d8 f3       	brcs	.-10     	; 0x1832 <__fp_mpack_finite+0x18>
    183c:	e8 94       	clt
    183e:	e0 e0       	ldi	r30, 0x00	; 0
    1840:	bb 27       	eor	r27, r27
    1842:	9f 57       	subi	r25, 0x7F	; 127
    1844:	f0 f0       	brcs	.+60     	; 0x1882 <__fp_rempio2+0x4c>
    1846:	2a ed       	ldi	r18, 0xDA	; 218
    1848:	3f e0       	ldi	r19, 0x0F	; 15
    184a:	49 ec       	ldi	r20, 0xC9	; 201
    184c:	06 c0       	rjmp	.+12     	; 0x185a <__fp_rempio2+0x24>
    184e:	ee 0f       	add	r30, r30
    1850:	bb 0f       	add	r27, r27
    1852:	66 1f       	adc	r22, r22
    1854:	77 1f       	adc	r23, r23
    1856:	88 1f       	adc	r24, r24
    1858:	28 f0       	brcs	.+10     	; 0x1864 <__fp_rempio2+0x2e>
    185a:	b2 3a       	cpi	r27, 0xA2	; 162
    185c:	62 07       	cpc	r22, r18
    185e:	73 07       	cpc	r23, r19
    1860:	84 07       	cpc	r24, r20
    1862:	28 f0       	brcs	.+10     	; 0x186e <__fp_rempio2+0x38>
    1864:	b2 5a       	subi	r27, 0xA2	; 162
    1866:	62 0b       	sbc	r22, r18
    1868:	73 0b       	sbc	r23, r19
    186a:	84 0b       	sbc	r24, r20
    186c:	e3 95       	inc	r30
    186e:	9a 95       	dec	r25
    1870:	72 f7       	brpl	.-36     	; 0x184e <__fp_rempio2+0x18>
    1872:	80 38       	cpi	r24, 0x80	; 128
    1874:	30 f4       	brcc	.+12     	; 0x1882 <__fp_rempio2+0x4c>
    1876:	9a 95       	dec	r25
    1878:	bb 0f       	add	r27, r27
    187a:	66 1f       	adc	r22, r22
    187c:	77 1f       	adc	r23, r23
    187e:	88 1f       	adc	r24, r24
    1880:	d2 f7       	brpl	.-12     	; 0x1876 <__fp_rempio2+0x40>
    1882:	90 48       	sbci	r25, 0x80	; 128
    1884:	0c 94 0d 0c 	jmp	0x181a	; 0x181a <__fp_mpack_finite>

00001888 <__fp_sinus>:
    1888:	ef 93       	push	r30
    188a:	e0 ff       	sbrs	r30, 0
    188c:	07 c0       	rjmp	.+14     	; 0x189c <__fp_sinus+0x14>
    188e:	a2 ea       	ldi	r26, 0xA2	; 162
    1890:	2a ed       	ldi	r18, 0xDA	; 218
    1892:	3f e0       	ldi	r19, 0x0F	; 15
    1894:	49 ec       	ldi	r20, 0xC9	; 201
    1896:	5f eb       	ldi	r21, 0xBF	; 191
    1898:	0e 94 ee 08 	call	0x11dc	; 0x11dc <__addsf3x>
    189c:	0e 94 e1 0a 	call	0x15c2	; 0x15c2 <__fp_round>
    18a0:	0f 90       	pop	r0
    18a2:	03 94       	inc	r0
    18a4:	01 fc       	sbrc	r0, 1
    18a6:	90 58       	subi	r25, 0x80	; 128
    18a8:	e4 ea       	ldi	r30, 0xA4	; 164
    18aa:	f0 e0       	ldi	r31, 0x00	; 0
    18ac:	0c 94 58 0c 	jmp	0x18b0	; 0x18b0 <__fp_powsodd>

000018b0 <__fp_powsodd>:
    18b0:	9f 93       	push	r25
    18b2:	8f 93       	push	r24
    18b4:	7f 93       	push	r23
    18b6:	6f 93       	push	r22
    18b8:	ff 93       	push	r31
    18ba:	ef 93       	push	r30
    18bc:	9b 01       	movw	r18, r22
    18be:	ac 01       	movw	r20, r24
    18c0:	0e 94 96 0b 	call	0x172c	; 0x172c <__mulsf3>
    18c4:	ef 91       	pop	r30
    18c6:	ff 91       	pop	r31
    18c8:	0e 94 ac 0a 	call	0x1558	; 0x1558 <__fp_powser>
    18cc:	2f 91       	pop	r18
    18ce:	3f 91       	pop	r19
    18d0:	4f 91       	pop	r20
    18d2:	5f 91       	pop	r21
    18d4:	0c 94 96 0b 	jmp	0x172c	; 0x172c <__mulsf3>

000018d8 <__udivmodsi4>:
    18d8:	a1 e2       	ldi	r26, 0x21	; 33
    18da:	1a 2e       	mov	r1, r26
    18dc:	aa 1b       	sub	r26, r26
    18de:	bb 1b       	sub	r27, r27
    18e0:	fd 01       	movw	r30, r26
    18e2:	0d c0       	rjmp	.+26     	; 0x18fe <__udivmodsi4_ep>

000018e4 <__udivmodsi4_loop>:
    18e4:	aa 1f       	adc	r26, r26
    18e6:	bb 1f       	adc	r27, r27
    18e8:	ee 1f       	adc	r30, r30
    18ea:	ff 1f       	adc	r31, r31
    18ec:	a2 17       	cp	r26, r18
    18ee:	b3 07       	cpc	r27, r19
    18f0:	e4 07       	cpc	r30, r20
    18f2:	f5 07       	cpc	r31, r21
    18f4:	20 f0       	brcs	.+8      	; 0x18fe <__udivmodsi4_ep>
    18f6:	a2 1b       	sub	r26, r18
    18f8:	b3 0b       	sbc	r27, r19
    18fa:	e4 0b       	sbc	r30, r20
    18fc:	f5 0b       	sbc	r31, r21

000018fe <__udivmodsi4_ep>:
    18fe:	66 1f       	adc	r22, r22
    1900:	77 1f       	adc	r23, r23
    1902:	88 1f       	adc	r24, r24
    1904:	99 1f       	adc	r25, r25
    1906:	1a 94       	dec	r1
    1908:	69 f7       	brne	.-38     	; 0x18e4 <__udivmodsi4_loop>
    190a:	60 95       	com	r22
    190c:	70 95       	com	r23
    190e:	80 95       	com	r24
    1910:	90 95       	com	r25
    1912:	9b 01       	movw	r18, r22
    1914:	ac 01       	movw	r20, r24
    1916:	bd 01       	movw	r22, r26
    1918:	cf 01       	movw	r24, r30
    191a:	08 95       	ret

0000191c <dtostrf>:
    191c:	ef 92       	push	r14
    191e:	0f 93       	push	r16
    1920:	1f 93       	push	r17
    1922:	cf 93       	push	r28
    1924:	df 93       	push	r29
    1926:	e8 01       	movw	r28, r16
    1928:	47 fd       	sbrc	r20, 7
    192a:	02 c0       	rjmp	.+4      	; 0x1930 <dtostrf+0x14>
    192c:	34 e0       	ldi	r19, 0x04	; 4
    192e:	01 c0       	rjmp	.+2      	; 0x1932 <dtostrf+0x16>
    1930:	34 e1       	ldi	r19, 0x14	; 20
    1932:	04 2e       	mov	r0, r20
    1934:	00 0c       	add	r0, r0
    1936:	55 0b       	sbc	r21, r21
    1938:	57 ff       	sbrs	r21, 7
    193a:	03 c0       	rjmp	.+6      	; 0x1942 <dtostrf+0x26>
    193c:	51 95       	neg	r21
    193e:	41 95       	neg	r20
    1940:	51 09       	sbc	r21, r1
    1942:	e3 2e       	mov	r14, r19
    1944:	02 2f       	mov	r16, r18
    1946:	24 2f       	mov	r18, r20
    1948:	ae 01       	movw	r20, r28
    194a:	0e 94 d5 0e 	call	0x1daa	; 0x1daa <dtoa_prf>
    194e:	ce 01       	movw	r24, r28
    1950:	df 91       	pop	r29
    1952:	cf 91       	pop	r28
    1954:	1f 91       	pop	r17
    1956:	0f 91       	pop	r16
    1958:	ef 90       	pop	r14
    195a:	08 95       	ret

0000195c <printf>:
    195c:	a0 e0       	ldi	r26, 0x00	; 0
    195e:	b0 e0       	ldi	r27, 0x00	; 0
    1960:	e4 eb       	ldi	r30, 0xB4	; 180
    1962:	fc e0       	ldi	r31, 0x0C	; 12
    1964:	0c 94 c7 11 	jmp	0x238e	; 0x238e <__prologue_saves__+0x20>
    1968:	ae 01       	movw	r20, r28
    196a:	4b 5f       	subi	r20, 0xFB	; 251
    196c:	5f 4f       	sbci	r21, 0xFF	; 255
    196e:	fa 01       	movw	r30, r20
    1970:	61 91       	ld	r22, Z+
    1972:	71 91       	ld	r23, Z+
    1974:	af 01       	movw	r20, r30
    1976:	80 91 67 38 	lds	r24, 0x3867	; 0x803867 <__iob+0x2>
    197a:	90 91 68 38 	lds	r25, 0x3868	; 0x803868 <__iob+0x3>
    197e:	0e 94 f4 0c 	call	0x19e8	; 0x19e8 <vfprintf>
    1982:	e2 e0       	ldi	r30, 0x02	; 2
    1984:	0c 94 e0 11 	jmp	0x23c0	; 0x23c0 <__epilogue_restores__+0x20>

00001988 <puts>:
    1988:	0f 93       	push	r16
    198a:	1f 93       	push	r17
    198c:	cf 93       	push	r28
    198e:	df 93       	push	r29
    1990:	e0 91 67 38 	lds	r30, 0x3867	; 0x803867 <__iob+0x2>
    1994:	f0 91 68 38 	lds	r31, 0x3868	; 0x803868 <__iob+0x3>
    1998:	23 81       	ldd	r18, Z+3	; 0x03
    199a:	21 ff       	sbrs	r18, 1
    199c:	1b c0       	rjmp	.+54     	; 0x19d4 <puts+0x4c>
    199e:	8c 01       	movw	r16, r24
    19a0:	d0 e0       	ldi	r29, 0x00	; 0
    19a2:	c0 e0       	ldi	r28, 0x00	; 0
    19a4:	f8 01       	movw	r30, r16
    19a6:	81 91       	ld	r24, Z+
    19a8:	8f 01       	movw	r16, r30
    19aa:	60 91 67 38 	lds	r22, 0x3867	; 0x803867 <__iob+0x2>
    19ae:	70 91 68 38 	lds	r23, 0x3868	; 0x803868 <__iob+0x3>
    19b2:	db 01       	movw	r26, r22
    19b4:	18 96       	adiw	r26, 0x08	; 8
    19b6:	ed 91       	ld	r30, X+
    19b8:	fc 91       	ld	r31, X
    19ba:	19 97       	sbiw	r26, 0x09	; 9
    19bc:	88 23       	and	r24, r24
    19be:	31 f0       	breq	.+12     	; 0x19cc <puts+0x44>
    19c0:	09 95       	icall
    19c2:	89 2b       	or	r24, r25
    19c4:	79 f3       	breq	.-34     	; 0x19a4 <puts+0x1c>
    19c6:	df ef       	ldi	r29, 0xFF	; 255
    19c8:	cf ef       	ldi	r28, 0xFF	; 255
    19ca:	ec cf       	rjmp	.-40     	; 0x19a4 <puts+0x1c>
    19cc:	8a e0       	ldi	r24, 0x0A	; 10
    19ce:	09 95       	icall
    19d0:	89 2b       	or	r24, r25
    19d2:	19 f0       	breq	.+6      	; 0x19da <puts+0x52>
    19d4:	8f ef       	ldi	r24, 0xFF	; 255
    19d6:	9f ef       	ldi	r25, 0xFF	; 255
    19d8:	02 c0       	rjmp	.+4      	; 0x19de <puts+0x56>
    19da:	8d 2f       	mov	r24, r29
    19dc:	9c 2f       	mov	r25, r28
    19de:	df 91       	pop	r29
    19e0:	cf 91       	pop	r28
    19e2:	1f 91       	pop	r17
    19e4:	0f 91       	pop	r16
    19e6:	08 95       	ret

000019e8 <vfprintf>:
    19e8:	ab e0       	ldi	r26, 0x0B	; 11
    19ea:	b0 e0       	ldi	r27, 0x00	; 0
    19ec:	ea ef       	ldi	r30, 0xFA	; 250
    19ee:	fc e0       	ldi	r31, 0x0C	; 12
    19f0:	0c 94 b7 11 	jmp	0x236e	; 0x236e <__prologue_saves__>
    19f4:	6c 01       	movw	r12, r24
    19f6:	7b 01       	movw	r14, r22
    19f8:	8a 01       	movw	r16, r20
    19fa:	fc 01       	movw	r30, r24
    19fc:	16 82       	std	Z+6, r1	; 0x06
    19fe:	17 82       	std	Z+7, r1	; 0x07
    1a00:	83 81       	ldd	r24, Z+3	; 0x03
    1a02:	81 ff       	sbrs	r24, 1
    1a04:	cc c1       	rjmp	.+920    	; 0x1d9e <vfprintf+0x3b6>
    1a06:	ce 01       	movw	r24, r28
    1a08:	01 96       	adiw	r24, 0x01	; 1
    1a0a:	3c 01       	movw	r6, r24
    1a0c:	f6 01       	movw	r30, r12
    1a0e:	93 81       	ldd	r25, Z+3	; 0x03
    1a10:	f7 01       	movw	r30, r14
    1a12:	93 fd       	sbrc	r25, 3
    1a14:	85 91       	lpm	r24, Z+
    1a16:	93 ff       	sbrs	r25, 3
    1a18:	81 91       	ld	r24, Z+
    1a1a:	7f 01       	movw	r14, r30
    1a1c:	88 23       	and	r24, r24
    1a1e:	09 f4       	brne	.+2      	; 0x1a22 <vfprintf+0x3a>
    1a20:	ba c1       	rjmp	.+884    	; 0x1d96 <vfprintf+0x3ae>
    1a22:	85 32       	cpi	r24, 0x25	; 37
    1a24:	39 f4       	brne	.+14     	; 0x1a34 <vfprintf+0x4c>
    1a26:	93 fd       	sbrc	r25, 3
    1a28:	85 91       	lpm	r24, Z+
    1a2a:	93 ff       	sbrs	r25, 3
    1a2c:	81 91       	ld	r24, Z+
    1a2e:	7f 01       	movw	r14, r30
    1a30:	85 32       	cpi	r24, 0x25	; 37
    1a32:	29 f4       	brne	.+10     	; 0x1a3e <vfprintf+0x56>
    1a34:	b6 01       	movw	r22, r12
    1a36:	90 e0       	ldi	r25, 0x00	; 0
    1a38:	0e 94 1d 11 	call	0x223a	; 0x223a <fputc>
    1a3c:	e7 cf       	rjmp	.-50     	; 0x1a0c <vfprintf+0x24>
    1a3e:	91 2c       	mov	r9, r1
    1a40:	21 2c       	mov	r2, r1
    1a42:	31 2c       	mov	r3, r1
    1a44:	ff e1       	ldi	r31, 0x1F	; 31
    1a46:	f3 15       	cp	r31, r3
    1a48:	d8 f0       	brcs	.+54     	; 0x1a80 <vfprintf+0x98>
    1a4a:	8b 32       	cpi	r24, 0x2B	; 43
    1a4c:	79 f0       	breq	.+30     	; 0x1a6c <vfprintf+0x84>
    1a4e:	38 f4       	brcc	.+14     	; 0x1a5e <vfprintf+0x76>
    1a50:	80 32       	cpi	r24, 0x20	; 32
    1a52:	79 f0       	breq	.+30     	; 0x1a72 <vfprintf+0x8a>
    1a54:	83 32       	cpi	r24, 0x23	; 35
    1a56:	a1 f4       	brne	.+40     	; 0x1a80 <vfprintf+0x98>
    1a58:	23 2d       	mov	r18, r3
    1a5a:	20 61       	ori	r18, 0x10	; 16
    1a5c:	1d c0       	rjmp	.+58     	; 0x1a98 <vfprintf+0xb0>
    1a5e:	8d 32       	cpi	r24, 0x2D	; 45
    1a60:	61 f0       	breq	.+24     	; 0x1a7a <vfprintf+0x92>
    1a62:	80 33       	cpi	r24, 0x30	; 48
    1a64:	69 f4       	brne	.+26     	; 0x1a80 <vfprintf+0x98>
    1a66:	23 2d       	mov	r18, r3
    1a68:	21 60       	ori	r18, 0x01	; 1
    1a6a:	16 c0       	rjmp	.+44     	; 0x1a98 <vfprintf+0xb0>
    1a6c:	83 2d       	mov	r24, r3
    1a6e:	82 60       	ori	r24, 0x02	; 2
    1a70:	38 2e       	mov	r3, r24
    1a72:	e3 2d       	mov	r30, r3
    1a74:	e4 60       	ori	r30, 0x04	; 4
    1a76:	3e 2e       	mov	r3, r30
    1a78:	2a c0       	rjmp	.+84     	; 0x1ace <vfprintf+0xe6>
    1a7a:	f3 2d       	mov	r31, r3
    1a7c:	f8 60       	ori	r31, 0x08	; 8
    1a7e:	1d c0       	rjmp	.+58     	; 0x1aba <vfprintf+0xd2>
    1a80:	37 fc       	sbrc	r3, 7
    1a82:	2d c0       	rjmp	.+90     	; 0x1ade <vfprintf+0xf6>
    1a84:	20 ed       	ldi	r18, 0xD0	; 208
    1a86:	28 0f       	add	r18, r24
    1a88:	2a 30       	cpi	r18, 0x0A	; 10
    1a8a:	40 f0       	brcs	.+16     	; 0x1a9c <vfprintf+0xb4>
    1a8c:	8e 32       	cpi	r24, 0x2E	; 46
    1a8e:	b9 f4       	brne	.+46     	; 0x1abe <vfprintf+0xd6>
    1a90:	36 fc       	sbrc	r3, 6
    1a92:	81 c1       	rjmp	.+770    	; 0x1d96 <vfprintf+0x3ae>
    1a94:	23 2d       	mov	r18, r3
    1a96:	20 64       	ori	r18, 0x40	; 64
    1a98:	32 2e       	mov	r3, r18
    1a9a:	19 c0       	rjmp	.+50     	; 0x1ace <vfprintf+0xe6>
    1a9c:	36 fe       	sbrs	r3, 6
    1a9e:	06 c0       	rjmp	.+12     	; 0x1aac <vfprintf+0xc4>
    1aa0:	8a e0       	ldi	r24, 0x0A	; 10
    1aa2:	98 9e       	mul	r9, r24
    1aa4:	20 0d       	add	r18, r0
    1aa6:	11 24       	eor	r1, r1
    1aa8:	92 2e       	mov	r9, r18
    1aaa:	11 c0       	rjmp	.+34     	; 0x1ace <vfprintf+0xe6>
    1aac:	ea e0       	ldi	r30, 0x0A	; 10
    1aae:	2e 9e       	mul	r2, r30
    1ab0:	20 0d       	add	r18, r0
    1ab2:	11 24       	eor	r1, r1
    1ab4:	22 2e       	mov	r2, r18
    1ab6:	f3 2d       	mov	r31, r3
    1ab8:	f0 62       	ori	r31, 0x20	; 32
    1aba:	3f 2e       	mov	r3, r31
    1abc:	08 c0       	rjmp	.+16     	; 0x1ace <vfprintf+0xe6>
    1abe:	8c 36       	cpi	r24, 0x6C	; 108
    1ac0:	21 f4       	brne	.+8      	; 0x1aca <vfprintf+0xe2>
    1ac2:	83 2d       	mov	r24, r3
    1ac4:	80 68       	ori	r24, 0x80	; 128
    1ac6:	38 2e       	mov	r3, r24
    1ac8:	02 c0       	rjmp	.+4      	; 0x1ace <vfprintf+0xe6>
    1aca:	88 36       	cpi	r24, 0x68	; 104
    1acc:	41 f4       	brne	.+16     	; 0x1ade <vfprintf+0xf6>
    1ace:	f7 01       	movw	r30, r14
    1ad0:	93 fd       	sbrc	r25, 3
    1ad2:	85 91       	lpm	r24, Z+
    1ad4:	93 ff       	sbrs	r25, 3
    1ad6:	81 91       	ld	r24, Z+
    1ad8:	7f 01       	movw	r14, r30
    1ada:	81 11       	cpse	r24, r1
    1adc:	b3 cf       	rjmp	.-154    	; 0x1a44 <vfprintf+0x5c>
    1ade:	98 2f       	mov	r25, r24
    1ae0:	9f 7d       	andi	r25, 0xDF	; 223
    1ae2:	95 54       	subi	r25, 0x45	; 69
    1ae4:	93 30       	cpi	r25, 0x03	; 3
    1ae6:	28 f4       	brcc	.+10     	; 0x1af2 <vfprintf+0x10a>
    1ae8:	0c 5f       	subi	r16, 0xFC	; 252
    1aea:	1f 4f       	sbci	r17, 0xFF	; 255
    1aec:	9f e3       	ldi	r25, 0x3F	; 63
    1aee:	99 83       	std	Y+1, r25	; 0x01
    1af0:	0d c0       	rjmp	.+26     	; 0x1b0c <vfprintf+0x124>
    1af2:	83 36       	cpi	r24, 0x63	; 99
    1af4:	31 f0       	breq	.+12     	; 0x1b02 <vfprintf+0x11a>
    1af6:	83 37       	cpi	r24, 0x73	; 115
    1af8:	71 f0       	breq	.+28     	; 0x1b16 <vfprintf+0x12e>
    1afa:	83 35       	cpi	r24, 0x53	; 83
    1afc:	09 f0       	breq	.+2      	; 0x1b00 <vfprintf+0x118>
    1afe:	59 c0       	rjmp	.+178    	; 0x1bb2 <vfprintf+0x1ca>
    1b00:	21 c0       	rjmp	.+66     	; 0x1b44 <vfprintf+0x15c>
    1b02:	f8 01       	movw	r30, r16
    1b04:	80 81       	ld	r24, Z
    1b06:	89 83       	std	Y+1, r24	; 0x01
    1b08:	0e 5f       	subi	r16, 0xFE	; 254
    1b0a:	1f 4f       	sbci	r17, 0xFF	; 255
    1b0c:	88 24       	eor	r8, r8
    1b0e:	83 94       	inc	r8
    1b10:	91 2c       	mov	r9, r1
    1b12:	53 01       	movw	r10, r6
    1b14:	13 c0       	rjmp	.+38     	; 0x1b3c <vfprintf+0x154>
    1b16:	28 01       	movw	r4, r16
    1b18:	f2 e0       	ldi	r31, 0x02	; 2
    1b1a:	4f 0e       	add	r4, r31
    1b1c:	51 1c       	adc	r5, r1
    1b1e:	f8 01       	movw	r30, r16
    1b20:	a0 80       	ld	r10, Z
    1b22:	b1 80       	ldd	r11, Z+1	; 0x01
    1b24:	36 fe       	sbrs	r3, 6
    1b26:	03 c0       	rjmp	.+6      	; 0x1b2e <vfprintf+0x146>
    1b28:	69 2d       	mov	r22, r9
    1b2a:	70 e0       	ldi	r23, 0x00	; 0
    1b2c:	02 c0       	rjmp	.+4      	; 0x1b32 <vfprintf+0x14a>
    1b2e:	6f ef       	ldi	r22, 0xFF	; 255
    1b30:	7f ef       	ldi	r23, 0xFF	; 255
    1b32:	c5 01       	movw	r24, r10
    1b34:	0e 94 12 11 	call	0x2224	; 0x2224 <strnlen>
    1b38:	4c 01       	movw	r8, r24
    1b3a:	82 01       	movw	r16, r4
    1b3c:	f3 2d       	mov	r31, r3
    1b3e:	ff 77       	andi	r31, 0x7F	; 127
    1b40:	3f 2e       	mov	r3, r31
    1b42:	16 c0       	rjmp	.+44     	; 0x1b70 <vfprintf+0x188>
    1b44:	28 01       	movw	r4, r16
    1b46:	22 e0       	ldi	r18, 0x02	; 2
    1b48:	42 0e       	add	r4, r18
    1b4a:	51 1c       	adc	r5, r1
    1b4c:	f8 01       	movw	r30, r16
    1b4e:	a0 80       	ld	r10, Z
    1b50:	b1 80       	ldd	r11, Z+1	; 0x01
    1b52:	36 fe       	sbrs	r3, 6
    1b54:	03 c0       	rjmp	.+6      	; 0x1b5c <vfprintf+0x174>
    1b56:	69 2d       	mov	r22, r9
    1b58:	70 e0       	ldi	r23, 0x00	; 0
    1b5a:	02 c0       	rjmp	.+4      	; 0x1b60 <vfprintf+0x178>
    1b5c:	6f ef       	ldi	r22, 0xFF	; 255
    1b5e:	7f ef       	ldi	r23, 0xFF	; 255
    1b60:	c5 01       	movw	r24, r10
    1b62:	0e 94 07 11 	call	0x220e	; 0x220e <strnlen_P>
    1b66:	4c 01       	movw	r8, r24
    1b68:	f3 2d       	mov	r31, r3
    1b6a:	f0 68       	ori	r31, 0x80	; 128
    1b6c:	3f 2e       	mov	r3, r31
    1b6e:	82 01       	movw	r16, r4
    1b70:	33 fc       	sbrc	r3, 3
    1b72:	1b c0       	rjmp	.+54     	; 0x1baa <vfprintf+0x1c2>
    1b74:	82 2d       	mov	r24, r2
    1b76:	90 e0       	ldi	r25, 0x00	; 0
    1b78:	88 16       	cp	r8, r24
    1b7a:	99 06       	cpc	r9, r25
    1b7c:	b0 f4       	brcc	.+44     	; 0x1baa <vfprintf+0x1c2>
    1b7e:	b6 01       	movw	r22, r12
    1b80:	80 e2       	ldi	r24, 0x20	; 32
    1b82:	90 e0       	ldi	r25, 0x00	; 0
    1b84:	0e 94 1d 11 	call	0x223a	; 0x223a <fputc>
    1b88:	2a 94       	dec	r2
    1b8a:	f4 cf       	rjmp	.-24     	; 0x1b74 <vfprintf+0x18c>
    1b8c:	f5 01       	movw	r30, r10
    1b8e:	37 fc       	sbrc	r3, 7
    1b90:	85 91       	lpm	r24, Z+
    1b92:	37 fe       	sbrs	r3, 7
    1b94:	81 91       	ld	r24, Z+
    1b96:	5f 01       	movw	r10, r30
    1b98:	b6 01       	movw	r22, r12
    1b9a:	90 e0       	ldi	r25, 0x00	; 0
    1b9c:	0e 94 1d 11 	call	0x223a	; 0x223a <fputc>
    1ba0:	21 10       	cpse	r2, r1
    1ba2:	2a 94       	dec	r2
    1ba4:	21 e0       	ldi	r18, 0x01	; 1
    1ba6:	82 1a       	sub	r8, r18
    1ba8:	91 08       	sbc	r9, r1
    1baa:	81 14       	cp	r8, r1
    1bac:	91 04       	cpc	r9, r1
    1bae:	71 f7       	brne	.-36     	; 0x1b8c <vfprintf+0x1a4>
    1bb0:	e8 c0       	rjmp	.+464    	; 0x1d82 <vfprintf+0x39a>
    1bb2:	84 36       	cpi	r24, 0x64	; 100
    1bb4:	11 f0       	breq	.+4      	; 0x1bba <vfprintf+0x1d2>
    1bb6:	89 36       	cpi	r24, 0x69	; 105
    1bb8:	41 f5       	brne	.+80     	; 0x1c0a <vfprintf+0x222>
    1bba:	f8 01       	movw	r30, r16
    1bbc:	37 fe       	sbrs	r3, 7
    1bbe:	07 c0       	rjmp	.+14     	; 0x1bce <vfprintf+0x1e6>
    1bc0:	60 81       	ld	r22, Z
    1bc2:	71 81       	ldd	r23, Z+1	; 0x01
    1bc4:	82 81       	ldd	r24, Z+2	; 0x02
    1bc6:	93 81       	ldd	r25, Z+3	; 0x03
    1bc8:	0c 5f       	subi	r16, 0xFC	; 252
    1bca:	1f 4f       	sbci	r17, 0xFF	; 255
    1bcc:	08 c0       	rjmp	.+16     	; 0x1bde <vfprintf+0x1f6>
    1bce:	60 81       	ld	r22, Z
    1bd0:	71 81       	ldd	r23, Z+1	; 0x01
    1bd2:	07 2e       	mov	r0, r23
    1bd4:	00 0c       	add	r0, r0
    1bd6:	88 0b       	sbc	r24, r24
    1bd8:	99 0b       	sbc	r25, r25
    1bda:	0e 5f       	subi	r16, 0xFE	; 254
    1bdc:	1f 4f       	sbci	r17, 0xFF	; 255
    1bde:	f3 2d       	mov	r31, r3
    1be0:	ff 76       	andi	r31, 0x6F	; 111
    1be2:	3f 2e       	mov	r3, r31
    1be4:	97 ff       	sbrs	r25, 7
    1be6:	09 c0       	rjmp	.+18     	; 0x1bfa <vfprintf+0x212>
    1be8:	90 95       	com	r25
    1bea:	80 95       	com	r24
    1bec:	70 95       	com	r23
    1bee:	61 95       	neg	r22
    1bf0:	7f 4f       	sbci	r23, 0xFF	; 255
    1bf2:	8f 4f       	sbci	r24, 0xFF	; 255
    1bf4:	9f 4f       	sbci	r25, 0xFF	; 255
    1bf6:	f0 68       	ori	r31, 0x80	; 128
    1bf8:	3f 2e       	mov	r3, r31
    1bfa:	2a e0       	ldi	r18, 0x0A	; 10
    1bfc:	30 e0       	ldi	r19, 0x00	; 0
    1bfe:	a3 01       	movw	r20, r6
    1c00:	0e 94 59 11 	call	0x22b2	; 0x22b2 <__ultoa_invert>
    1c04:	88 2e       	mov	r8, r24
    1c06:	86 18       	sub	r8, r6
    1c08:	45 c0       	rjmp	.+138    	; 0x1c94 <vfprintf+0x2ac>
    1c0a:	85 37       	cpi	r24, 0x75	; 117
    1c0c:	31 f4       	brne	.+12     	; 0x1c1a <vfprintf+0x232>
    1c0e:	23 2d       	mov	r18, r3
    1c10:	2f 7e       	andi	r18, 0xEF	; 239
    1c12:	b2 2e       	mov	r11, r18
    1c14:	2a e0       	ldi	r18, 0x0A	; 10
    1c16:	30 e0       	ldi	r19, 0x00	; 0
    1c18:	25 c0       	rjmp	.+74     	; 0x1c64 <vfprintf+0x27c>
    1c1a:	93 2d       	mov	r25, r3
    1c1c:	99 7f       	andi	r25, 0xF9	; 249
    1c1e:	b9 2e       	mov	r11, r25
    1c20:	8f 36       	cpi	r24, 0x6F	; 111
    1c22:	c1 f0       	breq	.+48     	; 0x1c54 <vfprintf+0x26c>
    1c24:	18 f4       	brcc	.+6      	; 0x1c2c <vfprintf+0x244>
    1c26:	88 35       	cpi	r24, 0x58	; 88
    1c28:	79 f0       	breq	.+30     	; 0x1c48 <vfprintf+0x260>
    1c2a:	b5 c0       	rjmp	.+362    	; 0x1d96 <vfprintf+0x3ae>
    1c2c:	80 37       	cpi	r24, 0x70	; 112
    1c2e:	19 f0       	breq	.+6      	; 0x1c36 <vfprintf+0x24e>
    1c30:	88 37       	cpi	r24, 0x78	; 120
    1c32:	21 f0       	breq	.+8      	; 0x1c3c <vfprintf+0x254>
    1c34:	b0 c0       	rjmp	.+352    	; 0x1d96 <vfprintf+0x3ae>
    1c36:	e9 2f       	mov	r30, r25
    1c38:	e0 61       	ori	r30, 0x10	; 16
    1c3a:	be 2e       	mov	r11, r30
    1c3c:	b4 fe       	sbrs	r11, 4
    1c3e:	0d c0       	rjmp	.+26     	; 0x1c5a <vfprintf+0x272>
    1c40:	fb 2d       	mov	r31, r11
    1c42:	f4 60       	ori	r31, 0x04	; 4
    1c44:	bf 2e       	mov	r11, r31
    1c46:	09 c0       	rjmp	.+18     	; 0x1c5a <vfprintf+0x272>
    1c48:	34 fe       	sbrs	r3, 4
    1c4a:	0a c0       	rjmp	.+20     	; 0x1c60 <vfprintf+0x278>
    1c4c:	29 2f       	mov	r18, r25
    1c4e:	26 60       	ori	r18, 0x06	; 6
    1c50:	b2 2e       	mov	r11, r18
    1c52:	06 c0       	rjmp	.+12     	; 0x1c60 <vfprintf+0x278>
    1c54:	28 e0       	ldi	r18, 0x08	; 8
    1c56:	30 e0       	ldi	r19, 0x00	; 0
    1c58:	05 c0       	rjmp	.+10     	; 0x1c64 <vfprintf+0x27c>
    1c5a:	20 e1       	ldi	r18, 0x10	; 16
    1c5c:	30 e0       	ldi	r19, 0x00	; 0
    1c5e:	02 c0       	rjmp	.+4      	; 0x1c64 <vfprintf+0x27c>
    1c60:	20 e1       	ldi	r18, 0x10	; 16
    1c62:	32 e0       	ldi	r19, 0x02	; 2
    1c64:	f8 01       	movw	r30, r16
    1c66:	b7 fe       	sbrs	r11, 7
    1c68:	07 c0       	rjmp	.+14     	; 0x1c78 <vfprintf+0x290>
    1c6a:	60 81       	ld	r22, Z
    1c6c:	71 81       	ldd	r23, Z+1	; 0x01
    1c6e:	82 81       	ldd	r24, Z+2	; 0x02
    1c70:	93 81       	ldd	r25, Z+3	; 0x03
    1c72:	0c 5f       	subi	r16, 0xFC	; 252
    1c74:	1f 4f       	sbci	r17, 0xFF	; 255
    1c76:	06 c0       	rjmp	.+12     	; 0x1c84 <vfprintf+0x29c>
    1c78:	60 81       	ld	r22, Z
    1c7a:	71 81       	ldd	r23, Z+1	; 0x01
    1c7c:	80 e0       	ldi	r24, 0x00	; 0
    1c7e:	90 e0       	ldi	r25, 0x00	; 0
    1c80:	0e 5f       	subi	r16, 0xFE	; 254
    1c82:	1f 4f       	sbci	r17, 0xFF	; 255
    1c84:	a3 01       	movw	r20, r6
    1c86:	0e 94 59 11 	call	0x22b2	; 0x22b2 <__ultoa_invert>
    1c8a:	88 2e       	mov	r8, r24
    1c8c:	86 18       	sub	r8, r6
    1c8e:	fb 2d       	mov	r31, r11
    1c90:	ff 77       	andi	r31, 0x7F	; 127
    1c92:	3f 2e       	mov	r3, r31
    1c94:	36 fe       	sbrs	r3, 6
    1c96:	0d c0       	rjmp	.+26     	; 0x1cb2 <vfprintf+0x2ca>
    1c98:	23 2d       	mov	r18, r3
    1c9a:	2e 7f       	andi	r18, 0xFE	; 254
    1c9c:	a2 2e       	mov	r10, r18
    1c9e:	89 14       	cp	r8, r9
    1ca0:	58 f4       	brcc	.+22     	; 0x1cb8 <vfprintf+0x2d0>
    1ca2:	34 fe       	sbrs	r3, 4
    1ca4:	0b c0       	rjmp	.+22     	; 0x1cbc <vfprintf+0x2d4>
    1ca6:	32 fc       	sbrc	r3, 2
    1ca8:	09 c0       	rjmp	.+18     	; 0x1cbc <vfprintf+0x2d4>
    1caa:	83 2d       	mov	r24, r3
    1cac:	8e 7e       	andi	r24, 0xEE	; 238
    1cae:	a8 2e       	mov	r10, r24
    1cb0:	05 c0       	rjmp	.+10     	; 0x1cbc <vfprintf+0x2d4>
    1cb2:	b8 2c       	mov	r11, r8
    1cb4:	a3 2c       	mov	r10, r3
    1cb6:	03 c0       	rjmp	.+6      	; 0x1cbe <vfprintf+0x2d6>
    1cb8:	b8 2c       	mov	r11, r8
    1cba:	01 c0       	rjmp	.+2      	; 0x1cbe <vfprintf+0x2d6>
    1cbc:	b9 2c       	mov	r11, r9
    1cbe:	a4 fe       	sbrs	r10, 4
    1cc0:	0f c0       	rjmp	.+30     	; 0x1ce0 <vfprintf+0x2f8>
    1cc2:	fe 01       	movw	r30, r28
    1cc4:	e8 0d       	add	r30, r8
    1cc6:	f1 1d       	adc	r31, r1
    1cc8:	80 81       	ld	r24, Z
    1cca:	80 33       	cpi	r24, 0x30	; 48
    1ccc:	21 f4       	brne	.+8      	; 0x1cd6 <vfprintf+0x2ee>
    1cce:	9a 2d       	mov	r25, r10
    1cd0:	99 7e       	andi	r25, 0xE9	; 233
    1cd2:	a9 2e       	mov	r10, r25
    1cd4:	09 c0       	rjmp	.+18     	; 0x1ce8 <vfprintf+0x300>
    1cd6:	a2 fe       	sbrs	r10, 2
    1cd8:	06 c0       	rjmp	.+12     	; 0x1ce6 <vfprintf+0x2fe>
    1cda:	b3 94       	inc	r11
    1cdc:	b3 94       	inc	r11
    1cde:	04 c0       	rjmp	.+8      	; 0x1ce8 <vfprintf+0x300>
    1ce0:	8a 2d       	mov	r24, r10
    1ce2:	86 78       	andi	r24, 0x86	; 134
    1ce4:	09 f0       	breq	.+2      	; 0x1ce8 <vfprintf+0x300>
    1ce6:	b3 94       	inc	r11
    1ce8:	a3 fc       	sbrc	r10, 3
    1cea:	11 c0       	rjmp	.+34     	; 0x1d0e <vfprintf+0x326>
    1cec:	a0 fe       	sbrs	r10, 0
    1cee:	06 c0       	rjmp	.+12     	; 0x1cfc <vfprintf+0x314>
    1cf0:	b2 14       	cp	r11, r2
    1cf2:	88 f4       	brcc	.+34     	; 0x1d16 <vfprintf+0x32e>
    1cf4:	28 0c       	add	r2, r8
    1cf6:	92 2c       	mov	r9, r2
    1cf8:	9b 18       	sub	r9, r11
    1cfa:	0e c0       	rjmp	.+28     	; 0x1d18 <vfprintf+0x330>
    1cfc:	b2 14       	cp	r11, r2
    1cfe:	60 f4       	brcc	.+24     	; 0x1d18 <vfprintf+0x330>
    1d00:	b6 01       	movw	r22, r12
    1d02:	80 e2       	ldi	r24, 0x20	; 32
    1d04:	90 e0       	ldi	r25, 0x00	; 0
    1d06:	0e 94 1d 11 	call	0x223a	; 0x223a <fputc>
    1d0a:	b3 94       	inc	r11
    1d0c:	f7 cf       	rjmp	.-18     	; 0x1cfc <vfprintf+0x314>
    1d0e:	b2 14       	cp	r11, r2
    1d10:	18 f4       	brcc	.+6      	; 0x1d18 <vfprintf+0x330>
    1d12:	2b 18       	sub	r2, r11
    1d14:	02 c0       	rjmp	.+4      	; 0x1d1a <vfprintf+0x332>
    1d16:	98 2c       	mov	r9, r8
    1d18:	21 2c       	mov	r2, r1
    1d1a:	a4 fe       	sbrs	r10, 4
    1d1c:	10 c0       	rjmp	.+32     	; 0x1d3e <vfprintf+0x356>
    1d1e:	b6 01       	movw	r22, r12
    1d20:	80 e3       	ldi	r24, 0x30	; 48
    1d22:	90 e0       	ldi	r25, 0x00	; 0
    1d24:	0e 94 1d 11 	call	0x223a	; 0x223a <fputc>
    1d28:	a2 fe       	sbrs	r10, 2
    1d2a:	17 c0       	rjmp	.+46     	; 0x1d5a <vfprintf+0x372>
    1d2c:	a1 fc       	sbrc	r10, 1
    1d2e:	03 c0       	rjmp	.+6      	; 0x1d36 <vfprintf+0x34e>
    1d30:	88 e7       	ldi	r24, 0x78	; 120
    1d32:	90 e0       	ldi	r25, 0x00	; 0
    1d34:	02 c0       	rjmp	.+4      	; 0x1d3a <vfprintf+0x352>
    1d36:	88 e5       	ldi	r24, 0x58	; 88
    1d38:	90 e0       	ldi	r25, 0x00	; 0
    1d3a:	b6 01       	movw	r22, r12
    1d3c:	0c c0       	rjmp	.+24     	; 0x1d56 <vfprintf+0x36e>
    1d3e:	8a 2d       	mov	r24, r10
    1d40:	86 78       	andi	r24, 0x86	; 134
    1d42:	59 f0       	breq	.+22     	; 0x1d5a <vfprintf+0x372>
    1d44:	a1 fe       	sbrs	r10, 1
    1d46:	02 c0       	rjmp	.+4      	; 0x1d4c <vfprintf+0x364>
    1d48:	8b e2       	ldi	r24, 0x2B	; 43
    1d4a:	01 c0       	rjmp	.+2      	; 0x1d4e <vfprintf+0x366>
    1d4c:	80 e2       	ldi	r24, 0x20	; 32
    1d4e:	a7 fc       	sbrc	r10, 7
    1d50:	8d e2       	ldi	r24, 0x2D	; 45
    1d52:	b6 01       	movw	r22, r12
    1d54:	90 e0       	ldi	r25, 0x00	; 0
    1d56:	0e 94 1d 11 	call	0x223a	; 0x223a <fputc>
    1d5a:	89 14       	cp	r8, r9
    1d5c:	38 f4       	brcc	.+14     	; 0x1d6c <vfprintf+0x384>
    1d5e:	b6 01       	movw	r22, r12
    1d60:	80 e3       	ldi	r24, 0x30	; 48
    1d62:	90 e0       	ldi	r25, 0x00	; 0
    1d64:	0e 94 1d 11 	call	0x223a	; 0x223a <fputc>
    1d68:	9a 94       	dec	r9
    1d6a:	f7 cf       	rjmp	.-18     	; 0x1d5a <vfprintf+0x372>
    1d6c:	8a 94       	dec	r8
    1d6e:	f3 01       	movw	r30, r6
    1d70:	e8 0d       	add	r30, r8
    1d72:	f1 1d       	adc	r31, r1
    1d74:	80 81       	ld	r24, Z
    1d76:	b6 01       	movw	r22, r12
    1d78:	90 e0       	ldi	r25, 0x00	; 0
    1d7a:	0e 94 1d 11 	call	0x223a	; 0x223a <fputc>
    1d7e:	81 10       	cpse	r8, r1
    1d80:	f5 cf       	rjmp	.-22     	; 0x1d6c <vfprintf+0x384>
    1d82:	22 20       	and	r2, r2
    1d84:	09 f4       	brne	.+2      	; 0x1d88 <vfprintf+0x3a0>
    1d86:	42 ce       	rjmp	.-892    	; 0x1a0c <vfprintf+0x24>
    1d88:	b6 01       	movw	r22, r12
    1d8a:	80 e2       	ldi	r24, 0x20	; 32
    1d8c:	90 e0       	ldi	r25, 0x00	; 0
    1d8e:	0e 94 1d 11 	call	0x223a	; 0x223a <fputc>
    1d92:	2a 94       	dec	r2
    1d94:	f6 cf       	rjmp	.-20     	; 0x1d82 <vfprintf+0x39a>
    1d96:	f6 01       	movw	r30, r12
    1d98:	86 81       	ldd	r24, Z+6	; 0x06
    1d9a:	97 81       	ldd	r25, Z+7	; 0x07
    1d9c:	02 c0       	rjmp	.+4      	; 0x1da2 <vfprintf+0x3ba>
    1d9e:	8f ef       	ldi	r24, 0xFF	; 255
    1da0:	9f ef       	ldi	r25, 0xFF	; 255
    1da2:	2b 96       	adiw	r28, 0x0b	; 11
    1da4:	e2 e1       	ldi	r30, 0x12	; 18
    1da6:	0c 94 d0 11 	jmp	0x23a0	; 0x23a0 <__epilogue_restores__>

00001daa <dtoa_prf>:
    1daa:	a9 e0       	ldi	r26, 0x09	; 9
    1dac:	b0 e0       	ldi	r27, 0x00	; 0
    1dae:	eb ed       	ldi	r30, 0xDB	; 219
    1db0:	fe e0       	ldi	r31, 0x0E	; 14
    1db2:	0c 94 bd 11 	jmp	0x237a	; 0x237a <__prologue_saves__+0xc>
    1db6:	6a 01       	movw	r12, r20
    1db8:	12 2f       	mov	r17, r18
    1dba:	b0 2e       	mov	r11, r16
    1dbc:	2b e3       	ldi	r18, 0x3B	; 59
    1dbe:	20 17       	cp	r18, r16
    1dc0:	20 f0       	brcs	.+8      	; 0x1dca <dtoa_prf+0x20>
    1dc2:	ff 24       	eor	r15, r15
    1dc4:	f3 94       	inc	r15
    1dc6:	f0 0e       	add	r15, r16
    1dc8:	02 c0       	rjmp	.+4      	; 0x1dce <dtoa_prf+0x24>
    1dca:	2c e3       	ldi	r18, 0x3C	; 60
    1dcc:	f2 2e       	mov	r15, r18
    1dce:	0f 2d       	mov	r16, r15
    1dd0:	27 e0       	ldi	r18, 0x07	; 7
    1dd2:	ae 01       	movw	r20, r28
    1dd4:	4f 5f       	subi	r20, 0xFF	; 255
    1dd6:	5f 4f       	sbci	r21, 0xFF	; 255
    1dd8:	0e 94 2f 10 	call	0x205e	; 0x205e <__ftoa_engine>
    1ddc:	bc 01       	movw	r22, r24
    1dde:	49 81       	ldd	r20, Y+1	; 0x01
    1de0:	84 2f       	mov	r24, r20
    1de2:	89 70       	andi	r24, 0x09	; 9
    1de4:	81 30       	cpi	r24, 0x01	; 1
    1de6:	31 f0       	breq	.+12     	; 0x1df4 <dtoa_prf+0x4a>
    1de8:	e1 fc       	sbrc	r14, 1
    1dea:	06 c0       	rjmp	.+12     	; 0x1df8 <dtoa_prf+0x4e>
    1dec:	e0 fe       	sbrs	r14, 0
    1dee:	06 c0       	rjmp	.+12     	; 0x1dfc <dtoa_prf+0x52>
    1df0:	90 e2       	ldi	r25, 0x20	; 32
    1df2:	05 c0       	rjmp	.+10     	; 0x1dfe <dtoa_prf+0x54>
    1df4:	9d e2       	ldi	r25, 0x2D	; 45
    1df6:	03 c0       	rjmp	.+6      	; 0x1dfe <dtoa_prf+0x54>
    1df8:	9b e2       	ldi	r25, 0x2B	; 43
    1dfa:	01 c0       	rjmp	.+2      	; 0x1dfe <dtoa_prf+0x54>
    1dfc:	90 e0       	ldi	r25, 0x00	; 0
    1dfe:	5e 2d       	mov	r21, r14
    1e00:	50 71       	andi	r21, 0x10	; 16
    1e02:	43 ff       	sbrs	r20, 3
    1e04:	3c c0       	rjmp	.+120    	; 0x1e7e <dtoa_prf+0xd4>
    1e06:	91 11       	cpse	r25, r1
    1e08:	02 c0       	rjmp	.+4      	; 0x1e0e <dtoa_prf+0x64>
    1e0a:	83 e0       	ldi	r24, 0x03	; 3
    1e0c:	01 c0       	rjmp	.+2      	; 0x1e10 <dtoa_prf+0x66>
    1e0e:	84 e0       	ldi	r24, 0x04	; 4
    1e10:	81 17       	cp	r24, r17
    1e12:	18 f4       	brcc	.+6      	; 0x1e1a <dtoa_prf+0x70>
    1e14:	21 2f       	mov	r18, r17
    1e16:	28 1b       	sub	r18, r24
    1e18:	01 c0       	rjmp	.+2      	; 0x1e1c <dtoa_prf+0x72>
    1e1a:	20 e0       	ldi	r18, 0x00	; 0
    1e1c:	51 11       	cpse	r21, r1
    1e1e:	0b c0       	rjmp	.+22     	; 0x1e36 <dtoa_prf+0x8c>
    1e20:	f6 01       	movw	r30, r12
    1e22:	82 2f       	mov	r24, r18
    1e24:	30 e2       	ldi	r19, 0x20	; 32
    1e26:	88 23       	and	r24, r24
    1e28:	19 f0       	breq	.+6      	; 0x1e30 <dtoa_prf+0x86>
    1e2a:	31 93       	st	Z+, r19
    1e2c:	81 50       	subi	r24, 0x01	; 1
    1e2e:	fb cf       	rjmp	.-10     	; 0x1e26 <dtoa_prf+0x7c>
    1e30:	c2 0e       	add	r12, r18
    1e32:	d1 1c       	adc	r13, r1
    1e34:	20 e0       	ldi	r18, 0x00	; 0
    1e36:	99 23       	and	r25, r25
    1e38:	29 f0       	breq	.+10     	; 0x1e44 <dtoa_prf+0x9a>
    1e3a:	d6 01       	movw	r26, r12
    1e3c:	9c 93       	st	X, r25
    1e3e:	f6 01       	movw	r30, r12
    1e40:	31 96       	adiw	r30, 0x01	; 1
    1e42:	6f 01       	movw	r12, r30
    1e44:	c6 01       	movw	r24, r12
    1e46:	03 96       	adiw	r24, 0x03	; 3
    1e48:	e2 fe       	sbrs	r14, 2
    1e4a:	0a c0       	rjmp	.+20     	; 0x1e60 <dtoa_prf+0xb6>
    1e4c:	3e e4       	ldi	r19, 0x4E	; 78
    1e4e:	d6 01       	movw	r26, r12
    1e50:	3c 93       	st	X, r19
    1e52:	41 e4       	ldi	r20, 0x41	; 65
    1e54:	11 96       	adiw	r26, 0x01	; 1
    1e56:	4c 93       	st	X, r20
    1e58:	11 97       	sbiw	r26, 0x01	; 1
    1e5a:	12 96       	adiw	r26, 0x02	; 2
    1e5c:	3c 93       	st	X, r19
    1e5e:	06 c0       	rjmp	.+12     	; 0x1e6c <dtoa_prf+0xc2>
    1e60:	3e e6       	ldi	r19, 0x6E	; 110
    1e62:	f6 01       	movw	r30, r12
    1e64:	30 83       	st	Z, r19
    1e66:	41 e6       	ldi	r20, 0x61	; 97
    1e68:	41 83       	std	Z+1, r20	; 0x01
    1e6a:	32 83       	std	Z+2, r19	; 0x02
    1e6c:	fc 01       	movw	r30, r24
    1e6e:	32 2f       	mov	r19, r18
    1e70:	40 e2       	ldi	r20, 0x20	; 32
    1e72:	33 23       	and	r19, r19
    1e74:	09 f4       	brne	.+2      	; 0x1e78 <dtoa_prf+0xce>
    1e76:	42 c0       	rjmp	.+132    	; 0x1efc <dtoa_prf+0x152>
    1e78:	41 93       	st	Z+, r20
    1e7a:	31 50       	subi	r19, 0x01	; 1
    1e7c:	fa cf       	rjmp	.-12     	; 0x1e72 <dtoa_prf+0xc8>
    1e7e:	42 ff       	sbrs	r20, 2
    1e80:	44 c0       	rjmp	.+136    	; 0x1f0a <dtoa_prf+0x160>
    1e82:	91 11       	cpse	r25, r1
    1e84:	02 c0       	rjmp	.+4      	; 0x1e8a <dtoa_prf+0xe0>
    1e86:	83 e0       	ldi	r24, 0x03	; 3
    1e88:	01 c0       	rjmp	.+2      	; 0x1e8c <dtoa_prf+0xe2>
    1e8a:	84 e0       	ldi	r24, 0x04	; 4
    1e8c:	81 17       	cp	r24, r17
    1e8e:	18 f4       	brcc	.+6      	; 0x1e96 <dtoa_prf+0xec>
    1e90:	21 2f       	mov	r18, r17
    1e92:	28 1b       	sub	r18, r24
    1e94:	01 c0       	rjmp	.+2      	; 0x1e98 <dtoa_prf+0xee>
    1e96:	20 e0       	ldi	r18, 0x00	; 0
    1e98:	51 11       	cpse	r21, r1
    1e9a:	0b c0       	rjmp	.+22     	; 0x1eb2 <dtoa_prf+0x108>
    1e9c:	f6 01       	movw	r30, r12
    1e9e:	82 2f       	mov	r24, r18
    1ea0:	30 e2       	ldi	r19, 0x20	; 32
    1ea2:	88 23       	and	r24, r24
    1ea4:	19 f0       	breq	.+6      	; 0x1eac <dtoa_prf+0x102>
    1ea6:	31 93       	st	Z+, r19
    1ea8:	81 50       	subi	r24, 0x01	; 1
    1eaa:	fb cf       	rjmp	.-10     	; 0x1ea2 <dtoa_prf+0xf8>
    1eac:	c2 0e       	add	r12, r18
    1eae:	d1 1c       	adc	r13, r1
    1eb0:	20 e0       	ldi	r18, 0x00	; 0
    1eb2:	99 23       	and	r25, r25
    1eb4:	29 f0       	breq	.+10     	; 0x1ec0 <dtoa_prf+0x116>
    1eb6:	d6 01       	movw	r26, r12
    1eb8:	9c 93       	st	X, r25
    1eba:	f6 01       	movw	r30, r12
    1ebc:	31 96       	adiw	r30, 0x01	; 1
    1ebe:	6f 01       	movw	r12, r30
    1ec0:	c6 01       	movw	r24, r12
    1ec2:	03 96       	adiw	r24, 0x03	; 3
    1ec4:	e2 fe       	sbrs	r14, 2
    1ec6:	0b c0       	rjmp	.+22     	; 0x1ede <dtoa_prf+0x134>
    1ec8:	39 e4       	ldi	r19, 0x49	; 73
    1eca:	d6 01       	movw	r26, r12
    1ecc:	3c 93       	st	X, r19
    1ece:	3e e4       	ldi	r19, 0x4E	; 78
    1ed0:	11 96       	adiw	r26, 0x01	; 1
    1ed2:	3c 93       	st	X, r19
    1ed4:	11 97       	sbiw	r26, 0x01	; 1
    1ed6:	36 e4       	ldi	r19, 0x46	; 70
    1ed8:	12 96       	adiw	r26, 0x02	; 2
    1eda:	3c 93       	st	X, r19
    1edc:	07 c0       	rjmp	.+14     	; 0x1eec <dtoa_prf+0x142>
    1ede:	39 e6       	ldi	r19, 0x69	; 105
    1ee0:	f6 01       	movw	r30, r12
    1ee2:	30 83       	st	Z, r19
    1ee4:	3e e6       	ldi	r19, 0x6E	; 110
    1ee6:	31 83       	std	Z+1, r19	; 0x01
    1ee8:	36 e6       	ldi	r19, 0x66	; 102
    1eea:	32 83       	std	Z+2, r19	; 0x02
    1eec:	fc 01       	movw	r30, r24
    1eee:	32 2f       	mov	r19, r18
    1ef0:	40 e2       	ldi	r20, 0x20	; 32
    1ef2:	33 23       	and	r19, r19
    1ef4:	19 f0       	breq	.+6      	; 0x1efc <dtoa_prf+0x152>
    1ef6:	41 93       	st	Z+, r20
    1ef8:	31 50       	subi	r19, 0x01	; 1
    1efa:	fb cf       	rjmp	.-10     	; 0x1ef2 <dtoa_prf+0x148>
    1efc:	fc 01       	movw	r30, r24
    1efe:	e2 0f       	add	r30, r18
    1f00:	f1 1d       	adc	r31, r1
    1f02:	10 82       	st	Z, r1
    1f04:	8e ef       	ldi	r24, 0xFE	; 254
    1f06:	9f ef       	ldi	r25, 0xFF	; 255
    1f08:	a6 c0       	rjmp	.+332    	; 0x2056 <dtoa_prf+0x2ac>
    1f0a:	21 e0       	ldi	r18, 0x01	; 1
    1f0c:	30 e0       	ldi	r19, 0x00	; 0
    1f0e:	91 11       	cpse	r25, r1
    1f10:	02 c0       	rjmp	.+4      	; 0x1f16 <dtoa_prf+0x16c>
    1f12:	20 e0       	ldi	r18, 0x00	; 0
    1f14:	30 e0       	ldi	r19, 0x00	; 0
    1f16:	16 16       	cp	r1, r22
    1f18:	17 06       	cpc	r1, r23
    1f1a:	1c f4       	brge	.+6      	; 0x1f22 <dtoa_prf+0x178>
    1f1c:	fb 01       	movw	r30, r22
    1f1e:	31 96       	adiw	r30, 0x01	; 1
    1f20:	02 c0       	rjmp	.+4      	; 0x1f26 <dtoa_prf+0x17c>
    1f22:	e1 e0       	ldi	r30, 0x01	; 1
    1f24:	f0 e0       	ldi	r31, 0x00	; 0
    1f26:	2e 0f       	add	r18, r30
    1f28:	3f 1f       	adc	r19, r31
    1f2a:	bb 20       	and	r11, r11
    1f2c:	21 f0       	breq	.+8      	; 0x1f36 <dtoa_prf+0x18c>
    1f2e:	eb 2d       	mov	r30, r11
    1f30:	f0 e0       	ldi	r31, 0x00	; 0
    1f32:	31 96       	adiw	r30, 0x01	; 1
    1f34:	02 c0       	rjmp	.+4      	; 0x1f3a <dtoa_prf+0x190>
    1f36:	e0 e0       	ldi	r30, 0x00	; 0
    1f38:	f0 e0       	ldi	r31, 0x00	; 0
    1f3a:	2e 0f       	add	r18, r30
    1f3c:	3f 1f       	adc	r19, r31
    1f3e:	e1 2f       	mov	r30, r17
    1f40:	f0 e0       	ldi	r31, 0x00	; 0
    1f42:	2e 17       	cp	r18, r30
    1f44:	3f 07       	cpc	r19, r31
    1f46:	1c f4       	brge	.+6      	; 0x1f4e <dtoa_prf+0x1a4>
    1f48:	12 1b       	sub	r17, r18
    1f4a:	21 2f       	mov	r18, r17
    1f4c:	01 c0       	rjmp	.+2      	; 0x1f50 <dtoa_prf+0x1a6>
    1f4e:	20 e0       	ldi	r18, 0x00	; 0
    1f50:	8e 2d       	mov	r24, r14
    1f52:	88 71       	andi	r24, 0x18	; 24
    1f54:	59 f4       	brne	.+22     	; 0x1f6c <dtoa_prf+0x1c2>
    1f56:	f6 01       	movw	r30, r12
    1f58:	82 2f       	mov	r24, r18
    1f5a:	30 e2       	ldi	r19, 0x20	; 32
    1f5c:	88 23       	and	r24, r24
    1f5e:	19 f0       	breq	.+6      	; 0x1f66 <dtoa_prf+0x1bc>
    1f60:	31 93       	st	Z+, r19
    1f62:	81 50       	subi	r24, 0x01	; 1
    1f64:	fb cf       	rjmp	.-10     	; 0x1f5c <dtoa_prf+0x1b2>
    1f66:	c2 0e       	add	r12, r18
    1f68:	d1 1c       	adc	r13, r1
    1f6a:	20 e0       	ldi	r18, 0x00	; 0
    1f6c:	99 23       	and	r25, r25
    1f6e:	29 f0       	breq	.+10     	; 0x1f7a <dtoa_prf+0x1d0>
    1f70:	d6 01       	movw	r26, r12
    1f72:	9c 93       	st	X, r25
    1f74:	f6 01       	movw	r30, r12
    1f76:	31 96       	adiw	r30, 0x01	; 1
    1f78:	6f 01       	movw	r12, r30
    1f7a:	51 11       	cpse	r21, r1
    1f7c:	0b c0       	rjmp	.+22     	; 0x1f94 <dtoa_prf+0x1ea>
    1f7e:	f6 01       	movw	r30, r12
    1f80:	82 2f       	mov	r24, r18
    1f82:	90 e3       	ldi	r25, 0x30	; 48
    1f84:	88 23       	and	r24, r24
    1f86:	19 f0       	breq	.+6      	; 0x1f8e <dtoa_prf+0x1e4>
    1f88:	91 93       	st	Z+, r25
    1f8a:	81 50       	subi	r24, 0x01	; 1
    1f8c:	fb cf       	rjmp	.-10     	; 0x1f84 <dtoa_prf+0x1da>
    1f8e:	c2 0e       	add	r12, r18
    1f90:	d1 1c       	adc	r13, r1
    1f92:	20 e0       	ldi	r18, 0x00	; 0
    1f94:	0f 2d       	mov	r16, r15
    1f96:	06 0f       	add	r16, r22
    1f98:	9a 81       	ldd	r25, Y+2	; 0x02
    1f9a:	34 2f       	mov	r19, r20
    1f9c:	30 71       	andi	r19, 0x10	; 16
    1f9e:	44 ff       	sbrs	r20, 4
    1fa0:	03 c0       	rjmp	.+6      	; 0x1fa8 <dtoa_prf+0x1fe>
    1fa2:	91 33       	cpi	r25, 0x31	; 49
    1fa4:	09 f4       	brne	.+2      	; 0x1fa8 <dtoa_prf+0x1fe>
    1fa6:	01 50       	subi	r16, 0x01	; 1
    1fa8:	10 16       	cp	r1, r16
    1faa:	24 f4       	brge	.+8      	; 0x1fb4 <dtoa_prf+0x20a>
    1fac:	09 30       	cpi	r16, 0x09	; 9
    1fae:	18 f0       	brcs	.+6      	; 0x1fb6 <dtoa_prf+0x20c>
    1fb0:	08 e0       	ldi	r16, 0x08	; 8
    1fb2:	01 c0       	rjmp	.+2      	; 0x1fb6 <dtoa_prf+0x20c>
    1fb4:	01 e0       	ldi	r16, 0x01	; 1
    1fb6:	ab 01       	movw	r20, r22
    1fb8:	77 ff       	sbrs	r23, 7
    1fba:	02 c0       	rjmp	.+4      	; 0x1fc0 <dtoa_prf+0x216>
    1fbc:	40 e0       	ldi	r20, 0x00	; 0
    1fbe:	50 e0       	ldi	r21, 0x00	; 0
    1fc0:	fb 01       	movw	r30, r22
    1fc2:	e4 1b       	sub	r30, r20
    1fc4:	f5 0b       	sbc	r31, r21
    1fc6:	a1 e0       	ldi	r26, 0x01	; 1
    1fc8:	b0 e0       	ldi	r27, 0x00	; 0
    1fca:	ac 0f       	add	r26, r28
    1fcc:	bd 1f       	adc	r27, r29
    1fce:	ea 0f       	add	r30, r26
    1fd0:	fb 1f       	adc	r31, r27
    1fd2:	8e e2       	ldi	r24, 0x2E	; 46
    1fd4:	a8 2e       	mov	r10, r24
    1fd6:	4b 01       	movw	r8, r22
    1fd8:	80 1a       	sub	r8, r16
    1fda:	91 08       	sbc	r9, r1
    1fdc:	0b 2d       	mov	r16, r11
    1fde:	10 e0       	ldi	r17, 0x00	; 0
    1fe0:	11 95       	neg	r17
    1fe2:	01 95       	neg	r16
    1fe4:	11 09       	sbc	r17, r1
    1fe6:	4f 3f       	cpi	r20, 0xFF	; 255
    1fe8:	bf ef       	ldi	r27, 0xFF	; 255
    1fea:	5b 07       	cpc	r21, r27
    1fec:	21 f4       	brne	.+8      	; 0x1ff6 <dtoa_prf+0x24c>
    1fee:	d6 01       	movw	r26, r12
    1ff0:	ac 92       	st	X, r10
    1ff2:	11 96       	adiw	r26, 0x01	; 1
    1ff4:	6d 01       	movw	r12, r26
    1ff6:	64 17       	cp	r22, r20
    1ff8:	75 07       	cpc	r23, r21
    1ffa:	2c f0       	brlt	.+10     	; 0x2006 <dtoa_prf+0x25c>
    1ffc:	84 16       	cp	r8, r20
    1ffe:	95 06       	cpc	r9, r21
    2000:	14 f4       	brge	.+4      	; 0x2006 <dtoa_prf+0x25c>
    2002:	81 81       	ldd	r24, Z+1	; 0x01
    2004:	01 c0       	rjmp	.+2      	; 0x2008 <dtoa_prf+0x25e>
    2006:	80 e3       	ldi	r24, 0x30	; 48
    2008:	41 50       	subi	r20, 0x01	; 1
    200a:	51 09       	sbc	r21, r1
    200c:	31 96       	adiw	r30, 0x01	; 1
    200e:	d6 01       	movw	r26, r12
    2010:	11 96       	adiw	r26, 0x01	; 1
    2012:	7d 01       	movw	r14, r26
    2014:	40 17       	cp	r20, r16
    2016:	51 07       	cpc	r21, r17
    2018:	24 f0       	brlt	.+8      	; 0x2022 <dtoa_prf+0x278>
    201a:	d6 01       	movw	r26, r12
    201c:	8c 93       	st	X, r24
    201e:	67 01       	movw	r12, r14
    2020:	e2 cf       	rjmp	.-60     	; 0x1fe6 <dtoa_prf+0x23c>
    2022:	64 17       	cp	r22, r20
    2024:	75 07       	cpc	r23, r21
    2026:	39 f4       	brne	.+14     	; 0x2036 <dtoa_prf+0x28c>
    2028:	96 33       	cpi	r25, 0x36	; 54
    202a:	20 f4       	brcc	.+8      	; 0x2034 <dtoa_prf+0x28a>
    202c:	95 33       	cpi	r25, 0x35	; 53
    202e:	19 f4       	brne	.+6      	; 0x2036 <dtoa_prf+0x28c>
    2030:	31 11       	cpse	r19, r1
    2032:	01 c0       	rjmp	.+2      	; 0x2036 <dtoa_prf+0x28c>
    2034:	81 e3       	ldi	r24, 0x31	; 49
    2036:	f6 01       	movw	r30, r12
    2038:	80 83       	st	Z, r24
    203a:	f7 01       	movw	r30, r14
    203c:	82 2f       	mov	r24, r18
    203e:	90 e2       	ldi	r25, 0x20	; 32
    2040:	88 23       	and	r24, r24
    2042:	19 f0       	breq	.+6      	; 0x204a <dtoa_prf+0x2a0>
    2044:	91 93       	st	Z+, r25
    2046:	81 50       	subi	r24, 0x01	; 1
    2048:	fb cf       	rjmp	.-10     	; 0x2040 <dtoa_prf+0x296>
    204a:	f7 01       	movw	r30, r14
    204c:	e2 0f       	add	r30, r18
    204e:	f1 1d       	adc	r31, r1
    2050:	10 82       	st	Z, r1
    2052:	80 e0       	ldi	r24, 0x00	; 0
    2054:	90 e0       	ldi	r25, 0x00	; 0
    2056:	29 96       	adiw	r28, 0x09	; 9
    2058:	ec e0       	ldi	r30, 0x0C	; 12
    205a:	0c 94 d6 11 	jmp	0x23ac	; 0x23ac <__epilogue_restores__+0xc>

0000205e <__ftoa_engine>:
    205e:	28 30       	cpi	r18, 0x08	; 8
    2060:	08 f0       	brcs	.+2      	; 0x2064 <__ftoa_engine+0x6>
    2062:	27 e0       	ldi	r18, 0x07	; 7
    2064:	33 27       	eor	r19, r19
    2066:	da 01       	movw	r26, r20
    2068:	99 0f       	add	r25, r25
    206a:	31 1d       	adc	r19, r1
    206c:	87 fd       	sbrc	r24, 7
    206e:	91 60       	ori	r25, 0x01	; 1
    2070:	00 96       	adiw	r24, 0x00	; 0
    2072:	61 05       	cpc	r22, r1
    2074:	71 05       	cpc	r23, r1
    2076:	39 f4       	brne	.+14     	; 0x2086 <__ftoa_engine+0x28>
    2078:	32 60       	ori	r19, 0x02	; 2
    207a:	2e 5f       	subi	r18, 0xFE	; 254
    207c:	3d 93       	st	X+, r19
    207e:	30 e3       	ldi	r19, 0x30	; 48
    2080:	2a 95       	dec	r18
    2082:	e1 f7       	brne	.-8      	; 0x207c <__ftoa_engine+0x1e>
    2084:	08 95       	ret
    2086:	9f 3f       	cpi	r25, 0xFF	; 255
    2088:	30 f0       	brcs	.+12     	; 0x2096 <__ftoa_engine+0x38>
    208a:	80 38       	cpi	r24, 0x80	; 128
    208c:	71 05       	cpc	r23, r1
    208e:	61 05       	cpc	r22, r1
    2090:	09 f0       	breq	.+2      	; 0x2094 <__ftoa_engine+0x36>
    2092:	3c 5f       	subi	r19, 0xFC	; 252
    2094:	3c 5f       	subi	r19, 0xFC	; 252
    2096:	3d 93       	st	X+, r19
    2098:	91 30       	cpi	r25, 0x01	; 1
    209a:	08 f0       	brcs	.+2      	; 0x209e <__ftoa_engine+0x40>
    209c:	80 68       	ori	r24, 0x80	; 128
    209e:	91 1d       	adc	r25, r1
    20a0:	df 93       	push	r29
    20a2:	cf 93       	push	r28
    20a4:	1f 93       	push	r17
    20a6:	0f 93       	push	r16
    20a8:	ff 92       	push	r15
    20aa:	ef 92       	push	r14
    20ac:	19 2f       	mov	r17, r25
    20ae:	98 7f       	andi	r25, 0xF8	; 248
    20b0:	96 95       	lsr	r25
    20b2:	e9 2f       	mov	r30, r25
    20b4:	96 95       	lsr	r25
    20b6:	96 95       	lsr	r25
    20b8:	e9 0f       	add	r30, r25
    20ba:	ff 27       	eor	r31, r31
    20bc:	e4 5e       	subi	r30, 0xE4	; 228
    20be:	fe 4f       	sbci	r31, 0xFE	; 254
    20c0:	99 27       	eor	r25, r25
    20c2:	33 27       	eor	r19, r19
    20c4:	ee 24       	eor	r14, r14
    20c6:	ff 24       	eor	r15, r15
    20c8:	a7 01       	movw	r20, r14
    20ca:	e7 01       	movw	r28, r14
    20cc:	05 90       	lpm	r0, Z+
    20ce:	08 94       	sec
    20d0:	07 94       	ror	r0
    20d2:	28 f4       	brcc	.+10     	; 0x20de <__ftoa_engine+0x80>
    20d4:	36 0f       	add	r19, r22
    20d6:	e7 1e       	adc	r14, r23
    20d8:	f8 1e       	adc	r15, r24
    20da:	49 1f       	adc	r20, r25
    20dc:	51 1d       	adc	r21, r1
    20de:	66 0f       	add	r22, r22
    20e0:	77 1f       	adc	r23, r23
    20e2:	88 1f       	adc	r24, r24
    20e4:	99 1f       	adc	r25, r25
    20e6:	06 94       	lsr	r0
    20e8:	a1 f7       	brne	.-24     	; 0x20d2 <__ftoa_engine+0x74>
    20ea:	05 90       	lpm	r0, Z+
    20ec:	07 94       	ror	r0
    20ee:	28 f4       	brcc	.+10     	; 0x20fa <__ftoa_engine+0x9c>
    20f0:	e7 0e       	add	r14, r23
    20f2:	f8 1e       	adc	r15, r24
    20f4:	49 1f       	adc	r20, r25
    20f6:	56 1f       	adc	r21, r22
    20f8:	c1 1d       	adc	r28, r1
    20fa:	77 0f       	add	r23, r23
    20fc:	88 1f       	adc	r24, r24
    20fe:	99 1f       	adc	r25, r25
    2100:	66 1f       	adc	r22, r22
    2102:	06 94       	lsr	r0
    2104:	a1 f7       	brne	.-24     	; 0x20ee <__ftoa_engine+0x90>
    2106:	05 90       	lpm	r0, Z+
    2108:	07 94       	ror	r0
    210a:	28 f4       	brcc	.+10     	; 0x2116 <__ftoa_engine+0xb8>
    210c:	f8 0e       	add	r15, r24
    210e:	49 1f       	adc	r20, r25
    2110:	56 1f       	adc	r21, r22
    2112:	c7 1f       	adc	r28, r23
    2114:	d1 1d       	adc	r29, r1
    2116:	88 0f       	add	r24, r24
    2118:	99 1f       	adc	r25, r25
    211a:	66 1f       	adc	r22, r22
    211c:	77 1f       	adc	r23, r23
    211e:	06 94       	lsr	r0
    2120:	a1 f7       	brne	.-24     	; 0x210a <__ftoa_engine+0xac>
    2122:	05 90       	lpm	r0, Z+
    2124:	07 94       	ror	r0
    2126:	20 f4       	brcc	.+8      	; 0x2130 <__ftoa_engine+0xd2>
    2128:	49 0f       	add	r20, r25
    212a:	56 1f       	adc	r21, r22
    212c:	c7 1f       	adc	r28, r23
    212e:	d8 1f       	adc	r29, r24
    2130:	99 0f       	add	r25, r25
    2132:	66 1f       	adc	r22, r22
    2134:	77 1f       	adc	r23, r23
    2136:	88 1f       	adc	r24, r24
    2138:	06 94       	lsr	r0
    213a:	a9 f7       	brne	.-22     	; 0x2126 <__ftoa_engine+0xc8>
    213c:	84 91       	lpm	r24, Z
    213e:	10 95       	com	r17
    2140:	17 70       	andi	r17, 0x07	; 7
    2142:	41 f0       	breq	.+16     	; 0x2154 <__ftoa_engine+0xf6>
    2144:	d6 95       	lsr	r29
    2146:	c7 95       	ror	r28
    2148:	57 95       	ror	r21
    214a:	47 95       	ror	r20
    214c:	f7 94       	ror	r15
    214e:	e7 94       	ror	r14
    2150:	1a 95       	dec	r17
    2152:	c1 f7       	brne	.-16     	; 0x2144 <__ftoa_engine+0xe6>
    2154:	e2 ec       	ldi	r30, 0xC2	; 194
    2156:	f0 e0       	ldi	r31, 0x00	; 0
    2158:	68 94       	set
    215a:	15 90       	lpm	r1, Z+
    215c:	15 91       	lpm	r17, Z+
    215e:	35 91       	lpm	r19, Z+
    2160:	65 91       	lpm	r22, Z+
    2162:	95 91       	lpm	r25, Z+
    2164:	05 90       	lpm	r0, Z+
    2166:	7f e2       	ldi	r23, 0x2F	; 47
    2168:	73 95       	inc	r23
    216a:	e1 18       	sub	r14, r1
    216c:	f1 0a       	sbc	r15, r17
    216e:	43 0b       	sbc	r20, r19
    2170:	56 0b       	sbc	r21, r22
    2172:	c9 0b       	sbc	r28, r25
    2174:	d0 09       	sbc	r29, r0
    2176:	c0 f7       	brcc	.-16     	; 0x2168 <__ftoa_engine+0x10a>
    2178:	e1 0c       	add	r14, r1
    217a:	f1 1e       	adc	r15, r17
    217c:	43 1f       	adc	r20, r19
    217e:	56 1f       	adc	r21, r22
    2180:	c9 1f       	adc	r28, r25
    2182:	d0 1d       	adc	r29, r0
    2184:	7e f4       	brtc	.+30     	; 0x21a4 <__ftoa_engine+0x146>
    2186:	70 33       	cpi	r23, 0x30	; 48
    2188:	11 f4       	brne	.+4      	; 0x218e <__ftoa_engine+0x130>
    218a:	8a 95       	dec	r24
    218c:	e6 cf       	rjmp	.-52     	; 0x215a <__ftoa_engine+0xfc>
    218e:	e8 94       	clt
    2190:	01 50       	subi	r16, 0x01	; 1
    2192:	30 f0       	brcs	.+12     	; 0x21a0 <__ftoa_engine+0x142>
    2194:	08 0f       	add	r16, r24
    2196:	0a f4       	brpl	.+2      	; 0x219a <__ftoa_engine+0x13c>
    2198:	00 27       	eor	r16, r16
    219a:	02 17       	cp	r16, r18
    219c:	08 f4       	brcc	.+2      	; 0x21a0 <__ftoa_engine+0x142>
    219e:	20 2f       	mov	r18, r16
    21a0:	23 95       	inc	r18
    21a2:	02 2f       	mov	r16, r18
    21a4:	7a 33       	cpi	r23, 0x3A	; 58
    21a6:	28 f0       	brcs	.+10     	; 0x21b2 <__ftoa_engine+0x154>
    21a8:	79 e3       	ldi	r23, 0x39	; 57
    21aa:	7d 93       	st	X+, r23
    21ac:	2a 95       	dec	r18
    21ae:	e9 f7       	brne	.-6      	; 0x21aa <__ftoa_engine+0x14c>
    21b0:	10 c0       	rjmp	.+32     	; 0x21d2 <__ftoa_engine+0x174>
    21b2:	7d 93       	st	X+, r23
    21b4:	2a 95       	dec	r18
    21b6:	89 f6       	brne	.-94     	; 0x215a <__ftoa_engine+0xfc>
    21b8:	06 94       	lsr	r0
    21ba:	97 95       	ror	r25
    21bc:	67 95       	ror	r22
    21be:	37 95       	ror	r19
    21c0:	17 95       	ror	r17
    21c2:	17 94       	ror	r1
    21c4:	e1 18       	sub	r14, r1
    21c6:	f1 0a       	sbc	r15, r17
    21c8:	43 0b       	sbc	r20, r19
    21ca:	56 0b       	sbc	r21, r22
    21cc:	c9 0b       	sbc	r28, r25
    21ce:	d0 09       	sbc	r29, r0
    21d0:	98 f0       	brcs	.+38     	; 0x21f8 <__ftoa_engine+0x19a>
    21d2:	23 95       	inc	r18
    21d4:	7e 91       	ld	r23, -X
    21d6:	73 95       	inc	r23
    21d8:	7a 33       	cpi	r23, 0x3A	; 58
    21da:	08 f0       	brcs	.+2      	; 0x21de <__ftoa_engine+0x180>
    21dc:	70 e3       	ldi	r23, 0x30	; 48
    21de:	7c 93       	st	X, r23
    21e0:	20 13       	cpse	r18, r16
    21e2:	b8 f7       	brcc	.-18     	; 0x21d2 <__ftoa_engine+0x174>
    21e4:	7e 91       	ld	r23, -X
    21e6:	70 61       	ori	r23, 0x10	; 16
    21e8:	7d 93       	st	X+, r23
    21ea:	30 f0       	brcs	.+12     	; 0x21f8 <__ftoa_engine+0x19a>
    21ec:	83 95       	inc	r24
    21ee:	71 e3       	ldi	r23, 0x31	; 49
    21f0:	7d 93       	st	X+, r23
    21f2:	70 e3       	ldi	r23, 0x30	; 48
    21f4:	2a 95       	dec	r18
    21f6:	e1 f7       	brne	.-8      	; 0x21f0 <__ftoa_engine+0x192>
    21f8:	11 24       	eor	r1, r1
    21fa:	ef 90       	pop	r14
    21fc:	ff 90       	pop	r15
    21fe:	0f 91       	pop	r16
    2200:	1f 91       	pop	r17
    2202:	cf 91       	pop	r28
    2204:	df 91       	pop	r29
    2206:	99 27       	eor	r25, r25
    2208:	87 fd       	sbrc	r24, 7
    220a:	90 95       	com	r25
    220c:	08 95       	ret

0000220e <strnlen_P>:
    220e:	fc 01       	movw	r30, r24
    2210:	05 90       	lpm	r0, Z+
    2212:	61 50       	subi	r22, 0x01	; 1
    2214:	70 40       	sbci	r23, 0x00	; 0
    2216:	01 10       	cpse	r0, r1
    2218:	d8 f7       	brcc	.-10     	; 0x2210 <strnlen_P+0x2>
    221a:	80 95       	com	r24
    221c:	90 95       	com	r25
    221e:	8e 0f       	add	r24, r30
    2220:	9f 1f       	adc	r25, r31
    2222:	08 95       	ret

00002224 <strnlen>:
    2224:	fc 01       	movw	r30, r24
    2226:	61 50       	subi	r22, 0x01	; 1
    2228:	70 40       	sbci	r23, 0x00	; 0
    222a:	01 90       	ld	r0, Z+
    222c:	01 10       	cpse	r0, r1
    222e:	d8 f7       	brcc	.-10     	; 0x2226 <strnlen+0x2>
    2230:	80 95       	com	r24
    2232:	90 95       	com	r25
    2234:	8e 0f       	add	r24, r30
    2236:	9f 1f       	adc	r25, r31
    2238:	08 95       	ret

0000223a <fputc>:
    223a:	0f 93       	push	r16
    223c:	1f 93       	push	r17
    223e:	cf 93       	push	r28
    2240:	df 93       	push	r29
    2242:	fb 01       	movw	r30, r22
    2244:	23 81       	ldd	r18, Z+3	; 0x03
    2246:	21 fd       	sbrc	r18, 1
    2248:	03 c0       	rjmp	.+6      	; 0x2250 <fputc+0x16>
    224a:	8f ef       	ldi	r24, 0xFF	; 255
    224c:	9f ef       	ldi	r25, 0xFF	; 255
    224e:	2c c0       	rjmp	.+88     	; 0x22a8 <fputc+0x6e>
    2250:	22 ff       	sbrs	r18, 2
    2252:	16 c0       	rjmp	.+44     	; 0x2280 <fputc+0x46>
    2254:	46 81       	ldd	r20, Z+6	; 0x06
    2256:	57 81       	ldd	r21, Z+7	; 0x07
    2258:	24 81       	ldd	r18, Z+4	; 0x04
    225a:	35 81       	ldd	r19, Z+5	; 0x05
    225c:	42 17       	cp	r20, r18
    225e:	53 07       	cpc	r21, r19
    2260:	44 f4       	brge	.+16     	; 0x2272 <fputc+0x38>
    2262:	a0 81       	ld	r26, Z
    2264:	b1 81       	ldd	r27, Z+1	; 0x01
    2266:	9d 01       	movw	r18, r26
    2268:	2f 5f       	subi	r18, 0xFF	; 255
    226a:	3f 4f       	sbci	r19, 0xFF	; 255
    226c:	20 83       	st	Z, r18
    226e:	31 83       	std	Z+1, r19	; 0x01
    2270:	8c 93       	st	X, r24
    2272:	26 81       	ldd	r18, Z+6	; 0x06
    2274:	37 81       	ldd	r19, Z+7	; 0x07
    2276:	2f 5f       	subi	r18, 0xFF	; 255
    2278:	3f 4f       	sbci	r19, 0xFF	; 255
    227a:	26 83       	std	Z+6, r18	; 0x06
    227c:	37 83       	std	Z+7, r19	; 0x07
    227e:	14 c0       	rjmp	.+40     	; 0x22a8 <fputc+0x6e>
    2280:	8b 01       	movw	r16, r22
    2282:	ec 01       	movw	r28, r24
    2284:	fb 01       	movw	r30, r22
    2286:	00 84       	ldd	r0, Z+8	; 0x08
    2288:	f1 85       	ldd	r31, Z+9	; 0x09
    228a:	e0 2d       	mov	r30, r0
    228c:	09 95       	icall
    228e:	89 2b       	or	r24, r25
    2290:	e1 f6       	brne	.-72     	; 0x224a <fputc+0x10>
    2292:	d8 01       	movw	r26, r16
    2294:	16 96       	adiw	r26, 0x06	; 6
    2296:	8d 91       	ld	r24, X+
    2298:	9c 91       	ld	r25, X
    229a:	17 97       	sbiw	r26, 0x07	; 7
    229c:	01 96       	adiw	r24, 0x01	; 1
    229e:	16 96       	adiw	r26, 0x06	; 6
    22a0:	8d 93       	st	X+, r24
    22a2:	9c 93       	st	X, r25
    22a4:	17 97       	sbiw	r26, 0x07	; 7
    22a6:	ce 01       	movw	r24, r28
    22a8:	df 91       	pop	r29
    22aa:	cf 91       	pop	r28
    22ac:	1f 91       	pop	r17
    22ae:	0f 91       	pop	r16
    22b0:	08 95       	ret

000022b2 <__ultoa_invert>:
    22b2:	fa 01       	movw	r30, r20
    22b4:	aa 27       	eor	r26, r26
    22b6:	28 30       	cpi	r18, 0x08	; 8
    22b8:	51 f1       	breq	.+84     	; 0x230e <__ultoa_invert+0x5c>
    22ba:	20 31       	cpi	r18, 0x10	; 16
    22bc:	81 f1       	breq	.+96     	; 0x231e <__ultoa_invert+0x6c>
    22be:	e8 94       	clt
    22c0:	6f 93       	push	r22
    22c2:	6e 7f       	andi	r22, 0xFE	; 254
    22c4:	6e 5f       	subi	r22, 0xFE	; 254
    22c6:	7f 4f       	sbci	r23, 0xFF	; 255
    22c8:	8f 4f       	sbci	r24, 0xFF	; 255
    22ca:	9f 4f       	sbci	r25, 0xFF	; 255
    22cc:	af 4f       	sbci	r26, 0xFF	; 255
    22ce:	b1 e0       	ldi	r27, 0x01	; 1
    22d0:	3e d0       	rcall	.+124    	; 0x234e <__ultoa_invert+0x9c>
    22d2:	b4 e0       	ldi	r27, 0x04	; 4
    22d4:	3c d0       	rcall	.+120    	; 0x234e <__ultoa_invert+0x9c>
    22d6:	67 0f       	add	r22, r23
    22d8:	78 1f       	adc	r23, r24
    22da:	89 1f       	adc	r24, r25
    22dc:	9a 1f       	adc	r25, r26
    22de:	a1 1d       	adc	r26, r1
    22e0:	68 0f       	add	r22, r24
    22e2:	79 1f       	adc	r23, r25
    22e4:	8a 1f       	adc	r24, r26
    22e6:	91 1d       	adc	r25, r1
    22e8:	a1 1d       	adc	r26, r1
    22ea:	6a 0f       	add	r22, r26
    22ec:	71 1d       	adc	r23, r1
    22ee:	81 1d       	adc	r24, r1
    22f0:	91 1d       	adc	r25, r1
    22f2:	a1 1d       	adc	r26, r1
    22f4:	20 d0       	rcall	.+64     	; 0x2336 <__ultoa_invert+0x84>
    22f6:	09 f4       	brne	.+2      	; 0x22fa <__ultoa_invert+0x48>
    22f8:	68 94       	set
    22fa:	3f 91       	pop	r19
    22fc:	2a e0       	ldi	r18, 0x0A	; 10
    22fe:	26 9f       	mul	r18, r22
    2300:	11 24       	eor	r1, r1
    2302:	30 19       	sub	r19, r0
    2304:	30 5d       	subi	r19, 0xD0	; 208
    2306:	31 93       	st	Z+, r19
    2308:	de f6       	brtc	.-74     	; 0x22c0 <__ultoa_invert+0xe>
    230a:	cf 01       	movw	r24, r30
    230c:	08 95       	ret
    230e:	46 2f       	mov	r20, r22
    2310:	47 70       	andi	r20, 0x07	; 7
    2312:	40 5d       	subi	r20, 0xD0	; 208
    2314:	41 93       	st	Z+, r20
    2316:	b3 e0       	ldi	r27, 0x03	; 3
    2318:	0f d0       	rcall	.+30     	; 0x2338 <__ultoa_invert+0x86>
    231a:	c9 f7       	brne	.-14     	; 0x230e <__ultoa_invert+0x5c>
    231c:	f6 cf       	rjmp	.-20     	; 0x230a <__ultoa_invert+0x58>
    231e:	46 2f       	mov	r20, r22
    2320:	4f 70       	andi	r20, 0x0F	; 15
    2322:	40 5d       	subi	r20, 0xD0	; 208
    2324:	4a 33       	cpi	r20, 0x3A	; 58
    2326:	18 f0       	brcs	.+6      	; 0x232e <__ultoa_invert+0x7c>
    2328:	49 5d       	subi	r20, 0xD9	; 217
    232a:	31 fd       	sbrc	r19, 1
    232c:	40 52       	subi	r20, 0x20	; 32
    232e:	41 93       	st	Z+, r20
    2330:	02 d0       	rcall	.+4      	; 0x2336 <__ultoa_invert+0x84>
    2332:	a9 f7       	brne	.-22     	; 0x231e <__ultoa_invert+0x6c>
    2334:	ea cf       	rjmp	.-44     	; 0x230a <__ultoa_invert+0x58>
    2336:	b4 e0       	ldi	r27, 0x04	; 4
    2338:	a6 95       	lsr	r26
    233a:	97 95       	ror	r25
    233c:	87 95       	ror	r24
    233e:	77 95       	ror	r23
    2340:	67 95       	ror	r22
    2342:	ba 95       	dec	r27
    2344:	c9 f7       	brne	.-14     	; 0x2338 <__ultoa_invert+0x86>
    2346:	00 97       	sbiw	r24, 0x00	; 0
    2348:	61 05       	cpc	r22, r1
    234a:	71 05       	cpc	r23, r1
    234c:	08 95       	ret
    234e:	9b 01       	movw	r18, r22
    2350:	ac 01       	movw	r20, r24
    2352:	0a 2e       	mov	r0, r26
    2354:	06 94       	lsr	r0
    2356:	57 95       	ror	r21
    2358:	47 95       	ror	r20
    235a:	37 95       	ror	r19
    235c:	27 95       	ror	r18
    235e:	ba 95       	dec	r27
    2360:	c9 f7       	brne	.-14     	; 0x2354 <__ultoa_invert+0xa2>
    2362:	62 0f       	add	r22, r18
    2364:	73 1f       	adc	r23, r19
    2366:	84 1f       	adc	r24, r20
    2368:	95 1f       	adc	r25, r21
    236a:	a0 1d       	adc	r26, r0
    236c:	08 95       	ret

0000236e <__prologue_saves__>:
    236e:	2f 92       	push	r2
    2370:	3f 92       	push	r3
    2372:	4f 92       	push	r4
    2374:	5f 92       	push	r5
    2376:	6f 92       	push	r6
    2378:	7f 92       	push	r7
    237a:	8f 92       	push	r8
    237c:	9f 92       	push	r9
    237e:	af 92       	push	r10
    2380:	bf 92       	push	r11
    2382:	cf 92       	push	r12
    2384:	df 92       	push	r13
    2386:	ef 92       	push	r14
    2388:	ff 92       	push	r15
    238a:	0f 93       	push	r16
    238c:	1f 93       	push	r17
    238e:	cf 93       	push	r28
    2390:	df 93       	push	r29
    2392:	cd b7       	in	r28, 0x3d	; 61
    2394:	de b7       	in	r29, 0x3e	; 62
    2396:	ca 1b       	sub	r28, r26
    2398:	db 0b       	sbc	r29, r27
    239a:	cd bf       	out	0x3d, r28	; 61
    239c:	de bf       	out	0x3e, r29	; 62
    239e:	09 94       	ijmp

000023a0 <__epilogue_restores__>:
    23a0:	2a 88       	ldd	r2, Y+18	; 0x12
    23a2:	39 88       	ldd	r3, Y+17	; 0x11
    23a4:	48 88       	ldd	r4, Y+16	; 0x10
    23a6:	5f 84       	ldd	r5, Y+15	; 0x0f
    23a8:	6e 84       	ldd	r6, Y+14	; 0x0e
    23aa:	7d 84       	ldd	r7, Y+13	; 0x0d
    23ac:	8c 84       	ldd	r8, Y+12	; 0x0c
    23ae:	9b 84       	ldd	r9, Y+11	; 0x0b
    23b0:	aa 84       	ldd	r10, Y+10	; 0x0a
    23b2:	b9 84       	ldd	r11, Y+9	; 0x09
    23b4:	c8 84       	ldd	r12, Y+8	; 0x08
    23b6:	df 80       	ldd	r13, Y+7	; 0x07
    23b8:	ee 80       	ldd	r14, Y+6	; 0x06
    23ba:	fd 80       	ldd	r15, Y+5	; 0x05
    23bc:	0c 81       	ldd	r16, Y+4	; 0x04
    23be:	1b 81       	ldd	r17, Y+3	; 0x03
    23c0:	aa 81       	ldd	r26, Y+2	; 0x02
    23c2:	b9 81       	ldd	r27, Y+1	; 0x01
    23c4:	ce 0f       	add	r28, r30
    23c6:	d1 1d       	adc	r29, r1
    23c8:	cd bf       	out	0x3d, r28	; 61
    23ca:	de bf       	out	0x3e, r29	; 62
    23cc:	ed 01       	movw	r28, r26
    23ce:	08 95       	ret

000023d0 <_exit>:
    23d0:	f8 94       	cli

000023d2 <__stop_program>:
    23d2:	ff cf       	rjmp	.-2      	; 0x23d2 <__stop_program>
