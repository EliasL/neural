
Hjernebyggesett_V4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000016  00803800  00002478  0000252c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000240e  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000006a  0000a40e  0000240e  000024c2  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .bss          00000056  00803816  00803816  00002542  2**0
                  ALLOC
  4 .comment      0000005c  00000000  00000000  00002542  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000025a0  2**2
                  CONTENTS, READONLY
  6 .debug_aranges 000004e8  00000000  00000000  000025e0  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00008753  00000000  00000000  00002ac8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 000036da  00000000  00000000  0000b21b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00002978  00000000  00000000  0000e8f5  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000008d0  00000000  00000000  00011270  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00003540  00000000  00000000  00011b40  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000173f  00000000  00000000  00015080  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000360  00000000  00000000  000167bf  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 de 00 	jmp	0x1bc	; 0x1bc <__ctors_end>
       4:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
       8:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
       c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      10:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      14:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      18:	0c 94 9e 05 	jmp	0xb3c	; 0xb3c <__vector_6>
      1c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      20:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      24:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      28:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      2c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      30:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      34:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      38:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      3c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      40:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      44:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      48:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      4c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      50:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      54:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      58:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      5c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      60:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      64:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      68:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      6c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      70:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      74:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      78:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      7c:	07 63       	ori	r16, 0x37	; 55
      7e:	42 36       	cpi	r20, 0x62	; 98
      80:	b7 9b       	sbis	0x16, 7	; 22
      82:	d8 a7       	std	Y+40, r29	; 0x28
      84:	1a 39       	cpi	r17, 0x9A	; 154
      86:	68 56       	subi	r22, 0x68	; 104
      88:	18 ae       	std	Y+56, r1	; 0x38
      8a:	ba ab       	std	Y+50, r27	; 0x32
      8c:	55 8c       	ldd	r5, Z+29	; 0x1d
      8e:	1d 3c       	cpi	r17, 0xCD	; 205
      90:	b7 cc       	rjmp	.-1682   	; 0xfffffa00 <__eeprom_end+0xff7efa00>
      92:	57 63       	ori	r21, 0x37	; 55
      94:	bd 6d       	ori	r27, 0xDD	; 221
      96:	ed fd       	.word	0xfded	; ????
      98:	75 3e       	cpi	r23, 0xE5	; 229
      9a:	f6 17       	cp	r31, r22
      9c:	72 31       	cpi	r23, 0x12	; 18
      9e:	bf 00       	.word	0x00bf	; ????
      a0:	00 00       	nop
      a2:	80 3f       	cpi	r24, 0xF0	; 240
      a4:	05 a8       	ldd	r0, Z+53	; 0x35
      a6:	4c cd       	rjmp	.-1384   	; 0xfffffb40 <__eeprom_end+0xff7efb40>
      a8:	b2 d4       	rcall	.+2404   	; 0xa0e <tinyDendrite_update_signals+0x6e>
      aa:	4e b9       	out	0x0e, r20	; 14
      ac:	38 36       	cpi	r19, 0x68	; 104
      ae:	a9 02       	muls	r26, r25
      b0:	0c 50       	subi	r16, 0x0C	; 12
      b2:	b9 91       	ld	r27, Y+
      b4:	86 88       	ldd	r8, Z+22	; 0x16
      b6:	08 3c       	cpi	r16, 0xC8	; 200
      b8:	a6 aa       	std	Z+54, r10	; 0x36
      ba:	aa 2a       	or	r10, r26
      bc:	be 00       	.word	0x00be	; ????
      be:	00 00       	nop
      c0:	80 3f       	cpi	r24, 0xF0	; 240

000000c2 <__trampolines_end>:
      c2:	00 40       	sbci	r16, 0x00	; 0
      c4:	7a 10       	cpse	r7, r10
      c6:	f3 5a       	subi	r31, 0xA3	; 163
      c8:	00 a0       	ldd	r0, Z+32	; 0x20
      ca:	72 4e       	sbci	r23, 0xE2	; 226
      cc:	18 09       	sbc	r17, r8
      ce:	00 10       	cpse	r0, r0
      d0:	a5 d4       	rcall	.+2378   	; 0xa1c <tinyDendrite_update_signals+0x7c>
      d2:	e8 00       	.word	0x00e8	; ????
      d4:	00 e8       	ldi	r16, 0x80	; 128
      d6:	76 48       	sbci	r23, 0x86	; 134
      d8:	17 00       	.word	0x0017	; ????
      da:	00 e4       	ldi	r16, 0x40	; 64
      dc:	0b 54       	subi	r16, 0x4B	; 75
      de:	02 00       	.word	0x0002	; ????
      e0:	00 ca       	rjmp	.-3072   	; 0xfffff4e2 <__eeprom_end+0xff7ef4e2>
      e2:	9a 3b       	cpi	r25, 0xBA	; 186
      e4:	00 00       	nop
      e6:	00 e1       	ldi	r16, 0x10	; 16
      e8:	f5 05       	cpc	r31, r5
      ea:	00 00       	nop
      ec:	80 96       	adiw	r24, 0x20	; 32
      ee:	98 00       	.word	0x0098	; ????
      f0:	00 00       	nop
      f2:	40 42       	sbci	r20, 0x20	; 32
      f4:	0f 00       	.word	0x000f	; ????
      f6:	00 00       	nop
      f8:	a0 86       	std	Z+8, r10	; 0x08
      fa:	01 00       	.word	0x0001	; ????
      fc:	00 00       	nop
      fe:	10 27       	eor	r17, r16
     100:	00 00       	nop
     102:	00 00       	nop
     104:	e8 03       	fmulsu	r22, r16
     106:	00 00       	nop
     108:	00 00       	nop
     10a:	64 00       	.word	0x0064	; ????
     10c:	00 00       	nop
     10e:	00 00       	nop
     110:	0a 00       	.word	0x000a	; ????
     112:	00 00       	nop
     114:	00 00       	nop
     116:	01 00       	.word	0x0001	; ????
     118:	00 00       	nop
     11a:	00 00       	nop
     11c:	2c 76       	andi	r18, 0x6C	; 108
     11e:	d8 88       	ldd	r13, Y+16	; 0x10
     120:	dc 67       	ori	r29, 0x7C	; 124
     122:	4f 08       	sbc	r4, r15
     124:	23 df       	rcall	.-442    	; 0xffffff6c <__eeprom_end+0xff7eff6c>
     126:	c1 df       	rcall	.-126    	; 0xaa <__SREG__+0x6b>
     128:	ae 59       	subi	r26, 0x9E	; 158
     12a:	e1 b1       	in	r30, 0x01	; 1
     12c:	b7 96       	adiw	r30, 0x27	; 39
     12e:	e5 e3       	ldi	r30, 0x35	; 53
     130:	e4 53       	subi	r30, 0x34	; 52
     132:	c6 3a       	cpi	r28, 0xA6	; 166
     134:	e6 51       	subi	r30, 0x16	; 22
     136:	99 76       	andi	r25, 0x69	; 105
     138:	96 e8       	ldi	r25, 0x86	; 134
     13a:	e6 c2       	rjmp	.+1484   	; 0x708 <tinyAxon_update_potential+0x108>
     13c:	84 26       	eor	r8, r20
     13e:	eb 89       	ldd	r30, Y+19	; 0x13
     140:	8c 9b       	sbis	0x11, 4	; 17
     142:	62 ed       	ldi	r22, 0xD2	; 210
     144:	40 7c       	andi	r20, 0xC0	; 192
     146:	6f fc       	.word	0xfc6f	; ????
     148:	ef bc       	out	0x2f, r14	; 47
     14a:	9c 9f       	mul	r25, r28
     14c:	40 f2       	brcs	.-112    	; 0xde <__trampolines_end+0x1c>
     14e:	ba a5       	ldd	r27, Y+42	; 0x2a
     150:	6f a5       	ldd	r22, Y+47	; 0x2f
     152:	f4 90       	lpm	r15, Z
     154:	05 5a       	subi	r16, 0xA5	; 165
     156:	2a f7       	brpl	.-54     	; 0x122 <__trampolines_end+0x60>
     158:	5c 93       	st	X, r21
     15a:	6b 6c       	ori	r22, 0xCB	; 203
     15c:	f9 67       	ori	r31, 0x79	; 121
     15e:	6d c1       	rjmp	.+730    	; 0x43a <system_init+0x6>
     160:	1b fc       	.word	0xfc1b	; ????
     162:	e0 e4       	ldi	r30, 0x40	; 64
     164:	0d 47       	sbci	r16, 0x7D	; 125
     166:	fe f5       	brtc	.+126    	; 0x1e6 <.do_clear_bss_loop>
     168:	20 e6       	ldi	r18, 0x60	; 96
     16a:	b5 00       	.word	0x00b5	; ????
     16c:	d0 ed       	ldi	r29, 0xD0	; 208
     16e:	90 2e       	mov	r9, r16
     170:	03 00       	.word	0x0003	; ????
     172:	94 35       	cpi	r25, 0x54	; 84
     174:	77 05       	cpc	r23, r7
     176:	00 80       	ld	r0, Z
     178:	84 1e       	adc	r8, r20
     17a:	08 00       	.word	0x0008	; ????
     17c:	00 20       	and	r0, r0
     17e:	4e 0a       	sbc	r4, r30
     180:	00 00       	nop
     182:	00 c8       	rjmp	.-4096   	; 0xfffff184 <__eeprom_end+0xff7ef184>
     184:	0c 33       	cpi	r16, 0x3C	; 60
     186:	33 33       	cpi	r19, 0x33	; 51
     188:	33 0f       	add	r19, r19
     18a:	98 6e       	ori	r25, 0xE8	; 232
     18c:	12 83       	std	Z+2, r17	; 0x02
     18e:	11 41       	sbci	r17, 0x11	; 17
     190:	ef 8d       	ldd	r30, Y+31	; 0x1f
     192:	21 14       	cp	r2, r1
     194:	89 3b       	cpi	r24, 0xB9	; 185
     196:	e6 55       	subi	r30, 0x56	; 86
     198:	16 cf       	rjmp	.-468    	; 0xffffffc6 <__eeprom_end+0xff7effc6>
     19a:	fe e6       	ldi	r31, 0x6E	; 110
     19c:	db 18       	sub	r13, r11
     19e:	d1 84       	ldd	r13, Z+9	; 0x09
     1a0:	4b 38       	cpi	r20, 0x8B	; 139
     1a2:	1b f7       	brvc	.-58     	; 0x16a <__trampolines_end+0xa8>
     1a4:	7c 1d       	adc	r23, r12
     1a6:	90 1d       	adc	r25, r0
     1a8:	a4 bb       	out	0x14, r26	; 20
     1aa:	e4 24       	eor	r14, r4
     1ac:	20 32       	cpi	r18, 0x20	; 32
     1ae:	84 72       	andi	r24, 0x24	; 36
     1b0:	5e 22       	and	r5, r30
     1b2:	81 00       	.word	0x0081	; ????
     1b4:	c9 f1       	breq	.+114    	; 0x228 <main+0x28>
     1b6:	24 ec       	ldi	r18, 0xC4	; 196
     1b8:	a1 e5       	ldi	r26, 0x51	; 81
     1ba:	3d 27       	eor	r19, r29

000001bc <__ctors_end>:
     1bc:	11 24       	eor	r1, r1
     1be:	1f be       	out	0x3f, r1	; 63
     1c0:	cf ef       	ldi	r28, 0xFF	; 255
     1c2:	cd bf       	out	0x3d, r28	; 61
     1c4:	df e3       	ldi	r29, 0x3F	; 63
     1c6:	de bf       	out	0x3e, r29	; 62

000001c8 <__do_copy_data>:
     1c8:	18 e3       	ldi	r17, 0x38	; 56
     1ca:	a0 e0       	ldi	r26, 0x00	; 0
     1cc:	b8 e3       	ldi	r27, 0x38	; 56
     1ce:	e8 e7       	ldi	r30, 0x78	; 120
     1d0:	f4 e2       	ldi	r31, 0x24	; 36
     1d2:	02 c0       	rjmp	.+4      	; 0x1d8 <__do_copy_data+0x10>
     1d4:	05 90       	lpm	r0, Z+
     1d6:	0d 92       	st	X+, r0
     1d8:	a6 31       	cpi	r26, 0x16	; 22
     1da:	b1 07       	cpc	r27, r17
     1dc:	d9 f7       	brne	.-10     	; 0x1d4 <__do_copy_data+0xc>

000001de <__do_clear_bss>:
     1de:	28 e3       	ldi	r18, 0x38	; 56
     1e0:	a6 e1       	ldi	r26, 0x16	; 22
     1e2:	b8 e3       	ldi	r27, 0x38	; 56
     1e4:	01 c0       	rjmp	.+2      	; 0x1e8 <.do_clear_bss_start>

000001e6 <.do_clear_bss_loop>:
     1e6:	1d 92       	st	X+, r1

000001e8 <.do_clear_bss_start>:
     1e8:	ac 36       	cpi	r26, 0x6C	; 108
     1ea:	b2 07       	cpc	r27, r18
     1ec:	e1 f7       	brne	.-8      	; 0x1e6 <.do_clear_bss_loop>
     1ee:	0e 94 00 01 	call	0x200	; 0x200 <main>
     1f2:	0c 94 05 12 	jmp	0x240a	; 0x240a <_exit>

000001f6 <__bad_interrupt>:
     1f6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000001fa <atmel_start_init>:
/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
	system_init();
     1fa:	0e 94 1a 02 	call	0x434	; 0x434 <system_init>
     1fe:	08 95       	ret

00000200 <main>:

int main(void)
{	
	
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
     200:	0e 94 fd 00 	call	0x1fa	; 0x1fa <atmel_start_init>
	For some reason, instead of the reference voltage being 4.32v, it is 3.3v. 
	A plausible explanation is that the microchip does not up the voltage, so that if the microchip is only ever 
	supplied with 3.3v, it will output 3.3v as the max.
	*/
	
	VREF.CTRLA |= VREF_DAC0REFSEL_4V34_gc;
     204:	e0 ea       	ldi	r30, 0xA0	; 160
     206:	f0 e0       	ldi	r31, 0x00	; 0
     208:	80 81       	ld	r24, Z
     20a:	83 60       	ori	r24, 0x03	; 3
     20c:	80 83       	st	Z, r24
	while (1)
	{
		// We don't want to update the neuron too often because of various reasons. The tinyISR_getflag is set every ms, and so the loop is only run once every ms.  
		if(tinyISR_getflag())
     20e:	0e 94 cc 05 	call	0xb98	; 0xb98 <tinyISR_getflag>
     212:	88 23       	and	r24, r24
     214:	e1 f3       	breq	.-8      	; 0x20e <main+0xe>
		{
			
			if(tinyCharge_is_connected_to_charger()){
     216:	0e 94 14 04 	call	0x828	; 0x828 <tinyCharge_is_connected_to_charger>
     21a:	88 23       	and	r24, r24
     21c:	59 f0       	breq	.+22     	; 0x234 <main+0x34>
				// Charge loop
				
				if(tinyCharge_is_fully_charged()){
     21e:	0e 94 17 04 	call	0x82e	; 0x82e <tinyCharge_is_fully_charged>
     222:	88 23       	and	r24, r24
     224:	21 f0       	breq	.+8      	; 0x22e <main+0x2e>
					tinyLED_set_color(OUT_LED, CHARGING_DONE_COLOR);
     226:	63 e0       	ldi	r22, 0x03	; 3
     228:	80 e0       	ldi	r24, 0x00	; 0
     22a:	0e 94 e3 05 	call	0xbc6	; 0xbc6 <tinyLED_set_color>
				}				
				// We check the Dendrites in order to detect if we have stopped charging
				tinyDendrite_update_signals();
     22e:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <tinyDendrite_update_signals>
     232:	0d c0       	rjmp	.+26     	; 0x24e <main+0x4e>
			}
			else{
				// Main loop			
				
				// Set LED
				if(tinyLED_get_color(OUT_LED) == OFF){
     234:	80 e0       	ldi	r24, 0x00	; 0
     236:	0e 94 ec 05 	call	0xbd8	; 0xbd8 <tinyLED_get_color>
     23a:	81 11       	cpse	r24, r1
     23c:	04 c0       	rjmp	.+8      	; 0x246 <main+0x46>
					tinyLED_set_color_mode(OUT_LED, PING_COLOR, PING);
     23e:	43 e0       	ldi	r20, 0x03	; 3
     240:	62 e0       	ldi	r22, 0x02	; 2
     242:	0e 94 f4 05 	call	0xbe8	; 0xbe8 <tinyLED_set_color_mode>
				}
				
				// Update button	
				tinyButton_update();
     246:	0e 94 b5 03 	call	0x76a	; 0x76a <tinyButton_update>
				
				// Update the potential (This is where most of the important stuff happens)
				tinyPotential_update();
     24a:	0e 94 0d 08 	call	0x101a	; 0x101a <tinyPotential_update>
			}
			// Update LED
			tinyLED_update();
     24e:	0e 94 34 06 	call	0xc68	; 0xc68 <tinyLED_update>
				
			// Switch transistors
			tinyCharge_set_transistors();
     252:	0e 94 4c 04 	call	0x898	; 0x898 <tinyCharge_set_transistors>
			
			// Prepare for next cycle
			tinyISR_setflag(false);
     256:	80 e0       	ldi	r24, 0x00	; 0
     258:	0e 94 c9 05 	call	0xb92	; 0xb92 <tinyISR_setflag>
			tinyDebugger_send_uint32("time", tinyTime_now());
     25c:	0e 94 ea 08 	call	0x11d4	; 0x11d4 <tinyTime_now>
     260:	ab 01       	movw	r20, r22
     262:	bc 01       	movw	r22, r24
     264:	8e e0       	ldi	r24, 0x0E	; 14
     266:	94 ea       	ldi	r25, 0xA4	; 164
     268:	0e 94 54 04 	call	0x8a8	; 0x8a8 <tinyDebugger_send_uint32>
			tinyDebugger_end_line();
     26c:	0e 94 bb 04 	call	0x976	; 0x976 <tinyDebugger_end_line>
     270:	ce cf       	rjmp	.-100    	; 0x20e <main+0xe>

00000272 <ADC_0_init>:
 * \return Conversion result read from the ADC_0 ADC module
 */
adc_result_t ADC_0_get_conversion_result(void)
{
	return (ADC1.RES);
}
     272:	e0 e4       	ldi	r30, 0x40	; 64
     274:	f6 e0       	ldi	r31, 0x06	; 6
     276:	80 e1       	ldi	r24, 0x10	; 16
     278:	82 83       	std	Z+2, r24	; 0x02
     27a:	85 e0       	ldi	r24, 0x05	; 5
     27c:	80 83       	st	Z, r24
     27e:	80 e0       	ldi	r24, 0x00	; 0
     280:	08 95       	ret

00000282 <ADC_0_is_conversion_done>:
     282:	80 91 4b 06 	lds	r24, 0x064B	; 0x80064b <__TEXT_REGION_LENGTH__+0x70064b>
     286:	81 70       	andi	r24, 0x01	; 1
     288:	08 95       	ret

0000028a <ADC_0_get_conversion>:
 *
 * \return Nothing
 */
void ADC_0_start_conversion(adc_1_channel_t channel)
{
	ADC1.MUXPOS  = channel;
     28a:	e0 e4       	ldi	r30, 0x40	; 64
     28c:	f6 e0       	ldi	r31, 0x06	; 6
     28e:	86 83       	std	Z+6, r24	; 0x06
	ADC1.COMMAND = ADC_STCONV_bm;
     290:	81 e0       	ldi	r24, 0x01	; 1
     292:	80 87       	std	Z+8, r24	; 0x08
adc_result_t ADC_0_get_conversion(adc_1_channel_t channel)
{
	adc_result_t res;

	ADC_0_start_conversion(channel);
	while (!ADC_0_is_conversion_done())
     294:	0e 94 41 01 	call	0x282	; 0x282 <ADC_0_is_conversion_done>
     298:	88 23       	and	r24, r24
     29a:	e1 f3       	breq	.-8      	; 0x294 <ADC_0_get_conversion+0xa>
 *
 * \return Conversion result read from the ADC_0 ADC module
 */
adc_result_t ADC_0_get_conversion_result(void)
{
	return (ADC1.RES);
     29c:	e0 e4       	ldi	r30, 0x40	; 64
     29e:	f6 e0       	ldi	r31, 0x06	; 6
     2a0:	20 89       	ldd	r18, Z+16	; 0x10
     2a2:	31 89       	ldd	r19, Z+17	; 0x11

	ADC_0_start_conversion(channel);
	while (!ADC_0_is_conversion_done())
		;
	res = ADC_0_get_conversion_result();
	ADC1.INTFLAGS |= ADC_RESRDY_bm;
     2a4:	93 85       	ldd	r25, Z+11	; 0x0b
     2a6:	91 60       	ori	r25, 0x01	; 1
     2a8:	93 87       	std	Z+11, r25	; 0x0b
	return res;
}
     2aa:	c9 01       	movw	r24, r18
     2ac:	08 95       	ret

000002ae <BOD_init>:
	//		 | BOD_VLMCFG_BELOW_gc; /* Interrupt when supply goes below VLM level */

	// BOD.VLMCTRLA = BOD_VLMLVL_5ABOVE_gc; /* VLM threshold 5% above BOD level */

	return 0;
}
     2ae:	80 e0       	ldi	r24, 0x00	; 0
     2b0:	08 95       	ret

000002b2 <DIGITAL_GLUE_LOGIC_0_init>:

	// Enable Protected register, peripheral must be disabled (ENABLE=0, in TCD.LUT0CTRLA).

	// CCL.SEQCTRL0 = CCL_SEQSEL_DISABLE_gc /* Sequential logic disabled */;

	CCL.TRUTH0 = 168; /* Truth 0: 168 */
     2b2:	e0 ec       	ldi	r30, 0xC0	; 192
     2b4:	f1 e0       	ldi	r31, 0x01	; 1
     2b6:	28 ea       	ldi	r18, 0xA8	; 168
     2b8:	20 87       	std	Z+8, r18	; 0x08

	CCL.LUT0CTRLC = CCL_INSEL2_TCA0_gc /* TCA0 WO2 input source */;
     2ba:	98 e0       	ldi	r25, 0x08	; 8
     2bc:	97 83       	std	Z+7, r25	; 0x07

	CCL.LUT0CTRLB = CCL_INSEL0_SPI0_gc /* SPI0 SCK source */
     2be:	8b eb       	ldi	r24, 0xBB	; 187
     2c0:	86 83       	std	Z+6, r24	; 0x06
	                | CCL_INSEL1_SPI0_gc /* SPI0 MOSI input source */;

	CCL.LUT0CTRLA = 0 << CCL_CLKSRC_bp       /* Clock Source Selection: disabled */
     2c2:	39 e0       	ldi	r19, 0x09	; 9
     2c4:	35 83       	std	Z+5, r19	; 0x05
	                | CCL_EDGEDET_DIS_gc     /* Edge detector is disabled */
	                | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	                | 1 << CCL_ENABLE_bp     /* LUT Enable: enabled */
	                | 1 << CCL_OUTEN_bp;     /* Output Enable: enabled */

	CCL.TRUTH1 = 168; /* Truth 1: 168 */
     2c6:	24 87       	std	Z+12, r18	; 0x0c

	CCL.LUT1CTRLC = CCL_INSEL2_TCA0_gc /* TCA0 WO2 input source */;
     2c8:	93 87       	std	Z+11, r25	; 0x0b

	CCL.LUT1CTRLB = CCL_INSEL0_SPI0_gc /* SPI0 SCK source */
     2ca:	82 87       	std	Z+10, r24	; 0x0a
	//		 | CCL_EDGEDET_DIS_gc /* Edge detector is disabled */
	//		 | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	//		 | 0 << CCL_ENABLE_bp /* LUT Enable: disabled */
	//		 | 0 << CCL_OUTEN_bp; /* Output Enable: disabled */

	CCL.CTRLA = 1 << CCL_ENABLE_bp      /* Enable: enabled */
     2cc:	81 e4       	ldi	r24, 0x41	; 65
     2ce:	80 83       	st	Z, r24
	            | 1 << CCL_RUNSTDBY_bp; /* Run in Standby: enabled */

	return 0;
}
     2d0:	80 e0       	ldi	r24, 0x00	; 0
     2d2:	08 95       	ret

000002d4 <CLKCTRL_init>:
 *       on calling convention. The memory model is not visible to the
 *       preprocessor, so it must be defined in the Assembler preprocessor directives.
 */
static inline void ccp_write_io(void *addr, uint8_t value)
{
	protected_write_io(addr, CCP_IOREG_gc, value);
     2d4:	47 e0       	ldi	r20, 0x07	; 7
     2d6:	68 ed       	ldi	r22, 0xD8	; 216
     2d8:	8c e7       	ldi	r24, 0x7C	; 124
     2da:	90 e0       	ldi	r25, 0x00	; 0
     2dc:	0e 94 47 02 	call	0x48e	; 0x48e <protected_write_io>
     2e0:	41 e0       	ldi	r20, 0x01	; 1
     2e2:	68 ed       	ldi	r22, 0xD8	; 216
     2e4:	81 e6       	ldi	r24, 0x61	; 97
     2e6:	90 e0       	ldi	r25, 0x00	; 0
     2e8:	0e 94 47 02 	call	0x48e	; 0x48e <protected_write_io>
	//		 | 0 << CLKCTRL_CLKOUT_bp /* System clock out: disabled */);

	// ccp_write_io((void*)&(CLKCTRL.MCLKLOCK),0 << CLKCTRL_LOCKEN_bp /* lock enable: disabled */);

	return 0;
}
     2ec:	80 e0       	ldi	r24, 0x00	; 0
     2ee:	08 95       	ret

000002f0 <CPUINT_init>:

	// CPUINT.LVL0PRI = 0x0 << CPUINT_LVL0PRI_gp; /* Interrupt Level Priority: 0x0 */

	// CPUINT.LVL1VEC = 0x0 << CPUINT_LVL1VEC_gp; /* Interrupt Vector with High Priority: 0x0 */

	ENABLE_INTERRUPTS();
     2f0:	78 94       	sei

	return 0;
}
     2f2:	80 e0       	ldi	r24, 0x00	; 0
     2f4:	08 95       	ret

000002f6 <DAC_0_init>:
int8_t DAC_0_init()
{

	// DAC0.DATA = 0x0; /* DATA Register: 0x0 */

	DAC0.CTRLA = 1 << DAC_ENABLE_bp      /* DAC Enable: enabled */
     2f6:	81 e4       	ldi	r24, 0x41	; 65
     2f8:	80 93 a0 06 	sts	0x06A0, r24	; 0x8006a0 <__TEXT_REGION_LENGTH__+0x7006a0>
	             | 1 << DAC_OUTEN_bp     /* Output Buffer Enable: enabled */
	             | 0 << DAC_RUNSTDBY_bp; /* Run in Standby Mode: disabled */

	return 0;
}
     2fc:	80 e0       	ldi	r24, 0x00	; 0
     2fe:	08 95       	ret

00000300 <DAC_0_uninit>:
int8_t DAC_0_uninit()
{

	// DAC0.DATA = 0x0; /* DATA Register: 0x0 */

	DAC0.CTRLA = 1 << DAC_ENABLE_bp      /* DAC Enable: enabled */
     300:	81 e0       	ldi	r24, 0x01	; 1
     302:	80 93 a0 06 	sts	0x06A0, r24	; 0x8006a0 <__TEXT_REGION_LENGTH__+0x7006a0>
	| 0 << DAC_OUTEN_bp     /* Output Buffer Enable: disabled */
	| 0 << DAC_RUNSTDBY_bp; /* Run in Standby Mode: disabled */

	return 0;
}
     306:	80 e0       	ldi	r24, 0x00	; 0
     308:	08 95       	ret

0000030a <DAC_0_enable>:
 *
 * \return Nothing
 */
void DAC_0_enable()
{
	DAC0.CTRLA |= DAC_ENABLE_bm;
     30a:	e0 ea       	ldi	r30, 0xA0	; 160
     30c:	f6 e0       	ldi	r31, 0x06	; 6
     30e:	80 81       	ld	r24, Z
     310:	81 60       	ori	r24, 0x01	; 1
     312:	80 83       	st	Z, r24
     314:	08 95       	ret

00000316 <DAC_0_disable>:
 *
 * \return Nothing
 */
void DAC_0_disable()
{
	DAC0.CTRLA &= ~DAC_ENABLE_bm;
     316:	e0 ea       	ldi	r30, 0xA0	; 160
     318:	f6 e0       	ldi	r31, 0x06	; 6
     31a:	80 81       	ld	r24, Z
     31c:	8e 7f       	andi	r24, 0xFE	; 254
     31e:	80 83       	st	Z, r24
     320:	08 95       	ret

00000322 <DAC_0_set_output>:
 *
 * \return Nothing
 */
void DAC_0_set_output(dac_resolution_t value)
{
	DAC0.DATA = value;
     322:	80 93 a1 06 	sts	0x06A1, r24	; 0x8006a1 <__TEXT_REGION_LENGTH__+0x7006a1>
     326:	08 95       	ret

00000328 <mcu_init>:
#ifdef __cplusplus
extern "C" {
#endif

void mcu_init(void)
{
     328:	e0 e1       	ldi	r30, 0x10	; 16
     32a:	f4 e0       	ldi	r31, 0x04	; 4
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     32c:	80 81       	ld	r24, Z
     32e:	88 60       	ori	r24, 0x08	; 8
     330:	81 93       	st	Z+, r24
	 * disables all peripherals to save power. Driver shall enable
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
     332:	e8 31       	cpi	r30, 0x18	; 24
     334:	84 e0       	ldi	r24, 0x04	; 4
     336:	f8 07       	cpc	r31, r24
     338:	c9 f7       	brne	.-14     	; 0x32c <mcu_init+0x4>
     33a:	e0 e3       	ldi	r30, 0x30	; 48
     33c:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     33e:	80 81       	ld	r24, Z
     340:	88 60       	ori	r24, 0x08	; 8
     342:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     344:	e8 33       	cpi	r30, 0x38	; 56
     346:	84 e0       	ldi	r24, 0x04	; 4
     348:	f8 07       	cpc	r31, r24
     34a:	c9 f7       	brne	.-14     	; 0x33e <mcu_init+0x16>
     34c:	e0 e5       	ldi	r30, 0x50	; 80
     34e:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     350:	80 81       	ld	r24, Z
     352:	88 60       	ori	r24, 0x08	; 8
     354:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     356:	e8 35       	cpi	r30, 0x58	; 88
     358:	84 e0       	ldi	r24, 0x04	; 4
     35a:	f8 07       	cpc	r31, r24
     35c:	c9 f7       	brne	.-14     	; 0x350 <mcu_init+0x28>
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}
}
     35e:	08 95       	ret

00000360 <ADC_0_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     360:	e5 e1       	ldi	r30, 0x15	; 21
     362:	f4 e0       	ldi	r31, 0x04	; 4
     364:	80 81       	ld	r24, Z
     366:	88 7f       	andi	r24, 0xF8	; 248
     368:	84 60       	ori	r24, 0x04	; 4
     36a:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     36c:	80 81       	ld	r24, Z
     36e:	87 7f       	andi	r24, 0xF7	; 247
     370:	80 83       	st	Z, r24
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     372:	e7 e1       	ldi	r30, 0x17	; 23
     374:	f4 e0       	ldi	r31, 0x04	; 4
     376:	80 81       	ld	r24, Z
     378:	88 7f       	andi	r24, 0xF8	; 248
     37a:	84 60       	ori	r24, 0x04	; 4
     37c:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     37e:	80 81       	ld	r24, Z
     380:	87 7f       	andi	r24, 0xF7	; 247
     382:	80 83       	st	Z, r24
 */
static inline void PORTC_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     384:	e0 e5       	ldi	r30, 0x50	; 80
     386:	f4 e0       	ldi	r31, 0x04	; 4
     388:	80 81       	ld	r24, Z
     38a:	88 7f       	andi	r24, 0xF8	; 248
     38c:	84 60       	ori	r24, 0x04	; 4
     38e:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     390:	80 81       	ld	r24, Z
     392:	87 7f       	andi	r24, 0xF7	; 247
     394:	80 83       	st	Z, r24
 */
static inline void PORTC_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     396:	e1 e5       	ldi	r30, 0x51	; 81
     398:	f4 e0       	ldi	r31, 0x04	; 4
     39a:	80 81       	ld	r24, Z
     39c:	88 7f       	andi	r24, 0xF8	; 248
     39e:	84 60       	ori	r24, 0x04	; 4
     3a0:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     3a2:	80 81       	ld	r24, Z
     3a4:	87 7f       	andi	r24, 0xF7	; 247
     3a6:	80 83       	st	Z, r24
 */
static inline void PORTC_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     3a8:	e3 e5       	ldi	r30, 0x53	; 83
     3aa:	f4 e0       	ldi	r31, 0x04	; 4
     3ac:	80 81       	ld	r24, Z
     3ae:	88 7f       	andi	r24, 0xF8	; 248
     3b0:	84 60       	ori	r24, 0x04	; 4
     3b2:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     3b4:	80 81       	ld	r24, Z
     3b6:	87 7f       	andi	r24, 0xF7	; 247
     3b8:	80 83       	st	Z, r24
	// Disable digital input buffer
	DEN4_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	DEN4_PIN_set_pull_mode(PORT_PULL_OFF);

	ADC_0_init();
     3ba:	0e 94 39 01 	call	0x272	; 0x272 <ADC_0_init>
     3be:	08 95       	ret

000003c0 <USART_0_initialization>:
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     3c0:	23 98       	cbi	0x04, 3	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     3c2:	e3 e3       	ldi	r30, 0x33	; 51
     3c4:	f4 e0       	ldi	r31, 0x04	; 4
     3c6:	80 81       	ld	r24, Z
     3c8:	87 7f       	andi	r24, 0xF7	; 247
     3ca:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     3cc:	22 9a       	sbi	0x04, 2	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     3ce:	2a 98       	cbi	0x05, 2	; 5
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	USART_0_init();
     3d0:	0e 94 81 02 	call	0x502	; 0x502 <USART_0_init>
     3d4:	08 95       	ret

000003d6 <TIMER_0_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     3d6:	25 9a       	sbi	0x04, 5	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     3d8:	2d 98       	cbi	0x05, 5	; 5
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLC |= PORTMUX_TCA02_bm;
     3da:	e0 e0       	ldi	r30, 0x00	; 0
     3dc:	f2 e0       	ldi	r31, 0x02	; 2
     3de:	82 81       	ldd	r24, Z+2	; 0x02
     3e0:	84 60       	ori	r24, 0x04	; 4
     3e2:	82 83       	std	Z+2, r24	; 0x02

	TIMER_0_init();
     3e4:	0e 94 71 02 	call	0x4e2	; 0x4e2 <TIMER_0_init>
     3e8:	08 95       	ret

000003ea <DIGITAL_GLUE_LOGIC_0_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     3ea:	24 9a       	sbi	0x04, 4	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     3ec:	2c 98       	cbi	0x05, 4	; 5
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLA |= PORTMUX_LUT0_bm;
     3ee:	e0 e0       	ldi	r30, 0x00	; 0
     3f0:	f2 e0       	ldi	r31, 0x02	; 2
     3f2:	80 81       	ld	r24, Z
     3f4:	80 61       	ori	r24, 0x10	; 16
     3f6:	80 83       	st	Z, r24

	DIGITAL_GLUE_LOGIC_0_init();
     3f8:	0e 94 59 01 	call	0x2b2	; 0x2b2 <DIGITAL_GLUE_LOGIC_0_init>
     3fc:	08 95       	ret

000003fe <SPI_0_initialization>:
 */
static inline void PORTA_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
     3fe:	02 98       	cbi	0x00, 2	; 0
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     400:	e2 e1       	ldi	r30, 0x12	; 18
     402:	f4 e0       	ldi	r31, 0x04	; 4
     404:	80 81       	ld	r24, Z
     406:	87 7f       	andi	r24, 0xF7	; 247
     408:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     40a:	01 9a       	sbi	0x00, 1	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     40c:	09 98       	cbi	0x01, 1	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     40e:	03 9a       	sbi	0x00, 3	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     410:	0b 98       	cbi	0x01, 3	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     412:	04 9a       	sbi	0x00, 4	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     414:	0c 98       	cbi	0x01, 4	; 1
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	SPI_0_init();
     416:	0e 94 69 02 	call	0x4d2	; 0x4d2 <SPI_0_init>
     41a:	08 95       	ret

0000041c <DAC_0_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     41c:	e6 e1       	ldi	r30, 0x16	; 22
     41e:	f4 e0       	ldi	r31, 0x04	; 4
     420:	80 81       	ld	r24, Z
     422:	88 7f       	andi	r24, 0xF8	; 248
     424:	84 60       	ori	r24, 0x04	; 4
     426:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     428:	80 81       	ld	r24, Z
     42a:	87 7f       	andi	r24, 0xF7	; 247
     42c:	80 83       	st	Z, r24
	// Disable digital input buffer
	AXON_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	AXON_PIN_set_pull_mode(PORT_PULL_OFF);

	DAC_0_init();
     42e:	0e 94 7b 01 	call	0x2f6	; 0x2f6 <DAC_0_init>
     432:	08 95       	ret

00000434 <system_init>:
/**
 * \brief System initialization
 */
void system_init()
{
	mcu_init();
     434:	0e 94 94 01 	call	0x328	; 0x328 <mcu_init>
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     438:	26 98       	cbi	0x04, 6	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     43a:	e6 e3       	ldi	r30, 0x36	; 54
     43c:	f4 e0       	ldi	r31, 0x04	; 4
     43e:	80 81       	ld	r24, Z
     440:	87 7f       	andi	r24, 0xF7	; 247
     442:	80 83       	st	Z, r24
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     444:	27 98       	cbi	0x04, 7	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     446:	e7 e3       	ldi	r30, 0x37	; 55
     448:	f4 e0       	ldi	r31, 0x04	; 4
     44a:	80 81       	ld	r24, Z
     44c:	87 7f       	andi	r24, 0xF7	; 247
     44e:	80 83       	st	Z, r24
 */
static inline void PORTC_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
     450:	42 98       	cbi	0x08, 2	; 8
static inline void PORTC_set_pin_pull_mode(const uint8_t pin, const enum port_pull_mode pull_mode)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
     452:	e2 e5       	ldi	r30, 0x52	; 82
     454:	f4 e0       	ldi	r31, 0x04	; 4
     456:	80 81       	ld	r24, Z
     458:	88 60       	ori	r24, 0x08	; 8
     45a:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTC.DIR |= (1 << pin);
     45c:	45 9a       	sbi	0x08, 5	; 8
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     45e:	4d 9a       	sbi	0x09, 5	; 9
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    true);

	CLKCTRL_init();
     460:	0e 94 6a 01 	call	0x2d4	; 0x2d4 <CLKCTRL_init>

	RTC_0_init();
     464:	0e 94 4b 02 	call	0x496	; 0x496 <RTC_0_init>

	ADC_0_initialization();
     468:	0e 94 b0 01 	call	0x360	; 0x360 <ADC_0_initialization>

	USART_0_initialization();
     46c:	0e 94 e0 01 	call	0x3c0	; 0x3c0 <USART_0_initialization>

	TIMER_0_initialization();
     470:	0e 94 eb 01 	call	0x3d6	; 0x3d6 <TIMER_0_initialization>

	DIGITAL_GLUE_LOGIC_0_initialization();
     474:	0e 94 f5 01 	call	0x3ea	; 0x3ea <DIGITAL_GLUE_LOGIC_0_initialization>

	SPI_0_initialization();
     478:	0e 94 ff 01 	call	0x3fe	; 0x3fe <SPI_0_initialization>

	DAC_0_initialization();
     47c:	0e 94 0e 02 	call	0x41c	; 0x41c <DAC_0_initialization>

	CPUINT_init();
     480:	0e 94 78 01 	call	0x2f0	; 0x2f0 <CPUINT_init>

	SLPCTRL_init();
     484:	0e 94 67 02 	call	0x4ce	; 0x4ce <SLPCTRL_init>

	BOD_init();
     488:	0e 94 57 01 	call	0x2ae	; 0x2ae <BOD_init>
     48c:	08 95       	ret

0000048e <protected_write_io>:
#if defined(__GNUC__)
  
#ifdef RAMPZ
	out     _SFR_IO_ADDR(RAMPZ), r1         // Clear bits 23:16 of Z
#endif
	movw    r30, r24                // Load addr into Z
     48e:	fc 01       	movw	r30, r24
	out     CCP, r22                // Start CCP handshake
     490:	64 bf       	out	0x34, r22	; 52
	st      Z, r20                  // Write value to I/O register
     492:	40 83       	st	Z, r20
	ret                             // Return to caller
     494:	08 95       	ret

00000496 <RTC_0_init>:
 * \return Initialization status.
 */
int8_t RTC_0_init()
{

	while (RTC.STATUS > 0) { /* Wait for all register to be synchronized */
     496:	e0 e4       	ldi	r30, 0x40	; 64
     498:	f1 e0       	ldi	r31, 0x01	; 1
     49a:	81 81       	ldd	r24, Z+1	; 0x01
     49c:	81 11       	cpse	r24, r1
     49e:	fd cf       	rjmp	.-6      	; 0x49a <RTC_0_init+0x4>
	}

	// RTC.CMP = 0x0; /* Compare: 0x0 */

	RTC.CNT = 0x20; /* Counter: 0x20 */
     4a0:	e0 e4       	ldi	r30, 0x40	; 64
     4a2:	f1 e0       	ldi	r31, 0x01	; 1
     4a4:	80 e2       	ldi	r24, 0x20	; 32
     4a6:	90 e0       	ldi	r25, 0x00	; 0
     4a8:	80 87       	std	Z+8, r24	; 0x08
     4aa:	91 87       	std	Z+9, r25	; 0x09

	RTC.CTRLA = RTC_PRESCALER_DIV1_gc   /* 1 */
     4ac:	81 e8       	ldi	r24, 0x81	; 129
     4ae:	80 83       	st	Z, r24
	            | 1 << RTC_RTCEN_bp     /* Enable: enabled */
	            | 1 << RTC_RUNSTDBY_bp; /* Run In Standby: enabled */

	RTC.PER = 0x20 / TIMESCALE; /* Period: 0x20 */
     4b0:	80 e8       	ldi	r24, 0x80	; 128
     4b2:	92 e0       	ldi	r25, 0x02	; 2
     4b4:	82 87       	std	Z+10, r24	; 0x0a
     4b6:	93 87       	std	Z+11, r25	; 0x0b

	// RTC.CLKSEL = RTC_CLKSEL_INT32K_gc; /* 32KHz Internal Ultra Low Power Oscillator (OSCULP32K) */

	RTC.DBGCTRL = 1 << RTC_DBGRUN_bp; /* Run in debug: enabled */
     4b8:	81 e0       	ldi	r24, 0x01	; 1
     4ba:	85 83       	std	Z+5, r24	; 0x05

	RTC.INTCTRL = 0 << RTC_CMP_bp    /* Compare Match Interrupt enable: disabled */
     4bc:	82 83       	std	Z+2, r24	; 0x02
	              | 1 << RTC_OVF_bp; /* Overflow Interrupt enable: enabled */

	while (RTC.PITSTATUS > 0) { /* Wait for all register to be synchronized */
     4be:	81 89       	ldd	r24, Z+17	; 0x11
     4c0:	81 11       	cpse	r24, r1
     4c2:	fd cf       	rjmp	.-6      	; 0x4be <RTC_0_init+0x28>
	}

	RTC.PITCTRLA = RTC_PERIOD_OFF_gc    /* Off */
     4c4:	81 e0       	ldi	r24, 0x01	; 1
     4c6:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <__TEXT_REGION_LENGTH__+0x700150>
	// RTC.PITDBGCTRL = 0 << RTC_DBGRUN_bp; /* Run in debug: disabled */

	// RTC.PITINTCTRL = 0 << RTC_PI_bp; /* Periodic Interrupt: disabled */

	return 0;
}
     4ca:	80 e0       	ldi	r24, 0x00	; 0
     4cc:	08 95       	ret

000004ce <SLPCTRL_init>:

	// SLPCTRL.CTRLA = 0 << SLPCTRL_SEN_bp /* Sleep enable: disabled */
	//		 | SLPCTRL_SMODE_IDLE_gc; /* Idle mode */

	return 0;
}
     4ce:	80 e0       	ldi	r24, 0x00	; 0
     4d0:	08 95       	ret

000004d2 <SPI_0_init>:
 * \return Initialization status
 */
int8_t SPI_0_init()
{

	SPI0.CTRLA = 0 << SPI_CLK2X_bp     /* Enable Double Speed: disabled */
     4d2:	e0 e2       	ldi	r30, 0x20	; 32
     4d4:	f8 e0       	ldi	r31, 0x08	; 8
     4d6:	83 e2       	ldi	r24, 0x23	; 35
     4d8:	80 83       	st	Z, r24
	             | 0 << SPI_DORD_bp    /* Data Order Setting: disabled */
	             | 1 << SPI_ENABLE_bp  /* Enable Module: enabled */
	             | 1 << SPI_MASTER_bp  /* SPI module in master mode */
	             | SPI_PRESC_DIV16_gc; /* System Clock / 16 */

	SPI0.CTRLB = 0 << SPI_BUFEN_bp   /* Buffer Mode Enable: disabled */
     4da:	84 e0       	ldi	r24, 0x04	; 4
     4dc:	81 83       	std	Z+1, r24	; 0x01
	//		 | 0 << SPI_RXCIE_bp /* Receive Complete Interrupt Enable: disabled */
	//		 | 0 << SPI_SSIE_bp /* Slave Select Trigger Interrupt Enable: disabled */
	//		 | 0 << SPI_TXCIE_bp; /* Transfer Complete Interrupt Enable: disabled */

	return 0;
}
     4de:	80 e0       	ldi	r24, 0x00	; 0
     4e0:	08 95       	ret

000004e2 <TIMER_0_init>:

	// TCA0.SINGLE.CMP0 = 0x0; /* Compare Register 0: 0x0 */

	// TCA0.SINGLE.CMP1 = 0x0; /* Compare Register 1: 0x0 */

	TCA0.SINGLE.CMP2 = 0x4; /* Compare Register 2: 0x4 */
     4e2:	e0 e0       	ldi	r30, 0x00	; 0
     4e4:	fa e0       	ldi	r31, 0x0A	; 10
     4e6:	84 e0       	ldi	r24, 0x04	; 4
     4e8:	90 e0       	ldi	r25, 0x00	; 0
     4ea:	84 a7       	std	Z+44, r24	; 0x2c
     4ec:	95 a7       	std	Z+45, r25	; 0x2d

	// TCA0.SINGLE.CNT = 0x0; /* Count: 0x0 */

	TCA0.SINGLE.CTRLB = 0 << TCA_SINGLE_ALUPD_bp            /* Auto Lock Update: disabled */
     4ee:	83 e4       	ldi	r24, 0x43	; 67
     4f0:	81 83       	std	Z+1, r24	; 0x01
	                    | 0 << TCA_SINGLE_CMP0EN_bp         /* Compare 0 Enable: disabled */
	                    | 0 << TCA_SINGLE_CMP1EN_bp         /* Compare 1 Enable: disabled */
	                    | 1 << TCA_SINGLE_CMP2EN_bp         /* Compare 2 Enable: enabled */
	                    | TCA_SINGLE_WGMODE_SINGLESLOPE_gc; /*  */

	TCA0.SINGLE.CTRLC = 0 << TCA_SINGLE_CMP0OV_bp    /* Compare 0 Waveform Output Value: disabled */
     4f2:	84 e0       	ldi	r24, 0x04	; 4
     4f4:	82 83       	std	Z+2, r24	; 0x02
	// TCA0.SINGLE.INTCTRL = 0 << TCA_SINGLE_CMP0_bp /* Compare 0 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP1_bp /* Compare 1 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP2_bp /* Compare 2 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_OVF_bp; /* Overflow Interrupt: disabled */

	TCA0.SINGLE.PER = 0x7; /* Period: 0x7 */
     4f6:	87 e0       	ldi	r24, 0x07	; 7
     4f8:	90 e0       	ldi	r25, 0x00	; 0
     4fa:	86 a3       	std	Z+38, r24	; 0x26
     4fc:	97 a3       	std	Z+39, r25	; 0x27

	// TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV1_gc /* System Clock */
	//		 | 0 << TCA_SINGLE_ENABLE_bp; /* Module Enable: disabled */

	return 0;
}
     4fe:	80 e0       	ldi	r24, 0x00	; 0
     500:	08 95       	ret

00000502 <USART_0_init>:
uint8_t USART_0_read()
{
	while (!(USART0.STATUS & USART_RXCIF_bm))
		;
	return USART0.RXDATAL;
}
     502:	e0 e0       	ldi	r30, 0x00	; 0
     504:	f8 e0       	ldi	r31, 0x08	; 8
     506:	8b e5       	ldi	r24, 0x5B	; 91
     508:	91 e0       	ldi	r25, 0x01	; 1
     50a:	80 87       	std	Z+8, r24	; 0x08
     50c:	91 87       	std	Z+9, r25	; 0x09
     50e:	80 ec       	ldi	r24, 0xC0	; 192
     510:	86 83       	std	Z+6, r24	; 0x06
     512:	80 e0       	ldi	r24, 0x00	; 0
     514:	98 e3       	ldi	r25, 0x38	; 56
     516:	80 93 68 38 	sts	0x3868, r24	; 0x803868 <__iob+0x2>
     51a:	90 93 69 38 	sts	0x3869, r25	; 0x803869 <__iob+0x3>
     51e:	80 e0       	ldi	r24, 0x00	; 0
     520:	08 95       	ret

00000522 <USART_0_write>:
 *
 * \return Nothing
 */
void USART_0_write(const uint8_t data)
{
	while (!(USART0.STATUS & USART_DREIF_bm))
     522:	e0 e0       	ldi	r30, 0x00	; 0
     524:	f8 e0       	ldi	r31, 0x08	; 8
     526:	94 81       	ldd	r25, Z+4	; 0x04
     528:	95 ff       	sbrs	r25, 5
     52a:	fd cf       	rjmp	.-6      	; 0x526 <USART_0_write+0x4>
		;
	USART0.TXDATAL = data;
     52c:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <__TEXT_REGION_LENGTH__+0x700802>
     530:	08 95       	ret

00000532 <USART_0_printCHAR>:

#if defined(__GNUC__)

int USART_0_printCHAR(char character, FILE *stream)
{
	USART_0_write(character);
     532:	0e 94 91 02 	call	0x522	; 0x522 <USART_0_write>
	return 0;
}
     536:	80 e0       	ldi	r24, 0x00	; 0
     538:	90 e0       	ldi	r25, 0x00	; 0
     53a:	08 95       	ret

0000053c <tinyAxon_add_pulse>:
{
	// We want to check each slot in the pulse_queue, and
	// if we find an empty slot (0), we add a pulse.
	for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
	{
		if(pulse_queue[i] == 0){
     53c:	20 91 17 38 	lds	r18, 0x3817	; 0x803817 <pulse_queue>
     540:	30 91 18 38 	lds	r19, 0x3818	; 0x803818 <pulse_queue+0x1>
     544:	23 2b       	or	r18, r19
     546:	51 f0       	breq	.+20     	; 0x55c <tinyAxon_add_pulse+0x20>
     548:	e9 e1       	ldi	r30, 0x19	; 25
     54a:	f8 e3       	ldi	r31, 0x38	; 56
     54c:	21 e0       	ldi	r18, 0x01	; 1
     54e:	30 e0       	ldi	r19, 0x00	; 0
     550:	b9 01       	movw	r22, r18
     552:	41 91       	ld	r20, Z+
     554:	51 91       	ld	r21, Z+
     556:	45 2b       	or	r20, r21
     558:	81 f4       	brne	.+32     	; 0x57a <tinyAxon_add_pulse+0x3e>
     55a:	02 c0       	rjmp	.+4      	; 0x560 <tinyAxon_add_pulse+0x24>
     55c:	60 e0       	ldi	r22, 0x00	; 0
     55e:	70 e0       	ldi	r23, 0x00	; 0
			pulse_queue[i] = new_pulse;
     560:	66 0f       	add	r22, r22
     562:	77 1f       	adc	r23, r23
     564:	fb 01       	movw	r30, r22
     566:	e9 5e       	subi	r30, 0xE9	; 233
     568:	f7 4c       	sbci	r31, 0xC7	; 199
     56a:	80 83       	st	Z, r24
     56c:	91 83       	std	Z+1, r25	; 0x01
			pulses_in_queue++;
     56e:	80 91 2b 38 	lds	r24, 0x382B	; 0x80382b <pulses_in_queue>
     572:	8f 5f       	subi	r24, 0xFF	; 255
     574:	80 93 2b 38 	sts	0x382B, r24	; 0x80382b <pulses_in_queue>
			// We return so we only ever add one
			break;
     578:	08 95       	ret
     57a:	2f 5f       	subi	r18, 0xFF	; 255
     57c:	3f 4f       	sbci	r19, 0xFF	; 255
*/
static void tinyAxon_add_pulse(uint16_t new_pulse)
{
	// We want to check each slot in the pulse_queue, and
	// if we find an empty slot (0), we add a pulse.
	for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
     57e:	2a 30       	cpi	r18, 0x0A	; 10
     580:	31 05       	cpc	r19, r1
     582:	31 f7       	brne	.-52     	; 0x550 <tinyAxon_add_pulse+0x14>
     584:	08 95       	ret

00000586 <find_newest_pulse>:
uint8_t find_newest_pulse() {
	uint16_t max;
	uint8_t current_index = 0;
	uint8_t return_index = 0;
	
	max = pulse_queue[current_index];
     586:	40 91 17 38 	lds	r20, 0x3817	; 0x803817 <pulse_queue>
     58a:	50 91 18 38 	lds	r21, 0x3818	; 0x803818 <pulse_queue+0x1>
     58e:	e9 e1       	ldi	r30, 0x19	; 25
     590:	f8 e3       	ldi	r31, 0x38	; 56
	
// This function will be used with pulse_queue to find the newest pulse
uint8_t find_newest_pulse() {
	uint16_t max;
	uint8_t current_index = 0;
	uint8_t return_index = 0;
     592:	80 e0       	ldi	r24, 0x00	; 0
	
	max = pulse_queue[current_index];
	
	for (current_index = 1; current_index < MAX_NUMBER_OF_PULSES; current_index++) {
     594:	91 e0       	ldi	r25, 0x01	; 1
		if (pulse_queue[current_index] > max) {
     596:	21 91       	ld	r18, Z+
     598:	31 91       	ld	r19, Z+
     59a:	42 17       	cp	r20, r18
     59c:	53 07       	cpc	r21, r19
     59e:	10 f4       	brcc	.+4      	; 0x5a4 <find_newest_pulse+0x1e>
     5a0:	89 2f       	mov	r24, r25
			return_index = current_index;
			max = pulse_queue[current_index];
     5a2:	a9 01       	movw	r20, r18
	uint8_t current_index = 0;
	uint8_t return_index = 0;
	
	max = pulse_queue[current_index];
	
	for (current_index = 1; current_index < MAX_NUMBER_OF_PULSES; current_index++) {
     5a4:	9f 5f       	subi	r25, 0xFF	; 255
     5a6:	9a 30       	cpi	r25, 0x0A	; 10
     5a8:	b1 f7       	brne	.-20     	; 0x596 <find_newest_pulse+0x10>
			return_index = current_index;
			max = pulse_queue[current_index];
		}
	}
	return return_index;
}
     5aa:	08 95       	ret

000005ac <tinyAxon_stop_sending_pulse>:
	tinyLED_set_color_mode(OUT_LED, WHITE, FLASH_ONCE);
}

void tinyAxon_stop_sending_pulse()
{
	DAC_0_set_output(NO_SIGNAL_OUTPUT);
     5ac:	80 e0       	ldi	r24, 0x00	; 0
     5ae:	90 e0       	ldi	r25, 0x00	; 0
     5b0:	0e 94 91 01 	call	0x322	; 0x322 <DAC_0_set_output>
	axonOutputValue=NO_SIGNAL_OUTPUT;
     5b4:	10 92 16 38 	sts	0x3816, r1	; 0x803816 <__data_end>
     5b8:	08 95       	ret

000005ba <tinyAxon_remove_pulse>:

/*
If the potential is very low, we want to try to remove a pulse.
*/
bool tinyAxon_remove_pulse(void)
{
     5ba:	cf 93       	push	r28
	// We want to return a bool indicating whether or not a pulse actually was removed.
	if(pulses_in_queue == 0){
     5bc:	c0 91 2b 38 	lds	r28, 0x382B	; 0x80382b <pulses_in_queue>
     5c0:	cc 23       	and	r28, r28
     5c2:	c9 f0       	breq	.+50     	; 0x5f6 <tinyAxon_remove_pulse+0x3c>
		//There was no pulse to remove.
		return false;
	}
	else{
		// If we are to remove a pulse, we want to remove the one that will fire last.
		uint8_t pulse_index = find_newest_pulse();
     5c4:	0e 94 c3 02 	call	0x586	; 0x586 <find_newest_pulse>
		uint16_t newest_pulse = pulse_queue[pulse_index];
     5c8:	90 e0       	ldi	r25, 0x00	; 0
     5ca:	fc 01       	movw	r30, r24
     5cc:	ee 0f       	add	r30, r30
     5ce:	ff 1f       	adc	r31, r31
     5d0:	e9 5e       	subi	r30, 0xE9	; 233
     5d2:	f7 4c       	sbci	r31, 0xC7	; 199
	
		// Now we want to check if the pulse is too far away to be affected by the low potential, or close enough that we decide to remove it.
		// (When we say that the pulse is too far away, it refers to the biological process of how the potential spreads from Dendrites to axon).
		if(newest_pulse > PULSE_NO_RETURN_TIME){
     5d4:	20 81       	ld	r18, Z
     5d6:	31 81       	ldd	r19, Z+1	; 0x01
     5d8:	2d 33       	cpi	r18, 0x3D	; 61
     5da:	31 05       	cpc	r19, r1
     5dc:	70 f0       	brcs	.+28     	; 0x5fa <tinyAxon_remove_pulse+0x40>
			// We decided to remove the pulse
			pulse_queue[pulse_index] = 0;
     5de:	88 0f       	add	r24, r24
     5e0:	99 1f       	adc	r25, r25
     5e2:	fc 01       	movw	r30, r24
     5e4:	e9 5e       	subi	r30, 0xE9	; 233
     5e6:	f7 4c       	sbci	r31, 0xC7	; 199
     5e8:	10 82       	st	Z, r1
     5ea:	11 82       	std	Z+1, r1	; 0x01
			pulses_in_queue--;
     5ec:	c1 50       	subi	r28, 0x01	; 1
     5ee:	c0 93 2b 38 	sts	0x382B, r28	; 0x80382b <pulses_in_queue>
			return true;
     5f2:	81 e0       	ldi	r24, 0x01	; 1
     5f4:	03 c0       	rjmp	.+6      	; 0x5fc <tinyAxon_remove_pulse+0x42>
bool tinyAxon_remove_pulse(void)
{
	// We want to return a bool indicating whether or not a pulse actually was removed.
	if(pulses_in_queue == 0){
		//There was no pulse to remove.
		return false;
     5f6:	80 e0       	ldi	r24, 0x00	; 0
     5f8:	01 c0       	rjmp	.+2      	; 0x5fc <tinyAxon_remove_pulse+0x42>
			pulses_in_queue--;
			return true;
		}
		// Here we have found that there is a pulse queued, but it is old enough to let pass anyway, so now we need to put it back into the queue.
		else{
			return false;
     5fa:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     5fc:	cf 91       	pop	r28
     5fe:	08 95       	ret

00000600 <tinyAxon_update_potential>:
/*
Decides whether or not the axon should fire
If the axon does fire, the potential is reduced
*/
double tinyAxon_update_potential(double potential)
{	
     600:	cf 92       	push	r12
     602:	df 92       	push	r13
     604:	ef 92       	push	r14
     606:	ff 92       	push	r15
     608:	6b 01       	movw	r12, r22
     60a:	7c 01       	movw	r14, r24
	//While the neuron has enough potential to fire, we want to fire more
	while (potential >= THRESHOLD_POTENTIAL)
     60c:	20 e0       	ldi	r18, 0x00	; 0
     60e:	30 e0       	ldi	r19, 0x00	; 0
     610:	48 ec       	ldi	r20, 0xC8	; 200
     612:	51 e4       	ldi	r21, 0x41	; 65
     614:	0e 94 38 0b 	call	0x1670	; 0x1670 <__gesf2>
     618:	88 23       	and	r24, r24
     61a:	bc f1       	brlt	.+110    	; 0x68a <tinyAxon_update_potential+0x8a>
	{
		// We have to check if there are already queued pulses, so that the frequency never exceeds FIRE_DELAY
		if(pulses_in_queue>0){
     61c:	80 91 2b 38 	lds	r24, 0x382B	; 0x80382b <pulses_in_queue>
     620:	88 23       	and	r24, r24
     622:	b1 f0       	breq	.+44     	; 0x650 <tinyAxon_update_potential+0x50>
			uint16_t newest_pulse = pulse_queue[find_newest_pulse()];
     624:	0e 94 c3 02 	call	0x586	; 0x586 <find_newest_pulse>
     628:	e8 2f       	mov	r30, r24
     62a:	f0 e0       	ldi	r31, 0x00	; 0
     62c:	ee 0f       	add	r30, r30
     62e:	ff 1f       	adc	r31, r31
     630:	e9 5e       	subi	r30, 0xE9	; 233
     632:	f7 4c       	sbci	r31, 0xC7	; 199
			
			// There is at least one pulse in the queue, and it is so close, that we need to offset the new pulse, so that we keep at least
			// one FIRE_DELAY between each pulse
			if(newest_pulse + FIRE_DELAY > TRAVLE_DELAY){
     634:	80 81       	ld	r24, Z
     636:	91 81       	ldd	r25, Z+1	; 0x01
     638:	0a 96       	adiw	r24, 0x0a	; 10
     63a:	85 36       	cpi	r24, 0x65	; 101
     63c:	91 05       	cpc	r25, r1
     63e:	18 f0       	brcs	.+6      	; 0x646 <tinyAxon_update_potential+0x46>
				tinyAxon_add_pulse(newest_pulse + FIRE_DELAY);
     640:	0e 94 9e 02 	call	0x53c	; 0x53c <tinyAxon_add_pulse>
     644:	09 c0       	rjmp	.+18     	; 0x658 <tinyAxon_update_potential+0x58>
			}
			// There is at least one pulse in the queue, but it's far enough away to ignore
			else{
				tinyAxon_add_pulse(TRAVLE_DELAY);
     646:	84 e6       	ldi	r24, 0x64	; 100
     648:	90 e0       	ldi	r25, 0x00	; 0
     64a:	0e 94 9e 02 	call	0x53c	; 0x53c <tinyAxon_add_pulse>
     64e:	04 c0       	rjmp	.+8      	; 0x658 <tinyAxon_update_potential+0x58>
			}
		}
		// There are no pulses in the queue, so we add a pulse as normal
		else{
			tinyAxon_add_pulse(TRAVLE_DELAY);		
     650:	84 e6       	ldi	r24, 0x64	; 100
     652:	90 e0       	ldi	r25, 0x00	; 0
     654:	0e 94 9e 02 	call	0x53c	; 0x53c <tinyAxon_add_pulse>
		}
		
		potential += POSTFIRE_POTENTIAL_REACTION; // This is usually defined as a negative value, don't be confused by the +=
     658:	20 e0       	ldi	r18, 0x00	; 0
     65a:	30 e0       	ldi	r19, 0x00	; 0
     65c:	48 ec       	ldi	r20, 0xC8	; 200
     65e:	51 e4       	ldi	r21, 0x41	; 65
     660:	c7 01       	movw	r24, r14
     662:	b6 01       	movw	r22, r12
     664:	0e 94 f3 08 	call	0x11e6	; 0x11e6 <__subsf3>
     668:	6b 01       	movw	r12, r22
     66a:	7c 01       	movw	r14, r24
		
		tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
     66c:	44 e0       	ldi	r20, 0x04	; 4
     66e:	63 e0       	ldi	r22, 0x03	; 3
     670:	81 e0       	ldi	r24, 0x01	; 1
     672:	0e 94 f4 05 	call	0xbe8	; 0xbe8 <tinyLED_set_color_mode>
If the axon does fire, the potential is reduced
*/
double tinyAxon_update_potential(double potential)
{	
	//While the neuron has enough potential to fire, we want to fire more
	while (potential >= THRESHOLD_POTENTIAL)
     676:	20 e0       	ldi	r18, 0x00	; 0
     678:	30 e0       	ldi	r19, 0x00	; 0
     67a:	48 ec       	ldi	r20, 0xC8	; 200
     67c:	51 e4       	ldi	r21, 0x41	; 65
     67e:	c7 01       	movw	r24, r14
     680:	b6 01       	movw	r22, r12
     682:	0e 94 38 0b 	call	0x1670	; 0x1670 <__gesf2>
     686:	88 23       	and	r24, r24
     688:	4c f6       	brge	.-110    	; 0x61c <tinyAxon_update_potential+0x1c>
		
		tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
	}
	
	// If the neuron has a very low potential, we want to remove a pulse from the queue (if there is one)
	if(potential < -THRESHOLD_POTENTIAL && pulses_in_queue > 0) // Perhaps this should be a separate variable? For now, we will just simply use -THRESHOLD_POTENTIAL
     68a:	20 e0       	ldi	r18, 0x00	; 0
     68c:	30 e0       	ldi	r19, 0x00	; 0
     68e:	48 ec       	ldi	r20, 0xC8	; 200
     690:	51 ec       	ldi	r21, 0xC1	; 193
     692:	c7 01       	movw	r24, r14
     694:	b6 01       	movw	r22, r12
     696:	0e 94 60 09 	call	0x12c0	; 0x12c0 <__cmpsf2>
     69a:	88 23       	and	r24, r24
     69c:	0c f0       	brlt	.+2      	; 0x6a0 <tinyAxon_update_potential+0xa0>
     69e:	46 c0       	rjmp	.+140    	; 0x72c <tinyAxon_update_potential+0x12c>
     6a0:	80 91 2b 38 	lds	r24, 0x382B	; 0x80382b <pulses_in_queue>
     6a4:	88 23       	and	r24, r24
     6a6:	11 f1       	breq	.+68     	; 0x6ec <tinyAxon_update_potential+0xec>
	{
		// The neurons potential is low enough to attempt to remove a queued fire (Fire less)
		if(tinyAxon_remove_pulse())
     6a8:	0e 94 dd 02 	call	0x5ba	; 0x5ba <tinyAxon_remove_pulse>
     6ac:	88 23       	and	r24, r24
     6ae:	f1 f1       	breq	.+124    	; 0x72c <tinyAxon_update_potential+0x12c>
		{
			// The potential has evened out a bit
			potential += THRESHOLD_POTENTIAL;
     6b0:	20 e0       	ldi	r18, 0x00	; 0
     6b2:	30 e0       	ldi	r19, 0x00	; 0
     6b4:	48 ec       	ldi	r20, 0xC8	; 200
     6b6:	51 e4       	ldi	r21, 0x41	; 65
     6b8:	c7 01       	movw	r24, r14
     6ba:	b6 01       	movw	r22, r12
     6bc:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <__addsf3>
     6c0:	6b 01       	movw	r12, r22
     6c2:	7c 01       	movw	r14, r24
     6c4:	33 c0       	rjmp	.+102    	; 0x72c <tinyAxon_update_potential+0x12c>
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
	{
		for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
		{
			if(pulse_queue[i] != 0){
     6c6:	80 81       	ld	r24, Z
     6c8:	91 81       	ldd	r25, Z+1	; 0x01
     6ca:	00 97       	sbiw	r24, 0x00	; 0
     6cc:	39 f0       	breq	.+14     	; 0x6dc <tinyAxon_update_potential+0xdc>
				pulse_queue[i]--;
     6ce:	01 97       	sbiw	r24, 0x01	; 1
     6d0:	80 83       	st	Z, r24
     6d2:	91 83       	std	Z+1, r25	; 0x01
				
				// If the time went from 1 to 0, we fire the axon
				if(pulse_queue[i] == 0){
     6d4:	89 2b       	or	r24, r25
     6d6:	11 f4       	brne	.+4      	; 0x6dc <tinyAxon_update_potential+0xdc>
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
	pulses_in_queue--;
     6d8:	41 50       	subi	r20, 0x01	; 1
Function to set firing.
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
     6da:	51 e0       	ldi	r21, 0x01	; 1
     6dc:	32 96       	adiw	r30, 0x02	; 2
	}
	
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
	{
		for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
     6de:	e2 17       	cp	r30, r18
     6e0:	f3 07       	cpc	r31, r19
     6e2:	89 f7       	brne	.-30     	; 0x6c6 <tinyAxon_update_potential+0xc6>
     6e4:	50 93 2c 38 	sts	0x382C, r21	; 0x80382c <tinyAxon_should_fire>
     6e8:	40 93 2b 38 	sts	0x382B, r20	; 0x80382b <pulses_in_queue>
The function should set the DAC to fire for two
update cycles once the pulse flag is set high.
*/
static void tinyAxon_update_pulse_transmitter(void)
{
	if (tinyAxon_should_fire)
     6ec:	80 91 2c 38 	lds	r24, 0x382C	; 0x80382c <tinyAxon_should_fire>
     6f0:	88 23       	and	r24, r24
     6f2:	91 f0       	breq	.+36     	; 0x718 <tinyAxon_update_potential+0x118>
	{
		tinyAxon_should_fire = false;
     6f4:	10 92 2c 38 	sts	0x382C, r1	; 0x80382c <tinyAxon_should_fire>
		tinyAxon_has_fired = true;
     6f8:	81 e0       	ldi	r24, 0x01	; 1
     6fa:	80 93 2d 38 	sts	0x382D, r24	; 0x80382d <tinyAxon_has_fired>
*/
static void tinyAxon_start_sending_pulse()
{
	if (NEURONTYPE == EXCITATORY_NEURON)
	{
		DAC_0_set_output(EXCITATORY_NEURON_OUTPUT);
     6fe:	82 ed       	ldi	r24, 0xD2	; 210
     700:	90 e0       	ldi	r25, 0x00	; 0
     702:	0e 94 91 01 	call	0x322	; 0x322 <DAC_0_set_output>
		axonOutputValue=EXCITATORY_NEURON_OUTPUT;
     706:	82 ed       	ldi	r24, 0xD2	; 210
     708:	80 93 16 38 	sts	0x3816, r24	; 0x803816 <__data_end>
	{
		DAC_0_set_output(INHIBITORY_NEURON_OUTPUT);
		axonOutputValue=INHIBITORY_NEURON_OUTPUT;
	}
	
	tinyLED_set_color_mode(OUT_LED, WHITE, FLASH_ONCE);
     70c:	44 e0       	ldi	r20, 0x04	; 4
     70e:	64 e0       	ldi	r22, 0x04	; 4
     710:	80 e0       	ldi	r24, 0x00	; 0
     712:	0e 94 f4 05 	call	0xbe8	; 0xbe8 <tinyLED_set_color_mode>
     716:	15 c0       	rjmp	.+42     	; 0x742 <tinyAxon_update_potential+0x142>
		tinyAxon_should_fire = false;
		tinyAxon_has_fired = true;
		
		tinyAxon_start_sending_pulse();
	}
	else if (tinyAxon_has_fired)
     718:	80 91 2d 38 	lds	r24, 0x382D	; 0x80382d <tinyAxon_has_fired>
     71c:	88 23       	and	r24, r24
     71e:	19 f0       	breq	.+6      	; 0x726 <tinyAxon_update_potential+0x126>
	{
		tinyAxon_has_fired = false;
     720:	10 92 2d 38 	sts	0x382D, r1	; 0x80382d <tinyAxon_has_fired>
     724:	0e c0       	rjmp	.+28     	; 0x742 <tinyAxon_update_potential+0x142>
	}
	else if (!tinyAxon_has_fired && !tinyAxon_should_fire)
	{
		tinyAxon_stop_sending_pulse();
     726:	0e 94 d6 02 	call	0x5ac	; 0x5ac <tinyAxon_stop_sending_pulse>
     72a:	0b c0       	rjmp	.+22     	; 0x742 <tinyAxon_update_potential+0x142>
			potential += THRESHOLD_POTENTIAL;
		}
	}
	
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
     72c:	40 91 2b 38 	lds	r20, 0x382B	; 0x80382b <pulses_in_queue>
     730:	44 23       	and	r20, r20
     732:	e1 f2       	breq	.-72     	; 0x6ec <tinyAxon_update_potential+0xec>
     734:	50 91 2c 38 	lds	r21, 0x382C	; 0x80382c <tinyAxon_should_fire>
     738:	e7 e1       	ldi	r30, 0x17	; 23
     73a:	f8 e3       	ldi	r31, 0x38	; 56
     73c:	2b e2       	ldi	r18, 0x2B	; 43
     73e:	38 e3       	ldi	r19, 0x38	; 56
     740:	c2 cf       	rjmp	.-124    	; 0x6c6 <tinyAxon_update_potential+0xc6>
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTB_get_pin_level(const uint8_t pin)
{
	return VPORTB.IN & (1 << pin);
     742:	86 b1       	in	r24, 0x06	; 6
	// We need to check if the axon is connected to a charger. We do this by checking the AXON_CHECK_PIN. If it is hight while the axon is not firing, it must be connected to a charger
	if(AXON_CHECK_PIN_get_level() && !tinyAxon_should_fire){
		//tinyCharge_set_charging_mode(true);
	}
	
	tinyDebugger_send_uint8("Axon", axonOutputValue);
     744:	60 91 16 38 	lds	r22, 0x3816	; 0x803816 <__data_end>
     748:	83 e1       	ldi	r24, 0x13	; 19
     74a:	94 ea       	ldi	r25, 0xA4	; 164
     74c:	0e 94 6a 04 	call	0x8d4	; 0x8d4 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("Pulses", pulses_in_queue);
     750:	60 91 2b 38 	lds	r22, 0x382B	; 0x80382b <pulses_in_queue>
     754:	88 e1       	ldi	r24, 0x18	; 24
     756:	94 ea       	ldi	r25, 0xA4	; 164
     758:	0e 94 6a 04 	call	0x8d4	; 0x8d4 <tinyDebugger_send_uint8>
	
	return potential;
}
     75c:	c7 01       	movw	r24, r14
     75e:	b6 01       	movw	r22, r12
     760:	ff 90       	pop	r15
     762:	ef 90       	pop	r14
     764:	df 90       	pop	r13
     766:	cf 90       	pop	r12
     768:	08 95       	ret

0000076a <tinyButton_update>:
/*
If the button has been let go, we change button_press to true. This only lasts one cycle, before it is set to false again.
If the button is held down for longer than PULSEMODE_BUTTON_PRESS_TIME, we toggle the pulse mode state.
*/
void tinyButton_update(void)
{
     76a:	0f 93       	push	r16
     76c:	1f 93       	push	r17
     76e:	cf 93       	push	r28
     770:	df 93       	push	r29
	button_press = false;
     772:	10 92 32 38 	sts	0x3832, r1	; 0x803832 <button_press>
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTC_get_pin_level(const uint8_t pin)
{
	return VPORTC.IN & (1 << pin);
     776:	8a b1       	in	r24, 0x0a	; 10
	_Bool button_is_pushed_down = !BUTTON_PIN_get_level(); // The digital port will be read as low if the button is pushed down.
     778:	d1 e0       	ldi	r29, 0x01	; 1
     77a:	c8 2f       	mov	r28, r24
     77c:	c4 70       	andi	r28, 0x04	; 4
     77e:	82 fd       	sbrc	r24, 2
     780:	d0 e0       	ldi	r29, 0x00	; 0

	if (button_is_pushed_down && !button_was_pushed_down)
     782:	c1 11       	cpse	r28, r1
     784:	36 c0       	rjmp	.+108    	; 0x7f2 <tinyButton_update+0x88>
     786:	80 91 33 38 	lds	r24, 0x3833	; 0x803833 <button_was_pushed_down>
     78a:	81 11       	cpse	r24, r1
     78c:	0e c0       	rjmp	.+28     	; 0x7aa <tinyButton_update+0x40>
	{
		tinyButton_start_time = tinyTime_now();
     78e:	0e 94 ea 08 	call	0x11d4	; 0x11d4 <tinyTime_now>
     792:	60 93 2e 38 	sts	0x382E, r22	; 0x80382e <tinyButton_start_time>
     796:	70 93 2f 38 	sts	0x382F, r23	; 0x80382f <tinyButton_start_time+0x1>
     79a:	80 93 30 38 	sts	0x3830, r24	; 0x803830 <tinyButton_start_time+0x2>
     79e:	90 93 31 38 	sts	0x3831, r25	; 0x803831 <tinyButton_start_time+0x3>
	}
	if (button_is_pushed_down && button_was_pushed_down)
     7a2:	80 91 33 38 	lds	r24, 0x3833	; 0x803833 <button_was_pushed_down>
     7a6:	88 23       	and	r24, r24
     7a8:	69 f1       	breq	.+90     	; 0x804 <tinyButton_update+0x9a>
	{
		if ((tinyTime_now() - tinyButton_start_time) > PULSEMODE_BUTTON_PRESS_TIME)
     7aa:	0e 94 ea 08 	call	0x11d4	; 0x11d4 <tinyTime_now>
     7ae:	00 91 2e 38 	lds	r16, 0x382E	; 0x80382e <tinyButton_start_time>
     7b2:	10 91 2f 38 	lds	r17, 0x382F	; 0x80382f <tinyButton_start_time+0x1>
     7b6:	20 91 30 38 	lds	r18, 0x3830	; 0x803830 <tinyButton_start_time+0x2>
     7ba:	30 91 31 38 	lds	r19, 0x3831	; 0x803831 <tinyButton_start_time+0x3>
     7be:	60 1b       	sub	r22, r16
     7c0:	71 0b       	sbc	r23, r17
     7c2:	82 0b       	sbc	r24, r18
     7c4:	93 0b       	sbc	r25, r19
     7c6:	0e 94 40 0a 	call	0x1480	; 0x1480 <__floatunsisf>
     7ca:	20 e0       	ldi	r18, 0x00	; 0
     7cc:	30 e0       	ldi	r19, 0x00	; 0
     7ce:	48 ec       	ldi	r20, 0xC8	; 200
     7d0:	52 e4       	ldi	r21, 0x42	; 66
     7d2:	0e 94 38 0b 	call	0x1670	; 0x1670 <__gesf2>
     7d6:	18 16       	cp	r1, r24
     7d8:	64 f4       	brge	.+24     	; 0x7f2 <tinyButton_update+0x88>
		{
			tinyPulse_toggle_pulse_mode();
     7da:	0e 94 97 08 	call	0x112e	; 0x112e <tinyPulse_toggle_pulse_mode>
			tinyButton_start_time = tinyTime_now();
     7de:	0e 94 ea 08 	call	0x11d4	; 0x11d4 <tinyTime_now>
     7e2:	60 93 2e 38 	sts	0x382E, r22	; 0x80382e <tinyButton_start_time>
     7e6:	70 93 2f 38 	sts	0x382F, r23	; 0x80382f <tinyButton_start_time+0x1>
     7ea:	80 93 30 38 	sts	0x3830, r24	; 0x803830 <tinyButton_start_time+0x2>
     7ee:	90 93 31 38 	sts	0x3831, r25	; 0x803831 <tinyButton_start_time+0x3>
		}
	}
	if (!button_is_pushed_down && button_was_pushed_down)
     7f2:	cc 23       	and	r28, r28
     7f4:	39 f0       	breq	.+14     	; 0x804 <tinyButton_update+0x9a>
     7f6:	80 91 33 38 	lds	r24, 0x3833	; 0x803833 <button_was_pushed_down>
     7fa:	88 23       	and	r24, r24
     7fc:	19 f0       	breq	.+6      	; 0x804 <tinyButton_update+0x9a>
	{
		button_press = true;
     7fe:	81 e0       	ldi	r24, 0x01	; 1
     800:	80 93 32 38 	sts	0x3832, r24	; 0x803832 <button_press>
	}
	button_was_pushed_down = button_is_pushed_down;
     804:	d0 93 33 38 	sts	0x3833, r29	; 0x803833 <button_was_pushed_down>
}
     808:	df 91       	pop	r29
     80a:	cf 91       	pop	r28
     80c:	1f 91       	pop	r17
     80e:	0f 91       	pop	r16
     810:	08 95       	ret

00000812 <tinyButton_update_potential>:

double tinyButton_update_potential(double potential){
	if(button_press){
     812:	20 91 32 38 	lds	r18, 0x3832	; 0x803832 <button_press>
     816:	22 23       	and	r18, r18
     818:	31 f0       	breq	.+12     	; 0x826 <tinyButton_update_potential+0x14>
		potential += BUTTON_PRESS_REACTION;
     81a:	20 e0       	ldi	r18, 0x00	; 0
     81c:	30 e0       	ldi	r19, 0x00	; 0
     81e:	48 ec       	ldi	r20, 0xC8	; 200
     820:	51 e4       	ldi	r21, 0x41	; 65
     822:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <__addsf3>
	}
	return potential;
}
     826:	08 95       	ret

00000828 <tinyCharge_is_connected_to_charger>:

_Bool connected_to_charger;

_Bool tinyCharge_is_connected_to_charger(){
	return connected_to_charger;
}
     828:	80 91 59 38 	lds	r24, 0x3859	; 0x803859 <connected_to_charger>
     82c:	08 95       	ret

0000082e <tinyCharge_is_fully_charged>:
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTB_get_pin_level(const uint8_t pin)
{
	return VPORTB.IN & (1 << pin);
     82e:	86 b1       	in	r24, 0x06	; 6

_Bool tinyCharge_is_fully_charged(){
	return CHARGING_STATUS_PIN_get_level();
}
     830:	86 fb       	bst	r24, 6
     832:	88 27       	eor	r24, r24
     834:	80 f9       	bld	r24, 0
     836:	08 95       	ret

00000838 <tinyCharge_DAC_dissable>:
void tinyCharge_DAC_dissable(){
	
	// We need some way to disable the DAC to prevent huge current draw when charging (64mA). When there is no code uploaded to the attiny, there is no problem.
	// We're going to try to enable the pin as a dendrite, since they seem to be doing fine. Completely uninitializing the pin probably caused a microchip to be fried.
	
	DAC_0_uninit();
     838:	0e 94 80 01 	call	0x300	; 0x300 <DAC_0_uninit>
	DAC_0_disable();
     83c:	0e 94 8b 01 	call	0x316	; 0x316 <DAC_0_disable>
     840:	08 95       	ret

00000842 <tinyCharge_DAC_enable>:
void tinyCharge_DAC_enable(){
	
	// We need some way to disable the DAC to prevent huge current draw when charging (64mA). When there is no code uploaded to the attiny, there is no problem.
	// We're going to try to enable the pin as a dendrite, since they seem to be doing fine. Completely uninitializing the pin probably caused a microchip to be fried.
	
	DAC_0_init();
     842:	0e 94 7b 01 	call	0x2f6	; 0x2f6 <DAC_0_init>
	DAC_0_enable();
     846:	0e 94 85 01 	call	0x30a	; 0x30a <DAC_0_enable>
     84a:	08 95       	ret

0000084c <tinyCharge_switch_mode>:
	
	//TODO
	// Dissable DAC so that it doesn't draw current
	
	
	if(connected_to_charger){
     84c:	80 91 59 38 	lds	r24, 0x3859	; 0x803859 <connected_to_charger>
     850:	88 23       	and	r24, r24
     852:	71 f0       	breq	.+28     	; 0x870 <tinyCharge_switch_mode+0x24>
		// Switch from main to charging mode
		
		// Set LED
		tinyLED_set_color(OUT_LED, OFF);
     854:	60 e0       	ldi	r22, 0x00	; 0
     856:	80 e0       	ldi	r24, 0x00	; 0
     858:	0e 94 e3 05 	call	0xbc6	; 0xbc6 <tinyLED_set_color>
		tinyLED_set_color_mode(INN_LED, CHARGING_COLOR, SWING);
     85c:	42 e0       	ldi	r20, 0x02	; 2
     85e:	61 e0       	ldi	r22, 0x01	; 1
     860:	81 e0       	ldi	r24, 0x01	; 1
     862:	0e 94 f4 05 	call	0xbe8	; 0xbe8 <tinyLED_set_color_mode>
		
		// Stop axon from firing
		// (There is a small chance that the neuron is put into charging mode as it is firing. The axon is then never told to stop firing)
		tinyAxon_stop_sending_pulse();
     866:	0e 94 d6 02 	call	0x5ac	; 0x5ac <tinyAxon_stop_sending_pulse>
		
		// disable DAC
		tinyCharge_DAC_dissable();
     86a:	0e 94 1c 04 	call	0x838	; 0x838 <tinyCharge_DAC_dissable>
     86e:	08 95       	ret
	}
	else{
		// Switch from charge to main mode
		
		// Set LED
		tinyLED_set_color(OUT_LED, OFF);
     870:	60 e0       	ldi	r22, 0x00	; 0
     872:	80 e0       	ldi	r24, 0x00	; 0
     874:	0e 94 e3 05 	call	0xbc6	; 0xbc6 <tinyLED_set_color>
		tinyLED_set_color(INN_LED, OFF);
     878:	60 e0       	ldi	r22, 0x00	; 0
     87a:	81 e0       	ldi	r24, 0x01	; 1
     87c:	0e 94 e3 05 	call	0xbc6	; 0xbc6 <tinyLED_set_color>
		
		// enable DAC
		tinyCharge_DAC_enable();
     880:	0e 94 21 04 	call	0x842	; 0x842 <tinyCharge_DAC_enable>
     884:	08 95       	ret

00000886 <tinyCharge_set_charging_mode>:
_Bool tinyCharge_is_fully_charged(){
	return CHARGING_STATUS_PIN_get_level();
}

void tinyCharge_set_charging_mode(_Bool charging_status){
	if(charging_status != connected_to_charger){
     886:	90 91 59 38 	lds	r25, 0x3859	; 0x803859 <connected_to_charger>
     88a:	98 17       	cp	r25, r24
     88c:	21 f0       	breq	.+8      	; 0x896 <tinyCharge_set_charging_mode+0x10>
		connected_to_charger = charging_status;
     88e:	80 93 59 38 	sts	0x3859, r24	; 0x803859 <connected_to_charger>
		tinyCharge_switch_mode();
     892:	0e 94 26 04 	call	0x84c	; 0x84c <tinyCharge_switch_mode>
     896:	08 95       	ret

00000898 <tinyCharge_set_transistors>:
	DAC_0_init();
	DAC_0_enable();
}

void tinyCharge_set_transistors(){
	if(connected_to_charger){
     898:	80 91 59 38 	lds	r24, 0x3859	; 0x803859 <connected_to_charger>
     89c:	88 23       	and	r24, r24
     89e:	11 f0       	breq	.+4      	; 0x8a4 <tinyCharge_set_transistors+0xc>
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
	} else {
		VPORTC.OUT &= ~(1 << pin);
     8a0:	4d 98       	cbi	0x09, 5	; 9
     8a2:	08 95       	ret
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     8a4:	4d 9a       	sbi	0x09, 5	; 9
     8a6:	08 95       	ret

000008a8 <tinyDebugger_send_uint32>:
		printf("%s:%5s\t", name, number);
	}
}
void tinyDebugger_send_string(const char* name, char * value){
	if(DEBUGGING && tinyDebugger_send_message){
		printf("%s:%s\t", name, value);
     8a8:	20 91 0e 38 	lds	r18, 0x380E	; 0x80380e <tinyDebugger_send_message>
     8ac:	22 23       	and	r18, r18
     8ae:	89 f0       	breq	.+34     	; 0x8d2 <tinyDebugger_send_uint32+0x2a>
     8b0:	7f 93       	push	r23
     8b2:	6f 93       	push	r22
     8b4:	5f 93       	push	r21
     8b6:	4f 93       	push	r20
     8b8:	9f 93       	push	r25
     8ba:	8f 93       	push	r24
     8bc:	87 e2       	ldi	r24, 0x27	; 39
     8be:	94 ea       	ldi	r25, 0xA4	; 164
     8c0:	9f 93       	push	r25
     8c2:	8f 93       	push	r24
     8c4:	0e 94 cb 0c 	call	0x1996	; 0x1996 <printf>
     8c8:	8d b7       	in	r24, 0x3d	; 61
     8ca:	9e b7       	in	r25, 0x3e	; 62
     8cc:	08 96       	adiw	r24, 0x08	; 8
     8ce:	8d bf       	out	0x3d, r24	; 61
     8d0:	9e bf       	out	0x3e, r25	; 62
     8d2:	08 95       	ret

000008d4 <tinyDebugger_send_uint8>:
     8d4:	20 91 0e 38 	lds	r18, 0x380E	; 0x80380e <tinyDebugger_send_message>
     8d8:	22 23       	and	r18, r18
     8da:	81 f0       	breq	.+32     	; 0x8fc <tinyDebugger_send_uint8+0x28>
     8dc:	1f 92       	push	r1
     8de:	6f 93       	push	r22
     8e0:	9f 93       	push	r25
     8e2:	8f 93       	push	r24
     8e4:	80 e3       	ldi	r24, 0x30	; 48
     8e6:	94 ea       	ldi	r25, 0xA4	; 164
     8e8:	9f 93       	push	r25
     8ea:	8f 93       	push	r24
     8ec:	0e 94 cb 0c 	call	0x1996	; 0x1996 <printf>
     8f0:	0f 90       	pop	r0
     8f2:	0f 90       	pop	r0
     8f4:	0f 90       	pop	r0
     8f6:	0f 90       	pop	r0
     8f8:	0f 90       	pop	r0
     8fa:	0f 90       	pop	r0
     8fc:	08 95       	ret

000008fe <tinyDebugger_send_double>:
     8fe:	cf 92       	push	r12
     900:	df 92       	push	r13
     902:	ef 92       	push	r14
     904:	ff 92       	push	r15
     906:	0f 93       	push	r16
     908:	1f 93       	push	r17
     90a:	cf 93       	push	r28
     90c:	df 93       	push	r29
     90e:	cd b7       	in	r28, 0x3d	; 61
     910:	de b7       	in	r29, 0x3e	; 62
     912:	64 97       	sbiw	r28, 0x14	; 20
     914:	cd bf       	out	0x3d, r28	; 61
     916:	de bf       	out	0x3e, r29	; 62
     918:	38 2f       	mov	r19, r24
     91a:	e9 2f       	mov	r30, r25
     91c:	20 91 0e 38 	lds	r18, 0x380E	; 0x80380e <tinyDebugger_send_message>
     920:	22 23       	and	r18, r18
     922:	e9 f0       	breq	.+58     	; 0x95e <tinyDebugger_send_double+0x60>
     924:	cb 01       	movw	r24, r22
     926:	ba 01       	movw	r22, r20
     928:	ee 2e       	mov	r14, r30
     92a:	f3 2e       	mov	r15, r19
     92c:	9e 01       	movw	r18, r28
     92e:	2f 5f       	subi	r18, 0xFF	; 255
     930:	3f 4f       	sbci	r19, 0xFF	; 255
     932:	69 01       	movw	r12, r18
     934:	89 01       	movw	r16, r18
     936:	21 e0       	ldi	r18, 0x01	; 1
     938:	41 e0       	ldi	r20, 0x01	; 1
     93a:	0e 94 ab 0c 	call	0x1956	; 0x1956 <dtostrf>
     93e:	df 92       	push	r13
     940:	cf 92       	push	r12
     942:	ef 92       	push	r14
     944:	ff 92       	push	r15
     946:	88 e3       	ldi	r24, 0x38	; 56
     948:	94 ea       	ldi	r25, 0xA4	; 164
     94a:	9f 93       	push	r25
     94c:	8f 93       	push	r24
     94e:	0e 94 cb 0c 	call	0x1996	; 0x1996 <printf>
     952:	0f 90       	pop	r0
     954:	0f 90       	pop	r0
     956:	0f 90       	pop	r0
     958:	0f 90       	pop	r0
     95a:	0f 90       	pop	r0
     95c:	0f 90       	pop	r0
     95e:	64 96       	adiw	r28, 0x14	; 20
     960:	cd bf       	out	0x3d, r28	; 61
     962:	de bf       	out	0x3e, r29	; 62
     964:	df 91       	pop	r29
     966:	cf 91       	pop	r28
     968:	1f 91       	pop	r17
     96a:	0f 91       	pop	r16
     96c:	ff 90       	pop	r15
     96e:	ef 90       	pop	r14
     970:	df 90       	pop	r13
     972:	cf 90       	pop	r12
     974:	08 95       	ret

00000976 <tinyDebugger_end_line>:
	}
}
void tinyDebugger_end_line(){
	if(DEBUGGING && tinyDebugger_send_message){
     976:	80 91 0e 38 	lds	r24, 0x380E	; 0x80380e <tinyDebugger_send_message>
     97a:	88 23       	and	r24, r24
     97c:	21 f0       	breq	.+8      	; 0x986 <tinyDebugger_end_line+0x10>
		printf("\r\n");
     97e:	87 e4       	ldi	r24, 0x47	; 71
     980:	94 ea       	ldi	r25, 0xA4	; 164
     982:	0e 94 e1 0c 	call	0x19c2	; 0x19c2 <puts>
	}
	tinyDebugger_print_attempts++;
     986:	80 91 34 38 	lds	r24, 0x3834	; 0x803834 <tinyDebugger_print_attempts>
     98a:	90 91 35 38 	lds	r25, 0x3835	; 0x803835 <tinyDebugger_print_attempts+0x1>
     98e:	01 96       	adiw	r24, 0x01	; 1
     990:	80 93 34 38 	sts	0x3834, r24	; 0x803834 <tinyDebugger_print_attempts>
     994:	90 93 35 38 	sts	0x3835, r25	; 0x803835 <tinyDebugger_print_attempts+0x1>
	tinyDebugger_send_message = tinyDebugger_print_attempts%DEBUG_EVERY == 0;
     998:	81 e0       	ldi	r24, 0x01	; 1
     99a:	80 93 0e 38 	sts	0x380E, r24	; 0x80380e <tinyDebugger_send_message>
     99e:	08 95       	ret

000009a0 <tinyDendrite_update_signals>:
/*
This function converts the 8 bit value from the ADC into one of the signal types defined in DendriteSignal
We also update the charging state
*/
void tinyDendrite_update_signals(void)
{
     9a0:	af 92       	push	r10
     9a2:	bf 92       	push	r11
     9a4:	cf 92       	push	r12
     9a6:	df 92       	push	r13
     9a8:	ef 92       	push	r14
     9aa:	ff 92       	push	r15
     9ac:	0f 93       	push	r16
     9ae:	1f 93       	push	r17
     9b0:	cf 93       	push	r28
     9b2:	df 93       	push	r29
     9b4:	cf e0       	ldi	r28, 0x0F	; 15
     9b6:	d8 e3       	ldi	r29, 0x38	; 56
     9b8:	00 e4       	ldi	r16, 0x40	; 64
     9ba:	18 e3       	ldi	r17, 0x38	; 56
     9bc:	0f 2e       	mov	r0, r31
     9be:	f4 e1       	ldi	r31, 0x14	; 20
     9c0:	cf 2e       	mov	r12, r31
     9c2:	f8 e3       	ldi	r31, 0x38	; 56
     9c4:	df 2e       	mov	r13, r31
     9c6:	f0 2d       	mov	r31, r0
     9c8:	78 01       	movw	r14, r16
*/
static void tinyDendrite_read_signals(void)
{
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_values[i] = ADC_0_get_conversion(Dendrite_ports[i]);
     9ca:	89 91       	ld	r24, Y+
     9cc:	0e 94 45 01 	call	0x28a	; 0x28a <ADC_0_get_conversion>
     9d0:	d7 01       	movw	r26, r14
     9d2:	8d 93       	st	X+, r24
     9d4:	7d 01       	movw	r14, r26
/*
This function reads the voltage at the Dendrite inputs with the ADC
*/
static void tinyDendrite_read_signals(void)
{
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
     9d6:	cc 15       	cp	r28, r12
     9d8:	dd 05       	cpc	r29, r13
     9da:	b9 f7       	brne	.-18     	; 0x9ca <tinyDendrite_update_signals+0x2a>
	{
		tinyDendrite_values[i] = ADC_0_get_conversion(Dendrite_ports[i]);
	}
	tinyDebugger_send_uint8("D1", tinyDendrite_values[0]);
     9dc:	c0 e4       	ldi	r28, 0x40	; 64
     9de:	d8 e3       	ldi	r29, 0x38	; 56
     9e0:	68 81       	ld	r22, Y
     9e2:	89 e4       	ldi	r24, 0x49	; 73
     9e4:	94 ea       	ldi	r25, 0xA4	; 164
     9e6:	0e 94 6a 04 	call	0x8d4	; 0x8d4 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D2", tinyDendrite_values[1]);
     9ea:	69 81       	ldd	r22, Y+1	; 0x01
     9ec:	8c e4       	ldi	r24, 0x4C	; 76
     9ee:	94 ea       	ldi	r25, 0xA4	; 164
     9f0:	0e 94 6a 04 	call	0x8d4	; 0x8d4 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D3", tinyDendrite_values[2]);
     9f4:	6a 81       	ldd	r22, Y+2	; 0x02
     9f6:	8f e4       	ldi	r24, 0x4F	; 79
     9f8:	94 ea       	ldi	r25, 0xA4	; 164
     9fa:	0e 94 6a 04 	call	0x8d4	; 0x8d4 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D4", tinyDendrite_values[3]);
     9fe:	6b 81       	ldd	r22, Y+3	; 0x03
     a00:	82 e5       	ldi	r24, 0x52	; 82
     a02:	94 ea       	ldi	r25, 0xA4	; 164
     a04:	0e 94 6a 04 	call	0x8d4	; 0x8d4 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D5", tinyDendrite_values[4]);
     a08:	6c 81       	ldd	r22, Y+4	; 0x04
     a0a:	85 e5       	ldi	r24, 0x55	; 85
     a0c:	94 ea       	ldi	r25, 0xA4	; 164
     a0e:	0e 94 6a 04 	call	0x8d4	; 0x8d4 <tinyDebugger_send_uint8>
     a12:	eb e3       	ldi	r30, 0x3B	; 59
     a14:	f8 e3       	ldi	r31, 0x38	; 56
     a16:	c6 e3       	ldi	r28, 0x36	; 54
     a18:	d8 e3       	ldi	r29, 0x38	; 56
     a1a:	40 e4       	ldi	r20, 0x40	; 64
     a1c:	58 e3       	ldi	r21, 0x38	; 56
{
	
	//Read the analog voltage values on each of the Dendrites
	tinyDendrite_read_signals();
	
	_Bool charging = false;
     a1e:	80 e0       	ldi	r24, 0x00	; 0
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     a20:	31 e0       	ldi	r19, 0x01	; 1
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
		}
		else if (tinyDendrite_values[i] > HIGH_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
     a22:	0f 2e       	mov	r0, r31
     a24:	f3 e0       	ldi	r31, 0x03	; 3
     a26:	cf 2e       	mov	r12, r31
     a28:	f0 2d       	mov	r31, r0
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     a2a:	68 94       	set
     a2c:	dd 24       	eor	r13, r13
     a2e:	d1 f8       	bld	r13, 1
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     a30:	68 94       	set
     a32:	ee 24       	eor	r14, r14
     a34:	e2 f8       	bld	r14, 2
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     a36:	0f 2e       	mov	r0, r31
     a38:	f6 e0       	ldi	r31, 0x06	; 6
     a3a:	ff 2e       	mov	r15, r31
     a3c:	f0 2d       	mov	r31, r0
			tinyDendrite_current_signals[i] = CHARGING;
			charging = true;
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     a3e:	75 e0       	ldi	r23, 0x05	; 5
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = CHARGING;
     a40:	67 e0       	ldi	r22, 0x07	; 7
     a42:	5f 01       	movw	r10, r30
	
	_Bool charging = false;
	
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
     a44:	90 81       	ld	r25, Z
     a46:	99 93       	st	Y+, r25
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
     a48:	d8 01       	movw	r26, r16
     a4a:	2d 91       	ld	r18, X+
     a4c:	8d 01       	movw	r16, r26
     a4e:	29 3e       	cpi	r18, 0xE9	; 233
     a50:	18 f0       	brcs	.+6      	; 0xa58 <tinyDendrite_update_signals+0xb8>
		{
			tinyDendrite_current_signals[i] = CHARGING;
     a52:	60 83       	st	Z, r22
			charging = true;
     a54:	83 2f       	mov	r24, r19
     a56:	19 c0       	rjmp	.+50     	; 0xa8a <tinyDendrite_update_signals+0xea>
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
     a58:	28 3c       	cpi	r18, 0xC8	; 200
     a5a:	10 f0       	brcs	.+4      	; 0xa60 <tinyDendrite_update_signals+0xc0>
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     a5c:	70 83       	st	Z, r23
     a5e:	15 c0       	rjmp	.+42     	; 0xa8a <tinyDendrite_update_signals+0xea>
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
     a60:	27 3a       	cpi	r18, 0xA7	; 167
     a62:	10 f0       	brcs	.+4      	; 0xa68 <tinyDendrite_update_signals+0xc8>
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     a64:	f0 82       	st	Z, r15
     a66:	11 c0       	rjmp	.+34     	; 0xa8a <tinyDendrite_update_signals+0xea>
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
     a68:	25 38       	cpi	r18, 0x85	; 133
     a6a:	10 f0       	brcs	.+4      	; 0xa70 <tinyDendrite_update_signals+0xd0>
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     a6c:	e0 82       	st	Z, r14
     a6e:	0d c0       	rjmp	.+26     	; 0xa8a <tinyDendrite_update_signals+0xea>
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
     a70:	24 36       	cpi	r18, 0x64	; 100
     a72:	10 f0       	brcs	.+4      	; 0xa78 <tinyDendrite_update_signals+0xd8>
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     a74:	d0 82       	st	Z, r13
     a76:	09 c0       	rjmp	.+18     	; 0xa8a <tinyDendrite_update_signals+0xea>
		}
		else if (tinyDendrite_values[i] > HIGH_INHIB_THRESHOLD)
     a78:	23 34       	cpi	r18, 0x43	; 67
     a7a:	10 f0       	brcs	.+4      	; 0xa80 <tinyDendrite_update_signals+0xe0>
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
     a7c:	c0 82       	st	Z, r12
     a7e:	05 c0       	rjmp	.+10     	; 0xa8a <tinyDendrite_update_signals+0xea>
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
     a80:	22 32       	cpi	r18, 0x22	; 34
     a82:	10 f0       	brcs	.+4      	; 0xa88 <tinyDendrite_update_signals+0xe8>
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     a84:	30 83       	st	Z, r19
     a86:	01 c0       	rjmp	.+2      	; 0xa8a <tinyDendrite_update_signals+0xea>
		}
		else
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     a88:	10 82       	st	Z, r1
		}
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
     a8a:	d5 01       	movw	r26, r10
     a8c:	2c 91       	ld	r18, X
     a8e:	92 13       	cpse	r25, r18
     a90:	01 c0       	rjmp	.+2      	; 0xa94 <tinyDendrite_update_signals+0xf4>
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     a92:	1c 92       	st	X, r1
     a94:	31 96       	adiw	r30, 0x01	; 1
	//Read the analog voltage values on each of the Dendrites
	tinyDendrite_read_signals();
	
	_Bool charging = false;
	
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
     a96:	e4 17       	cp	r30, r20
     a98:	f5 07       	cpc	r31, r21
     a9a:	99 f6       	brne	.-90     	; 0xa42 <tinyDendrite_update_signals+0xa2>
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
		}
	}
	tinyCharge_set_charging_mode(charging);
     a9c:	0e 94 43 04 	call	0x886	; 0x886 <tinyCharge_set_charging_mode>
}
     aa0:	df 91       	pop	r29
     aa2:	cf 91       	pop	r28
     aa4:	1f 91       	pop	r17
     aa6:	0f 91       	pop	r16
     aa8:	ff 90       	pop	r15
     aaa:	ef 90       	pop	r14
     aac:	df 90       	pop	r13
     aae:	cf 90       	pop	r12
     ab0:	bf 90       	pop	r11
     ab2:	af 90       	pop	r10
     ab4:	08 95       	ret

00000ab6 <tinyDendrite_get_potential>:
outside. It uses the previously declared functions to return the potential.
*/
int16_t tinyDendrite_get_potential()
{
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
     ab6:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <tinyDendrite_update_signals>
     aba:	eb e3       	ldi	r30, 0x3B	; 59
     abc:	f8 e3       	ldi	r31, 0x38	; 56
     abe:	40 e4       	ldi	r20, 0x40	; 64
     ac0:	58 e3       	ldi	r21, 0x38	; 56
	
	int16_t return_potential_val = 0;
     ac2:	20 e0       	ldi	r18, 0x00	; 0
     ac4:	30 e0       	ldi	r19, 0x00	; 0
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		switch(tinyDendrite_current_signals[i])
     ac6:	91 91       	ld	r25, Z+
     ac8:	93 30       	cpi	r25, 0x03	; 3
     aca:	a1 f0       	breq	.+40     	; 0xaf4 <tinyDendrite_get_potential+0x3e>
     acc:	28 f4       	brcc	.+10     	; 0xad8 <tinyDendrite_get_potential+0x22>
     ace:	91 30       	cpi	r25, 0x01	; 1
     ad0:	b9 f0       	breq	.+46     	; 0xb00 <tinyDendrite_get_potential+0x4a>
     ad2:	92 30       	cpi	r25, 0x02	; 2
     ad4:	91 f0       	breq	.+36     	; 0xafa <tinyDendrite_get_potential+0x44>
     ad6:	16 c0       	rjmp	.+44     	; 0xb04 <tinyDendrite_get_potential+0x4e>
     ad8:	95 30       	cpi	r25, 0x05	; 5
     ada:	31 f0       	breq	.+12     	; 0xae8 <tinyDendrite_get_potential+0x32>
     adc:	40 f0       	brcs	.+16     	; 0xaee <tinyDendrite_get_potential+0x38>
     ade:	96 30       	cpi	r25, 0x06	; 6
     ae0:	89 f4       	brne	.+34     	; 0xb04 <tinyDendrite_get_potential+0x4e>
		{
			case NO_SIGNAL:
				return_potential_val += NO_SIGNAL_REACTION;
				break;
			case HIGH_EXCITE:
				return_potential_val += HIGH_EXCITE_REACTION;
     ae2:	2c 5c       	subi	r18, 0xCC	; 204
     ae4:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     ae6:	0e c0       	rjmp	.+28     	; 0xb04 <tinyDendrite_get_potential+0x4e>
			case NORMAL_EXCITE:
				return_potential_val += NORMAL_EXCITE_REACTION;
     ae8:	27 5e       	subi	r18, 0xE7	; 231
     aea:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     aec:	0b c0       	rjmp	.+22     	; 0xb04 <tinyDendrite_get_potential+0x4e>
			case LOW_EXCITE:
				return_potential_val += LOW_EXCITE_REACTION;
     aee:	2c 5e       	subi	r18, 0xEC	; 236
     af0:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     af2:	08 c0       	rjmp	.+16     	; 0xb04 <tinyDendrite_get_potential+0x4e>
			case HIGH_INHIB:
				return_potential_val += HIGH_INHIB_REACTION;
     af4:	22 53       	subi	r18, 0x32	; 50
     af6:	31 09       	sbc	r19, r1
				break;
     af8:	05 c0       	rjmp	.+10     	; 0xb04 <tinyDendrite_get_potential+0x4e>
			case NORMAL_INHIB:
				return_potential_val += NORMAL_INHIB_REACTION;
     afa:	29 51       	subi	r18, 0x19	; 25
     afc:	31 09       	sbc	r19, r1
				break;
     afe:	02 c0       	rjmp	.+4      	; 0xb04 <tinyDendrite_get_potential+0x4e>
			case LOW_INHIB:
				return_potential_val += LOW_INHIB_REACTION;
     b00:	24 51       	subi	r18, 0x14	; 20
     b02:	31 09       	sbc	r19, r1
{
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
	
	int16_t return_potential_val = 0;
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
     b04:	e4 17       	cp	r30, r20
     b06:	f5 07       	cpc	r31, r21
     b08:	f1 f6       	brne	.-68     	; 0xac6 <tinyDendrite_get_potential+0x10>
			default:
				break;
		}
	}
	return return_potential_val;
}
     b0a:	c9 01       	movw	r24, r18
     b0c:	08 95       	ret

00000b0e <tinyDendrite_update_potential>:

double tinyDendrite_update_potential(double potential){
     b0e:	cf 92       	push	r12
     b10:	df 92       	push	r13
     b12:	ef 92       	push	r14
     b14:	ff 92       	push	r15
     b16:	6b 01       	movw	r12, r22
     b18:	7c 01       	movw	r14, r24
	
	int16_t potential_change = tinyDendrite_get_potential();
     b1a:	0e 94 5b 05 	call	0xab6	; 0xab6 <tinyDendrite_get_potential>
	potential += potential_change;
	return potential;
     b1e:	bc 01       	movw	r22, r24
     b20:	99 0f       	add	r25, r25
     b22:	88 0b       	sbc	r24, r24
     b24:	99 0b       	sbc	r25, r25
     b26:	0e 94 42 0a 	call	0x1484	; 0x1484 <__floatsisf>
     b2a:	a7 01       	movw	r20, r14
     b2c:	96 01       	movw	r18, r12
     b2e:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <__addsf3>
     b32:	ff 90       	pop	r15
     b34:	ef 90       	pop	r14
     b36:	df 90       	pop	r13
     b38:	cf 90       	pop	r12
     b3a:	08 95       	ret

00000b3c <__vector_6>:
This function is called every time the RTC (Real Time Clock) counter overflows.
With the current settings, it will be called every ms.
The RTC clock runs at 1kHz, and the number of cycles before overflow is set with RTC.PER = someHexValue (e.g. 0x20) in src/rtc.c
*/
ISR(RTC_CNT_vect)
{
     b3c:	1f 92       	push	r1
     b3e:	0f 92       	push	r0
     b40:	0f b6       	in	r0, 0x3f	; 63
     b42:	0f 92       	push	r0
     b44:	11 24       	eor	r1, r1
     b46:	2f 93       	push	r18
     b48:	3f 93       	push	r19
     b4a:	4f 93       	push	r20
     b4c:	5f 93       	push	r21
     b4e:	6f 93       	push	r22
     b50:	7f 93       	push	r23
     b52:	8f 93       	push	r24
     b54:	9f 93       	push	r25
     b56:	af 93       	push	r26
     b58:	bf 93       	push	r27
     b5a:	cf 93       	push	r28
     b5c:	ef 93       	push	r30
     b5e:	ff 93       	push	r31
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     b60:	c1 e0       	ldi	r28, 0x01	; 1
     b62:	c0 93 45 38 	sts	0x3845, r28	; 0x803845 <tinyISR_interrupt_flag>
{
	// Set flag to let main loop run a new cycle
	tinyISR_setflag(true);
	
	// Timer counter incrementation
	tinyTime_counter_increment();
     b66:	0e 94 d6 08 	call	0x11ac	; 0x11ac <tinyTime_counter_increment>

	/* Overflow interrupt flag has to be cleared manually */
	RTC.INTFLAGS = RTC_OVF_bm;
     b6a:	c0 93 43 01 	sts	0x0143, r28	; 0x800143 <__TEXT_REGION_LENGTH__+0x700143>
}
     b6e:	ff 91       	pop	r31
     b70:	ef 91       	pop	r30
     b72:	cf 91       	pop	r28
     b74:	bf 91       	pop	r27
     b76:	af 91       	pop	r26
     b78:	9f 91       	pop	r25
     b7a:	8f 91       	pop	r24
     b7c:	7f 91       	pop	r23
     b7e:	6f 91       	pop	r22
     b80:	5f 91       	pop	r21
     b82:	4f 91       	pop	r20
     b84:	3f 91       	pop	r19
     b86:	2f 91       	pop	r18
     b88:	0f 90       	pop	r0
     b8a:	0f be       	out	0x3f, r0	; 63
     b8c:	0f 90       	pop	r0
     b8e:	1f 90       	pop	r1
     b90:	18 95       	reti

00000b92 <tinyISR_setflag>:
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     b92:	80 93 45 38 	sts	0x3845, r24	; 0x803845 <tinyISR_interrupt_flag>
     b96:	08 95       	ret

00000b98 <tinyISR_getflag>:
}

_Bool tinyISR_getflag(void)
{
	return tinyISR_interrupt_flag;
}
     b98:	80 91 45 38 	lds	r24, 0x3845	; 0x803845 <tinyISR_interrupt_flag>
     b9c:	08 95       	ret

00000b9e <tinyLED_SPIWriteByte>:
Function used to send a byte over SPI, which in turn gets
translated to the bit-sequence required by the LEDs over the CCL.
*/
static void tinyLED_SPIWriteByte(uint8_t byte)
{
	SPI0.INTFLAGS = SPI0_INTFLAGS; // clear the write collision flag to allow writing
     b9e:	90 91 23 08 	lds	r25, 0x0823	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
     ba2:	90 93 23 08 	sts	0x0823, r25	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
	TCA0.SINGLE.CNT = 0; // reset TCA counter register to ensure the first rising edge of the PWM is predictable
     ba6:	e0 e0       	ldi	r30, 0x00	; 0
     ba8:	fa e0       	ldi	r31, 0x0A	; 10
     baa:	10 a2       	std	Z+32, r1	; 0x20
     bac:	11 a2       	std	Z+33, r1	; 0x21
	
	// start TCA
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 1 << TCA_SPLIT_ENABLE_bp;
     bae:	91 e0       	ldi	r25, 0x01	; 1
     bb0:	90 83       	st	Z, r25
	SPI0_DATA = byte;
     bb2:	80 93 24 08 	sts	0x0824, r24	; 0x800824 <__TEXT_REGION_LENGTH__+0x700824>

	while((SPI0.INTFLAGS & SPI_RXCIE_bm) == 0){} // wait for transfer to complete
     bb6:	e0 e2       	ldi	r30, 0x20	; 32
     bb8:	f8 e0       	ldi	r31, 0x08	; 8
     bba:	83 81       	ldd	r24, Z+3	; 0x03
     bbc:	88 23       	and	r24, r24
     bbe:	ec f7       	brge	.-6      	; 0xbba <tinyLED_SPIWriteByte+0x1c>
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 0 << TCA_SPLIT_ENABLE_bp; //Stop TCA
     bc0:	10 92 00 0a 	sts	0x0A00, r1	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
     bc4:	08 95       	ret

00000bc6 <tinyLED_set_color>:
changes the values in the variables stored in the LED-array.
*/
void tinyLED_set_color_mode(uint8_t LED_id, enum Colors color, enum ColorModes mode)
{
	struct ColorSetting setting = {.color=color, .mode=mode};
	tinyLED_colors[LED_id] = setting;
     bc6:	e8 2f       	mov	r30, r24
     bc8:	f0 e0       	ldi	r31, 0x00	; 0
     bca:	ee 0f       	add	r30, r30
     bcc:	ff 1f       	adc	r31, r31
     bce:	ee 59       	subi	r30, 0x9E	; 158
     bd0:	f7 4c       	sbci	r31, 0xC7	; 199
     bd2:	60 83       	st	Z, r22
     bd4:	11 82       	std	Z+1, r1	; 0x01
     bd6:	08 95       	ret

00000bd8 <tinyLED_get_color>:
	tinyLED_set_color_mode(LED_id, color, STABLE);
}

enum Colors tinyLED_get_color(uint8_t LED_id)
{
	return tinyLED_colors[LED_id].color;
     bd8:	e8 2f       	mov	r30, r24
     bda:	f0 e0       	ldi	r31, 0x00	; 0
     bdc:	ee 0f       	add	r30, r30
     bde:	ff 1f       	adc	r31, r31
     be0:	ee 59       	subi	r30, 0x9E	; 158
     be2:	f7 4c       	sbci	r31, 0xC7	; 199
}
     be4:	80 81       	ld	r24, Z
     be6:	08 95       	ret

00000be8 <tinyLED_set_color_mode>:
changes the values in the variables stored in the LED-array.
*/
void tinyLED_set_color_mode(uint8_t LED_id, enum Colors color, enum ColorModes mode)
{
	struct ColorSetting setting = {.color=color, .mode=mode};
	tinyLED_colors[LED_id] = setting;
     be8:	90 e0       	ldi	r25, 0x00	; 0
     bea:	fc 01       	movw	r30, r24
     bec:	ee 0f       	add	r30, r30
     bee:	ff 1f       	adc	r31, r31
     bf0:	ee 59       	subi	r30, 0x9E	; 158
     bf2:	f7 4c       	sbci	r31, 0xC7	; 199
     bf4:	60 83       	st	Z, r22
     bf6:	41 83       	std	Z+1, r20	; 0x01
	if (mode == FLASH_ONCE)
     bf8:	44 30       	cpi	r20, 0x04	; 4
     bfa:	29 f4       	brne	.+10     	; 0xc06 <tinyLED_set_color_mode+0x1e>
	{
		tinyLED_flash_once_time[LED_id] = 1000*FLASH_TIME;
     bfc:	fc 01       	movw	r30, r24
     bfe:	e6 5a       	subi	r30, 0xA6	; 166
     c00:	f7 4c       	sbci	r31, 0xC7	; 199
     c02:	2a e0       	ldi	r18, 0x0A	; 10
     c04:	20 83       	st	Z, r18
     c06:	08 95       	ret

00000c08 <tinyLED_RGB_Color_Compare>:
	}
	return rgb_color;
			
};

_Bool tinyLED_RGB_Color_Compare(struct RGB_Color* a, struct RGB_Color* b){
     c08:	dc 01       	movw	r26, r24
     c0a:	fb 01       	movw	r30, r22
	for (int i=0; i<NUMBER_OF_LEDS; i++)
	{
		if(!(a[i].red==b[i].red && a[i].green==b[i].green && a[i].blue==b[i].blue)){
     c0c:	9c 91       	ld	r25, X
     c0e:	80 81       	ld	r24, Z
     c10:	98 13       	cpse	r25, r24
     c12:	20 c0       	rjmp	.+64     	; 0xc54 <tinyLED_RGB_Color_Compare+0x4c>
     c14:	11 96       	adiw	r26, 0x01	; 1
     c16:	9c 91       	ld	r25, X
     c18:	11 97       	sbiw	r26, 0x01	; 1
     c1a:	81 81       	ldd	r24, Z+1	; 0x01
     c1c:	98 13       	cpse	r25, r24
     c1e:	1c c0       	rjmp	.+56     	; 0xc58 <tinyLED_RGB_Color_Compare+0x50>
     c20:	12 96       	adiw	r26, 0x02	; 2
     c22:	9c 91       	ld	r25, X
     c24:	12 97       	sbiw	r26, 0x02	; 2
     c26:	82 81       	ldd	r24, Z+2	; 0x02
     c28:	98 13       	cpse	r25, r24
     c2a:	18 c0       	rjmp	.+48     	; 0xc5c <tinyLED_RGB_Color_Compare+0x54>
     c2c:	13 96       	adiw	r26, 0x03	; 3
     c2e:	9c 91       	ld	r25, X
     c30:	13 97       	sbiw	r26, 0x03	; 3
     c32:	83 81       	ldd	r24, Z+3	; 0x03
     c34:	98 13       	cpse	r25, r24
     c36:	14 c0       	rjmp	.+40     	; 0xc60 <tinyLED_RGB_Color_Compare+0x58>
     c38:	14 96       	adiw	r26, 0x04	; 4
     c3a:	9c 91       	ld	r25, X
     c3c:	14 97       	sbiw	r26, 0x04	; 4
     c3e:	84 81       	ldd	r24, Z+4	; 0x04
     c40:	98 13       	cpse	r25, r24
     c42:	10 c0       	rjmp	.+32     	; 0xc64 <tinyLED_RGB_Color_Compare+0x5c>
     c44:	81 e0       	ldi	r24, 0x01	; 1
     c46:	15 96       	adiw	r26, 0x05	; 5
     c48:	2c 91       	ld	r18, X
     c4a:	95 81       	ldd	r25, Z+5	; 0x05
     c4c:	29 17       	cp	r18, r25
     c4e:	59 f0       	breq	.+22     	; 0xc66 <tinyLED_RGB_Color_Compare+0x5e>
     c50:	80 e0       	ldi	r24, 0x00	; 0
     c52:	08 95       	ret
			return false;
     c54:	80 e0       	ldi	r24, 0x00	; 0
     c56:	08 95       	ret
     c58:	80 e0       	ldi	r24, 0x00	; 0
     c5a:	08 95       	ret
     c5c:	80 e0       	ldi	r24, 0x00	; 0
     c5e:	08 95       	ret
     c60:	80 e0       	ldi	r24, 0x00	; 0
     c62:	08 95       	ret
     c64:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	return true;
}
     c66:	08 95       	ret

00000c68 <tinyLED_update>:
/*
function to write the current LED-array on to the LEDs and
effectively update the values stored in the LEDs to the values stored in the MCU.
*/
void tinyLED_update(void)
{
     c68:	2f 92       	push	r2
     c6a:	3f 92       	push	r3
     c6c:	4f 92       	push	r4
     c6e:	5f 92       	push	r5
     c70:	6f 92       	push	r6
     c72:	7f 92       	push	r7
     c74:	8f 92       	push	r8
     c76:	9f 92       	push	r9
     c78:	af 92       	push	r10
     c7a:	bf 92       	push	r11
     c7c:	cf 92       	push	r12
     c7e:	df 92       	push	r13
     c80:	ef 92       	push	r14
     c82:	ff 92       	push	r15
     c84:	0f 93       	push	r16
     c86:	1f 93       	push	r17
     c88:	cf 93       	push	r28
     c8a:	df 93       	push	r29
     c8c:	cd b7       	in	r28, 0x3d	; 61
     c8e:	de b7       	in	r29, 0x3e	; 62
     c90:	6e 97       	sbiw	r28, 0x1e	; 30
     c92:	cd bf       	out	0x3d, r28	; 61
     c94:	de bf       	out	0x3e, r29	; 62
			
	uint32_t now = tinyTime_now();
     c96:	0e 94 ea 08 	call	0x11d4	; 0x11d4 <tinyTime_now>
     c9a:	6b 01       	movw	r12, r22
     c9c:	7c 01       	movw	r14, r24
	
	// This is a sin curve, but between 0 and 1 instead of -1 and 1
	double sinValue = 0.5+sin((double)now/(100*M_PI/SWING_RATE))/2;
     c9e:	0e 94 40 0a 	call	0x1480	; 0x1480 <__floatunsisf>
     ca2:	22 ed       	ldi	r18, 0xD2	; 210
     ca4:	33 e5       	ldi	r19, 0x53	; 83
     ca6:	4b ef       	ldi	r20, 0xFB	; 251
     ca8:	51 e4       	ldi	r21, 0x41	; 65
     caa:	0e 94 65 09 	call	0x12ca	; 0x12ca <__divsf3>
     cae:	0e 94 20 0c 	call	0x1840	; 0x1840 <sin>
     cb2:	20 e0       	ldi	r18, 0x00	; 0
     cb4:	30 e0       	ldi	r19, 0x00	; 0
     cb6:	40 e0       	ldi	r20, 0x00	; 0
     cb8:	5f e3       	ldi	r21, 0x3F	; 63
     cba:	0e 94 b3 0b 	call	0x1766	; 0x1766 <__mulsf3>
     cbe:	20 e0       	ldi	r18, 0x00	; 0
     cc0:	30 e0       	ldi	r19, 0x00	; 0
     cc2:	40 e0       	ldi	r20, 0x00	; 0
     cc4:	5f e3       	ldi	r21, 0x3F	; 63
     cc6:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <__addsf3>
     cca:	69 87       	std	Y+9, r22	; 0x09
     ccc:	7a 87       	std	Y+10, r23	; 0x0a
     cce:	8b 87       	std	Y+11, r24	; 0x0b
     cd0:	9c 87       	std	Y+12, r25	; 0x0c
	
	// If FLASH_RATE is one, then that means that the left side of the "<" will just count from 0 to 1000, and flash_on will be true for half of the time
	_Bool flash_on = now%(uint32_t)(1000/FLASH_RATE)  <   500/FLASH_RATE;
     cd2:	c7 01       	movw	r24, r14
     cd4:	b6 01       	movw	r22, r12
     cd6:	22 e3       	ldi	r18, 0x32	; 50
     cd8:	30 e0       	ldi	r19, 0x00	; 0
     cda:	40 e0       	ldi	r20, 0x00	; 0
     cdc:	50 e0       	ldi	r21, 0x00	; 0
     cde:	0e 94 89 0c 	call	0x1912	; 0x1912 <__udivmodsi4>
     ce2:	0e 94 40 0a 	call	0x1480	; 0x1480 <__floatunsisf>
     ce6:	20 e0       	ldi	r18, 0x00	; 0
     ce8:	30 e0       	ldi	r19, 0x00	; 0
     cea:	48 ec       	ldi	r20, 0xC8	; 200
     cec:	51 e4       	ldi	r21, 0x41	; 65
     cee:	0e 94 60 09 	call	0x12c0	; 0x12c0 <__cmpsf2>
     cf2:	88 1f       	adc	r24, r24
     cf4:	88 27       	eor	r24, r24
     cf6:	88 1f       	adc	r24, r24
     cf8:	8f 83       	std	Y+7, r24	; 0x07
	
	// PING_RATE is usually small, so the left side counts to some large number. Since flash_time usually is also quite small,
	// the left side will usually be larger than the right
	_Bool ping_on =  now%(uint32_t)(1000/PING_RATE)   <   1000*FLASH_TIME;
     cfa:	c7 01       	movw	r24, r14
     cfc:	b6 01       	movw	r22, r12
     cfe:	24 ef       	ldi	r18, 0xF4	; 244
     d00:	31 e0       	ldi	r19, 0x01	; 1
     d02:	40 e0       	ldi	r20, 0x00	; 0
     d04:	50 e0       	ldi	r21, 0x00	; 0
     d06:	0e 94 89 0c 	call	0x1912	; 0x1912 <__udivmodsi4>
     d0a:	0e 94 40 0a 	call	0x1480	; 0x1480 <__floatunsisf>
     d0e:	20 e0       	ldi	r18, 0x00	; 0
     d10:	30 e0       	ldi	r19, 0x00	; 0
     d12:	40 e2       	ldi	r20, 0x20	; 32
     d14:	51 e4       	ldi	r21, 0x41	; 65
     d16:	0e 94 60 09 	call	0x12c0	; 0x12c0 <__cmpsf2>
     d1a:	88 1f       	adc	r24, r24
     d1c:	88 27       	eor	r24, r24
     d1e:	88 1f       	adc	r24, r24
     d20:	02 e6       	ldi	r16, 0x62	; 98
     d22:	18 e3       	ldi	r17, 0x38	; 56
     d24:	9e 01       	movw	r18, r28
     d26:	2f 5f       	subi	r18, 0xFF	; 255
     d28:	3f 4f       	sbci	r19, 0xFF	; 255
     d2a:	0f 2e       	mov	r0, r31
     d2c:	fa e5       	ldi	r31, 0x5A	; 90
     d2e:	4f 2e       	mov	r4, r31
     d30:	f8 e3       	ldi	r31, 0x38	; 56
     d32:	5f 2e       	mov	r5, r31
     d34:	f0 2d       	mov	r31, r0
     d36:	0f 2e       	mov	r0, r31
     d38:	f6 e6       	ldi	r31, 0x66	; 102
     d3a:	6f 2e       	mov	r6, r31
     d3c:	f8 e3       	ldi	r31, 0x38	; 56
     d3e:	7f 2e       	mov	r7, r31
     d40:	f0 2d       	mov	r31, r0
     d42:	19 01       	movw	r2, r18
			case SWING:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*sinValue, rgb_colors[i].green*sinValue, rgb_colors[i].blue*sinValue};
				break;
			case PING:
				// in the line below, fmin will either return 1 or 0, so each rgb color is either 0 or 255*PING_BRIGHTNESS
				rgb_colors[i] = (struct RGB_Color){255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].red)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].green)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].blue)*ping_on};
     d44:	88 2e       	mov	r8, r24
     d46:	91 2c       	mov	r9, r1
     d48:	a1 2c       	mov	r10, r1
     d4a:	b1 2c       	mov	r11, r1
     d4c:	2d 87       	std	Y+13, r18	; 0x0d
     d4e:	3e 87       	std	Y+14, r19	; 0x0e
     d50:	df 80       	ldd	r13, Y+7	; 0x07
     d52:	f8 01       	movw	r30, r16
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 0 << TCA_SPLIT_ENABLE_bp; //Stop TCA
}

static struct RGB_Color tinyLED_enum_to_RGB_Color(enum Colors color){
	struct RGB_Color rgb_color;
	switch(color)
     d54:	80 81       	ld	r24, Z
     d56:	82 30       	cpi	r24, 0x02	; 2
     d58:	a1 f0       	breq	.+40     	; 0xd82 <tinyLED_update+0x11a>
     d5a:	18 f4       	brcc	.+6      	; 0xd62 <tinyLED_update+0xfa>
     d5c:	81 30       	cpi	r24, 0x01	; 1
     d5e:	31 f0       	breq	.+12     	; 0xd6c <tinyLED_update+0x104>
     d60:	21 c0       	rjmp	.+66     	; 0xda4 <tinyLED_update+0x13c>
     d62:	83 30       	cpi	r24, 0x03	; 3
     d64:	39 f0       	breq	.+14     	; 0xd74 <tinyLED_update+0x10c>
     d66:	84 30       	cpi	r24, 0x04	; 4
     d68:	99 f0       	breq	.+38     	; 0xd90 <tinyLED_update+0x128>
     d6a:	1c c0       	rjmp	.+56     	; 0xda4 <tinyLED_update+0x13c>
	{
		case OFF:
			rgb_color = (struct RGB_Color){0, 0, 0};
			break;
		case RED:
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 0, 0};
     d6c:	f1 2c       	mov	r15, r1
     d6e:	e1 2c       	mov	r14, r1
     d70:	69 e1       	ldi	r22, 0x19	; 25
     d72:	1b c0       	rjmp	.+54     	; 0xdaa <tinyLED_update+0x142>
			break;
		case GREEN:
			rgb_color = (struct RGB_Color){0, 255*LED_BRIGHTNESS, 0};
     d74:	f1 2c       	mov	r15, r1
     d76:	0f 2e       	mov	r0, r31
     d78:	f9 e1       	ldi	r31, 0x19	; 25
     d7a:	ef 2e       	mov	r14, r31
     d7c:	f0 2d       	mov	r31, r0
     d7e:	60 e0       	ldi	r22, 0x00	; 0
     d80:	14 c0       	rjmp	.+40     	; 0xdaa <tinyLED_update+0x142>
			break;
		case BLUE:
			rgb_color = (struct RGB_Color){0, 0, 255*LED_BRIGHTNESS};
     d82:	0f 2e       	mov	r0, r31
     d84:	f9 e1       	ldi	r31, 0x19	; 25
     d86:	ff 2e       	mov	r15, r31
     d88:	f0 2d       	mov	r31, r0
     d8a:	e1 2c       	mov	r14, r1
     d8c:	60 e0       	ldi	r22, 0x00	; 0
     d8e:	0d c0       	rjmp	.+26     	; 0xdaa <tinyLED_update+0x142>
			// Should the /3 be there? This requires testing.
			// After testing, findings were that at 0.1 brightness, one would see the three LEDs instead of one white led
			// We try with /2 instead.
			// We find that the best results come from not dividing by anything. At leasts in the lower brightness settings, and that
			// is where we suspect it will be most of the time. When we divide, the LEDs are so weak, that they appear as three lights instead of one.
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS};
     d90:	0f 2e       	mov	r0, r31
     d92:	f9 e1       	ldi	r31, 0x19	; 25
     d94:	ff 2e       	mov	r15, r31
     d96:	f0 2d       	mov	r31, r0
     d98:	0f 2e       	mov	r0, r31
     d9a:	f9 e1       	ldi	r31, 0x19	; 25
     d9c:	ef 2e       	mov	r14, r31
     d9e:	f0 2d       	mov	r31, r0
     da0:	69 e1       	ldi	r22, 0x19	; 25
     da2:	03 c0       	rjmp	.+6      	; 0xdaa <tinyLED_update+0x142>
static struct RGB_Color tinyLED_enum_to_RGB_Color(enum Colors color){
	struct RGB_Color rgb_color;
	switch(color)
	{
		case OFF:
			rgb_color = (struct RGB_Color){0, 0, 0};
     da4:	f1 2c       	mov	r15, r1
     da6:	e1 2c       	mov	r14, r1
     da8:	60 e0       	ldi	r22, 0x00	; 0
     daa:	2f 82       	std	Y+7, r2	; 0x07
     dac:	38 86       	std	Y+8, r3	; 0x08
	
		
	for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
	{		
		// Convert enum to RGB_Color
		rgb_colors[i] = tinyLED_enum_to_RGB_Color(tinyLED_colors[i].color);
     dae:	d1 01       	movw	r26, r2
     db0:	6c 93       	st	X, r22
     db2:	11 96       	adiw	r26, 0x01	; 1
     db4:	ec 92       	st	X, r14
     db6:	11 97       	sbiw	r26, 0x01	; 1
     db8:	12 96       	adiw	r26, 0x02	; 2
     dba:	fc 92       	st	X, r15
			
		// Adjust colors according to mode
		switch(tinyLED_colors[i].mode)
     dbc:	81 81       	ldd	r24, Z+1	; 0x01
     dbe:	82 30       	cpi	r24, 0x02	; 2
     dc0:	d1 f0       	breq	.+52     	; 0xdf6 <tinyLED_update+0x18e>
     dc2:	18 f4       	brcc	.+6      	; 0xdca <tinyLED_update+0x162>
     dc4:	81 30       	cpi	r24, 0x01	; 1
     dc6:	41 f0       	breq	.+16     	; 0xdd8 <tinyLED_update+0x170>
     dc8:	cd c0       	rjmp	.+410    	; 0xf64 <tinyLED_update+0x2fc>
     dca:	83 30       	cpi	r24, 0x03	; 3
     dcc:	09 f4       	brne	.+2      	; 0xdd0 <tinyLED_update+0x168>
     dce:	44 c0       	rjmp	.+136    	; 0xe58 <tinyLED_update+0x1f0>
     dd0:	84 30       	cpi	r24, 0x04	; 4
     dd2:	09 f4       	brne	.+2      	; 0xdd6 <tinyLED_update+0x16e>
     dd4:	bf c0       	rjmp	.+382    	; 0xf54 <tinyLED_update+0x2ec>
     dd6:	c6 c0       	rjmp	.+396    	; 0xf64 <tinyLED_update+0x2fc>
		{
			case STABLE:
				break;
			case FLASH:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*flash_on, rgb_colors[i].green*flash_on, rgb_colors[i].blue*flash_on};
     dd8:	d6 9e       	mul	r13, r22
     dda:	60 2d       	mov	r22, r0
     ddc:	11 24       	eor	r1, r1
     dde:	ef 81       	ldd	r30, Y+7	; 0x07
     de0:	f8 85       	ldd	r31, Y+8	; 0x08
     de2:	60 83       	st	Z, r22
     de4:	de 9c       	mul	r13, r14
     de6:	e0 2c       	mov	r14, r0
     de8:	11 24       	eor	r1, r1
     dea:	e1 82       	std	Z+1, r14	; 0x01
     dec:	df 9c       	mul	r13, r15
     dee:	f0 2c       	mov	r15, r0
     df0:	11 24       	eor	r1, r1
     df2:	f2 82       	std	Z+2, r15	; 0x02
				break;
     df4:	b7 c0       	rjmp	.+366    	; 0xf64 <tinyLED_update+0x2fc>
			case SWING:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*sinValue, rgb_colors[i].green*sinValue, rgb_colors[i].blue*sinValue};
     df6:	70 e0       	ldi	r23, 0x00	; 0
     df8:	80 e0       	ldi	r24, 0x00	; 0
     dfa:	90 e0       	ldi	r25, 0x00	; 0
     dfc:	0e 94 42 0a 	call	0x1484	; 0x1484 <__floatsisf>
     e00:	29 85       	ldd	r18, Y+9	; 0x09
     e02:	3a 85       	ldd	r19, Y+10	; 0x0a
     e04:	4b 85       	ldd	r20, Y+11	; 0x0b
     e06:	5c 85       	ldd	r21, Y+12	; 0x0c
     e08:	0e 94 b3 0b 	call	0x1766	; 0x1766 <__mulsf3>
     e0c:	0e 94 11 0a 	call	0x1422	; 0x1422 <__fixunssfsi>
     e10:	d1 01       	movw	r26, r2
     e12:	6c 93       	st	X, r22
     e14:	6e 2d       	mov	r22, r14
     e16:	70 e0       	ldi	r23, 0x00	; 0
     e18:	80 e0       	ldi	r24, 0x00	; 0
     e1a:	90 e0       	ldi	r25, 0x00	; 0
     e1c:	0e 94 42 0a 	call	0x1484	; 0x1484 <__floatsisf>
     e20:	29 85       	ldd	r18, Y+9	; 0x09
     e22:	3a 85       	ldd	r19, Y+10	; 0x0a
     e24:	4b 85       	ldd	r20, Y+11	; 0x0b
     e26:	5c 85       	ldd	r21, Y+12	; 0x0c
     e28:	0e 94 b3 0b 	call	0x1766	; 0x1766 <__mulsf3>
     e2c:	0e 94 11 0a 	call	0x1422	; 0x1422 <__fixunssfsi>
     e30:	f1 01       	movw	r30, r2
     e32:	61 83       	std	Z+1, r22	; 0x01
     e34:	6f 2d       	mov	r22, r15
     e36:	70 e0       	ldi	r23, 0x00	; 0
     e38:	80 e0       	ldi	r24, 0x00	; 0
     e3a:	90 e0       	ldi	r25, 0x00	; 0
     e3c:	0e 94 42 0a 	call	0x1484	; 0x1484 <__floatsisf>
     e40:	29 85       	ldd	r18, Y+9	; 0x09
     e42:	3a 85       	ldd	r19, Y+10	; 0x0a
     e44:	4b 85       	ldd	r20, Y+11	; 0x0b
     e46:	5c 85       	ldd	r21, Y+12	; 0x0c
     e48:	0e 94 b3 0b 	call	0x1766	; 0x1766 <__mulsf3>
     e4c:	0e 94 11 0a 	call	0x1422	; 0x1422 <__fixunssfsi>
     e50:	d1 01       	movw	r26, r2
     e52:	12 96       	adiw	r26, 0x02	; 2
     e54:	6c 93       	st	X, r22
				break;
     e56:	86 c0       	rjmp	.+268    	; 0xf64 <tinyLED_update+0x2fc>
			case PING:
				// in the line below, fmin will either return 1 or 0, so each rgb color is either 0 or 255*PING_BRIGHTNESS
				rgb_colors[i] = (struct RGB_Color){255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].red)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].green)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].blue)*ping_on};
     e58:	70 e0       	ldi	r23, 0x00	; 0
     e5a:	80 e0       	ldi	r24, 0x00	; 0
     e5c:	90 e0       	ldi	r25, 0x00	; 0
     e5e:	0e 94 40 0a 	call	0x1480	; 0x1480 <__floatunsisf>
     e62:	9b 01       	movw	r18, r22
     e64:	ac 01       	movw	r20, r24
     e66:	60 e0       	ldi	r22, 0x00	; 0
     e68:	70 e0       	ldi	r23, 0x00	; 0
     e6a:	80 e8       	ldi	r24, 0x80	; 128
     e6c:	9f e3       	ldi	r25, 0x3F	; 63
     e6e:	0e 94 7d 0a 	call	0x14fa	; 0x14fa <fmin>
     e72:	6b 8b       	std	Y+19, r22	; 0x13
     e74:	7c 8b       	std	Y+20, r23	; 0x14
     e76:	8d 8b       	std	Y+21, r24	; 0x15
     e78:	9e 8b       	std	Y+22, r25	; 0x16
     e7a:	c5 01       	movw	r24, r10
     e7c:	b4 01       	movw	r22, r8
     e7e:	0e 94 42 0a 	call	0x1484	; 0x1484 <__floatsisf>
     e82:	6f 87       	std	Y+15, r22	; 0x0f
     e84:	78 8b       	std	Y+16, r23	; 0x10
     e86:	89 8b       	std	Y+17, r24	; 0x11
     e88:	9a 8b       	std	Y+18, r25	; 0x12
     e8a:	6e 2d       	mov	r22, r14
     e8c:	70 e0       	ldi	r23, 0x00	; 0
     e8e:	80 e0       	ldi	r24, 0x00	; 0
     e90:	90 e0       	ldi	r25, 0x00	; 0
     e92:	0e 94 40 0a 	call	0x1480	; 0x1480 <__floatunsisf>
     e96:	9b 01       	movw	r18, r22
     e98:	ac 01       	movw	r20, r24
     e9a:	60 e0       	ldi	r22, 0x00	; 0
     e9c:	70 e0       	ldi	r23, 0x00	; 0
     e9e:	80 e8       	ldi	r24, 0x80	; 128
     ea0:	9f e3       	ldi	r25, 0x3F	; 63
     ea2:	0e 94 7d 0a 	call	0x14fa	; 0x14fa <fmin>
     ea6:	6f 8b       	std	Y+23, r22	; 0x17
     ea8:	78 8f       	std	Y+24, r23	; 0x18
     eaa:	89 8f       	std	Y+25, r24	; 0x19
     eac:	9a 8f       	std	Y+26, r25	; 0x1a
     eae:	6f 2d       	mov	r22, r15
     eb0:	70 e0       	ldi	r23, 0x00	; 0
     eb2:	80 e0       	ldi	r24, 0x00	; 0
     eb4:	90 e0       	ldi	r25, 0x00	; 0
     eb6:	0e 94 40 0a 	call	0x1480	; 0x1480 <__floatunsisf>
     eba:	9b 01       	movw	r18, r22
     ebc:	ac 01       	movw	r20, r24
     ebe:	60 e0       	ldi	r22, 0x00	; 0
     ec0:	70 e0       	ldi	r23, 0x00	; 0
     ec2:	80 e8       	ldi	r24, 0x80	; 128
     ec4:	9f e3       	ldi	r25, 0x3F	; 63
     ec6:	0e 94 7d 0a 	call	0x14fa	; 0x14fa <fmin>
     eca:	6b 8f       	std	Y+27, r22	; 0x1b
     ecc:	7c 8f       	std	Y+28, r23	; 0x1c
     ece:	8d 8f       	std	Y+29, r24	; 0x1d
     ed0:	9e 8f       	std	Y+30, r25	; 0x1e
     ed2:	23 e3       	ldi	r18, 0x33	; 51
     ed4:	33 e3       	ldi	r19, 0x33	; 51
     ed6:	43 ea       	ldi	r20, 0xA3	; 163
     ed8:	50 e4       	ldi	r21, 0x40	; 64
     eda:	6b 89       	ldd	r22, Y+19	; 0x13
     edc:	7c 89       	ldd	r23, Y+20	; 0x14
     ede:	8d 89       	ldd	r24, Y+21	; 0x15
     ee0:	9e 89       	ldd	r25, Y+22	; 0x16
     ee2:	0e 94 b3 0b 	call	0x1766	; 0x1766 <__mulsf3>
     ee6:	2f 85       	ldd	r18, Y+15	; 0x0f
     ee8:	38 89       	ldd	r19, Y+16	; 0x10
     eea:	49 89       	ldd	r20, Y+17	; 0x11
     eec:	5a 89       	ldd	r21, Y+18	; 0x12
     eee:	0e 94 b3 0b 	call	0x1766	; 0x1766 <__mulsf3>
     ef2:	0e 94 11 0a 	call	0x1422	; 0x1422 <__fixunssfsi>
     ef6:	ef 81       	ldd	r30, Y+7	; 0x07
     ef8:	f8 85       	ldd	r31, Y+8	; 0x08
     efa:	60 83       	st	Z, r22
     efc:	23 e3       	ldi	r18, 0x33	; 51
     efe:	33 e3       	ldi	r19, 0x33	; 51
     f00:	43 ea       	ldi	r20, 0xA3	; 163
     f02:	50 e4       	ldi	r21, 0x40	; 64
     f04:	6f 89       	ldd	r22, Y+23	; 0x17
     f06:	78 8d       	ldd	r23, Y+24	; 0x18
     f08:	89 8d       	ldd	r24, Y+25	; 0x19
     f0a:	9a 8d       	ldd	r25, Y+26	; 0x1a
     f0c:	0e 94 b3 0b 	call	0x1766	; 0x1766 <__mulsf3>
     f10:	2f 85       	ldd	r18, Y+15	; 0x0f
     f12:	38 89       	ldd	r19, Y+16	; 0x10
     f14:	49 89       	ldd	r20, Y+17	; 0x11
     f16:	5a 89       	ldd	r21, Y+18	; 0x12
     f18:	0e 94 b3 0b 	call	0x1766	; 0x1766 <__mulsf3>
     f1c:	0e 94 11 0a 	call	0x1422	; 0x1422 <__fixunssfsi>
     f20:	af 81       	ldd	r26, Y+7	; 0x07
     f22:	b8 85       	ldd	r27, Y+8	; 0x08
     f24:	11 96       	adiw	r26, 0x01	; 1
     f26:	6c 93       	st	X, r22
     f28:	23 e3       	ldi	r18, 0x33	; 51
     f2a:	33 e3       	ldi	r19, 0x33	; 51
     f2c:	43 ea       	ldi	r20, 0xA3	; 163
     f2e:	50 e4       	ldi	r21, 0x40	; 64
     f30:	6b 8d       	ldd	r22, Y+27	; 0x1b
     f32:	7c 8d       	ldd	r23, Y+28	; 0x1c
     f34:	8d 8d       	ldd	r24, Y+29	; 0x1d
     f36:	9e 8d       	ldd	r25, Y+30	; 0x1e
     f38:	0e 94 b3 0b 	call	0x1766	; 0x1766 <__mulsf3>
     f3c:	2f 85       	ldd	r18, Y+15	; 0x0f
     f3e:	38 89       	ldd	r19, Y+16	; 0x10
     f40:	49 89       	ldd	r20, Y+17	; 0x11
     f42:	5a 89       	ldd	r21, Y+18	; 0x12
     f44:	0e 94 b3 0b 	call	0x1766	; 0x1766 <__mulsf3>
     f48:	0e 94 11 0a 	call	0x1422	; 0x1422 <__fixunssfsi>
     f4c:	ef 81       	ldd	r30, Y+7	; 0x07
     f4e:	f8 85       	ldd	r31, Y+8	; 0x08
     f50:	62 83       	std	Z+2, r22	; 0x02
				break;
     f52:	08 c0       	rjmp	.+16     	; 0xf64 <tinyLED_update+0x2fc>
			case FLASH_ONCE:
				if(tinyLED_flash_once_time[i]>0){
     f54:	d2 01       	movw	r26, r4
     f56:	8c 91       	ld	r24, X
     f58:	88 23       	and	r24, r24
     f5a:	19 f0       	breq	.+6      	; 0xf62 <tinyLED_update+0x2fa>
					rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red, rgb_colors[i].green, rgb_colors[i].blue};
					tinyLED_flash_once_time[i]--;
     f5c:	81 50       	subi	r24, 0x01	; 1
     f5e:	8c 93       	st	X, r24
     f60:	01 c0       	rjmp	.+2      	; 0xf64 <tinyLED_update+0x2fc>
				}
				else{
					tinyLED_colors[i].color = OFF;
     f62:	10 82       	st	Z, r1
     f64:	0e 5f       	subi	r16, 0xFE	; 254
     f66:	1f 4f       	sbci	r17, 0xFF	; 255
     f68:	b3 e0       	ldi	r27, 0x03	; 3
     f6a:	2b 0e       	add	r2, r27
     f6c:	31 1c       	adc	r3, r1
     f6e:	ef ef       	ldi	r30, 0xFF	; 255
     f70:	4e 1a       	sub	r4, r30
     f72:	5e 0a       	sbc	r5, r30
	
	// This is where we store all the actual color values we want to send to the LED
	struct RGB_Color rgb_colors[NUMBER_OF_LEDS];
	
		
	for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
     f74:	06 15       	cp	r16, r6
     f76:	17 05       	cpc	r17, r7
     f78:	09 f0       	breq	.+2      	; 0xf7c <tinyLED_update+0x314>
     f7a:	eb ce       	rjmp	.-554    	; 0xd52 <tinyLED_update+0xea>
     f7c:	cd 84       	ldd	r12, Y+13	; 0x0d
     f7e:	de 84       	ldd	r13, Y+14	; 0x0e
				break;
		}
	}
	
	// We only write to the LEDs if there is something to change. (In SWING mode, we update the LEDs every cycle)
	if(!tinyLED_RGB_Color_Compare(&rgb_colors, &tinyLED_old_colors)){
     f80:	6c e5       	ldi	r22, 0x5C	; 92
     f82:	78 e3       	ldi	r23, 0x38	; 56
     f84:	ce 01       	movw	r24, r28
     f86:	01 96       	adiw	r24, 0x01	; 1
     f88:	0e 94 04 06 	call	0xc08	; 0xc08 <tinyLED_RGB_Color_Compare>
     f8c:	81 11       	cpse	r24, r1
     f8e:	2f c0       	rjmp	.+94     	; 0xfee <tinyLED_update+0x386>
     f90:	0c e5       	ldi	r16, 0x5C	; 92
     f92:	18 e3       	ldi	r17, 0x38	; 56
     f94:	7e 01       	movw	r14, r28
     f96:	f7 e0       	ldi	r31, 0x07	; 7
     f98:	ef 0e       	add	r14, r31
     f9a:	f1 1c       	adc	r15, r1
		for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
		{
			// Write to LEDs
			//For some reason, the data-bus to the LEDs is serialized as GRB
			//which means the 24-bit data-bus will look like [Green[0:7], Red[0:7], Blue[0:7]]
			tinyLED_SPIWriteByte(rgb_colors[i].green);
     f9c:	d6 01       	movw	r26, r12
     f9e:	11 96       	adiw	r26, 0x01	; 1
     fa0:	8c 91       	ld	r24, X
     fa2:	0e 94 cf 05 	call	0xb9e	; 0xb9e <tinyLED_SPIWriteByte>
			tinyLED_SPIWriteByte(rgb_colors[i].red);
     fa6:	f6 01       	movw	r30, r12
     fa8:	80 81       	ld	r24, Z
     faa:	0e 94 cf 05 	call	0xb9e	; 0xb9e <tinyLED_SPIWriteByte>
			tinyLED_SPIWriteByte(rgb_colors[i].blue);
     fae:	d6 01       	movw	r26, r12
     fb0:	12 96       	adiw	r26, 0x02	; 2
     fb2:	8c 91       	ld	r24, X
     fb4:	0e 94 cf 05 	call	0xb9e	; 0xb9e <tinyLED_SPIWriteByte>
			tinyLED_old_colors[i] = rgb_colors[i];
     fb8:	f6 01       	movw	r30, r12
     fba:	81 91       	ld	r24, Z+
     fbc:	91 91       	ld	r25, Z+
     fbe:	a1 91       	ld	r26, Z+
     fc0:	6f 01       	movw	r12, r30
     fc2:	f8 01       	movw	r30, r16
     fc4:	81 93       	st	Z+, r24
     fc6:	91 93       	st	Z+, r25
     fc8:	a1 93       	st	Z+, r26
     fca:	8f 01       	movw	r16, r30
		}
	}
	
	// We only write to the LEDs if there is something to change. (In SWING mode, we update the LEDs every cycle)
	if(!tinyLED_RGB_Color_Compare(&rgb_colors, &tinyLED_old_colors)){
		for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
     fcc:	ce 14       	cp	r12, r14
     fce:	df 04       	cpc	r13, r15
     fd0:	29 f7       	brne	.-54     	; 0xf9c <tinyLED_update+0x334>
			tinyLED_SPIWriteByte(rgb_colors[i].green);
			tinyLED_SPIWriteByte(rgb_colors[i].red);
			tinyLED_SPIWriteByte(rgb_colors[i].blue);
			tinyLED_old_colors[i] = rgb_colors[i];
	}
		tinyDebugger_send_uint8("LED1 color", tinyLED_colors[0].color);
     fd2:	02 e6       	ldi	r16, 0x62	; 98
     fd4:	18 e3       	ldi	r17, 0x38	; 56
     fd6:	d8 01       	movw	r26, r16
     fd8:	6c 91       	ld	r22, X
     fda:	88 e5       	ldi	r24, 0x58	; 88
     fdc:	94 ea       	ldi	r25, 0xA4	; 164
     fde:	0e 94 6a 04 	call	0x8d4	; 0x8d4 <tinyDebugger_send_uint8>
		tinyDebugger_send_uint8("LED2 color", tinyLED_colors[1].color);
     fe2:	f8 01       	movw	r30, r16
     fe4:	62 81       	ldd	r22, Z+2	; 0x02
     fe6:	83 e6       	ldi	r24, 0x63	; 99
     fe8:	94 ea       	ldi	r25, 0xA4	; 164
     fea:	0e 94 6a 04 	call	0x8d4	; 0x8d4 <tinyDebugger_send_uint8>
	}
}
     fee:	6e 96       	adiw	r28, 0x1e	; 30
     ff0:	cd bf       	out	0x3d, r28	; 61
     ff2:	de bf       	out	0x3e, r29	; 62
     ff4:	df 91       	pop	r29
     ff6:	cf 91       	pop	r28
     ff8:	1f 91       	pop	r17
     ffa:	0f 91       	pop	r16
     ffc:	ff 90       	pop	r15
     ffe:	ef 90       	pop	r14
    1000:	df 90       	pop	r13
    1002:	cf 90       	pop	r12
    1004:	bf 90       	pop	r11
    1006:	af 90       	pop	r10
    1008:	9f 90       	pop	r9
    100a:	8f 90       	pop	r8
    100c:	7f 90       	pop	r7
    100e:	6f 90       	pop	r6
    1010:	5f 90       	pop	r5
    1012:	4f 90       	pop	r4
    1014:	3f 90       	pop	r3
    1016:	2f 90       	pop	r2
    1018:	08 95       	ret

0000101a <tinyPotential_update>:

/*
Update the potential
*/
void tinyPotential_update()
{
    101a:	cf 92       	push	r12
    101c:	df 92       	push	r13
    101e:	ef 92       	push	r14
    1020:	ff 92       	push	r15
Function to decay the potential towards 0
*/
static void tinyPotential_decay()
{
		
	uint8_t time_since_last_update = tinyTime_now() - previous_update_time;
    1022:	0e 94 ea 08 	call	0x11d4	; 0x11d4 <tinyTime_now>
	tinyPotential_potential *= (exp(-((float)time_since_last_update/(float)TINYPOTENTIAL_TIME_CONST)));
    1026:	80 91 46 38 	lds	r24, 0x3846	; 0x803846 <previous_update_time>
    102a:	68 1b       	sub	r22, r24
    102c:	70 e0       	ldi	r23, 0x00	; 0
    102e:	80 e0       	ldi	r24, 0x00	; 0
    1030:	90 e0       	ldi	r25, 0x00	; 0
    1032:	0e 94 40 0a 	call	0x1480	; 0x1480 <__floatunsisf>
    1036:	20 e0       	ldi	r18, 0x00	; 0
    1038:	30 e0       	ldi	r19, 0x00	; 0
    103a:	48 ec       	ldi	r20, 0xC8	; 200
    103c:	52 e4       	ldi	r21, 0x42	; 66
    103e:	0e 94 65 09 	call	0x12ca	; 0x12ca <__divsf3>
    1042:	90 58       	subi	r25, 0x80	; 128
    1044:	0e 94 df 09 	call	0x13be	; 0x13be <exp>
    1048:	20 91 4a 38 	lds	r18, 0x384A	; 0x80384a <tinyPotential_potential>
    104c:	30 91 4b 38 	lds	r19, 0x384B	; 0x80384b <tinyPotential_potential+0x1>
    1050:	40 91 4c 38 	lds	r20, 0x384C	; 0x80384c <tinyPotential_potential+0x2>
    1054:	50 91 4d 38 	lds	r21, 0x384D	; 0x80384d <tinyPotential_potential+0x3>
    1058:	0e 94 b3 0b 	call	0x1766	; 0x1766 <__mulsf3>
    105c:	6b 01       	movw	r12, r22
    105e:	7c 01       	movw	r14, r24
	if(fabs(tinyPotential_potential)<0.1){
    1060:	9f 77       	andi	r25, 0x7F	; 127
    1062:	2d ec       	ldi	r18, 0xCD	; 205
    1064:	3c ec       	ldi	r19, 0xCC	; 204
    1066:	4c ec       	ldi	r20, 0xCC	; 204
    1068:	5d e3       	ldi	r21, 0x3D	; 61
    106a:	0e 94 60 09 	call	0x12c0	; 0x12c0 <__cmpsf2>
    106e:	88 23       	and	r24, r24
    1070:	4c f0       	brlt	.+18     	; 0x1084 <tinyPotential_update+0x6a>
*/
static void tinyPotential_decay()
{
		
	uint8_t time_since_last_update = tinyTime_now() - previous_update_time;
	tinyPotential_potential *= (exp(-((float)time_since_last_update/(float)TINYPOTENTIAL_TIME_CONST)));
    1072:	c0 92 4a 38 	sts	0x384A, r12	; 0x80384a <tinyPotential_potential>
    1076:	d0 92 4b 38 	sts	0x384B, r13	; 0x80384b <tinyPotential_potential+0x1>
    107a:	e0 92 4c 38 	sts	0x384C, r14	; 0x80384c <tinyPotential_potential+0x2>
    107e:	f0 92 4d 38 	sts	0x384D, r15	; 0x80384d <tinyPotential_potential+0x3>
    1082:	08 c0       	rjmp	.+16     	; 0x1094 <tinyPotential_update+0x7a>
	if(fabs(tinyPotential_potential)<0.1){
		tinyPotential_potential=0;
    1084:	10 92 4a 38 	sts	0x384A, r1	; 0x80384a <tinyPotential_potential>
    1088:	10 92 4b 38 	sts	0x384B, r1	; 0x80384b <tinyPotential_potential+0x1>
    108c:	10 92 4c 38 	sts	0x384C, r1	; 0x80384c <tinyPotential_potential+0x2>
    1090:	10 92 4d 38 	sts	0x384D, r1	; 0x80384d <tinyPotential_potential+0x3>
	}
	previous_update_time = tinyTime_now();
    1094:	0e 94 ea 08 	call	0x11d4	; 0x11d4 <tinyTime_now>
    1098:	60 93 46 38 	sts	0x3846, r22	; 0x803846 <previous_update_time>
    109c:	70 93 47 38 	sts	0x3847, r23	; 0x803847 <previous_update_time+0x1>
    10a0:	80 93 48 38 	sts	0x3848, r24	; 0x803848 <previous_update_time+0x2>
    10a4:	90 93 49 38 	sts	0x3849, r25	; 0x803849 <previous_update_time+0x3>
void tinyPotential_update()
{
	//Some of the potential in the neuron has decayed away
	tinyPotential_decay();
	// Update potential with values from Dendrites
	tinyPotential_potential = tinyDendrite_update_potential(tinyPotential_potential);
    10a8:	60 91 4a 38 	lds	r22, 0x384A	; 0x80384a <tinyPotential_potential>
    10ac:	70 91 4b 38 	lds	r23, 0x384B	; 0x80384b <tinyPotential_potential+0x1>
    10b0:	80 91 4c 38 	lds	r24, 0x384C	; 0x80384c <tinyPotential_potential+0x2>
    10b4:	90 91 4d 38 	lds	r25, 0x384D	; 0x80384d <tinyPotential_potential+0x3>
    10b8:	0e 94 87 05 	call	0xb0e	; 0xb0e <tinyDendrite_update_potential>
    10bc:	60 93 4a 38 	sts	0x384A, r22	; 0x80384a <tinyPotential_potential>
    10c0:	70 93 4b 38 	sts	0x384B, r23	; 0x80384b <tinyPotential_potential+0x1>
    10c4:	80 93 4c 38 	sts	0x384C, r24	; 0x80384c <tinyPotential_potential+0x2>
    10c8:	90 93 4d 38 	sts	0x384D, r25	; 0x80384d <tinyPotential_potential+0x3>
	
	// Update potential from button press
	tinyPotential_potential = tinyButton_update_potential(tinyPotential_potential);
    10cc:	0e 94 09 04 	call	0x812	; 0x812 <tinyButton_update_potential>
    10d0:	60 93 4a 38 	sts	0x384A, r22	; 0x80384a <tinyPotential_potential>
    10d4:	70 93 4b 38 	sts	0x384B, r23	; 0x80384b <tinyPotential_potential+0x1>
    10d8:	80 93 4c 38 	sts	0x384C, r24	; 0x80384c <tinyPotential_potential+0x2>
    10dc:	90 93 4d 38 	sts	0x384D, r25	; 0x80384d <tinyPotential_potential+0x3>
	
	// Update potential with values from spontaneous pulse.
	tinyPotential_potential = tinyPulse_update_potential(tinyPotential_potential);
    10e0:	0e 94 9e 08 	call	0x113c	; 0x113c <tinyPulse_update_potential>
    10e4:	ab 01       	movw	r20, r22
    10e6:	bc 01       	movw	r22, r24
    10e8:	40 93 4a 38 	sts	0x384A, r20	; 0x80384a <tinyPotential_potential>
    10ec:	50 93 4b 38 	sts	0x384B, r21	; 0x80384b <tinyPotential_potential+0x1>
    10f0:	60 93 4c 38 	sts	0x384C, r22	; 0x80384c <tinyPotential_potential+0x2>
    10f4:	70 93 4d 38 	sts	0x384D, r23	; 0x80384d <tinyPotential_potential+0x3>
	
	tinyDebugger_send_double("Potential", tinyPotential_potential);
    10f8:	8e e6       	ldi	r24, 0x6E	; 110
    10fa:	94 ea       	ldi	r25, 0xA4	; 164
    10fc:	0e 94 7f 04 	call	0x8fe	; 0x8fe <tinyDebugger_send_double>
	
	
	// Let the axon affect the potential
	// This is also where we decide whether or not the axon should fire
	tinyPotential_potential = tinyAxon_update_potential(tinyPotential_potential);
    1100:	60 91 4a 38 	lds	r22, 0x384A	; 0x80384a <tinyPotential_potential>
    1104:	70 91 4b 38 	lds	r23, 0x384B	; 0x80384b <tinyPotential_potential+0x1>
    1108:	80 91 4c 38 	lds	r24, 0x384C	; 0x80384c <tinyPotential_potential+0x2>
    110c:	90 91 4d 38 	lds	r25, 0x384D	; 0x80384d <tinyPotential_potential+0x3>
    1110:	0e 94 00 03 	call	0x600	; 0x600 <tinyAxon_update_potential>
    1114:	60 93 4a 38 	sts	0x384A, r22	; 0x80384a <tinyPotential_potential>
    1118:	70 93 4b 38 	sts	0x384B, r23	; 0x80384b <tinyPotential_potential+0x1>
    111c:	80 93 4c 38 	sts	0x384C, r24	; 0x80384c <tinyPotential_potential+0x2>
    1120:	90 93 4d 38 	sts	0x384D, r25	; 0x80384d <tinyPotential_potential+0x3>
}
    1124:	ff 90       	pop	r15
    1126:	ef 90       	pop	r14
    1128:	df 90       	pop	r13
    112a:	cf 90       	pop	r12
    112c:	08 95       	ret

0000112e <tinyPulse_toggle_pulse_mode>:
uint32_t time_of_last_pulse = 0;
uint16_t time_since_last_pulse = 0;
uint16_t ideal_time_between_pulses = 1000/PULSEMODE_FREQUENCY;

void tinyPulse_toggle_pulse_mode(){
	pulse_mode = !pulse_mode;
    112e:	90 91 54 38 	lds	r25, 0x3854	; 0x803854 <pulse_mode>
    1132:	81 e0       	ldi	r24, 0x01	; 1
    1134:	89 27       	eor	r24, r25
    1136:	80 93 54 38 	sts	0x3854, r24	; 0x803854 <pulse_mode>
    113a:	08 95       	ret

0000113c <tinyPulse_update_potential>:
}

double tinyPulse_update_potential(double potential){
    113c:	cf 92       	push	r12
    113e:	df 92       	push	r13
    1140:	ef 92       	push	r14
    1142:	ff 92       	push	r15
    1144:	6b 01       	movw	r12, r22
    1146:	7c 01       	movw	r14, r24
	if(pulse_mode){
    1148:	80 91 54 38 	lds	r24, 0x3854	; 0x803854 <pulse_mode>
    114c:	88 23       	and	r24, r24
    114e:	39 f1       	breq	.+78     	; 0x119e <tinyPulse_update_potential+0x62>
		
		time_since_last_pulse = tinyTime_now() - time_of_last_pulse;
    1150:	0e 94 ea 08 	call	0x11d4	; 0x11d4 <tinyTime_now>
    1154:	20 91 50 38 	lds	r18, 0x3850	; 0x803850 <time_of_last_pulse>
    1158:	30 91 51 38 	lds	r19, 0x3851	; 0x803851 <time_of_last_pulse+0x1>
    115c:	62 1b       	sub	r22, r18
    115e:	73 0b       	sbc	r23, r19
    1160:	60 93 4e 38 	sts	0x384E, r22	; 0x80384e <time_since_last_pulse>
    1164:	70 93 4f 38 	sts	0x384F, r23	; 0x80384f <time_since_last_pulse+0x1>
		
		if(time_since_last_pulse >= ideal_time_between_pulses){
    1168:	80 91 14 38 	lds	r24, 0x3814	; 0x803814 <ideal_time_between_pulses>
    116c:	90 91 15 38 	lds	r25, 0x3815	; 0x803815 <ideal_time_between_pulses+0x1>
    1170:	68 17       	cp	r22, r24
    1172:	79 07       	cpc	r23, r25
    1174:	a0 f0       	brcs	.+40     	; 0x119e <tinyPulse_update_potential+0x62>
			// This isn't actually a button press. You could have a separate variable for this, but it seems unnecessary.
			potential += BUTTON_PRESS_REACTION;
    1176:	20 e0       	ldi	r18, 0x00	; 0
    1178:	30 e0       	ldi	r19, 0x00	; 0
    117a:	48 ec       	ldi	r20, 0xC8	; 200
    117c:	51 e4       	ldi	r21, 0x41	; 65
    117e:	c7 01       	movw	r24, r14
    1180:	b6 01       	movw	r22, r12
    1182:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <__addsf3>
    1186:	6b 01       	movw	r12, r22
    1188:	7c 01       	movw	r14, r24
			time_of_last_pulse = tinyTime_now();			
    118a:	0e 94 ea 08 	call	0x11d4	; 0x11d4 <tinyTime_now>
    118e:	60 93 50 38 	sts	0x3850, r22	; 0x803850 <time_of_last_pulse>
    1192:	70 93 51 38 	sts	0x3851, r23	; 0x803851 <time_of_last_pulse+0x1>
    1196:	80 93 52 38 	sts	0x3852, r24	; 0x803852 <time_of_last_pulse+0x2>
    119a:	90 93 53 38 	sts	0x3853, r25	; 0x803853 <time_of_last_pulse+0x3>
		}
	}
	return potential;
}
    119e:	c7 01       	movw	r24, r14
    11a0:	b6 01       	movw	r22, r12
    11a2:	ff 90       	pop	r15
    11a4:	ef 90       	pop	r14
    11a6:	df 90       	pop	r13
    11a8:	cf 90       	pop	r12
    11aa:	08 95       	ret

000011ac <tinyTime_counter_increment>:
If the Interrupt Service Routine is clocked by a crystal oscillator
it gives a very precise timer-counter.
*/
void tinyTime_counter_increment(void)
{
	time_counter++;
    11ac:	80 91 55 38 	lds	r24, 0x3855	; 0x803855 <time_counter>
    11b0:	90 91 56 38 	lds	r25, 0x3856	; 0x803856 <time_counter+0x1>
    11b4:	a0 91 57 38 	lds	r26, 0x3857	; 0x803857 <time_counter+0x2>
    11b8:	b0 91 58 38 	lds	r27, 0x3858	; 0x803858 <time_counter+0x3>
    11bc:	01 96       	adiw	r24, 0x01	; 1
    11be:	a1 1d       	adc	r26, r1
    11c0:	b1 1d       	adc	r27, r1
    11c2:	80 93 55 38 	sts	0x3855, r24	; 0x803855 <time_counter>
    11c6:	90 93 56 38 	sts	0x3856, r25	; 0x803856 <time_counter+0x1>
    11ca:	a0 93 57 38 	sts	0x3857, r26	; 0x803857 <time_counter+0x2>
    11ce:	b0 93 58 38 	sts	0x3858, r27	; 0x803858 <time_counter+0x3>
    11d2:	08 95       	ret

000011d4 <tinyTime_now>:
/*
This function is callable by external libraries to give them the counted time so far.
*/
uint32_t tinyTime_now(void)
{
	return time_counter;
    11d4:	60 91 55 38 	lds	r22, 0x3855	; 0x803855 <time_counter>
    11d8:	70 91 56 38 	lds	r23, 0x3856	; 0x803856 <time_counter+0x1>
    11dc:	80 91 57 38 	lds	r24, 0x3857	; 0x803857 <time_counter+0x2>
    11e0:	90 91 58 38 	lds	r25, 0x3858	; 0x803858 <time_counter+0x3>
    11e4:	08 95       	ret

000011e6 <__subsf3>:
    11e6:	50 58       	subi	r21, 0x80	; 128

000011e8 <__addsf3>:
    11e8:	bb 27       	eor	r27, r27
    11ea:	aa 27       	eor	r26, r26
    11ec:	0e 94 0b 09 	call	0x1216	; 0x1216 <__addsf3x>
    11f0:	0c 94 fe 0a 	jmp	0x15fc	; 0x15fc <__fp_round>
    11f4:	0e 94 f0 0a 	call	0x15e0	; 0x15e0 <__fp_pscA>
    11f8:	38 f0       	brcs	.+14     	; 0x1208 <__addsf3+0x20>
    11fa:	0e 94 f7 0a 	call	0x15ee	; 0x15ee <__fp_pscB>
    11fe:	20 f0       	brcs	.+8      	; 0x1208 <__addsf3+0x20>
    1200:	39 f4       	brne	.+14     	; 0x1210 <__addsf3+0x28>
    1202:	9f 3f       	cpi	r25, 0xFF	; 255
    1204:	19 f4       	brne	.+6      	; 0x120c <__addsf3+0x24>
    1206:	26 f4       	brtc	.+8      	; 0x1210 <__addsf3+0x28>
    1208:	0c 94 c6 0a 	jmp	0x158c	; 0x158c <__fp_nan>
    120c:	0e f4       	brtc	.+2      	; 0x1210 <__addsf3+0x28>
    120e:	e0 95       	com	r30
    1210:	e7 fb       	bst	r30, 7
    1212:	0c 94 c0 0a 	jmp	0x1580	; 0x1580 <__fp_inf>

00001216 <__addsf3x>:
    1216:	e9 2f       	mov	r30, r25
    1218:	0e 94 0f 0b 	call	0x161e	; 0x161e <__fp_split3>
    121c:	58 f3       	brcs	.-42     	; 0x11f4 <__addsf3+0xc>
    121e:	ba 17       	cp	r27, r26
    1220:	62 07       	cpc	r22, r18
    1222:	73 07       	cpc	r23, r19
    1224:	84 07       	cpc	r24, r20
    1226:	95 07       	cpc	r25, r21
    1228:	20 f0       	brcs	.+8      	; 0x1232 <__addsf3x+0x1c>
    122a:	79 f4       	brne	.+30     	; 0x124a <__addsf3x+0x34>
    122c:	a6 f5       	brtc	.+104    	; 0x1296 <__addsf3x+0x80>
    122e:	0c 94 31 0b 	jmp	0x1662	; 0x1662 <__fp_zero>
    1232:	0e f4       	brtc	.+2      	; 0x1236 <__addsf3x+0x20>
    1234:	e0 95       	com	r30
    1236:	0b 2e       	mov	r0, r27
    1238:	ba 2f       	mov	r27, r26
    123a:	a0 2d       	mov	r26, r0
    123c:	0b 01       	movw	r0, r22
    123e:	b9 01       	movw	r22, r18
    1240:	90 01       	movw	r18, r0
    1242:	0c 01       	movw	r0, r24
    1244:	ca 01       	movw	r24, r20
    1246:	a0 01       	movw	r20, r0
    1248:	11 24       	eor	r1, r1
    124a:	ff 27       	eor	r31, r31
    124c:	59 1b       	sub	r21, r25
    124e:	99 f0       	breq	.+38     	; 0x1276 <__addsf3x+0x60>
    1250:	59 3f       	cpi	r21, 0xF9	; 249
    1252:	50 f4       	brcc	.+20     	; 0x1268 <__addsf3x+0x52>
    1254:	50 3e       	cpi	r21, 0xE0	; 224
    1256:	68 f1       	brcs	.+90     	; 0x12b2 <__addsf3x+0x9c>
    1258:	1a 16       	cp	r1, r26
    125a:	f0 40       	sbci	r31, 0x00	; 0
    125c:	a2 2f       	mov	r26, r18
    125e:	23 2f       	mov	r18, r19
    1260:	34 2f       	mov	r19, r20
    1262:	44 27       	eor	r20, r20
    1264:	58 5f       	subi	r21, 0xF8	; 248
    1266:	f3 cf       	rjmp	.-26     	; 0x124e <__addsf3x+0x38>
    1268:	46 95       	lsr	r20
    126a:	37 95       	ror	r19
    126c:	27 95       	ror	r18
    126e:	a7 95       	ror	r26
    1270:	f0 40       	sbci	r31, 0x00	; 0
    1272:	53 95       	inc	r21
    1274:	c9 f7       	brne	.-14     	; 0x1268 <__addsf3x+0x52>
    1276:	7e f4       	brtc	.+30     	; 0x1296 <__addsf3x+0x80>
    1278:	1f 16       	cp	r1, r31
    127a:	ba 0b       	sbc	r27, r26
    127c:	62 0b       	sbc	r22, r18
    127e:	73 0b       	sbc	r23, r19
    1280:	84 0b       	sbc	r24, r20
    1282:	ba f0       	brmi	.+46     	; 0x12b2 <__addsf3x+0x9c>
    1284:	91 50       	subi	r25, 0x01	; 1
    1286:	a1 f0       	breq	.+40     	; 0x12b0 <__addsf3x+0x9a>
    1288:	ff 0f       	add	r31, r31
    128a:	bb 1f       	adc	r27, r27
    128c:	66 1f       	adc	r22, r22
    128e:	77 1f       	adc	r23, r23
    1290:	88 1f       	adc	r24, r24
    1292:	c2 f7       	brpl	.-16     	; 0x1284 <__addsf3x+0x6e>
    1294:	0e c0       	rjmp	.+28     	; 0x12b2 <__addsf3x+0x9c>
    1296:	ba 0f       	add	r27, r26
    1298:	62 1f       	adc	r22, r18
    129a:	73 1f       	adc	r23, r19
    129c:	84 1f       	adc	r24, r20
    129e:	48 f4       	brcc	.+18     	; 0x12b2 <__addsf3x+0x9c>
    12a0:	87 95       	ror	r24
    12a2:	77 95       	ror	r23
    12a4:	67 95       	ror	r22
    12a6:	b7 95       	ror	r27
    12a8:	f7 95       	ror	r31
    12aa:	9e 3f       	cpi	r25, 0xFE	; 254
    12ac:	08 f0       	brcs	.+2      	; 0x12b0 <__addsf3x+0x9a>
    12ae:	b0 cf       	rjmp	.-160    	; 0x1210 <__addsf3+0x28>
    12b0:	93 95       	inc	r25
    12b2:	88 0f       	add	r24, r24
    12b4:	08 f0       	brcs	.+2      	; 0x12b8 <__addsf3x+0xa2>
    12b6:	99 27       	eor	r25, r25
    12b8:	ee 0f       	add	r30, r30
    12ba:	97 95       	ror	r25
    12bc:	87 95       	ror	r24
    12be:	08 95       	ret

000012c0 <__cmpsf2>:
    12c0:	0e 94 9c 0a 	call	0x1538	; 0x1538 <__fp_cmp>
    12c4:	08 f4       	brcc	.+2      	; 0x12c8 <__cmpsf2+0x8>
    12c6:	81 e0       	ldi	r24, 0x01	; 1
    12c8:	08 95       	ret

000012ca <__divsf3>:
    12ca:	0e 94 79 09 	call	0x12f2	; 0x12f2 <__divsf3x>
    12ce:	0c 94 fe 0a 	jmp	0x15fc	; 0x15fc <__fp_round>
    12d2:	0e 94 f7 0a 	call	0x15ee	; 0x15ee <__fp_pscB>
    12d6:	58 f0       	brcs	.+22     	; 0x12ee <__divsf3+0x24>
    12d8:	0e 94 f0 0a 	call	0x15e0	; 0x15e0 <__fp_pscA>
    12dc:	40 f0       	brcs	.+16     	; 0x12ee <__divsf3+0x24>
    12de:	29 f4       	brne	.+10     	; 0x12ea <__divsf3+0x20>
    12e0:	5f 3f       	cpi	r21, 0xFF	; 255
    12e2:	29 f0       	breq	.+10     	; 0x12ee <__divsf3+0x24>
    12e4:	0c 94 c0 0a 	jmp	0x1580	; 0x1580 <__fp_inf>
    12e8:	51 11       	cpse	r21, r1
    12ea:	0c 94 32 0b 	jmp	0x1664	; 0x1664 <__fp_szero>
    12ee:	0c 94 c6 0a 	jmp	0x158c	; 0x158c <__fp_nan>

000012f2 <__divsf3x>:
    12f2:	0e 94 0f 0b 	call	0x161e	; 0x161e <__fp_split3>
    12f6:	68 f3       	brcs	.-38     	; 0x12d2 <__divsf3+0x8>

000012f8 <__divsf3_pse>:
    12f8:	99 23       	and	r25, r25
    12fa:	b1 f3       	breq	.-20     	; 0x12e8 <__divsf3+0x1e>
    12fc:	55 23       	and	r21, r21
    12fe:	91 f3       	breq	.-28     	; 0x12e4 <__divsf3+0x1a>
    1300:	95 1b       	sub	r25, r21
    1302:	55 0b       	sbc	r21, r21
    1304:	bb 27       	eor	r27, r27
    1306:	aa 27       	eor	r26, r26
    1308:	62 17       	cp	r22, r18
    130a:	73 07       	cpc	r23, r19
    130c:	84 07       	cpc	r24, r20
    130e:	38 f0       	brcs	.+14     	; 0x131e <__divsf3_pse+0x26>
    1310:	9f 5f       	subi	r25, 0xFF	; 255
    1312:	5f 4f       	sbci	r21, 0xFF	; 255
    1314:	22 0f       	add	r18, r18
    1316:	33 1f       	adc	r19, r19
    1318:	44 1f       	adc	r20, r20
    131a:	aa 1f       	adc	r26, r26
    131c:	a9 f3       	breq	.-22     	; 0x1308 <__divsf3_pse+0x10>
    131e:	35 d0       	rcall	.+106    	; 0x138a <__divsf3_pse+0x92>
    1320:	0e 2e       	mov	r0, r30
    1322:	3a f0       	brmi	.+14     	; 0x1332 <__divsf3_pse+0x3a>
    1324:	e0 e8       	ldi	r30, 0x80	; 128
    1326:	32 d0       	rcall	.+100    	; 0x138c <__divsf3_pse+0x94>
    1328:	91 50       	subi	r25, 0x01	; 1
    132a:	50 40       	sbci	r21, 0x00	; 0
    132c:	e6 95       	lsr	r30
    132e:	00 1c       	adc	r0, r0
    1330:	ca f7       	brpl	.-14     	; 0x1324 <__divsf3_pse+0x2c>
    1332:	2b d0       	rcall	.+86     	; 0x138a <__divsf3_pse+0x92>
    1334:	fe 2f       	mov	r31, r30
    1336:	29 d0       	rcall	.+82     	; 0x138a <__divsf3_pse+0x92>
    1338:	66 0f       	add	r22, r22
    133a:	77 1f       	adc	r23, r23
    133c:	88 1f       	adc	r24, r24
    133e:	bb 1f       	adc	r27, r27
    1340:	26 17       	cp	r18, r22
    1342:	37 07       	cpc	r19, r23
    1344:	48 07       	cpc	r20, r24
    1346:	ab 07       	cpc	r26, r27
    1348:	b0 e8       	ldi	r27, 0x80	; 128
    134a:	09 f0       	breq	.+2      	; 0x134e <__divsf3_pse+0x56>
    134c:	bb 0b       	sbc	r27, r27
    134e:	80 2d       	mov	r24, r0
    1350:	bf 01       	movw	r22, r30
    1352:	ff 27       	eor	r31, r31
    1354:	93 58       	subi	r25, 0x83	; 131
    1356:	5f 4f       	sbci	r21, 0xFF	; 255
    1358:	3a f0       	brmi	.+14     	; 0x1368 <__divsf3_pse+0x70>
    135a:	9e 3f       	cpi	r25, 0xFE	; 254
    135c:	51 05       	cpc	r21, r1
    135e:	78 f0       	brcs	.+30     	; 0x137e <__divsf3_pse+0x86>
    1360:	0c 94 c0 0a 	jmp	0x1580	; 0x1580 <__fp_inf>
    1364:	0c 94 32 0b 	jmp	0x1664	; 0x1664 <__fp_szero>
    1368:	5f 3f       	cpi	r21, 0xFF	; 255
    136a:	e4 f3       	brlt	.-8      	; 0x1364 <__divsf3_pse+0x6c>
    136c:	98 3e       	cpi	r25, 0xE8	; 232
    136e:	d4 f3       	brlt	.-12     	; 0x1364 <__divsf3_pse+0x6c>
    1370:	86 95       	lsr	r24
    1372:	77 95       	ror	r23
    1374:	67 95       	ror	r22
    1376:	b7 95       	ror	r27
    1378:	f7 95       	ror	r31
    137a:	9f 5f       	subi	r25, 0xFF	; 255
    137c:	c9 f7       	brne	.-14     	; 0x1370 <__divsf3_pse+0x78>
    137e:	88 0f       	add	r24, r24
    1380:	91 1d       	adc	r25, r1
    1382:	96 95       	lsr	r25
    1384:	87 95       	ror	r24
    1386:	97 f9       	bld	r25, 7
    1388:	08 95       	ret
    138a:	e1 e0       	ldi	r30, 0x01	; 1
    138c:	66 0f       	add	r22, r22
    138e:	77 1f       	adc	r23, r23
    1390:	88 1f       	adc	r24, r24
    1392:	bb 1f       	adc	r27, r27
    1394:	62 17       	cp	r22, r18
    1396:	73 07       	cpc	r23, r19
    1398:	84 07       	cpc	r24, r20
    139a:	ba 07       	cpc	r27, r26
    139c:	20 f0       	brcs	.+8      	; 0x13a6 <__divsf3_pse+0xae>
    139e:	62 1b       	sub	r22, r18
    13a0:	73 0b       	sbc	r23, r19
    13a2:	84 0b       	sbc	r24, r20
    13a4:	ba 0b       	sbc	r27, r26
    13a6:	ee 1f       	adc	r30, r30
    13a8:	88 f7       	brcc	.-30     	; 0x138c <__divsf3_pse+0x94>
    13aa:	e0 95       	com	r30
    13ac:	08 95       	ret
    13ae:	29 f4       	brne	.+10     	; 0x13ba <__divsf3_pse+0xc2>
    13b0:	16 f0       	brts	.+4      	; 0x13b6 <__divsf3_pse+0xbe>
    13b2:	0c 94 c0 0a 	jmp	0x1580	; 0x1580 <__fp_inf>
    13b6:	0c 94 31 0b 	jmp	0x1662	; 0x1662 <__fp_zero>
    13ba:	0c 94 c6 0a 	jmp	0x158c	; 0x158c <__fp_nan>

000013be <exp>:
    13be:	0e 94 17 0b 	call	0x162e	; 0x162e <__fp_splitA>
    13c2:	a8 f3       	brcs	.-22     	; 0x13ae <__divsf3_pse+0xb6>
    13c4:	96 38       	cpi	r25, 0x86	; 134
    13c6:	a0 f7       	brcc	.-24     	; 0x13b0 <__divsf3_pse+0xb8>
    13c8:	07 f8       	bld	r0, 7
    13ca:	0f 92       	push	r0
    13cc:	e8 94       	clt
    13ce:	2b e3       	ldi	r18, 0x3B	; 59
    13d0:	3a ea       	ldi	r19, 0xAA	; 170
    13d2:	48 eb       	ldi	r20, 0xB8	; 184
    13d4:	5f e7       	ldi	r21, 0x7F	; 127
    13d6:	0e 94 c9 0b 	call	0x1792	; 0x1792 <__mulsf3_pse>
    13da:	0f 92       	push	r0
    13dc:	0f 92       	push	r0
    13de:	0f 92       	push	r0
    13e0:	4d b7       	in	r20, 0x3d	; 61
    13e2:	5e b7       	in	r21, 0x3e	; 62
    13e4:	0f 92       	push	r0
    13e6:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <modf>
    13ea:	ec e7       	ldi	r30, 0x7C	; 124
    13ec:	f0 e0       	ldi	r31, 0x00	; 0
    13ee:	0e 94 c9 0a 	call	0x1592	; 0x1592 <__fp_powser>
    13f2:	4f 91       	pop	r20
    13f4:	5f 91       	pop	r21
    13f6:	ef 91       	pop	r30
    13f8:	ff 91       	pop	r31
    13fa:	e5 95       	asr	r30
    13fc:	ee 1f       	adc	r30, r30
    13fe:	ff 1f       	adc	r31, r31
    1400:	49 f0       	breq	.+18     	; 0x1414 <exp+0x56>
    1402:	fe 57       	subi	r31, 0x7E	; 126
    1404:	e0 68       	ori	r30, 0x80	; 128
    1406:	44 27       	eor	r20, r20
    1408:	ee 0f       	add	r30, r30
    140a:	44 1f       	adc	r20, r20
    140c:	fa 95       	dec	r31
    140e:	e1 f7       	brne	.-8      	; 0x1408 <exp+0x4a>
    1410:	41 95       	neg	r20
    1412:	55 0b       	sbc	r21, r21
    1414:	0e 94 49 0b 	call	0x1692	; 0x1692 <ldexp>
    1418:	0f 90       	pop	r0
    141a:	07 fe       	sbrs	r0, 7
    141c:	0c 94 3d 0b 	jmp	0x167a	; 0x167a <inverse>
    1420:	08 95       	ret

00001422 <__fixunssfsi>:
    1422:	0e 94 17 0b 	call	0x162e	; 0x162e <__fp_splitA>
    1426:	88 f0       	brcs	.+34     	; 0x144a <__fixunssfsi+0x28>
    1428:	9f 57       	subi	r25, 0x7F	; 127
    142a:	98 f0       	brcs	.+38     	; 0x1452 <__fixunssfsi+0x30>
    142c:	b9 2f       	mov	r27, r25
    142e:	99 27       	eor	r25, r25
    1430:	b7 51       	subi	r27, 0x17	; 23
    1432:	b0 f0       	brcs	.+44     	; 0x1460 <__fixunssfsi+0x3e>
    1434:	e1 f0       	breq	.+56     	; 0x146e <__fixunssfsi+0x4c>
    1436:	66 0f       	add	r22, r22
    1438:	77 1f       	adc	r23, r23
    143a:	88 1f       	adc	r24, r24
    143c:	99 1f       	adc	r25, r25
    143e:	1a f0       	brmi	.+6      	; 0x1446 <__fixunssfsi+0x24>
    1440:	ba 95       	dec	r27
    1442:	c9 f7       	brne	.-14     	; 0x1436 <__fixunssfsi+0x14>
    1444:	14 c0       	rjmp	.+40     	; 0x146e <__fixunssfsi+0x4c>
    1446:	b1 30       	cpi	r27, 0x01	; 1
    1448:	91 f0       	breq	.+36     	; 0x146e <__fixunssfsi+0x4c>
    144a:	0e 94 31 0b 	call	0x1662	; 0x1662 <__fp_zero>
    144e:	b1 e0       	ldi	r27, 0x01	; 1
    1450:	08 95       	ret
    1452:	0c 94 31 0b 	jmp	0x1662	; 0x1662 <__fp_zero>
    1456:	67 2f       	mov	r22, r23
    1458:	78 2f       	mov	r23, r24
    145a:	88 27       	eor	r24, r24
    145c:	b8 5f       	subi	r27, 0xF8	; 248
    145e:	39 f0       	breq	.+14     	; 0x146e <__fixunssfsi+0x4c>
    1460:	b9 3f       	cpi	r27, 0xF9	; 249
    1462:	cc f3       	brlt	.-14     	; 0x1456 <__fixunssfsi+0x34>
    1464:	86 95       	lsr	r24
    1466:	77 95       	ror	r23
    1468:	67 95       	ror	r22
    146a:	b3 95       	inc	r27
    146c:	d9 f7       	brne	.-10     	; 0x1464 <__fixunssfsi+0x42>
    146e:	3e f4       	brtc	.+14     	; 0x147e <__fixunssfsi+0x5c>
    1470:	90 95       	com	r25
    1472:	80 95       	com	r24
    1474:	70 95       	com	r23
    1476:	61 95       	neg	r22
    1478:	7f 4f       	sbci	r23, 0xFF	; 255
    147a:	8f 4f       	sbci	r24, 0xFF	; 255
    147c:	9f 4f       	sbci	r25, 0xFF	; 255
    147e:	08 95       	ret

00001480 <__floatunsisf>:
    1480:	e8 94       	clt
    1482:	09 c0       	rjmp	.+18     	; 0x1496 <__floatsisf+0x12>

00001484 <__floatsisf>:
    1484:	97 fb       	bst	r25, 7
    1486:	3e f4       	brtc	.+14     	; 0x1496 <__floatsisf+0x12>
    1488:	90 95       	com	r25
    148a:	80 95       	com	r24
    148c:	70 95       	com	r23
    148e:	61 95       	neg	r22
    1490:	7f 4f       	sbci	r23, 0xFF	; 255
    1492:	8f 4f       	sbci	r24, 0xFF	; 255
    1494:	9f 4f       	sbci	r25, 0xFF	; 255
    1496:	99 23       	and	r25, r25
    1498:	a9 f0       	breq	.+42     	; 0x14c4 <__floatsisf+0x40>
    149a:	f9 2f       	mov	r31, r25
    149c:	96 e9       	ldi	r25, 0x96	; 150
    149e:	bb 27       	eor	r27, r27
    14a0:	93 95       	inc	r25
    14a2:	f6 95       	lsr	r31
    14a4:	87 95       	ror	r24
    14a6:	77 95       	ror	r23
    14a8:	67 95       	ror	r22
    14aa:	b7 95       	ror	r27
    14ac:	f1 11       	cpse	r31, r1
    14ae:	f8 cf       	rjmp	.-16     	; 0x14a0 <__floatsisf+0x1c>
    14b0:	fa f4       	brpl	.+62     	; 0x14f0 <__floatsisf+0x6c>
    14b2:	bb 0f       	add	r27, r27
    14b4:	11 f4       	brne	.+4      	; 0x14ba <__floatsisf+0x36>
    14b6:	60 ff       	sbrs	r22, 0
    14b8:	1b c0       	rjmp	.+54     	; 0x14f0 <__floatsisf+0x6c>
    14ba:	6f 5f       	subi	r22, 0xFF	; 255
    14bc:	7f 4f       	sbci	r23, 0xFF	; 255
    14be:	8f 4f       	sbci	r24, 0xFF	; 255
    14c0:	9f 4f       	sbci	r25, 0xFF	; 255
    14c2:	16 c0       	rjmp	.+44     	; 0x14f0 <__floatsisf+0x6c>
    14c4:	88 23       	and	r24, r24
    14c6:	11 f0       	breq	.+4      	; 0x14cc <__floatsisf+0x48>
    14c8:	96 e9       	ldi	r25, 0x96	; 150
    14ca:	11 c0       	rjmp	.+34     	; 0x14ee <__floatsisf+0x6a>
    14cc:	77 23       	and	r23, r23
    14ce:	21 f0       	breq	.+8      	; 0x14d8 <__floatsisf+0x54>
    14d0:	9e e8       	ldi	r25, 0x8E	; 142
    14d2:	87 2f       	mov	r24, r23
    14d4:	76 2f       	mov	r23, r22
    14d6:	05 c0       	rjmp	.+10     	; 0x14e2 <__floatsisf+0x5e>
    14d8:	66 23       	and	r22, r22
    14da:	71 f0       	breq	.+28     	; 0x14f8 <__floatsisf+0x74>
    14dc:	96 e8       	ldi	r25, 0x86	; 134
    14de:	86 2f       	mov	r24, r22
    14e0:	70 e0       	ldi	r23, 0x00	; 0
    14e2:	60 e0       	ldi	r22, 0x00	; 0
    14e4:	2a f0       	brmi	.+10     	; 0x14f0 <__floatsisf+0x6c>
    14e6:	9a 95       	dec	r25
    14e8:	66 0f       	add	r22, r22
    14ea:	77 1f       	adc	r23, r23
    14ec:	88 1f       	adc	r24, r24
    14ee:	da f7       	brpl	.-10     	; 0x14e6 <__floatsisf+0x62>
    14f0:	88 0f       	add	r24, r24
    14f2:	96 95       	lsr	r25
    14f4:	87 95       	ror	r24
    14f6:	97 f9       	bld	r25, 7
    14f8:	08 95       	ret

000014fa <fmin>:
    14fa:	99 0f       	add	r25, r25
    14fc:	bb 0b       	sbc	r27, r27
    14fe:	55 0f       	add	r21, r21
    1500:	aa 0b       	sbc	r26, r26
    1502:	e0 e8       	ldi	r30, 0x80	; 128
    1504:	fe ef       	ldi	r31, 0xFE	; 254
    1506:	16 16       	cp	r1, r22
    1508:	17 06       	cpc	r1, r23
    150a:	e8 07       	cpc	r30, r24
    150c:	f9 07       	cpc	r31, r25
    150e:	70 f0       	brcs	.+28     	; 0x152c <fmin+0x32>
    1510:	12 16       	cp	r1, r18
    1512:	13 06       	cpc	r1, r19
    1514:	e4 07       	cpc	r30, r20
    1516:	f5 07       	cpc	r31, r21
    1518:	60 f0       	brcs	.+24     	; 0x1532 <fmin+0x38>
    151a:	ba 17       	cp	r27, r26
    151c:	54 f0       	brlt	.+20     	; 0x1532 <fmin+0x38>
    151e:	31 f4       	brne	.+12     	; 0x152c <fmin+0x32>
    1520:	26 17       	cp	r18, r22
    1522:	37 07       	cpc	r19, r23
    1524:	48 07       	cpc	r20, r24
    1526:	59 07       	cpc	r21, r25
    1528:	a7 95       	ror	r26
    152a:	1b f4       	brvc	.+6      	; 0x1532 <fmin+0x38>
    152c:	b9 01       	movw	r22, r18
    152e:	ca 01       	movw	r24, r20
    1530:	ba 2f       	mov	r27, r26
    1532:	b6 95       	lsr	r27
    1534:	97 95       	ror	r25
    1536:	08 95       	ret

00001538 <__fp_cmp>:
    1538:	99 0f       	add	r25, r25
    153a:	00 08       	sbc	r0, r0
    153c:	55 0f       	add	r21, r21
    153e:	aa 0b       	sbc	r26, r26
    1540:	e0 e8       	ldi	r30, 0x80	; 128
    1542:	fe ef       	ldi	r31, 0xFE	; 254
    1544:	16 16       	cp	r1, r22
    1546:	17 06       	cpc	r1, r23
    1548:	e8 07       	cpc	r30, r24
    154a:	f9 07       	cpc	r31, r25
    154c:	c0 f0       	brcs	.+48     	; 0x157e <__fp_cmp+0x46>
    154e:	12 16       	cp	r1, r18
    1550:	13 06       	cpc	r1, r19
    1552:	e4 07       	cpc	r30, r20
    1554:	f5 07       	cpc	r31, r21
    1556:	98 f0       	brcs	.+38     	; 0x157e <__fp_cmp+0x46>
    1558:	62 1b       	sub	r22, r18
    155a:	73 0b       	sbc	r23, r19
    155c:	84 0b       	sbc	r24, r20
    155e:	95 0b       	sbc	r25, r21
    1560:	39 f4       	brne	.+14     	; 0x1570 <__fp_cmp+0x38>
    1562:	0a 26       	eor	r0, r26
    1564:	61 f0       	breq	.+24     	; 0x157e <__fp_cmp+0x46>
    1566:	23 2b       	or	r18, r19
    1568:	24 2b       	or	r18, r20
    156a:	25 2b       	or	r18, r21
    156c:	21 f4       	brne	.+8      	; 0x1576 <__fp_cmp+0x3e>
    156e:	08 95       	ret
    1570:	0a 26       	eor	r0, r26
    1572:	09 f4       	brne	.+2      	; 0x1576 <__fp_cmp+0x3e>
    1574:	a1 40       	sbci	r26, 0x01	; 1
    1576:	a6 95       	lsr	r26
    1578:	8f ef       	ldi	r24, 0xFF	; 255
    157a:	81 1d       	adc	r24, r1
    157c:	81 1d       	adc	r24, r1
    157e:	08 95       	ret

00001580 <__fp_inf>:
    1580:	97 f9       	bld	r25, 7
    1582:	9f 67       	ori	r25, 0x7F	; 127
    1584:	80 e8       	ldi	r24, 0x80	; 128
    1586:	70 e0       	ldi	r23, 0x00	; 0
    1588:	60 e0       	ldi	r22, 0x00	; 0
    158a:	08 95       	ret

0000158c <__fp_nan>:
    158c:	9f ef       	ldi	r25, 0xFF	; 255
    158e:	80 ec       	ldi	r24, 0xC0	; 192
    1590:	08 95       	ret

00001592 <__fp_powser>:
    1592:	df 93       	push	r29
    1594:	cf 93       	push	r28
    1596:	1f 93       	push	r17
    1598:	0f 93       	push	r16
    159a:	ff 92       	push	r15
    159c:	ef 92       	push	r14
    159e:	df 92       	push	r13
    15a0:	7b 01       	movw	r14, r22
    15a2:	8c 01       	movw	r16, r24
    15a4:	68 94       	set
    15a6:	06 c0       	rjmp	.+12     	; 0x15b4 <__fp_powser+0x22>
    15a8:	da 2e       	mov	r13, r26
    15aa:	ef 01       	movw	r28, r30
    15ac:	0e 94 c6 0b 	call	0x178c	; 0x178c <__mulsf3x>
    15b0:	fe 01       	movw	r30, r28
    15b2:	e8 94       	clt
    15b4:	a5 91       	lpm	r26, Z+
    15b6:	25 91       	lpm	r18, Z+
    15b8:	35 91       	lpm	r19, Z+
    15ba:	45 91       	lpm	r20, Z+
    15bc:	55 91       	lpm	r21, Z+
    15be:	a6 f3       	brts	.-24     	; 0x15a8 <__fp_powser+0x16>
    15c0:	ef 01       	movw	r28, r30
    15c2:	0e 94 0b 09 	call	0x1216	; 0x1216 <__addsf3x>
    15c6:	fe 01       	movw	r30, r28
    15c8:	97 01       	movw	r18, r14
    15ca:	a8 01       	movw	r20, r16
    15cc:	da 94       	dec	r13
    15ce:	69 f7       	brne	.-38     	; 0x15aa <__fp_powser+0x18>
    15d0:	df 90       	pop	r13
    15d2:	ef 90       	pop	r14
    15d4:	ff 90       	pop	r15
    15d6:	0f 91       	pop	r16
    15d8:	1f 91       	pop	r17
    15da:	cf 91       	pop	r28
    15dc:	df 91       	pop	r29
    15de:	08 95       	ret

000015e0 <__fp_pscA>:
    15e0:	00 24       	eor	r0, r0
    15e2:	0a 94       	dec	r0
    15e4:	16 16       	cp	r1, r22
    15e6:	17 06       	cpc	r1, r23
    15e8:	18 06       	cpc	r1, r24
    15ea:	09 06       	cpc	r0, r25
    15ec:	08 95       	ret

000015ee <__fp_pscB>:
    15ee:	00 24       	eor	r0, r0
    15f0:	0a 94       	dec	r0
    15f2:	12 16       	cp	r1, r18
    15f4:	13 06       	cpc	r1, r19
    15f6:	14 06       	cpc	r1, r20
    15f8:	05 06       	cpc	r0, r21
    15fa:	08 95       	ret

000015fc <__fp_round>:
    15fc:	09 2e       	mov	r0, r25
    15fe:	03 94       	inc	r0
    1600:	00 0c       	add	r0, r0
    1602:	11 f4       	brne	.+4      	; 0x1608 <__fp_round+0xc>
    1604:	88 23       	and	r24, r24
    1606:	52 f0       	brmi	.+20     	; 0x161c <__fp_round+0x20>
    1608:	bb 0f       	add	r27, r27
    160a:	40 f4       	brcc	.+16     	; 0x161c <__fp_round+0x20>
    160c:	bf 2b       	or	r27, r31
    160e:	11 f4       	brne	.+4      	; 0x1614 <__fp_round+0x18>
    1610:	60 ff       	sbrs	r22, 0
    1612:	04 c0       	rjmp	.+8      	; 0x161c <__fp_round+0x20>
    1614:	6f 5f       	subi	r22, 0xFF	; 255
    1616:	7f 4f       	sbci	r23, 0xFF	; 255
    1618:	8f 4f       	sbci	r24, 0xFF	; 255
    161a:	9f 4f       	sbci	r25, 0xFF	; 255
    161c:	08 95       	ret

0000161e <__fp_split3>:
    161e:	57 fd       	sbrc	r21, 7
    1620:	90 58       	subi	r25, 0x80	; 128
    1622:	44 0f       	add	r20, r20
    1624:	55 1f       	adc	r21, r21
    1626:	59 f0       	breq	.+22     	; 0x163e <__fp_splitA+0x10>
    1628:	5f 3f       	cpi	r21, 0xFF	; 255
    162a:	71 f0       	breq	.+28     	; 0x1648 <__fp_splitA+0x1a>
    162c:	47 95       	ror	r20

0000162e <__fp_splitA>:
    162e:	88 0f       	add	r24, r24
    1630:	97 fb       	bst	r25, 7
    1632:	99 1f       	adc	r25, r25
    1634:	61 f0       	breq	.+24     	; 0x164e <__fp_splitA+0x20>
    1636:	9f 3f       	cpi	r25, 0xFF	; 255
    1638:	79 f0       	breq	.+30     	; 0x1658 <__fp_splitA+0x2a>
    163a:	87 95       	ror	r24
    163c:	08 95       	ret
    163e:	12 16       	cp	r1, r18
    1640:	13 06       	cpc	r1, r19
    1642:	14 06       	cpc	r1, r20
    1644:	55 1f       	adc	r21, r21
    1646:	f2 cf       	rjmp	.-28     	; 0x162c <__fp_split3+0xe>
    1648:	46 95       	lsr	r20
    164a:	f1 df       	rcall	.-30     	; 0x162e <__fp_splitA>
    164c:	08 c0       	rjmp	.+16     	; 0x165e <__fp_splitA+0x30>
    164e:	16 16       	cp	r1, r22
    1650:	17 06       	cpc	r1, r23
    1652:	18 06       	cpc	r1, r24
    1654:	99 1f       	adc	r25, r25
    1656:	f1 cf       	rjmp	.-30     	; 0x163a <__fp_splitA+0xc>
    1658:	86 95       	lsr	r24
    165a:	71 05       	cpc	r23, r1
    165c:	61 05       	cpc	r22, r1
    165e:	08 94       	sec
    1660:	08 95       	ret

00001662 <__fp_zero>:
    1662:	e8 94       	clt

00001664 <__fp_szero>:
    1664:	bb 27       	eor	r27, r27
    1666:	66 27       	eor	r22, r22
    1668:	77 27       	eor	r23, r23
    166a:	cb 01       	movw	r24, r22
    166c:	97 f9       	bld	r25, 7
    166e:	08 95       	ret

00001670 <__gesf2>:
    1670:	0e 94 9c 0a 	call	0x1538	; 0x1538 <__fp_cmp>
    1674:	08 f4       	brcc	.+2      	; 0x1678 <__gesf2+0x8>
    1676:	8f ef       	ldi	r24, 0xFF	; 255
    1678:	08 95       	ret

0000167a <inverse>:
    167a:	9b 01       	movw	r18, r22
    167c:	ac 01       	movw	r20, r24
    167e:	60 e0       	ldi	r22, 0x00	; 0
    1680:	70 e0       	ldi	r23, 0x00	; 0
    1682:	80 e8       	ldi	r24, 0x80	; 128
    1684:	9f e3       	ldi	r25, 0x3F	; 63
    1686:	0c 94 65 09 	jmp	0x12ca	; 0x12ca <__divsf3>
    168a:	0c 94 c0 0a 	jmp	0x1580	; 0x1580 <__fp_inf>
    168e:	0c 94 28 0c 	jmp	0x1850	; 0x1850 <__fp_mpack>

00001692 <ldexp>:
    1692:	0e 94 17 0b 	call	0x162e	; 0x162e <__fp_splitA>
    1696:	d8 f3       	brcs	.-10     	; 0x168e <inverse+0x14>
    1698:	99 23       	and	r25, r25
    169a:	c9 f3       	breq	.-14     	; 0x168e <inverse+0x14>
    169c:	94 0f       	add	r25, r20
    169e:	51 1d       	adc	r21, r1
    16a0:	a3 f3       	brvs	.-24     	; 0x168a <inverse+0x10>
    16a2:	91 50       	subi	r25, 0x01	; 1
    16a4:	50 40       	sbci	r21, 0x00	; 0
    16a6:	94 f0       	brlt	.+36     	; 0x16cc <ldexp+0x3a>
    16a8:	59 f0       	breq	.+22     	; 0x16c0 <ldexp+0x2e>
    16aa:	88 23       	and	r24, r24
    16ac:	32 f0       	brmi	.+12     	; 0x16ba <ldexp+0x28>
    16ae:	66 0f       	add	r22, r22
    16b0:	77 1f       	adc	r23, r23
    16b2:	88 1f       	adc	r24, r24
    16b4:	91 50       	subi	r25, 0x01	; 1
    16b6:	50 40       	sbci	r21, 0x00	; 0
    16b8:	c1 f7       	brne	.-16     	; 0x16aa <ldexp+0x18>
    16ba:	9e 3f       	cpi	r25, 0xFE	; 254
    16bc:	51 05       	cpc	r21, r1
    16be:	2c f7       	brge	.-54     	; 0x168a <inverse+0x10>
    16c0:	88 0f       	add	r24, r24
    16c2:	91 1d       	adc	r25, r1
    16c4:	96 95       	lsr	r25
    16c6:	87 95       	ror	r24
    16c8:	97 f9       	bld	r25, 7
    16ca:	08 95       	ret
    16cc:	5f 3f       	cpi	r21, 0xFF	; 255
    16ce:	ac f0       	brlt	.+42     	; 0x16fa <ldexp+0x68>
    16d0:	98 3e       	cpi	r25, 0xE8	; 232
    16d2:	9c f0       	brlt	.+38     	; 0x16fa <ldexp+0x68>
    16d4:	bb 27       	eor	r27, r27
    16d6:	86 95       	lsr	r24
    16d8:	77 95       	ror	r23
    16da:	67 95       	ror	r22
    16dc:	b7 95       	ror	r27
    16de:	08 f4       	brcc	.+2      	; 0x16e2 <ldexp+0x50>
    16e0:	b1 60       	ori	r27, 0x01	; 1
    16e2:	93 95       	inc	r25
    16e4:	c1 f7       	brne	.-16     	; 0x16d6 <ldexp+0x44>
    16e6:	bb 0f       	add	r27, r27
    16e8:	58 f7       	brcc	.-42     	; 0x16c0 <ldexp+0x2e>
    16ea:	11 f4       	brne	.+4      	; 0x16f0 <ldexp+0x5e>
    16ec:	60 ff       	sbrs	r22, 0
    16ee:	e8 cf       	rjmp	.-48     	; 0x16c0 <ldexp+0x2e>
    16f0:	6f 5f       	subi	r22, 0xFF	; 255
    16f2:	7f 4f       	sbci	r23, 0xFF	; 255
    16f4:	8f 4f       	sbci	r24, 0xFF	; 255
    16f6:	9f 4f       	sbci	r25, 0xFF	; 255
    16f8:	e3 cf       	rjmp	.-58     	; 0x16c0 <ldexp+0x2e>
    16fa:	0c 94 32 0b 	jmp	0x1664	; 0x1664 <__fp_szero>

000016fe <modf>:
    16fe:	fa 01       	movw	r30, r20
    1700:	dc 01       	movw	r26, r24
    1702:	aa 0f       	add	r26, r26
    1704:	bb 1f       	adc	r27, r27
    1706:	9b 01       	movw	r18, r22
    1708:	ac 01       	movw	r20, r24
    170a:	bf 57       	subi	r27, 0x7F	; 127
    170c:	28 f4       	brcc	.+10     	; 0x1718 <modf+0x1a>
    170e:	22 27       	eor	r18, r18
    1710:	33 27       	eor	r19, r19
    1712:	44 27       	eor	r20, r20
    1714:	50 78       	andi	r21, 0x80	; 128
    1716:	20 c0       	rjmp	.+64     	; 0x1758 <modf+0x5a>
    1718:	b7 51       	subi	r27, 0x17	; 23
    171a:	90 f4       	brcc	.+36     	; 0x1740 <modf+0x42>
    171c:	ab 2f       	mov	r26, r27
    171e:	00 24       	eor	r0, r0
    1720:	46 95       	lsr	r20
    1722:	37 95       	ror	r19
    1724:	27 95       	ror	r18
    1726:	01 1c       	adc	r0, r1
    1728:	a3 95       	inc	r26
    172a:	d2 f3       	brmi	.-12     	; 0x1720 <modf+0x22>
    172c:	00 20       	and	r0, r0
    172e:	71 f0       	breq	.+28     	; 0x174c <modf+0x4e>
    1730:	22 0f       	add	r18, r18
    1732:	33 1f       	adc	r19, r19
    1734:	44 1f       	adc	r20, r20
    1736:	b3 95       	inc	r27
    1738:	da f3       	brmi	.-10     	; 0x1730 <modf+0x32>
    173a:	0e d0       	rcall	.+28     	; 0x1758 <modf+0x5a>
    173c:	0c 94 f3 08 	jmp	0x11e6	; 0x11e6 <__subsf3>
    1740:	61 30       	cpi	r22, 0x01	; 1
    1742:	71 05       	cpc	r23, r1
    1744:	a0 e8       	ldi	r26, 0x80	; 128
    1746:	8a 07       	cpc	r24, r26
    1748:	b9 46       	sbci	r27, 0x69	; 105
    174a:	30 f4       	brcc	.+12     	; 0x1758 <modf+0x5a>
    174c:	9b 01       	movw	r18, r22
    174e:	ac 01       	movw	r20, r24
    1750:	66 27       	eor	r22, r22
    1752:	77 27       	eor	r23, r23
    1754:	88 27       	eor	r24, r24
    1756:	90 78       	andi	r25, 0x80	; 128
    1758:	30 96       	adiw	r30, 0x00	; 0
    175a:	21 f0       	breq	.+8      	; 0x1764 <modf+0x66>
    175c:	20 83       	st	Z, r18
    175e:	31 83       	std	Z+1, r19	; 0x01
    1760:	42 83       	std	Z+2, r20	; 0x02
    1762:	53 83       	std	Z+3, r21	; 0x03
    1764:	08 95       	ret

00001766 <__mulsf3>:
    1766:	0e 94 c6 0b 	call	0x178c	; 0x178c <__mulsf3x>
    176a:	0c 94 fe 0a 	jmp	0x15fc	; 0x15fc <__fp_round>
    176e:	0e 94 f0 0a 	call	0x15e0	; 0x15e0 <__fp_pscA>
    1772:	38 f0       	brcs	.+14     	; 0x1782 <__mulsf3+0x1c>
    1774:	0e 94 f7 0a 	call	0x15ee	; 0x15ee <__fp_pscB>
    1778:	20 f0       	brcs	.+8      	; 0x1782 <__mulsf3+0x1c>
    177a:	95 23       	and	r25, r21
    177c:	11 f0       	breq	.+4      	; 0x1782 <__mulsf3+0x1c>
    177e:	0c 94 c0 0a 	jmp	0x1580	; 0x1580 <__fp_inf>
    1782:	0c 94 c6 0a 	jmp	0x158c	; 0x158c <__fp_nan>
    1786:	11 24       	eor	r1, r1
    1788:	0c 94 32 0b 	jmp	0x1664	; 0x1664 <__fp_szero>

0000178c <__mulsf3x>:
    178c:	0e 94 0f 0b 	call	0x161e	; 0x161e <__fp_split3>
    1790:	70 f3       	brcs	.-36     	; 0x176e <__mulsf3+0x8>

00001792 <__mulsf3_pse>:
    1792:	95 9f       	mul	r25, r21
    1794:	c1 f3       	breq	.-16     	; 0x1786 <__mulsf3+0x20>
    1796:	95 0f       	add	r25, r21
    1798:	50 e0       	ldi	r21, 0x00	; 0
    179a:	55 1f       	adc	r21, r21
    179c:	62 9f       	mul	r22, r18
    179e:	f0 01       	movw	r30, r0
    17a0:	72 9f       	mul	r23, r18
    17a2:	bb 27       	eor	r27, r27
    17a4:	f0 0d       	add	r31, r0
    17a6:	b1 1d       	adc	r27, r1
    17a8:	63 9f       	mul	r22, r19
    17aa:	aa 27       	eor	r26, r26
    17ac:	f0 0d       	add	r31, r0
    17ae:	b1 1d       	adc	r27, r1
    17b0:	aa 1f       	adc	r26, r26
    17b2:	64 9f       	mul	r22, r20
    17b4:	66 27       	eor	r22, r22
    17b6:	b0 0d       	add	r27, r0
    17b8:	a1 1d       	adc	r26, r1
    17ba:	66 1f       	adc	r22, r22
    17bc:	82 9f       	mul	r24, r18
    17be:	22 27       	eor	r18, r18
    17c0:	b0 0d       	add	r27, r0
    17c2:	a1 1d       	adc	r26, r1
    17c4:	62 1f       	adc	r22, r18
    17c6:	73 9f       	mul	r23, r19
    17c8:	b0 0d       	add	r27, r0
    17ca:	a1 1d       	adc	r26, r1
    17cc:	62 1f       	adc	r22, r18
    17ce:	83 9f       	mul	r24, r19
    17d0:	a0 0d       	add	r26, r0
    17d2:	61 1d       	adc	r22, r1
    17d4:	22 1f       	adc	r18, r18
    17d6:	74 9f       	mul	r23, r20
    17d8:	33 27       	eor	r19, r19
    17da:	a0 0d       	add	r26, r0
    17dc:	61 1d       	adc	r22, r1
    17de:	23 1f       	adc	r18, r19
    17e0:	84 9f       	mul	r24, r20
    17e2:	60 0d       	add	r22, r0
    17e4:	21 1d       	adc	r18, r1
    17e6:	82 2f       	mov	r24, r18
    17e8:	76 2f       	mov	r23, r22
    17ea:	6a 2f       	mov	r22, r26
    17ec:	11 24       	eor	r1, r1
    17ee:	9f 57       	subi	r25, 0x7F	; 127
    17f0:	50 40       	sbci	r21, 0x00	; 0
    17f2:	9a f0       	brmi	.+38     	; 0x181a <__mulsf3_pse+0x88>
    17f4:	f1 f0       	breq	.+60     	; 0x1832 <__mulsf3_pse+0xa0>
    17f6:	88 23       	and	r24, r24
    17f8:	4a f0       	brmi	.+18     	; 0x180c <__mulsf3_pse+0x7a>
    17fa:	ee 0f       	add	r30, r30
    17fc:	ff 1f       	adc	r31, r31
    17fe:	bb 1f       	adc	r27, r27
    1800:	66 1f       	adc	r22, r22
    1802:	77 1f       	adc	r23, r23
    1804:	88 1f       	adc	r24, r24
    1806:	91 50       	subi	r25, 0x01	; 1
    1808:	50 40       	sbci	r21, 0x00	; 0
    180a:	a9 f7       	brne	.-22     	; 0x17f6 <__mulsf3_pse+0x64>
    180c:	9e 3f       	cpi	r25, 0xFE	; 254
    180e:	51 05       	cpc	r21, r1
    1810:	80 f0       	brcs	.+32     	; 0x1832 <__mulsf3_pse+0xa0>
    1812:	0c 94 c0 0a 	jmp	0x1580	; 0x1580 <__fp_inf>
    1816:	0c 94 32 0b 	jmp	0x1664	; 0x1664 <__fp_szero>
    181a:	5f 3f       	cpi	r21, 0xFF	; 255
    181c:	e4 f3       	brlt	.-8      	; 0x1816 <__mulsf3_pse+0x84>
    181e:	98 3e       	cpi	r25, 0xE8	; 232
    1820:	d4 f3       	brlt	.-12     	; 0x1816 <__mulsf3_pse+0x84>
    1822:	86 95       	lsr	r24
    1824:	77 95       	ror	r23
    1826:	67 95       	ror	r22
    1828:	b7 95       	ror	r27
    182a:	f7 95       	ror	r31
    182c:	e7 95       	ror	r30
    182e:	9f 5f       	subi	r25, 0xFF	; 255
    1830:	c1 f7       	brne	.-16     	; 0x1822 <__mulsf3_pse+0x90>
    1832:	fe 2b       	or	r31, r30
    1834:	88 0f       	add	r24, r24
    1836:	91 1d       	adc	r25, r1
    1838:	96 95       	lsr	r25
    183a:	87 95       	ror	r24
    183c:	97 f9       	bld	r25, 7
    183e:	08 95       	ret

00001840 <sin>:
    1840:	9f 93       	push	r25
    1842:	0e 94 38 0c 	call	0x1870	; 0x1870 <__fp_rempio2>
    1846:	0f 90       	pop	r0
    1848:	07 fc       	sbrc	r0, 7
    184a:	ee 5f       	subi	r30, 0xFE	; 254
    184c:	0c 94 61 0c 	jmp	0x18c2	; 0x18c2 <__fp_sinus>

00001850 <__fp_mpack>:
    1850:	9f 3f       	cpi	r25, 0xFF	; 255
    1852:	31 f0       	breq	.+12     	; 0x1860 <__fp_mpack_finite+0xc>

00001854 <__fp_mpack_finite>:
    1854:	91 50       	subi	r25, 0x01	; 1
    1856:	20 f4       	brcc	.+8      	; 0x1860 <__fp_mpack_finite+0xc>
    1858:	87 95       	ror	r24
    185a:	77 95       	ror	r23
    185c:	67 95       	ror	r22
    185e:	b7 95       	ror	r27
    1860:	88 0f       	add	r24, r24
    1862:	91 1d       	adc	r25, r1
    1864:	96 95       	lsr	r25
    1866:	87 95       	ror	r24
    1868:	97 f9       	bld	r25, 7
    186a:	08 95       	ret
    186c:	0c 94 c6 0a 	jmp	0x158c	; 0x158c <__fp_nan>

00001870 <__fp_rempio2>:
    1870:	0e 94 17 0b 	call	0x162e	; 0x162e <__fp_splitA>
    1874:	d8 f3       	brcs	.-10     	; 0x186c <__fp_mpack_finite+0x18>
    1876:	e8 94       	clt
    1878:	e0 e0       	ldi	r30, 0x00	; 0
    187a:	bb 27       	eor	r27, r27
    187c:	9f 57       	subi	r25, 0x7F	; 127
    187e:	f0 f0       	brcs	.+60     	; 0x18bc <__fp_rempio2+0x4c>
    1880:	2a ed       	ldi	r18, 0xDA	; 218
    1882:	3f e0       	ldi	r19, 0x0F	; 15
    1884:	49 ec       	ldi	r20, 0xC9	; 201
    1886:	06 c0       	rjmp	.+12     	; 0x1894 <__fp_rempio2+0x24>
    1888:	ee 0f       	add	r30, r30
    188a:	bb 0f       	add	r27, r27
    188c:	66 1f       	adc	r22, r22
    188e:	77 1f       	adc	r23, r23
    1890:	88 1f       	adc	r24, r24
    1892:	28 f0       	brcs	.+10     	; 0x189e <__fp_rempio2+0x2e>
    1894:	b2 3a       	cpi	r27, 0xA2	; 162
    1896:	62 07       	cpc	r22, r18
    1898:	73 07       	cpc	r23, r19
    189a:	84 07       	cpc	r24, r20
    189c:	28 f0       	brcs	.+10     	; 0x18a8 <__fp_rempio2+0x38>
    189e:	b2 5a       	subi	r27, 0xA2	; 162
    18a0:	62 0b       	sbc	r22, r18
    18a2:	73 0b       	sbc	r23, r19
    18a4:	84 0b       	sbc	r24, r20
    18a6:	e3 95       	inc	r30
    18a8:	9a 95       	dec	r25
    18aa:	72 f7       	brpl	.-36     	; 0x1888 <__fp_rempio2+0x18>
    18ac:	80 38       	cpi	r24, 0x80	; 128
    18ae:	30 f4       	brcc	.+12     	; 0x18bc <__fp_rempio2+0x4c>
    18b0:	9a 95       	dec	r25
    18b2:	bb 0f       	add	r27, r27
    18b4:	66 1f       	adc	r22, r22
    18b6:	77 1f       	adc	r23, r23
    18b8:	88 1f       	adc	r24, r24
    18ba:	d2 f7       	brpl	.-12     	; 0x18b0 <__fp_rempio2+0x40>
    18bc:	90 48       	sbci	r25, 0x80	; 128
    18be:	0c 94 2a 0c 	jmp	0x1854	; 0x1854 <__fp_mpack_finite>

000018c2 <__fp_sinus>:
    18c2:	ef 93       	push	r30
    18c4:	e0 ff       	sbrs	r30, 0
    18c6:	07 c0       	rjmp	.+14     	; 0x18d6 <__fp_sinus+0x14>
    18c8:	a2 ea       	ldi	r26, 0xA2	; 162
    18ca:	2a ed       	ldi	r18, 0xDA	; 218
    18cc:	3f e0       	ldi	r19, 0x0F	; 15
    18ce:	49 ec       	ldi	r20, 0xC9	; 201
    18d0:	5f eb       	ldi	r21, 0xBF	; 191
    18d2:	0e 94 0b 09 	call	0x1216	; 0x1216 <__addsf3x>
    18d6:	0e 94 fe 0a 	call	0x15fc	; 0x15fc <__fp_round>
    18da:	0f 90       	pop	r0
    18dc:	03 94       	inc	r0
    18de:	01 fc       	sbrc	r0, 1
    18e0:	90 58       	subi	r25, 0x80	; 128
    18e2:	e4 ea       	ldi	r30, 0xA4	; 164
    18e4:	f0 e0       	ldi	r31, 0x00	; 0
    18e6:	0c 94 75 0c 	jmp	0x18ea	; 0x18ea <__fp_powsodd>

000018ea <__fp_powsodd>:
    18ea:	9f 93       	push	r25
    18ec:	8f 93       	push	r24
    18ee:	7f 93       	push	r23
    18f0:	6f 93       	push	r22
    18f2:	ff 93       	push	r31
    18f4:	ef 93       	push	r30
    18f6:	9b 01       	movw	r18, r22
    18f8:	ac 01       	movw	r20, r24
    18fa:	0e 94 b3 0b 	call	0x1766	; 0x1766 <__mulsf3>
    18fe:	ef 91       	pop	r30
    1900:	ff 91       	pop	r31
    1902:	0e 94 c9 0a 	call	0x1592	; 0x1592 <__fp_powser>
    1906:	2f 91       	pop	r18
    1908:	3f 91       	pop	r19
    190a:	4f 91       	pop	r20
    190c:	5f 91       	pop	r21
    190e:	0c 94 b3 0b 	jmp	0x1766	; 0x1766 <__mulsf3>

00001912 <__udivmodsi4>:
    1912:	a1 e2       	ldi	r26, 0x21	; 33
    1914:	1a 2e       	mov	r1, r26
    1916:	aa 1b       	sub	r26, r26
    1918:	bb 1b       	sub	r27, r27
    191a:	fd 01       	movw	r30, r26
    191c:	0d c0       	rjmp	.+26     	; 0x1938 <__udivmodsi4_ep>

0000191e <__udivmodsi4_loop>:
    191e:	aa 1f       	adc	r26, r26
    1920:	bb 1f       	adc	r27, r27
    1922:	ee 1f       	adc	r30, r30
    1924:	ff 1f       	adc	r31, r31
    1926:	a2 17       	cp	r26, r18
    1928:	b3 07       	cpc	r27, r19
    192a:	e4 07       	cpc	r30, r20
    192c:	f5 07       	cpc	r31, r21
    192e:	20 f0       	brcs	.+8      	; 0x1938 <__udivmodsi4_ep>
    1930:	a2 1b       	sub	r26, r18
    1932:	b3 0b       	sbc	r27, r19
    1934:	e4 0b       	sbc	r30, r20
    1936:	f5 0b       	sbc	r31, r21

00001938 <__udivmodsi4_ep>:
    1938:	66 1f       	adc	r22, r22
    193a:	77 1f       	adc	r23, r23
    193c:	88 1f       	adc	r24, r24
    193e:	99 1f       	adc	r25, r25
    1940:	1a 94       	dec	r1
    1942:	69 f7       	brne	.-38     	; 0x191e <__udivmodsi4_loop>
    1944:	60 95       	com	r22
    1946:	70 95       	com	r23
    1948:	80 95       	com	r24
    194a:	90 95       	com	r25
    194c:	9b 01       	movw	r18, r22
    194e:	ac 01       	movw	r20, r24
    1950:	bd 01       	movw	r22, r26
    1952:	cf 01       	movw	r24, r30
    1954:	08 95       	ret

00001956 <dtostrf>:
    1956:	ef 92       	push	r14
    1958:	0f 93       	push	r16
    195a:	1f 93       	push	r17
    195c:	cf 93       	push	r28
    195e:	df 93       	push	r29
    1960:	e8 01       	movw	r28, r16
    1962:	47 fd       	sbrc	r20, 7
    1964:	02 c0       	rjmp	.+4      	; 0x196a <dtostrf+0x14>
    1966:	34 e0       	ldi	r19, 0x04	; 4
    1968:	01 c0       	rjmp	.+2      	; 0x196c <dtostrf+0x16>
    196a:	34 e1       	ldi	r19, 0x14	; 20
    196c:	04 2e       	mov	r0, r20
    196e:	00 0c       	add	r0, r0
    1970:	55 0b       	sbc	r21, r21
    1972:	57 ff       	sbrs	r21, 7
    1974:	03 c0       	rjmp	.+6      	; 0x197c <dtostrf+0x26>
    1976:	51 95       	neg	r21
    1978:	41 95       	neg	r20
    197a:	51 09       	sbc	r21, r1
    197c:	e3 2e       	mov	r14, r19
    197e:	02 2f       	mov	r16, r18
    1980:	24 2f       	mov	r18, r20
    1982:	ae 01       	movw	r20, r28
    1984:	0e 94 f2 0e 	call	0x1de4	; 0x1de4 <dtoa_prf>
    1988:	ce 01       	movw	r24, r28
    198a:	df 91       	pop	r29
    198c:	cf 91       	pop	r28
    198e:	1f 91       	pop	r17
    1990:	0f 91       	pop	r16
    1992:	ef 90       	pop	r14
    1994:	08 95       	ret

00001996 <printf>:
    1996:	a0 e0       	ldi	r26, 0x00	; 0
    1998:	b0 e0       	ldi	r27, 0x00	; 0
    199a:	e1 ed       	ldi	r30, 0xD1	; 209
    199c:	fc e0       	ldi	r31, 0x0C	; 12
    199e:	0c 94 e4 11 	jmp	0x23c8	; 0x23c8 <__prologue_saves__+0x20>
    19a2:	ae 01       	movw	r20, r28
    19a4:	4b 5f       	subi	r20, 0xFB	; 251
    19a6:	5f 4f       	sbci	r21, 0xFF	; 255
    19a8:	fa 01       	movw	r30, r20
    19aa:	61 91       	ld	r22, Z+
    19ac:	71 91       	ld	r23, Z+
    19ae:	af 01       	movw	r20, r30
    19b0:	80 91 68 38 	lds	r24, 0x3868	; 0x803868 <__iob+0x2>
    19b4:	90 91 69 38 	lds	r25, 0x3869	; 0x803869 <__iob+0x3>
    19b8:	0e 94 11 0d 	call	0x1a22	; 0x1a22 <vfprintf>
    19bc:	e2 e0       	ldi	r30, 0x02	; 2
    19be:	0c 94 fd 11 	jmp	0x23fa	; 0x23fa <__epilogue_restores__+0x20>

000019c2 <puts>:
    19c2:	0f 93       	push	r16
    19c4:	1f 93       	push	r17
    19c6:	cf 93       	push	r28
    19c8:	df 93       	push	r29
    19ca:	e0 91 68 38 	lds	r30, 0x3868	; 0x803868 <__iob+0x2>
    19ce:	f0 91 69 38 	lds	r31, 0x3869	; 0x803869 <__iob+0x3>
    19d2:	23 81       	ldd	r18, Z+3	; 0x03
    19d4:	21 ff       	sbrs	r18, 1
    19d6:	1b c0       	rjmp	.+54     	; 0x1a0e <puts+0x4c>
    19d8:	8c 01       	movw	r16, r24
    19da:	d0 e0       	ldi	r29, 0x00	; 0
    19dc:	c0 e0       	ldi	r28, 0x00	; 0
    19de:	f8 01       	movw	r30, r16
    19e0:	81 91       	ld	r24, Z+
    19e2:	8f 01       	movw	r16, r30
    19e4:	60 91 68 38 	lds	r22, 0x3868	; 0x803868 <__iob+0x2>
    19e8:	70 91 69 38 	lds	r23, 0x3869	; 0x803869 <__iob+0x3>
    19ec:	db 01       	movw	r26, r22
    19ee:	18 96       	adiw	r26, 0x08	; 8
    19f0:	ed 91       	ld	r30, X+
    19f2:	fc 91       	ld	r31, X
    19f4:	19 97       	sbiw	r26, 0x09	; 9
    19f6:	88 23       	and	r24, r24
    19f8:	31 f0       	breq	.+12     	; 0x1a06 <puts+0x44>
    19fa:	09 95       	icall
    19fc:	89 2b       	or	r24, r25
    19fe:	79 f3       	breq	.-34     	; 0x19de <puts+0x1c>
    1a00:	df ef       	ldi	r29, 0xFF	; 255
    1a02:	cf ef       	ldi	r28, 0xFF	; 255
    1a04:	ec cf       	rjmp	.-40     	; 0x19de <puts+0x1c>
    1a06:	8a e0       	ldi	r24, 0x0A	; 10
    1a08:	09 95       	icall
    1a0a:	89 2b       	or	r24, r25
    1a0c:	19 f0       	breq	.+6      	; 0x1a14 <puts+0x52>
    1a0e:	8f ef       	ldi	r24, 0xFF	; 255
    1a10:	9f ef       	ldi	r25, 0xFF	; 255
    1a12:	02 c0       	rjmp	.+4      	; 0x1a18 <puts+0x56>
    1a14:	8d 2f       	mov	r24, r29
    1a16:	9c 2f       	mov	r25, r28
    1a18:	df 91       	pop	r29
    1a1a:	cf 91       	pop	r28
    1a1c:	1f 91       	pop	r17
    1a1e:	0f 91       	pop	r16
    1a20:	08 95       	ret

00001a22 <vfprintf>:
    1a22:	ab e0       	ldi	r26, 0x0B	; 11
    1a24:	b0 e0       	ldi	r27, 0x00	; 0
    1a26:	e7 e1       	ldi	r30, 0x17	; 23
    1a28:	fd e0       	ldi	r31, 0x0D	; 13
    1a2a:	0c 94 d4 11 	jmp	0x23a8	; 0x23a8 <__prologue_saves__>
    1a2e:	6c 01       	movw	r12, r24
    1a30:	7b 01       	movw	r14, r22
    1a32:	8a 01       	movw	r16, r20
    1a34:	fc 01       	movw	r30, r24
    1a36:	16 82       	std	Z+6, r1	; 0x06
    1a38:	17 82       	std	Z+7, r1	; 0x07
    1a3a:	83 81       	ldd	r24, Z+3	; 0x03
    1a3c:	81 ff       	sbrs	r24, 1
    1a3e:	cc c1       	rjmp	.+920    	; 0x1dd8 <vfprintf+0x3b6>
    1a40:	ce 01       	movw	r24, r28
    1a42:	01 96       	adiw	r24, 0x01	; 1
    1a44:	3c 01       	movw	r6, r24
    1a46:	f6 01       	movw	r30, r12
    1a48:	93 81       	ldd	r25, Z+3	; 0x03
    1a4a:	f7 01       	movw	r30, r14
    1a4c:	93 fd       	sbrc	r25, 3
    1a4e:	85 91       	lpm	r24, Z+
    1a50:	93 ff       	sbrs	r25, 3
    1a52:	81 91       	ld	r24, Z+
    1a54:	7f 01       	movw	r14, r30
    1a56:	88 23       	and	r24, r24
    1a58:	09 f4       	brne	.+2      	; 0x1a5c <vfprintf+0x3a>
    1a5a:	ba c1       	rjmp	.+884    	; 0x1dd0 <vfprintf+0x3ae>
    1a5c:	85 32       	cpi	r24, 0x25	; 37
    1a5e:	39 f4       	brne	.+14     	; 0x1a6e <vfprintf+0x4c>
    1a60:	93 fd       	sbrc	r25, 3
    1a62:	85 91       	lpm	r24, Z+
    1a64:	93 ff       	sbrs	r25, 3
    1a66:	81 91       	ld	r24, Z+
    1a68:	7f 01       	movw	r14, r30
    1a6a:	85 32       	cpi	r24, 0x25	; 37
    1a6c:	29 f4       	brne	.+10     	; 0x1a78 <vfprintf+0x56>
    1a6e:	b6 01       	movw	r22, r12
    1a70:	90 e0       	ldi	r25, 0x00	; 0
    1a72:	0e 94 3a 11 	call	0x2274	; 0x2274 <fputc>
    1a76:	e7 cf       	rjmp	.-50     	; 0x1a46 <vfprintf+0x24>
    1a78:	91 2c       	mov	r9, r1
    1a7a:	21 2c       	mov	r2, r1
    1a7c:	31 2c       	mov	r3, r1
    1a7e:	ff e1       	ldi	r31, 0x1F	; 31
    1a80:	f3 15       	cp	r31, r3
    1a82:	d8 f0       	brcs	.+54     	; 0x1aba <vfprintf+0x98>
    1a84:	8b 32       	cpi	r24, 0x2B	; 43
    1a86:	79 f0       	breq	.+30     	; 0x1aa6 <vfprintf+0x84>
    1a88:	38 f4       	brcc	.+14     	; 0x1a98 <vfprintf+0x76>
    1a8a:	80 32       	cpi	r24, 0x20	; 32
    1a8c:	79 f0       	breq	.+30     	; 0x1aac <vfprintf+0x8a>
    1a8e:	83 32       	cpi	r24, 0x23	; 35
    1a90:	a1 f4       	brne	.+40     	; 0x1aba <vfprintf+0x98>
    1a92:	23 2d       	mov	r18, r3
    1a94:	20 61       	ori	r18, 0x10	; 16
    1a96:	1d c0       	rjmp	.+58     	; 0x1ad2 <vfprintf+0xb0>
    1a98:	8d 32       	cpi	r24, 0x2D	; 45
    1a9a:	61 f0       	breq	.+24     	; 0x1ab4 <vfprintf+0x92>
    1a9c:	80 33       	cpi	r24, 0x30	; 48
    1a9e:	69 f4       	brne	.+26     	; 0x1aba <vfprintf+0x98>
    1aa0:	23 2d       	mov	r18, r3
    1aa2:	21 60       	ori	r18, 0x01	; 1
    1aa4:	16 c0       	rjmp	.+44     	; 0x1ad2 <vfprintf+0xb0>
    1aa6:	83 2d       	mov	r24, r3
    1aa8:	82 60       	ori	r24, 0x02	; 2
    1aaa:	38 2e       	mov	r3, r24
    1aac:	e3 2d       	mov	r30, r3
    1aae:	e4 60       	ori	r30, 0x04	; 4
    1ab0:	3e 2e       	mov	r3, r30
    1ab2:	2a c0       	rjmp	.+84     	; 0x1b08 <vfprintf+0xe6>
    1ab4:	f3 2d       	mov	r31, r3
    1ab6:	f8 60       	ori	r31, 0x08	; 8
    1ab8:	1d c0       	rjmp	.+58     	; 0x1af4 <vfprintf+0xd2>
    1aba:	37 fc       	sbrc	r3, 7
    1abc:	2d c0       	rjmp	.+90     	; 0x1b18 <vfprintf+0xf6>
    1abe:	20 ed       	ldi	r18, 0xD0	; 208
    1ac0:	28 0f       	add	r18, r24
    1ac2:	2a 30       	cpi	r18, 0x0A	; 10
    1ac4:	40 f0       	brcs	.+16     	; 0x1ad6 <vfprintf+0xb4>
    1ac6:	8e 32       	cpi	r24, 0x2E	; 46
    1ac8:	b9 f4       	brne	.+46     	; 0x1af8 <vfprintf+0xd6>
    1aca:	36 fc       	sbrc	r3, 6
    1acc:	81 c1       	rjmp	.+770    	; 0x1dd0 <vfprintf+0x3ae>
    1ace:	23 2d       	mov	r18, r3
    1ad0:	20 64       	ori	r18, 0x40	; 64
    1ad2:	32 2e       	mov	r3, r18
    1ad4:	19 c0       	rjmp	.+50     	; 0x1b08 <vfprintf+0xe6>
    1ad6:	36 fe       	sbrs	r3, 6
    1ad8:	06 c0       	rjmp	.+12     	; 0x1ae6 <vfprintf+0xc4>
    1ada:	8a e0       	ldi	r24, 0x0A	; 10
    1adc:	98 9e       	mul	r9, r24
    1ade:	20 0d       	add	r18, r0
    1ae0:	11 24       	eor	r1, r1
    1ae2:	92 2e       	mov	r9, r18
    1ae4:	11 c0       	rjmp	.+34     	; 0x1b08 <vfprintf+0xe6>
    1ae6:	ea e0       	ldi	r30, 0x0A	; 10
    1ae8:	2e 9e       	mul	r2, r30
    1aea:	20 0d       	add	r18, r0
    1aec:	11 24       	eor	r1, r1
    1aee:	22 2e       	mov	r2, r18
    1af0:	f3 2d       	mov	r31, r3
    1af2:	f0 62       	ori	r31, 0x20	; 32
    1af4:	3f 2e       	mov	r3, r31
    1af6:	08 c0       	rjmp	.+16     	; 0x1b08 <vfprintf+0xe6>
    1af8:	8c 36       	cpi	r24, 0x6C	; 108
    1afa:	21 f4       	brne	.+8      	; 0x1b04 <vfprintf+0xe2>
    1afc:	83 2d       	mov	r24, r3
    1afe:	80 68       	ori	r24, 0x80	; 128
    1b00:	38 2e       	mov	r3, r24
    1b02:	02 c0       	rjmp	.+4      	; 0x1b08 <vfprintf+0xe6>
    1b04:	88 36       	cpi	r24, 0x68	; 104
    1b06:	41 f4       	brne	.+16     	; 0x1b18 <vfprintf+0xf6>
    1b08:	f7 01       	movw	r30, r14
    1b0a:	93 fd       	sbrc	r25, 3
    1b0c:	85 91       	lpm	r24, Z+
    1b0e:	93 ff       	sbrs	r25, 3
    1b10:	81 91       	ld	r24, Z+
    1b12:	7f 01       	movw	r14, r30
    1b14:	81 11       	cpse	r24, r1
    1b16:	b3 cf       	rjmp	.-154    	; 0x1a7e <vfprintf+0x5c>
    1b18:	98 2f       	mov	r25, r24
    1b1a:	9f 7d       	andi	r25, 0xDF	; 223
    1b1c:	95 54       	subi	r25, 0x45	; 69
    1b1e:	93 30       	cpi	r25, 0x03	; 3
    1b20:	28 f4       	brcc	.+10     	; 0x1b2c <vfprintf+0x10a>
    1b22:	0c 5f       	subi	r16, 0xFC	; 252
    1b24:	1f 4f       	sbci	r17, 0xFF	; 255
    1b26:	9f e3       	ldi	r25, 0x3F	; 63
    1b28:	99 83       	std	Y+1, r25	; 0x01
    1b2a:	0d c0       	rjmp	.+26     	; 0x1b46 <vfprintf+0x124>
    1b2c:	83 36       	cpi	r24, 0x63	; 99
    1b2e:	31 f0       	breq	.+12     	; 0x1b3c <vfprintf+0x11a>
    1b30:	83 37       	cpi	r24, 0x73	; 115
    1b32:	71 f0       	breq	.+28     	; 0x1b50 <vfprintf+0x12e>
    1b34:	83 35       	cpi	r24, 0x53	; 83
    1b36:	09 f0       	breq	.+2      	; 0x1b3a <vfprintf+0x118>
    1b38:	59 c0       	rjmp	.+178    	; 0x1bec <vfprintf+0x1ca>
    1b3a:	21 c0       	rjmp	.+66     	; 0x1b7e <vfprintf+0x15c>
    1b3c:	f8 01       	movw	r30, r16
    1b3e:	80 81       	ld	r24, Z
    1b40:	89 83       	std	Y+1, r24	; 0x01
    1b42:	0e 5f       	subi	r16, 0xFE	; 254
    1b44:	1f 4f       	sbci	r17, 0xFF	; 255
    1b46:	88 24       	eor	r8, r8
    1b48:	83 94       	inc	r8
    1b4a:	91 2c       	mov	r9, r1
    1b4c:	53 01       	movw	r10, r6
    1b4e:	13 c0       	rjmp	.+38     	; 0x1b76 <vfprintf+0x154>
    1b50:	28 01       	movw	r4, r16
    1b52:	f2 e0       	ldi	r31, 0x02	; 2
    1b54:	4f 0e       	add	r4, r31
    1b56:	51 1c       	adc	r5, r1
    1b58:	f8 01       	movw	r30, r16
    1b5a:	a0 80       	ld	r10, Z
    1b5c:	b1 80       	ldd	r11, Z+1	; 0x01
    1b5e:	36 fe       	sbrs	r3, 6
    1b60:	03 c0       	rjmp	.+6      	; 0x1b68 <vfprintf+0x146>
    1b62:	69 2d       	mov	r22, r9
    1b64:	70 e0       	ldi	r23, 0x00	; 0
    1b66:	02 c0       	rjmp	.+4      	; 0x1b6c <vfprintf+0x14a>
    1b68:	6f ef       	ldi	r22, 0xFF	; 255
    1b6a:	7f ef       	ldi	r23, 0xFF	; 255
    1b6c:	c5 01       	movw	r24, r10
    1b6e:	0e 94 2f 11 	call	0x225e	; 0x225e <strnlen>
    1b72:	4c 01       	movw	r8, r24
    1b74:	82 01       	movw	r16, r4
    1b76:	f3 2d       	mov	r31, r3
    1b78:	ff 77       	andi	r31, 0x7F	; 127
    1b7a:	3f 2e       	mov	r3, r31
    1b7c:	16 c0       	rjmp	.+44     	; 0x1baa <vfprintf+0x188>
    1b7e:	28 01       	movw	r4, r16
    1b80:	22 e0       	ldi	r18, 0x02	; 2
    1b82:	42 0e       	add	r4, r18
    1b84:	51 1c       	adc	r5, r1
    1b86:	f8 01       	movw	r30, r16
    1b88:	a0 80       	ld	r10, Z
    1b8a:	b1 80       	ldd	r11, Z+1	; 0x01
    1b8c:	36 fe       	sbrs	r3, 6
    1b8e:	03 c0       	rjmp	.+6      	; 0x1b96 <vfprintf+0x174>
    1b90:	69 2d       	mov	r22, r9
    1b92:	70 e0       	ldi	r23, 0x00	; 0
    1b94:	02 c0       	rjmp	.+4      	; 0x1b9a <vfprintf+0x178>
    1b96:	6f ef       	ldi	r22, 0xFF	; 255
    1b98:	7f ef       	ldi	r23, 0xFF	; 255
    1b9a:	c5 01       	movw	r24, r10
    1b9c:	0e 94 24 11 	call	0x2248	; 0x2248 <strnlen_P>
    1ba0:	4c 01       	movw	r8, r24
    1ba2:	f3 2d       	mov	r31, r3
    1ba4:	f0 68       	ori	r31, 0x80	; 128
    1ba6:	3f 2e       	mov	r3, r31
    1ba8:	82 01       	movw	r16, r4
    1baa:	33 fc       	sbrc	r3, 3
    1bac:	1b c0       	rjmp	.+54     	; 0x1be4 <vfprintf+0x1c2>
    1bae:	82 2d       	mov	r24, r2
    1bb0:	90 e0       	ldi	r25, 0x00	; 0
    1bb2:	88 16       	cp	r8, r24
    1bb4:	99 06       	cpc	r9, r25
    1bb6:	b0 f4       	brcc	.+44     	; 0x1be4 <vfprintf+0x1c2>
    1bb8:	b6 01       	movw	r22, r12
    1bba:	80 e2       	ldi	r24, 0x20	; 32
    1bbc:	90 e0       	ldi	r25, 0x00	; 0
    1bbe:	0e 94 3a 11 	call	0x2274	; 0x2274 <fputc>
    1bc2:	2a 94       	dec	r2
    1bc4:	f4 cf       	rjmp	.-24     	; 0x1bae <vfprintf+0x18c>
    1bc6:	f5 01       	movw	r30, r10
    1bc8:	37 fc       	sbrc	r3, 7
    1bca:	85 91       	lpm	r24, Z+
    1bcc:	37 fe       	sbrs	r3, 7
    1bce:	81 91       	ld	r24, Z+
    1bd0:	5f 01       	movw	r10, r30
    1bd2:	b6 01       	movw	r22, r12
    1bd4:	90 e0       	ldi	r25, 0x00	; 0
    1bd6:	0e 94 3a 11 	call	0x2274	; 0x2274 <fputc>
    1bda:	21 10       	cpse	r2, r1
    1bdc:	2a 94       	dec	r2
    1bde:	21 e0       	ldi	r18, 0x01	; 1
    1be0:	82 1a       	sub	r8, r18
    1be2:	91 08       	sbc	r9, r1
    1be4:	81 14       	cp	r8, r1
    1be6:	91 04       	cpc	r9, r1
    1be8:	71 f7       	brne	.-36     	; 0x1bc6 <vfprintf+0x1a4>
    1bea:	e8 c0       	rjmp	.+464    	; 0x1dbc <vfprintf+0x39a>
    1bec:	84 36       	cpi	r24, 0x64	; 100
    1bee:	11 f0       	breq	.+4      	; 0x1bf4 <vfprintf+0x1d2>
    1bf0:	89 36       	cpi	r24, 0x69	; 105
    1bf2:	41 f5       	brne	.+80     	; 0x1c44 <vfprintf+0x222>
    1bf4:	f8 01       	movw	r30, r16
    1bf6:	37 fe       	sbrs	r3, 7
    1bf8:	07 c0       	rjmp	.+14     	; 0x1c08 <vfprintf+0x1e6>
    1bfa:	60 81       	ld	r22, Z
    1bfc:	71 81       	ldd	r23, Z+1	; 0x01
    1bfe:	82 81       	ldd	r24, Z+2	; 0x02
    1c00:	93 81       	ldd	r25, Z+3	; 0x03
    1c02:	0c 5f       	subi	r16, 0xFC	; 252
    1c04:	1f 4f       	sbci	r17, 0xFF	; 255
    1c06:	08 c0       	rjmp	.+16     	; 0x1c18 <vfprintf+0x1f6>
    1c08:	60 81       	ld	r22, Z
    1c0a:	71 81       	ldd	r23, Z+1	; 0x01
    1c0c:	07 2e       	mov	r0, r23
    1c0e:	00 0c       	add	r0, r0
    1c10:	88 0b       	sbc	r24, r24
    1c12:	99 0b       	sbc	r25, r25
    1c14:	0e 5f       	subi	r16, 0xFE	; 254
    1c16:	1f 4f       	sbci	r17, 0xFF	; 255
    1c18:	f3 2d       	mov	r31, r3
    1c1a:	ff 76       	andi	r31, 0x6F	; 111
    1c1c:	3f 2e       	mov	r3, r31
    1c1e:	97 ff       	sbrs	r25, 7
    1c20:	09 c0       	rjmp	.+18     	; 0x1c34 <vfprintf+0x212>
    1c22:	90 95       	com	r25
    1c24:	80 95       	com	r24
    1c26:	70 95       	com	r23
    1c28:	61 95       	neg	r22
    1c2a:	7f 4f       	sbci	r23, 0xFF	; 255
    1c2c:	8f 4f       	sbci	r24, 0xFF	; 255
    1c2e:	9f 4f       	sbci	r25, 0xFF	; 255
    1c30:	f0 68       	ori	r31, 0x80	; 128
    1c32:	3f 2e       	mov	r3, r31
    1c34:	2a e0       	ldi	r18, 0x0A	; 10
    1c36:	30 e0       	ldi	r19, 0x00	; 0
    1c38:	a3 01       	movw	r20, r6
    1c3a:	0e 94 76 11 	call	0x22ec	; 0x22ec <__ultoa_invert>
    1c3e:	88 2e       	mov	r8, r24
    1c40:	86 18       	sub	r8, r6
    1c42:	45 c0       	rjmp	.+138    	; 0x1cce <vfprintf+0x2ac>
    1c44:	85 37       	cpi	r24, 0x75	; 117
    1c46:	31 f4       	brne	.+12     	; 0x1c54 <vfprintf+0x232>
    1c48:	23 2d       	mov	r18, r3
    1c4a:	2f 7e       	andi	r18, 0xEF	; 239
    1c4c:	b2 2e       	mov	r11, r18
    1c4e:	2a e0       	ldi	r18, 0x0A	; 10
    1c50:	30 e0       	ldi	r19, 0x00	; 0
    1c52:	25 c0       	rjmp	.+74     	; 0x1c9e <vfprintf+0x27c>
    1c54:	93 2d       	mov	r25, r3
    1c56:	99 7f       	andi	r25, 0xF9	; 249
    1c58:	b9 2e       	mov	r11, r25
    1c5a:	8f 36       	cpi	r24, 0x6F	; 111
    1c5c:	c1 f0       	breq	.+48     	; 0x1c8e <vfprintf+0x26c>
    1c5e:	18 f4       	brcc	.+6      	; 0x1c66 <vfprintf+0x244>
    1c60:	88 35       	cpi	r24, 0x58	; 88
    1c62:	79 f0       	breq	.+30     	; 0x1c82 <vfprintf+0x260>
    1c64:	b5 c0       	rjmp	.+362    	; 0x1dd0 <vfprintf+0x3ae>
    1c66:	80 37       	cpi	r24, 0x70	; 112
    1c68:	19 f0       	breq	.+6      	; 0x1c70 <vfprintf+0x24e>
    1c6a:	88 37       	cpi	r24, 0x78	; 120
    1c6c:	21 f0       	breq	.+8      	; 0x1c76 <vfprintf+0x254>
    1c6e:	b0 c0       	rjmp	.+352    	; 0x1dd0 <vfprintf+0x3ae>
    1c70:	e9 2f       	mov	r30, r25
    1c72:	e0 61       	ori	r30, 0x10	; 16
    1c74:	be 2e       	mov	r11, r30
    1c76:	b4 fe       	sbrs	r11, 4
    1c78:	0d c0       	rjmp	.+26     	; 0x1c94 <vfprintf+0x272>
    1c7a:	fb 2d       	mov	r31, r11
    1c7c:	f4 60       	ori	r31, 0x04	; 4
    1c7e:	bf 2e       	mov	r11, r31
    1c80:	09 c0       	rjmp	.+18     	; 0x1c94 <vfprintf+0x272>
    1c82:	34 fe       	sbrs	r3, 4
    1c84:	0a c0       	rjmp	.+20     	; 0x1c9a <vfprintf+0x278>
    1c86:	29 2f       	mov	r18, r25
    1c88:	26 60       	ori	r18, 0x06	; 6
    1c8a:	b2 2e       	mov	r11, r18
    1c8c:	06 c0       	rjmp	.+12     	; 0x1c9a <vfprintf+0x278>
    1c8e:	28 e0       	ldi	r18, 0x08	; 8
    1c90:	30 e0       	ldi	r19, 0x00	; 0
    1c92:	05 c0       	rjmp	.+10     	; 0x1c9e <vfprintf+0x27c>
    1c94:	20 e1       	ldi	r18, 0x10	; 16
    1c96:	30 e0       	ldi	r19, 0x00	; 0
    1c98:	02 c0       	rjmp	.+4      	; 0x1c9e <vfprintf+0x27c>
    1c9a:	20 e1       	ldi	r18, 0x10	; 16
    1c9c:	32 e0       	ldi	r19, 0x02	; 2
    1c9e:	f8 01       	movw	r30, r16
    1ca0:	b7 fe       	sbrs	r11, 7
    1ca2:	07 c0       	rjmp	.+14     	; 0x1cb2 <vfprintf+0x290>
    1ca4:	60 81       	ld	r22, Z
    1ca6:	71 81       	ldd	r23, Z+1	; 0x01
    1ca8:	82 81       	ldd	r24, Z+2	; 0x02
    1caa:	93 81       	ldd	r25, Z+3	; 0x03
    1cac:	0c 5f       	subi	r16, 0xFC	; 252
    1cae:	1f 4f       	sbci	r17, 0xFF	; 255
    1cb0:	06 c0       	rjmp	.+12     	; 0x1cbe <vfprintf+0x29c>
    1cb2:	60 81       	ld	r22, Z
    1cb4:	71 81       	ldd	r23, Z+1	; 0x01
    1cb6:	80 e0       	ldi	r24, 0x00	; 0
    1cb8:	90 e0       	ldi	r25, 0x00	; 0
    1cba:	0e 5f       	subi	r16, 0xFE	; 254
    1cbc:	1f 4f       	sbci	r17, 0xFF	; 255
    1cbe:	a3 01       	movw	r20, r6
    1cc0:	0e 94 76 11 	call	0x22ec	; 0x22ec <__ultoa_invert>
    1cc4:	88 2e       	mov	r8, r24
    1cc6:	86 18       	sub	r8, r6
    1cc8:	fb 2d       	mov	r31, r11
    1cca:	ff 77       	andi	r31, 0x7F	; 127
    1ccc:	3f 2e       	mov	r3, r31
    1cce:	36 fe       	sbrs	r3, 6
    1cd0:	0d c0       	rjmp	.+26     	; 0x1cec <vfprintf+0x2ca>
    1cd2:	23 2d       	mov	r18, r3
    1cd4:	2e 7f       	andi	r18, 0xFE	; 254
    1cd6:	a2 2e       	mov	r10, r18
    1cd8:	89 14       	cp	r8, r9
    1cda:	58 f4       	brcc	.+22     	; 0x1cf2 <vfprintf+0x2d0>
    1cdc:	34 fe       	sbrs	r3, 4
    1cde:	0b c0       	rjmp	.+22     	; 0x1cf6 <vfprintf+0x2d4>
    1ce0:	32 fc       	sbrc	r3, 2
    1ce2:	09 c0       	rjmp	.+18     	; 0x1cf6 <vfprintf+0x2d4>
    1ce4:	83 2d       	mov	r24, r3
    1ce6:	8e 7e       	andi	r24, 0xEE	; 238
    1ce8:	a8 2e       	mov	r10, r24
    1cea:	05 c0       	rjmp	.+10     	; 0x1cf6 <vfprintf+0x2d4>
    1cec:	b8 2c       	mov	r11, r8
    1cee:	a3 2c       	mov	r10, r3
    1cf0:	03 c0       	rjmp	.+6      	; 0x1cf8 <vfprintf+0x2d6>
    1cf2:	b8 2c       	mov	r11, r8
    1cf4:	01 c0       	rjmp	.+2      	; 0x1cf8 <vfprintf+0x2d6>
    1cf6:	b9 2c       	mov	r11, r9
    1cf8:	a4 fe       	sbrs	r10, 4
    1cfa:	0f c0       	rjmp	.+30     	; 0x1d1a <vfprintf+0x2f8>
    1cfc:	fe 01       	movw	r30, r28
    1cfe:	e8 0d       	add	r30, r8
    1d00:	f1 1d       	adc	r31, r1
    1d02:	80 81       	ld	r24, Z
    1d04:	80 33       	cpi	r24, 0x30	; 48
    1d06:	21 f4       	brne	.+8      	; 0x1d10 <vfprintf+0x2ee>
    1d08:	9a 2d       	mov	r25, r10
    1d0a:	99 7e       	andi	r25, 0xE9	; 233
    1d0c:	a9 2e       	mov	r10, r25
    1d0e:	09 c0       	rjmp	.+18     	; 0x1d22 <vfprintf+0x300>
    1d10:	a2 fe       	sbrs	r10, 2
    1d12:	06 c0       	rjmp	.+12     	; 0x1d20 <vfprintf+0x2fe>
    1d14:	b3 94       	inc	r11
    1d16:	b3 94       	inc	r11
    1d18:	04 c0       	rjmp	.+8      	; 0x1d22 <vfprintf+0x300>
    1d1a:	8a 2d       	mov	r24, r10
    1d1c:	86 78       	andi	r24, 0x86	; 134
    1d1e:	09 f0       	breq	.+2      	; 0x1d22 <vfprintf+0x300>
    1d20:	b3 94       	inc	r11
    1d22:	a3 fc       	sbrc	r10, 3
    1d24:	11 c0       	rjmp	.+34     	; 0x1d48 <vfprintf+0x326>
    1d26:	a0 fe       	sbrs	r10, 0
    1d28:	06 c0       	rjmp	.+12     	; 0x1d36 <vfprintf+0x314>
    1d2a:	b2 14       	cp	r11, r2
    1d2c:	88 f4       	brcc	.+34     	; 0x1d50 <vfprintf+0x32e>
    1d2e:	28 0c       	add	r2, r8
    1d30:	92 2c       	mov	r9, r2
    1d32:	9b 18       	sub	r9, r11
    1d34:	0e c0       	rjmp	.+28     	; 0x1d52 <vfprintf+0x330>
    1d36:	b2 14       	cp	r11, r2
    1d38:	60 f4       	brcc	.+24     	; 0x1d52 <vfprintf+0x330>
    1d3a:	b6 01       	movw	r22, r12
    1d3c:	80 e2       	ldi	r24, 0x20	; 32
    1d3e:	90 e0       	ldi	r25, 0x00	; 0
    1d40:	0e 94 3a 11 	call	0x2274	; 0x2274 <fputc>
    1d44:	b3 94       	inc	r11
    1d46:	f7 cf       	rjmp	.-18     	; 0x1d36 <vfprintf+0x314>
    1d48:	b2 14       	cp	r11, r2
    1d4a:	18 f4       	brcc	.+6      	; 0x1d52 <vfprintf+0x330>
    1d4c:	2b 18       	sub	r2, r11
    1d4e:	02 c0       	rjmp	.+4      	; 0x1d54 <vfprintf+0x332>
    1d50:	98 2c       	mov	r9, r8
    1d52:	21 2c       	mov	r2, r1
    1d54:	a4 fe       	sbrs	r10, 4
    1d56:	10 c0       	rjmp	.+32     	; 0x1d78 <vfprintf+0x356>
    1d58:	b6 01       	movw	r22, r12
    1d5a:	80 e3       	ldi	r24, 0x30	; 48
    1d5c:	90 e0       	ldi	r25, 0x00	; 0
    1d5e:	0e 94 3a 11 	call	0x2274	; 0x2274 <fputc>
    1d62:	a2 fe       	sbrs	r10, 2
    1d64:	17 c0       	rjmp	.+46     	; 0x1d94 <vfprintf+0x372>
    1d66:	a1 fc       	sbrc	r10, 1
    1d68:	03 c0       	rjmp	.+6      	; 0x1d70 <vfprintf+0x34e>
    1d6a:	88 e7       	ldi	r24, 0x78	; 120
    1d6c:	90 e0       	ldi	r25, 0x00	; 0
    1d6e:	02 c0       	rjmp	.+4      	; 0x1d74 <vfprintf+0x352>
    1d70:	88 e5       	ldi	r24, 0x58	; 88
    1d72:	90 e0       	ldi	r25, 0x00	; 0
    1d74:	b6 01       	movw	r22, r12
    1d76:	0c c0       	rjmp	.+24     	; 0x1d90 <vfprintf+0x36e>
    1d78:	8a 2d       	mov	r24, r10
    1d7a:	86 78       	andi	r24, 0x86	; 134
    1d7c:	59 f0       	breq	.+22     	; 0x1d94 <vfprintf+0x372>
    1d7e:	a1 fe       	sbrs	r10, 1
    1d80:	02 c0       	rjmp	.+4      	; 0x1d86 <vfprintf+0x364>
    1d82:	8b e2       	ldi	r24, 0x2B	; 43
    1d84:	01 c0       	rjmp	.+2      	; 0x1d88 <vfprintf+0x366>
    1d86:	80 e2       	ldi	r24, 0x20	; 32
    1d88:	a7 fc       	sbrc	r10, 7
    1d8a:	8d e2       	ldi	r24, 0x2D	; 45
    1d8c:	b6 01       	movw	r22, r12
    1d8e:	90 e0       	ldi	r25, 0x00	; 0
    1d90:	0e 94 3a 11 	call	0x2274	; 0x2274 <fputc>
    1d94:	89 14       	cp	r8, r9
    1d96:	38 f4       	brcc	.+14     	; 0x1da6 <vfprintf+0x384>
    1d98:	b6 01       	movw	r22, r12
    1d9a:	80 e3       	ldi	r24, 0x30	; 48
    1d9c:	90 e0       	ldi	r25, 0x00	; 0
    1d9e:	0e 94 3a 11 	call	0x2274	; 0x2274 <fputc>
    1da2:	9a 94       	dec	r9
    1da4:	f7 cf       	rjmp	.-18     	; 0x1d94 <vfprintf+0x372>
    1da6:	8a 94       	dec	r8
    1da8:	f3 01       	movw	r30, r6
    1daa:	e8 0d       	add	r30, r8
    1dac:	f1 1d       	adc	r31, r1
    1dae:	80 81       	ld	r24, Z
    1db0:	b6 01       	movw	r22, r12
    1db2:	90 e0       	ldi	r25, 0x00	; 0
    1db4:	0e 94 3a 11 	call	0x2274	; 0x2274 <fputc>
    1db8:	81 10       	cpse	r8, r1
    1dba:	f5 cf       	rjmp	.-22     	; 0x1da6 <vfprintf+0x384>
    1dbc:	22 20       	and	r2, r2
    1dbe:	09 f4       	brne	.+2      	; 0x1dc2 <vfprintf+0x3a0>
    1dc0:	42 ce       	rjmp	.-892    	; 0x1a46 <vfprintf+0x24>
    1dc2:	b6 01       	movw	r22, r12
    1dc4:	80 e2       	ldi	r24, 0x20	; 32
    1dc6:	90 e0       	ldi	r25, 0x00	; 0
    1dc8:	0e 94 3a 11 	call	0x2274	; 0x2274 <fputc>
    1dcc:	2a 94       	dec	r2
    1dce:	f6 cf       	rjmp	.-20     	; 0x1dbc <vfprintf+0x39a>
    1dd0:	f6 01       	movw	r30, r12
    1dd2:	86 81       	ldd	r24, Z+6	; 0x06
    1dd4:	97 81       	ldd	r25, Z+7	; 0x07
    1dd6:	02 c0       	rjmp	.+4      	; 0x1ddc <vfprintf+0x3ba>
    1dd8:	8f ef       	ldi	r24, 0xFF	; 255
    1dda:	9f ef       	ldi	r25, 0xFF	; 255
    1ddc:	2b 96       	adiw	r28, 0x0b	; 11
    1dde:	e2 e1       	ldi	r30, 0x12	; 18
    1de0:	0c 94 ed 11 	jmp	0x23da	; 0x23da <__epilogue_restores__>

00001de4 <dtoa_prf>:
    1de4:	a9 e0       	ldi	r26, 0x09	; 9
    1de6:	b0 e0       	ldi	r27, 0x00	; 0
    1de8:	e8 ef       	ldi	r30, 0xF8	; 248
    1dea:	fe e0       	ldi	r31, 0x0E	; 14
    1dec:	0c 94 da 11 	jmp	0x23b4	; 0x23b4 <__prologue_saves__+0xc>
    1df0:	6a 01       	movw	r12, r20
    1df2:	12 2f       	mov	r17, r18
    1df4:	b0 2e       	mov	r11, r16
    1df6:	2b e3       	ldi	r18, 0x3B	; 59
    1df8:	20 17       	cp	r18, r16
    1dfa:	20 f0       	brcs	.+8      	; 0x1e04 <dtoa_prf+0x20>
    1dfc:	ff 24       	eor	r15, r15
    1dfe:	f3 94       	inc	r15
    1e00:	f0 0e       	add	r15, r16
    1e02:	02 c0       	rjmp	.+4      	; 0x1e08 <dtoa_prf+0x24>
    1e04:	2c e3       	ldi	r18, 0x3C	; 60
    1e06:	f2 2e       	mov	r15, r18
    1e08:	0f 2d       	mov	r16, r15
    1e0a:	27 e0       	ldi	r18, 0x07	; 7
    1e0c:	ae 01       	movw	r20, r28
    1e0e:	4f 5f       	subi	r20, 0xFF	; 255
    1e10:	5f 4f       	sbci	r21, 0xFF	; 255
    1e12:	0e 94 4c 10 	call	0x2098	; 0x2098 <__ftoa_engine>
    1e16:	bc 01       	movw	r22, r24
    1e18:	49 81       	ldd	r20, Y+1	; 0x01
    1e1a:	84 2f       	mov	r24, r20
    1e1c:	89 70       	andi	r24, 0x09	; 9
    1e1e:	81 30       	cpi	r24, 0x01	; 1
    1e20:	31 f0       	breq	.+12     	; 0x1e2e <dtoa_prf+0x4a>
    1e22:	e1 fc       	sbrc	r14, 1
    1e24:	06 c0       	rjmp	.+12     	; 0x1e32 <dtoa_prf+0x4e>
    1e26:	e0 fe       	sbrs	r14, 0
    1e28:	06 c0       	rjmp	.+12     	; 0x1e36 <dtoa_prf+0x52>
    1e2a:	90 e2       	ldi	r25, 0x20	; 32
    1e2c:	05 c0       	rjmp	.+10     	; 0x1e38 <dtoa_prf+0x54>
    1e2e:	9d e2       	ldi	r25, 0x2D	; 45
    1e30:	03 c0       	rjmp	.+6      	; 0x1e38 <dtoa_prf+0x54>
    1e32:	9b e2       	ldi	r25, 0x2B	; 43
    1e34:	01 c0       	rjmp	.+2      	; 0x1e38 <dtoa_prf+0x54>
    1e36:	90 e0       	ldi	r25, 0x00	; 0
    1e38:	5e 2d       	mov	r21, r14
    1e3a:	50 71       	andi	r21, 0x10	; 16
    1e3c:	43 ff       	sbrs	r20, 3
    1e3e:	3c c0       	rjmp	.+120    	; 0x1eb8 <dtoa_prf+0xd4>
    1e40:	91 11       	cpse	r25, r1
    1e42:	02 c0       	rjmp	.+4      	; 0x1e48 <dtoa_prf+0x64>
    1e44:	83 e0       	ldi	r24, 0x03	; 3
    1e46:	01 c0       	rjmp	.+2      	; 0x1e4a <dtoa_prf+0x66>
    1e48:	84 e0       	ldi	r24, 0x04	; 4
    1e4a:	81 17       	cp	r24, r17
    1e4c:	18 f4       	brcc	.+6      	; 0x1e54 <dtoa_prf+0x70>
    1e4e:	21 2f       	mov	r18, r17
    1e50:	28 1b       	sub	r18, r24
    1e52:	01 c0       	rjmp	.+2      	; 0x1e56 <dtoa_prf+0x72>
    1e54:	20 e0       	ldi	r18, 0x00	; 0
    1e56:	51 11       	cpse	r21, r1
    1e58:	0b c0       	rjmp	.+22     	; 0x1e70 <dtoa_prf+0x8c>
    1e5a:	f6 01       	movw	r30, r12
    1e5c:	82 2f       	mov	r24, r18
    1e5e:	30 e2       	ldi	r19, 0x20	; 32
    1e60:	88 23       	and	r24, r24
    1e62:	19 f0       	breq	.+6      	; 0x1e6a <dtoa_prf+0x86>
    1e64:	31 93       	st	Z+, r19
    1e66:	81 50       	subi	r24, 0x01	; 1
    1e68:	fb cf       	rjmp	.-10     	; 0x1e60 <dtoa_prf+0x7c>
    1e6a:	c2 0e       	add	r12, r18
    1e6c:	d1 1c       	adc	r13, r1
    1e6e:	20 e0       	ldi	r18, 0x00	; 0
    1e70:	99 23       	and	r25, r25
    1e72:	29 f0       	breq	.+10     	; 0x1e7e <dtoa_prf+0x9a>
    1e74:	d6 01       	movw	r26, r12
    1e76:	9c 93       	st	X, r25
    1e78:	f6 01       	movw	r30, r12
    1e7a:	31 96       	adiw	r30, 0x01	; 1
    1e7c:	6f 01       	movw	r12, r30
    1e7e:	c6 01       	movw	r24, r12
    1e80:	03 96       	adiw	r24, 0x03	; 3
    1e82:	e2 fe       	sbrs	r14, 2
    1e84:	0a c0       	rjmp	.+20     	; 0x1e9a <dtoa_prf+0xb6>
    1e86:	3e e4       	ldi	r19, 0x4E	; 78
    1e88:	d6 01       	movw	r26, r12
    1e8a:	3c 93       	st	X, r19
    1e8c:	41 e4       	ldi	r20, 0x41	; 65
    1e8e:	11 96       	adiw	r26, 0x01	; 1
    1e90:	4c 93       	st	X, r20
    1e92:	11 97       	sbiw	r26, 0x01	; 1
    1e94:	12 96       	adiw	r26, 0x02	; 2
    1e96:	3c 93       	st	X, r19
    1e98:	06 c0       	rjmp	.+12     	; 0x1ea6 <dtoa_prf+0xc2>
    1e9a:	3e e6       	ldi	r19, 0x6E	; 110
    1e9c:	f6 01       	movw	r30, r12
    1e9e:	30 83       	st	Z, r19
    1ea0:	41 e6       	ldi	r20, 0x61	; 97
    1ea2:	41 83       	std	Z+1, r20	; 0x01
    1ea4:	32 83       	std	Z+2, r19	; 0x02
    1ea6:	fc 01       	movw	r30, r24
    1ea8:	32 2f       	mov	r19, r18
    1eaa:	40 e2       	ldi	r20, 0x20	; 32
    1eac:	33 23       	and	r19, r19
    1eae:	09 f4       	brne	.+2      	; 0x1eb2 <dtoa_prf+0xce>
    1eb0:	42 c0       	rjmp	.+132    	; 0x1f36 <dtoa_prf+0x152>
    1eb2:	41 93       	st	Z+, r20
    1eb4:	31 50       	subi	r19, 0x01	; 1
    1eb6:	fa cf       	rjmp	.-12     	; 0x1eac <dtoa_prf+0xc8>
    1eb8:	42 ff       	sbrs	r20, 2
    1eba:	44 c0       	rjmp	.+136    	; 0x1f44 <dtoa_prf+0x160>
    1ebc:	91 11       	cpse	r25, r1
    1ebe:	02 c0       	rjmp	.+4      	; 0x1ec4 <dtoa_prf+0xe0>
    1ec0:	83 e0       	ldi	r24, 0x03	; 3
    1ec2:	01 c0       	rjmp	.+2      	; 0x1ec6 <dtoa_prf+0xe2>
    1ec4:	84 e0       	ldi	r24, 0x04	; 4
    1ec6:	81 17       	cp	r24, r17
    1ec8:	18 f4       	brcc	.+6      	; 0x1ed0 <dtoa_prf+0xec>
    1eca:	21 2f       	mov	r18, r17
    1ecc:	28 1b       	sub	r18, r24
    1ece:	01 c0       	rjmp	.+2      	; 0x1ed2 <dtoa_prf+0xee>
    1ed0:	20 e0       	ldi	r18, 0x00	; 0
    1ed2:	51 11       	cpse	r21, r1
    1ed4:	0b c0       	rjmp	.+22     	; 0x1eec <dtoa_prf+0x108>
    1ed6:	f6 01       	movw	r30, r12
    1ed8:	82 2f       	mov	r24, r18
    1eda:	30 e2       	ldi	r19, 0x20	; 32
    1edc:	88 23       	and	r24, r24
    1ede:	19 f0       	breq	.+6      	; 0x1ee6 <dtoa_prf+0x102>
    1ee0:	31 93       	st	Z+, r19
    1ee2:	81 50       	subi	r24, 0x01	; 1
    1ee4:	fb cf       	rjmp	.-10     	; 0x1edc <dtoa_prf+0xf8>
    1ee6:	c2 0e       	add	r12, r18
    1ee8:	d1 1c       	adc	r13, r1
    1eea:	20 e0       	ldi	r18, 0x00	; 0
    1eec:	99 23       	and	r25, r25
    1eee:	29 f0       	breq	.+10     	; 0x1efa <dtoa_prf+0x116>
    1ef0:	d6 01       	movw	r26, r12
    1ef2:	9c 93       	st	X, r25
    1ef4:	f6 01       	movw	r30, r12
    1ef6:	31 96       	adiw	r30, 0x01	; 1
    1ef8:	6f 01       	movw	r12, r30
    1efa:	c6 01       	movw	r24, r12
    1efc:	03 96       	adiw	r24, 0x03	; 3
    1efe:	e2 fe       	sbrs	r14, 2
    1f00:	0b c0       	rjmp	.+22     	; 0x1f18 <dtoa_prf+0x134>
    1f02:	39 e4       	ldi	r19, 0x49	; 73
    1f04:	d6 01       	movw	r26, r12
    1f06:	3c 93       	st	X, r19
    1f08:	3e e4       	ldi	r19, 0x4E	; 78
    1f0a:	11 96       	adiw	r26, 0x01	; 1
    1f0c:	3c 93       	st	X, r19
    1f0e:	11 97       	sbiw	r26, 0x01	; 1
    1f10:	36 e4       	ldi	r19, 0x46	; 70
    1f12:	12 96       	adiw	r26, 0x02	; 2
    1f14:	3c 93       	st	X, r19
    1f16:	07 c0       	rjmp	.+14     	; 0x1f26 <dtoa_prf+0x142>
    1f18:	39 e6       	ldi	r19, 0x69	; 105
    1f1a:	f6 01       	movw	r30, r12
    1f1c:	30 83       	st	Z, r19
    1f1e:	3e e6       	ldi	r19, 0x6E	; 110
    1f20:	31 83       	std	Z+1, r19	; 0x01
    1f22:	36 e6       	ldi	r19, 0x66	; 102
    1f24:	32 83       	std	Z+2, r19	; 0x02
    1f26:	fc 01       	movw	r30, r24
    1f28:	32 2f       	mov	r19, r18
    1f2a:	40 e2       	ldi	r20, 0x20	; 32
    1f2c:	33 23       	and	r19, r19
    1f2e:	19 f0       	breq	.+6      	; 0x1f36 <dtoa_prf+0x152>
    1f30:	41 93       	st	Z+, r20
    1f32:	31 50       	subi	r19, 0x01	; 1
    1f34:	fb cf       	rjmp	.-10     	; 0x1f2c <dtoa_prf+0x148>
    1f36:	fc 01       	movw	r30, r24
    1f38:	e2 0f       	add	r30, r18
    1f3a:	f1 1d       	adc	r31, r1
    1f3c:	10 82       	st	Z, r1
    1f3e:	8e ef       	ldi	r24, 0xFE	; 254
    1f40:	9f ef       	ldi	r25, 0xFF	; 255
    1f42:	a6 c0       	rjmp	.+332    	; 0x2090 <dtoa_prf+0x2ac>
    1f44:	21 e0       	ldi	r18, 0x01	; 1
    1f46:	30 e0       	ldi	r19, 0x00	; 0
    1f48:	91 11       	cpse	r25, r1
    1f4a:	02 c0       	rjmp	.+4      	; 0x1f50 <dtoa_prf+0x16c>
    1f4c:	20 e0       	ldi	r18, 0x00	; 0
    1f4e:	30 e0       	ldi	r19, 0x00	; 0
    1f50:	16 16       	cp	r1, r22
    1f52:	17 06       	cpc	r1, r23
    1f54:	1c f4       	brge	.+6      	; 0x1f5c <dtoa_prf+0x178>
    1f56:	fb 01       	movw	r30, r22
    1f58:	31 96       	adiw	r30, 0x01	; 1
    1f5a:	02 c0       	rjmp	.+4      	; 0x1f60 <dtoa_prf+0x17c>
    1f5c:	e1 e0       	ldi	r30, 0x01	; 1
    1f5e:	f0 e0       	ldi	r31, 0x00	; 0
    1f60:	2e 0f       	add	r18, r30
    1f62:	3f 1f       	adc	r19, r31
    1f64:	bb 20       	and	r11, r11
    1f66:	21 f0       	breq	.+8      	; 0x1f70 <dtoa_prf+0x18c>
    1f68:	eb 2d       	mov	r30, r11
    1f6a:	f0 e0       	ldi	r31, 0x00	; 0
    1f6c:	31 96       	adiw	r30, 0x01	; 1
    1f6e:	02 c0       	rjmp	.+4      	; 0x1f74 <dtoa_prf+0x190>
    1f70:	e0 e0       	ldi	r30, 0x00	; 0
    1f72:	f0 e0       	ldi	r31, 0x00	; 0
    1f74:	2e 0f       	add	r18, r30
    1f76:	3f 1f       	adc	r19, r31
    1f78:	e1 2f       	mov	r30, r17
    1f7a:	f0 e0       	ldi	r31, 0x00	; 0
    1f7c:	2e 17       	cp	r18, r30
    1f7e:	3f 07       	cpc	r19, r31
    1f80:	1c f4       	brge	.+6      	; 0x1f88 <dtoa_prf+0x1a4>
    1f82:	12 1b       	sub	r17, r18
    1f84:	21 2f       	mov	r18, r17
    1f86:	01 c0       	rjmp	.+2      	; 0x1f8a <dtoa_prf+0x1a6>
    1f88:	20 e0       	ldi	r18, 0x00	; 0
    1f8a:	8e 2d       	mov	r24, r14
    1f8c:	88 71       	andi	r24, 0x18	; 24
    1f8e:	59 f4       	brne	.+22     	; 0x1fa6 <dtoa_prf+0x1c2>
    1f90:	f6 01       	movw	r30, r12
    1f92:	82 2f       	mov	r24, r18
    1f94:	30 e2       	ldi	r19, 0x20	; 32
    1f96:	88 23       	and	r24, r24
    1f98:	19 f0       	breq	.+6      	; 0x1fa0 <dtoa_prf+0x1bc>
    1f9a:	31 93       	st	Z+, r19
    1f9c:	81 50       	subi	r24, 0x01	; 1
    1f9e:	fb cf       	rjmp	.-10     	; 0x1f96 <dtoa_prf+0x1b2>
    1fa0:	c2 0e       	add	r12, r18
    1fa2:	d1 1c       	adc	r13, r1
    1fa4:	20 e0       	ldi	r18, 0x00	; 0
    1fa6:	99 23       	and	r25, r25
    1fa8:	29 f0       	breq	.+10     	; 0x1fb4 <dtoa_prf+0x1d0>
    1faa:	d6 01       	movw	r26, r12
    1fac:	9c 93       	st	X, r25
    1fae:	f6 01       	movw	r30, r12
    1fb0:	31 96       	adiw	r30, 0x01	; 1
    1fb2:	6f 01       	movw	r12, r30
    1fb4:	51 11       	cpse	r21, r1
    1fb6:	0b c0       	rjmp	.+22     	; 0x1fce <dtoa_prf+0x1ea>
    1fb8:	f6 01       	movw	r30, r12
    1fba:	82 2f       	mov	r24, r18
    1fbc:	90 e3       	ldi	r25, 0x30	; 48
    1fbe:	88 23       	and	r24, r24
    1fc0:	19 f0       	breq	.+6      	; 0x1fc8 <dtoa_prf+0x1e4>
    1fc2:	91 93       	st	Z+, r25
    1fc4:	81 50       	subi	r24, 0x01	; 1
    1fc6:	fb cf       	rjmp	.-10     	; 0x1fbe <dtoa_prf+0x1da>
    1fc8:	c2 0e       	add	r12, r18
    1fca:	d1 1c       	adc	r13, r1
    1fcc:	20 e0       	ldi	r18, 0x00	; 0
    1fce:	0f 2d       	mov	r16, r15
    1fd0:	06 0f       	add	r16, r22
    1fd2:	9a 81       	ldd	r25, Y+2	; 0x02
    1fd4:	34 2f       	mov	r19, r20
    1fd6:	30 71       	andi	r19, 0x10	; 16
    1fd8:	44 ff       	sbrs	r20, 4
    1fda:	03 c0       	rjmp	.+6      	; 0x1fe2 <dtoa_prf+0x1fe>
    1fdc:	91 33       	cpi	r25, 0x31	; 49
    1fde:	09 f4       	brne	.+2      	; 0x1fe2 <dtoa_prf+0x1fe>
    1fe0:	01 50       	subi	r16, 0x01	; 1
    1fe2:	10 16       	cp	r1, r16
    1fe4:	24 f4       	brge	.+8      	; 0x1fee <dtoa_prf+0x20a>
    1fe6:	09 30       	cpi	r16, 0x09	; 9
    1fe8:	18 f0       	brcs	.+6      	; 0x1ff0 <dtoa_prf+0x20c>
    1fea:	08 e0       	ldi	r16, 0x08	; 8
    1fec:	01 c0       	rjmp	.+2      	; 0x1ff0 <dtoa_prf+0x20c>
    1fee:	01 e0       	ldi	r16, 0x01	; 1
    1ff0:	ab 01       	movw	r20, r22
    1ff2:	77 ff       	sbrs	r23, 7
    1ff4:	02 c0       	rjmp	.+4      	; 0x1ffa <dtoa_prf+0x216>
    1ff6:	40 e0       	ldi	r20, 0x00	; 0
    1ff8:	50 e0       	ldi	r21, 0x00	; 0
    1ffa:	fb 01       	movw	r30, r22
    1ffc:	e4 1b       	sub	r30, r20
    1ffe:	f5 0b       	sbc	r31, r21
    2000:	a1 e0       	ldi	r26, 0x01	; 1
    2002:	b0 e0       	ldi	r27, 0x00	; 0
    2004:	ac 0f       	add	r26, r28
    2006:	bd 1f       	adc	r27, r29
    2008:	ea 0f       	add	r30, r26
    200a:	fb 1f       	adc	r31, r27
    200c:	8e e2       	ldi	r24, 0x2E	; 46
    200e:	a8 2e       	mov	r10, r24
    2010:	4b 01       	movw	r8, r22
    2012:	80 1a       	sub	r8, r16
    2014:	91 08       	sbc	r9, r1
    2016:	0b 2d       	mov	r16, r11
    2018:	10 e0       	ldi	r17, 0x00	; 0
    201a:	11 95       	neg	r17
    201c:	01 95       	neg	r16
    201e:	11 09       	sbc	r17, r1
    2020:	4f 3f       	cpi	r20, 0xFF	; 255
    2022:	bf ef       	ldi	r27, 0xFF	; 255
    2024:	5b 07       	cpc	r21, r27
    2026:	21 f4       	brne	.+8      	; 0x2030 <dtoa_prf+0x24c>
    2028:	d6 01       	movw	r26, r12
    202a:	ac 92       	st	X, r10
    202c:	11 96       	adiw	r26, 0x01	; 1
    202e:	6d 01       	movw	r12, r26
    2030:	64 17       	cp	r22, r20
    2032:	75 07       	cpc	r23, r21
    2034:	2c f0       	brlt	.+10     	; 0x2040 <dtoa_prf+0x25c>
    2036:	84 16       	cp	r8, r20
    2038:	95 06       	cpc	r9, r21
    203a:	14 f4       	brge	.+4      	; 0x2040 <dtoa_prf+0x25c>
    203c:	81 81       	ldd	r24, Z+1	; 0x01
    203e:	01 c0       	rjmp	.+2      	; 0x2042 <dtoa_prf+0x25e>
    2040:	80 e3       	ldi	r24, 0x30	; 48
    2042:	41 50       	subi	r20, 0x01	; 1
    2044:	51 09       	sbc	r21, r1
    2046:	31 96       	adiw	r30, 0x01	; 1
    2048:	d6 01       	movw	r26, r12
    204a:	11 96       	adiw	r26, 0x01	; 1
    204c:	7d 01       	movw	r14, r26
    204e:	40 17       	cp	r20, r16
    2050:	51 07       	cpc	r21, r17
    2052:	24 f0       	brlt	.+8      	; 0x205c <dtoa_prf+0x278>
    2054:	d6 01       	movw	r26, r12
    2056:	8c 93       	st	X, r24
    2058:	67 01       	movw	r12, r14
    205a:	e2 cf       	rjmp	.-60     	; 0x2020 <dtoa_prf+0x23c>
    205c:	64 17       	cp	r22, r20
    205e:	75 07       	cpc	r23, r21
    2060:	39 f4       	brne	.+14     	; 0x2070 <dtoa_prf+0x28c>
    2062:	96 33       	cpi	r25, 0x36	; 54
    2064:	20 f4       	brcc	.+8      	; 0x206e <dtoa_prf+0x28a>
    2066:	95 33       	cpi	r25, 0x35	; 53
    2068:	19 f4       	brne	.+6      	; 0x2070 <dtoa_prf+0x28c>
    206a:	31 11       	cpse	r19, r1
    206c:	01 c0       	rjmp	.+2      	; 0x2070 <dtoa_prf+0x28c>
    206e:	81 e3       	ldi	r24, 0x31	; 49
    2070:	f6 01       	movw	r30, r12
    2072:	80 83       	st	Z, r24
    2074:	f7 01       	movw	r30, r14
    2076:	82 2f       	mov	r24, r18
    2078:	90 e2       	ldi	r25, 0x20	; 32
    207a:	88 23       	and	r24, r24
    207c:	19 f0       	breq	.+6      	; 0x2084 <dtoa_prf+0x2a0>
    207e:	91 93       	st	Z+, r25
    2080:	81 50       	subi	r24, 0x01	; 1
    2082:	fb cf       	rjmp	.-10     	; 0x207a <dtoa_prf+0x296>
    2084:	f7 01       	movw	r30, r14
    2086:	e2 0f       	add	r30, r18
    2088:	f1 1d       	adc	r31, r1
    208a:	10 82       	st	Z, r1
    208c:	80 e0       	ldi	r24, 0x00	; 0
    208e:	90 e0       	ldi	r25, 0x00	; 0
    2090:	29 96       	adiw	r28, 0x09	; 9
    2092:	ec e0       	ldi	r30, 0x0C	; 12
    2094:	0c 94 f3 11 	jmp	0x23e6	; 0x23e6 <__epilogue_restores__+0xc>

00002098 <__ftoa_engine>:
    2098:	28 30       	cpi	r18, 0x08	; 8
    209a:	08 f0       	brcs	.+2      	; 0x209e <__ftoa_engine+0x6>
    209c:	27 e0       	ldi	r18, 0x07	; 7
    209e:	33 27       	eor	r19, r19
    20a0:	da 01       	movw	r26, r20
    20a2:	99 0f       	add	r25, r25
    20a4:	31 1d       	adc	r19, r1
    20a6:	87 fd       	sbrc	r24, 7
    20a8:	91 60       	ori	r25, 0x01	; 1
    20aa:	00 96       	adiw	r24, 0x00	; 0
    20ac:	61 05       	cpc	r22, r1
    20ae:	71 05       	cpc	r23, r1
    20b0:	39 f4       	brne	.+14     	; 0x20c0 <__ftoa_engine+0x28>
    20b2:	32 60       	ori	r19, 0x02	; 2
    20b4:	2e 5f       	subi	r18, 0xFE	; 254
    20b6:	3d 93       	st	X+, r19
    20b8:	30 e3       	ldi	r19, 0x30	; 48
    20ba:	2a 95       	dec	r18
    20bc:	e1 f7       	brne	.-8      	; 0x20b6 <__ftoa_engine+0x1e>
    20be:	08 95       	ret
    20c0:	9f 3f       	cpi	r25, 0xFF	; 255
    20c2:	30 f0       	brcs	.+12     	; 0x20d0 <__ftoa_engine+0x38>
    20c4:	80 38       	cpi	r24, 0x80	; 128
    20c6:	71 05       	cpc	r23, r1
    20c8:	61 05       	cpc	r22, r1
    20ca:	09 f0       	breq	.+2      	; 0x20ce <__ftoa_engine+0x36>
    20cc:	3c 5f       	subi	r19, 0xFC	; 252
    20ce:	3c 5f       	subi	r19, 0xFC	; 252
    20d0:	3d 93       	st	X+, r19
    20d2:	91 30       	cpi	r25, 0x01	; 1
    20d4:	08 f0       	brcs	.+2      	; 0x20d8 <__ftoa_engine+0x40>
    20d6:	80 68       	ori	r24, 0x80	; 128
    20d8:	91 1d       	adc	r25, r1
    20da:	df 93       	push	r29
    20dc:	cf 93       	push	r28
    20de:	1f 93       	push	r17
    20e0:	0f 93       	push	r16
    20e2:	ff 92       	push	r15
    20e4:	ef 92       	push	r14
    20e6:	19 2f       	mov	r17, r25
    20e8:	98 7f       	andi	r25, 0xF8	; 248
    20ea:	96 95       	lsr	r25
    20ec:	e9 2f       	mov	r30, r25
    20ee:	96 95       	lsr	r25
    20f0:	96 95       	lsr	r25
    20f2:	e9 0f       	add	r30, r25
    20f4:	ff 27       	eor	r31, r31
    20f6:	e4 5e       	subi	r30, 0xE4	; 228
    20f8:	fe 4f       	sbci	r31, 0xFE	; 254
    20fa:	99 27       	eor	r25, r25
    20fc:	33 27       	eor	r19, r19
    20fe:	ee 24       	eor	r14, r14
    2100:	ff 24       	eor	r15, r15
    2102:	a7 01       	movw	r20, r14
    2104:	e7 01       	movw	r28, r14
    2106:	05 90       	lpm	r0, Z+
    2108:	08 94       	sec
    210a:	07 94       	ror	r0
    210c:	28 f4       	brcc	.+10     	; 0x2118 <__ftoa_engine+0x80>
    210e:	36 0f       	add	r19, r22
    2110:	e7 1e       	adc	r14, r23
    2112:	f8 1e       	adc	r15, r24
    2114:	49 1f       	adc	r20, r25
    2116:	51 1d       	adc	r21, r1
    2118:	66 0f       	add	r22, r22
    211a:	77 1f       	adc	r23, r23
    211c:	88 1f       	adc	r24, r24
    211e:	99 1f       	adc	r25, r25
    2120:	06 94       	lsr	r0
    2122:	a1 f7       	brne	.-24     	; 0x210c <__ftoa_engine+0x74>
    2124:	05 90       	lpm	r0, Z+
    2126:	07 94       	ror	r0
    2128:	28 f4       	brcc	.+10     	; 0x2134 <__ftoa_engine+0x9c>
    212a:	e7 0e       	add	r14, r23
    212c:	f8 1e       	adc	r15, r24
    212e:	49 1f       	adc	r20, r25
    2130:	56 1f       	adc	r21, r22
    2132:	c1 1d       	adc	r28, r1
    2134:	77 0f       	add	r23, r23
    2136:	88 1f       	adc	r24, r24
    2138:	99 1f       	adc	r25, r25
    213a:	66 1f       	adc	r22, r22
    213c:	06 94       	lsr	r0
    213e:	a1 f7       	brne	.-24     	; 0x2128 <__ftoa_engine+0x90>
    2140:	05 90       	lpm	r0, Z+
    2142:	07 94       	ror	r0
    2144:	28 f4       	brcc	.+10     	; 0x2150 <__ftoa_engine+0xb8>
    2146:	f8 0e       	add	r15, r24
    2148:	49 1f       	adc	r20, r25
    214a:	56 1f       	adc	r21, r22
    214c:	c7 1f       	adc	r28, r23
    214e:	d1 1d       	adc	r29, r1
    2150:	88 0f       	add	r24, r24
    2152:	99 1f       	adc	r25, r25
    2154:	66 1f       	adc	r22, r22
    2156:	77 1f       	adc	r23, r23
    2158:	06 94       	lsr	r0
    215a:	a1 f7       	brne	.-24     	; 0x2144 <__ftoa_engine+0xac>
    215c:	05 90       	lpm	r0, Z+
    215e:	07 94       	ror	r0
    2160:	20 f4       	brcc	.+8      	; 0x216a <__ftoa_engine+0xd2>
    2162:	49 0f       	add	r20, r25
    2164:	56 1f       	adc	r21, r22
    2166:	c7 1f       	adc	r28, r23
    2168:	d8 1f       	adc	r29, r24
    216a:	99 0f       	add	r25, r25
    216c:	66 1f       	adc	r22, r22
    216e:	77 1f       	adc	r23, r23
    2170:	88 1f       	adc	r24, r24
    2172:	06 94       	lsr	r0
    2174:	a9 f7       	brne	.-22     	; 0x2160 <__ftoa_engine+0xc8>
    2176:	84 91       	lpm	r24, Z
    2178:	10 95       	com	r17
    217a:	17 70       	andi	r17, 0x07	; 7
    217c:	41 f0       	breq	.+16     	; 0x218e <__ftoa_engine+0xf6>
    217e:	d6 95       	lsr	r29
    2180:	c7 95       	ror	r28
    2182:	57 95       	ror	r21
    2184:	47 95       	ror	r20
    2186:	f7 94       	ror	r15
    2188:	e7 94       	ror	r14
    218a:	1a 95       	dec	r17
    218c:	c1 f7       	brne	.-16     	; 0x217e <__ftoa_engine+0xe6>
    218e:	e2 ec       	ldi	r30, 0xC2	; 194
    2190:	f0 e0       	ldi	r31, 0x00	; 0
    2192:	68 94       	set
    2194:	15 90       	lpm	r1, Z+
    2196:	15 91       	lpm	r17, Z+
    2198:	35 91       	lpm	r19, Z+
    219a:	65 91       	lpm	r22, Z+
    219c:	95 91       	lpm	r25, Z+
    219e:	05 90       	lpm	r0, Z+
    21a0:	7f e2       	ldi	r23, 0x2F	; 47
    21a2:	73 95       	inc	r23
    21a4:	e1 18       	sub	r14, r1
    21a6:	f1 0a       	sbc	r15, r17
    21a8:	43 0b       	sbc	r20, r19
    21aa:	56 0b       	sbc	r21, r22
    21ac:	c9 0b       	sbc	r28, r25
    21ae:	d0 09       	sbc	r29, r0
    21b0:	c0 f7       	brcc	.-16     	; 0x21a2 <__ftoa_engine+0x10a>
    21b2:	e1 0c       	add	r14, r1
    21b4:	f1 1e       	adc	r15, r17
    21b6:	43 1f       	adc	r20, r19
    21b8:	56 1f       	adc	r21, r22
    21ba:	c9 1f       	adc	r28, r25
    21bc:	d0 1d       	adc	r29, r0
    21be:	7e f4       	brtc	.+30     	; 0x21de <__ftoa_engine+0x146>
    21c0:	70 33       	cpi	r23, 0x30	; 48
    21c2:	11 f4       	brne	.+4      	; 0x21c8 <__ftoa_engine+0x130>
    21c4:	8a 95       	dec	r24
    21c6:	e6 cf       	rjmp	.-52     	; 0x2194 <__ftoa_engine+0xfc>
    21c8:	e8 94       	clt
    21ca:	01 50       	subi	r16, 0x01	; 1
    21cc:	30 f0       	brcs	.+12     	; 0x21da <__ftoa_engine+0x142>
    21ce:	08 0f       	add	r16, r24
    21d0:	0a f4       	brpl	.+2      	; 0x21d4 <__ftoa_engine+0x13c>
    21d2:	00 27       	eor	r16, r16
    21d4:	02 17       	cp	r16, r18
    21d6:	08 f4       	brcc	.+2      	; 0x21da <__ftoa_engine+0x142>
    21d8:	20 2f       	mov	r18, r16
    21da:	23 95       	inc	r18
    21dc:	02 2f       	mov	r16, r18
    21de:	7a 33       	cpi	r23, 0x3A	; 58
    21e0:	28 f0       	brcs	.+10     	; 0x21ec <__ftoa_engine+0x154>
    21e2:	79 e3       	ldi	r23, 0x39	; 57
    21e4:	7d 93       	st	X+, r23
    21e6:	2a 95       	dec	r18
    21e8:	e9 f7       	brne	.-6      	; 0x21e4 <__ftoa_engine+0x14c>
    21ea:	10 c0       	rjmp	.+32     	; 0x220c <__ftoa_engine+0x174>
    21ec:	7d 93       	st	X+, r23
    21ee:	2a 95       	dec	r18
    21f0:	89 f6       	brne	.-94     	; 0x2194 <__ftoa_engine+0xfc>
    21f2:	06 94       	lsr	r0
    21f4:	97 95       	ror	r25
    21f6:	67 95       	ror	r22
    21f8:	37 95       	ror	r19
    21fa:	17 95       	ror	r17
    21fc:	17 94       	ror	r1
    21fe:	e1 18       	sub	r14, r1
    2200:	f1 0a       	sbc	r15, r17
    2202:	43 0b       	sbc	r20, r19
    2204:	56 0b       	sbc	r21, r22
    2206:	c9 0b       	sbc	r28, r25
    2208:	d0 09       	sbc	r29, r0
    220a:	98 f0       	brcs	.+38     	; 0x2232 <__ftoa_engine+0x19a>
    220c:	23 95       	inc	r18
    220e:	7e 91       	ld	r23, -X
    2210:	73 95       	inc	r23
    2212:	7a 33       	cpi	r23, 0x3A	; 58
    2214:	08 f0       	brcs	.+2      	; 0x2218 <__ftoa_engine+0x180>
    2216:	70 e3       	ldi	r23, 0x30	; 48
    2218:	7c 93       	st	X, r23
    221a:	20 13       	cpse	r18, r16
    221c:	b8 f7       	brcc	.-18     	; 0x220c <__ftoa_engine+0x174>
    221e:	7e 91       	ld	r23, -X
    2220:	70 61       	ori	r23, 0x10	; 16
    2222:	7d 93       	st	X+, r23
    2224:	30 f0       	brcs	.+12     	; 0x2232 <__ftoa_engine+0x19a>
    2226:	83 95       	inc	r24
    2228:	71 e3       	ldi	r23, 0x31	; 49
    222a:	7d 93       	st	X+, r23
    222c:	70 e3       	ldi	r23, 0x30	; 48
    222e:	2a 95       	dec	r18
    2230:	e1 f7       	brne	.-8      	; 0x222a <__ftoa_engine+0x192>
    2232:	11 24       	eor	r1, r1
    2234:	ef 90       	pop	r14
    2236:	ff 90       	pop	r15
    2238:	0f 91       	pop	r16
    223a:	1f 91       	pop	r17
    223c:	cf 91       	pop	r28
    223e:	df 91       	pop	r29
    2240:	99 27       	eor	r25, r25
    2242:	87 fd       	sbrc	r24, 7
    2244:	90 95       	com	r25
    2246:	08 95       	ret

00002248 <strnlen_P>:
    2248:	fc 01       	movw	r30, r24
    224a:	05 90       	lpm	r0, Z+
    224c:	61 50       	subi	r22, 0x01	; 1
    224e:	70 40       	sbci	r23, 0x00	; 0
    2250:	01 10       	cpse	r0, r1
    2252:	d8 f7       	brcc	.-10     	; 0x224a <strnlen_P+0x2>
    2254:	80 95       	com	r24
    2256:	90 95       	com	r25
    2258:	8e 0f       	add	r24, r30
    225a:	9f 1f       	adc	r25, r31
    225c:	08 95       	ret

0000225e <strnlen>:
    225e:	fc 01       	movw	r30, r24
    2260:	61 50       	subi	r22, 0x01	; 1
    2262:	70 40       	sbci	r23, 0x00	; 0
    2264:	01 90       	ld	r0, Z+
    2266:	01 10       	cpse	r0, r1
    2268:	d8 f7       	brcc	.-10     	; 0x2260 <strnlen+0x2>
    226a:	80 95       	com	r24
    226c:	90 95       	com	r25
    226e:	8e 0f       	add	r24, r30
    2270:	9f 1f       	adc	r25, r31
    2272:	08 95       	ret

00002274 <fputc>:
    2274:	0f 93       	push	r16
    2276:	1f 93       	push	r17
    2278:	cf 93       	push	r28
    227a:	df 93       	push	r29
    227c:	fb 01       	movw	r30, r22
    227e:	23 81       	ldd	r18, Z+3	; 0x03
    2280:	21 fd       	sbrc	r18, 1
    2282:	03 c0       	rjmp	.+6      	; 0x228a <fputc+0x16>
    2284:	8f ef       	ldi	r24, 0xFF	; 255
    2286:	9f ef       	ldi	r25, 0xFF	; 255
    2288:	2c c0       	rjmp	.+88     	; 0x22e2 <fputc+0x6e>
    228a:	22 ff       	sbrs	r18, 2
    228c:	16 c0       	rjmp	.+44     	; 0x22ba <fputc+0x46>
    228e:	46 81       	ldd	r20, Z+6	; 0x06
    2290:	57 81       	ldd	r21, Z+7	; 0x07
    2292:	24 81       	ldd	r18, Z+4	; 0x04
    2294:	35 81       	ldd	r19, Z+5	; 0x05
    2296:	42 17       	cp	r20, r18
    2298:	53 07       	cpc	r21, r19
    229a:	44 f4       	brge	.+16     	; 0x22ac <fputc+0x38>
    229c:	a0 81       	ld	r26, Z
    229e:	b1 81       	ldd	r27, Z+1	; 0x01
    22a0:	9d 01       	movw	r18, r26
    22a2:	2f 5f       	subi	r18, 0xFF	; 255
    22a4:	3f 4f       	sbci	r19, 0xFF	; 255
    22a6:	20 83       	st	Z, r18
    22a8:	31 83       	std	Z+1, r19	; 0x01
    22aa:	8c 93       	st	X, r24
    22ac:	26 81       	ldd	r18, Z+6	; 0x06
    22ae:	37 81       	ldd	r19, Z+7	; 0x07
    22b0:	2f 5f       	subi	r18, 0xFF	; 255
    22b2:	3f 4f       	sbci	r19, 0xFF	; 255
    22b4:	26 83       	std	Z+6, r18	; 0x06
    22b6:	37 83       	std	Z+7, r19	; 0x07
    22b8:	14 c0       	rjmp	.+40     	; 0x22e2 <fputc+0x6e>
    22ba:	8b 01       	movw	r16, r22
    22bc:	ec 01       	movw	r28, r24
    22be:	fb 01       	movw	r30, r22
    22c0:	00 84       	ldd	r0, Z+8	; 0x08
    22c2:	f1 85       	ldd	r31, Z+9	; 0x09
    22c4:	e0 2d       	mov	r30, r0
    22c6:	09 95       	icall
    22c8:	89 2b       	or	r24, r25
    22ca:	e1 f6       	brne	.-72     	; 0x2284 <fputc+0x10>
    22cc:	d8 01       	movw	r26, r16
    22ce:	16 96       	adiw	r26, 0x06	; 6
    22d0:	8d 91       	ld	r24, X+
    22d2:	9c 91       	ld	r25, X
    22d4:	17 97       	sbiw	r26, 0x07	; 7
    22d6:	01 96       	adiw	r24, 0x01	; 1
    22d8:	16 96       	adiw	r26, 0x06	; 6
    22da:	8d 93       	st	X+, r24
    22dc:	9c 93       	st	X, r25
    22de:	17 97       	sbiw	r26, 0x07	; 7
    22e0:	ce 01       	movw	r24, r28
    22e2:	df 91       	pop	r29
    22e4:	cf 91       	pop	r28
    22e6:	1f 91       	pop	r17
    22e8:	0f 91       	pop	r16
    22ea:	08 95       	ret

000022ec <__ultoa_invert>:
    22ec:	fa 01       	movw	r30, r20
    22ee:	aa 27       	eor	r26, r26
    22f0:	28 30       	cpi	r18, 0x08	; 8
    22f2:	51 f1       	breq	.+84     	; 0x2348 <__ultoa_invert+0x5c>
    22f4:	20 31       	cpi	r18, 0x10	; 16
    22f6:	81 f1       	breq	.+96     	; 0x2358 <__ultoa_invert+0x6c>
    22f8:	e8 94       	clt
    22fa:	6f 93       	push	r22
    22fc:	6e 7f       	andi	r22, 0xFE	; 254
    22fe:	6e 5f       	subi	r22, 0xFE	; 254
    2300:	7f 4f       	sbci	r23, 0xFF	; 255
    2302:	8f 4f       	sbci	r24, 0xFF	; 255
    2304:	9f 4f       	sbci	r25, 0xFF	; 255
    2306:	af 4f       	sbci	r26, 0xFF	; 255
    2308:	b1 e0       	ldi	r27, 0x01	; 1
    230a:	3e d0       	rcall	.+124    	; 0x2388 <__ultoa_invert+0x9c>
    230c:	b4 e0       	ldi	r27, 0x04	; 4
    230e:	3c d0       	rcall	.+120    	; 0x2388 <__ultoa_invert+0x9c>
    2310:	67 0f       	add	r22, r23
    2312:	78 1f       	adc	r23, r24
    2314:	89 1f       	adc	r24, r25
    2316:	9a 1f       	adc	r25, r26
    2318:	a1 1d       	adc	r26, r1
    231a:	68 0f       	add	r22, r24
    231c:	79 1f       	adc	r23, r25
    231e:	8a 1f       	adc	r24, r26
    2320:	91 1d       	adc	r25, r1
    2322:	a1 1d       	adc	r26, r1
    2324:	6a 0f       	add	r22, r26
    2326:	71 1d       	adc	r23, r1
    2328:	81 1d       	adc	r24, r1
    232a:	91 1d       	adc	r25, r1
    232c:	a1 1d       	adc	r26, r1
    232e:	20 d0       	rcall	.+64     	; 0x2370 <__ultoa_invert+0x84>
    2330:	09 f4       	brne	.+2      	; 0x2334 <__ultoa_invert+0x48>
    2332:	68 94       	set
    2334:	3f 91       	pop	r19
    2336:	2a e0       	ldi	r18, 0x0A	; 10
    2338:	26 9f       	mul	r18, r22
    233a:	11 24       	eor	r1, r1
    233c:	30 19       	sub	r19, r0
    233e:	30 5d       	subi	r19, 0xD0	; 208
    2340:	31 93       	st	Z+, r19
    2342:	de f6       	brtc	.-74     	; 0x22fa <__ultoa_invert+0xe>
    2344:	cf 01       	movw	r24, r30
    2346:	08 95       	ret
    2348:	46 2f       	mov	r20, r22
    234a:	47 70       	andi	r20, 0x07	; 7
    234c:	40 5d       	subi	r20, 0xD0	; 208
    234e:	41 93       	st	Z+, r20
    2350:	b3 e0       	ldi	r27, 0x03	; 3
    2352:	0f d0       	rcall	.+30     	; 0x2372 <__ultoa_invert+0x86>
    2354:	c9 f7       	brne	.-14     	; 0x2348 <__ultoa_invert+0x5c>
    2356:	f6 cf       	rjmp	.-20     	; 0x2344 <__ultoa_invert+0x58>
    2358:	46 2f       	mov	r20, r22
    235a:	4f 70       	andi	r20, 0x0F	; 15
    235c:	40 5d       	subi	r20, 0xD0	; 208
    235e:	4a 33       	cpi	r20, 0x3A	; 58
    2360:	18 f0       	brcs	.+6      	; 0x2368 <__ultoa_invert+0x7c>
    2362:	49 5d       	subi	r20, 0xD9	; 217
    2364:	31 fd       	sbrc	r19, 1
    2366:	40 52       	subi	r20, 0x20	; 32
    2368:	41 93       	st	Z+, r20
    236a:	02 d0       	rcall	.+4      	; 0x2370 <__ultoa_invert+0x84>
    236c:	a9 f7       	brne	.-22     	; 0x2358 <__ultoa_invert+0x6c>
    236e:	ea cf       	rjmp	.-44     	; 0x2344 <__ultoa_invert+0x58>
    2370:	b4 e0       	ldi	r27, 0x04	; 4
    2372:	a6 95       	lsr	r26
    2374:	97 95       	ror	r25
    2376:	87 95       	ror	r24
    2378:	77 95       	ror	r23
    237a:	67 95       	ror	r22
    237c:	ba 95       	dec	r27
    237e:	c9 f7       	brne	.-14     	; 0x2372 <__ultoa_invert+0x86>
    2380:	00 97       	sbiw	r24, 0x00	; 0
    2382:	61 05       	cpc	r22, r1
    2384:	71 05       	cpc	r23, r1
    2386:	08 95       	ret
    2388:	9b 01       	movw	r18, r22
    238a:	ac 01       	movw	r20, r24
    238c:	0a 2e       	mov	r0, r26
    238e:	06 94       	lsr	r0
    2390:	57 95       	ror	r21
    2392:	47 95       	ror	r20
    2394:	37 95       	ror	r19
    2396:	27 95       	ror	r18
    2398:	ba 95       	dec	r27
    239a:	c9 f7       	brne	.-14     	; 0x238e <__ultoa_invert+0xa2>
    239c:	62 0f       	add	r22, r18
    239e:	73 1f       	adc	r23, r19
    23a0:	84 1f       	adc	r24, r20
    23a2:	95 1f       	adc	r25, r21
    23a4:	a0 1d       	adc	r26, r0
    23a6:	08 95       	ret

000023a8 <__prologue_saves__>:
    23a8:	2f 92       	push	r2
    23aa:	3f 92       	push	r3
    23ac:	4f 92       	push	r4
    23ae:	5f 92       	push	r5
    23b0:	6f 92       	push	r6
    23b2:	7f 92       	push	r7
    23b4:	8f 92       	push	r8
    23b6:	9f 92       	push	r9
    23b8:	af 92       	push	r10
    23ba:	bf 92       	push	r11
    23bc:	cf 92       	push	r12
    23be:	df 92       	push	r13
    23c0:	ef 92       	push	r14
    23c2:	ff 92       	push	r15
    23c4:	0f 93       	push	r16
    23c6:	1f 93       	push	r17
    23c8:	cf 93       	push	r28
    23ca:	df 93       	push	r29
    23cc:	cd b7       	in	r28, 0x3d	; 61
    23ce:	de b7       	in	r29, 0x3e	; 62
    23d0:	ca 1b       	sub	r28, r26
    23d2:	db 0b       	sbc	r29, r27
    23d4:	cd bf       	out	0x3d, r28	; 61
    23d6:	de bf       	out	0x3e, r29	; 62
    23d8:	09 94       	ijmp

000023da <__epilogue_restores__>:
    23da:	2a 88       	ldd	r2, Y+18	; 0x12
    23dc:	39 88       	ldd	r3, Y+17	; 0x11
    23de:	48 88       	ldd	r4, Y+16	; 0x10
    23e0:	5f 84       	ldd	r5, Y+15	; 0x0f
    23e2:	6e 84       	ldd	r6, Y+14	; 0x0e
    23e4:	7d 84       	ldd	r7, Y+13	; 0x0d
    23e6:	8c 84       	ldd	r8, Y+12	; 0x0c
    23e8:	9b 84       	ldd	r9, Y+11	; 0x0b
    23ea:	aa 84       	ldd	r10, Y+10	; 0x0a
    23ec:	b9 84       	ldd	r11, Y+9	; 0x09
    23ee:	c8 84       	ldd	r12, Y+8	; 0x08
    23f0:	df 80       	ldd	r13, Y+7	; 0x07
    23f2:	ee 80       	ldd	r14, Y+6	; 0x06
    23f4:	fd 80       	ldd	r15, Y+5	; 0x05
    23f6:	0c 81       	ldd	r16, Y+4	; 0x04
    23f8:	1b 81       	ldd	r17, Y+3	; 0x03
    23fa:	aa 81       	ldd	r26, Y+2	; 0x02
    23fc:	b9 81       	ldd	r27, Y+1	; 0x01
    23fe:	ce 0f       	add	r28, r30
    2400:	d1 1d       	adc	r29, r1
    2402:	cd bf       	out	0x3d, r28	; 61
    2404:	de bf       	out	0x3e, r29	; 62
    2406:	ed 01       	movw	r28, r26
    2408:	08 95       	ret

0000240a <_exit>:
    240a:	f8 94       	cli

0000240c <__stop_program>:
    240c:	ff cf       	rjmp	.-2      	; 0x240c <__stop_program>
