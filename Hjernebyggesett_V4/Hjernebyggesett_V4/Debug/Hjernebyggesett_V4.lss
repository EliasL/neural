
Hjernebyggesett_V4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000016  00803800  00001b29  00001bdd  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001aec  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000003d  00009aec  00001aec  00001ba0  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .bss          0000005c  00803816  00803816  00001bf3  2**0
                  ALLOC
  4 .comment      00000030  00000000  00000000  00001bf3  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001c24  2**2
                  CONTENTS, READONLY
  6 .debug_aranges 00000570  00000000  00000000  00001c68  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00008c89  00000000  00000000  000021d8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00003751  00000000  00000000  0000ae61  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00002cfe  00000000  00000000  0000e5b2  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000978  00000000  00000000  000112b0  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00003736  00000000  00000000  00011c28  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00001654  00000000  00000000  0001535e  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 000003f0  00000000  00000000  000169b2  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 61 00 	jmp	0xc2	; 0xc2 <__ctors_end>
       4:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
       8:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
       c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      10:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      14:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      18:	0c 94 54 05 	jmp	0xaa8	; 0xaa8 <__vector_6>
      1c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      20:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      24:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      28:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      2c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      30:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      34:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      38:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      3c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      40:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      44:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      48:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      4c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      50:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      54:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      58:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      5c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      60:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      64:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      68:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      6c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      70:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      74:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      78:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      7c:	07 63       	ori	r16, 0x37	; 55
      7e:	42 36       	cpi	r20, 0x62	; 98
      80:	b7 9b       	sbis	0x16, 7	; 22
      82:	d8 a7       	std	Y+40, r29	; 0x28
      84:	1a 39       	cpi	r17, 0x9A	; 154
      86:	68 56       	subi	r22, 0x68	; 104
      88:	18 ae       	std	Y+56, r1	; 0x38
      8a:	ba ab       	std	Y+50, r27	; 0x32
      8c:	55 8c       	ldd	r5, Z+29	; 0x1d
      8e:	1d 3c       	cpi	r17, 0xCD	; 205
      90:	b7 cc       	rjmp	.-1682   	; 0xfffffa00 <__eeprom_end+0xff7efa00>
      92:	57 63       	ori	r21, 0x37	; 55
      94:	bd 6d       	ori	r27, 0xDD	; 221
      96:	ed fd       	.word	0xfded	; ????
      98:	75 3e       	cpi	r23, 0xE5	; 229
      9a:	f6 17       	cp	r31, r22
      9c:	72 31       	cpi	r23, 0x12	; 18
      9e:	bf 00       	.word	0x00bf	; ????
      a0:	00 00       	nop
      a2:	80 3f       	cpi	r24, 0xF0	; 240
      a4:	05 a8       	ldd	r0, Z+53	; 0x35
      a6:	4c cd       	rjmp	.-1384   	; 0xfffffb40 <__eeprom_end+0xff7efb40>
      a8:	b2 d4       	rcall	.+2404   	; 0xa0e <tinyDendrite_update_signals+0xd4>
      aa:	4e b9       	out	0x0e, r20	; 14
      ac:	38 36       	cpi	r19, 0x68	; 104
      ae:	a9 02       	muls	r26, r25
      b0:	0c 50       	subi	r16, 0x0C	; 12
      b2:	b9 91       	ld	r27, Y+
      b4:	86 88       	ldd	r8, Z+22	; 0x16
      b6:	08 3c       	cpi	r16, 0xC8	; 200
      b8:	a6 aa       	std	Z+54, r10	; 0x36
      ba:	aa 2a       	or	r10, r26
      bc:	be 00       	.word	0x00be	; ????
      be:	00 00       	nop
      c0:	80 3f       	cpi	r24, 0xF0	; 240

000000c2 <__ctors_end>:
      c2:	11 24       	eor	r1, r1
      c4:	1f be       	out	0x3f, r1	; 63
      c6:	cf ef       	ldi	r28, 0xFF	; 255
      c8:	cd bf       	out	0x3d, r28	; 61
      ca:	df e3       	ldi	r29, 0x3F	; 63
      cc:	de bf       	out	0x3e, r29	; 62

000000ce <__do_copy_data>:
      ce:	18 e3       	ldi	r17, 0x38	; 56
      d0:	a0 e0       	ldi	r26, 0x00	; 0
      d2:	b8 e3       	ldi	r27, 0x38	; 56
      d4:	e9 e2       	ldi	r30, 0x29	; 41
      d6:	fb e1       	ldi	r31, 0x1B	; 27
      d8:	02 c0       	rjmp	.+4      	; 0xde <__do_copy_data+0x10>
      da:	05 90       	lpm	r0, Z+
      dc:	0d 92       	st	X+, r0
      de:	a6 31       	cpi	r26, 0x16	; 22
      e0:	b1 07       	cpc	r27, r17
      e2:	d9 f7       	brne	.-10     	; 0xda <__do_copy_data+0xc>

000000e4 <__do_clear_bss>:
      e4:	28 e3       	ldi	r18, 0x38	; 56
      e6:	a6 e1       	ldi	r26, 0x16	; 22
      e8:	b8 e3       	ldi	r27, 0x38	; 56
      ea:	01 c0       	rjmp	.+2      	; 0xee <.do_clear_bss_start>

000000ec <.do_clear_bss_loop>:
      ec:	1d 92       	st	X+, r1

000000ee <.do_clear_bss_start>:
      ee:	a2 37       	cpi	r26, 0x72	; 114
      f0:	b2 07       	cpc	r27, r18
      f2:	e1 f7       	brne	.-8      	; 0xec <.do_clear_bss_loop>
      f4:	0e 94 83 00 	call	0x106	; 0x106 <main>
      f8:	0c 94 74 0d 	jmp	0x1ae8	; 0x1ae8 <_exit>

000000fc <__bad_interrupt>:
      fc:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000100 <atmel_start_init>:
/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
	system_init();
     100:	0e 94 b2 01 	call	0x364	; 0x364 <system_init>
     104:	08 95       	ret

00000106 <main>:

int main(void)
{	
	
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
     106:	0e 94 80 00 	call	0x100	; 0x100 <atmel_start_init>
	Setting this value will mean that the ADC (Analog to Digital Converter) will read 4.32v as 255, and 0v as 0.
	For some reason, instead of the reference voltage being 4.32v, it is 3.3v. 
	A plausible explanation is that the microchip does not up the voltage, so that if the microchip is only ever 
	supplied with 3.3v, it will output 3.3v as the max.
	*/
	VREF.CTRLA |= VREF_DAC0REFSEL_4V34_gc;
     10a:	e0 ea       	ldi	r30, 0xA0	; 160
     10c:	f0 e0       	ldi	r31, 0x00	; 0
     10e:	80 81       	ld	r24, Z
     110:	83 60       	ori	r24, 0x03	; 3
     112:	80 83       	st	Z, r24
	
	//tinyTester_test();
	
	tinySleep_prepare_sleep();
     114:	0e 94 86 09 	call	0x130c	; 0x130c <tinySleep_prepare_sleep>
	
	tinySleep_enter_sleep();
     118:	0e 94 8f 09 	call	0x131e	; 0x131e <tinySleep_enter_sleep>
	
	while (1)
	{
		// We don't want to update the neuron too often because of various reasons. The tinyISR_getflag is set every ms, and so the loop is only run once every ms.  
		if(tinyISR_getflag())
     11c:	0e 94 82 05 	call	0xb04	; 0xb04 <tinyISR_getflag>
     120:	88 23       	and	r24, r24
     122:	e1 f3       	breq	.-8      	; 0x11c <main+0x16>
		{
			//Testing sleep mode
			//tinySleep_enter_sleep();
			tinyCharge_update_charging_mode();
     124:	0e 94 18 04 	call	0x830	; 0x830 <tinyCharge_update_charging_mode>
			
			if(tinyCharge_is_connected_to_charger()){
     128:	0e 94 dd 03 	call	0x7ba	; 0x7ba <tinyCharge_is_connected_to_charger>
     12c:	88 23       	and	r24, r24
     12e:	b9 f0       	breq	.+46     	; 0x15e <main+0x58>
				// Charge loop
				
				if(tinyCharge_is_fully_charged()){
     130:	0e 94 e0 03 	call	0x7c0	; 0x7c0 <tinyCharge_is_fully_charged>
     134:	88 23       	and	r24, r24
     136:	49 f0       	breq	.+18     	; 0x14a <main+0x44>
					// When the neuron is connected to a charger, and fully charged:
					tinyLED_set_color(INN_LED, CHARGING_DONE_COLOR);
     138:	64 e0       	ldi	r22, 0x04	; 4
     13a:	80 e0       	ldi	r24, 0x00	; 0
     13c:	0e 94 c9 05 	call	0xb92	; 0xb92 <tinyLED_set_color>
					tinyLED_set_color(OUT_LED, LED_OFF);
     140:	60 e0       	ldi	r22, 0x00	; 0
     142:	81 e0       	ldi	r24, 0x01	; 1
     144:	0e 94 c9 05 	call	0xb92	; 0xb92 <tinyLED_set_color>
     148:	1a c0       	rjmp	.+52     	; 0x17e <main+0x78>
				}
				else{
					// When the neuron is charging and is not fully charged
					tinyLED_set_color_mode(OUT_LED, CHARGING_COLOR, SWING);
     14a:	43 e0       	ldi	r20, 0x03	; 3
     14c:	62 e0       	ldi	r22, 0x02	; 2
     14e:	81 e0       	ldi	r24, 0x01	; 1
     150:	0e 94 a1 05 	call	0xb42	; 0xb42 <tinyLED_set_color_mode>
					tinyLED_set_color(INN_LED, LED_OFF);
     154:	60 e0       	ldi	r22, 0x00	; 0
     156:	80 e0       	ldi	r24, 0x00	; 0
     158:	0e 94 c9 05 	call	0xb92	; 0xb92 <tinyLED_set_color>
     15c:	10 c0       	rjmp	.+32     	; 0x17e <main+0x78>
				// Main loop			
				
				// Set LED
				// If the out led is turned LED_OFF, and the ping color is not disabled,
				// we turn on ping mode
				if(tinyLED_get_color(OUT_LED) == LED_OFF && PING_COLOR != LED_OFF){
     15e:	81 e0       	ldi	r24, 0x01	; 1
     160:	0e 94 99 05 	call	0xb32	; 0xb32 <tinyLED_get_color>
					tinyLED_set_color_mode(OUT_LED, PING_COLOR, PING);
				}
				if(tinyLED_get_color(INN_LED) == LED_OFF){
     164:	80 e0       	ldi	r24, 0x00	; 0
     166:	0e 94 99 05 	call	0xb32	; 0xb32 <tinyLED_get_color>
     16a:	81 11       	cpse	r24, r1
     16c:	04 c0       	rjmp	.+8      	; 0x176 <main+0x70>
					// Display potential level with LED
					tinyLED_set_color_mode(INN_LED, CHANGING_COLOR, POTENTIAL);
     16e:	46 e0       	ldi	r20, 0x06	; 6
     170:	61 e0       	ldi	r22, 0x01	; 1
     172:	0e 94 a1 05 	call	0xb42	; 0xb42 <tinyLED_set_color_mode>
				}
				
				// Update button	
				tinyButton_update();
     176:	0e 94 77 03 	call	0x6ee	; 0x6ee <tinyButton_update>
				
				// Update the potential (This is where most of the important stuff happens)
				tinyPotential_update();
     17a:	0e 94 ab 08 	call	0x1156	; 0x1156 <tinyPotential_update>
			}
			
			// Update LED
			tinyLED_update();
     17e:	0e 94 fd 05 	call	0xbfa	; 0xbfa <tinyLED_update>
				
			// Switch transistors
			tinyCharge_set_transistors();
     182:	0e 94 52 04 	call	0x8a4	; 0x8a4 <tinyCharge_set_transistors>
			
			// Prepare for next cycle
			tinyISR_setflag(false);
     186:	80 e0       	ldi	r24, 0x00	; 0
     188:	0e 94 7f 05 	call	0xafe	; 0xafe <tinyISR_setflag>
			tinyDebugger_send_uint32("time", tinyTime_now());
     18c:	0e 94 ac 09 	call	0x1358	; 0x1358 <tinyTime_now>
     190:	ab 01       	movw	r20, r22
     192:	bc 01       	movw	r22, r24
     194:	8c ee       	ldi	r24, 0xEC	; 236
     196:	9a e9       	ldi	r25, 0x9A	; 154
     198:	0e 94 5d 04 	call	0x8ba	; 0x8ba <tinyDebugger_send_uint32>
			tinyDebugger_end_line();
     19c:	0e 94 60 04 	call	0x8c0	; 0x8c0 <tinyDebugger_end_line>
     1a0:	bd cf       	rjmp	.-134    	; 0x11c <main+0x16>

000001a2 <ADC_0_init>:
 * \return Conversion result read from the ADC_0 ADC module
 */
adc_result_t ADC_0_get_conversion_result(void)
{
	return (ADC1.RES);
}
     1a2:	e0 e4       	ldi	r30, 0x40	; 64
     1a4:	f6 e0       	ldi	r31, 0x06	; 6
     1a6:	80 e1       	ldi	r24, 0x10	; 16
     1a8:	82 83       	std	Z+2, r24	; 0x02
     1aa:	85 e0       	ldi	r24, 0x05	; 5
     1ac:	80 83       	st	Z, r24
     1ae:	80 e0       	ldi	r24, 0x00	; 0
     1b0:	08 95       	ret

000001b2 <ADC_0_is_conversion_done>:
     1b2:	80 91 4b 06 	lds	r24, 0x064B	; 0x80064b <__TEXT_REGION_LENGTH__+0x70064b>
     1b6:	81 70       	andi	r24, 0x01	; 1
     1b8:	08 95       	ret

000001ba <ADC_0_get_conversion>:
 *
 * \return Nothing
 */
void ADC_0_start_conversion(adc_1_channel_t channel)
{
	ADC1.MUXPOS  = channel;
     1ba:	e0 e4       	ldi	r30, 0x40	; 64
     1bc:	f6 e0       	ldi	r31, 0x06	; 6
     1be:	86 83       	std	Z+6, r24	; 0x06
	ADC1.COMMAND = ADC_STCONV_bm;
     1c0:	81 e0       	ldi	r24, 0x01	; 1
     1c2:	80 87       	std	Z+8, r24	; 0x08
adc_result_t ADC_0_get_conversion(adc_1_channel_t channel)
{
	adc_result_t res;

	ADC_0_start_conversion(channel);
	while (!ADC_0_is_conversion_done())
     1c4:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <ADC_0_is_conversion_done>
     1c8:	88 23       	and	r24, r24
     1ca:	e1 f3       	breq	.-8      	; 0x1c4 <ADC_0_get_conversion+0xa>
 *
 * \return Conversion result read from the ADC_0 ADC module
 */
adc_result_t ADC_0_get_conversion_result(void)
{
	return (ADC1.RES);
     1cc:	e0 e4       	ldi	r30, 0x40	; 64
     1ce:	f6 e0       	ldi	r31, 0x06	; 6
     1d0:	20 89       	ldd	r18, Z+16	; 0x10
     1d2:	31 89       	ldd	r19, Z+17	; 0x11

	ADC_0_start_conversion(channel);
	while (!ADC_0_is_conversion_done())
		;
	res = ADC_0_get_conversion_result();
	ADC1.INTFLAGS |= ADC_RESRDY_bm;
     1d4:	93 85       	ldd	r25, Z+11	; 0x0b
     1d6:	91 60       	ori	r25, 0x01	; 1
     1d8:	93 87       	std	Z+11, r25	; 0x0b
	return res;
}
     1da:	c9 01       	movw	r24, r18
     1dc:	08 95       	ret

000001de <BOD_init>:
	//		 | BOD_VLMCFG_BELOW_gc; /* Interrupt when supply goes below VLM level */

	// BOD.VLMCTRLA = BOD_VLMLVL_5ABOVE_gc; /* VLM threshold 5% above BOD level */

	return 0;
}
     1de:	80 e0       	ldi	r24, 0x00	; 0
     1e0:	08 95       	ret

000001e2 <DIGITAL_GLUE_LOGIC_0_init>:

	// Enable Protected register, peripheral must be disabled (ENABLE=0, in TCD.LUT0CTRLA).

	// CCL.SEQCTRL0 = CCL_SEQSEL_DISABLE_gc /* Sequential logic disabled */;

	CCL.TRUTH0 = 168; /* Truth 0: 168 */
     1e2:	e0 ec       	ldi	r30, 0xC0	; 192
     1e4:	f1 e0       	ldi	r31, 0x01	; 1
     1e6:	28 ea       	ldi	r18, 0xA8	; 168
     1e8:	20 87       	std	Z+8, r18	; 0x08

	CCL.LUT0CTRLC = CCL_INSEL2_TCA0_gc /* TCA0 WO2 input source */;
     1ea:	98 e0       	ldi	r25, 0x08	; 8
     1ec:	97 83       	std	Z+7, r25	; 0x07

	CCL.LUT0CTRLB = CCL_INSEL0_SPI0_gc /* SPI0 SCK source */
     1ee:	8b eb       	ldi	r24, 0xBB	; 187
     1f0:	86 83       	std	Z+6, r24	; 0x06
	                | CCL_INSEL1_SPI0_gc /* SPI0 MOSI input source */;

	CCL.LUT0CTRLA = 0 << CCL_CLKSRC_bp       /* Clock Source Selection: disabled */
     1f2:	39 e0       	ldi	r19, 0x09	; 9
     1f4:	35 83       	std	Z+5, r19	; 0x05
	                | CCL_EDGEDET_DIS_gc     /* Edge detector is disabled */
	                | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	                | 1 << CCL_ENABLE_bp     /* LUT Enable: enabled */
	                | 1 << CCL_OUTEN_bp;     /* Output Enable: enabled */

	CCL.TRUTH1 = 168; /* Truth 1: 168 */
     1f6:	24 87       	std	Z+12, r18	; 0x0c

	CCL.LUT1CTRLC = CCL_INSEL2_TCA0_gc /* TCA0 WO2 input source */;
     1f8:	93 87       	std	Z+11, r25	; 0x0b

	CCL.LUT1CTRLB = CCL_INSEL0_SPI0_gc /* SPI0 SCK source */
     1fa:	82 87       	std	Z+10, r24	; 0x0a
	//		 | CCL_EDGEDET_DIS_gc /* Edge detector is disabled */
	//		 | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	//		 | 0 << CCL_ENABLE_bp /* LUT Enable: disabled */
	//		 | 0 << CCL_OUTEN_bp; /* Output Enable: disabled */

	CCL.CTRLA = 1 << CCL_ENABLE_bp      /* Enable: enabled */
     1fc:	81 e4       	ldi	r24, 0x41	; 65
     1fe:	80 83       	st	Z, r24
	            | 1 << CCL_RUNSTDBY_bp; /* Run in Standby: enabled */

	return 0;
}
     200:	80 e0       	ldi	r24, 0x00	; 0
     202:	08 95       	ret

00000204 <CLKCTRL_init>:
 *       on calling convention. The memory model is not visible to the
 *       preprocessor, so it must be defined in the Assembler preprocessor directives.
 */
static inline void ccp_write_io(void *addr, uint8_t value)
{
	protected_write_io(addr, CCP_IOREG_gc, value);
     204:	47 e0       	ldi	r20, 0x07	; 7
     206:	68 ed       	ldi	r22, 0xD8	; 216
     208:	8c e7       	ldi	r24, 0x7C	; 124
     20a:	90 e0       	ldi	r25, 0x00	; 0
     20c:	0e 94 e1 01 	call	0x3c2	; 0x3c2 <protected_write_io>
     210:	41 e0       	ldi	r20, 0x01	; 1
     212:	68 ed       	ldi	r22, 0xD8	; 216
     214:	81 e6       	ldi	r24, 0x61	; 97
     216:	90 e0       	ldi	r25, 0x00	; 0
     218:	0e 94 e1 01 	call	0x3c2	; 0x3c2 <protected_write_io>
	//		 | 0 << CLKCTRL_CLKOUT_bp /* System clock out: disabled */);

	// ccp_write_io((void*)&(CLKCTRL.MCLKLOCK),0 << CLKCTRL_LOCKEN_bp /* lock enable: disabled */);

	return 0;
}
     21c:	80 e0       	ldi	r24, 0x00	; 0
     21e:	08 95       	ret

00000220 <CPUINT_init>:

	// CPUINT.LVL0PRI = 0x0 << CPUINT_LVL0PRI_gp; /* Interrupt Level Priority: 0x0 */

	// CPUINT.LVL1VEC = 0x0 << CPUINT_LVL1VEC_gp; /* Interrupt Vector with High Priority: 0x0 */

	ENABLE_INTERRUPTS();
     220:	78 94       	sei

	return 0;
}
     222:	80 e0       	ldi	r24, 0x00	; 0
     224:	08 95       	ret

00000226 <DAC_0_init>:
int8_t DAC_0_init()
{

	// DAC0.DATA = 0x0; /* DATA Register: 0x0 */

	DAC0.CTRLA = 1 << DAC_ENABLE_bp      /* DAC Enable: enabled */
     226:	81 e4       	ldi	r24, 0x41	; 65
     228:	80 93 a0 06 	sts	0x06A0, r24	; 0x8006a0 <__TEXT_REGION_LENGTH__+0x7006a0>
	             | 1 << DAC_OUTEN_bp     /* Output Buffer Enable: enabled */
	             | 0 << DAC_RUNSTDBY_bp; /* Run in Standby Mode: disabled */

	return 0;
}
     22c:	80 e0       	ldi	r24, 0x00	; 0
     22e:	08 95       	ret

00000230 <DAC_0_uninit>:
int8_t DAC_0_uninit()
{

	// DAC0.DATA = 0x0; /* DATA Register: 0x0 */

	DAC0.CTRLA = 1 << DAC_ENABLE_bp      /* DAC Enable: enabled */
     230:	81 e0       	ldi	r24, 0x01	; 1
     232:	80 93 a0 06 	sts	0x06A0, r24	; 0x8006a0 <__TEXT_REGION_LENGTH__+0x7006a0>
	| 0 << DAC_OUTEN_bp     /* Output Buffer Enable: disabled */
	| 0 << DAC_RUNSTDBY_bp; /* Run in Standby Mode: disabled */

	return 0;
}
     236:	80 e0       	ldi	r24, 0x00	; 0
     238:	08 95       	ret

0000023a <DAC_0_enable>:
 *
 * \return Nothing
 */
void DAC_0_enable()
{
	DAC0.CTRLA |= DAC_ENABLE_bm;
     23a:	e0 ea       	ldi	r30, 0xA0	; 160
     23c:	f6 e0       	ldi	r31, 0x06	; 6
     23e:	80 81       	ld	r24, Z
     240:	81 60       	ori	r24, 0x01	; 1
     242:	80 83       	st	Z, r24
     244:	08 95       	ret

00000246 <DAC_0_disable>:
 *
 * \return Nothing
 */
void DAC_0_disable()
{
	DAC0.CTRLA &= ~DAC_ENABLE_bm;
     246:	e0 ea       	ldi	r30, 0xA0	; 160
     248:	f6 e0       	ldi	r31, 0x06	; 6
     24a:	80 81       	ld	r24, Z
     24c:	8e 7f       	andi	r24, 0xFE	; 254
     24e:	80 83       	st	Z, r24
     250:	08 95       	ret

00000252 <DAC_0_set_output>:
 *
 * \return Nothing
 */
void DAC_0_set_output(dac_resolution_t value)
{
	DAC0.DATA = value;
     252:	80 93 a1 06 	sts	0x06A1, r24	; 0x8006a1 <__TEXT_REGION_LENGTH__+0x7006a1>
     256:	08 95       	ret

00000258 <mcu_init>:
#ifdef __cplusplus
extern "C" {
#endif

void mcu_init(void)
{
     258:	e0 e1       	ldi	r30, 0x10	; 16
     25a:	f4 e0       	ldi	r31, 0x04	; 4
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     25c:	80 81       	ld	r24, Z
     25e:	88 60       	ori	r24, 0x08	; 8
     260:	81 93       	st	Z+, r24
	 * disables all peripherals to save power. Driver shall enable
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
     262:	e8 31       	cpi	r30, 0x18	; 24
     264:	84 e0       	ldi	r24, 0x04	; 4
     266:	f8 07       	cpc	r31, r24
     268:	c9 f7       	brne	.-14     	; 0x25c <mcu_init+0x4>
     26a:	e0 e3       	ldi	r30, 0x30	; 48
     26c:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     26e:	80 81       	ld	r24, Z
     270:	88 60       	ori	r24, 0x08	; 8
     272:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     274:	e8 33       	cpi	r30, 0x38	; 56
     276:	84 e0       	ldi	r24, 0x04	; 4
     278:	f8 07       	cpc	r31, r24
     27a:	c9 f7       	brne	.-14     	; 0x26e <mcu_init+0x16>
     27c:	e0 e5       	ldi	r30, 0x50	; 80
     27e:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     280:	80 81       	ld	r24, Z
     282:	88 60       	ori	r24, 0x08	; 8
     284:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     286:	e8 35       	cpi	r30, 0x58	; 88
     288:	84 e0       	ldi	r24, 0x04	; 4
     28a:	f8 07       	cpc	r31, r24
     28c:	c9 f7       	brne	.-14     	; 0x280 <mcu_init+0x28>
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}
}
     28e:	08 95       	ret

00000290 <ADC_0_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     290:	e5 e1       	ldi	r30, 0x15	; 21
     292:	f4 e0       	ldi	r31, 0x04	; 4
     294:	80 81       	ld	r24, Z
     296:	88 7f       	andi	r24, 0xF8	; 248
     298:	84 60       	ori	r24, 0x04	; 4
     29a:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     29c:	80 81       	ld	r24, Z
     29e:	87 7f       	andi	r24, 0xF7	; 247
     2a0:	80 83       	st	Z, r24
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     2a2:	e7 e1       	ldi	r30, 0x17	; 23
     2a4:	f4 e0       	ldi	r31, 0x04	; 4
     2a6:	80 81       	ld	r24, Z
     2a8:	88 7f       	andi	r24, 0xF8	; 248
     2aa:	84 60       	ori	r24, 0x04	; 4
     2ac:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2ae:	80 81       	ld	r24, Z
     2b0:	87 7f       	andi	r24, 0xF7	; 247
     2b2:	80 83       	st	Z, r24
 */
static inline void PORTC_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     2b4:	e0 e5       	ldi	r30, 0x50	; 80
     2b6:	f4 e0       	ldi	r31, 0x04	; 4
     2b8:	80 81       	ld	r24, Z
     2ba:	88 7f       	andi	r24, 0xF8	; 248
     2bc:	84 60       	ori	r24, 0x04	; 4
     2be:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2c0:	80 81       	ld	r24, Z
     2c2:	87 7f       	andi	r24, 0xF7	; 247
     2c4:	80 83       	st	Z, r24
 */
static inline void PORTC_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     2c6:	e1 e5       	ldi	r30, 0x51	; 81
     2c8:	f4 e0       	ldi	r31, 0x04	; 4
     2ca:	80 81       	ld	r24, Z
     2cc:	88 7f       	andi	r24, 0xF8	; 248
     2ce:	84 60       	ori	r24, 0x04	; 4
     2d0:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2d2:	80 81       	ld	r24, Z
     2d4:	87 7f       	andi	r24, 0xF7	; 247
     2d6:	80 83       	st	Z, r24
 */
static inline void PORTC_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     2d8:	e3 e5       	ldi	r30, 0x53	; 83
     2da:	f4 e0       	ldi	r31, 0x04	; 4
     2dc:	80 81       	ld	r24, Z
     2de:	88 7f       	andi	r24, 0xF8	; 248
     2e0:	84 60       	ori	r24, 0x04	; 4
     2e2:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2e4:	80 81       	ld	r24, Z
     2e6:	87 7f       	andi	r24, 0xF7	; 247
     2e8:	80 83       	st	Z, r24
	// Disable digital input buffer
	DEN4_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	DEN4_PIN_set_pull_mode(PORT_PULL_OFF);

	ADC_0_init();
     2ea:	0e 94 d1 00 	call	0x1a2	; 0x1a2 <ADC_0_init>
     2ee:	08 95       	ret

000002f0 <USART_0_initialization>:
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     2f0:	23 98       	cbi	0x04, 3	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2f2:	e3 e3       	ldi	r30, 0x33	; 51
     2f4:	f4 e0       	ldi	r31, 0x04	; 4
     2f6:	80 81       	ld	r24, Z
     2f8:	87 7f       	andi	r24, 0xF7	; 247
     2fa:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     2fc:	22 9a       	sbi	0x04, 2	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     2fe:	2a 98       	cbi	0x05, 2	; 5
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	USART_0_init();
     300:	0e 94 19 02 	call	0x432	; 0x432 <USART_0_init>
     304:	08 95       	ret

00000306 <TIMER_0_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     306:	25 9a       	sbi	0x04, 5	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     308:	2d 98       	cbi	0x05, 5	; 5
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLC |= PORTMUX_TCA02_bm;
     30a:	e0 e0       	ldi	r30, 0x00	; 0
     30c:	f2 e0       	ldi	r31, 0x02	; 2
     30e:	82 81       	ldd	r24, Z+2	; 0x02
     310:	84 60       	ori	r24, 0x04	; 4
     312:	82 83       	std	Z+2, r24	; 0x02

	TIMER_0_init();
     314:	0e 94 09 02 	call	0x412	; 0x412 <TIMER_0_init>
     318:	08 95       	ret

0000031a <DIGITAL_GLUE_LOGIC_0_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     31a:	24 9a       	sbi	0x04, 4	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     31c:	2c 98       	cbi	0x05, 4	; 5
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLA |= PORTMUX_LUT0_bm;
     31e:	e0 e0       	ldi	r30, 0x00	; 0
     320:	f2 e0       	ldi	r31, 0x02	; 2
     322:	80 81       	ld	r24, Z
     324:	80 61       	ori	r24, 0x10	; 16
     326:	80 83       	st	Z, r24

	DIGITAL_GLUE_LOGIC_0_init();
     328:	0e 94 f1 00 	call	0x1e2	; 0x1e2 <DIGITAL_GLUE_LOGIC_0_init>
     32c:	08 95       	ret

0000032e <SPI_0_initialization>:
 */
static inline void PORTA_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
     32e:	02 98       	cbi	0x00, 2	; 0
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     330:	e2 e1       	ldi	r30, 0x12	; 18
     332:	f4 e0       	ldi	r31, 0x04	; 4
     334:	80 81       	ld	r24, Z
     336:	87 7f       	andi	r24, 0xF7	; 247
     338:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     33a:	01 9a       	sbi	0x00, 1	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     33c:	09 98       	cbi	0x01, 1	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     33e:	03 9a       	sbi	0x00, 3	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     340:	0b 98       	cbi	0x01, 3	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     342:	04 9a       	sbi	0x00, 4	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     344:	0c 98       	cbi	0x01, 4	; 1
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	SPI_0_init();
     346:	0e 94 01 02 	call	0x402	; 0x402 <SPI_0_init>
     34a:	08 95       	ret

0000034c <DAC_0_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     34c:	e6 e1       	ldi	r30, 0x16	; 22
     34e:	f4 e0       	ldi	r31, 0x04	; 4
     350:	80 81       	ld	r24, Z
     352:	88 7f       	andi	r24, 0xF8	; 248
     354:	84 60       	ori	r24, 0x04	; 4
     356:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     358:	80 81       	ld	r24, Z
     35a:	87 7f       	andi	r24, 0xF7	; 247
     35c:	80 83       	st	Z, r24
	// Disable digital input buffer
	AXON_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	AXON_PIN_set_pull_mode(PORT_PULL_OFF);

	DAC_0_init();
     35e:	0e 94 13 01 	call	0x226	; 0x226 <DAC_0_init>
     362:	08 95       	ret

00000364 <system_init>:
/**
 * \brief System initialization
 */
void system_init()
{
	mcu_init();
     364:	0e 94 2c 01 	call	0x258	; 0x258 <mcu_init>
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     368:	21 9a       	sbi	0x04, 1	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     36a:	29 98       	cbi	0x05, 1	; 5
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     36c:	26 98       	cbi	0x04, 6	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     36e:	e6 e3       	ldi	r30, 0x36	; 54
     370:	f4 e0       	ldi	r31, 0x04	; 4
     372:	80 81       	ld	r24, Z
     374:	87 7f       	andi	r24, 0xF7	; 247
     376:	80 83       	st	Z, r24
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     378:	27 98       	cbi	0x04, 7	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     37a:	e7 e3       	ldi	r30, 0x37	; 55
     37c:	f4 e0       	ldi	r31, 0x04	; 4
     37e:	80 81       	ld	r24, Z
     380:	87 7f       	andi	r24, 0xF7	; 247
     382:	80 83       	st	Z, r24
 */
static inline void PORTC_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
     384:	42 98       	cbi	0x08, 2	; 8
static inline void PORTC_set_pin_pull_mode(const uint8_t pin, const enum port_pull_mode pull_mode)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
     386:	e2 e5       	ldi	r30, 0x52	; 82
     388:	f4 e0       	ldi	r31, 0x04	; 4
     38a:	80 81       	ld	r24, Z
     38c:	88 60       	ori	r24, 0x08	; 8
     38e:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTC.DIR |= (1 << pin);
     390:	45 9a       	sbi	0x08, 5	; 8
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     392:	4d 9a       	sbi	0x09, 5	; 9
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    true);

	CLKCTRL_init();
     394:	0e 94 02 01 	call	0x204	; 0x204 <CLKCTRL_init>

	RTC_0_init();
     398:	0e 94 e5 01 	call	0x3ca	; 0x3ca <RTC_0_init>

	ADC_0_initialization();
     39c:	0e 94 48 01 	call	0x290	; 0x290 <ADC_0_initialization>

	USART_0_initialization();
     3a0:	0e 94 78 01 	call	0x2f0	; 0x2f0 <USART_0_initialization>

	TIMER_0_initialization();
     3a4:	0e 94 83 01 	call	0x306	; 0x306 <TIMER_0_initialization>

	DIGITAL_GLUE_LOGIC_0_initialization();
     3a8:	0e 94 8d 01 	call	0x31a	; 0x31a <DIGITAL_GLUE_LOGIC_0_initialization>

	SPI_0_initialization();
     3ac:	0e 94 97 01 	call	0x32e	; 0x32e <SPI_0_initialization>

	DAC_0_initialization();
     3b0:	0e 94 a6 01 	call	0x34c	; 0x34c <DAC_0_initialization>

	CPUINT_init();
     3b4:	0e 94 10 01 	call	0x220	; 0x220 <CPUINT_init>

	SLPCTRL_init();
     3b8:	0e 94 ff 01 	call	0x3fe	; 0x3fe <SLPCTRL_init>

	BOD_init();
     3bc:	0e 94 ef 00 	call	0x1de	; 0x1de <BOD_init>
     3c0:	08 95       	ret

000003c2 <protected_write_io>:
#if defined(__GNUC__)
  
#ifdef RAMPZ
	out     _SFR_IO_ADDR(RAMPZ), r1         // Clear bits 23:16 of Z
#endif
	movw    r30, r24                // Load addr into Z
     3c2:	fc 01       	movw	r30, r24
	out     CCP, r22                // Start CCP handshake
     3c4:	64 bf       	out	0x34, r22	; 52
	st      Z, r20                  // Write value to I/O register
     3c6:	40 83       	st	Z, r20
	ret                             // Return to caller
     3c8:	08 95       	ret

000003ca <RTC_0_init>:
 * \return Initialization status.
 */
int8_t RTC_0_init()
{

	while (RTC.STATUS > 0) { /* Wait for all register to be synchronized */
     3ca:	e0 e4       	ldi	r30, 0x40	; 64
     3cc:	f1 e0       	ldi	r31, 0x01	; 1
     3ce:	81 81       	ldd	r24, Z+1	; 0x01
     3d0:	81 11       	cpse	r24, r1
     3d2:	fd cf       	rjmp	.-6      	; 0x3ce <RTC_0_init+0x4>
	}

	// RTC.CMP = 0x0; /* Compare: 0x0 */

	RTC.CNT = 0x20; /* Counter: 0x20 */
     3d4:	e0 e4       	ldi	r30, 0x40	; 64
     3d6:	f1 e0       	ldi	r31, 0x01	; 1
     3d8:	80 e2       	ldi	r24, 0x20	; 32
     3da:	90 e0       	ldi	r25, 0x00	; 0
     3dc:	80 87       	std	Z+8, r24	; 0x08
     3de:	91 87       	std	Z+9, r25	; 0x09

	RTC.CTRLA = RTC_PRESCALER_DIV1_gc   /* 1 */
     3e0:	21 e8       	ldi	r18, 0x81	; 129
     3e2:	20 83       	st	Z, r18
	            | 1 << RTC_RTCEN_bp     /* Enable: enabled */
	            | 1 << RTC_RUNSTDBY_bp; /* Run In Standby: enabled */

	RTC.PER = 0x20 / TIMESCALE; /* Period: 0x20 */
     3e4:	82 87       	std	Z+10, r24	; 0x0a
     3e6:	93 87       	std	Z+11, r25	; 0x0b

	// RTC.CLKSEL = RTC_CLKSEL_INT32K_gc; /* 32KHz Internal Ultra Low Power Oscillator (OSCULP32K) */

	RTC.DBGCTRL = 1 << RTC_DBGRUN_bp; /* Run in debug: enabled */
     3e8:	81 e0       	ldi	r24, 0x01	; 1
     3ea:	85 83       	std	Z+5, r24	; 0x05

	RTC.INTCTRL = 0 << RTC_CMP_bp    /* Compare Match Interrupt enable: disabled */
     3ec:	82 83       	std	Z+2, r24	; 0x02
	              | 1 << RTC_OVF_bp; /* Overflow Interrupt enable: enabled */

	while (RTC.PITSTATUS > 0) { /* Wait for all register to be synchronized */
     3ee:	81 89       	ldd	r24, Z+17	; 0x11
     3f0:	81 11       	cpse	r24, r1
     3f2:	fd cf       	rjmp	.-6      	; 0x3ee <RTC_0_init+0x24>
	}

	RTC.PITCTRLA = RTC_PERIOD_OFF_gc    /* Off */
     3f4:	81 e0       	ldi	r24, 0x01	; 1
     3f6:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <__TEXT_REGION_LENGTH__+0x700150>
	// RTC.PITDBGCTRL = 0 << RTC_DBGRUN_bp; /* Run in debug: disabled */

	// RTC.PITINTCTRL = 0 << RTC_PI_bp; /* Periodic Interrupt: disabled */

	return 0;
}
     3fa:	80 e0       	ldi	r24, 0x00	; 0
     3fc:	08 95       	ret

000003fe <SLPCTRL_init>:

	// SLPCTRL.CTRLA = 0 << SLPCTRL_SEN_bp /* Sleep enable: disabled */
	//		 | SLPCTRL_SMODE_IDLE_gc; /* Idle mode */

	return 0;
}
     3fe:	80 e0       	ldi	r24, 0x00	; 0
     400:	08 95       	ret

00000402 <SPI_0_init>:
 * \return Initialization status
 */
int8_t SPI_0_init()
{

	SPI0.CTRLA = 0 << SPI_CLK2X_bp     /* Enable Double Speed: disabled */
     402:	e0 e2       	ldi	r30, 0x20	; 32
     404:	f8 e0       	ldi	r31, 0x08	; 8
     406:	83 e2       	ldi	r24, 0x23	; 35
     408:	80 83       	st	Z, r24
	             | 0 << SPI_DORD_bp    /* Data Order Setting: disabled */
	             | 1 << SPI_ENABLE_bp  /* Enable Module: enabled */
	             | 1 << SPI_MASTER_bp  /* SPI module in master mode */
	             | SPI_PRESC_DIV16_gc; /* System Clock / 16 */

	SPI0.CTRLB = 0 << SPI_BUFEN_bp   /* Buffer Mode Enable: disabled */
     40a:	84 e0       	ldi	r24, 0x04	; 4
     40c:	81 83       	std	Z+1, r24	; 0x01
	//		 | 0 << SPI_RXCIE_bp /* Receive Complete Interrupt Enable: disabled */
	//		 | 0 << SPI_SSIE_bp /* Slave Select Trigger Interrupt Enable: disabled */
	//		 | 0 << SPI_TXCIE_bp; /* Transfer Complete Interrupt Enable: disabled */

	return 0;
}
     40e:	80 e0       	ldi	r24, 0x00	; 0
     410:	08 95       	ret

00000412 <TIMER_0_init>:

	// TCA0.SINGLE.CMP0 = 0x0; /* Compare Register 0: 0x0 */

	// TCA0.SINGLE.CMP1 = 0x0; /* Compare Register 1: 0x0 */

	TCA0.SINGLE.CMP2 = 0x4; /* Compare Register 2: 0x4 */
     412:	e0 e0       	ldi	r30, 0x00	; 0
     414:	fa e0       	ldi	r31, 0x0A	; 10
     416:	84 e0       	ldi	r24, 0x04	; 4
     418:	90 e0       	ldi	r25, 0x00	; 0
     41a:	84 a7       	std	Z+44, r24	; 0x2c
     41c:	95 a7       	std	Z+45, r25	; 0x2d

	// TCA0.SINGLE.CNT = 0x0; /* Count: 0x0 */

	TCA0.SINGLE.CTRLB = 0 << TCA_SINGLE_ALUPD_bp            /* Auto Lock Update: disabled */
     41e:	83 e4       	ldi	r24, 0x43	; 67
     420:	81 83       	std	Z+1, r24	; 0x01
	                    | 0 << TCA_SINGLE_CMP0EN_bp         /* Compare 0 Enable: disabled */
	                    | 0 << TCA_SINGLE_CMP1EN_bp         /* Compare 1 Enable: disabled */
	                    | 1 << TCA_SINGLE_CMP2EN_bp         /* Compare 2 Enable: enabled */
	                    | TCA_SINGLE_WGMODE_SINGLESLOPE_gc; /*  */

	TCA0.SINGLE.CTRLC = 0 << TCA_SINGLE_CMP0OV_bp    /* Compare 0 Waveform Output Value: disabled */
     422:	84 e0       	ldi	r24, 0x04	; 4
     424:	82 83       	std	Z+2, r24	; 0x02
	// TCA0.SINGLE.INTCTRL = 0 << TCA_SINGLE_CMP0_bp /* Compare 0 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP1_bp /* Compare 1 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP2_bp /* Compare 2 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_OVF_bp; /* Overflow Interrupt: disabled */

	TCA0.SINGLE.PER = 0x7; /* Period: 0x7 */
     426:	87 e0       	ldi	r24, 0x07	; 7
     428:	90 e0       	ldi	r25, 0x00	; 0
     42a:	86 a3       	std	Z+38, r24	; 0x26
     42c:	97 a3       	std	Z+39, r25	; 0x27

	// TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV1_gc /* System Clock */
	//		 | 0 << TCA_SINGLE_ENABLE_bp; /* Module Enable: disabled */

	return 0;
}
     42e:	80 e0       	ldi	r24, 0x00	; 0
     430:	08 95       	ret

00000432 <USART_0_init>:
uint8_t USART_0_read()
{
	while (!(USART0.STATUS & USART_RXCIF_bm))
		;
	return USART0.RXDATAL;
}
     432:	e0 e0       	ldi	r30, 0x00	; 0
     434:	f8 e0       	ldi	r31, 0x08	; 8
     436:	8b e5       	ldi	r24, 0x5B	; 91
     438:	91 e0       	ldi	r25, 0x01	; 1
     43a:	80 87       	std	Z+8, r24	; 0x08
     43c:	91 87       	std	Z+9, r25	; 0x09
     43e:	80 ec       	ldi	r24, 0xC0	; 192
     440:	86 83       	std	Z+6, r24	; 0x06
     442:	80 e0       	ldi	r24, 0x00	; 0
     444:	98 e3       	ldi	r25, 0x38	; 56
     446:	80 93 6e 38 	sts	0x386E, r24	; 0x80386e <__iob+0x2>
     44a:	90 93 6f 38 	sts	0x386F, r25	; 0x80386f <__iob+0x3>
     44e:	80 e0       	ldi	r24, 0x00	; 0
     450:	08 95       	ret

00000452 <USART_0_write>:
 *
 * \return Nothing
 */
void USART_0_write(const uint8_t data)
{
	while (!(USART0.STATUS & USART_DREIF_bm))
     452:	e0 e0       	ldi	r30, 0x00	; 0
     454:	f8 e0       	ldi	r31, 0x08	; 8
     456:	94 81       	ldd	r25, Z+4	; 0x04
     458:	95 ff       	sbrs	r25, 5
     45a:	fd cf       	rjmp	.-6      	; 0x456 <USART_0_write+0x4>
		;
	USART0.TXDATAL = data;
     45c:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <__TEXT_REGION_LENGTH__+0x700802>
     460:	08 95       	ret

00000462 <USART_0_printCHAR>:

#if defined(__GNUC__)

int USART_0_printCHAR(char character, FILE *stream)
{
	USART_0_write(character);
     462:	0e 94 29 02 	call	0x452	; 0x452 <USART_0_write>
	return 0;
}
     466:	80 e0       	ldi	r24, 0x00	; 0
     468:	90 e0       	ldi	r25, 0x00	; 0
     46a:	08 95       	ret

0000046c <tinyAxon_add_pulse>:
{
	// We want to check each slot in the pulse_queue, and
	// if we find an empty slot (0), we add a pulse.
	for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
	{
		if(pulse_queue[i] == 0){
     46c:	20 91 16 38 	lds	r18, 0x3816	; 0x803816 <__data_end>
     470:	30 91 17 38 	lds	r19, 0x3817	; 0x803817 <__data_end+0x1>
     474:	23 2b       	or	r18, r19
     476:	51 f0       	breq	.+20     	; 0x48c <tinyAxon_add_pulse+0x20>
     478:	e8 e1       	ldi	r30, 0x18	; 24
     47a:	f8 e3       	ldi	r31, 0x38	; 56
     47c:	21 e0       	ldi	r18, 0x01	; 1
     47e:	30 e0       	ldi	r19, 0x00	; 0
     480:	b9 01       	movw	r22, r18
     482:	41 91       	ld	r20, Z+
     484:	51 91       	ld	r21, Z+
     486:	45 2b       	or	r20, r21
     488:	81 f4       	brne	.+32     	; 0x4aa <tinyAxon_add_pulse+0x3e>
     48a:	02 c0       	rjmp	.+4      	; 0x490 <tinyAxon_add_pulse+0x24>
     48c:	60 e0       	ldi	r22, 0x00	; 0
     48e:	70 e0       	ldi	r23, 0x00	; 0
			pulse_queue[i] = new_pulse;
     490:	66 0f       	add	r22, r22
     492:	77 1f       	adc	r23, r23
     494:	fb 01       	movw	r30, r22
     496:	ea 5e       	subi	r30, 0xEA	; 234
     498:	f7 4c       	sbci	r31, 0xC7	; 199
     49a:	80 83       	st	Z, r24
     49c:	91 83       	std	Z+1, r25	; 0x01
			pulses_in_queue++;
     49e:	80 91 2a 38 	lds	r24, 0x382A	; 0x80382a <pulses_in_queue>
     4a2:	8f 5f       	subi	r24, 0xFF	; 255
     4a4:	80 93 2a 38 	sts	0x382A, r24	; 0x80382a <pulses_in_queue>
			// We return so we only ever add one
			break;
     4a8:	08 95       	ret
     4aa:	2f 5f       	subi	r18, 0xFF	; 255
     4ac:	3f 4f       	sbci	r19, 0xFF	; 255
*/
static void tinyAxon_add_pulse(uint16_t new_pulse)
{
	// We want to check each slot in the pulse_queue, and
	// if we find an empty slot (0), we add a pulse.
	for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
     4ae:	2a 30       	cpi	r18, 0x0A	; 10
     4b0:	31 05       	cpc	r19, r1
     4b2:	31 f7       	brne	.-52     	; 0x480 <tinyAxon_add_pulse+0x14>
     4b4:	08 95       	ret

000004b6 <tinyAxon_is_firing>:
// DAC has no DAC_0_get_output, so we keep track of this here.
uint8_t axonOutputValue = 0;


_Bool tinyAxon_is_firing(){
	return axonOutputValue != NO_SIGNAL_OUTPUT;
     4b6:	81 e0       	ldi	r24, 0x01	; 1
     4b8:	90 91 2b 38 	lds	r25, 0x382B	; 0x80382b <axonOutputValue>
     4bc:	91 11       	cpse	r25, r1
     4be:	01 c0       	rjmp	.+2      	; 0x4c2 <tinyAxon_is_firing+0xc>
     4c0:	80 e0       	ldi	r24, 0x00	; 0
}
     4c2:	08 95       	ret

000004c4 <tinyAxon_get_pulses_in_queue>:
uint8_t pulses_in_queue = 0; //variable to determine how many pulses are in queue.

uint8_t tinyAxon_get_pulses_in_queue()
{
	return pulses_in_queue;
}
     4c4:	80 91 2a 38 	lds	r24, 0x382A	; 0x80382a <pulses_in_queue>
     4c8:	08 95       	ret

000004ca <find_newest_pulse>:
uint8_t find_newest_pulse() {
	uint16_t max;
	uint8_t current_index = 0;
	uint8_t return_index = 0;
	
	max = pulse_queue[current_index];
     4ca:	40 91 16 38 	lds	r20, 0x3816	; 0x803816 <__data_end>
     4ce:	50 91 17 38 	lds	r21, 0x3817	; 0x803817 <__data_end+0x1>
     4d2:	e8 e1       	ldi	r30, 0x18	; 24
     4d4:	f8 e3       	ldi	r31, 0x38	; 56
	
// This function will be used with pulse_queue to find the newest pulse
uint8_t find_newest_pulse() {
	uint16_t max;
	uint8_t current_index = 0;
	uint8_t return_index = 0;
     4d6:	80 e0       	ldi	r24, 0x00	; 0
	
	max = pulse_queue[current_index];
	
	for (current_index = 1; current_index < MAX_NUMBER_OF_PULSES; current_index++) {
     4d8:	91 e0       	ldi	r25, 0x01	; 1
		if (pulse_queue[current_index] > max) {
     4da:	21 91       	ld	r18, Z+
     4dc:	31 91       	ld	r19, Z+
     4de:	42 17       	cp	r20, r18
     4e0:	53 07       	cpc	r21, r19
     4e2:	10 f4       	brcc	.+4      	; 0x4e8 <find_newest_pulse+0x1e>
     4e4:	89 2f       	mov	r24, r25
			return_index = current_index;
			max = pulse_queue[current_index];
     4e6:	a9 01       	movw	r20, r18
	uint8_t current_index = 0;
	uint8_t return_index = 0;
	
	max = pulse_queue[current_index];
	
	for (current_index = 1; current_index < MAX_NUMBER_OF_PULSES; current_index++) {
     4e8:	9f 5f       	subi	r25, 0xFF	; 255
     4ea:	9a 30       	cpi	r25, 0x0A	; 10
     4ec:	b1 f7       	brne	.-20     	; 0x4da <find_newest_pulse+0x10>
			return_index = current_index;
			max = pulse_queue[current_index];
		}
	}
	return return_index;
}
     4ee:	08 95       	ret

000004f0 <tinyAxon_time_until_next_pulse>:


// This function will be used with in the tinyLED to determine how long the light should flash
uint16_t tinyAxon_time_until_next_pulse(){
     4f0:	cf 93       	push	r28
     4f2:	df 93       	push	r29
     4f4:	e6 e1       	ldi	r30, 0x16	; 22
     4f6:	f8 e3       	ldi	r31, 0x38	; 56
     4f8:	2a e2       	ldi	r18, 0x2A	; 42
     4fa:	38 e3       	ldi	r19, 0x38	; 56
	uint16_t min_pulse = 65530;
     4fc:	ca ef       	ldi	r28, 0xFA	; 250
     4fe:	df ef       	ldi	r29, 0xFF	; 255
	
	for (uint8_t current_index = 0; current_index < MAX_NUMBER_OF_PULSES; current_index++) {
		// We don't count pluses with time=0, they have already bee fired.
		if (pulse_queue[current_index] < min_pulse && pulse_queue[current_index] > 0) {
     500:	81 91       	ld	r24, Z+
     502:	91 91       	ld	r25, Z+
     504:	8c 17       	cp	r24, r28
     506:	9d 07       	cpc	r25, r29
     508:	18 f4       	brcc	.+6      	; 0x510 <tinyAxon_time_until_next_pulse+0x20>
     50a:	00 97       	sbiw	r24, 0x00	; 0
     50c:	09 f0       	breq	.+2      	; 0x510 <tinyAxon_time_until_next_pulse+0x20>
			min_pulse = pulse_queue[current_index];
     50e:	ec 01       	movw	r28, r24

// This function will be used with in the tinyLED to determine how long the light should flash
uint16_t tinyAxon_time_until_next_pulse(){
	uint16_t min_pulse = 65530;
	
	for (uint8_t current_index = 0; current_index < MAX_NUMBER_OF_PULSES; current_index++) {
     510:	e2 17       	cp	r30, r18
     512:	f3 07       	cpc	r31, r19
     514:	a9 f7       	brne	.-22     	; 0x500 <tinyAxon_time_until_next_pulse+0x10>
		// We don't count pluses with time=0, they have already bee fired.
		if (pulse_queue[current_index] < min_pulse && pulse_queue[current_index] > 0) {
			min_pulse = pulse_queue[current_index];
		}
	}
	tinyDebugger_send_uint32("Next Pulse", min_pulse);
     516:	ae 01       	movw	r20, r28
     518:	60 e0       	ldi	r22, 0x00	; 0
     51a:	70 e0       	ldi	r23, 0x00	; 0
     51c:	81 ef       	ldi	r24, 0xF1	; 241
     51e:	9a e9       	ldi	r25, 0x9A	; 154
     520:	0e 94 5d 04 	call	0x8ba	; 0x8ba <tinyDebugger_send_uint32>
	return min_pulse;
}
     524:	ce 01       	movw	r24, r28
     526:	df 91       	pop	r29
     528:	cf 91       	pop	r28
     52a:	08 95       	ret

0000052c <tinyAxon_stop_sending_pulse>:
	tinyLED_set_color_mode(OUT_LED, WHITE, FLASH_ONCE);
}

void tinyAxon_stop_sending_pulse()
{
	DAC_0_set_output(NO_SIGNAL_OUTPUT);
     52c:	80 e0       	ldi	r24, 0x00	; 0
     52e:	90 e0       	ldi	r25, 0x00	; 0
     530:	0e 94 29 01 	call	0x252	; 0x252 <DAC_0_set_output>
	axonOutputValue=NO_SIGNAL_OUTPUT;
     534:	10 92 2b 38 	sts	0x382B, r1	; 0x80382b <axonOutputValue>
     538:	08 95       	ret

0000053a <tinyAxon_remove_pulse>:

/*
If the potential is very low, we want to try to remove a pulse.
*/
bool tinyAxon_remove_pulse(void)
{
     53a:	cf 93       	push	r28
	// We want to return a bool indicating whether or not a pulse actually was removed.
	if(pulses_in_queue == 0){
     53c:	c0 91 2a 38 	lds	r28, 0x382A	; 0x80382a <pulses_in_queue>
     540:	cc 23       	and	r28, r28
     542:	c1 f0       	breq	.+48     	; 0x574 <tinyAxon_remove_pulse+0x3a>
		//There was no pulse to remove.
		return false;
	}
	else{
		// If we are to remove a pulse, we want to remove the one that will fire last.
		uint8_t pulse_index = find_newest_pulse();
     544:	0e 94 65 02 	call	0x4ca	; 0x4ca <find_newest_pulse>
		uint16_t newest_pulse = pulse_queue[pulse_index];
     548:	90 e0       	ldi	r25, 0x00	; 0
     54a:	fc 01       	movw	r30, r24
     54c:	ee 0f       	add	r30, r30
     54e:	ff 1f       	adc	r31, r31
     550:	ea 5e       	subi	r30, 0xEA	; 234
     552:	f7 4c       	sbci	r31, 0xC7	; 199
	
		// Now we want to check if the pulse is too far away to be affected by the low potential, or close enough that we decide to remove it.
		// (When we say that the pulse is too far away, it refers to the biological process of how the potential spreads from Dendrites to axon).
		if(newest_pulse > PULSE_NO_RETURN_TIME){
     554:	20 81       	ld	r18, Z
     556:	31 81       	ldd	r19, Z+1	; 0x01
     558:	23 2b       	or	r18, r19
     55a:	71 f0       	breq	.+28     	; 0x578 <tinyAxon_remove_pulse+0x3e>
			// We decided to remove the pulse
			pulse_queue[pulse_index] = 0;
     55c:	88 0f       	add	r24, r24
     55e:	99 1f       	adc	r25, r25
     560:	fc 01       	movw	r30, r24
     562:	ea 5e       	subi	r30, 0xEA	; 234
     564:	f7 4c       	sbci	r31, 0xC7	; 199
     566:	10 82       	st	Z, r1
     568:	11 82       	std	Z+1, r1	; 0x01
			pulses_in_queue--;
     56a:	c1 50       	subi	r28, 0x01	; 1
     56c:	c0 93 2a 38 	sts	0x382A, r28	; 0x80382a <pulses_in_queue>
			return true;
     570:	81 e0       	ldi	r24, 0x01	; 1
     572:	03 c0       	rjmp	.+6      	; 0x57a <tinyAxon_remove_pulse+0x40>
bool tinyAxon_remove_pulse(void)
{
	// We want to return a bool indicating whether or not a pulse actually was removed.
	if(pulses_in_queue == 0){
		//There was no pulse to remove.
		return false;
     574:	80 e0       	ldi	r24, 0x00	; 0
     576:	01 c0       	rjmp	.+2      	; 0x57a <tinyAxon_remove_pulse+0x40>
			pulses_in_queue--;
			return true;
		}
		// Here we have found that there is a pulse queued, but it is old enough to let pass anyway, so now we need to put it back into the queue.
		else{
			return false;
     578:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     57a:	cf 91       	pop	r28
     57c:	08 95       	ret

0000057e <tinyAxon_update_potential>:
/*
Decides whether or not the axon should fire
If the axon does fire, the potential is reduced
*/
double tinyAxon_update_potential(double potential)
{	
     57e:	cf 92       	push	r12
     580:	df 92       	push	r13
     582:	ef 92       	push	r14
     584:	ff 92       	push	r15
     586:	6b 01       	movw	r12, r22
     588:	7c 01       	movw	r14, r24
	//While the neuron has enough potential to fire, we want to fire more
	while (potential >= THRESHOLD_POTENTIAL)
     58a:	20 e0       	ldi	r18, 0x00	; 0
     58c:	30 e0       	ldi	r19, 0x00	; 0
     58e:	48 ec       	ldi	r20, 0xC8	; 200
     590:	51 e4       	ldi	r21, 0x41	; 65
     592:	0e 94 01 0c 	call	0x1802	; 0x1802 <__gesf2>
     596:	88 23       	and	r24, r24
     598:	84 f1       	brlt	.+96     	; 0x5fa <tinyAxon_update_potential+0x7c>
	{
		// We have to check if there are already queued pulses, so that the frequency never exceeds FIRE_DELAY
		if(pulses_in_queue>0){
     59a:	80 91 2a 38 	lds	r24, 0x382A	; 0x80382a <pulses_in_queue>
     59e:	88 23       	and	r24, r24
     5a0:	b1 f0       	breq	.+44     	; 0x5ce <tinyAxon_update_potential+0x50>
			uint16_t newest_pulse = pulse_queue[find_newest_pulse()];
     5a2:	0e 94 65 02 	call	0x4ca	; 0x4ca <find_newest_pulse>
     5a6:	e8 2f       	mov	r30, r24
     5a8:	f0 e0       	ldi	r31, 0x00	; 0
     5aa:	ee 0f       	add	r30, r30
     5ac:	ff 1f       	adc	r31, r31
     5ae:	ea 5e       	subi	r30, 0xEA	; 234
     5b0:	f7 4c       	sbci	r31, 0xC7	; 199
			
			// There is at least one pulse in the queue, and it is "so close", that we need to offset the new pulse, so that we keep at least
			// one FIRE_DELAY between each pulse
			if(newest_pulse + FIRE_DELAY > TRAVLE_DELAY){
     5b2:	80 81       	ld	r24, Z
     5b4:	91 81       	ldd	r25, Z+1	; 0x01
     5b6:	0f 96       	adiw	r24, 0x0f	; 15
     5b8:	85 36       	cpi	r24, 0x65	; 101
     5ba:	91 05       	cpc	r25, r1
     5bc:	18 f0       	brcs	.+6      	; 0x5c4 <tinyAxon_update_potential+0x46>
				tinyAxon_add_pulse(newest_pulse + FIRE_DELAY);
     5be:	0e 94 36 02 	call	0x46c	; 0x46c <tinyAxon_add_pulse>
     5c2:	09 c0       	rjmp	.+18     	; 0x5d6 <tinyAxon_update_potential+0x58>
			}
			// There is at least one pulse in the queue, but it's "far enough away" to ignore
			else{
				tinyAxon_add_pulse(TRAVLE_DELAY);
     5c4:	84 e6       	ldi	r24, 0x64	; 100
     5c6:	90 e0       	ldi	r25, 0x00	; 0
     5c8:	0e 94 36 02 	call	0x46c	; 0x46c <tinyAxon_add_pulse>
     5cc:	04 c0       	rjmp	.+8      	; 0x5d6 <tinyAxon_update_potential+0x58>
			}
		}
		// There are no pulses in the queue, so we add a pulse as normal
		else{
			tinyAxon_add_pulse(TRAVLE_DELAY);		
     5ce:	84 e6       	ldi	r24, 0x64	; 100
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	0e 94 36 02 	call	0x46c	; 0x46c <tinyAxon_add_pulse>
		}
		
		potential += POSTFIRE_POTENTIAL_REACTION; // This is usually defined as a negative value, don't be confused by the +=
     5d6:	20 e0       	ldi	r18, 0x00	; 0
     5d8:	30 e0       	ldi	r19, 0x00	; 0
     5da:	48 ec       	ldi	r20, 0xC8	; 200
     5dc:	51 e4       	ldi	r21, 0x41	; 65
     5de:	c7 01       	movw	r24, r14
     5e0:	b6 01       	movw	r22, r12
     5e2:	0e 94 b5 09 	call	0x136a	; 0x136a <__subsf3>
     5e6:	6b 01       	movw	r12, r22
     5e8:	7c 01       	movw	r14, r24
If the axon does fire, the potential is reduced
*/
double tinyAxon_update_potential(double potential)
{	
	//While the neuron has enough potential to fire, we want to fire more
	while (potential >= THRESHOLD_POTENTIAL)
     5ea:	20 e0       	ldi	r18, 0x00	; 0
     5ec:	30 e0       	ldi	r19, 0x00	; 0
     5ee:	48 ec       	ldi	r20, 0xC8	; 200
     5f0:	51 e4       	ldi	r21, 0x41	; 65
     5f2:	0e 94 01 0c 	call	0x1802	; 0x1802 <__gesf2>
     5f6:	88 23       	and	r24, r24
     5f8:	84 f6       	brge	.-96     	; 0x59a <tinyAxon_update_potential+0x1c>
		// Why the hell is this line here? It shoudln't i think...
		//tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
	}
	
	// If the neuron has a very low potential, we want to remove a pulse from the queue (if there is one)
	if(potential < REMOVE_PULSE_THRESHOLD) // REMOVE_PULSE_THRESHOLD is a negative number
     5fa:	20 e0       	ldi	r18, 0x00	; 0
     5fc:	30 e0       	ldi	r19, 0x00	; 0
     5fe:	40 ea       	ldi	r20, 0xA0	; 160
     600:	51 ec       	ldi	r21, 0xC1	; 193
     602:	c7 01       	movw	r24, r14
     604:	b6 01       	movw	r22, r12
     606:	0e 94 22 0a 	call	0x1444	; 0x1444 <__cmpsf2>
     60a:	88 23       	and	r24, r24
     60c:	0c f0       	brlt	.+2      	; 0x610 <tinyAxon_update_potential+0x92>
     60e:	46 c0       	rjmp	.+140    	; 0x69c <tinyAxon_update_potential+0x11e>
	{
		if(pulses_in_queue > 0)
     610:	80 91 2a 38 	lds	r24, 0x382A	; 0x80382a <pulses_in_queue>
     614:	88 23       	and	r24, r24
     616:	11 f1       	breq	.+68     	; 0x65c <tinyAxon_update_potential+0xde>
		{
			// The neurons potential is low enough to attempt to remove a queued fire (Fire less)
			if(tinyAxon_remove_pulse())
     618:	0e 94 9d 02 	call	0x53a	; 0x53a <tinyAxon_remove_pulse>
     61c:	88 23       	and	r24, r24
     61e:	f1 f1       	breq	.+124    	; 0x69c <tinyAxon_update_potential+0x11e>
			{
				// The potential has evened out a bit
				potential += THRESHOLD_POTENTIAL;
     620:	20 e0       	ldi	r18, 0x00	; 0
     622:	30 e0       	ldi	r19, 0x00	; 0
     624:	48 ec       	ldi	r20, 0xC8	; 200
     626:	51 e4       	ldi	r21, 0x41	; 65
     628:	c7 01       	movw	r24, r14
     62a:	b6 01       	movw	r22, r12
     62c:	0e 94 b6 09 	call	0x136c	; 0x136c <__addsf3>
     630:	6b 01       	movw	r12, r22
     632:	7c 01       	movw	r14, r24
     634:	33 c0       	rjmp	.+102    	; 0x69c <tinyAxon_update_potential+0x11e>
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
	{
		for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
		{
			if(pulse_queue[i] != 0){
     636:	80 81       	ld	r24, Z
     638:	91 81       	ldd	r25, Z+1	; 0x01
     63a:	00 97       	sbiw	r24, 0x00	; 0
     63c:	39 f0       	breq	.+14     	; 0x64c <tinyAxon_update_potential+0xce>
				pulse_queue[i]--;
     63e:	01 97       	sbiw	r24, 0x01	; 1
     640:	80 83       	st	Z, r24
     642:	91 83       	std	Z+1, r25	; 0x01
				
				// If the time went from 1 to 0, we fire the axon
				if(pulse_queue[i] == 0){
     644:	89 2b       	or	r24, r25
     646:	11 f4       	brne	.+4      	; 0x64c <tinyAxon_update_potential+0xce>
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
	pulses_in_queue--;
     648:	41 50       	subi	r20, 0x01	; 1
Function to set firing.
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
     64a:	51 e0       	ldi	r21, 0x01	; 1
     64c:	32 96       	adiw	r30, 0x02	; 2
	}
	
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
	{
		for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
     64e:	e2 17       	cp	r30, r18
     650:	f3 07       	cpc	r31, r19
     652:	89 f7       	brne	.-30     	; 0x636 <tinyAxon_update_potential+0xb8>
     654:	50 93 2c 38 	sts	0x382C, r21	; 0x80382c <tinyAxon_should_fire>
     658:	40 93 2a 38 	sts	0x382A, r20	; 0x80382a <pulses_in_queue>
The function should set the DAC to fire for two
update cycles once the pulse flag is set high.
*/
static void tinyAxon_update_pulse_transmitter(void)
{
	if (tinyAxon_should_fire)
     65c:	80 91 2c 38 	lds	r24, 0x382C	; 0x80382c <tinyAxon_should_fire>
     660:	88 23       	and	r24, r24
     662:	91 f0       	breq	.+36     	; 0x688 <tinyAxon_update_potential+0x10a>
	{
		tinyAxon_should_fire = false;
     664:	10 92 2c 38 	sts	0x382C, r1	; 0x80382c <tinyAxon_should_fire>
		DAC_0_set_output(EXCITATORY_NEURON_OUTPUT);
		axonOutputValue=EXCITATORY_NEURON_OUTPUT;
	}
	else if(NEURONTYPE == INHIBITORY_NEURON)
	{
		DAC_0_set_output(INHIBITORY_NEURON_OUTPUT);
     668:	8e e6       	ldi	r24, 0x6E	; 110
     66a:	90 e0       	ldi	r25, 0x00	; 0
     66c:	0e 94 29 01 	call	0x252	; 0x252 <DAC_0_set_output>
		axonOutputValue=INHIBITORY_NEURON_OUTPUT;
     670:	8e e6       	ldi	r24, 0x6E	; 110
     672:	80 93 2b 38 	sts	0x382B, r24	; 0x80382b <axonOutputValue>
	}
	
	tinyLED_set_color_mode(OUT_LED, WHITE, FLASH_ONCE);
     676:	45 e0       	ldi	r20, 0x05	; 5
     678:	66 e0       	ldi	r22, 0x06	; 6
     67a:	81 e0       	ldi	r24, 0x01	; 1
     67c:	0e 94 a1 05 	call	0xb42	; 0xb42 <tinyLED_set_color_mode>
{
	if (tinyAxon_should_fire)
	{
		tinyAxon_should_fire = false;
		tinyAxon_start_sending_pulse();
		tinyAxon_has_just_fired = true;
     680:	81 e0       	ldi	r24, 0x01	; 1
     682:	80 93 2d 38 	sts	0x382D, r24	; 0x80382d <tinyAxon_has_just_fired>
     686:	15 c0       	rjmp	.+42     	; 0x6b2 <tinyAxon_update_potential+0x134>
		
	}
	else if (tinyAxon_has_just_fired)
     688:	80 91 2d 38 	lds	r24, 0x382D	; 0x80382d <tinyAxon_has_just_fired>
     68c:	88 23       	and	r24, r24
     68e:	19 f0       	breq	.+6      	; 0x696 <tinyAxon_update_potential+0x118>
	{
		tinyAxon_has_just_fired = false;
     690:	10 92 2d 38 	sts	0x382D, r1	; 0x80382d <tinyAxon_has_just_fired>
     694:	0e c0       	rjmp	.+28     	; 0x6b2 <tinyAxon_update_potential+0x134>
	}
	else if (!tinyAxon_has_just_fired && !tinyAxon_should_fire)
	{
		tinyAxon_stop_sending_pulse();
     696:	0e 94 96 02 	call	0x52c	; 0x52c <tinyAxon_stop_sending_pulse>
     69a:	0b c0       	rjmp	.+22     	; 0x6b2 <tinyAxon_update_potential+0x134>
			}
		}
	}
	
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
     69c:	40 91 2a 38 	lds	r20, 0x382A	; 0x80382a <pulses_in_queue>
     6a0:	44 23       	and	r20, r20
     6a2:	e1 f2       	breq	.-72     	; 0x65c <tinyAxon_update_potential+0xde>
     6a4:	50 91 2c 38 	lds	r21, 0x382C	; 0x80382c <tinyAxon_should_fire>
     6a8:	e6 e1       	ldi	r30, 0x16	; 22
     6aa:	f8 e3       	ldi	r31, 0x38	; 56
     6ac:	2a e2       	ldi	r18, 0x2A	; 42
     6ae:	38 e3       	ldi	r19, 0x38	; 56
     6b0:	c2 cf       	rjmp	.-124    	; 0x636 <tinyAxon_update_potential+0xb8>
	}
	
	// Here we set the actual output of the DAC (Digital to Analog Converter)
	tinyAxon_update_pulse_transmitter();
	
	tinyDebugger_send_uint8("Axon", axonOutputValue);
     6b2:	60 91 2b 38 	lds	r22, 0x382B	; 0x80382b <axonOutputValue>
     6b6:	8c ef       	ldi	r24, 0xFC	; 252
     6b8:	9a e9       	ldi	r25, 0x9A	; 154
     6ba:	0e 94 5e 04 	call	0x8bc	; 0x8bc <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("Pulses", pulses_in_queue);
     6be:	60 91 2a 38 	lds	r22, 0x382A	; 0x80382a <pulses_in_queue>
     6c2:	81 e0       	ldi	r24, 0x01	; 1
     6c4:	9b e9       	ldi	r25, 0x9B	; 155
     6c6:	0e 94 5e 04 	call	0x8bc	; 0x8bc <tinyDebugger_send_uint8>
	
	
	return potential;
}
     6ca:	c7 01       	movw	r24, r14
     6cc:	b6 01       	movw	r22, r12
     6ce:	ff 90       	pop	r15
     6d0:	ef 90       	pop	r14
     6d2:	df 90       	pop	r13
     6d4:	cf 90       	pop	r12
     6d6:	08 95       	ret

000006d8 <tinyAxon_check_charge_level>:


_Bool tinyAxon_check_charge_level(void)
{
	// We check the AXON_CHECK_PIN. If it is hight while the axon is not firing, it must be connected to a charger
	return (AXON_CHECK_PIN_get_level() && !tinyAxon_has_just_fired);
     6d8:	37 9b       	sbis	0x06, 7	; 6
     6da:	05 c0       	rjmp	.+10     	; 0x6e6 <tinyAxon_check_charge_level+0xe>
     6dc:	90 91 2d 38 	lds	r25, 0x382D	; 0x80382d <tinyAxon_has_just_fired>
     6e0:	81 e0       	ldi	r24, 0x01	; 1
     6e2:	89 27       	eor	r24, r25
     6e4:	02 c0       	rjmp	.+4      	; 0x6ea <tinyAxon_check_charge_level+0x12>
     6e6:	80 e0       	ldi	r24, 0x00	; 0
     6e8:	90 e0       	ldi	r25, 0x00	; 0
     6ea:	81 70       	andi	r24, 0x01	; 1
     6ec:	08 95       	ret

000006ee <tinyButton_update>:
/*
If the button has been let go, we change button_press to true. This only lasts one cycle, before it is set to false again.
If the button is held down for longer than PULSEMODE_BUTTON_PRESS_TIME, we toggle the pulse mode state.
*/
void tinyButton_update(void)
{
     6ee:	0f 93       	push	r16
     6f0:	1f 93       	push	r17
     6f2:	cf 93       	push	r28
     6f4:	df 93       	push	r29
	button_press = false;
     6f6:	10 92 33 38 	sts	0x3833, r1	; 0x803833 <button_press>
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTC_get_pin_level(const uint8_t pin)
{
	return VPORTC.IN & (1 << pin);
     6fa:	8a b1       	in	r24, 0x0a	; 10
	_Bool button_is_pushed_down = !BUTTON_PIN_get_level(); // The digital port will be read as low if the button is pushed down.
     6fc:	d1 e0       	ldi	r29, 0x01	; 1
     6fe:	c8 2f       	mov	r28, r24
     700:	c4 70       	andi	r28, 0x04	; 4
     702:	82 fd       	sbrc	r24, 2
     704:	d0 e0       	ldi	r29, 0x00	; 0

	if (button_is_pushed_down && !button_was_pushed_down)
     706:	c1 11       	cpse	r28, r1
     708:	36 c0       	rjmp	.+108    	; 0x776 <tinyButton_update+0x88>
     70a:	80 91 34 38 	lds	r24, 0x3834	; 0x803834 <button_was_pushed_down>
     70e:	81 11       	cpse	r24, r1
     710:	0e c0       	rjmp	.+28     	; 0x72e <tinyButton_update+0x40>
	{
		tinyButton_start_time = tinyTime_now();
     712:	0e 94 ac 09 	call	0x1358	; 0x1358 <tinyTime_now>
     716:	60 93 2e 38 	sts	0x382E, r22	; 0x80382e <tinyButton_start_time>
     71a:	70 93 2f 38 	sts	0x382F, r23	; 0x80382f <tinyButton_start_time+0x1>
     71e:	80 93 30 38 	sts	0x3830, r24	; 0x803830 <tinyButton_start_time+0x2>
     722:	90 93 31 38 	sts	0x3831, r25	; 0x803831 <tinyButton_start_time+0x3>
	}
	if (button_is_pushed_down && button_was_pushed_down)
     726:	80 91 34 38 	lds	r24, 0x3834	; 0x803834 <button_was_pushed_down>
     72a:	88 23       	and	r24, r24
     72c:	a1 f1       	breq	.+104    	; 0x796 <tinyButton_update+0xa8>
	{
		if ((tinyTime_now() - tinyButton_start_time) > PULSEMODE_BUTTON_PRESS_TIME)
     72e:	0e 94 ac 09 	call	0x1358	; 0x1358 <tinyTime_now>
     732:	00 91 2e 38 	lds	r16, 0x382E	; 0x80382e <tinyButton_start_time>
     736:	10 91 2f 38 	lds	r17, 0x382F	; 0x80382f <tinyButton_start_time+0x1>
     73a:	20 91 30 38 	lds	r18, 0x3830	; 0x803830 <tinyButton_start_time+0x2>
     73e:	30 91 31 38 	lds	r19, 0x3831	; 0x803831 <tinyButton_start_time+0x3>
     742:	dc 01       	movw	r26, r24
     744:	cb 01       	movw	r24, r22
     746:	80 1b       	sub	r24, r16
     748:	91 0b       	sbc	r25, r17
     74a:	a2 0b       	sbc	r26, r18
     74c:	b3 0b       	sbc	r27, r19
     74e:	81 3d       	cpi	r24, 0xD1	; 209
     750:	97 40       	sbci	r25, 0x07	; 7
     752:	a1 05       	cpc	r26, r1
     754:	b1 05       	cpc	r27, r1
     756:	78 f0       	brcs	.+30     	; 0x776 <tinyButton_update+0x88>
		{
			tinyPulse_toggle_pulse_mode();
     758:	0e 94 35 09 	call	0x126a	; 0x126a <tinyPulse_toggle_pulse_mode>
			tinyButton_start_time = tinyTime_now();
     75c:	0e 94 ac 09 	call	0x1358	; 0x1358 <tinyTime_now>
     760:	60 93 2e 38 	sts	0x382E, r22	; 0x80382e <tinyButton_start_time>
     764:	70 93 2f 38 	sts	0x382F, r23	; 0x80382f <tinyButton_start_time+0x1>
     768:	80 93 30 38 	sts	0x3830, r24	; 0x803830 <tinyButton_start_time+0x2>
     76c:	90 93 31 38 	sts	0x3831, r25	; 0x803831 <tinyButton_start_time+0x3>
			// We don't want switching to pulse mode to count as a button press, so we ignore the next button press
			ignore_next_button_press = true;
     770:	81 e0       	ldi	r24, 0x01	; 1
     772:	80 93 32 38 	sts	0x3832, r24	; 0x803832 <ignore_next_button_press>
		}
	}
	if (!button_is_pushed_down && button_was_pushed_down)
     776:	cc 23       	and	r28, r28
     778:	71 f0       	breq	.+28     	; 0x796 <tinyButton_update+0xa8>
     77a:	80 91 34 38 	lds	r24, 0x3834	; 0x803834 <button_was_pushed_down>
     77e:	88 23       	and	r24, r24
     780:	51 f0       	breq	.+20     	; 0x796 <tinyButton_update+0xa8>
	{
		if(!ignore_next_button_press){
     782:	80 91 32 38 	lds	r24, 0x3832	; 0x803832 <ignore_next_button_press>
     786:	81 11       	cpse	r24, r1
     788:	04 c0       	rjmp	.+8      	; 0x792 <tinyButton_update+0xa4>
			button_press = true;
     78a:	81 e0       	ldi	r24, 0x01	; 1
     78c:	80 93 33 38 	sts	0x3833, r24	; 0x803833 <button_press>
     790:	02 c0       	rjmp	.+4      	; 0x796 <tinyButton_update+0xa8>
		}
		else{
			ignore_next_button_press = false;
     792:	10 92 32 38 	sts	0x3832, r1	; 0x803832 <ignore_next_button_press>
		}
		
	}
	button_was_pushed_down = button_is_pushed_down;
     796:	d0 93 34 38 	sts	0x3834, r29	; 0x803834 <button_was_pushed_down>
}
     79a:	df 91       	pop	r29
     79c:	cf 91       	pop	r28
     79e:	1f 91       	pop	r17
     7a0:	0f 91       	pop	r16
     7a2:	08 95       	ret

000007a4 <tinyButton_update_potential>:

double tinyButton_update_potential(double potential){
	if(button_press){
     7a4:	20 91 33 38 	lds	r18, 0x3833	; 0x803833 <button_press>
     7a8:	22 23       	and	r18, r18
     7aa:	31 f0       	breq	.+12     	; 0x7b8 <tinyButton_update_potential+0x14>
		potential += BUTTON_PRESS_REACTION;
     7ac:	20 e0       	ldi	r18, 0x00	; 0
     7ae:	30 e0       	ldi	r19, 0x00	; 0
     7b0:	40 ed       	ldi	r20, 0xD0	; 208
     7b2:	51 e4       	ldi	r21, 0x41	; 65
     7b4:	0e 94 b6 09 	call	0x136c	; 0x136c <__addsf3>
	}
	return potential;
}
     7b8:	08 95       	ret

000007ba <tinyCharge_is_connected_to_charger>:
*/
uint8_t charge_counter = 0; 

_Bool tinyCharge_is_connected_to_charger(){
	return connected_to_charger;
}
     7ba:	80 91 67 38 	lds	r24, 0x3867	; 0x803867 <connected_to_charger>
     7be:	08 95       	ret

000007c0 <tinyCharge_is_fully_charged>:
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTB_get_pin_level(const uint8_t pin)
{
	return VPORTB.IN & (1 << pin);
     7c0:	86 b1       	in	r24, 0x06	; 6

_Bool tinyCharge_is_fully_charged(){
	return CHARGING_STATUS_PIN_get_level();
}
     7c2:	86 fb       	bst	r24, 6
     7c4:	88 27       	eor	r24, r24
     7c6:	80 f9       	bld	r24, 0
     7c8:	08 95       	ret

000007ca <tinyCharge_DAC_dissable>:
void tinyCharge_DAC_dissable(){
	
	// We need some way to disable the DAC to prevent huge current draw when charging (64mA). When there is no code uploaded to the attiny, there is no problem.
	// We're going to try to enable the pin as a dendrite, since they seem to be doing fine. Completely uninitializing the pin probably caused a microchip to be fried.
	
	DAC_0_uninit();
     7ca:	0e 94 18 01 	call	0x230	; 0x230 <DAC_0_uninit>
	DAC_0_disable();
     7ce:	0e 94 23 01 	call	0x246	; 0x246 <DAC_0_disable>
     7d2:	08 95       	ret

000007d4 <tinyCharge_DAC_enable>:
void tinyCharge_DAC_enable(){
	
	// We need some way to disable the DAC to prevent huge current draw when charging (64mA). When there is no code uploaded to the attiny, there is no problem.
	// We're going to try to enable the pin as a dendrite, since they seem to be doing fine. Completely uninitializing the pin probably caused a microchip to be fried.
	
	DAC_0_init();
     7d4:	0e 94 13 01 	call	0x226	; 0x226 <DAC_0_init>
	DAC_0_enable();
     7d8:	0e 94 1d 01 	call	0x23a	; 0x23a <DAC_0_enable>
     7dc:	08 95       	ret

000007de <tinyCharge_switch_mode>:
}


void tinyCharge_switch_mode(){
	
	if(connected_to_charger){
     7de:	80 91 67 38 	lds	r24, 0x3867	; 0x803867 <connected_to_charger>
     7e2:	88 23       	and	r24, r24
     7e4:	89 f0       	breq	.+34     	; 0x808 <tinyCharge_switch_mode+0x2a>
		// Switch from main to charging mode
		
		// Set LED
		tinyLED_set_color_mode(OUT_LED, CHARGING_COLOR, SWING);
     7e6:	43 e0       	ldi	r20, 0x03	; 3
     7e8:	62 e0       	ldi	r22, 0x02	; 2
     7ea:	81 e0       	ldi	r24, 0x01	; 1
     7ec:	0e 94 a1 05 	call	0xb42	; 0xb42 <tinyLED_set_color_mode>
		tinyLED_set_color(INN_LED, LED_OFF);
     7f0:	60 e0       	ldi	r22, 0x00	; 0
     7f2:	80 e0       	ldi	r24, 0x00	; 0
     7f4:	0e 94 c9 05 	call	0xb92	; 0xb92 <tinyLED_set_color>


		// Stop axon from firing
		// (There is a small chance that the neuron is put into charging mode as it is firing. The axon is then never told to stop firing)
		tinyAxon_stop_sending_pulse();
     7f8:	0e 94 96 02 	call	0x52c	; 0x52c <tinyAxon_stop_sending_pulse>

		// disable DAC
		tinyCharge_DAC_dissable();
     7fc:	0e 94 e5 03 	call	0x7ca	; 0x7ca <tinyCharge_DAC_dissable>
		
		// We also turn off pulse mode, because it's confusing if it suddenly comes on
		// after it has been charging
		tinyPulse_set_pulse_mode(false);
     800:	80 e0       	ldi	r24, 0x00	; 0
     802:	0e 94 48 09 	call	0x1290	; 0x1290 <tinyPulse_set_pulse_mode>
     806:	08 95       	ret
	}
	else{
		// Switch from charge to main mode
		
		// Set LED
		tinyLED_set_color(OUT_LED, LED_OFF);
     808:	60 e0       	ldi	r22, 0x00	; 0
     80a:	81 e0       	ldi	r24, 0x01	; 1
     80c:	0e 94 c9 05 	call	0xb92	; 0xb92 <tinyLED_set_color>
		tinyLED_set_color(INN_LED, LED_OFF);
     810:	60 e0       	ldi	r22, 0x00	; 0
     812:	80 e0       	ldi	r24, 0x00	; 0
     814:	0e 94 c9 05 	call	0xb92	; 0xb92 <tinyLED_set_color>
		
		// enable DAC
		tinyCharge_DAC_enable();
     818:	0e 94 ea 03 	call	0x7d4	; 0x7d4 <tinyCharge_DAC_enable>
     81c:	08 95       	ret

0000081e <tinyCharge_set_charging_mode>:
	}
}

void tinyCharge_set_charging_mode(_Bool charging_status){
	if(charging_status != connected_to_charger){
     81e:	90 91 67 38 	lds	r25, 0x3867	; 0x803867 <connected_to_charger>
     822:	98 17       	cp	r25, r24
     824:	21 f0       	breq	.+8      	; 0x82e <tinyCharge_set_charging_mode+0x10>
		connected_to_charger = charging_status;
     826:	80 93 67 38 	sts	0x3867, r24	; 0x803867 <connected_to_charger>
		tinyCharge_switch_mode();
     82a:	0e 94 ef 03 	call	0x7de	; 0x7de <tinyCharge_switch_mode>
     82e:	08 95       	ret

00000830 <tinyCharge_update_charging_mode>:

/*
Checks if the levels of the dendrites and axon are at charging levels
and updates the mode accordingly
*/
void tinyCharge_update_charging_mode(){
     830:	cf 93       	push	r28
	// For complicated reasons, the axon_check_level will be high even when the charger is not connected
	// WHEN the neuron is in charging mode, hence we ignore the axon level when the neuron is in charging mode
	_Bool charging;
	if(connected_to_charger){
     832:	80 91 67 38 	lds	r24, 0x3867	; 0x803867 <connected_to_charger>
     836:	88 23       	and	r24, r24
     838:	21 f0       	breq	.+8      	; 0x842 <tinyCharge_update_charging_mode+0x12>
		charging = tinyDendrite_check_charge_level();
     83a:	0e 94 81 04 	call	0x902	; 0x902 <tinyDendrite_check_charge_level>
     83e:	c8 2f       	mov	r28, r24
     840:	0b c0       	rjmp	.+22     	; 0x858 <tinyCharge_update_charging_mode+0x28>
	} else{
		charging = tinyDendrite_check_charge_level() || tinyAxon_check_charge_level();
     842:	0e 94 81 04 	call	0x902	; 0x902 <tinyDendrite_check_charge_level>
     846:	81 11       	cpse	r24, r1
     848:	03 c0       	rjmp	.+6      	; 0x850 <tinyCharge_update_charging_mode+0x20>
     84a:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <tinyAxon_check_charge_level>
     84e:	02 c0       	rjmp	.+4      	; 0x854 <tinyCharge_update_charging_mode+0x24>
     850:	81 e0       	ldi	r24, 0x01	; 1
     852:	90 e0       	ldi	r25, 0x00	; 0
     854:	c8 2f       	mov	r28, r24
     856:	c1 70       	andi	r28, 0x01	; 1
	}
	
	// In order to prevent the axon from stimulating itself, we only switch into charging mode when the conditions have been right for several cycles
	if(!connected_to_charger && charging){
     858:	80 91 67 38 	lds	r24, 0x3867	; 0x803867 <connected_to_charger>
     85c:	81 11       	cpse	r24, r1
     85e:	0d c0       	rjmp	.+26     	; 0x87a <tinyCharge_update_charging_mode+0x4a>
     860:	cc 23       	and	r28, r28
     862:	d1 f0       	breq	.+52     	; 0x898 <tinyCharge_update_charging_mode+0x68>
		charge_counter++;
     864:	80 91 35 38 	lds	r24, 0x3835	; 0x803835 <charge_counter>
     868:	8f 5f       	subi	r24, 0xFF	; 255
		if(charge_counter > CYCLES_REQUIRED_FOR_CHARGING_MODE_SWITCH){
     86a:	8b 30       	cpi	r24, 0x0B	; 11
     86c:	90 f0       	brcs	.+36     	; 0x892 <tinyCharge_update_charging_mode+0x62>
			charge_counter = 0;
     86e:	10 92 35 38 	sts	0x3835, r1	; 0x803835 <charge_counter>
			tinyCharge_set_charging_mode(charging);
     872:	81 e0       	ldi	r24, 0x01	; 1
     874:	0e 94 0f 04 	call	0x81e	; 0x81e <tinyCharge_set_charging_mode>
     878:	13 c0       	rjmp	.+38     	; 0x8a0 <tinyCharge_update_charging_mode+0x70>
		}
	}
	else{
		tinyCharge_set_charging_mode(charging);
     87a:	8c 2f       	mov	r24, r28
     87c:	0e 94 0f 04 	call	0x81e	; 0x81e <tinyCharge_set_charging_mode>
	}
	
	// We have to prevent charge_counters from accumulating over time
	if(!charging && charge_counter>0){
     880:	c1 11       	cpse	r28, r1
     882:	0e c0       	rjmp	.+28     	; 0x8a0 <tinyCharge_update_charging_mode+0x70>
     884:	80 91 35 38 	lds	r24, 0x3835	; 0x803835 <charge_counter>
     888:	88 23       	and	r24, r24
     88a:	51 f0       	breq	.+20     	; 0x8a0 <tinyCharge_update_charging_mode+0x70>
		charge_counter = 0;
     88c:	10 92 35 38 	sts	0x3835, r1	; 0x803835 <charge_counter>
	}
	
}
     890:	07 c0       	rjmp	.+14     	; 0x8a0 <tinyCharge_update_charging_mode+0x70>
		charging = tinyDendrite_check_charge_level() || tinyAxon_check_charge_level();
	}
	
	// In order to prevent the axon from stimulating itself, we only switch into charging mode when the conditions have been right for several cycles
	if(!connected_to_charger && charging){
		charge_counter++;
     892:	80 93 35 38 	sts	0x3835, r24	; 0x803835 <charge_counter>
     896:	04 c0       	rjmp	.+8      	; 0x8a0 <tinyCharge_update_charging_mode+0x70>
			charge_counter = 0;
			tinyCharge_set_charging_mode(charging);
		}
	}
	else{
		tinyCharge_set_charging_mode(charging);
     898:	8c 2f       	mov	r24, r28
     89a:	0e 94 0f 04 	call	0x81e	; 0x81e <tinyCharge_set_charging_mode>
     89e:	f2 cf       	rjmp	.-28     	; 0x884 <tinyCharge_update_charging_mode+0x54>
	// We have to prevent charge_counters from accumulating over time
	if(!charging && charge_counter>0){
		charge_counter = 0;
	}
	
}
     8a0:	cf 91       	pop	r28
     8a2:	08 95       	ret

000008a4 <tinyCharge_set_transistors>:



void tinyCharge_set_transistors(){
	if(connected_to_charger){
     8a4:	80 91 67 38 	lds	r24, 0x3867	; 0x803867 <connected_to_charger>
     8a8:	88 23       	and	r24, r24
     8aa:	19 f0       	breq	.+6      	; 0x8b2 <tinyCharge_set_transistors+0xe>
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
	} else {
		VPORTC.OUT &= ~(1 << pin);
     8ac:	4d 98       	cbi	0x09, 5	; 9
 *                  false = Pin level set to "low" state
 */
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
     8ae:	29 9a       	sbi	0x05, 1	; 5
     8b0:	08 95       	ret
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     8b2:	4d 9a       	sbi	0x09, 5	; 9
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     8b4:	29 98       	cbi	0x05, 1	; 5
     8b6:	08 95       	ret

000008b8 <tinyDebugger_send_int>:
		char number[20]; // Arbitrary max
		dtostrf(value,1,NUMBER_OF_DECIMALS, number);
		printf("%s:%5s\t", name, number);
	}
}
void tinyDebugger_send_string(const char* name, char * value){
     8b8:	08 95       	ret

000008ba <tinyDebugger_send_uint32>:
     8ba:	08 95       	ret

000008bc <tinyDebugger_send_uint8>:
     8bc:	08 95       	ret

000008be <tinyDebugger_send_double>:
     8be:	08 95       	ret

000008c0 <tinyDebugger_end_line>:
	if(DEBUGGING){
		printf("%s:%s\t", name, value);
	}
}
void tinyDebugger_end_line(){
     8c0:	08 95       	ret

000008c2 <tinyDendrite_read_signals>:
	}
}

uint8_t tinyDendrite_get_value(uint8_t dendrite_number){
	return tinyDendrite_values[dendrite_number];
}
     8c2:	ef 92       	push	r14
     8c4:	ff 92       	push	r15
     8c6:	0f 93       	push	r16
     8c8:	1f 93       	push	r17
     8ca:	cf 93       	push	r28
     8cc:	df 93       	push	r29
     8ce:	ce e0       	ldi	r28, 0x0E	; 14
     8d0:	d8 e3       	ldi	r29, 0x38	; 56
     8d2:	00 e4       	ldi	r16, 0x40	; 64
     8d4:	18 e3       	ldi	r17, 0x38	; 56
     8d6:	0f 2e       	mov	r0, r31
     8d8:	f3 e1       	ldi	r31, 0x13	; 19
     8da:	ef 2e       	mov	r14, r31
     8dc:	f8 e3       	ldi	r31, 0x38	; 56
     8de:	ff 2e       	mov	r15, r31
     8e0:	f0 2d       	mov	r31, r0
     8e2:	89 91       	ld	r24, Y+
     8e4:	0e 94 dd 00 	call	0x1ba	; 0x1ba <ADC_0_get_conversion>
     8e8:	f8 01       	movw	r30, r16
     8ea:	81 93       	st	Z+, r24
     8ec:	8f 01       	movw	r16, r30
     8ee:	ce 15       	cp	r28, r14
     8f0:	df 05       	cpc	r29, r15
     8f2:	b9 f7       	brne	.-18     	; 0x8e2 <tinyDendrite_read_signals+0x20>
     8f4:	df 91       	pop	r29
     8f6:	cf 91       	pop	r28
     8f8:	1f 91       	pop	r17
     8fa:	0f 91       	pop	r16
     8fc:	ff 90       	pop	r15
     8fe:	ef 90       	pop	r14
     900:	08 95       	ret

00000902 <tinyDendrite_check_charge_level>:

_Bool tinyDendrite_check_charge_level(void)
{
     902:	cf 93       	push	r28
     904:	df 93       	push	r29
	_Bool charging = false;
	
	tinyDendrite_read_signals();
     906:	0e 94 61 04 	call	0x8c2	; 0x8c2 <tinyDendrite_read_signals>
     90a:	eb e3       	ldi	r30, 0x3B	; 59
     90c:	f8 e3       	ldi	r31, 0x38	; 56
     90e:	c6 e3       	ldi	r28, 0x36	; 54
     910:	d8 e3       	ldi	r29, 0x38	; 56
     912:	a0 e4       	ldi	r26, 0x40	; 64
     914:	b8 e3       	ldi	r27, 0x38	; 56
     916:	20 e4       	ldi	r18, 0x40	; 64
     918:	38 e3       	ldi	r19, 0x38	; 56
	return tinyDendrite_values[dendrite_number];
}

_Bool tinyDendrite_check_charge_level(void)
{
	_Bool charging = false;
     91a:	80 e0       	ldi	r24, 0x00	; 0
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = CHARGING;
     91c:	47 e0       	ldi	r20, 0x07	; 7
	_Bool charging = false;
	
	tinyDendrite_read_signals();
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
     91e:	90 81       	ld	r25, Z
     920:	99 93       	st	Y+, r25
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
     922:	9d 91       	ld	r25, X+
     924:	9f 3f       	cpi	r25, 0xFF	; 255
     926:	11 f4       	brne	.+4      	; 0x92c <tinyDendrite_check_charge_level+0x2a>
		{
			tinyDendrite_current_signals[i] = CHARGING;
     928:	40 83       	st	Z, r20
			charging = true;
     92a:	81 e0       	ldi	r24, 0x01	; 1
     92c:	31 96       	adiw	r30, 0x01	; 1
_Bool tinyDendrite_check_charge_level(void)
{
	_Bool charging = false;
	
	tinyDendrite_read_signals();
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
     92e:	e2 17       	cp	r30, r18
     930:	f3 07       	cpc	r31, r19
     932:	a9 f7       	brne	.-22     	; 0x91e <tinyDendrite_check_charge_level+0x1c>
			tinyDendrite_current_signals[i] = CHARGING;
			charging = true;
		}
	}
	return charging;
}
     934:	df 91       	pop	r29
     936:	cf 91       	pop	r28
     938:	08 95       	ret

0000093a <tinyDendrite_update_signals>:

/*
This function converts the 8 bit value from the ADC into one of the signal types defined in DendriteSignal
*/
void tinyDendrite_update_signals(void)
{
     93a:	af 92       	push	r10
     93c:	bf 92       	push	r11
     93e:	df 92       	push	r13
     940:	ef 92       	push	r14
     942:	ff 92       	push	r15
     944:	0f 93       	push	r16
     946:	1f 93       	push	r17
     948:	cf 93       	push	r28
     94a:	df 93       	push	r29
	
	// This function does not read the dendrite values! Read_signals must be called somewhere prior to this function!
	// As of writing this, the update_charging_mode function in main runs check_charge_level, so 
	// the tinyDendrite_values are updated when update_signals is called later
	
	tinyDebugger_send_uint8("D1", tinyDendrite_values[0]);
     94c:	c0 e4       	ldi	r28, 0x40	; 64
     94e:	d8 e3       	ldi	r29, 0x38	; 56
     950:	68 81       	ld	r22, Y
     952:	88 e0       	ldi	r24, 0x08	; 8
     954:	9b e9       	ldi	r25, 0x9B	; 155
     956:	0e 94 5e 04 	call	0x8bc	; 0x8bc <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D2", tinyDendrite_values[1]);
     95a:	69 81       	ldd	r22, Y+1	; 0x01
     95c:	8b e0       	ldi	r24, 0x0B	; 11
     95e:	9b e9       	ldi	r25, 0x9B	; 155
     960:	0e 94 5e 04 	call	0x8bc	; 0x8bc <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D3", tinyDendrite_values[2]);
     964:	6a 81       	ldd	r22, Y+2	; 0x02
     966:	8e e0       	ldi	r24, 0x0E	; 14
     968:	9b e9       	ldi	r25, 0x9B	; 155
     96a:	0e 94 5e 04 	call	0x8bc	; 0x8bc <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D4", tinyDendrite_values[3]);
     96e:	6b 81       	ldd	r22, Y+3	; 0x03
     970:	81 e1       	ldi	r24, 0x11	; 17
     972:	9b e9       	ldi	r25, 0x9B	; 155
     974:	0e 94 5e 04 	call	0x8bc	; 0x8bc <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D5", tinyDendrite_values[4]);
     978:	6c 81       	ldd	r22, Y+4	; 0x04
     97a:	84 e1       	ldi	r24, 0x14	; 20
     97c:	9b e9       	ldi	r25, 0x9B	; 155
     97e:	0e 94 5e 04 	call	0x8bc	; 0x8bc <tinyDebugger_send_uint8>
     982:	eb e3       	ldi	r30, 0x3B	; 59
     984:	f8 e3       	ldi	r31, 0x38	; 56
     986:	26 e3       	ldi	r18, 0x36	; 54
     988:	38 e3       	ldi	r19, 0x38	; 56
     98a:	5e 01       	movw	r10, r28
     98c:	40 e4       	ldi	r20, 0x40	; 64
     98e:	58 e3       	ldi	r21, 0x38	; 56
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     990:	dd 24       	eor	r13, r13
     992:	d3 94       	inc	r13
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
		}
		else if (tinyDendrite_values[i] > HIGH_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
     994:	0f 2e       	mov	r0, r31
     996:	f3 e0       	ldi	r31, 0x03	; 3
     998:	ef 2e       	mov	r14, r31
     99a:	f0 2d       	mov	r31, r0
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     99c:	68 94       	set
     99e:	ff 24       	eor	r15, r15
     9a0:	f1 f8       	bld	r15, 1
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     9a2:	04 e0       	ldi	r16, 0x04	; 4
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     9a4:	16 e0       	ldi	r17, 0x06	; 6
			// been moved to tinyDendrite_check_charging.
			//charging = true;
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     9a6:	65 e0       	ldi	r22, 0x05	; 5
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = CHARGING;
     9a8:	77 e0       	ldi	r23, 0x07	; 7
     9aa:	df 01       	movw	r26, r30
	tinyDebugger_send_uint8("D4", tinyDendrite_values[3]);
	tinyDebugger_send_uint8("D5", tinyDendrite_values[4]);
	
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
     9ac:	90 81       	ld	r25, Z
     9ae:	e9 01       	movw	r28, r18
     9b0:	99 93       	st	Y+, r25
     9b2:	9e 01       	movw	r18, r28
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
     9b4:	e5 01       	movw	r28, r10
     9b6:	89 91       	ld	r24, Y+
     9b8:	5e 01       	movw	r10, r28
     9ba:	8f 3f       	cpi	r24, 0xFF	; 255
     9bc:	11 f4       	brne	.+4      	; 0x9c2 <tinyDendrite_update_signals+0x88>
		{
			tinyDendrite_current_signals[i] = CHARGING;
     9be:	70 83       	st	Z, r23
     9c0:	19 c0       	rjmp	.+50     	; 0x9f4 <tinyDendrite_update_signals+0xba>
			// Previously, we used this function to check charging, but this has now
			// been moved to tinyDendrite_check_charging.
			//charging = true;
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
     9c2:	8b 3d       	cpi	r24, 0xDB	; 219
     9c4:	10 f0       	brcs	.+4      	; 0x9ca <tinyDendrite_update_signals+0x90>
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     9c6:	60 83       	st	Z, r22
     9c8:	15 c0       	rjmp	.+42     	; 0x9f4 <tinyDendrite_update_signals+0xba>
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
     9ca:	86 3b       	cpi	r24, 0xB6	; 182
     9cc:	10 f0       	brcs	.+4      	; 0x9d2 <tinyDendrite_update_signals+0x98>
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     9ce:	10 83       	st	Z, r17
     9d0:	11 c0       	rjmp	.+34     	; 0x9f4 <tinyDendrite_update_signals+0xba>
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
     9d2:	82 39       	cpi	r24, 0x92	; 146
     9d4:	10 f0       	brcs	.+4      	; 0x9da <tinyDendrite_update_signals+0xa0>
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     9d6:	00 83       	st	Z, r16
     9d8:	0d c0       	rjmp	.+26     	; 0x9f4 <tinyDendrite_update_signals+0xba>
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
     9da:	85 36       	cpi	r24, 0x65	; 101
     9dc:	10 f0       	brcs	.+4      	; 0x9e2 <tinyDendrite_update_signals+0xa8>
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     9de:	f0 82       	st	Z, r15
     9e0:	09 c0       	rjmp	.+18     	; 0x9f4 <tinyDendrite_update_signals+0xba>
		}
		else if (tinyDendrite_values[i] > HIGH_INHIB_THRESHOLD)
     9e2:	8a 34       	cpi	r24, 0x4A	; 74
     9e4:	10 f0       	brcs	.+4      	; 0x9ea <tinyDendrite_update_signals+0xb0>
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
     9e6:	e0 82       	st	Z, r14
     9e8:	05 c0       	rjmp	.+10     	; 0x9f4 <tinyDendrite_update_signals+0xba>
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
     9ea:	85 32       	cpi	r24, 0x25	; 37
     9ec:	10 f0       	brcs	.+4      	; 0x9f2 <tinyDendrite_update_signals+0xb8>
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     9ee:	d0 82       	st	Z, r13
     9f0:	01 c0       	rjmp	.+2      	; 0x9f4 <tinyDendrite_update_signals+0xba>
		}
		else
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     9f2:	10 82       	st	Z, r1
		}
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
     9f4:	8c 91       	ld	r24, X
     9f6:	98 13       	cpse	r25, r24
     9f8:	01 c0       	rjmp	.+2      	; 0x9fc <tinyDendrite_update_signals+0xc2>
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     9fa:	1c 92       	st	X, r1
     9fc:	31 96       	adiw	r30, 0x01	; 1
	tinyDebugger_send_uint8("D2", tinyDendrite_values[1]);
	tinyDebugger_send_uint8("D3", tinyDendrite_values[2]);
	tinyDebugger_send_uint8("D4", tinyDendrite_values[3]);
	tinyDebugger_send_uint8("D5", tinyDendrite_values[4]);
	
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
     9fe:	e4 17       	cp	r30, r20
     a00:	f5 07       	cpc	r31, r21
     a02:	99 f6       	brne	.-90     	; 0x9aa <tinyDendrite_update_signals+0x70>
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
		}
	}
}
     a04:	df 91       	pop	r29
     a06:	cf 91       	pop	r28
     a08:	1f 91       	pop	r17
     a0a:	0f 91       	pop	r16
     a0c:	ff 90       	pop	r15
     a0e:	ef 90       	pop	r14
     a10:	df 90       	pop	r13
     a12:	bf 90       	pop	r11
     a14:	af 90       	pop	r10
     a16:	08 95       	ret

00000a18 <tinyDendrite_get_potential>:
/*
This is the master function of the module that is callable from
outside. It uses the previously declared functions to return the potential.
*/
int16_t tinyDendrite_get_potential()
{
     a18:	cf 93       	push	r28
     a1a:	df 93       	push	r29
	if(tinyAxon_is_firing() && IGNORE_INPUT_WHILE_FIRING){
     a1c:	0e 94 5b 02 	call	0x4b6	; 0x4b6 <tinyAxon_is_firing>
		
		return NO_SIGNAL_REACTION;
	}
	
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
     a20:	0e 94 9d 04 	call	0x93a	; 0x93a <tinyDendrite_update_signals>
     a24:	eb e3       	ldi	r30, 0x3B	; 59
     a26:	f8 e3       	ldi	r31, 0x38	; 56
     a28:	20 e4       	ldi	r18, 0x40	; 64
     a2a:	38 e3       	ldi	r19, 0x38	; 56
	
	int16_t return_potential_val = 0;
     a2c:	c0 e0       	ldi	r28, 0x00	; 0
     a2e:	d0 e0       	ldi	r29, 0x00	; 0
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		switch(tinyDendrite_current_signals[i])
     a30:	81 91       	ld	r24, Z+
     a32:	83 30       	cpi	r24, 0x03	; 3
     a34:	89 f0       	breq	.+34     	; 0xa58 <tinyDendrite_get_potential+0x40>
     a36:	28 f4       	brcc	.+10     	; 0xa42 <tinyDendrite_get_potential+0x2a>
     a38:	81 30       	cpi	r24, 0x01	; 1
     a3a:	91 f0       	breq	.+36     	; 0xa60 <tinyDendrite_get_potential+0x48>
     a3c:	82 30       	cpi	r24, 0x02	; 2
     a3e:	71 f0       	breq	.+28     	; 0xa5c <tinyDendrite_get_potential+0x44>
     a40:	10 c0       	rjmp	.+32     	; 0xa62 <tinyDendrite_get_potential+0x4a>
     a42:	85 30       	cpi	r24, 0x05	; 5
     a44:	29 f0       	breq	.+10     	; 0xa50 <tinyDendrite_get_potential+0x38>
     a46:	30 f0       	brcs	.+12     	; 0xa54 <tinyDendrite_get_potential+0x3c>
     a48:	86 30       	cpi	r24, 0x06	; 6
     a4a:	59 f4       	brne	.+22     	; 0xa62 <tinyDendrite_get_potential+0x4a>
		{
			case NO_SIGNAL:
				return_potential_val += NO_SIGNAL_REACTION;
				break;
			case HIGH_EXCITE:
				return_potential_val += HIGH_EXCITE_REACTION;
     a4c:	e4 96       	adiw	r28, 0x34	; 52
				//tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
				// Used for signaling modified signals
				//tinyLED_set_color_mode(OUT_LED, BLUE, FLASH_ONCE);
				break;
     a4e:	09 c0       	rjmp	.+18     	; 0xa62 <tinyDendrite_get_potential+0x4a>
			case NORMAL_EXCITE:
				return_potential_val += NORMAL_EXCITE_REACTION;
     a50:	69 96       	adiw	r28, 0x19	; 25
				//tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
				break;
     a52:	07 c0       	rjmp	.+14     	; 0xa62 <tinyDendrite_get_potential+0x4a>
			case LOW_EXCITE:
				return_potential_val += LOW_EXCITE_REACTION;
     a54:	64 96       	adiw	r28, 0x14	; 20
				//tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
				//tinyLED_set_color_mode(OUT_LED, YELLOW, FLASH_ONCE);
				break;
     a56:	05 c0       	rjmp	.+10     	; 0xa62 <tinyDendrite_get_potential+0x4a>
			case HIGH_INHIB:
				return_potential_val += HIGH_INHIB_REACTION;
     a58:	e2 97       	sbiw	r28, 0x32	; 50
				//tinyLED_set_color_mode(INN_LED, RED, FLASH_ONCE);
				//tinyLED_set_color_mode(OUT_LED, BLUE, FLASH_ONCE);
				break;
     a5a:	03 c0       	rjmp	.+6      	; 0xa62 <tinyDendrite_get_potential+0x4a>
			case NORMAL_INHIB:
				return_potential_val += NORMAL_INHIB_REACTION;
     a5c:	69 97       	sbiw	r28, 0x19	; 25
				//tinyLED_set_color_mode(INN_LED, RED, FLASH_ONCE);
				break;
     a5e:	01 c0       	rjmp	.+2      	; 0xa62 <tinyDendrite_get_potential+0x4a>
			case LOW_INHIB:
				return_potential_val += LOW_INHIB_REACTION;
     a60:	64 97       	sbiw	r28, 0x14	; 20
	
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
	
	int16_t return_potential_val = 0;
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
     a62:	e2 17       	cp	r30, r18
     a64:	f3 07       	cpc	r31, r19
     a66:	21 f7       	brne	.-56     	; 0xa30 <tinyDendrite_get_potential+0x18>
			default:
				break;
		}
	}
	
	tinyDebugger_send_int("ReturnP", return_potential_val);
     a68:	be 01       	movw	r22, r28
     a6a:	87 e1       	ldi	r24, 0x17	; 23
     a6c:	9b e9       	ldi	r25, 0x9B	; 155
     a6e:	0e 94 5c 04 	call	0x8b8	; 0x8b8 <tinyDebugger_send_int>
	
	
	return return_potential_val;
	
}
     a72:	ce 01       	movw	r24, r28
     a74:	df 91       	pop	r29
     a76:	cf 91       	pop	r28
     a78:	08 95       	ret

00000a7a <tinyDendrite_update_potential>:

double tinyDendrite_update_potential(double potential){
     a7a:	cf 92       	push	r12
     a7c:	df 92       	push	r13
     a7e:	ef 92       	push	r14
     a80:	ff 92       	push	r15
     a82:	6b 01       	movw	r12, r22
     a84:	7c 01       	movw	r14, r24
	
	int16_t potential_change = tinyDendrite_get_potential();
     a86:	0e 94 0c 05 	call	0xa18	; 0xa18 <tinyDendrite_get_potential>
	/*
	We DON'T want to signal that we have recived a signal, we want to signal that the potential has changed!
	We could send flashes from here, but instead, I'll try to implement a light mode that is constantly communicating the value of the potential.
	*/
	
	return potential;
     a8a:	bc 01       	movw	r22, r24
     a8c:	99 0f       	add	r25, r25
     a8e:	88 0b       	sbc	r24, r24
     a90:	99 0b       	sbc	r25, r25
     a92:	0e 94 0b 0b 	call	0x1616	; 0x1616 <__floatsisf>
     a96:	a7 01       	movw	r20, r14
     a98:	96 01       	movw	r18, r12
     a9a:	0e 94 b6 09 	call	0x136c	; 0x136c <__addsf3>
     a9e:	ff 90       	pop	r15
     aa0:	ef 90       	pop	r14
     aa2:	df 90       	pop	r13
     aa4:	cf 90       	pop	r12
     aa6:	08 95       	ret

00000aa8 <__vector_6>:
This function is called every time the RTC (Real Time Clock) counter overflows.
With the current settings, it will be called every ms.
The RTC clock runs at 1kHz, and the number of cycles before overflow is set with RTC.PER = someHexValue (e.g. 0x20) in src/rtc.c
*/
ISR(RTC_CNT_vect)
{
     aa8:	1f 92       	push	r1
     aaa:	0f 92       	push	r0
     aac:	0f b6       	in	r0, 0x3f	; 63
     aae:	0f 92       	push	r0
     ab0:	11 24       	eor	r1, r1
     ab2:	2f 93       	push	r18
     ab4:	3f 93       	push	r19
     ab6:	4f 93       	push	r20
     ab8:	5f 93       	push	r21
     aba:	6f 93       	push	r22
     abc:	7f 93       	push	r23
     abe:	8f 93       	push	r24
     ac0:	9f 93       	push	r25
     ac2:	af 93       	push	r26
     ac4:	bf 93       	push	r27
     ac6:	cf 93       	push	r28
     ac8:	ef 93       	push	r30
     aca:	ff 93       	push	r31
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     acc:	c1 e0       	ldi	r28, 0x01	; 1
     ace:	c0 93 45 38 	sts	0x3845, r28	; 0x803845 <tinyISR_interrupt_flag>
{
	// Set flag to let main loop run a new cycle
	tinyISR_setflag(true);
	
	// Timer counter incrementation
	tinyTime_counter_increment();
     ad2:	0e 94 98 09 	call	0x1330	; 0x1330 <tinyTime_counter_increment>

	/* Overflow interrupt flag has to be cleared manually */
	RTC.INTFLAGS = RTC_OVF_bm;
     ad6:	c0 93 43 01 	sts	0x0143, r28	; 0x800143 <__TEXT_REGION_LENGTH__+0x700143>
}
     ada:	ff 91       	pop	r31
     adc:	ef 91       	pop	r30
     ade:	cf 91       	pop	r28
     ae0:	bf 91       	pop	r27
     ae2:	af 91       	pop	r26
     ae4:	9f 91       	pop	r25
     ae6:	8f 91       	pop	r24
     ae8:	7f 91       	pop	r23
     aea:	6f 91       	pop	r22
     aec:	5f 91       	pop	r21
     aee:	4f 91       	pop	r20
     af0:	3f 91       	pop	r19
     af2:	2f 91       	pop	r18
     af4:	0f 90       	pop	r0
     af6:	0f be       	out	0x3f, r0	; 63
     af8:	0f 90       	pop	r0
     afa:	1f 90       	pop	r1
     afc:	18 95       	reti

00000afe <tinyISR_setflag>:
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     afe:	80 93 45 38 	sts	0x3845, r24	; 0x803845 <tinyISR_interrupt_flag>
     b02:	08 95       	ret

00000b04 <tinyISR_getflag>:
}

_Bool tinyISR_getflag(void)
{
	return tinyISR_interrupt_flag;
}
     b04:	80 91 45 38 	lds	r24, 0x3845	; 0x803845 <tinyISR_interrupt_flag>
     b08:	08 95       	ret

00000b0a <tinyLED_SPIWriteByte>:
Function used to send a byte over SPI, which in turn gets
translated to the bit-sequence required by the LEDs over the CCL.
*/
static void tinyLED_SPIWriteByte(uint8_t byte)
{
	SPI0.INTFLAGS = SPI0_INTFLAGS; // clear the write collision flag to allow writing
     b0a:	90 91 23 08 	lds	r25, 0x0823	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
     b0e:	90 93 23 08 	sts	0x0823, r25	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
	TCA0.SINGLE.CNT = 0; // reset TCA counter register to ensure the first rising edge of the PWM is predictable
     b12:	e0 e0       	ldi	r30, 0x00	; 0
     b14:	fa e0       	ldi	r31, 0x0A	; 10
     b16:	10 a2       	std	Z+32, r1	; 0x20
     b18:	11 a2       	std	Z+33, r1	; 0x21
	
	// start TCA
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 1 << TCA_SPLIT_ENABLE_bp;
     b1a:	91 e0       	ldi	r25, 0x01	; 1
     b1c:	90 83       	st	Z, r25
	SPI0_DATA = byte;
     b1e:	80 93 24 08 	sts	0x0824, r24	; 0x800824 <__TEXT_REGION_LENGTH__+0x700824>

	while((SPI0.INTFLAGS & SPI_RXCIE_bm) == 0){} // wait for transfer to complete
     b22:	e0 e2       	ldi	r30, 0x20	; 32
     b24:	f8 e0       	ldi	r31, 0x08	; 8
     b26:	83 81       	ldd	r24, Z+3	; 0x03
     b28:	88 23       	and	r24, r24
     b2a:	ec f7       	brge	.-6      	; 0xb26 <tinyLED_SPIWriteByte+0x1c>
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 0 << TCA_SPLIT_ENABLE_bp; //Stop TCA
     b2c:	10 92 00 0a 	sts	0x0A00, r1	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
     b30:	08 95       	ret

00000b32 <tinyLED_get_color>:
	tinyLED_set_color_mode(LED_id, color, STABLE);
}

enum Colors tinyLED_get_color(uint8_t LED_id)
{
	return tinyLED_settings[LED_id].color;
     b32:	e8 2f       	mov	r30, r24
     b34:	f0 e0       	ldi	r31, 0x00	; 0
     b36:	ee 0f       	add	r30, r30
     b38:	ff 1f       	adc	r31, r31
     b3a:	e0 5b       	subi	r30, 0xB0	; 176
     b3c:	f7 4c       	sbci	r31, 0xC7	; 199
}
     b3e:	80 81       	ld	r24, Z
     b40:	08 95       	ret

00000b42 <tinyLED_set_color_mode>:
{
	// If we are in pulse mode, we want to stay in pulse mode after we have flashed a light.
	// We do this by storing the previous mode in old settings.
	// However, it can happen that two flashes comes very quickly after one another, that leads
	// to an infinite flash loop, therefore, we only store the settings if it is not flash mode.
	if(tinyLED_settings[LED_id].mode != FLASH_ONCE){
     b42:	90 e0       	ldi	r25, 0x00	; 0
     b44:	fc 01       	movw	r30, r24
     b46:	ee 0f       	add	r30, r30
     b48:	ff 1f       	adc	r31, r31
     b4a:	e0 5b       	subi	r30, 0xB0	; 176
     b4c:	f7 4c       	sbci	r31, 0xC7	; 199
     b4e:	51 81       	ldd	r21, Z+1	; 0x01
     b50:	55 30       	cpi	r21, 0x05	; 5
     b52:	61 f0       	breq	.+24     	; 0xb6c <tinyLED_set_color_mode+0x2a>
		// We use two lines to avoid pointer trouble. (I'm not good with pointers)
		tinyLED_old_settings[LED_id].color = tinyLED_settings[LED_id].color;
     b54:	9c 01       	movw	r18, r24
     b56:	22 0f       	add	r18, r18
     b58:	33 1f       	adc	r19, r19
     b5a:	f9 01       	movw	r30, r18
     b5c:	e4 5b       	subi	r30, 0xB4	; 180
     b5e:	f7 4c       	sbci	r31, 0xC7	; 199
     b60:	d9 01       	movw	r26, r18
     b62:	a0 5b       	subi	r26, 0xB0	; 176
     b64:	b7 4c       	sbci	r27, 0xC7	; 199
     b66:	2c 91       	ld	r18, X
     b68:	20 83       	st	Z, r18
		tinyLED_old_settings[LED_id].mode = tinyLED_settings[LED_id].mode;
     b6a:	51 83       	std	Z+1, r21	; 0x01
	}
	
	struct ColorSetting new_setting = {.color=color, .mode=mode};
	tinyLED_settings[LED_id] = new_setting;
     b6c:	fc 01       	movw	r30, r24
     b6e:	ee 0f       	add	r30, r30
     b70:	ff 1f       	adc	r31, r31
     b72:	e0 5b       	subi	r30, 0xB0	; 176
     b74:	f7 4c       	sbci	r31, 0xC7	; 199
     b76:	60 83       	st	Z, r22
     b78:	41 83       	std	Z+1, r20	; 0x01
	if (mode == FLASH_ONCE)
     b7a:	45 30       	cpi	r20, 0x05	; 5
     b7c:	49 f4       	brne	.+18     	; 0xb90 <tinyLED_set_color_mode+0x4e>
	{
		tinyLED_flash_once_time[LED_id] = 1000*FLASH_TIME;
     b7e:	88 0f       	add	r24, r24
     b80:	99 1f       	adc	r25, r25
     b82:	fc 01       	movw	r30, r24
     b84:	e8 59       	subi	r30, 0x98	; 152
     b86:	f7 4c       	sbci	r31, 0xC7	; 199
     b88:	84 e6       	ldi	r24, 0x64	; 100
     b8a:	90 e0       	ldi	r25, 0x00	; 0
     b8c:	80 83       	st	Z, r24
     b8e:	91 83       	std	Z+1, r25	; 0x01
     b90:	08 95       	ret

00000b92 <tinyLED_set_color>:
/*
changes the values in the variables stored in the LED-array.
*/
void tinyLED_set_color(uint8_t LED_id, enum Colors color)
{
	tinyLED_set_color_mode(LED_id, color, STABLE);
     b92:	40 e0       	ldi	r20, 0x00	; 0
     b94:	0e 94 a1 05 	call	0xb42	; 0xb42 <tinyLED_set_color_mode>
     b98:	08 95       	ret

00000b9a <tinyLED_RGB_Color_Compare>:
	return rgb_color;
			
};
// This might be cause of strange light behavior?
//Message		expected 'struct RGB_Color *' but argument is of type 'struct RGB_Color (*)[2]'	Hjernebyggesett_V4	C:\Users\Elias Lundheim\Documents\GitHub\neural\Hjernebyggesett_V4\Hjernebyggesett_V4\tinyLED\tinyLED.c	121
_Bool tinyLED_RGB_Color_Compare(struct RGB_Color (*a)[NUMBER_OF_LEDS], struct RGB_Color (*b)[NUMBER_OF_LEDS]){
     b9a:	dc 01       	movw	r26, r24
     b9c:	fb 01       	movw	r30, r22
	for (int i=0; i<NUMBER_OF_LEDS; i++)
	{
		if(!((*a)[i].red==(*b)[i].red && (*a)[i].green==(*b)[i].green && (*a)[i].blue==(*b)[i].blue)){
     b9e:	9c 91       	ld	r25, X
     ba0:	80 81       	ld	r24, Z
     ba2:	98 13       	cpse	r25, r24
     ba4:	20 c0       	rjmp	.+64     	; 0xbe6 <tinyLED_RGB_Color_Compare+0x4c>
     ba6:	11 96       	adiw	r26, 0x01	; 1
     ba8:	9c 91       	ld	r25, X
     baa:	11 97       	sbiw	r26, 0x01	; 1
     bac:	81 81       	ldd	r24, Z+1	; 0x01
     bae:	98 13       	cpse	r25, r24
     bb0:	1c c0       	rjmp	.+56     	; 0xbea <tinyLED_RGB_Color_Compare+0x50>
     bb2:	12 96       	adiw	r26, 0x02	; 2
     bb4:	9c 91       	ld	r25, X
     bb6:	12 97       	sbiw	r26, 0x02	; 2
     bb8:	82 81       	ldd	r24, Z+2	; 0x02
     bba:	98 13       	cpse	r25, r24
     bbc:	18 c0       	rjmp	.+48     	; 0xbee <tinyLED_RGB_Color_Compare+0x54>
     bbe:	13 96       	adiw	r26, 0x03	; 3
     bc0:	9c 91       	ld	r25, X
     bc2:	13 97       	sbiw	r26, 0x03	; 3
     bc4:	83 81       	ldd	r24, Z+3	; 0x03
     bc6:	98 13       	cpse	r25, r24
     bc8:	14 c0       	rjmp	.+40     	; 0xbf2 <tinyLED_RGB_Color_Compare+0x58>
     bca:	14 96       	adiw	r26, 0x04	; 4
     bcc:	9c 91       	ld	r25, X
     bce:	14 97       	sbiw	r26, 0x04	; 4
     bd0:	84 81       	ldd	r24, Z+4	; 0x04
     bd2:	98 13       	cpse	r25, r24
     bd4:	10 c0       	rjmp	.+32     	; 0xbf6 <tinyLED_RGB_Color_Compare+0x5c>
     bd6:	81 e0       	ldi	r24, 0x01	; 1
     bd8:	15 96       	adiw	r26, 0x05	; 5
     bda:	2c 91       	ld	r18, X
     bdc:	95 81       	ldd	r25, Z+5	; 0x05
     bde:	29 17       	cp	r18, r25
     be0:	59 f0       	breq	.+22     	; 0xbf8 <tinyLED_RGB_Color_Compare+0x5e>
     be2:	80 e0       	ldi	r24, 0x00	; 0
     be4:	08 95       	ret
			return false;
     be6:	80 e0       	ldi	r24, 0x00	; 0
     be8:	08 95       	ret
     bea:	80 e0       	ldi	r24, 0x00	; 0
     bec:	08 95       	ret
     bee:	80 e0       	ldi	r24, 0x00	; 0
     bf0:	08 95       	ret
     bf2:	80 e0       	ldi	r24, 0x00	; 0
     bf4:	08 95       	ret
     bf6:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	return true;
}
     bf8:	08 95       	ret

00000bfa <tinyLED_update>:
/*
function to write the current LED-array on to the LEDs and
effectively update the values stored in the LEDs to the values stored in the MCU.
*/
void tinyLED_update(void)
{
     bfa:	2f 92       	push	r2
     bfc:	3f 92       	push	r3
     bfe:	4f 92       	push	r4
     c00:	5f 92       	push	r5
     c02:	6f 92       	push	r6
     c04:	7f 92       	push	r7
     c06:	8f 92       	push	r8
     c08:	9f 92       	push	r9
     c0a:	af 92       	push	r10
     c0c:	bf 92       	push	r11
     c0e:	cf 92       	push	r12
     c10:	df 92       	push	r13
     c12:	ef 92       	push	r14
     c14:	ff 92       	push	r15
     c16:	0f 93       	push	r16
     c18:	1f 93       	push	r17
     c1a:	cf 93       	push	r28
     c1c:	df 93       	push	r29
     c1e:	cd b7       	in	r28, 0x3d	; 61
     c20:	de b7       	in	r29, 0x3e	; 62
     c22:	ae 97       	sbiw	r28, 0x2e	; 46
     c24:	cd bf       	out	0x3d, r28	; 61
     c26:	de bf       	out	0x3e, r29	; 62
			
	uint32_t now = tinyTime_now();
     c28:	0e 94 ac 09 	call	0x1358	; 0x1358 <tinyTime_now>
     c2c:	6b 01       	movw	r12, r22
     c2e:	7c 01       	movw	r14, r24
	uint8_t red = 0;
	uint8_t green = 0;
	
	// This is a sin curve, but between 0 and 1 instead of -1 and 1
	double sinValue = 0.5+sin((double)now/(100*M_PI/SWING_RATE))/2;
     c30:	0e 94 09 0b 	call	0x1612	; 0x1612 <__floatunsisf>
     c34:	23 e6       	ldi	r18, 0x63	; 99
     c36:	34 e1       	ldi	r19, 0x14	; 20
     c38:	4d e1       	ldi	r20, 0x1D	; 29
     c3a:	54 e4       	ldi	r21, 0x44	; 68
     c3c:	0e 94 27 0a 	call	0x144e	; 0x144e <__divsf3>
     c40:	0e 94 e9 0c 	call	0x19d2	; 0x19d2 <sin>
     c44:	20 e0       	ldi	r18, 0x00	; 0
     c46:	30 e0       	ldi	r19, 0x00	; 0
     c48:	40 e0       	ldi	r20, 0x00	; 0
     c4a:	5f e3       	ldi	r21, 0x3F	; 63
     c4c:	0e 94 7c 0c 	call	0x18f8	; 0x18f8 <__mulsf3>
     c50:	20 e0       	ldi	r18, 0x00	; 0
     c52:	30 e0       	ldi	r19, 0x00	; 0
     c54:	40 e0       	ldi	r20, 0x00	; 0
     c56:	5f e3       	ldi	r21, 0x3F	; 63
     c58:	0e 94 b6 09 	call	0x136c	; 0x136c <__addsf3>
     c5c:	69 87       	std	Y+9, r22	; 0x09
     c5e:	7a 87       	std	Y+10, r23	; 0x0a
     c60:	8b 87       	std	Y+11, r24	; 0x0b
     c62:	9c 87       	std	Y+12, r25	; 0x0c
	
	// If FLASH_RATE is one, then that means that the left side of the "<" will just count from 0 to 1000, and flash_on will be true for half of the time
	_Bool flash_on = now%(uint32_t)(1000/FLASH_RATE)  <   500/FLASH_RATE;
     c64:	c7 01       	movw	r24, r14
     c66:	b6 01       	movw	r22, r12
     c68:	28 ee       	ldi	r18, 0xE8	; 232
     c6a:	33 e0       	ldi	r19, 0x03	; 3
     c6c:	40 e0       	ldi	r20, 0x00	; 0
     c6e:	50 e0       	ldi	r21, 0x00	; 0
     c70:	0e 94 52 0d 	call	0x1aa4	; 0x1aa4 <__udivmodsi4>
     c74:	21 e0       	ldi	r18, 0x01	; 1
     c76:	2f 83       	std	Y+7, r18	; 0x07
     c78:	64 3f       	cpi	r22, 0xF4	; 244
     c7a:	71 40       	sbci	r23, 0x01	; 1
     c7c:	81 05       	cpc	r24, r1
     c7e:	91 05       	cpc	r25, r1
     c80:	08 f0       	brcs	.+2      	; 0xc84 <tinyLED_update+0x8a>
     c82:	1f 82       	std	Y+7, r1	; 0x07
	
	// PING_RATE is usually small, so the left side counts to some large number. Since flash_time usually is also quite small,
	// the left side will usually be larger than the right
	_Bool ping_on =  now%(uint32_t)(1000/PING_RATE)   <   1000*FLASH_TIME;
     c84:	c7 01       	movw	r24, r14
     c86:	b6 01       	movw	r22, r12
     c88:	20 e1       	ldi	r18, 0x10	; 16
     c8a:	37 e2       	ldi	r19, 0x27	; 39
     c8c:	40 e0       	ldi	r20, 0x00	; 0
     c8e:	50 e0       	ldi	r21, 0x00	; 0
     c90:	0e 94 52 0d 	call	0x1aa4	; 0x1aa4 <__udivmodsi4>
     c94:	0e 94 09 0b 	call	0x1612	; 0x1612 <__floatunsisf>
     c98:	20 e0       	ldi	r18, 0x00	; 0
     c9a:	30 e0       	ldi	r19, 0x00	; 0
     c9c:	48 ec       	ldi	r20, 0xC8	; 200
     c9e:	52 e4       	ldi	r21, 0x42	; 66
     ca0:	0e 94 22 0a 	call	0x1444	; 0x1444 <__cmpsf2>
     ca4:	18 2f       	mov	r17, r24
     ca6:	11 1f       	adc	r17, r17
     ca8:	11 27       	eor	r17, r17
     caa:	11 1f       	adc	r17, r17
	
	// Find potential 
	double tinyPotential_potental = tinyPotential_get_potential();
     cac:	0e 94 a2 08 	call	0x1144	; 0x1144 <tinyPotential_get_potential>
     cb0:	6d 87       	std	Y+13, r22	; 0x0d
     cb2:	7e 87       	std	Y+14, r23	; 0x0e
     cb4:	8f 87       	std	Y+15, r24	; 0x0f
     cb6:	98 8b       	std	Y+16, r25	; 0x10
	uint8_t tinyAxon_pulses_in_queue = tinyAxon_get_pulses_in_queue();
     cb8:	0e 94 62 02 	call	0x4c4	; 0x4c4 <tinyAxon_get_pulses_in_queue>
     cbc:	88 87       	std	Y+8, r24	; 0x08
	uint16_t time_until_next_pulse = tinyAxon_time_until_next_pulse();
     cbe:	0e 94 78 02 	call	0x4f0	; 0x4f0 <tinyAxon_time_until_next_pulse>
			
			case POTENTIAL:
				// In this mode, we try to communicate the level of the potential with color and brightness
				
				if(tinyPotential_potental > 0 || tinyAxon_pulses_in_queue > 0){
					green = fmin(255*LED_BRIGHTNESS * (tinyPotential_potental+tinyAxon_pulses_in_queue*THRESHOLD_POTENTIAL)/FULL_BRIGHTNESS_POTENTIAL, 255);
     cc2:	68 85       	ldd	r22, Y+8	; 0x08
     cc4:	59 e1       	ldi	r21, 0x19	; 25
     cc6:	65 9f       	mul	r22, r21
     cc8:	90 01       	movw	r18, r0
     cca:	11 24       	eor	r1, r1
     ccc:	0f 2e       	mov	r0, r31
     cce:	f0 e5       	ldi	r31, 0x50	; 80
     cd0:	2f 2e       	mov	r2, r31
     cd2:	f8 e3       	ldi	r31, 0x38	; 56
     cd4:	3f 2e       	mov	r3, r31
     cd6:	f0 2d       	mov	r31, r0
     cd8:	de 01       	movw	r26, r28
     cda:	11 96       	adiw	r26, 0x01	; 1
     cdc:	5d 01       	movw	r10, r26
     cde:	0f 2e       	mov	r0, r31
     ce0:	fc e4       	ldi	r31, 0x4C	; 76
     ce2:	4f 2e       	mov	r4, r31
     ce4:	f8 e3       	ldi	r31, 0x38	; 56
     ce6:	5f 2e       	mov	r5, r31
     ce8:	f0 2d       	mov	r31, r0
     cea:	0f 2e       	mov	r0, r31
     cec:	f8 e6       	ldi	r31, 0x68	; 104
     cee:	6f 2e       	mov	r6, r31
     cf0:	f8 e3       	ldi	r31, 0x38	; 56
     cf2:	7f 2e       	mov	r7, r31
     cf4:	f0 2d       	mov	r31, r0
     cf6:	0f 2e       	mov	r0, r31
     cf8:	f4 e5       	ldi	r31, 0x54	; 84
     cfa:	8f 2e       	mov	r8, r31
     cfc:	f8 e3       	ldi	r31, 0x38	; 56
     cfe:	9f 2e       	mov	r9, r31
     d00:	f0 2d       	mov	r31, r0
     d02:	6d 01       	movw	r12, r26
void tinyLED_update(void)
{
			
	uint32_t now = tinyTime_now();
	uint8_t red = 0;
	uint8_t green = 0;
     d04:	1d 8a       	std	Y+21, r1	; 0x15
*/
void tinyLED_update(void)
{
			
	uint32_t now = tinyTime_now();
	uint8_t red = 0;
     d06:	1e 8a       	std	Y+22, r1	; 0x16
				break;
				
			case FLASH_ONCE:
				if(tinyLED_flash_once_time[i]>0){
					// Check if flash is inside off period
					if(time_until_next_pulse < FLASH_OFF_TIME*1000){
     d08:	ac 01       	movw	r20, r24
     d0a:	60 e0       	ldi	r22, 0x00	; 0
     d0c:	70 e0       	ldi	r23, 0x00	; 0
     d0e:	4f 8f       	std	Y+31, r20	; 0x1f
     d10:	58 a3       	std	Y+32, r21	; 0x20
     d12:	69 a3       	std	Y+33, r22	; 0x21
     d14:	7a a3       	std	Y+34, r23	; 0x22
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*sinValue, rgb_colors[i].green*sinValue, rgb_colors[i].blue*sinValue};
				break;
				
			case PING:
				// in the line below, fmin will either return 1 or 0, so each rgb color is either 0 or 255*PING_BRIGHTNESS
				rgb_colors[i] = (struct RGB_Color){255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].red)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].green)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].blue)*ping_on};
     d16:	61 2f       	mov	r22, r17
     d18:	70 e0       	ldi	r23, 0x00	; 0
     d1a:	80 e0       	ldi	r24, 0x00	; 0
     d1c:	90 e0       	ldi	r25, 0x00	; 0
     d1e:	6f 8b       	std	Y+23, r22	; 0x17
     d20:	78 8f       	std	Y+24, r23	; 0x18
     d22:	89 8f       	std	Y+25, r24	; 0x19
     d24:	9a 8f       	std	Y+26, r25	; 0x1a
			
			case POTENTIAL:
				// In this mode, we try to communicate the level of the potential with color and brightness
				
				if(tinyPotential_potental > 0 || tinyAxon_pulses_in_queue > 0){
					green = fmin(255*LED_BRIGHTNESS * (tinyPotential_potental+tinyAxon_pulses_in_queue*THRESHOLD_POTENTIAL)/FULL_BRIGHTNESS_POTENTIAL, 255);
     d26:	c9 01       	movw	r24, r18
     d28:	33 0f       	add	r19, r19
     d2a:	aa 0b       	sbc	r26, r26
     d2c:	bb 0b       	sbc	r27, r27
     d2e:	8b 8f       	std	Y+27, r24	; 0x1b
     d30:	9c 8f       	std	Y+28, r25	; 0x1c
     d32:	ad 8f       	std	Y+29, r26	; 0x1d
     d34:	be 8f       	std	Y+30, r27	; 0x1e
     d36:	f1 01       	movw	r30, r2
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 0 << TCA_SPLIT_ENABLE_bp; //Stop TCA
}

static struct RGB_Color tinyLED_enum_to_RGB_Color(enum Colors color){
	struct RGB_Color rgb_color;
	switch(color)
     d38:	80 81       	ld	r24, Z
     d3a:	84 30       	cpi	r24, 0x04	; 4
     d3c:	79 f0       	breq	.+30     	; 0xd5c <tinyLED_update+0x162>
     d3e:	28 f4       	brcc	.+10     	; 0xd4a <tinyLED_update+0x150>
     d40:	82 30       	cpi	r24, 0x02	; 2
     d42:	41 f0       	breq	.+16     	; 0xd54 <tinyLED_update+0x15a>
     d44:	83 30       	cpi	r24, 0x03	; 3
     d46:	71 f0       	breq	.+28     	; 0xd64 <tinyLED_update+0x16a>
     d48:	19 c0       	rjmp	.+50     	; 0xd7c <tinyLED_update+0x182>
     d4a:	85 30       	cpi	r24, 0x05	; 5
     d4c:	79 f0       	breq	.+30     	; 0xd6c <tinyLED_update+0x172>
     d4e:	86 30       	cpi	r24, 0x06	; 6
     d50:	89 f0       	breq	.+34     	; 0xd74 <tinyLED_update+0x17a>
     d52:	14 c0       	rjmp	.+40     	; 0xd7c <tinyLED_update+0x182>
	{
		case LED_OFF:
			rgb_color = (struct RGB_Color){0, 0, 0};
			break;
		case RED:
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 0, 0};
     d54:	10 e0       	ldi	r17, 0x00	; 0
     d56:	00 e0       	ldi	r16, 0x00	; 0
     d58:	69 e1       	ldi	r22, 0x19	; 25
     d5a:	13 c0       	rjmp	.+38     	; 0xd82 <tinyLED_update+0x188>
			break;
		case GREEN:
			rgb_color = (struct RGB_Color){0, 255*LED_BRIGHTNESS, 0};
     d5c:	10 e0       	ldi	r17, 0x00	; 0
     d5e:	09 e1       	ldi	r16, 0x19	; 25
     d60:	60 e0       	ldi	r22, 0x00	; 0
     d62:	0f c0       	rjmp	.+30     	; 0xd82 <tinyLED_update+0x188>
			break;
		case BLUE:
			rgb_color = (struct RGB_Color){0, 0, 255*LED_BRIGHTNESS};
     d64:	19 e1       	ldi	r17, 0x19	; 25
     d66:	00 e0       	ldi	r16, 0x00	; 0
     d68:	60 e0       	ldi	r22, 0x00	; 0
     d6a:	0b c0       	rjmp	.+22     	; 0xd82 <tinyLED_update+0x188>
			break;
		case YELLOW:
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS, 0};
     d6c:	10 e0       	ldi	r17, 0x00	; 0
     d6e:	09 e1       	ldi	r16, 0x19	; 25
     d70:	69 e1       	ldi	r22, 0x19	; 25
     d72:	07 c0       	rjmp	.+14     	; 0xd82 <tinyLED_update+0x188>
			// Should the /3 be there? This requires testing.
			// After testing, findings were that at 0.1 brightness, one would see the three LEDs instead of one white led
			// We try with /2 instead.
			// We find that the best results come from not dividing by anything. At leasts in the lower brightness settings, and that
			// is where we suspect it will be most of the time. When we divide, the LEDs are so weak, that they appear as three lights instead of one.
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS};
     d74:	19 e1       	ldi	r17, 0x19	; 25
     d76:	09 e1       	ldi	r16, 0x19	; 25
     d78:	69 e1       	ldi	r22, 0x19	; 25
     d7a:	03 c0       	rjmp	.+6      	; 0xd82 <tinyLED_update+0x188>
static struct RGB_Color tinyLED_enum_to_RGB_Color(enum Colors color){
	struct RGB_Color rgb_color;
	switch(color)
	{
		case LED_OFF:
			rgb_color = (struct RGB_Color){0, 0, 0};
     d7c:	10 e0       	ldi	r17, 0x00	; 0
     d7e:	00 e0       	ldi	r16, 0x00	; 0
     d80:	60 e0       	ldi	r22, 0x00	; 0
     d82:	76 01       	movw	r14, r12
	
	
	for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
	{		
		// Convert enum to RGB_Color
		rgb_colors[i] = tinyLED_enum_to_RGB_Color(tinyLED_settings[i].color);
     d84:	d6 01       	movw	r26, r12
     d86:	6c 93       	st	X, r22
     d88:	11 96       	adiw	r26, 0x01	; 1
     d8a:	0c 93       	st	X, r16
     d8c:	11 97       	sbiw	r26, 0x01	; 1
     d8e:	12 96       	adiw	r26, 0x02	; 2
     d90:	1c 93       	st	X, r17
		
		// Adjust colors according to mode
		switch(tinyLED_settings[i].mode)
     d92:	81 81       	ldd	r24, Z+1	; 0x01
     d94:	83 30       	cpi	r24, 0x03	; 3
     d96:	09 f4       	brne	.+2      	; 0xd9a <tinyLED_update+0x1a0>
     d98:	52 c0       	rjmp	.+164    	; 0xe3e <tinyLED_update+0x244>
     d9a:	28 f4       	brcc	.+10     	; 0xda6 <tinyLED_update+0x1ac>
     d9c:	81 30       	cpi	r24, 0x01	; 1
     d9e:	61 f0       	breq	.+24     	; 0xdb8 <tinyLED_update+0x1be>
     da0:	82 30       	cpi	r24, 0x02	; 2
     da2:	d9 f1       	breq	.+118    	; 0xe1a <tinyLED_update+0x220>
     da4:	80 c1       	rjmp	.+768    	; 0x10a6 <tinyLED_update+0x4ac>
     da6:	85 30       	cpi	r24, 0x05	; 5
     da8:	09 f4       	brne	.+2      	; 0xdac <tinyLED_update+0x1b2>
     daa:	f7 c0       	rjmp	.+494    	; 0xf9a <tinyLED_update+0x3a0>
     dac:	08 f4       	brcc	.+2      	; 0xdb0 <tinyLED_update+0x1b6>
     dae:	78 c0       	rjmp	.+240    	; 0xea0 <tinyLED_update+0x2a6>
     db0:	86 30       	cpi	r24, 0x06	; 6
     db2:	09 f4       	brne	.+2      	; 0xdb6 <tinyLED_update+0x1bc>
     db4:	1a c1       	rjmp	.+564    	; 0xfea <tinyLED_update+0x3f0>
     db6:	77 c1       	rjmp	.+750    	; 0x10a6 <tinyLED_update+0x4ac>
		{
			case STABLE:
				break;
				
			case WEAK:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*WEAK_BRIGHTNESS, rgb_colors[i].green*WEAK_BRIGHTNESS, rgb_colors[i].blue*WEAK_BRIGHTNESS};
     db8:	70 e0       	ldi	r23, 0x00	; 0
     dba:	80 e0       	ldi	r24, 0x00	; 0
     dbc:	90 e0       	ldi	r25, 0x00	; 0
     dbe:	0e 94 0b 0b 	call	0x1616	; 0x1616 <__floatsisf>
     dc2:	2d ec       	ldi	r18, 0xCD	; 205
     dc4:	3c ec       	ldi	r19, 0xCC	; 204
     dc6:	4c ec       	ldi	r20, 0xCC	; 204
     dc8:	5d e3       	ldi	r21, 0x3D	; 61
     dca:	0e 94 7c 0c 	call	0x18f8	; 0x18f8 <__mulsf3>
     dce:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <__fixunssfsi>
     dd2:	f6 01       	movw	r30, r12
     dd4:	60 83       	st	Z, r22
     dd6:	60 2f       	mov	r22, r16
     dd8:	70 e0       	ldi	r23, 0x00	; 0
     dda:	80 e0       	ldi	r24, 0x00	; 0
     ddc:	90 e0       	ldi	r25, 0x00	; 0
     dde:	0e 94 0b 0b 	call	0x1616	; 0x1616 <__floatsisf>
     de2:	2d ec       	ldi	r18, 0xCD	; 205
     de4:	3c ec       	ldi	r19, 0xCC	; 204
     de6:	4c ec       	ldi	r20, 0xCC	; 204
     de8:	5d e3       	ldi	r21, 0x3D	; 61
     dea:	0e 94 7c 0c 	call	0x18f8	; 0x18f8 <__mulsf3>
     dee:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <__fixunssfsi>
     df2:	d6 01       	movw	r26, r12
     df4:	11 96       	adiw	r26, 0x01	; 1
     df6:	6c 93       	st	X, r22
     df8:	61 2f       	mov	r22, r17
     dfa:	70 e0       	ldi	r23, 0x00	; 0
     dfc:	80 e0       	ldi	r24, 0x00	; 0
     dfe:	90 e0       	ldi	r25, 0x00	; 0
     e00:	0e 94 0b 0b 	call	0x1616	; 0x1616 <__floatsisf>
     e04:	2d ec       	ldi	r18, 0xCD	; 205
     e06:	3c ec       	ldi	r19, 0xCC	; 204
     e08:	4c ec       	ldi	r20, 0xCC	; 204
     e0a:	5d e3       	ldi	r21, 0x3D	; 61
     e0c:	0e 94 7c 0c 	call	0x18f8	; 0x18f8 <__mulsf3>
     e10:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <__fixunssfsi>
     e14:	f6 01       	movw	r30, r12
     e16:	62 83       	std	Z+2, r22	; 0x02
				break;
     e18:	46 c1       	rjmp	.+652    	; 0x10a6 <tinyLED_update+0x4ac>
				
			case FLASH:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*flash_on, rgb_colors[i].green*flash_on, rgb_colors[i].blue*flash_on};
     e1a:	ff 81       	ldd	r31, Y+7	; 0x07
     e1c:	f6 9f       	mul	r31, r22
     e1e:	60 2d       	mov	r22, r0
     e20:	11 24       	eor	r1, r1
     e22:	d6 01       	movw	r26, r12
     e24:	6c 93       	st	X, r22
     e26:	f0 9f       	mul	r31, r16
     e28:	00 2d       	mov	r16, r0
     e2a:	11 24       	eor	r1, r1
     e2c:	11 96       	adiw	r26, 0x01	; 1
     e2e:	0c 93       	st	X, r16
     e30:	11 97       	sbiw	r26, 0x01	; 1
     e32:	f1 9f       	mul	r31, r17
     e34:	10 2d       	mov	r17, r0
     e36:	11 24       	eor	r1, r1
     e38:	12 96       	adiw	r26, 0x02	; 2
     e3a:	1c 93       	st	X, r17
				break;
     e3c:	34 c1       	rjmp	.+616    	; 0x10a6 <tinyLED_update+0x4ac>
				
			case SWING:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*sinValue, rgb_colors[i].green*sinValue, rgb_colors[i].blue*sinValue};
     e3e:	70 e0       	ldi	r23, 0x00	; 0
     e40:	80 e0       	ldi	r24, 0x00	; 0
     e42:	90 e0       	ldi	r25, 0x00	; 0
     e44:	0e 94 0b 0b 	call	0x1616	; 0x1616 <__floatsisf>
     e48:	29 85       	ldd	r18, Y+9	; 0x09
     e4a:	3a 85       	ldd	r19, Y+10	; 0x0a
     e4c:	4b 85       	ldd	r20, Y+11	; 0x0b
     e4e:	5c 85       	ldd	r21, Y+12	; 0x0c
     e50:	0e 94 7c 0c 	call	0x18f8	; 0x18f8 <__mulsf3>
     e54:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <__fixunssfsi>
     e58:	f6 01       	movw	r30, r12
     e5a:	60 83       	st	Z, r22
     e5c:	60 2f       	mov	r22, r16
     e5e:	70 e0       	ldi	r23, 0x00	; 0
     e60:	80 e0       	ldi	r24, 0x00	; 0
     e62:	90 e0       	ldi	r25, 0x00	; 0
     e64:	0e 94 0b 0b 	call	0x1616	; 0x1616 <__floatsisf>
     e68:	29 85       	ldd	r18, Y+9	; 0x09
     e6a:	3a 85       	ldd	r19, Y+10	; 0x0a
     e6c:	4b 85       	ldd	r20, Y+11	; 0x0b
     e6e:	5c 85       	ldd	r21, Y+12	; 0x0c
     e70:	0e 94 7c 0c 	call	0x18f8	; 0x18f8 <__mulsf3>
     e74:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <__fixunssfsi>
     e78:	d6 01       	movw	r26, r12
     e7a:	11 96       	adiw	r26, 0x01	; 1
     e7c:	6c 93       	st	X, r22
     e7e:	61 2f       	mov	r22, r17
     e80:	70 e0       	ldi	r23, 0x00	; 0
     e82:	80 e0       	ldi	r24, 0x00	; 0
     e84:	90 e0       	ldi	r25, 0x00	; 0
     e86:	0e 94 0b 0b 	call	0x1616	; 0x1616 <__floatsisf>
     e8a:	29 85       	ldd	r18, Y+9	; 0x09
     e8c:	3a 85       	ldd	r19, Y+10	; 0x0a
     e8e:	4b 85       	ldd	r20, Y+11	; 0x0b
     e90:	5c 85       	ldd	r21, Y+12	; 0x0c
     e92:	0e 94 7c 0c 	call	0x18f8	; 0x18f8 <__mulsf3>
     e96:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <__fixunssfsi>
     e9a:	f6 01       	movw	r30, r12
     e9c:	62 83       	std	Z+2, r22	; 0x02
				break;
     e9e:	03 c1       	rjmp	.+518    	; 0x10a6 <tinyLED_update+0x4ac>
				
			case PING:
				// in the line below, fmin will either return 1 or 0, so each rgb color is either 0 or 255*PING_BRIGHTNESS
				rgb_colors[i] = (struct RGB_Color){255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].red)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].green)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].blue)*ping_on};
     ea0:	70 e0       	ldi	r23, 0x00	; 0
     ea2:	80 e0       	ldi	r24, 0x00	; 0
     ea4:	90 e0       	ldi	r25, 0x00	; 0
     ea6:	0e 94 09 0b 	call	0x1612	; 0x1612 <__floatunsisf>
     eaa:	9b 01       	movw	r18, r22
     eac:	ac 01       	movw	r20, r24
     eae:	60 e0       	ldi	r22, 0x00	; 0
     eb0:	70 e0       	ldi	r23, 0x00	; 0
     eb2:	80 e8       	ldi	r24, 0x80	; 128
     eb4:	9f e3       	ldi	r25, 0x3F	; 63
     eb6:	0e 94 46 0b 	call	0x168c	; 0x168c <fmin>
     eba:	6b a3       	std	Y+35, r22	; 0x23
     ebc:	7c a3       	std	Y+36, r23	; 0x24
     ebe:	8d a3       	std	Y+37, r24	; 0x25
     ec0:	9e a3       	std	Y+38, r25	; 0x26
     ec2:	6f 89       	ldd	r22, Y+23	; 0x17
     ec4:	78 8d       	ldd	r23, Y+24	; 0x18
     ec6:	89 8d       	ldd	r24, Y+25	; 0x19
     ec8:	9a 8d       	ldd	r25, Y+26	; 0x1a
     eca:	0e 94 0b 0b 	call	0x1616	; 0x1616 <__floatsisf>
     ece:	69 8b       	std	Y+17, r22	; 0x11
     ed0:	7a 8b       	std	Y+18, r23	; 0x12
     ed2:	8b 8b       	std	Y+19, r24	; 0x13
     ed4:	9c 8b       	std	Y+20, r25	; 0x14
     ed6:	60 2f       	mov	r22, r16
     ed8:	70 e0       	ldi	r23, 0x00	; 0
     eda:	80 e0       	ldi	r24, 0x00	; 0
     edc:	90 e0       	ldi	r25, 0x00	; 0
     ede:	0e 94 09 0b 	call	0x1612	; 0x1612 <__floatunsisf>
     ee2:	9b 01       	movw	r18, r22
     ee4:	ac 01       	movw	r20, r24
     ee6:	60 e0       	ldi	r22, 0x00	; 0
     ee8:	70 e0       	ldi	r23, 0x00	; 0
     eea:	80 e8       	ldi	r24, 0x80	; 128
     eec:	9f e3       	ldi	r25, 0x3F	; 63
     eee:	0e 94 46 0b 	call	0x168c	; 0x168c <fmin>
     ef2:	6f a3       	std	Y+39, r22	; 0x27
     ef4:	78 a7       	std	Y+40, r23	; 0x28
     ef6:	89 a7       	std	Y+41, r24	; 0x29
     ef8:	9a a7       	std	Y+42, r25	; 0x2a
     efa:	61 2f       	mov	r22, r17
     efc:	70 e0       	ldi	r23, 0x00	; 0
     efe:	80 e0       	ldi	r24, 0x00	; 0
     f00:	90 e0       	ldi	r25, 0x00	; 0
     f02:	0e 94 09 0b 	call	0x1612	; 0x1612 <__floatunsisf>
     f06:	9b 01       	movw	r18, r22
     f08:	ac 01       	movw	r20, r24
     f0a:	60 e0       	ldi	r22, 0x00	; 0
     f0c:	70 e0       	ldi	r23, 0x00	; 0
     f0e:	80 e8       	ldi	r24, 0x80	; 128
     f10:	9f e3       	ldi	r25, 0x3F	; 63
     f12:	0e 94 46 0b 	call	0x168c	; 0x168c <fmin>
     f16:	6b a7       	std	Y+43, r22	; 0x2b
     f18:	7c a7       	std	Y+44, r23	; 0x2c
     f1a:	8d a7       	std	Y+45, r24	; 0x2d
     f1c:	9e a7       	std	Y+46, r25	; 0x2e
     f1e:	23 e3       	ldi	r18, 0x33	; 51
     f20:	33 e3       	ldi	r19, 0x33	; 51
     f22:	43 ea       	ldi	r20, 0xA3	; 163
     f24:	50 e4       	ldi	r21, 0x40	; 64
     f26:	6b a1       	ldd	r22, Y+35	; 0x23
     f28:	7c a1       	ldd	r23, Y+36	; 0x24
     f2a:	8d a1       	ldd	r24, Y+37	; 0x25
     f2c:	9e a1       	ldd	r25, Y+38	; 0x26
     f2e:	0e 94 7c 0c 	call	0x18f8	; 0x18f8 <__mulsf3>
     f32:	29 89       	ldd	r18, Y+17	; 0x11
     f34:	3a 89       	ldd	r19, Y+18	; 0x12
     f36:	4b 89       	ldd	r20, Y+19	; 0x13
     f38:	5c 89       	ldd	r21, Y+20	; 0x14
     f3a:	0e 94 7c 0c 	call	0x18f8	; 0x18f8 <__mulsf3>
     f3e:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <__fixunssfsi>
     f42:	d6 01       	movw	r26, r12
     f44:	6c 93       	st	X, r22
     f46:	23 e3       	ldi	r18, 0x33	; 51
     f48:	33 e3       	ldi	r19, 0x33	; 51
     f4a:	43 ea       	ldi	r20, 0xA3	; 163
     f4c:	50 e4       	ldi	r21, 0x40	; 64
     f4e:	6f a1       	ldd	r22, Y+39	; 0x27
     f50:	78 a5       	ldd	r23, Y+40	; 0x28
     f52:	89 a5       	ldd	r24, Y+41	; 0x29
     f54:	9a a5       	ldd	r25, Y+42	; 0x2a
     f56:	0e 94 7c 0c 	call	0x18f8	; 0x18f8 <__mulsf3>
     f5a:	29 89       	ldd	r18, Y+17	; 0x11
     f5c:	3a 89       	ldd	r19, Y+18	; 0x12
     f5e:	4b 89       	ldd	r20, Y+19	; 0x13
     f60:	5c 89       	ldd	r21, Y+20	; 0x14
     f62:	0e 94 7c 0c 	call	0x18f8	; 0x18f8 <__mulsf3>
     f66:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <__fixunssfsi>
     f6a:	f6 01       	movw	r30, r12
     f6c:	61 83       	std	Z+1, r22	; 0x01
     f6e:	23 e3       	ldi	r18, 0x33	; 51
     f70:	33 e3       	ldi	r19, 0x33	; 51
     f72:	43 ea       	ldi	r20, 0xA3	; 163
     f74:	50 e4       	ldi	r21, 0x40	; 64
     f76:	6b a5       	ldd	r22, Y+43	; 0x2b
     f78:	7c a5       	ldd	r23, Y+44	; 0x2c
     f7a:	8d a5       	ldd	r24, Y+45	; 0x2d
     f7c:	9e a5       	ldd	r25, Y+46	; 0x2e
     f7e:	0e 94 7c 0c 	call	0x18f8	; 0x18f8 <__mulsf3>
     f82:	29 89       	ldd	r18, Y+17	; 0x11
     f84:	3a 89       	ldd	r19, Y+18	; 0x12
     f86:	4b 89       	ldd	r20, Y+19	; 0x13
     f88:	5c 89       	ldd	r21, Y+20	; 0x14
     f8a:	0e 94 7c 0c 	call	0x18f8	; 0x18f8 <__mulsf3>
     f8e:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <__fixunssfsi>
     f92:	d6 01       	movw	r26, r12
     f94:	12 96       	adiw	r26, 0x02	; 2
     f96:	6c 93       	st	X, r22
				break;
     f98:	86 c0       	rjmp	.+268    	; 0x10a6 <tinyLED_update+0x4ac>
     f9a:	69 8a       	std	Y+17, r6	; 0x11
     f9c:	7a 8a       	std	Y+18, r7	; 0x12
				
			case FLASH_ONCE:
				if(tinyLED_flash_once_time[i]>0){
     f9e:	d3 01       	movw	r26, r6
     fa0:	0d 91       	ld	r16, X+
     fa2:	1c 91       	ld	r17, X
     fa4:	01 15       	cp	r16, r1
     fa6:	11 05       	cpc	r17, r1
     fa8:	c9 f0       	breq	.+50     	; 0xfdc <tinyLED_update+0x3e2>
					// Check if flash is inside off period
					if(time_until_next_pulse < FLASH_OFF_TIME*1000){
     faa:	6f 8d       	ldd	r22, Y+31	; 0x1f
     fac:	78 a1       	ldd	r23, Y+32	; 0x20
     fae:	89 a1       	ldd	r24, Y+33	; 0x21
     fb0:	9a a1       	ldd	r25, Y+34	; 0x22
     fb2:	0e 94 09 0b 	call	0x1612	; 0x1612 <__floatunsisf>
     fb6:	20 e0       	ldi	r18, 0x00	; 0
     fb8:	30 e0       	ldi	r19, 0x00	; 0
     fba:	40 e4       	ldi	r20, 0x40	; 64
     fbc:	51 e4       	ldi	r21, 0x41	; 65
     fbe:	0e 94 22 0a 	call	0x1444	; 0x1444 <__cmpsf2>
     fc2:	88 23       	and	r24, r24
     fc4:	24 f4       	brge	.+8      	; 0xfce <tinyLED_update+0x3d4>
						// This is used to separate flashes
						rgb_colors[i] = (struct RGB_Color){0, 0, 0};
     fc6:	f6 01       	movw	r30, r12
     fc8:	10 82       	st	Z, r1
     fca:	11 82       	std	Z+1, r1	; 0x01
     fcc:	12 82       	std	Z+2, r1	; 0x02
					}
					tinyLED_flash_once_time[i]--;
     fce:	01 50       	subi	r16, 0x01	; 1
     fd0:	11 09       	sbc	r17, r1
     fd2:	a9 89       	ldd	r26, Y+17	; 0x11
     fd4:	ba 89       	ldd	r27, Y+18	; 0x12
     fd6:	0d 93       	st	X+, r16
     fd8:	1c 93       	st	X, r17
     fda:	65 c0       	rjmp	.+202    	; 0x10a6 <tinyLED_update+0x4ac>
				}
				else{
					// Here we return to the previous color and mode
					tinyLED_settings[i].color = tinyLED_old_settings[i].color;
     fdc:	d2 01       	movw	r26, r4
     fde:	8c 91       	ld	r24, X
     fe0:	80 83       	st	Z, r24
					tinyLED_settings[i].mode = tinyLED_old_settings[i].mode;
     fe2:	11 96       	adiw	r26, 0x01	; 1
     fe4:	8c 91       	ld	r24, X
     fe6:	81 83       	std	Z+1, r24	; 0x01
     fe8:	5e c0       	rjmp	.+188    	; 0x10a6 <tinyLED_update+0x4ac>
				break;
			
			case POTENTIAL:
				// In this mode, we try to communicate the level of the potential with color and brightness
				
				if(tinyPotential_potental > 0 || tinyAxon_pulses_in_queue > 0){
     fea:	20 e0       	ldi	r18, 0x00	; 0
     fec:	30 e0       	ldi	r19, 0x00	; 0
     fee:	a9 01       	movw	r20, r18
     ff0:	6d 85       	ldd	r22, Y+13	; 0x0d
     ff2:	7e 85       	ldd	r23, Y+14	; 0x0e
     ff4:	8f 85       	ldd	r24, Y+15	; 0x0f
     ff6:	98 89       	ldd	r25, Y+16	; 0x10
     ff8:	0e 94 01 0c 	call	0x1802	; 0x1802 <__gesf2>
     ffc:	18 16       	cp	r1, r24
     ffe:	1c f0       	brlt	.+6      	; 0x1006 <tinyLED_update+0x40c>
    1000:	b8 85       	ldd	r27, Y+8	; 0x08
    1002:	bb 23       	and	r27, r27
    1004:	11 f1       	breq	.+68     	; 0x104a <tinyLED_update+0x450>
					green = fmin(255*LED_BRIGHTNESS * (tinyPotential_potental+tinyAxon_pulses_in_queue*THRESHOLD_POTENTIAL)/FULL_BRIGHTNESS_POTENTIAL, 255);
    1006:	6b 8d       	ldd	r22, Y+27	; 0x1b
    1008:	7c 8d       	ldd	r23, Y+28	; 0x1c
    100a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    100c:	9e 8d       	ldd	r25, Y+30	; 0x1e
    100e:	0e 94 0b 0b 	call	0x1616	; 0x1616 <__floatsisf>
    1012:	2d 85       	ldd	r18, Y+13	; 0x0d
    1014:	3e 85       	ldd	r19, Y+14	; 0x0e
    1016:	4f 85       	ldd	r20, Y+15	; 0x0f
    1018:	58 89       	ldd	r21, Y+16	; 0x10
    101a:	0e 94 b6 09 	call	0x136c	; 0x136c <__addsf3>
    101e:	20 e0       	ldi	r18, 0x00	; 0
    1020:	30 e0       	ldi	r19, 0x00	; 0
    1022:	4c ec       	ldi	r20, 0xCC	; 204
    1024:	51 e4       	ldi	r21, 0x41	; 65
    1026:	0e 94 7c 0c 	call	0x18f8	; 0x18f8 <__mulsf3>
    102a:	20 e0       	ldi	r18, 0x00	; 0
    102c:	30 e0       	ldi	r19, 0x00	; 0
    102e:	48 ec       	ldi	r20, 0xC8	; 200
    1030:	51 e4       	ldi	r21, 0x41	; 65
    1032:	0e 94 27 0a 	call	0x144e	; 0x144e <__divsf3>
    1036:	20 e0       	ldi	r18, 0x00	; 0
    1038:	30 e0       	ldi	r19, 0x00	; 0
    103a:	4f e7       	ldi	r20, 0x7F	; 127
    103c:	53 e4       	ldi	r21, 0x43	; 67
    103e:	0e 94 46 0b 	call	0x168c	; 0x168c <fmin>
    1042:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <__fixunssfsi>
    1046:	6d 8b       	std	Y+21, r22	; 0x15
    1048:	28 c0       	rjmp	.+80     	; 0x109a <tinyLED_update+0x4a0>
				}
				else{
					red = fmin(255*LED_BRIGHTNESS * abs(tinyPotential_potental)/FULL_BRIGHTNESS_POTENTIAL, 255);
    104a:	6d 85       	ldd	r22, Y+13	; 0x0d
    104c:	7e 85       	ldd	r23, Y+14	; 0x0e
    104e:	8f 85       	ldd	r24, Y+15	; 0x0f
    1050:	98 89       	ldd	r25, Y+16	; 0x10
    1052:	0e 94 d3 0a 	call	0x15a6	; 0x15a6 <__fixsfsi>
    1056:	9b 01       	movw	r18, r22
    1058:	77 23       	and	r23, r23
    105a:	24 f4       	brge	.+8      	; 0x1064 <tinyLED_update+0x46a>
    105c:	22 27       	eor	r18, r18
    105e:	33 27       	eor	r19, r19
    1060:	26 1b       	sub	r18, r22
    1062:	37 0b       	sbc	r19, r23
    1064:	b9 01       	movw	r22, r18
    1066:	33 0f       	add	r19, r19
    1068:	88 0b       	sbc	r24, r24
    106a:	99 0b       	sbc	r25, r25
    106c:	0e 94 0b 0b 	call	0x1616	; 0x1616 <__floatsisf>
    1070:	20 e0       	ldi	r18, 0x00	; 0
    1072:	30 e0       	ldi	r19, 0x00	; 0
    1074:	4c ec       	ldi	r20, 0xCC	; 204
    1076:	51 e4       	ldi	r21, 0x41	; 65
    1078:	0e 94 7c 0c 	call	0x18f8	; 0x18f8 <__mulsf3>
    107c:	20 e0       	ldi	r18, 0x00	; 0
    107e:	30 e0       	ldi	r19, 0x00	; 0
    1080:	48 ec       	ldi	r20, 0xC8	; 200
    1082:	51 e4       	ldi	r21, 0x41	; 65
    1084:	0e 94 27 0a 	call	0x144e	; 0x144e <__divsf3>
    1088:	20 e0       	ldi	r18, 0x00	; 0
    108a:	30 e0       	ldi	r19, 0x00	; 0
    108c:	4f e7       	ldi	r20, 0x7F	; 127
    108e:	53 e4       	ldi	r21, 0x43	; 67
    1090:	0e 94 46 0b 	call	0x168c	; 0x168c <fmin>
    1094:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <__fixunssfsi>
    1098:	6e 8b       	std	Y+22, r22	; 0x16
				}
				
				rgb_colors[i] = (struct RGB_Color){red, green, 0};
    109a:	2e 89       	ldd	r18, Y+22	; 0x16
    109c:	f7 01       	movw	r30, r14
    109e:	20 83       	st	Z, r18
    10a0:	4d 89       	ldd	r20, Y+21	; 0x15
    10a2:	41 83       	std	Z+1, r20	; 0x01
    10a4:	12 82       	std	Z+2, r1	; 0x02
    10a6:	52 e0       	ldi	r21, 0x02	; 2
    10a8:	25 0e       	add	r2, r21
    10aa:	31 1c       	adc	r3, r1
    10ac:	63 e0       	ldi	r22, 0x03	; 3
    10ae:	c6 0e       	add	r12, r22
    10b0:	d1 1c       	adc	r13, r1
    10b2:	72 e0       	ldi	r23, 0x02	; 2
    10b4:	47 0e       	add	r4, r23
    10b6:	51 1c       	adc	r5, r1
    10b8:	82 e0       	ldi	r24, 0x02	; 2
    10ba:	68 0e       	add	r6, r24
    10bc:	71 1c       	adc	r7, r1
	
	// This is where we store all the actual color values we want to send to the LED
	struct RGB_Color rgb_colors[NUMBER_OF_LEDS];
	
	
	for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
    10be:	28 14       	cp	r2, r8
    10c0:	39 04       	cpc	r3, r9
    10c2:	09 f0       	breq	.+2      	; 0x10c6 <tinyLED_update+0x4cc>
    10c4:	38 ce       	rjmp	.-912    	; 0xd36 <tinyLED_update+0x13c>
				break;
		}
	}
	
	// We only write to the LEDs if there is something to change. (eg. in SWING mode, we update the LEDs almost every cycle)
	if(!tinyLED_RGB_Color_Compare(&rgb_colors, &tinyLED_old_colors)){
    10c6:	66 e4       	ldi	r22, 0x46	; 70
    10c8:	78 e3       	ldi	r23, 0x38	; 56
    10ca:	ce 01       	movw	r24, r28
    10cc:	01 96       	adiw	r24, 0x01	; 1
    10ce:	0e 94 cd 05 	call	0xb9a	; 0xb9a <tinyLED_RGB_Color_Compare>
    10d2:	81 11       	cpse	r24, r1
    10d4:	21 c0       	rjmp	.+66     	; 0x1118 <tinyLED_update+0x51e>
    10d6:	06 e4       	ldi	r16, 0x46	; 70
    10d8:	18 e3       	ldi	r17, 0x38	; 56
    10da:	7e 01       	movw	r14, r28
    10dc:	97 e0       	ldi	r25, 0x07	; 7
    10de:	e9 0e       	add	r14, r25
    10e0:	f1 1c       	adc	r15, r1
		for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
		{
			// Write to LEDs
			//For some reason, the data-bus to the LEDs is serialized as GRB
			//which means the 24-bit data-bus will look like [Green[0:7], Red[0:7], Blue[0:7]]
			tinyLED_SPIWriteByte(rgb_colors[i].green);
    10e2:	d5 01       	movw	r26, r10
    10e4:	11 96       	adiw	r26, 0x01	; 1
    10e6:	8c 91       	ld	r24, X
    10e8:	0e 94 85 05 	call	0xb0a	; 0xb0a <tinyLED_SPIWriteByte>
			tinyLED_SPIWriteByte(rgb_colors[i].red);
    10ec:	f5 01       	movw	r30, r10
    10ee:	80 81       	ld	r24, Z
    10f0:	0e 94 85 05 	call	0xb0a	; 0xb0a <tinyLED_SPIWriteByte>
			tinyLED_SPIWriteByte(rgb_colors[i].blue);
    10f4:	d5 01       	movw	r26, r10
    10f6:	12 96       	adiw	r26, 0x02	; 2
    10f8:	8c 91       	ld	r24, X
    10fa:	0e 94 85 05 	call	0xb0a	; 0xb0a <tinyLED_SPIWriteByte>
			tinyLED_old_colors[i] = rgb_colors[i];
    10fe:	f5 01       	movw	r30, r10
    1100:	81 91       	ld	r24, Z+
    1102:	91 91       	ld	r25, Z+
    1104:	a1 91       	ld	r26, Z+
    1106:	5f 01       	movw	r10, r30
    1108:	f8 01       	movw	r30, r16
    110a:	81 93       	st	Z+, r24
    110c:	91 93       	st	Z+, r25
    110e:	a1 93       	st	Z+, r26
    1110:	8f 01       	movw	r16, r30
		}
	}
	
	// We only write to the LEDs if there is something to change. (eg. in SWING mode, we update the LEDs almost every cycle)
	if(!tinyLED_RGB_Color_Compare(&rgb_colors, &tinyLED_old_colors)){
		for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
    1112:	ae 14       	cp	r10, r14
    1114:	bf 04       	cpc	r11, r15
    1116:	29 f7       	brne	.-54     	; 0x10e2 <tinyLED_update+0x4e8>
			tinyLED_SPIWriteByte(rgb_colors[i].red);
			tinyLED_SPIWriteByte(rgb_colors[i].blue);
			tinyLED_old_colors[i] = rgb_colors[i];
		}
	}
}
    1118:	ae 96       	adiw	r28, 0x2e	; 46
    111a:	cd bf       	out	0x3d, r28	; 61
    111c:	de bf       	out	0x3e, r29	; 62
    111e:	df 91       	pop	r29
    1120:	cf 91       	pop	r28
    1122:	1f 91       	pop	r17
    1124:	0f 91       	pop	r16
    1126:	ff 90       	pop	r15
    1128:	ef 90       	pop	r14
    112a:	df 90       	pop	r13
    112c:	cf 90       	pop	r12
    112e:	bf 90       	pop	r11
    1130:	af 90       	pop	r10
    1132:	9f 90       	pop	r9
    1134:	8f 90       	pop	r8
    1136:	7f 90       	pop	r7
    1138:	6f 90       	pop	r6
    113a:	5f 90       	pop	r5
    113c:	4f 90       	pop	r4
    113e:	3f 90       	pop	r3
    1140:	2f 90       	pop	r2
    1142:	08 95       	ret

00001144 <tinyPotential_get_potential>:
/*
Sends the potential
*/
double tinyPotential_get_potential()
{
	return tinyPotential_potential;
    1144:	60 91 58 38 	lds	r22, 0x3858	; 0x803858 <tinyPotential_potential>
    1148:	70 91 59 38 	lds	r23, 0x3859	; 0x803859 <tinyPotential_potential+0x1>
    114c:	80 91 5a 38 	lds	r24, 0x385A	; 0x80385a <tinyPotential_potential+0x2>
    1150:	90 91 5b 38 	lds	r25, 0x385B	; 0x80385b <tinyPotential_potential+0x3>
}
    1154:	08 95       	ret

00001156 <tinyPotential_update>:

/*
Update the potential
*/
void tinyPotential_update()
{
    1156:	cf 92       	push	r12
    1158:	df 92       	push	r13
    115a:	ef 92       	push	r14
    115c:	ff 92       	push	r15
Function to decay the potential towards 0
*/
static void tinyPotential_decay()
{
		
	uint8_t time_since_last_update = tinyTime_now() - previous_update_time;
    115e:	0e 94 ac 09 	call	0x1358	; 0x1358 <tinyTime_now>
	tinyPotential_potential *= (exp(-((float)time_since_last_update/(float)TINYPOTENTIAL_TIME_CONST)));
    1162:	80 91 54 38 	lds	r24, 0x3854	; 0x803854 <previous_update_time>
    1166:	68 1b       	sub	r22, r24
    1168:	70 e0       	ldi	r23, 0x00	; 0
    116a:	80 e0       	ldi	r24, 0x00	; 0
    116c:	90 e0       	ldi	r25, 0x00	; 0
    116e:	0e 94 09 0b 	call	0x1612	; 0x1612 <__floatunsisf>
    1172:	20 e0       	ldi	r18, 0x00	; 0
    1174:	30 e0       	ldi	r19, 0x00	; 0
    1176:	48 ec       	ldi	r20, 0xC8	; 200
    1178:	52 e4       	ldi	r21, 0x42	; 66
    117a:	0e 94 27 0a 	call	0x144e	; 0x144e <__divsf3>
    117e:	90 58       	subi	r25, 0x80	; 128
    1180:	0e 94 a1 0a 	call	0x1542	; 0x1542 <exp>
    1184:	20 91 58 38 	lds	r18, 0x3858	; 0x803858 <tinyPotential_potential>
    1188:	30 91 59 38 	lds	r19, 0x3859	; 0x803859 <tinyPotential_potential+0x1>
    118c:	40 91 5a 38 	lds	r20, 0x385A	; 0x80385a <tinyPotential_potential+0x2>
    1190:	50 91 5b 38 	lds	r21, 0x385B	; 0x80385b <tinyPotential_potential+0x3>
    1194:	0e 94 7c 0c 	call	0x18f8	; 0x18f8 <__mulsf3>
    1198:	6b 01       	movw	r12, r22
    119a:	7c 01       	movw	r14, r24
	if(fabs(tinyPotential_potential)<POLARIZATION_OFFSET){
    119c:	9f 77       	andi	r25, 0x7F	; 127
    119e:	2d ec       	ldi	r18, 0xCD	; 205
    11a0:	3c ec       	ldi	r19, 0xCC	; 204
    11a2:	4c ec       	ldi	r20, 0xCC	; 204
    11a4:	5d e3       	ldi	r21, 0x3D	; 61
    11a6:	0e 94 22 0a 	call	0x1444	; 0x1444 <__cmpsf2>
    11aa:	88 23       	and	r24, r24
    11ac:	4c f0       	brlt	.+18     	; 0x11c0 <tinyPotential_update+0x6a>
*/
static void tinyPotential_decay()
{
		
	uint8_t time_since_last_update = tinyTime_now() - previous_update_time;
	tinyPotential_potential *= (exp(-((float)time_since_last_update/(float)TINYPOTENTIAL_TIME_CONST)));
    11ae:	c0 92 58 38 	sts	0x3858, r12	; 0x803858 <tinyPotential_potential>
    11b2:	d0 92 59 38 	sts	0x3859, r13	; 0x803859 <tinyPotential_potential+0x1>
    11b6:	e0 92 5a 38 	sts	0x385A, r14	; 0x80385a <tinyPotential_potential+0x2>
    11ba:	f0 92 5b 38 	sts	0x385B, r15	; 0x80385b <tinyPotential_potential+0x3>
    11be:	08 c0       	rjmp	.+16     	; 0x11d0 <tinyPotential_update+0x7a>
	if(fabs(tinyPotential_potential)<POLARIZATION_OFFSET){
		tinyPotential_potential=0;
    11c0:	10 92 58 38 	sts	0x3858, r1	; 0x803858 <tinyPotential_potential>
    11c4:	10 92 59 38 	sts	0x3859, r1	; 0x803859 <tinyPotential_potential+0x1>
    11c8:	10 92 5a 38 	sts	0x385A, r1	; 0x80385a <tinyPotential_potential+0x2>
    11cc:	10 92 5b 38 	sts	0x385B, r1	; 0x80385b <tinyPotential_potential+0x3>
	}
	previous_update_time = tinyTime_now();
    11d0:	0e 94 ac 09 	call	0x1358	; 0x1358 <tinyTime_now>
    11d4:	60 93 54 38 	sts	0x3854, r22	; 0x803854 <previous_update_time>
    11d8:	70 93 55 38 	sts	0x3855, r23	; 0x803855 <previous_update_time+0x1>
    11dc:	80 93 56 38 	sts	0x3856, r24	; 0x803856 <previous_update_time+0x2>
    11e0:	90 93 57 38 	sts	0x3857, r25	; 0x803857 <previous_update_time+0x3>
void tinyPotential_update()
{
	//Some of the potential in the neuron has decayed away
	tinyPotential_decay();
	// Update potential with values from Dendrites
	tinyPotential_potential = tinyDendrite_update_potential(tinyPotential_potential);
    11e4:	60 91 58 38 	lds	r22, 0x3858	; 0x803858 <tinyPotential_potential>
    11e8:	70 91 59 38 	lds	r23, 0x3859	; 0x803859 <tinyPotential_potential+0x1>
    11ec:	80 91 5a 38 	lds	r24, 0x385A	; 0x80385a <tinyPotential_potential+0x2>
    11f0:	90 91 5b 38 	lds	r25, 0x385B	; 0x80385b <tinyPotential_potential+0x3>
    11f4:	0e 94 3d 05 	call	0xa7a	; 0xa7a <tinyDendrite_update_potential>
    11f8:	60 93 58 38 	sts	0x3858, r22	; 0x803858 <tinyPotential_potential>
    11fc:	70 93 59 38 	sts	0x3859, r23	; 0x803859 <tinyPotential_potential+0x1>
    1200:	80 93 5a 38 	sts	0x385A, r24	; 0x80385a <tinyPotential_potential+0x2>
    1204:	90 93 5b 38 	sts	0x385B, r25	; 0x80385b <tinyPotential_potential+0x3>
	
	// Update potential from button press
	tinyPotential_potential = tinyButton_update_potential(tinyPotential_potential);
    1208:	0e 94 d2 03 	call	0x7a4	; 0x7a4 <tinyButton_update_potential>
    120c:	60 93 58 38 	sts	0x3858, r22	; 0x803858 <tinyPotential_potential>
    1210:	70 93 59 38 	sts	0x3859, r23	; 0x803859 <tinyPotential_potential+0x1>
    1214:	80 93 5a 38 	sts	0x385A, r24	; 0x80385a <tinyPotential_potential+0x2>
    1218:	90 93 5b 38 	sts	0x385B, r25	; 0x80385b <tinyPotential_potential+0x3>
	
	// Update potential with values from spontaneous pulse.
	tinyPotential_potential = tinyPulse_update_potential(tinyPotential_potential);
    121c:	0e 94 4e 09 	call	0x129c	; 0x129c <tinyPulse_update_potential>
    1220:	ab 01       	movw	r20, r22
    1222:	bc 01       	movw	r22, r24
    1224:	40 93 58 38 	sts	0x3858, r20	; 0x803858 <tinyPotential_potential>
    1228:	50 93 59 38 	sts	0x3859, r21	; 0x803859 <tinyPotential_potential+0x1>
    122c:	60 93 5a 38 	sts	0x385A, r22	; 0x80385a <tinyPotential_potential+0x2>
    1230:	70 93 5b 38 	sts	0x385B, r23	; 0x80385b <tinyPotential_potential+0x3>
	
	tinyDebugger_send_double("Potential", tinyPotential_potential);
    1234:	8f e1       	ldi	r24, 0x1F	; 31
    1236:	9b e9       	ldi	r25, 0x9B	; 155
    1238:	0e 94 5f 04 	call	0x8be	; 0x8be <tinyDebugger_send_double>
	
	
	// Let the axon affect the potential
	// This is also where we decide whether or not the axon should fire
	tinyPotential_potential = tinyAxon_update_potential(tinyPotential_potential);
    123c:	60 91 58 38 	lds	r22, 0x3858	; 0x803858 <tinyPotential_potential>
    1240:	70 91 59 38 	lds	r23, 0x3859	; 0x803859 <tinyPotential_potential+0x1>
    1244:	80 91 5a 38 	lds	r24, 0x385A	; 0x80385a <tinyPotential_potential+0x2>
    1248:	90 91 5b 38 	lds	r25, 0x385B	; 0x80385b <tinyPotential_potential+0x3>
    124c:	0e 94 bf 02 	call	0x57e	; 0x57e <tinyAxon_update_potential>
    1250:	60 93 58 38 	sts	0x3858, r22	; 0x803858 <tinyPotential_potential>
    1254:	70 93 59 38 	sts	0x3859, r23	; 0x803859 <tinyPotential_potential+0x1>
    1258:	80 93 5a 38 	sts	0x385A, r24	; 0x80385a <tinyPotential_potential+0x2>
    125c:	90 93 5b 38 	sts	0x385B, r25	; 0x80385b <tinyPotential_potential+0x3>
}
    1260:	ff 90       	pop	r15
    1262:	ef 90       	pop	r14
    1264:	df 90       	pop	r13
    1266:	cf 90       	pop	r12
    1268:	08 95       	ret

0000126a <tinyPulse_toggle_pulse_mode>:
_Bool tinyPulse_is_in_pulse_mode(){
	return pulse_mode;
}

void tinyPulse_toggle_pulse_mode(){
	pulse_mode = !pulse_mode;
    126a:	90 91 62 38 	lds	r25, 0x3862	; 0x803862 <pulse_mode>
    126e:	81 e0       	ldi	r24, 0x01	; 1
    1270:	89 27       	eor	r24, r25
    1272:	80 93 62 38 	sts	0x3862, r24	; 0x803862 <pulse_mode>
	
	if(tinyPulse_is_in_pulse_mode()){
    1276:	88 23       	and	r24, r24
    1278:	31 f0       	breq	.+12     	; 0x1286 <tinyPulse_toggle_pulse_mode+0x1c>
		tinyLED_set_color_mode(OUT_LED, PULSEMODE_COLOR, WEAK);
    127a:	41 e0       	ldi	r20, 0x01	; 1
    127c:	63 e0       	ldi	r22, 0x03	; 3
    127e:	81 e0       	ldi	r24, 0x01	; 1
    1280:	0e 94 a1 05 	call	0xb42	; 0xb42 <tinyLED_set_color_mode>
    1284:	08 95       	ret
		//tinyLED_set_color_mode(INN_LED, PULSEMODE_COLOR, WEAK);
	}
	else{
		tinyLED_set_color(OUT_LED, LED_OFF);
    1286:	60 e0       	ldi	r22, 0x00	; 0
    1288:	81 e0       	ldi	r24, 0x01	; 1
    128a:	0e 94 c9 05 	call	0xb92	; 0xb92 <tinyLED_set_color>
    128e:	08 95       	ret

00001290 <tinyPulse_set_pulse_mode>:
		//tinyLED_set_color(INN_LED, LED_OFF);
	}
}

void tinyPulse_set_pulse_mode(_Bool mode){
	if (pulse_mode != mode)
    1290:	90 91 62 38 	lds	r25, 0x3862	; 0x803862 <pulse_mode>
    1294:	98 13       	cpse	r25, r24
	{
		tinyPulse_toggle_pulse_mode();
    1296:	0e 94 35 09 	call	0x126a	; 0x126a <tinyPulse_toggle_pulse_mode>
    129a:	08 95       	ret

0000129c <tinyPulse_update_potential>:
	}
}

double tinyPulse_update_potential(double potential){
    129c:	cf 92       	push	r12
    129e:	df 92       	push	r13
    12a0:	ef 92       	push	r14
    12a2:	ff 92       	push	r15
    12a4:	6b 01       	movw	r12, r22
    12a6:	7c 01       	movw	r14, r24
	if(pulse_mode){
    12a8:	80 91 62 38 	lds	r24, 0x3862	; 0x803862 <pulse_mode>
    12ac:	88 23       	and	r24, r24
    12ae:	39 f1       	breq	.+78     	; 0x12fe <tinyPulse_update_potential+0x62>
		
		time_since_last_pulse = tinyTime_now() - time_of_last_pulse;
    12b0:	0e 94 ac 09 	call	0x1358	; 0x1358 <tinyTime_now>
    12b4:	20 91 5e 38 	lds	r18, 0x385E	; 0x80385e <time_of_last_pulse>
    12b8:	30 91 5f 38 	lds	r19, 0x385F	; 0x80385f <time_of_last_pulse+0x1>
    12bc:	62 1b       	sub	r22, r18
    12be:	73 0b       	sbc	r23, r19
    12c0:	60 93 5c 38 	sts	0x385C, r22	; 0x80385c <time_since_last_pulse>
    12c4:	70 93 5d 38 	sts	0x385D, r23	; 0x80385d <time_since_last_pulse+0x1>
		
		if(time_since_last_pulse >= ideal_time_between_pulses){
    12c8:	80 91 13 38 	lds	r24, 0x3813	; 0x803813 <ideal_time_between_pulses>
    12cc:	90 91 14 38 	lds	r25, 0x3814	; 0x803814 <ideal_time_between_pulses+0x1>
    12d0:	68 17       	cp	r22, r24
    12d2:	79 07       	cpc	r23, r25
    12d4:	a0 f0       	brcs	.+40     	; 0x12fe <tinyPulse_update_potential+0x62>
			// This isn't actually a button press. You could have a separate variable for this, but it seems unnecessary.
			potential += BUTTON_PRESS_REACTION;
    12d6:	20 e0       	ldi	r18, 0x00	; 0
    12d8:	30 e0       	ldi	r19, 0x00	; 0
    12da:	40 ed       	ldi	r20, 0xD0	; 208
    12dc:	51 e4       	ldi	r21, 0x41	; 65
    12de:	c7 01       	movw	r24, r14
    12e0:	b6 01       	movw	r22, r12
    12e2:	0e 94 b6 09 	call	0x136c	; 0x136c <__addsf3>
    12e6:	6b 01       	movw	r12, r22
    12e8:	7c 01       	movw	r14, r24
			time_of_last_pulse = tinyTime_now();			
    12ea:	0e 94 ac 09 	call	0x1358	; 0x1358 <tinyTime_now>
    12ee:	60 93 5e 38 	sts	0x385E, r22	; 0x80385e <time_of_last_pulse>
    12f2:	70 93 5f 38 	sts	0x385F, r23	; 0x80385f <time_of_last_pulse+0x1>
    12f6:	80 93 60 38 	sts	0x3860, r24	; 0x803860 <time_of_last_pulse+0x2>
    12fa:	90 93 61 38 	sts	0x3861, r25	; 0x803861 <time_of_last_pulse+0x3>
		}
	}
	return potential;
}
    12fe:	c7 01       	movw	r24, r14
    1300:	b6 01       	movw	r22, r12
    1302:	ff 90       	pop	r15
    1304:	ef 90       	pop	r14
    1306:	df 90       	pop	r13
    1308:	cf 90       	pop	r12
    130a:	08 95       	ret

0000130c <tinySleep_prepare_sleep>:
  PCMSK |= _BV(PCINT3);                   // Use PB3 as interrupt pin
  ADCSRA &= ~_BV(ADEN);                   // ADC off
  */
  
  //set_sleep_mode(SLEEP_MODE_PWR_DOWN);  // Set sleep mode to POWER DOWN mode
  set_sleep_mode(SLEEP_MODE_IDLE);  // Set sleep mode to POWER DOWN mode
    130c:	e0 e5       	ldi	r30, 0x50	; 80
    130e:	f0 e0       	ldi	r31, 0x00	; 0
    1310:	80 81       	ld	r24, Z
    1312:	89 7f       	andi	r24, 0xF9	; 249
    1314:	80 83       	st	Z, r24
  sleep_enable();
    1316:	80 81       	ld	r24, Z
    1318:	81 60       	ori	r24, 0x01	; 1
    131a:	80 83       	st	Z, r24
    131c:	08 95       	ret

0000131e <tinySleep_enter_sleep>:

void tinySleep_enter_sleep(){

	
  //sleep_bod_disable();
  cli();
    131e:	f8 94       	cli
  sei();
    1320:	78 94       	sei
  sleep_cpu();
    1322:	88 95       	sleep
  sleep_disable();
    1324:	e0 e5       	ldi	r30, 0x50	; 80
    1326:	f0 e0       	ldi	r31, 0x00	; 0
    1328:	80 81       	ld	r24, Z
    132a:	8e 7f       	andi	r24, 0xFE	; 254
    132c:	80 83       	st	Z, r24
    132e:	08 95       	ret

00001330 <tinyTime_counter_increment>:
If the Interrupt Service Routine is clocked by a crystal oscillator
it gives a very precise timer-counter.
*/
void tinyTime_counter_increment(void)
{
	time_counter++;
    1330:	80 91 63 38 	lds	r24, 0x3863	; 0x803863 <time_counter>
    1334:	90 91 64 38 	lds	r25, 0x3864	; 0x803864 <time_counter+0x1>
    1338:	a0 91 65 38 	lds	r26, 0x3865	; 0x803865 <time_counter+0x2>
    133c:	b0 91 66 38 	lds	r27, 0x3866	; 0x803866 <time_counter+0x3>
    1340:	01 96       	adiw	r24, 0x01	; 1
    1342:	a1 1d       	adc	r26, r1
    1344:	b1 1d       	adc	r27, r1
    1346:	80 93 63 38 	sts	0x3863, r24	; 0x803863 <time_counter>
    134a:	90 93 64 38 	sts	0x3864, r25	; 0x803864 <time_counter+0x1>
    134e:	a0 93 65 38 	sts	0x3865, r26	; 0x803865 <time_counter+0x2>
    1352:	b0 93 66 38 	sts	0x3866, r27	; 0x803866 <time_counter+0x3>
    1356:	08 95       	ret

00001358 <tinyTime_now>:
/*
This function is callable by external libraries to give them the counted time so far.
*/
uint32_t tinyTime_now(void)
{
	return time_counter;
    1358:	60 91 63 38 	lds	r22, 0x3863	; 0x803863 <time_counter>
    135c:	70 91 64 38 	lds	r23, 0x3864	; 0x803864 <time_counter+0x1>
    1360:	80 91 65 38 	lds	r24, 0x3865	; 0x803865 <time_counter+0x2>
    1364:	90 91 66 38 	lds	r25, 0x3866	; 0x803866 <time_counter+0x3>
    1368:	08 95       	ret

0000136a <__subsf3>:
    136a:	50 58       	subi	r21, 0x80	; 128

0000136c <__addsf3>:
    136c:	bb 27       	eor	r27, r27
    136e:	aa 27       	eor	r26, r26
    1370:	0e 94 cd 09 	call	0x139a	; 0x139a <__addsf3x>
    1374:	0c 94 c7 0b 	jmp	0x178e	; 0x178e <__fp_round>
    1378:	0e 94 b9 0b 	call	0x1772	; 0x1772 <__fp_pscA>
    137c:	38 f0       	brcs	.+14     	; 0x138c <__addsf3+0x20>
    137e:	0e 94 c0 0b 	call	0x1780	; 0x1780 <__fp_pscB>
    1382:	20 f0       	brcs	.+8      	; 0x138c <__addsf3+0x20>
    1384:	39 f4       	brne	.+14     	; 0x1394 <__addsf3+0x28>
    1386:	9f 3f       	cpi	r25, 0xFF	; 255
    1388:	19 f4       	brne	.+6      	; 0x1390 <__addsf3+0x24>
    138a:	26 f4       	brtc	.+8      	; 0x1394 <__addsf3+0x28>
    138c:	0c 94 8f 0b 	jmp	0x171e	; 0x171e <__fp_nan>
    1390:	0e f4       	brtc	.+2      	; 0x1394 <__addsf3+0x28>
    1392:	e0 95       	com	r30
    1394:	e7 fb       	bst	r30, 7
    1396:	0c 94 89 0b 	jmp	0x1712	; 0x1712 <__fp_inf>

0000139a <__addsf3x>:
    139a:	e9 2f       	mov	r30, r25
    139c:	0e 94 d8 0b 	call	0x17b0	; 0x17b0 <__fp_split3>
    13a0:	58 f3       	brcs	.-42     	; 0x1378 <__addsf3+0xc>
    13a2:	ba 17       	cp	r27, r26
    13a4:	62 07       	cpc	r22, r18
    13a6:	73 07       	cpc	r23, r19
    13a8:	84 07       	cpc	r24, r20
    13aa:	95 07       	cpc	r25, r21
    13ac:	20 f0       	brcs	.+8      	; 0x13b6 <__addsf3x+0x1c>
    13ae:	79 f4       	brne	.+30     	; 0x13ce <__addsf3x+0x34>
    13b0:	a6 f5       	brtc	.+104    	; 0x141a <__addsf3x+0x80>
    13b2:	0c 94 fa 0b 	jmp	0x17f4	; 0x17f4 <__fp_zero>
    13b6:	0e f4       	brtc	.+2      	; 0x13ba <__addsf3x+0x20>
    13b8:	e0 95       	com	r30
    13ba:	0b 2e       	mov	r0, r27
    13bc:	ba 2f       	mov	r27, r26
    13be:	a0 2d       	mov	r26, r0
    13c0:	0b 01       	movw	r0, r22
    13c2:	b9 01       	movw	r22, r18
    13c4:	90 01       	movw	r18, r0
    13c6:	0c 01       	movw	r0, r24
    13c8:	ca 01       	movw	r24, r20
    13ca:	a0 01       	movw	r20, r0
    13cc:	11 24       	eor	r1, r1
    13ce:	ff 27       	eor	r31, r31
    13d0:	59 1b       	sub	r21, r25
    13d2:	99 f0       	breq	.+38     	; 0x13fa <__addsf3x+0x60>
    13d4:	59 3f       	cpi	r21, 0xF9	; 249
    13d6:	50 f4       	brcc	.+20     	; 0x13ec <__addsf3x+0x52>
    13d8:	50 3e       	cpi	r21, 0xE0	; 224
    13da:	68 f1       	brcs	.+90     	; 0x1436 <__addsf3x+0x9c>
    13dc:	1a 16       	cp	r1, r26
    13de:	f0 40       	sbci	r31, 0x00	; 0
    13e0:	a2 2f       	mov	r26, r18
    13e2:	23 2f       	mov	r18, r19
    13e4:	34 2f       	mov	r19, r20
    13e6:	44 27       	eor	r20, r20
    13e8:	58 5f       	subi	r21, 0xF8	; 248
    13ea:	f3 cf       	rjmp	.-26     	; 0x13d2 <__addsf3x+0x38>
    13ec:	46 95       	lsr	r20
    13ee:	37 95       	ror	r19
    13f0:	27 95       	ror	r18
    13f2:	a7 95       	ror	r26
    13f4:	f0 40       	sbci	r31, 0x00	; 0
    13f6:	53 95       	inc	r21
    13f8:	c9 f7       	brne	.-14     	; 0x13ec <__addsf3x+0x52>
    13fa:	7e f4       	brtc	.+30     	; 0x141a <__addsf3x+0x80>
    13fc:	1f 16       	cp	r1, r31
    13fe:	ba 0b       	sbc	r27, r26
    1400:	62 0b       	sbc	r22, r18
    1402:	73 0b       	sbc	r23, r19
    1404:	84 0b       	sbc	r24, r20
    1406:	ba f0       	brmi	.+46     	; 0x1436 <__addsf3x+0x9c>
    1408:	91 50       	subi	r25, 0x01	; 1
    140a:	a1 f0       	breq	.+40     	; 0x1434 <__addsf3x+0x9a>
    140c:	ff 0f       	add	r31, r31
    140e:	bb 1f       	adc	r27, r27
    1410:	66 1f       	adc	r22, r22
    1412:	77 1f       	adc	r23, r23
    1414:	88 1f       	adc	r24, r24
    1416:	c2 f7       	brpl	.-16     	; 0x1408 <__addsf3x+0x6e>
    1418:	0e c0       	rjmp	.+28     	; 0x1436 <__addsf3x+0x9c>
    141a:	ba 0f       	add	r27, r26
    141c:	62 1f       	adc	r22, r18
    141e:	73 1f       	adc	r23, r19
    1420:	84 1f       	adc	r24, r20
    1422:	48 f4       	brcc	.+18     	; 0x1436 <__addsf3x+0x9c>
    1424:	87 95       	ror	r24
    1426:	77 95       	ror	r23
    1428:	67 95       	ror	r22
    142a:	b7 95       	ror	r27
    142c:	f7 95       	ror	r31
    142e:	9e 3f       	cpi	r25, 0xFE	; 254
    1430:	08 f0       	brcs	.+2      	; 0x1434 <__addsf3x+0x9a>
    1432:	b0 cf       	rjmp	.-160    	; 0x1394 <__addsf3+0x28>
    1434:	93 95       	inc	r25
    1436:	88 0f       	add	r24, r24
    1438:	08 f0       	brcs	.+2      	; 0x143c <__addsf3x+0xa2>
    143a:	99 27       	eor	r25, r25
    143c:	ee 0f       	add	r30, r30
    143e:	97 95       	ror	r25
    1440:	87 95       	ror	r24
    1442:	08 95       	ret

00001444 <__cmpsf2>:
    1444:	0e 94 65 0b 	call	0x16ca	; 0x16ca <__fp_cmp>
    1448:	08 f4       	brcc	.+2      	; 0x144c <__cmpsf2+0x8>
    144a:	81 e0       	ldi	r24, 0x01	; 1
    144c:	08 95       	ret

0000144e <__divsf3>:
    144e:	0e 94 3b 0a 	call	0x1476	; 0x1476 <__divsf3x>
    1452:	0c 94 c7 0b 	jmp	0x178e	; 0x178e <__fp_round>
    1456:	0e 94 c0 0b 	call	0x1780	; 0x1780 <__fp_pscB>
    145a:	58 f0       	brcs	.+22     	; 0x1472 <__divsf3+0x24>
    145c:	0e 94 b9 0b 	call	0x1772	; 0x1772 <__fp_pscA>
    1460:	40 f0       	brcs	.+16     	; 0x1472 <__divsf3+0x24>
    1462:	29 f4       	brne	.+10     	; 0x146e <__divsf3+0x20>
    1464:	5f 3f       	cpi	r21, 0xFF	; 255
    1466:	29 f0       	breq	.+10     	; 0x1472 <__divsf3+0x24>
    1468:	0c 94 89 0b 	jmp	0x1712	; 0x1712 <__fp_inf>
    146c:	51 11       	cpse	r21, r1
    146e:	0c 94 fb 0b 	jmp	0x17f6	; 0x17f6 <__fp_szero>
    1472:	0c 94 8f 0b 	jmp	0x171e	; 0x171e <__fp_nan>

00001476 <__divsf3x>:
    1476:	0e 94 d8 0b 	call	0x17b0	; 0x17b0 <__fp_split3>
    147a:	68 f3       	brcs	.-38     	; 0x1456 <__divsf3+0x8>

0000147c <__divsf3_pse>:
    147c:	99 23       	and	r25, r25
    147e:	b1 f3       	breq	.-20     	; 0x146c <__divsf3+0x1e>
    1480:	55 23       	and	r21, r21
    1482:	91 f3       	breq	.-28     	; 0x1468 <__divsf3+0x1a>
    1484:	95 1b       	sub	r25, r21
    1486:	55 0b       	sbc	r21, r21
    1488:	bb 27       	eor	r27, r27
    148a:	aa 27       	eor	r26, r26
    148c:	62 17       	cp	r22, r18
    148e:	73 07       	cpc	r23, r19
    1490:	84 07       	cpc	r24, r20
    1492:	38 f0       	brcs	.+14     	; 0x14a2 <__divsf3_pse+0x26>
    1494:	9f 5f       	subi	r25, 0xFF	; 255
    1496:	5f 4f       	sbci	r21, 0xFF	; 255
    1498:	22 0f       	add	r18, r18
    149a:	33 1f       	adc	r19, r19
    149c:	44 1f       	adc	r20, r20
    149e:	aa 1f       	adc	r26, r26
    14a0:	a9 f3       	breq	.-22     	; 0x148c <__divsf3_pse+0x10>
    14a2:	35 d0       	rcall	.+106    	; 0x150e <__divsf3_pse+0x92>
    14a4:	0e 2e       	mov	r0, r30
    14a6:	3a f0       	brmi	.+14     	; 0x14b6 <__divsf3_pse+0x3a>
    14a8:	e0 e8       	ldi	r30, 0x80	; 128
    14aa:	32 d0       	rcall	.+100    	; 0x1510 <__divsf3_pse+0x94>
    14ac:	91 50       	subi	r25, 0x01	; 1
    14ae:	50 40       	sbci	r21, 0x00	; 0
    14b0:	e6 95       	lsr	r30
    14b2:	00 1c       	adc	r0, r0
    14b4:	ca f7       	brpl	.-14     	; 0x14a8 <__divsf3_pse+0x2c>
    14b6:	2b d0       	rcall	.+86     	; 0x150e <__divsf3_pse+0x92>
    14b8:	fe 2f       	mov	r31, r30
    14ba:	29 d0       	rcall	.+82     	; 0x150e <__divsf3_pse+0x92>
    14bc:	66 0f       	add	r22, r22
    14be:	77 1f       	adc	r23, r23
    14c0:	88 1f       	adc	r24, r24
    14c2:	bb 1f       	adc	r27, r27
    14c4:	26 17       	cp	r18, r22
    14c6:	37 07       	cpc	r19, r23
    14c8:	48 07       	cpc	r20, r24
    14ca:	ab 07       	cpc	r26, r27
    14cc:	b0 e8       	ldi	r27, 0x80	; 128
    14ce:	09 f0       	breq	.+2      	; 0x14d2 <__divsf3_pse+0x56>
    14d0:	bb 0b       	sbc	r27, r27
    14d2:	80 2d       	mov	r24, r0
    14d4:	bf 01       	movw	r22, r30
    14d6:	ff 27       	eor	r31, r31
    14d8:	93 58       	subi	r25, 0x83	; 131
    14da:	5f 4f       	sbci	r21, 0xFF	; 255
    14dc:	3a f0       	brmi	.+14     	; 0x14ec <__divsf3_pse+0x70>
    14de:	9e 3f       	cpi	r25, 0xFE	; 254
    14e0:	51 05       	cpc	r21, r1
    14e2:	78 f0       	brcs	.+30     	; 0x1502 <__divsf3_pse+0x86>
    14e4:	0c 94 89 0b 	jmp	0x1712	; 0x1712 <__fp_inf>
    14e8:	0c 94 fb 0b 	jmp	0x17f6	; 0x17f6 <__fp_szero>
    14ec:	5f 3f       	cpi	r21, 0xFF	; 255
    14ee:	e4 f3       	brlt	.-8      	; 0x14e8 <__divsf3_pse+0x6c>
    14f0:	98 3e       	cpi	r25, 0xE8	; 232
    14f2:	d4 f3       	brlt	.-12     	; 0x14e8 <__divsf3_pse+0x6c>
    14f4:	86 95       	lsr	r24
    14f6:	77 95       	ror	r23
    14f8:	67 95       	ror	r22
    14fa:	b7 95       	ror	r27
    14fc:	f7 95       	ror	r31
    14fe:	9f 5f       	subi	r25, 0xFF	; 255
    1500:	c9 f7       	brne	.-14     	; 0x14f4 <__divsf3_pse+0x78>
    1502:	88 0f       	add	r24, r24
    1504:	91 1d       	adc	r25, r1
    1506:	96 95       	lsr	r25
    1508:	87 95       	ror	r24
    150a:	97 f9       	bld	r25, 7
    150c:	08 95       	ret
    150e:	e1 e0       	ldi	r30, 0x01	; 1
    1510:	66 0f       	add	r22, r22
    1512:	77 1f       	adc	r23, r23
    1514:	88 1f       	adc	r24, r24
    1516:	bb 1f       	adc	r27, r27
    1518:	62 17       	cp	r22, r18
    151a:	73 07       	cpc	r23, r19
    151c:	84 07       	cpc	r24, r20
    151e:	ba 07       	cpc	r27, r26
    1520:	20 f0       	brcs	.+8      	; 0x152a <__divsf3_pse+0xae>
    1522:	62 1b       	sub	r22, r18
    1524:	73 0b       	sbc	r23, r19
    1526:	84 0b       	sbc	r24, r20
    1528:	ba 0b       	sbc	r27, r26
    152a:	ee 1f       	adc	r30, r30
    152c:	88 f7       	brcc	.-30     	; 0x1510 <__divsf3_pse+0x94>
    152e:	e0 95       	com	r30
    1530:	08 95       	ret
    1532:	29 f4       	brne	.+10     	; 0x153e <__divsf3_pse+0xc2>
    1534:	16 f0       	brts	.+4      	; 0x153a <__divsf3_pse+0xbe>
    1536:	0c 94 89 0b 	jmp	0x1712	; 0x1712 <__fp_inf>
    153a:	0c 94 fa 0b 	jmp	0x17f4	; 0x17f4 <__fp_zero>
    153e:	0c 94 8f 0b 	jmp	0x171e	; 0x171e <__fp_nan>

00001542 <exp>:
    1542:	0e 94 e0 0b 	call	0x17c0	; 0x17c0 <__fp_splitA>
    1546:	a8 f3       	brcs	.-22     	; 0x1532 <__divsf3_pse+0xb6>
    1548:	96 38       	cpi	r25, 0x86	; 134
    154a:	a0 f7       	brcc	.-24     	; 0x1534 <__divsf3_pse+0xb8>
    154c:	07 f8       	bld	r0, 7
    154e:	0f 92       	push	r0
    1550:	e8 94       	clt
    1552:	2b e3       	ldi	r18, 0x3B	; 59
    1554:	3a ea       	ldi	r19, 0xAA	; 170
    1556:	48 eb       	ldi	r20, 0xB8	; 184
    1558:	5f e7       	ldi	r21, 0x7F	; 127
    155a:	0e 94 92 0c 	call	0x1924	; 0x1924 <__mulsf3_pse>
    155e:	0f 92       	push	r0
    1560:	0f 92       	push	r0
    1562:	0f 92       	push	r0
    1564:	4d b7       	in	r20, 0x3d	; 61
    1566:	5e b7       	in	r21, 0x3e	; 62
    1568:	0f 92       	push	r0
    156a:	0e 94 48 0c 	call	0x1890	; 0x1890 <modf>
    156e:	ec e7       	ldi	r30, 0x7C	; 124
    1570:	f0 e0       	ldi	r31, 0x00	; 0
    1572:	0e 94 92 0b 	call	0x1724	; 0x1724 <__fp_powser>
    1576:	4f 91       	pop	r20
    1578:	5f 91       	pop	r21
    157a:	ef 91       	pop	r30
    157c:	ff 91       	pop	r31
    157e:	e5 95       	asr	r30
    1580:	ee 1f       	adc	r30, r30
    1582:	ff 1f       	adc	r31, r31
    1584:	49 f0       	breq	.+18     	; 0x1598 <exp+0x56>
    1586:	fe 57       	subi	r31, 0x7E	; 126
    1588:	e0 68       	ori	r30, 0x80	; 128
    158a:	44 27       	eor	r20, r20
    158c:	ee 0f       	add	r30, r30
    158e:	44 1f       	adc	r20, r20
    1590:	fa 95       	dec	r31
    1592:	e1 f7       	brne	.-8      	; 0x158c <exp+0x4a>
    1594:	41 95       	neg	r20
    1596:	55 0b       	sbc	r21, r21
    1598:	0e 94 12 0c 	call	0x1824	; 0x1824 <ldexp>
    159c:	0f 90       	pop	r0
    159e:	07 fe       	sbrs	r0, 7
    15a0:	0c 94 06 0c 	jmp	0x180c	; 0x180c <inverse>
    15a4:	08 95       	ret

000015a6 <__fixsfsi>:
    15a6:	0e 94 da 0a 	call	0x15b4	; 0x15b4 <__fixunssfsi>
    15aa:	68 94       	set
    15ac:	b1 11       	cpse	r27, r1
    15ae:	0c 94 fb 0b 	jmp	0x17f6	; 0x17f6 <__fp_szero>
    15b2:	08 95       	ret

000015b4 <__fixunssfsi>:
    15b4:	0e 94 e0 0b 	call	0x17c0	; 0x17c0 <__fp_splitA>
    15b8:	88 f0       	brcs	.+34     	; 0x15dc <__fixunssfsi+0x28>
    15ba:	9f 57       	subi	r25, 0x7F	; 127
    15bc:	98 f0       	brcs	.+38     	; 0x15e4 <__fixunssfsi+0x30>
    15be:	b9 2f       	mov	r27, r25
    15c0:	99 27       	eor	r25, r25
    15c2:	b7 51       	subi	r27, 0x17	; 23
    15c4:	b0 f0       	brcs	.+44     	; 0x15f2 <__fixunssfsi+0x3e>
    15c6:	e1 f0       	breq	.+56     	; 0x1600 <__fixunssfsi+0x4c>
    15c8:	66 0f       	add	r22, r22
    15ca:	77 1f       	adc	r23, r23
    15cc:	88 1f       	adc	r24, r24
    15ce:	99 1f       	adc	r25, r25
    15d0:	1a f0       	brmi	.+6      	; 0x15d8 <__fixunssfsi+0x24>
    15d2:	ba 95       	dec	r27
    15d4:	c9 f7       	brne	.-14     	; 0x15c8 <__fixunssfsi+0x14>
    15d6:	14 c0       	rjmp	.+40     	; 0x1600 <__fixunssfsi+0x4c>
    15d8:	b1 30       	cpi	r27, 0x01	; 1
    15da:	91 f0       	breq	.+36     	; 0x1600 <__fixunssfsi+0x4c>
    15dc:	0e 94 fa 0b 	call	0x17f4	; 0x17f4 <__fp_zero>
    15e0:	b1 e0       	ldi	r27, 0x01	; 1
    15e2:	08 95       	ret
    15e4:	0c 94 fa 0b 	jmp	0x17f4	; 0x17f4 <__fp_zero>
    15e8:	67 2f       	mov	r22, r23
    15ea:	78 2f       	mov	r23, r24
    15ec:	88 27       	eor	r24, r24
    15ee:	b8 5f       	subi	r27, 0xF8	; 248
    15f0:	39 f0       	breq	.+14     	; 0x1600 <__fixunssfsi+0x4c>
    15f2:	b9 3f       	cpi	r27, 0xF9	; 249
    15f4:	cc f3       	brlt	.-14     	; 0x15e8 <__fixunssfsi+0x34>
    15f6:	86 95       	lsr	r24
    15f8:	77 95       	ror	r23
    15fa:	67 95       	ror	r22
    15fc:	b3 95       	inc	r27
    15fe:	d9 f7       	brne	.-10     	; 0x15f6 <__fixunssfsi+0x42>
    1600:	3e f4       	brtc	.+14     	; 0x1610 <__fixunssfsi+0x5c>
    1602:	90 95       	com	r25
    1604:	80 95       	com	r24
    1606:	70 95       	com	r23
    1608:	61 95       	neg	r22
    160a:	7f 4f       	sbci	r23, 0xFF	; 255
    160c:	8f 4f       	sbci	r24, 0xFF	; 255
    160e:	9f 4f       	sbci	r25, 0xFF	; 255
    1610:	08 95       	ret

00001612 <__floatunsisf>:
    1612:	e8 94       	clt
    1614:	09 c0       	rjmp	.+18     	; 0x1628 <__floatsisf+0x12>

00001616 <__floatsisf>:
    1616:	97 fb       	bst	r25, 7
    1618:	3e f4       	brtc	.+14     	; 0x1628 <__floatsisf+0x12>
    161a:	90 95       	com	r25
    161c:	80 95       	com	r24
    161e:	70 95       	com	r23
    1620:	61 95       	neg	r22
    1622:	7f 4f       	sbci	r23, 0xFF	; 255
    1624:	8f 4f       	sbci	r24, 0xFF	; 255
    1626:	9f 4f       	sbci	r25, 0xFF	; 255
    1628:	99 23       	and	r25, r25
    162a:	a9 f0       	breq	.+42     	; 0x1656 <__floatsisf+0x40>
    162c:	f9 2f       	mov	r31, r25
    162e:	96 e9       	ldi	r25, 0x96	; 150
    1630:	bb 27       	eor	r27, r27
    1632:	93 95       	inc	r25
    1634:	f6 95       	lsr	r31
    1636:	87 95       	ror	r24
    1638:	77 95       	ror	r23
    163a:	67 95       	ror	r22
    163c:	b7 95       	ror	r27
    163e:	f1 11       	cpse	r31, r1
    1640:	f8 cf       	rjmp	.-16     	; 0x1632 <__floatsisf+0x1c>
    1642:	fa f4       	brpl	.+62     	; 0x1682 <__floatsisf+0x6c>
    1644:	bb 0f       	add	r27, r27
    1646:	11 f4       	brne	.+4      	; 0x164c <__floatsisf+0x36>
    1648:	60 ff       	sbrs	r22, 0
    164a:	1b c0       	rjmp	.+54     	; 0x1682 <__floatsisf+0x6c>
    164c:	6f 5f       	subi	r22, 0xFF	; 255
    164e:	7f 4f       	sbci	r23, 0xFF	; 255
    1650:	8f 4f       	sbci	r24, 0xFF	; 255
    1652:	9f 4f       	sbci	r25, 0xFF	; 255
    1654:	16 c0       	rjmp	.+44     	; 0x1682 <__floatsisf+0x6c>
    1656:	88 23       	and	r24, r24
    1658:	11 f0       	breq	.+4      	; 0x165e <__floatsisf+0x48>
    165a:	96 e9       	ldi	r25, 0x96	; 150
    165c:	11 c0       	rjmp	.+34     	; 0x1680 <__floatsisf+0x6a>
    165e:	77 23       	and	r23, r23
    1660:	21 f0       	breq	.+8      	; 0x166a <__floatsisf+0x54>
    1662:	9e e8       	ldi	r25, 0x8E	; 142
    1664:	87 2f       	mov	r24, r23
    1666:	76 2f       	mov	r23, r22
    1668:	05 c0       	rjmp	.+10     	; 0x1674 <__floatsisf+0x5e>
    166a:	66 23       	and	r22, r22
    166c:	71 f0       	breq	.+28     	; 0x168a <__floatsisf+0x74>
    166e:	96 e8       	ldi	r25, 0x86	; 134
    1670:	86 2f       	mov	r24, r22
    1672:	70 e0       	ldi	r23, 0x00	; 0
    1674:	60 e0       	ldi	r22, 0x00	; 0
    1676:	2a f0       	brmi	.+10     	; 0x1682 <__floatsisf+0x6c>
    1678:	9a 95       	dec	r25
    167a:	66 0f       	add	r22, r22
    167c:	77 1f       	adc	r23, r23
    167e:	88 1f       	adc	r24, r24
    1680:	da f7       	brpl	.-10     	; 0x1678 <__floatsisf+0x62>
    1682:	88 0f       	add	r24, r24
    1684:	96 95       	lsr	r25
    1686:	87 95       	ror	r24
    1688:	97 f9       	bld	r25, 7
    168a:	08 95       	ret

0000168c <fmin>:
    168c:	99 0f       	add	r25, r25
    168e:	bb 0b       	sbc	r27, r27
    1690:	55 0f       	add	r21, r21
    1692:	aa 0b       	sbc	r26, r26
    1694:	e0 e8       	ldi	r30, 0x80	; 128
    1696:	fe ef       	ldi	r31, 0xFE	; 254
    1698:	16 16       	cp	r1, r22
    169a:	17 06       	cpc	r1, r23
    169c:	e8 07       	cpc	r30, r24
    169e:	f9 07       	cpc	r31, r25
    16a0:	70 f0       	brcs	.+28     	; 0x16be <fmin+0x32>
    16a2:	12 16       	cp	r1, r18
    16a4:	13 06       	cpc	r1, r19
    16a6:	e4 07       	cpc	r30, r20
    16a8:	f5 07       	cpc	r31, r21
    16aa:	60 f0       	brcs	.+24     	; 0x16c4 <fmin+0x38>
    16ac:	ba 17       	cp	r27, r26
    16ae:	54 f0       	brlt	.+20     	; 0x16c4 <fmin+0x38>
    16b0:	31 f4       	brne	.+12     	; 0x16be <fmin+0x32>
    16b2:	26 17       	cp	r18, r22
    16b4:	37 07       	cpc	r19, r23
    16b6:	48 07       	cpc	r20, r24
    16b8:	59 07       	cpc	r21, r25
    16ba:	a7 95       	ror	r26
    16bc:	1b f4       	brvc	.+6      	; 0x16c4 <fmin+0x38>
    16be:	b9 01       	movw	r22, r18
    16c0:	ca 01       	movw	r24, r20
    16c2:	ba 2f       	mov	r27, r26
    16c4:	b6 95       	lsr	r27
    16c6:	97 95       	ror	r25
    16c8:	08 95       	ret

000016ca <__fp_cmp>:
    16ca:	99 0f       	add	r25, r25
    16cc:	00 08       	sbc	r0, r0
    16ce:	55 0f       	add	r21, r21
    16d0:	aa 0b       	sbc	r26, r26
    16d2:	e0 e8       	ldi	r30, 0x80	; 128
    16d4:	fe ef       	ldi	r31, 0xFE	; 254
    16d6:	16 16       	cp	r1, r22
    16d8:	17 06       	cpc	r1, r23
    16da:	e8 07       	cpc	r30, r24
    16dc:	f9 07       	cpc	r31, r25
    16de:	c0 f0       	brcs	.+48     	; 0x1710 <__fp_cmp+0x46>
    16e0:	12 16       	cp	r1, r18
    16e2:	13 06       	cpc	r1, r19
    16e4:	e4 07       	cpc	r30, r20
    16e6:	f5 07       	cpc	r31, r21
    16e8:	98 f0       	brcs	.+38     	; 0x1710 <__fp_cmp+0x46>
    16ea:	62 1b       	sub	r22, r18
    16ec:	73 0b       	sbc	r23, r19
    16ee:	84 0b       	sbc	r24, r20
    16f0:	95 0b       	sbc	r25, r21
    16f2:	39 f4       	brne	.+14     	; 0x1702 <__fp_cmp+0x38>
    16f4:	0a 26       	eor	r0, r26
    16f6:	61 f0       	breq	.+24     	; 0x1710 <__fp_cmp+0x46>
    16f8:	23 2b       	or	r18, r19
    16fa:	24 2b       	or	r18, r20
    16fc:	25 2b       	or	r18, r21
    16fe:	21 f4       	brne	.+8      	; 0x1708 <__fp_cmp+0x3e>
    1700:	08 95       	ret
    1702:	0a 26       	eor	r0, r26
    1704:	09 f4       	brne	.+2      	; 0x1708 <__fp_cmp+0x3e>
    1706:	a1 40       	sbci	r26, 0x01	; 1
    1708:	a6 95       	lsr	r26
    170a:	8f ef       	ldi	r24, 0xFF	; 255
    170c:	81 1d       	adc	r24, r1
    170e:	81 1d       	adc	r24, r1
    1710:	08 95       	ret

00001712 <__fp_inf>:
    1712:	97 f9       	bld	r25, 7
    1714:	9f 67       	ori	r25, 0x7F	; 127
    1716:	80 e8       	ldi	r24, 0x80	; 128
    1718:	70 e0       	ldi	r23, 0x00	; 0
    171a:	60 e0       	ldi	r22, 0x00	; 0
    171c:	08 95       	ret

0000171e <__fp_nan>:
    171e:	9f ef       	ldi	r25, 0xFF	; 255
    1720:	80 ec       	ldi	r24, 0xC0	; 192
    1722:	08 95       	ret

00001724 <__fp_powser>:
    1724:	df 93       	push	r29
    1726:	cf 93       	push	r28
    1728:	1f 93       	push	r17
    172a:	0f 93       	push	r16
    172c:	ff 92       	push	r15
    172e:	ef 92       	push	r14
    1730:	df 92       	push	r13
    1732:	7b 01       	movw	r14, r22
    1734:	8c 01       	movw	r16, r24
    1736:	68 94       	set
    1738:	06 c0       	rjmp	.+12     	; 0x1746 <__fp_powser+0x22>
    173a:	da 2e       	mov	r13, r26
    173c:	ef 01       	movw	r28, r30
    173e:	0e 94 8f 0c 	call	0x191e	; 0x191e <__mulsf3x>
    1742:	fe 01       	movw	r30, r28
    1744:	e8 94       	clt
    1746:	a5 91       	lpm	r26, Z+
    1748:	25 91       	lpm	r18, Z+
    174a:	35 91       	lpm	r19, Z+
    174c:	45 91       	lpm	r20, Z+
    174e:	55 91       	lpm	r21, Z+
    1750:	a6 f3       	brts	.-24     	; 0x173a <__fp_powser+0x16>
    1752:	ef 01       	movw	r28, r30
    1754:	0e 94 cd 09 	call	0x139a	; 0x139a <__addsf3x>
    1758:	fe 01       	movw	r30, r28
    175a:	97 01       	movw	r18, r14
    175c:	a8 01       	movw	r20, r16
    175e:	da 94       	dec	r13
    1760:	69 f7       	brne	.-38     	; 0x173c <__fp_powser+0x18>
    1762:	df 90       	pop	r13
    1764:	ef 90       	pop	r14
    1766:	ff 90       	pop	r15
    1768:	0f 91       	pop	r16
    176a:	1f 91       	pop	r17
    176c:	cf 91       	pop	r28
    176e:	df 91       	pop	r29
    1770:	08 95       	ret

00001772 <__fp_pscA>:
    1772:	00 24       	eor	r0, r0
    1774:	0a 94       	dec	r0
    1776:	16 16       	cp	r1, r22
    1778:	17 06       	cpc	r1, r23
    177a:	18 06       	cpc	r1, r24
    177c:	09 06       	cpc	r0, r25
    177e:	08 95       	ret

00001780 <__fp_pscB>:
    1780:	00 24       	eor	r0, r0
    1782:	0a 94       	dec	r0
    1784:	12 16       	cp	r1, r18
    1786:	13 06       	cpc	r1, r19
    1788:	14 06       	cpc	r1, r20
    178a:	05 06       	cpc	r0, r21
    178c:	08 95       	ret

0000178e <__fp_round>:
    178e:	09 2e       	mov	r0, r25
    1790:	03 94       	inc	r0
    1792:	00 0c       	add	r0, r0
    1794:	11 f4       	brne	.+4      	; 0x179a <__fp_round+0xc>
    1796:	88 23       	and	r24, r24
    1798:	52 f0       	brmi	.+20     	; 0x17ae <__fp_round+0x20>
    179a:	bb 0f       	add	r27, r27
    179c:	40 f4       	brcc	.+16     	; 0x17ae <__fp_round+0x20>
    179e:	bf 2b       	or	r27, r31
    17a0:	11 f4       	brne	.+4      	; 0x17a6 <__fp_round+0x18>
    17a2:	60 ff       	sbrs	r22, 0
    17a4:	04 c0       	rjmp	.+8      	; 0x17ae <__fp_round+0x20>
    17a6:	6f 5f       	subi	r22, 0xFF	; 255
    17a8:	7f 4f       	sbci	r23, 0xFF	; 255
    17aa:	8f 4f       	sbci	r24, 0xFF	; 255
    17ac:	9f 4f       	sbci	r25, 0xFF	; 255
    17ae:	08 95       	ret

000017b0 <__fp_split3>:
    17b0:	57 fd       	sbrc	r21, 7
    17b2:	90 58       	subi	r25, 0x80	; 128
    17b4:	44 0f       	add	r20, r20
    17b6:	55 1f       	adc	r21, r21
    17b8:	59 f0       	breq	.+22     	; 0x17d0 <__fp_splitA+0x10>
    17ba:	5f 3f       	cpi	r21, 0xFF	; 255
    17bc:	71 f0       	breq	.+28     	; 0x17da <__fp_splitA+0x1a>
    17be:	47 95       	ror	r20

000017c0 <__fp_splitA>:
    17c0:	88 0f       	add	r24, r24
    17c2:	97 fb       	bst	r25, 7
    17c4:	99 1f       	adc	r25, r25
    17c6:	61 f0       	breq	.+24     	; 0x17e0 <__fp_splitA+0x20>
    17c8:	9f 3f       	cpi	r25, 0xFF	; 255
    17ca:	79 f0       	breq	.+30     	; 0x17ea <__fp_splitA+0x2a>
    17cc:	87 95       	ror	r24
    17ce:	08 95       	ret
    17d0:	12 16       	cp	r1, r18
    17d2:	13 06       	cpc	r1, r19
    17d4:	14 06       	cpc	r1, r20
    17d6:	55 1f       	adc	r21, r21
    17d8:	f2 cf       	rjmp	.-28     	; 0x17be <__fp_split3+0xe>
    17da:	46 95       	lsr	r20
    17dc:	f1 df       	rcall	.-30     	; 0x17c0 <__fp_splitA>
    17de:	08 c0       	rjmp	.+16     	; 0x17f0 <__fp_splitA+0x30>
    17e0:	16 16       	cp	r1, r22
    17e2:	17 06       	cpc	r1, r23
    17e4:	18 06       	cpc	r1, r24
    17e6:	99 1f       	adc	r25, r25
    17e8:	f1 cf       	rjmp	.-30     	; 0x17cc <__fp_splitA+0xc>
    17ea:	86 95       	lsr	r24
    17ec:	71 05       	cpc	r23, r1
    17ee:	61 05       	cpc	r22, r1
    17f0:	08 94       	sec
    17f2:	08 95       	ret

000017f4 <__fp_zero>:
    17f4:	e8 94       	clt

000017f6 <__fp_szero>:
    17f6:	bb 27       	eor	r27, r27
    17f8:	66 27       	eor	r22, r22
    17fa:	77 27       	eor	r23, r23
    17fc:	cb 01       	movw	r24, r22
    17fe:	97 f9       	bld	r25, 7
    1800:	08 95       	ret

00001802 <__gesf2>:
    1802:	0e 94 65 0b 	call	0x16ca	; 0x16ca <__fp_cmp>
    1806:	08 f4       	brcc	.+2      	; 0x180a <__gesf2+0x8>
    1808:	8f ef       	ldi	r24, 0xFF	; 255
    180a:	08 95       	ret

0000180c <inverse>:
    180c:	9b 01       	movw	r18, r22
    180e:	ac 01       	movw	r20, r24
    1810:	60 e0       	ldi	r22, 0x00	; 0
    1812:	70 e0       	ldi	r23, 0x00	; 0
    1814:	80 e8       	ldi	r24, 0x80	; 128
    1816:	9f e3       	ldi	r25, 0x3F	; 63
    1818:	0c 94 27 0a 	jmp	0x144e	; 0x144e <__divsf3>
    181c:	0c 94 89 0b 	jmp	0x1712	; 0x1712 <__fp_inf>
    1820:	0c 94 f1 0c 	jmp	0x19e2	; 0x19e2 <__fp_mpack>

00001824 <ldexp>:
    1824:	0e 94 e0 0b 	call	0x17c0	; 0x17c0 <__fp_splitA>
    1828:	d8 f3       	brcs	.-10     	; 0x1820 <inverse+0x14>
    182a:	99 23       	and	r25, r25
    182c:	c9 f3       	breq	.-14     	; 0x1820 <inverse+0x14>
    182e:	94 0f       	add	r25, r20
    1830:	51 1d       	adc	r21, r1
    1832:	a3 f3       	brvs	.-24     	; 0x181c <inverse+0x10>
    1834:	91 50       	subi	r25, 0x01	; 1
    1836:	50 40       	sbci	r21, 0x00	; 0
    1838:	94 f0       	brlt	.+36     	; 0x185e <ldexp+0x3a>
    183a:	59 f0       	breq	.+22     	; 0x1852 <ldexp+0x2e>
    183c:	88 23       	and	r24, r24
    183e:	32 f0       	brmi	.+12     	; 0x184c <ldexp+0x28>
    1840:	66 0f       	add	r22, r22
    1842:	77 1f       	adc	r23, r23
    1844:	88 1f       	adc	r24, r24
    1846:	91 50       	subi	r25, 0x01	; 1
    1848:	50 40       	sbci	r21, 0x00	; 0
    184a:	c1 f7       	brne	.-16     	; 0x183c <ldexp+0x18>
    184c:	9e 3f       	cpi	r25, 0xFE	; 254
    184e:	51 05       	cpc	r21, r1
    1850:	2c f7       	brge	.-54     	; 0x181c <inverse+0x10>
    1852:	88 0f       	add	r24, r24
    1854:	91 1d       	adc	r25, r1
    1856:	96 95       	lsr	r25
    1858:	87 95       	ror	r24
    185a:	97 f9       	bld	r25, 7
    185c:	08 95       	ret
    185e:	5f 3f       	cpi	r21, 0xFF	; 255
    1860:	ac f0       	brlt	.+42     	; 0x188c <ldexp+0x68>
    1862:	98 3e       	cpi	r25, 0xE8	; 232
    1864:	9c f0       	brlt	.+38     	; 0x188c <ldexp+0x68>
    1866:	bb 27       	eor	r27, r27
    1868:	86 95       	lsr	r24
    186a:	77 95       	ror	r23
    186c:	67 95       	ror	r22
    186e:	b7 95       	ror	r27
    1870:	08 f4       	brcc	.+2      	; 0x1874 <ldexp+0x50>
    1872:	b1 60       	ori	r27, 0x01	; 1
    1874:	93 95       	inc	r25
    1876:	c1 f7       	brne	.-16     	; 0x1868 <ldexp+0x44>
    1878:	bb 0f       	add	r27, r27
    187a:	58 f7       	brcc	.-42     	; 0x1852 <ldexp+0x2e>
    187c:	11 f4       	brne	.+4      	; 0x1882 <ldexp+0x5e>
    187e:	60 ff       	sbrs	r22, 0
    1880:	e8 cf       	rjmp	.-48     	; 0x1852 <ldexp+0x2e>
    1882:	6f 5f       	subi	r22, 0xFF	; 255
    1884:	7f 4f       	sbci	r23, 0xFF	; 255
    1886:	8f 4f       	sbci	r24, 0xFF	; 255
    1888:	9f 4f       	sbci	r25, 0xFF	; 255
    188a:	e3 cf       	rjmp	.-58     	; 0x1852 <ldexp+0x2e>
    188c:	0c 94 fb 0b 	jmp	0x17f6	; 0x17f6 <__fp_szero>

00001890 <modf>:
    1890:	fa 01       	movw	r30, r20
    1892:	dc 01       	movw	r26, r24
    1894:	aa 0f       	add	r26, r26
    1896:	bb 1f       	adc	r27, r27
    1898:	9b 01       	movw	r18, r22
    189a:	ac 01       	movw	r20, r24
    189c:	bf 57       	subi	r27, 0x7F	; 127
    189e:	28 f4       	brcc	.+10     	; 0x18aa <modf+0x1a>
    18a0:	22 27       	eor	r18, r18
    18a2:	33 27       	eor	r19, r19
    18a4:	44 27       	eor	r20, r20
    18a6:	50 78       	andi	r21, 0x80	; 128
    18a8:	20 c0       	rjmp	.+64     	; 0x18ea <modf+0x5a>
    18aa:	b7 51       	subi	r27, 0x17	; 23
    18ac:	90 f4       	brcc	.+36     	; 0x18d2 <modf+0x42>
    18ae:	ab 2f       	mov	r26, r27
    18b0:	00 24       	eor	r0, r0
    18b2:	46 95       	lsr	r20
    18b4:	37 95       	ror	r19
    18b6:	27 95       	ror	r18
    18b8:	01 1c       	adc	r0, r1
    18ba:	a3 95       	inc	r26
    18bc:	d2 f3       	brmi	.-12     	; 0x18b2 <modf+0x22>
    18be:	00 20       	and	r0, r0
    18c0:	71 f0       	breq	.+28     	; 0x18de <modf+0x4e>
    18c2:	22 0f       	add	r18, r18
    18c4:	33 1f       	adc	r19, r19
    18c6:	44 1f       	adc	r20, r20
    18c8:	b3 95       	inc	r27
    18ca:	da f3       	brmi	.-10     	; 0x18c2 <modf+0x32>
    18cc:	0e d0       	rcall	.+28     	; 0x18ea <modf+0x5a>
    18ce:	0c 94 b5 09 	jmp	0x136a	; 0x136a <__subsf3>
    18d2:	61 30       	cpi	r22, 0x01	; 1
    18d4:	71 05       	cpc	r23, r1
    18d6:	a0 e8       	ldi	r26, 0x80	; 128
    18d8:	8a 07       	cpc	r24, r26
    18da:	b9 46       	sbci	r27, 0x69	; 105
    18dc:	30 f4       	brcc	.+12     	; 0x18ea <modf+0x5a>
    18de:	9b 01       	movw	r18, r22
    18e0:	ac 01       	movw	r20, r24
    18e2:	66 27       	eor	r22, r22
    18e4:	77 27       	eor	r23, r23
    18e6:	88 27       	eor	r24, r24
    18e8:	90 78       	andi	r25, 0x80	; 128
    18ea:	30 96       	adiw	r30, 0x00	; 0
    18ec:	21 f0       	breq	.+8      	; 0x18f6 <modf+0x66>
    18ee:	20 83       	st	Z, r18
    18f0:	31 83       	std	Z+1, r19	; 0x01
    18f2:	42 83       	std	Z+2, r20	; 0x02
    18f4:	53 83       	std	Z+3, r21	; 0x03
    18f6:	08 95       	ret

000018f8 <__mulsf3>:
    18f8:	0e 94 8f 0c 	call	0x191e	; 0x191e <__mulsf3x>
    18fc:	0c 94 c7 0b 	jmp	0x178e	; 0x178e <__fp_round>
    1900:	0e 94 b9 0b 	call	0x1772	; 0x1772 <__fp_pscA>
    1904:	38 f0       	brcs	.+14     	; 0x1914 <__mulsf3+0x1c>
    1906:	0e 94 c0 0b 	call	0x1780	; 0x1780 <__fp_pscB>
    190a:	20 f0       	brcs	.+8      	; 0x1914 <__mulsf3+0x1c>
    190c:	95 23       	and	r25, r21
    190e:	11 f0       	breq	.+4      	; 0x1914 <__mulsf3+0x1c>
    1910:	0c 94 89 0b 	jmp	0x1712	; 0x1712 <__fp_inf>
    1914:	0c 94 8f 0b 	jmp	0x171e	; 0x171e <__fp_nan>
    1918:	11 24       	eor	r1, r1
    191a:	0c 94 fb 0b 	jmp	0x17f6	; 0x17f6 <__fp_szero>

0000191e <__mulsf3x>:
    191e:	0e 94 d8 0b 	call	0x17b0	; 0x17b0 <__fp_split3>
    1922:	70 f3       	brcs	.-36     	; 0x1900 <__mulsf3+0x8>

00001924 <__mulsf3_pse>:
    1924:	95 9f       	mul	r25, r21
    1926:	c1 f3       	breq	.-16     	; 0x1918 <__mulsf3+0x20>
    1928:	95 0f       	add	r25, r21
    192a:	50 e0       	ldi	r21, 0x00	; 0
    192c:	55 1f       	adc	r21, r21
    192e:	62 9f       	mul	r22, r18
    1930:	f0 01       	movw	r30, r0
    1932:	72 9f       	mul	r23, r18
    1934:	bb 27       	eor	r27, r27
    1936:	f0 0d       	add	r31, r0
    1938:	b1 1d       	adc	r27, r1
    193a:	63 9f       	mul	r22, r19
    193c:	aa 27       	eor	r26, r26
    193e:	f0 0d       	add	r31, r0
    1940:	b1 1d       	adc	r27, r1
    1942:	aa 1f       	adc	r26, r26
    1944:	64 9f       	mul	r22, r20
    1946:	66 27       	eor	r22, r22
    1948:	b0 0d       	add	r27, r0
    194a:	a1 1d       	adc	r26, r1
    194c:	66 1f       	adc	r22, r22
    194e:	82 9f       	mul	r24, r18
    1950:	22 27       	eor	r18, r18
    1952:	b0 0d       	add	r27, r0
    1954:	a1 1d       	adc	r26, r1
    1956:	62 1f       	adc	r22, r18
    1958:	73 9f       	mul	r23, r19
    195a:	b0 0d       	add	r27, r0
    195c:	a1 1d       	adc	r26, r1
    195e:	62 1f       	adc	r22, r18
    1960:	83 9f       	mul	r24, r19
    1962:	a0 0d       	add	r26, r0
    1964:	61 1d       	adc	r22, r1
    1966:	22 1f       	adc	r18, r18
    1968:	74 9f       	mul	r23, r20
    196a:	33 27       	eor	r19, r19
    196c:	a0 0d       	add	r26, r0
    196e:	61 1d       	adc	r22, r1
    1970:	23 1f       	adc	r18, r19
    1972:	84 9f       	mul	r24, r20
    1974:	60 0d       	add	r22, r0
    1976:	21 1d       	adc	r18, r1
    1978:	82 2f       	mov	r24, r18
    197a:	76 2f       	mov	r23, r22
    197c:	6a 2f       	mov	r22, r26
    197e:	11 24       	eor	r1, r1
    1980:	9f 57       	subi	r25, 0x7F	; 127
    1982:	50 40       	sbci	r21, 0x00	; 0
    1984:	9a f0       	brmi	.+38     	; 0x19ac <__mulsf3_pse+0x88>
    1986:	f1 f0       	breq	.+60     	; 0x19c4 <__mulsf3_pse+0xa0>
    1988:	88 23       	and	r24, r24
    198a:	4a f0       	brmi	.+18     	; 0x199e <__mulsf3_pse+0x7a>
    198c:	ee 0f       	add	r30, r30
    198e:	ff 1f       	adc	r31, r31
    1990:	bb 1f       	adc	r27, r27
    1992:	66 1f       	adc	r22, r22
    1994:	77 1f       	adc	r23, r23
    1996:	88 1f       	adc	r24, r24
    1998:	91 50       	subi	r25, 0x01	; 1
    199a:	50 40       	sbci	r21, 0x00	; 0
    199c:	a9 f7       	brne	.-22     	; 0x1988 <__mulsf3_pse+0x64>
    199e:	9e 3f       	cpi	r25, 0xFE	; 254
    19a0:	51 05       	cpc	r21, r1
    19a2:	80 f0       	brcs	.+32     	; 0x19c4 <__mulsf3_pse+0xa0>
    19a4:	0c 94 89 0b 	jmp	0x1712	; 0x1712 <__fp_inf>
    19a8:	0c 94 fb 0b 	jmp	0x17f6	; 0x17f6 <__fp_szero>
    19ac:	5f 3f       	cpi	r21, 0xFF	; 255
    19ae:	e4 f3       	brlt	.-8      	; 0x19a8 <__mulsf3_pse+0x84>
    19b0:	98 3e       	cpi	r25, 0xE8	; 232
    19b2:	d4 f3       	brlt	.-12     	; 0x19a8 <__mulsf3_pse+0x84>
    19b4:	86 95       	lsr	r24
    19b6:	77 95       	ror	r23
    19b8:	67 95       	ror	r22
    19ba:	b7 95       	ror	r27
    19bc:	f7 95       	ror	r31
    19be:	e7 95       	ror	r30
    19c0:	9f 5f       	subi	r25, 0xFF	; 255
    19c2:	c1 f7       	brne	.-16     	; 0x19b4 <__mulsf3_pse+0x90>
    19c4:	fe 2b       	or	r31, r30
    19c6:	88 0f       	add	r24, r24
    19c8:	91 1d       	adc	r25, r1
    19ca:	96 95       	lsr	r25
    19cc:	87 95       	ror	r24
    19ce:	97 f9       	bld	r25, 7
    19d0:	08 95       	ret

000019d2 <sin>:
    19d2:	9f 93       	push	r25
    19d4:	0e 94 01 0d 	call	0x1a02	; 0x1a02 <__fp_rempio2>
    19d8:	0f 90       	pop	r0
    19da:	07 fc       	sbrc	r0, 7
    19dc:	ee 5f       	subi	r30, 0xFE	; 254
    19de:	0c 94 2a 0d 	jmp	0x1a54	; 0x1a54 <__fp_sinus>

000019e2 <__fp_mpack>:
    19e2:	9f 3f       	cpi	r25, 0xFF	; 255
    19e4:	31 f0       	breq	.+12     	; 0x19f2 <__fp_mpack_finite+0xc>

000019e6 <__fp_mpack_finite>:
    19e6:	91 50       	subi	r25, 0x01	; 1
    19e8:	20 f4       	brcc	.+8      	; 0x19f2 <__fp_mpack_finite+0xc>
    19ea:	87 95       	ror	r24
    19ec:	77 95       	ror	r23
    19ee:	67 95       	ror	r22
    19f0:	b7 95       	ror	r27
    19f2:	88 0f       	add	r24, r24
    19f4:	91 1d       	adc	r25, r1
    19f6:	96 95       	lsr	r25
    19f8:	87 95       	ror	r24
    19fa:	97 f9       	bld	r25, 7
    19fc:	08 95       	ret
    19fe:	0c 94 8f 0b 	jmp	0x171e	; 0x171e <__fp_nan>

00001a02 <__fp_rempio2>:
    1a02:	0e 94 e0 0b 	call	0x17c0	; 0x17c0 <__fp_splitA>
    1a06:	d8 f3       	brcs	.-10     	; 0x19fe <__fp_mpack_finite+0x18>
    1a08:	e8 94       	clt
    1a0a:	e0 e0       	ldi	r30, 0x00	; 0
    1a0c:	bb 27       	eor	r27, r27
    1a0e:	9f 57       	subi	r25, 0x7F	; 127
    1a10:	f0 f0       	brcs	.+60     	; 0x1a4e <__fp_rempio2+0x4c>
    1a12:	2a ed       	ldi	r18, 0xDA	; 218
    1a14:	3f e0       	ldi	r19, 0x0F	; 15
    1a16:	49 ec       	ldi	r20, 0xC9	; 201
    1a18:	06 c0       	rjmp	.+12     	; 0x1a26 <__fp_rempio2+0x24>
    1a1a:	ee 0f       	add	r30, r30
    1a1c:	bb 0f       	add	r27, r27
    1a1e:	66 1f       	adc	r22, r22
    1a20:	77 1f       	adc	r23, r23
    1a22:	88 1f       	adc	r24, r24
    1a24:	28 f0       	brcs	.+10     	; 0x1a30 <__fp_rempio2+0x2e>
    1a26:	b2 3a       	cpi	r27, 0xA2	; 162
    1a28:	62 07       	cpc	r22, r18
    1a2a:	73 07       	cpc	r23, r19
    1a2c:	84 07       	cpc	r24, r20
    1a2e:	28 f0       	brcs	.+10     	; 0x1a3a <__fp_rempio2+0x38>
    1a30:	b2 5a       	subi	r27, 0xA2	; 162
    1a32:	62 0b       	sbc	r22, r18
    1a34:	73 0b       	sbc	r23, r19
    1a36:	84 0b       	sbc	r24, r20
    1a38:	e3 95       	inc	r30
    1a3a:	9a 95       	dec	r25
    1a3c:	72 f7       	brpl	.-36     	; 0x1a1a <__fp_rempio2+0x18>
    1a3e:	80 38       	cpi	r24, 0x80	; 128
    1a40:	30 f4       	brcc	.+12     	; 0x1a4e <__fp_rempio2+0x4c>
    1a42:	9a 95       	dec	r25
    1a44:	bb 0f       	add	r27, r27
    1a46:	66 1f       	adc	r22, r22
    1a48:	77 1f       	adc	r23, r23
    1a4a:	88 1f       	adc	r24, r24
    1a4c:	d2 f7       	brpl	.-12     	; 0x1a42 <__fp_rempio2+0x40>
    1a4e:	90 48       	sbci	r25, 0x80	; 128
    1a50:	0c 94 f3 0c 	jmp	0x19e6	; 0x19e6 <__fp_mpack_finite>

00001a54 <__fp_sinus>:
    1a54:	ef 93       	push	r30
    1a56:	e0 ff       	sbrs	r30, 0
    1a58:	07 c0       	rjmp	.+14     	; 0x1a68 <__fp_sinus+0x14>
    1a5a:	a2 ea       	ldi	r26, 0xA2	; 162
    1a5c:	2a ed       	ldi	r18, 0xDA	; 218
    1a5e:	3f e0       	ldi	r19, 0x0F	; 15
    1a60:	49 ec       	ldi	r20, 0xC9	; 201
    1a62:	5f eb       	ldi	r21, 0xBF	; 191
    1a64:	0e 94 cd 09 	call	0x139a	; 0x139a <__addsf3x>
    1a68:	0e 94 c7 0b 	call	0x178e	; 0x178e <__fp_round>
    1a6c:	0f 90       	pop	r0
    1a6e:	03 94       	inc	r0
    1a70:	01 fc       	sbrc	r0, 1
    1a72:	90 58       	subi	r25, 0x80	; 128
    1a74:	e4 ea       	ldi	r30, 0xA4	; 164
    1a76:	f0 e0       	ldi	r31, 0x00	; 0
    1a78:	0c 94 3e 0d 	jmp	0x1a7c	; 0x1a7c <__fp_powsodd>

00001a7c <__fp_powsodd>:
    1a7c:	9f 93       	push	r25
    1a7e:	8f 93       	push	r24
    1a80:	7f 93       	push	r23
    1a82:	6f 93       	push	r22
    1a84:	ff 93       	push	r31
    1a86:	ef 93       	push	r30
    1a88:	9b 01       	movw	r18, r22
    1a8a:	ac 01       	movw	r20, r24
    1a8c:	0e 94 7c 0c 	call	0x18f8	; 0x18f8 <__mulsf3>
    1a90:	ef 91       	pop	r30
    1a92:	ff 91       	pop	r31
    1a94:	0e 94 92 0b 	call	0x1724	; 0x1724 <__fp_powser>
    1a98:	2f 91       	pop	r18
    1a9a:	3f 91       	pop	r19
    1a9c:	4f 91       	pop	r20
    1a9e:	5f 91       	pop	r21
    1aa0:	0c 94 7c 0c 	jmp	0x18f8	; 0x18f8 <__mulsf3>

00001aa4 <__udivmodsi4>:
    1aa4:	a1 e2       	ldi	r26, 0x21	; 33
    1aa6:	1a 2e       	mov	r1, r26
    1aa8:	aa 1b       	sub	r26, r26
    1aaa:	bb 1b       	sub	r27, r27
    1aac:	fd 01       	movw	r30, r26
    1aae:	0d c0       	rjmp	.+26     	; 0x1aca <__udivmodsi4_ep>

00001ab0 <__udivmodsi4_loop>:
    1ab0:	aa 1f       	adc	r26, r26
    1ab2:	bb 1f       	adc	r27, r27
    1ab4:	ee 1f       	adc	r30, r30
    1ab6:	ff 1f       	adc	r31, r31
    1ab8:	a2 17       	cp	r26, r18
    1aba:	b3 07       	cpc	r27, r19
    1abc:	e4 07       	cpc	r30, r20
    1abe:	f5 07       	cpc	r31, r21
    1ac0:	20 f0       	brcs	.+8      	; 0x1aca <__udivmodsi4_ep>
    1ac2:	a2 1b       	sub	r26, r18
    1ac4:	b3 0b       	sbc	r27, r19
    1ac6:	e4 0b       	sbc	r30, r20
    1ac8:	f5 0b       	sbc	r31, r21

00001aca <__udivmodsi4_ep>:
    1aca:	66 1f       	adc	r22, r22
    1acc:	77 1f       	adc	r23, r23
    1ace:	88 1f       	adc	r24, r24
    1ad0:	99 1f       	adc	r25, r25
    1ad2:	1a 94       	dec	r1
    1ad4:	69 f7       	brne	.-38     	; 0x1ab0 <__udivmodsi4_loop>
    1ad6:	60 95       	com	r22
    1ad8:	70 95       	com	r23
    1ada:	80 95       	com	r24
    1adc:	90 95       	com	r25
    1ade:	9b 01       	movw	r18, r22
    1ae0:	ac 01       	movw	r20, r24
    1ae2:	bd 01       	movw	r22, r26
    1ae4:	cf 01       	movw	r24, r30
    1ae6:	08 95       	ret

00001ae8 <_exit>:
    1ae8:	f8 94       	cli

00001aea <__stop_program>:
    1aea:	ff cf       	rjmp	.-2      	; 0x1aea <__stop_program>
