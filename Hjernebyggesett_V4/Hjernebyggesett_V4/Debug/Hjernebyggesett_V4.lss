
Hjernebyggesett_V4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000016  00803800  00001afd  00001bb1  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001ac0  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       0000003d  00009ac0  00001ac0  00001b74  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .bss          0000005c  00803816  00803816  00001bc7  2**0
                  ALLOC
  4 .comment      00000030  00000000  00000000  00001bc7  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001bf8  2**2
                  CONTENTS, READONLY
  6 .debug_aranges 00000540  00000000  00000000  00001c38  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00008baa  00000000  00000000  00002178  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00003702  00000000  00000000  0000ad22  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00002bec  00000000  00000000  0000e424  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000934  00000000  00000000  00011010  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000036d0  00000000  00000000  00011944  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00001654  00000000  00000000  00015014  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 000003d0  00000000  00000000  00016668  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 61 00 	jmp	0xc2	; 0xc2 <__ctors_end>
       4:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
       8:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
       c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      10:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      14:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      18:	0c 94 50 05 	jmp	0xaa0	; 0xaa0 <__vector_6>
      1c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      20:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      24:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      28:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      2c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      30:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      34:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      38:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      3c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      40:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      44:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      48:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      4c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      50:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      54:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      58:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      5c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      60:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      64:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      68:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      6c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      70:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      74:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      78:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      7c:	07 63       	ori	r16, 0x37	; 55
      7e:	42 36       	cpi	r20, 0x62	; 98
      80:	b7 9b       	sbis	0x16, 7	; 22
      82:	d8 a7       	std	Y+40, r29	; 0x28
      84:	1a 39       	cpi	r17, 0x9A	; 154
      86:	68 56       	subi	r22, 0x68	; 104
      88:	18 ae       	std	Y+56, r1	; 0x38
      8a:	ba ab       	std	Y+50, r27	; 0x32
      8c:	55 8c       	ldd	r5, Z+29	; 0x1d
      8e:	1d 3c       	cpi	r17, 0xCD	; 205
      90:	b7 cc       	rjmp	.-1682   	; 0xfffffa00 <__eeprom_end+0xff7efa00>
      92:	57 63       	ori	r21, 0x37	; 55
      94:	bd 6d       	ori	r27, 0xDD	; 221
      96:	ed fd       	.word	0xfded	; ????
      98:	75 3e       	cpi	r23, 0xE5	; 229
      9a:	f6 17       	cp	r31, r22
      9c:	72 31       	cpi	r23, 0x12	; 18
      9e:	bf 00       	.word	0x00bf	; ????
      a0:	00 00       	nop
      a2:	80 3f       	cpi	r24, 0xF0	; 240
      a4:	05 a8       	ldd	r0, Z+53	; 0x35
      a6:	4c cd       	rjmp	.-1384   	; 0xfffffb40 <__eeprom_end+0xff7efb40>
      a8:	b2 d4       	rcall	.+2404   	; 0xa0e <tinyDendrite_update_signals+0xdc>
      aa:	4e b9       	out	0x0e, r20	; 14
      ac:	38 36       	cpi	r19, 0x68	; 104
      ae:	a9 02       	muls	r26, r25
      b0:	0c 50       	subi	r16, 0x0C	; 12
      b2:	b9 91       	ld	r27, Y+
      b4:	86 88       	ldd	r8, Z+22	; 0x16
      b6:	08 3c       	cpi	r16, 0xC8	; 200
      b8:	a6 aa       	std	Z+54, r10	; 0x36
      ba:	aa 2a       	or	r10, r26
      bc:	be 00       	.word	0x00be	; ????
      be:	00 00       	nop
      c0:	80 3f       	cpi	r24, 0xF0	; 240

000000c2 <__ctors_end>:
      c2:	11 24       	eor	r1, r1
      c4:	1f be       	out	0x3f, r1	; 63
      c6:	cf ef       	ldi	r28, 0xFF	; 255
      c8:	cd bf       	out	0x3d, r28	; 61
      ca:	df e3       	ldi	r29, 0x3F	; 63
      cc:	de bf       	out	0x3e, r29	; 62

000000ce <__do_copy_data>:
      ce:	18 e3       	ldi	r17, 0x38	; 56
      d0:	a0 e0       	ldi	r26, 0x00	; 0
      d2:	b8 e3       	ldi	r27, 0x38	; 56
      d4:	ed ef       	ldi	r30, 0xFD	; 253
      d6:	fa e1       	ldi	r31, 0x1A	; 26
      d8:	02 c0       	rjmp	.+4      	; 0xde <__do_copy_data+0x10>
      da:	05 90       	lpm	r0, Z+
      dc:	0d 92       	st	X+, r0
      de:	a6 31       	cpi	r26, 0x16	; 22
      e0:	b1 07       	cpc	r27, r17
      e2:	d9 f7       	brne	.-10     	; 0xda <__do_copy_data+0xc>

000000e4 <__do_clear_bss>:
      e4:	28 e3       	ldi	r18, 0x38	; 56
      e6:	a6 e1       	ldi	r26, 0x16	; 22
      e8:	b8 e3       	ldi	r27, 0x38	; 56
      ea:	01 c0       	rjmp	.+2      	; 0xee <.do_clear_bss_start>

000000ec <.do_clear_bss_loop>:
      ec:	1d 92       	st	X+, r1

000000ee <.do_clear_bss_start>:
      ee:	a2 37       	cpi	r26, 0x72	; 114
      f0:	b2 07       	cpc	r27, r18
      f2:	e1 f7       	brne	.-8      	; 0xec <.do_clear_bss_loop>
      f4:	0e 94 83 00 	call	0x106	; 0x106 <main>
      f8:	0c 94 5e 0d 	jmp	0x1abc	; 0x1abc <_exit>

000000fc <__bad_interrupt>:
      fc:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000100 <atmel_start_init>:
/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
	system_init();
     100:	0e 94 ae 01 	call	0x35c	; 0x35c <system_init>
     104:	08 95       	ret

00000106 <main>:

int main(void)
{	
	
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
     106:	0e 94 80 00 	call	0x100	; 0x100 <atmel_start_init>
	Setting this value will mean that the ADC (Analog to Digital Converter) will read 4.32v as 255, and 0v as 0.
	For some reason, instead of the reference voltage being 4.32v, it is 3.3v. 
	A plausible explanation is that the microchip does not up the voltage, so that if the microchip is only ever 
	supplied with 3.3v, it will output 3.3v as the max.
	*/
	VREF.CTRLA |= VREF_DAC0REFSEL_4V34_gc;
     10a:	e0 ea       	ldi	r30, 0xA0	; 160
     10c:	f0 e0       	ldi	r31, 0x00	; 0
     10e:	80 81       	ld	r24, Z
     110:	83 60       	ori	r24, 0x03	; 3
     112:	80 83       	st	Z, r24
	
	while (1)
	{
		// We don't want to update the neuron too often because of various reasons. The tinyISR_getflag is set every ms, and so the loop is only run once every ms.  
		if(tinyISR_getflag())
     114:	0e 94 7e 05 	call	0xafc	; 0xafc <tinyISR_getflag>
     118:	88 23       	and	r24, r24
     11a:	e1 f3       	breq	.-8      	; 0x114 <main+0xe>
		{
			// Check if the neuron is connected to a charger (High potential on dendrites or axon)
			tinyCharge_update_charging_mode();
     11c:	0e 94 14 04 	call	0x828	; 0x828 <tinyCharge_update_charging_mode>
			
			if(tinyCharge_is_connected_to_charger()){
     120:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <tinyCharge_is_connected_to_charger>
     124:	88 23       	and	r24, r24
     126:	b9 f0       	breq	.+46     	; 0x156 <main+0x50>
				
				// Charge loop
				
				if(tinyCharge_is_fully_charged()){
     128:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <tinyCharge_is_fully_charged>
     12c:	88 23       	and	r24, r24
     12e:	49 f0       	breq	.+18     	; 0x142 <main+0x3c>
					// When the neuron is connected to a charger, and fully charged:
					tinyLED_set_color(INN_LED, CHARGING_DONE_COLOR);
     130:	64 e0       	ldi	r22, 0x04	; 4
     132:	80 e0       	ldi	r24, 0x00	; 0
     134:	0e 94 c5 05 	call	0xb8a	; 0xb8a <tinyLED_set_color>
					tinyLED_set_color(OUT_LED, LED_OFF);
     138:	60 e0       	ldi	r22, 0x00	; 0
     13a:	81 e0       	ldi	r24, 0x01	; 1
     13c:	0e 94 c5 05 	call	0xb8a	; 0xb8a <tinyLED_set_color>
     140:	1a c0       	rjmp	.+52     	; 0x176 <main+0x70>
				}
				else{
					// When the neuron is charging and is not fully charged
					tinyLED_set_color_mode(OUT_LED, CHARGING_COLOR, SWING);
     142:	43 e0       	ldi	r20, 0x03	; 3
     144:	62 e0       	ldi	r22, 0x02	; 2
     146:	81 e0       	ldi	r24, 0x01	; 1
     148:	0e 94 9d 05 	call	0xb3a	; 0xb3a <tinyLED_set_color_mode>
					tinyLED_set_color(INN_LED, LED_OFF);
     14c:	60 e0       	ldi	r22, 0x00	; 0
     14e:	80 e0       	ldi	r24, 0x00	; 0
     150:	0e 94 c5 05 	call	0xb8a	; 0xb8a <tinyLED_set_color>
     154:	10 c0       	rjmp	.+32     	; 0x176 <main+0x70>
				// Main loop			
				
				// Set LED
				// If the out led is turned LED_OFF, and the ping color is not disabled,
				// we turn on ping mode
				if(tinyLED_get_color(OUT_LED) == LED_OFF && PING_COLOR != LED_OFF){
     156:	81 e0       	ldi	r24, 0x01	; 1
     158:	0e 94 95 05 	call	0xb2a	; 0xb2a <tinyLED_get_color>
					tinyLED_set_color_mode(OUT_LED, PING_COLOR, PING);
				}
				if(tinyLED_get_color(INN_LED) == LED_OFF){
     15c:	80 e0       	ldi	r24, 0x00	; 0
     15e:	0e 94 95 05 	call	0xb2a	; 0xb2a <tinyLED_get_color>
     162:	81 11       	cpse	r24, r1
     164:	04 c0       	rjmp	.+8      	; 0x16e <main+0x68>
					// Display potential level with LED
					tinyLED_set_color_mode(INN_LED, CHANGING_COLOR, POTENTIAL);
     166:	46 e0       	ldi	r20, 0x06	; 6
     168:	61 e0       	ldi	r22, 0x01	; 1
     16a:	0e 94 9d 05 	call	0xb3a	; 0xb3a <tinyLED_set_color_mode>
				}
				
				// Update button	
				tinyButton_update();
     16e:	0e 94 73 03 	call	0x6e6	; 0x6e6 <tinyButton_update>
				
				// Update the potential (This is where most of the important stuff happens)
				tinyPotential_update();
     172:	0e 94 a7 08 	call	0x114e	; 0x114e <tinyPotential_update>
			}
			
			// Update LED
			tinyLED_update();
     176:	0e 94 f9 05 	call	0xbf2	; 0xbf2 <tinyLED_update>
				
			// Switch transistors
			tinyCharge_set_transistors();
     17a:	0e 94 4e 04 	call	0x89c	; 0x89c <tinyCharge_set_transistors>
			
			// Prepare for next cycle
			tinyISR_setflag(false);
     17e:	80 e0       	ldi	r24, 0x00	; 0
     180:	0e 94 7b 05 	call	0xaf6	; 0xaf6 <tinyISR_setflag>
			tinyDebugger_send_uint32("time", tinyTime_now());
     184:	0e 94 96 09 	call	0x132c	; 0x132c <tinyTime_now>
     188:	ab 01       	movw	r20, r22
     18a:	bc 01       	movw	r22, r24
     18c:	80 ec       	ldi	r24, 0xC0	; 192
     18e:	9a e9       	ldi	r25, 0x9A	; 154
     190:	0e 94 59 04 	call	0x8b2	; 0x8b2 <tinyDebugger_send_uint32>
			tinyDebugger_end_line();
     194:	0e 94 5c 04 	call	0x8b8	; 0x8b8 <tinyDebugger_end_line>
     198:	bd cf       	rjmp	.-134    	; 0x114 <main+0xe>

0000019a <ADC_0_init>:
 * \return Conversion result read from the ADC_0 ADC module
 */
adc_result_t ADC_0_get_conversion_result(void)
{
	return (ADC1.RES);
}
     19a:	e0 e4       	ldi	r30, 0x40	; 64
     19c:	f6 e0       	ldi	r31, 0x06	; 6
     19e:	80 e1       	ldi	r24, 0x10	; 16
     1a0:	82 83       	std	Z+2, r24	; 0x02
     1a2:	85 e0       	ldi	r24, 0x05	; 5
     1a4:	80 83       	st	Z, r24
     1a6:	80 e0       	ldi	r24, 0x00	; 0
     1a8:	08 95       	ret

000001aa <ADC_0_is_conversion_done>:
     1aa:	80 91 4b 06 	lds	r24, 0x064B	; 0x80064b <__TEXT_REGION_LENGTH__+0x70064b>
     1ae:	81 70       	andi	r24, 0x01	; 1
     1b0:	08 95       	ret

000001b2 <ADC_0_get_conversion>:
 *
 * \return Nothing
 */
void ADC_0_start_conversion(adc_1_channel_t channel)
{
	ADC1.MUXPOS  = channel;
     1b2:	e0 e4       	ldi	r30, 0x40	; 64
     1b4:	f6 e0       	ldi	r31, 0x06	; 6
     1b6:	86 83       	std	Z+6, r24	; 0x06
	ADC1.COMMAND = ADC_STCONV_bm;
     1b8:	81 e0       	ldi	r24, 0x01	; 1
     1ba:	80 87       	std	Z+8, r24	; 0x08
adc_result_t ADC_0_get_conversion(adc_1_channel_t channel)
{
	adc_result_t res;

	ADC_0_start_conversion(channel);
	while (!ADC_0_is_conversion_done())
     1bc:	0e 94 d5 00 	call	0x1aa	; 0x1aa <ADC_0_is_conversion_done>
     1c0:	88 23       	and	r24, r24
     1c2:	e1 f3       	breq	.-8      	; 0x1bc <ADC_0_get_conversion+0xa>
 *
 * \return Conversion result read from the ADC_0 ADC module
 */
adc_result_t ADC_0_get_conversion_result(void)
{
	return (ADC1.RES);
     1c4:	e0 e4       	ldi	r30, 0x40	; 64
     1c6:	f6 e0       	ldi	r31, 0x06	; 6
     1c8:	20 89       	ldd	r18, Z+16	; 0x10
     1ca:	31 89       	ldd	r19, Z+17	; 0x11

	ADC_0_start_conversion(channel);
	while (!ADC_0_is_conversion_done())
		;
	res = ADC_0_get_conversion_result();
	ADC1.INTFLAGS |= ADC_RESRDY_bm;
     1cc:	93 85       	ldd	r25, Z+11	; 0x0b
     1ce:	91 60       	ori	r25, 0x01	; 1
     1d0:	93 87       	std	Z+11, r25	; 0x0b
	return res;
}
     1d2:	c9 01       	movw	r24, r18
     1d4:	08 95       	ret

000001d6 <BOD_init>:
	//		 | BOD_VLMCFG_BELOW_gc; /* Interrupt when supply goes below VLM level */

	// BOD.VLMCTRLA = BOD_VLMLVL_5ABOVE_gc; /* VLM threshold 5% above BOD level */

	return 0;
}
     1d6:	80 e0       	ldi	r24, 0x00	; 0
     1d8:	08 95       	ret

000001da <DIGITAL_GLUE_LOGIC_0_init>:

	// Enable Protected register, peripheral must be disabled (ENABLE=0, in TCD.LUT0CTRLA).

	// CCL.SEQCTRL0 = CCL_SEQSEL_DISABLE_gc /* Sequential logic disabled */;

	CCL.TRUTH0 = 168; /* Truth 0: 168 */
     1da:	e0 ec       	ldi	r30, 0xC0	; 192
     1dc:	f1 e0       	ldi	r31, 0x01	; 1
     1de:	28 ea       	ldi	r18, 0xA8	; 168
     1e0:	20 87       	std	Z+8, r18	; 0x08

	CCL.LUT0CTRLC = CCL_INSEL2_TCA0_gc /* TCA0 WO2 input source */;
     1e2:	98 e0       	ldi	r25, 0x08	; 8
     1e4:	97 83       	std	Z+7, r25	; 0x07

	CCL.LUT0CTRLB = CCL_INSEL0_SPI0_gc /* SPI0 SCK source */
     1e6:	8b eb       	ldi	r24, 0xBB	; 187
     1e8:	86 83       	std	Z+6, r24	; 0x06
	                | CCL_INSEL1_SPI0_gc /* SPI0 MOSI input source */;

	CCL.LUT0CTRLA = 0 << CCL_CLKSRC_bp       /* Clock Source Selection: disabled */
     1ea:	39 e0       	ldi	r19, 0x09	; 9
     1ec:	35 83       	std	Z+5, r19	; 0x05
	                | CCL_EDGEDET_DIS_gc     /* Edge detector is disabled */
	                | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	                | 1 << CCL_ENABLE_bp     /* LUT Enable: enabled */
	                | 1 << CCL_OUTEN_bp;     /* Output Enable: enabled */

	CCL.TRUTH1 = 168; /* Truth 1: 168 */
     1ee:	24 87       	std	Z+12, r18	; 0x0c

	CCL.LUT1CTRLC = CCL_INSEL2_TCA0_gc /* TCA0 WO2 input source */;
     1f0:	93 87       	std	Z+11, r25	; 0x0b

	CCL.LUT1CTRLB = CCL_INSEL0_SPI0_gc /* SPI0 SCK source */
     1f2:	82 87       	std	Z+10, r24	; 0x0a
	//		 | CCL_EDGEDET_DIS_gc /* Edge detector is disabled */
	//		 | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	//		 | 0 << CCL_ENABLE_bp /* LUT Enable: disabled */
	//		 | 0 << CCL_OUTEN_bp; /* Output Enable: disabled */

	CCL.CTRLA = 1 << CCL_ENABLE_bp      /* Enable: enabled */
     1f4:	81 e4       	ldi	r24, 0x41	; 65
     1f6:	80 83       	st	Z, r24
	            | 1 << CCL_RUNSTDBY_bp; /* Run in Standby: enabled */

	return 0;
}
     1f8:	80 e0       	ldi	r24, 0x00	; 0
     1fa:	08 95       	ret

000001fc <CLKCTRL_init>:
 *       on calling convention. The memory model is not visible to the
 *       preprocessor, so it must be defined in the Assembler preprocessor directives.
 */
static inline void ccp_write_io(void *addr, uint8_t value)
{
	protected_write_io(addr, CCP_IOREG_gc, value);
     1fc:	47 e0       	ldi	r20, 0x07	; 7
     1fe:	68 ed       	ldi	r22, 0xD8	; 216
     200:	8c e7       	ldi	r24, 0x7C	; 124
     202:	90 e0       	ldi	r25, 0x00	; 0
     204:	0e 94 dd 01 	call	0x3ba	; 0x3ba <protected_write_io>
     208:	41 e0       	ldi	r20, 0x01	; 1
     20a:	68 ed       	ldi	r22, 0xD8	; 216
     20c:	81 e6       	ldi	r24, 0x61	; 97
     20e:	90 e0       	ldi	r25, 0x00	; 0
     210:	0e 94 dd 01 	call	0x3ba	; 0x3ba <protected_write_io>
	//		 | 0 << CLKCTRL_CLKOUT_bp /* System clock out: disabled */);

	// ccp_write_io((void*)&(CLKCTRL.MCLKLOCK),0 << CLKCTRL_LOCKEN_bp /* lock enable: disabled */);

	return 0;
}
     214:	80 e0       	ldi	r24, 0x00	; 0
     216:	08 95       	ret

00000218 <CPUINT_init>:

	// CPUINT.LVL0PRI = 0x0 << CPUINT_LVL0PRI_gp; /* Interrupt Level Priority: 0x0 */

	// CPUINT.LVL1VEC = 0x0 << CPUINT_LVL1VEC_gp; /* Interrupt Vector with High Priority: 0x0 */

	ENABLE_INTERRUPTS();
     218:	78 94       	sei

	return 0;
}
     21a:	80 e0       	ldi	r24, 0x00	; 0
     21c:	08 95       	ret

0000021e <DAC_0_init>:
int8_t DAC_0_init()
{

	// DAC0.DATA = 0x0; /* DATA Register: 0x0 */

	DAC0.CTRLA = 1 << DAC_ENABLE_bp      /* DAC Enable: enabled */
     21e:	81 e4       	ldi	r24, 0x41	; 65
     220:	80 93 a0 06 	sts	0x06A0, r24	; 0x8006a0 <__TEXT_REGION_LENGTH__+0x7006a0>
	             | 1 << DAC_OUTEN_bp     /* Output Buffer Enable: enabled */
	             | 0 << DAC_RUNSTDBY_bp; /* Run in Standby Mode: disabled */

	return 0;
}
     224:	80 e0       	ldi	r24, 0x00	; 0
     226:	08 95       	ret

00000228 <DAC_0_uninit>:
int8_t DAC_0_uninit()
{

	// DAC0.DATA = 0x0; /* DATA Register: 0x0 */

	DAC0.CTRLA = 1 << DAC_ENABLE_bp      /* DAC Enable: enabled */
     228:	81 e0       	ldi	r24, 0x01	; 1
     22a:	80 93 a0 06 	sts	0x06A0, r24	; 0x8006a0 <__TEXT_REGION_LENGTH__+0x7006a0>
	| 0 << DAC_OUTEN_bp     /* Output Buffer Enable: disabled */
	| 0 << DAC_RUNSTDBY_bp; /* Run in Standby Mode: disabled */

	return 0;
}
     22e:	80 e0       	ldi	r24, 0x00	; 0
     230:	08 95       	ret

00000232 <DAC_0_enable>:
 *
 * \return Nothing
 */
void DAC_0_enable()
{
	DAC0.CTRLA |= DAC_ENABLE_bm;
     232:	e0 ea       	ldi	r30, 0xA0	; 160
     234:	f6 e0       	ldi	r31, 0x06	; 6
     236:	80 81       	ld	r24, Z
     238:	81 60       	ori	r24, 0x01	; 1
     23a:	80 83       	st	Z, r24
     23c:	08 95       	ret

0000023e <DAC_0_disable>:
 *
 * \return Nothing
 */
void DAC_0_disable()
{
	DAC0.CTRLA &= ~DAC_ENABLE_bm;
     23e:	e0 ea       	ldi	r30, 0xA0	; 160
     240:	f6 e0       	ldi	r31, 0x06	; 6
     242:	80 81       	ld	r24, Z
     244:	8e 7f       	andi	r24, 0xFE	; 254
     246:	80 83       	st	Z, r24
     248:	08 95       	ret

0000024a <DAC_0_set_output>:
 *
 * \return Nothing
 */
void DAC_0_set_output(dac_resolution_t value)
{
	DAC0.DATA = value;
     24a:	80 93 a1 06 	sts	0x06A1, r24	; 0x8006a1 <__TEXT_REGION_LENGTH__+0x7006a1>
     24e:	08 95       	ret

00000250 <mcu_init>:
#ifdef __cplusplus
extern "C" {
#endif

void mcu_init(void)
{
     250:	e0 e1       	ldi	r30, 0x10	; 16
     252:	f4 e0       	ldi	r31, 0x04	; 4
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     254:	80 81       	ld	r24, Z
     256:	88 60       	ori	r24, 0x08	; 8
     258:	81 93       	st	Z+, r24
	 * disables all peripherals to save power. Driver shall enable
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
     25a:	e8 31       	cpi	r30, 0x18	; 24
     25c:	84 e0       	ldi	r24, 0x04	; 4
     25e:	f8 07       	cpc	r31, r24
     260:	c9 f7       	brne	.-14     	; 0x254 <mcu_init+0x4>
     262:	e0 e3       	ldi	r30, 0x30	; 48
     264:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     266:	80 81       	ld	r24, Z
     268:	88 60       	ori	r24, 0x08	; 8
     26a:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     26c:	e8 33       	cpi	r30, 0x38	; 56
     26e:	84 e0       	ldi	r24, 0x04	; 4
     270:	f8 07       	cpc	r31, r24
     272:	c9 f7       	brne	.-14     	; 0x266 <mcu_init+0x16>
     274:	e0 e5       	ldi	r30, 0x50	; 80
     276:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     278:	80 81       	ld	r24, Z
     27a:	88 60       	ori	r24, 0x08	; 8
     27c:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     27e:	e8 35       	cpi	r30, 0x58	; 88
     280:	84 e0       	ldi	r24, 0x04	; 4
     282:	f8 07       	cpc	r31, r24
     284:	c9 f7       	brne	.-14     	; 0x278 <mcu_init+0x28>
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}
}
     286:	08 95       	ret

00000288 <ADC_0_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     288:	e5 e1       	ldi	r30, 0x15	; 21
     28a:	f4 e0       	ldi	r31, 0x04	; 4
     28c:	80 81       	ld	r24, Z
     28e:	88 7f       	andi	r24, 0xF8	; 248
     290:	84 60       	ori	r24, 0x04	; 4
     292:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     294:	80 81       	ld	r24, Z
     296:	87 7f       	andi	r24, 0xF7	; 247
     298:	80 83       	st	Z, r24
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     29a:	e7 e1       	ldi	r30, 0x17	; 23
     29c:	f4 e0       	ldi	r31, 0x04	; 4
     29e:	80 81       	ld	r24, Z
     2a0:	88 7f       	andi	r24, 0xF8	; 248
     2a2:	84 60       	ori	r24, 0x04	; 4
     2a4:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2a6:	80 81       	ld	r24, Z
     2a8:	87 7f       	andi	r24, 0xF7	; 247
     2aa:	80 83       	st	Z, r24
 */
static inline void PORTC_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     2ac:	e0 e5       	ldi	r30, 0x50	; 80
     2ae:	f4 e0       	ldi	r31, 0x04	; 4
     2b0:	80 81       	ld	r24, Z
     2b2:	88 7f       	andi	r24, 0xF8	; 248
     2b4:	84 60       	ori	r24, 0x04	; 4
     2b6:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2b8:	80 81       	ld	r24, Z
     2ba:	87 7f       	andi	r24, 0xF7	; 247
     2bc:	80 83       	st	Z, r24
 */
static inline void PORTC_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     2be:	e1 e5       	ldi	r30, 0x51	; 81
     2c0:	f4 e0       	ldi	r31, 0x04	; 4
     2c2:	80 81       	ld	r24, Z
     2c4:	88 7f       	andi	r24, 0xF8	; 248
     2c6:	84 60       	ori	r24, 0x04	; 4
     2c8:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2ca:	80 81       	ld	r24, Z
     2cc:	87 7f       	andi	r24, 0xF7	; 247
     2ce:	80 83       	st	Z, r24
 */
static inline void PORTC_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     2d0:	e3 e5       	ldi	r30, 0x53	; 83
     2d2:	f4 e0       	ldi	r31, 0x04	; 4
     2d4:	80 81       	ld	r24, Z
     2d6:	88 7f       	andi	r24, 0xF8	; 248
     2d8:	84 60       	ori	r24, 0x04	; 4
     2da:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2dc:	80 81       	ld	r24, Z
     2de:	87 7f       	andi	r24, 0xF7	; 247
     2e0:	80 83       	st	Z, r24
	// Disable digital input buffer
	DEN4_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	DEN4_PIN_set_pull_mode(PORT_PULL_OFF);

	ADC_0_init();
     2e2:	0e 94 cd 00 	call	0x19a	; 0x19a <ADC_0_init>
     2e6:	08 95       	ret

000002e8 <USART_0_initialization>:
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     2e8:	23 98       	cbi	0x04, 3	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2ea:	e3 e3       	ldi	r30, 0x33	; 51
     2ec:	f4 e0       	ldi	r31, 0x04	; 4
     2ee:	80 81       	ld	r24, Z
     2f0:	87 7f       	andi	r24, 0xF7	; 247
     2f2:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     2f4:	22 9a       	sbi	0x04, 2	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     2f6:	2a 98       	cbi	0x05, 2	; 5
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	USART_0_init();
     2f8:	0e 94 15 02 	call	0x42a	; 0x42a <USART_0_init>
     2fc:	08 95       	ret

000002fe <TIMER_0_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     2fe:	25 9a       	sbi	0x04, 5	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     300:	2d 98       	cbi	0x05, 5	; 5
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLC |= PORTMUX_TCA02_bm;
     302:	e0 e0       	ldi	r30, 0x00	; 0
     304:	f2 e0       	ldi	r31, 0x02	; 2
     306:	82 81       	ldd	r24, Z+2	; 0x02
     308:	84 60       	ori	r24, 0x04	; 4
     30a:	82 83       	std	Z+2, r24	; 0x02

	TIMER_0_init();
     30c:	0e 94 05 02 	call	0x40a	; 0x40a <TIMER_0_init>
     310:	08 95       	ret

00000312 <DIGITAL_GLUE_LOGIC_0_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     312:	24 9a       	sbi	0x04, 4	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     314:	2c 98       	cbi	0x05, 4	; 5
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLA |= PORTMUX_LUT0_bm;
     316:	e0 e0       	ldi	r30, 0x00	; 0
     318:	f2 e0       	ldi	r31, 0x02	; 2
     31a:	80 81       	ld	r24, Z
     31c:	80 61       	ori	r24, 0x10	; 16
     31e:	80 83       	st	Z, r24

	DIGITAL_GLUE_LOGIC_0_init();
     320:	0e 94 ed 00 	call	0x1da	; 0x1da <DIGITAL_GLUE_LOGIC_0_init>
     324:	08 95       	ret

00000326 <SPI_0_initialization>:
 */
static inline void PORTA_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
     326:	02 98       	cbi	0x00, 2	; 0
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     328:	e2 e1       	ldi	r30, 0x12	; 18
     32a:	f4 e0       	ldi	r31, 0x04	; 4
     32c:	80 81       	ld	r24, Z
     32e:	87 7f       	andi	r24, 0xF7	; 247
     330:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     332:	01 9a       	sbi	0x00, 1	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     334:	09 98       	cbi	0x01, 1	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     336:	03 9a       	sbi	0x00, 3	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     338:	0b 98       	cbi	0x01, 3	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     33a:	04 9a       	sbi	0x00, 4	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     33c:	0c 98       	cbi	0x01, 4	; 1
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	SPI_0_init();
     33e:	0e 94 fd 01 	call	0x3fa	; 0x3fa <SPI_0_init>
     342:	08 95       	ret

00000344 <DAC_0_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     344:	e6 e1       	ldi	r30, 0x16	; 22
     346:	f4 e0       	ldi	r31, 0x04	; 4
     348:	80 81       	ld	r24, Z
     34a:	88 7f       	andi	r24, 0xF8	; 248
     34c:	84 60       	ori	r24, 0x04	; 4
     34e:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     350:	80 81       	ld	r24, Z
     352:	87 7f       	andi	r24, 0xF7	; 247
     354:	80 83       	st	Z, r24
	// Disable digital input buffer
	AXON_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	AXON_PIN_set_pull_mode(PORT_PULL_OFF);

	DAC_0_init();
     356:	0e 94 0f 01 	call	0x21e	; 0x21e <DAC_0_init>
     35a:	08 95       	ret

0000035c <system_init>:
/**
 * \brief System initialization
 */
void system_init()
{
	mcu_init();
     35c:	0e 94 28 01 	call	0x250	; 0x250 <mcu_init>
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     360:	21 9a       	sbi	0x04, 1	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     362:	29 98       	cbi	0x05, 1	; 5
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     364:	26 98       	cbi	0x04, 6	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     366:	e6 e3       	ldi	r30, 0x36	; 54
     368:	f4 e0       	ldi	r31, 0x04	; 4
     36a:	80 81       	ld	r24, Z
     36c:	87 7f       	andi	r24, 0xF7	; 247
     36e:	80 83       	st	Z, r24
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     370:	27 98       	cbi	0x04, 7	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     372:	e7 e3       	ldi	r30, 0x37	; 55
     374:	f4 e0       	ldi	r31, 0x04	; 4
     376:	80 81       	ld	r24, Z
     378:	87 7f       	andi	r24, 0xF7	; 247
     37a:	80 83       	st	Z, r24
 */
static inline void PORTC_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
     37c:	42 98       	cbi	0x08, 2	; 8
static inline void PORTC_set_pin_pull_mode(const uint8_t pin, const enum port_pull_mode pull_mode)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
     37e:	e2 e5       	ldi	r30, 0x52	; 82
     380:	f4 e0       	ldi	r31, 0x04	; 4
     382:	80 81       	ld	r24, Z
     384:	88 60       	ori	r24, 0x08	; 8
     386:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTC.DIR |= (1 << pin);
     388:	45 9a       	sbi	0x08, 5	; 8
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     38a:	4d 9a       	sbi	0x09, 5	; 9
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    true);

	CLKCTRL_init();
     38c:	0e 94 fe 00 	call	0x1fc	; 0x1fc <CLKCTRL_init>

	RTC_0_init();
     390:	0e 94 e1 01 	call	0x3c2	; 0x3c2 <RTC_0_init>

	ADC_0_initialization();
     394:	0e 94 44 01 	call	0x288	; 0x288 <ADC_0_initialization>

	USART_0_initialization();
     398:	0e 94 74 01 	call	0x2e8	; 0x2e8 <USART_0_initialization>

	TIMER_0_initialization();
     39c:	0e 94 7f 01 	call	0x2fe	; 0x2fe <TIMER_0_initialization>

	DIGITAL_GLUE_LOGIC_0_initialization();
     3a0:	0e 94 89 01 	call	0x312	; 0x312 <DIGITAL_GLUE_LOGIC_0_initialization>

	SPI_0_initialization();
     3a4:	0e 94 93 01 	call	0x326	; 0x326 <SPI_0_initialization>

	DAC_0_initialization();
     3a8:	0e 94 a2 01 	call	0x344	; 0x344 <DAC_0_initialization>

	CPUINT_init();
     3ac:	0e 94 0c 01 	call	0x218	; 0x218 <CPUINT_init>

	SLPCTRL_init();
     3b0:	0e 94 fb 01 	call	0x3f6	; 0x3f6 <SLPCTRL_init>

	BOD_init();
     3b4:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <BOD_init>
     3b8:	08 95       	ret

000003ba <protected_write_io>:
#if defined(__GNUC__)
  
#ifdef RAMPZ
	out     _SFR_IO_ADDR(RAMPZ), r1         // Clear bits 23:16 of Z
#endif
	movw    r30, r24                // Load addr into Z
     3ba:	fc 01       	movw	r30, r24
	out     CCP, r22                // Start CCP handshake
     3bc:	64 bf       	out	0x34, r22	; 52
	st      Z, r20                  // Write value to I/O register
     3be:	40 83       	st	Z, r20
	ret                             // Return to caller
     3c0:	08 95       	ret

000003c2 <RTC_0_init>:
 * \return Initialization status.
 */
int8_t RTC_0_init()
{

	while (RTC.STATUS > 0) { /* Wait for all register to be synchronized */
     3c2:	e0 e4       	ldi	r30, 0x40	; 64
     3c4:	f1 e0       	ldi	r31, 0x01	; 1
     3c6:	81 81       	ldd	r24, Z+1	; 0x01
     3c8:	81 11       	cpse	r24, r1
     3ca:	fd cf       	rjmp	.-6      	; 0x3c6 <RTC_0_init+0x4>
	}

	// RTC.CMP = 0x0; /* Compare: 0x0 */

	RTC.CNT = 0x20; /* Counter: 0x20 */
     3cc:	e0 e4       	ldi	r30, 0x40	; 64
     3ce:	f1 e0       	ldi	r31, 0x01	; 1
     3d0:	80 e2       	ldi	r24, 0x20	; 32
     3d2:	90 e0       	ldi	r25, 0x00	; 0
     3d4:	80 87       	std	Z+8, r24	; 0x08
     3d6:	91 87       	std	Z+9, r25	; 0x09

	RTC.CTRLA = RTC_PRESCALER_DIV1_gc   /* 1 */
     3d8:	21 e8       	ldi	r18, 0x81	; 129
     3da:	20 83       	st	Z, r18
	            | 1 << RTC_RTCEN_bp     /* Enable: enabled */
	            | 1 << RTC_RUNSTDBY_bp; /* Run In Standby: enabled */

	RTC.PER = 0x20 / TIMESCALE; /* Period: 0x20 */
     3dc:	82 87       	std	Z+10, r24	; 0x0a
     3de:	93 87       	std	Z+11, r25	; 0x0b

	// RTC.CLKSEL = RTC_CLKSEL_INT32K_gc; /* 32KHz Internal Ultra Low Power Oscillator (OSCULP32K) */

	RTC.DBGCTRL = 1 << RTC_DBGRUN_bp; /* Run in debug: enabled */
     3e0:	81 e0       	ldi	r24, 0x01	; 1
     3e2:	85 83       	std	Z+5, r24	; 0x05

	RTC.INTCTRL = 0 << RTC_CMP_bp    /* Compare Match Interrupt enable: disabled */
     3e4:	82 83       	std	Z+2, r24	; 0x02
	              | 1 << RTC_OVF_bp; /* Overflow Interrupt enable: enabled */

	while (RTC.PITSTATUS > 0) { /* Wait for all register to be synchronized */
     3e6:	81 89       	ldd	r24, Z+17	; 0x11
     3e8:	81 11       	cpse	r24, r1
     3ea:	fd cf       	rjmp	.-6      	; 0x3e6 <RTC_0_init+0x24>
	}

	RTC.PITCTRLA = RTC_PERIOD_OFF_gc    /* Off */
     3ec:	81 e0       	ldi	r24, 0x01	; 1
     3ee:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <__TEXT_REGION_LENGTH__+0x700150>
	// RTC.PITDBGCTRL = 0 << RTC_DBGRUN_bp; /* Run in debug: disabled */

	// RTC.PITINTCTRL = 0 << RTC_PI_bp; /* Periodic Interrupt: disabled */

	return 0;
}
     3f2:	80 e0       	ldi	r24, 0x00	; 0
     3f4:	08 95       	ret

000003f6 <SLPCTRL_init>:

	// SLPCTRL.CTRLA = 0 << SLPCTRL_SEN_bp /* Sleep enable: disabled */
	//		 | SLPCTRL_SMODE_IDLE_gc; /* Idle mode */

	return 0;
}
     3f6:	80 e0       	ldi	r24, 0x00	; 0
     3f8:	08 95       	ret

000003fa <SPI_0_init>:
 * \return Initialization status
 */
int8_t SPI_0_init()
{

	SPI0.CTRLA = 0 << SPI_CLK2X_bp     /* Enable Double Speed: disabled */
     3fa:	e0 e2       	ldi	r30, 0x20	; 32
     3fc:	f8 e0       	ldi	r31, 0x08	; 8
     3fe:	83 e2       	ldi	r24, 0x23	; 35
     400:	80 83       	st	Z, r24
	             | 0 << SPI_DORD_bp    /* Data Order Setting: disabled */
	             | 1 << SPI_ENABLE_bp  /* Enable Module: enabled */
	             | 1 << SPI_MASTER_bp  /* SPI module in master mode */
	             | SPI_PRESC_DIV16_gc; /* System Clock / 16 */

	SPI0.CTRLB = 0 << SPI_BUFEN_bp   /* Buffer Mode Enable: disabled */
     402:	84 e0       	ldi	r24, 0x04	; 4
     404:	81 83       	std	Z+1, r24	; 0x01
	//		 | 0 << SPI_RXCIE_bp /* Receive Complete Interrupt Enable: disabled */
	//		 | 0 << SPI_SSIE_bp /* Slave Select Trigger Interrupt Enable: disabled */
	//		 | 0 << SPI_TXCIE_bp; /* Transfer Complete Interrupt Enable: disabled */

	return 0;
}
     406:	80 e0       	ldi	r24, 0x00	; 0
     408:	08 95       	ret

0000040a <TIMER_0_init>:

	// TCA0.SINGLE.CMP0 = 0x0; /* Compare Register 0: 0x0 */

	// TCA0.SINGLE.CMP1 = 0x0; /* Compare Register 1: 0x0 */

	TCA0.SINGLE.CMP2 = 0x4; /* Compare Register 2: 0x4 */
     40a:	e0 e0       	ldi	r30, 0x00	; 0
     40c:	fa e0       	ldi	r31, 0x0A	; 10
     40e:	84 e0       	ldi	r24, 0x04	; 4
     410:	90 e0       	ldi	r25, 0x00	; 0
     412:	84 a7       	std	Z+44, r24	; 0x2c
     414:	95 a7       	std	Z+45, r25	; 0x2d

	// TCA0.SINGLE.CNT = 0x0; /* Count: 0x0 */

	TCA0.SINGLE.CTRLB = 0 << TCA_SINGLE_ALUPD_bp            /* Auto Lock Update: disabled */
     416:	83 e4       	ldi	r24, 0x43	; 67
     418:	81 83       	std	Z+1, r24	; 0x01
	                    | 0 << TCA_SINGLE_CMP0EN_bp         /* Compare 0 Enable: disabled */
	                    | 0 << TCA_SINGLE_CMP1EN_bp         /* Compare 1 Enable: disabled */
	                    | 1 << TCA_SINGLE_CMP2EN_bp         /* Compare 2 Enable: enabled */
	                    | TCA_SINGLE_WGMODE_SINGLESLOPE_gc; /*  */

	TCA0.SINGLE.CTRLC = 0 << TCA_SINGLE_CMP0OV_bp    /* Compare 0 Waveform Output Value: disabled */
     41a:	84 e0       	ldi	r24, 0x04	; 4
     41c:	82 83       	std	Z+2, r24	; 0x02
	// TCA0.SINGLE.INTCTRL = 0 << TCA_SINGLE_CMP0_bp /* Compare 0 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP1_bp /* Compare 1 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP2_bp /* Compare 2 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_OVF_bp; /* Overflow Interrupt: disabled */

	TCA0.SINGLE.PER = 0x7; /* Period: 0x7 */
     41e:	87 e0       	ldi	r24, 0x07	; 7
     420:	90 e0       	ldi	r25, 0x00	; 0
     422:	86 a3       	std	Z+38, r24	; 0x26
     424:	97 a3       	std	Z+39, r25	; 0x27

	// TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV1_gc /* System Clock */
	//		 | 0 << TCA_SINGLE_ENABLE_bp; /* Module Enable: disabled */

	return 0;
}
     426:	80 e0       	ldi	r24, 0x00	; 0
     428:	08 95       	ret

0000042a <USART_0_init>:
uint8_t USART_0_read()
{
	while (!(USART0.STATUS & USART_RXCIF_bm))
		;
	return USART0.RXDATAL;
}
     42a:	e0 e0       	ldi	r30, 0x00	; 0
     42c:	f8 e0       	ldi	r31, 0x08	; 8
     42e:	8b e5       	ldi	r24, 0x5B	; 91
     430:	91 e0       	ldi	r25, 0x01	; 1
     432:	80 87       	std	Z+8, r24	; 0x08
     434:	91 87       	std	Z+9, r25	; 0x09
     436:	80 ec       	ldi	r24, 0xC0	; 192
     438:	86 83       	std	Z+6, r24	; 0x06
     43a:	80 e0       	ldi	r24, 0x00	; 0
     43c:	98 e3       	ldi	r25, 0x38	; 56
     43e:	80 93 6e 38 	sts	0x386E, r24	; 0x80386e <__iob+0x2>
     442:	90 93 6f 38 	sts	0x386F, r25	; 0x80386f <__iob+0x3>
     446:	80 e0       	ldi	r24, 0x00	; 0
     448:	08 95       	ret

0000044a <USART_0_write>:
 *
 * \return Nothing
 */
void USART_0_write(const uint8_t data)
{
	while (!(USART0.STATUS & USART_DREIF_bm))
     44a:	e0 e0       	ldi	r30, 0x00	; 0
     44c:	f8 e0       	ldi	r31, 0x08	; 8
     44e:	94 81       	ldd	r25, Z+4	; 0x04
     450:	95 ff       	sbrs	r25, 5
     452:	fd cf       	rjmp	.-6      	; 0x44e <USART_0_write+0x4>
		;
	USART0.TXDATAL = data;
     454:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <__TEXT_REGION_LENGTH__+0x700802>
     458:	08 95       	ret

0000045a <USART_0_printCHAR>:

#if defined(__GNUC__)

int USART_0_printCHAR(char character, FILE *stream)
{
	USART_0_write(character);
     45a:	0e 94 25 02 	call	0x44a	; 0x44a <USART_0_write>
	return 0;
}
     45e:	80 e0       	ldi	r24, 0x00	; 0
     460:	90 e0       	ldi	r25, 0x00	; 0
     462:	08 95       	ret

00000464 <tinyAxon_add_pulse>:
{
	// We want to check each slot in the pulse_queue, and
	// if we find an empty slot (0), we add a pulse.
	for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
	{
		if(pulse_queue[i] == 0){
     464:	20 91 16 38 	lds	r18, 0x3816	; 0x803816 <__data_end>
     468:	30 91 17 38 	lds	r19, 0x3817	; 0x803817 <__data_end+0x1>
     46c:	23 2b       	or	r18, r19
     46e:	51 f0       	breq	.+20     	; 0x484 <tinyAxon_add_pulse+0x20>
     470:	e8 e1       	ldi	r30, 0x18	; 24
     472:	f8 e3       	ldi	r31, 0x38	; 56
     474:	21 e0       	ldi	r18, 0x01	; 1
     476:	30 e0       	ldi	r19, 0x00	; 0
     478:	b9 01       	movw	r22, r18
     47a:	41 91       	ld	r20, Z+
     47c:	51 91       	ld	r21, Z+
     47e:	45 2b       	or	r20, r21
     480:	81 f4       	brne	.+32     	; 0x4a2 <tinyAxon_add_pulse+0x3e>
     482:	02 c0       	rjmp	.+4      	; 0x488 <tinyAxon_add_pulse+0x24>
     484:	60 e0       	ldi	r22, 0x00	; 0
     486:	70 e0       	ldi	r23, 0x00	; 0
			pulse_queue[i] = new_pulse;
     488:	66 0f       	add	r22, r22
     48a:	77 1f       	adc	r23, r23
     48c:	fb 01       	movw	r30, r22
     48e:	ea 5e       	subi	r30, 0xEA	; 234
     490:	f7 4c       	sbci	r31, 0xC7	; 199
     492:	80 83       	st	Z, r24
     494:	91 83       	std	Z+1, r25	; 0x01
			pulses_in_queue++;
     496:	80 91 2a 38 	lds	r24, 0x382A	; 0x80382a <pulses_in_queue>
     49a:	8f 5f       	subi	r24, 0xFF	; 255
     49c:	80 93 2a 38 	sts	0x382A, r24	; 0x80382a <pulses_in_queue>
			// We return so we only ever add one
			break;
     4a0:	08 95       	ret
     4a2:	2f 5f       	subi	r18, 0xFF	; 255
     4a4:	3f 4f       	sbci	r19, 0xFF	; 255
*/
static void tinyAxon_add_pulse(uint16_t new_pulse)
{
	// We want to check each slot in the pulse_queue, and
	// if we find an empty slot (0), we add a pulse.
	for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
     4a6:	2a 30       	cpi	r18, 0x0A	; 10
     4a8:	31 05       	cpc	r19, r1
     4aa:	31 f7       	brne	.-52     	; 0x478 <tinyAxon_add_pulse+0x14>
     4ac:	08 95       	ret

000004ae <tinyAxon_is_firing>:
// DAC has no DAC_0_get_output, so we keep track of this here.
uint8_t axonOutputValue = 0;


_Bool tinyAxon_is_firing(){
	return axonOutputValue != NO_SIGNAL_OUTPUT;
     4ae:	81 e0       	ldi	r24, 0x01	; 1
     4b0:	90 91 2b 38 	lds	r25, 0x382B	; 0x80382b <axonOutputValue>
     4b4:	91 11       	cpse	r25, r1
     4b6:	01 c0       	rjmp	.+2      	; 0x4ba <tinyAxon_is_firing+0xc>
     4b8:	80 e0       	ldi	r24, 0x00	; 0
}
     4ba:	08 95       	ret

000004bc <tinyAxon_get_pulses_in_queue>:
uint8_t pulses_in_queue = 0; //variable to determine how many pulses are in queue.

uint8_t tinyAxon_get_pulses_in_queue()
{
	return pulses_in_queue;
}
     4bc:	80 91 2a 38 	lds	r24, 0x382A	; 0x80382a <pulses_in_queue>
     4c0:	08 95       	ret

000004c2 <find_newest_pulse>:
uint8_t find_newest_pulse() {
	uint16_t max;
	uint8_t current_index = 0;
	uint8_t return_index = 0;
	
	max = pulse_queue[current_index];
     4c2:	40 91 16 38 	lds	r20, 0x3816	; 0x803816 <__data_end>
     4c6:	50 91 17 38 	lds	r21, 0x3817	; 0x803817 <__data_end+0x1>
     4ca:	e8 e1       	ldi	r30, 0x18	; 24
     4cc:	f8 e3       	ldi	r31, 0x38	; 56
	
// This function will be used with pulse_queue to find the newest pulse
uint8_t find_newest_pulse() {
	uint16_t max;
	uint8_t current_index = 0;
	uint8_t return_index = 0;
     4ce:	80 e0       	ldi	r24, 0x00	; 0
	
	max = pulse_queue[current_index];
	
	for (current_index = 1; current_index < MAX_NUMBER_OF_PULSES; current_index++) {
     4d0:	91 e0       	ldi	r25, 0x01	; 1
		if (pulse_queue[current_index] > max) {
     4d2:	21 91       	ld	r18, Z+
     4d4:	31 91       	ld	r19, Z+
     4d6:	42 17       	cp	r20, r18
     4d8:	53 07       	cpc	r21, r19
     4da:	10 f4       	brcc	.+4      	; 0x4e0 <find_newest_pulse+0x1e>
     4dc:	89 2f       	mov	r24, r25
			return_index = current_index;
			max = pulse_queue[current_index];
     4de:	a9 01       	movw	r20, r18
	uint8_t current_index = 0;
	uint8_t return_index = 0;
	
	max = pulse_queue[current_index];
	
	for (current_index = 1; current_index < MAX_NUMBER_OF_PULSES; current_index++) {
     4e0:	9f 5f       	subi	r25, 0xFF	; 255
     4e2:	9a 30       	cpi	r25, 0x0A	; 10
     4e4:	b1 f7       	brne	.-20     	; 0x4d2 <find_newest_pulse+0x10>
			return_index = current_index;
			max = pulse_queue[current_index];
		}
	}
	return return_index;
}
     4e6:	08 95       	ret

000004e8 <tinyAxon_time_until_next_pulse>:


// This function will be used with in the tinyLED to determine how long the light should flash
uint16_t tinyAxon_time_until_next_pulse(){
     4e8:	cf 93       	push	r28
     4ea:	df 93       	push	r29
     4ec:	e6 e1       	ldi	r30, 0x16	; 22
     4ee:	f8 e3       	ldi	r31, 0x38	; 56
     4f0:	2a e2       	ldi	r18, 0x2A	; 42
     4f2:	38 e3       	ldi	r19, 0x38	; 56
	uint16_t min_pulse = 65530;
     4f4:	ca ef       	ldi	r28, 0xFA	; 250
     4f6:	df ef       	ldi	r29, 0xFF	; 255
	
	for (uint8_t current_index = 0; current_index < MAX_NUMBER_OF_PULSES; current_index++) {
		// We don't count pluses with time=0, they have already bee fired.
		if (pulse_queue[current_index] < min_pulse && pulse_queue[current_index] > 0) {
     4f8:	81 91       	ld	r24, Z+
     4fa:	91 91       	ld	r25, Z+
     4fc:	8c 17       	cp	r24, r28
     4fe:	9d 07       	cpc	r25, r29
     500:	18 f4       	brcc	.+6      	; 0x508 <tinyAxon_time_until_next_pulse+0x20>
     502:	00 97       	sbiw	r24, 0x00	; 0
     504:	09 f0       	breq	.+2      	; 0x508 <tinyAxon_time_until_next_pulse+0x20>
			min_pulse = pulse_queue[current_index];
     506:	ec 01       	movw	r28, r24

// This function will be used with in the tinyLED to determine how long the light should flash
uint16_t tinyAxon_time_until_next_pulse(){
	uint16_t min_pulse = 65530;
	
	for (uint8_t current_index = 0; current_index < MAX_NUMBER_OF_PULSES; current_index++) {
     508:	e2 17       	cp	r30, r18
     50a:	f3 07       	cpc	r31, r19
     50c:	a9 f7       	brne	.-22     	; 0x4f8 <tinyAxon_time_until_next_pulse+0x10>
		// We don't count pluses with time=0, they have already bee fired.
		if (pulse_queue[current_index] < min_pulse && pulse_queue[current_index] > 0) {
			min_pulse = pulse_queue[current_index];
		}
	}
	tinyDebugger_send_uint32("Next Pulse", min_pulse);
     50e:	ae 01       	movw	r20, r28
     510:	60 e0       	ldi	r22, 0x00	; 0
     512:	70 e0       	ldi	r23, 0x00	; 0
     514:	85 ec       	ldi	r24, 0xC5	; 197
     516:	9a e9       	ldi	r25, 0x9A	; 154
     518:	0e 94 59 04 	call	0x8b2	; 0x8b2 <tinyDebugger_send_uint32>
	return min_pulse;
}
     51c:	ce 01       	movw	r24, r28
     51e:	df 91       	pop	r29
     520:	cf 91       	pop	r28
     522:	08 95       	ret

00000524 <tinyAxon_stop_sending_pulse>:
	tinyLED_set_color_mode(OUT_LED, WHITE, FLASH_ONCE);
}

void tinyAxon_stop_sending_pulse()
{
	DAC_0_set_output(NO_SIGNAL_OUTPUT);
     524:	80 e0       	ldi	r24, 0x00	; 0
     526:	90 e0       	ldi	r25, 0x00	; 0
     528:	0e 94 25 01 	call	0x24a	; 0x24a <DAC_0_set_output>
	axonOutputValue=NO_SIGNAL_OUTPUT;
     52c:	10 92 2b 38 	sts	0x382B, r1	; 0x80382b <axonOutputValue>
     530:	08 95       	ret

00000532 <tinyAxon_remove_pulse>:

/*
If the potential is very low, we want to try to remove a pulse.
*/
bool tinyAxon_remove_pulse(void)
{
     532:	cf 93       	push	r28
	// We want to return a bool indicating whether or not a pulse actually was removed.
	if(pulses_in_queue == 0){
     534:	c0 91 2a 38 	lds	r28, 0x382A	; 0x80382a <pulses_in_queue>
     538:	cc 23       	and	r28, r28
     53a:	c1 f0       	breq	.+48     	; 0x56c <tinyAxon_remove_pulse+0x3a>
		//There was no pulse to remove.
		return false;
	}
	else{
		// If we are to remove a pulse, we want to remove the one that will fire last.
		uint8_t pulse_index = find_newest_pulse();
     53c:	0e 94 61 02 	call	0x4c2	; 0x4c2 <find_newest_pulse>
		uint16_t newest_pulse = pulse_queue[pulse_index];
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	fc 01       	movw	r30, r24
     544:	ee 0f       	add	r30, r30
     546:	ff 1f       	adc	r31, r31
     548:	ea 5e       	subi	r30, 0xEA	; 234
     54a:	f7 4c       	sbci	r31, 0xC7	; 199
	
		// Now we want to check if the pulse is too far away to be affected by the low potential, or close enough that we decide to remove it.
		// (When we say that the pulse is too far away, it refers to the biological process of how the potential spreads from Dendrites to axon).
		if(newest_pulse > PULSE_NO_RETURN_TIME){
     54c:	20 81       	ld	r18, Z
     54e:	31 81       	ldd	r19, Z+1	; 0x01
     550:	23 2b       	or	r18, r19
     552:	71 f0       	breq	.+28     	; 0x570 <tinyAxon_remove_pulse+0x3e>
			// We decided to remove the pulse
			pulse_queue[pulse_index] = 0;
     554:	88 0f       	add	r24, r24
     556:	99 1f       	adc	r25, r25
     558:	fc 01       	movw	r30, r24
     55a:	ea 5e       	subi	r30, 0xEA	; 234
     55c:	f7 4c       	sbci	r31, 0xC7	; 199
     55e:	10 82       	st	Z, r1
     560:	11 82       	std	Z+1, r1	; 0x01
			pulses_in_queue--;
     562:	c1 50       	subi	r28, 0x01	; 1
     564:	c0 93 2a 38 	sts	0x382A, r28	; 0x80382a <pulses_in_queue>
			return true;
     568:	81 e0       	ldi	r24, 0x01	; 1
     56a:	03 c0       	rjmp	.+6      	; 0x572 <tinyAxon_remove_pulse+0x40>
bool tinyAxon_remove_pulse(void)
{
	// We want to return a bool indicating whether or not a pulse actually was removed.
	if(pulses_in_queue == 0){
		//There was no pulse to remove.
		return false;
     56c:	80 e0       	ldi	r24, 0x00	; 0
     56e:	01 c0       	rjmp	.+2      	; 0x572 <tinyAxon_remove_pulse+0x40>
			pulses_in_queue--;
			return true;
		}
		// Here we have found that there is a pulse queued, but it is old enough to let pass anyway, so now we need to put it back into the queue.
		else{
			return false;
     570:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     572:	cf 91       	pop	r28
     574:	08 95       	ret

00000576 <tinyAxon_update_potential>:
/*
Decides whether or not the axon should fire
If the axon does fire, the potential is reduced
*/
double tinyAxon_update_potential(double potential)
{	
     576:	cf 92       	push	r12
     578:	df 92       	push	r13
     57a:	ef 92       	push	r14
     57c:	ff 92       	push	r15
     57e:	6b 01       	movw	r12, r22
     580:	7c 01       	movw	r14, r24
	//While the neuron has enough potential to fire, we want to fire more
	while (potential >= THRESHOLD_POTENTIAL)
     582:	20 e0       	ldi	r18, 0x00	; 0
     584:	30 e0       	ldi	r19, 0x00	; 0
     586:	48 ec       	ldi	r20, 0xC8	; 200
     588:	51 e4       	ldi	r21, 0x41	; 65
     58a:	0e 94 eb 0b 	call	0x17d6	; 0x17d6 <__gesf2>
     58e:	88 23       	and	r24, r24
     590:	84 f1       	brlt	.+96     	; 0x5f2 <tinyAxon_update_potential+0x7c>
	{
		// We have to check if there are already queued pulses, so that the frequency never exceeds FIRE_DELAY
		if(pulses_in_queue>0){
     592:	80 91 2a 38 	lds	r24, 0x382A	; 0x80382a <pulses_in_queue>
     596:	88 23       	and	r24, r24
     598:	b1 f0       	breq	.+44     	; 0x5c6 <tinyAxon_update_potential+0x50>
			uint16_t newest_pulse = pulse_queue[find_newest_pulse()];
     59a:	0e 94 61 02 	call	0x4c2	; 0x4c2 <find_newest_pulse>
     59e:	e8 2f       	mov	r30, r24
     5a0:	f0 e0       	ldi	r31, 0x00	; 0
     5a2:	ee 0f       	add	r30, r30
     5a4:	ff 1f       	adc	r31, r31
     5a6:	ea 5e       	subi	r30, 0xEA	; 234
     5a8:	f7 4c       	sbci	r31, 0xC7	; 199
			
			// There is at least one pulse in the queue, and it is "so close", that we need to offset the new pulse, so that we keep at least
			// one FIRE_DELAY between each pulse
			if(newest_pulse + FIRE_DELAY > TRAVLE_DELAY){
     5aa:	80 81       	ld	r24, Z
     5ac:	91 81       	ldd	r25, Z+1	; 0x01
     5ae:	0f 96       	adiw	r24, 0x0f	; 15
     5b0:	85 36       	cpi	r24, 0x65	; 101
     5b2:	91 05       	cpc	r25, r1
     5b4:	18 f0       	brcs	.+6      	; 0x5bc <tinyAxon_update_potential+0x46>
				tinyAxon_add_pulse(newest_pulse + FIRE_DELAY);
     5b6:	0e 94 32 02 	call	0x464	; 0x464 <tinyAxon_add_pulse>
     5ba:	09 c0       	rjmp	.+18     	; 0x5ce <tinyAxon_update_potential+0x58>
			}
			// There is at least one pulse in the queue, but it's "far enough away" to ignore
			else{
				tinyAxon_add_pulse(TRAVLE_DELAY);
     5bc:	84 e6       	ldi	r24, 0x64	; 100
     5be:	90 e0       	ldi	r25, 0x00	; 0
     5c0:	0e 94 32 02 	call	0x464	; 0x464 <tinyAxon_add_pulse>
     5c4:	04 c0       	rjmp	.+8      	; 0x5ce <tinyAxon_update_potential+0x58>
			}
		}
		// There are no pulses in the queue, so we add a pulse as normal
		else{
			tinyAxon_add_pulse(TRAVLE_DELAY);		
     5c6:	84 e6       	ldi	r24, 0x64	; 100
     5c8:	90 e0       	ldi	r25, 0x00	; 0
     5ca:	0e 94 32 02 	call	0x464	; 0x464 <tinyAxon_add_pulse>
		}
		
		potential += POSTFIRE_POTENTIAL_REACTION; // This is usually defined as a negative value, don't be confused by the +=
     5ce:	20 e0       	ldi	r18, 0x00	; 0
     5d0:	30 e0       	ldi	r19, 0x00	; 0
     5d2:	48 ec       	ldi	r20, 0xC8	; 200
     5d4:	51 e4       	ldi	r21, 0x41	; 65
     5d6:	c7 01       	movw	r24, r14
     5d8:	b6 01       	movw	r22, r12
     5da:	0e 94 9f 09 	call	0x133e	; 0x133e <__subsf3>
     5de:	6b 01       	movw	r12, r22
     5e0:	7c 01       	movw	r14, r24
If the axon does fire, the potential is reduced
*/
double tinyAxon_update_potential(double potential)
{	
	//While the neuron has enough potential to fire, we want to fire more
	while (potential >= THRESHOLD_POTENTIAL)
     5e2:	20 e0       	ldi	r18, 0x00	; 0
     5e4:	30 e0       	ldi	r19, 0x00	; 0
     5e6:	48 ec       	ldi	r20, 0xC8	; 200
     5e8:	51 e4       	ldi	r21, 0x41	; 65
     5ea:	0e 94 eb 0b 	call	0x17d6	; 0x17d6 <__gesf2>
     5ee:	88 23       	and	r24, r24
     5f0:	84 f6       	brge	.-96     	; 0x592 <tinyAxon_update_potential+0x1c>
		// Why the hell is this line here? It shoudln't i think...
		//tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
	}
	
	// If the neuron has a very low potential, we want to remove a pulse from the queue (if there is one)
	if(potential < REMOVE_PULSE_THRESHOLD) // REMOVE_PULSE_THRESHOLD is a negative number
     5f2:	20 e0       	ldi	r18, 0x00	; 0
     5f4:	30 e0       	ldi	r19, 0x00	; 0
     5f6:	40 ea       	ldi	r20, 0xA0	; 160
     5f8:	51 ec       	ldi	r21, 0xC1	; 193
     5fa:	c7 01       	movw	r24, r14
     5fc:	b6 01       	movw	r22, r12
     5fe:	0e 94 0c 0a 	call	0x1418	; 0x1418 <__cmpsf2>
     602:	88 23       	and	r24, r24
     604:	0c f0       	brlt	.+2      	; 0x608 <tinyAxon_update_potential+0x92>
     606:	46 c0       	rjmp	.+140    	; 0x694 <tinyAxon_update_potential+0x11e>
	{
		if(pulses_in_queue > 0)
     608:	80 91 2a 38 	lds	r24, 0x382A	; 0x80382a <pulses_in_queue>
     60c:	88 23       	and	r24, r24
     60e:	11 f1       	breq	.+68     	; 0x654 <tinyAxon_update_potential+0xde>
		{
			// The neurons potential is low enough to attempt to remove a queued fire (Fire less)
			if(tinyAxon_remove_pulse())
     610:	0e 94 99 02 	call	0x532	; 0x532 <tinyAxon_remove_pulse>
     614:	88 23       	and	r24, r24
     616:	f1 f1       	breq	.+124    	; 0x694 <tinyAxon_update_potential+0x11e>
			{
				// The potential has evened out a bit
				potential += THRESHOLD_POTENTIAL;
     618:	20 e0       	ldi	r18, 0x00	; 0
     61a:	30 e0       	ldi	r19, 0x00	; 0
     61c:	48 ec       	ldi	r20, 0xC8	; 200
     61e:	51 e4       	ldi	r21, 0x41	; 65
     620:	c7 01       	movw	r24, r14
     622:	b6 01       	movw	r22, r12
     624:	0e 94 a0 09 	call	0x1340	; 0x1340 <__addsf3>
     628:	6b 01       	movw	r12, r22
     62a:	7c 01       	movw	r14, r24
     62c:	33 c0       	rjmp	.+102    	; 0x694 <tinyAxon_update_potential+0x11e>
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
	{
		for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
		{
			if(pulse_queue[i] != 0){
     62e:	80 81       	ld	r24, Z
     630:	91 81       	ldd	r25, Z+1	; 0x01
     632:	00 97       	sbiw	r24, 0x00	; 0
     634:	39 f0       	breq	.+14     	; 0x644 <tinyAxon_update_potential+0xce>
				pulse_queue[i]--;
     636:	01 97       	sbiw	r24, 0x01	; 1
     638:	80 83       	st	Z, r24
     63a:	91 83       	std	Z+1, r25	; 0x01
				
				// If the time went from 1 to 0, we fire the axon
				if(pulse_queue[i] == 0){
     63c:	89 2b       	or	r24, r25
     63e:	11 f4       	brne	.+4      	; 0x644 <tinyAxon_update_potential+0xce>
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
	pulses_in_queue--;
     640:	41 50       	subi	r20, 0x01	; 1
Function to set firing.
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
     642:	51 e0       	ldi	r21, 0x01	; 1
     644:	32 96       	adiw	r30, 0x02	; 2
	}
	
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
	{
		for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
     646:	e2 17       	cp	r30, r18
     648:	f3 07       	cpc	r31, r19
     64a:	89 f7       	brne	.-30     	; 0x62e <tinyAxon_update_potential+0xb8>
     64c:	50 93 2c 38 	sts	0x382C, r21	; 0x80382c <tinyAxon_should_fire>
     650:	40 93 2a 38 	sts	0x382A, r20	; 0x80382a <pulses_in_queue>
The function should set the DAC to fire for two
update cycles once the pulse flag is set high.
*/
static void tinyAxon_update_pulse_transmitter(void)
{
	if (tinyAxon_should_fire)
     654:	80 91 2c 38 	lds	r24, 0x382C	; 0x80382c <tinyAxon_should_fire>
     658:	88 23       	and	r24, r24
     65a:	91 f0       	breq	.+36     	; 0x680 <tinyAxon_update_potential+0x10a>
	{
		tinyAxon_should_fire = false;
     65c:	10 92 2c 38 	sts	0x382C, r1	; 0x80382c <tinyAxon_should_fire>
*/
static void tinyAxon_start_sending_pulse()
{
	if (NEURONTYPE == EXCITATORY_NEURON)
	{
		DAC_0_set_output(EXCITATORY_NEURON_OUTPUT);
     660:	8c ee       	ldi	r24, 0xEC	; 236
     662:	90 e0       	ldi	r25, 0x00	; 0
     664:	0e 94 25 01 	call	0x24a	; 0x24a <DAC_0_set_output>
		axonOutputValue=EXCITATORY_NEURON_OUTPUT;
     668:	8c ee       	ldi	r24, 0xEC	; 236
     66a:	80 93 2b 38 	sts	0x382B, r24	; 0x80382b <axonOutputValue>
	{
		DAC_0_set_output(INHIBITORY_NEURON_OUTPUT);
		axonOutputValue=INHIBITORY_NEURON_OUTPUT;
	}
	
	tinyLED_set_color_mode(OUT_LED, WHITE, FLASH_ONCE);
     66e:	45 e0       	ldi	r20, 0x05	; 5
     670:	66 e0       	ldi	r22, 0x06	; 6
     672:	81 e0       	ldi	r24, 0x01	; 1
     674:	0e 94 9d 05 	call	0xb3a	; 0xb3a <tinyLED_set_color_mode>
{
	if (tinyAxon_should_fire)
	{
		tinyAxon_should_fire = false;
		tinyAxon_start_sending_pulse();
		tinyAxon_has_just_fired = true;
     678:	81 e0       	ldi	r24, 0x01	; 1
     67a:	80 93 2d 38 	sts	0x382D, r24	; 0x80382d <tinyAxon_has_just_fired>
     67e:	15 c0       	rjmp	.+42     	; 0x6aa <tinyAxon_update_potential+0x134>
		
	}
	else if (tinyAxon_has_just_fired)
     680:	80 91 2d 38 	lds	r24, 0x382D	; 0x80382d <tinyAxon_has_just_fired>
     684:	88 23       	and	r24, r24
     686:	19 f0       	breq	.+6      	; 0x68e <tinyAxon_update_potential+0x118>
	{
		tinyAxon_has_just_fired = false;
     688:	10 92 2d 38 	sts	0x382D, r1	; 0x80382d <tinyAxon_has_just_fired>
     68c:	0e c0       	rjmp	.+28     	; 0x6aa <tinyAxon_update_potential+0x134>
	}
	else if (!tinyAxon_has_just_fired && !tinyAxon_should_fire)
	{
		tinyAxon_stop_sending_pulse();
     68e:	0e 94 92 02 	call	0x524	; 0x524 <tinyAxon_stop_sending_pulse>
     692:	0b c0       	rjmp	.+22     	; 0x6aa <tinyAxon_update_potential+0x134>
			}
		}
	}
	
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
     694:	40 91 2a 38 	lds	r20, 0x382A	; 0x80382a <pulses_in_queue>
     698:	44 23       	and	r20, r20
     69a:	e1 f2       	breq	.-72     	; 0x654 <tinyAxon_update_potential+0xde>
     69c:	50 91 2c 38 	lds	r21, 0x382C	; 0x80382c <tinyAxon_should_fire>
     6a0:	e6 e1       	ldi	r30, 0x16	; 22
     6a2:	f8 e3       	ldi	r31, 0x38	; 56
     6a4:	2a e2       	ldi	r18, 0x2A	; 42
     6a6:	38 e3       	ldi	r19, 0x38	; 56
     6a8:	c2 cf       	rjmp	.-124    	; 0x62e <tinyAxon_update_potential+0xb8>
	}
	
	// Here we set the actual output of the DAC (Digital to Analog Converter)
	tinyAxon_update_pulse_transmitter();
	
	tinyDebugger_send_uint8("Axon", axonOutputValue);
     6aa:	60 91 2b 38 	lds	r22, 0x382B	; 0x80382b <axonOutputValue>
     6ae:	80 ed       	ldi	r24, 0xD0	; 208
     6b0:	9a e9       	ldi	r25, 0x9A	; 154
     6b2:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("Pulses", pulses_in_queue);
     6b6:	60 91 2a 38 	lds	r22, 0x382A	; 0x80382a <pulses_in_queue>
     6ba:	85 ed       	ldi	r24, 0xD5	; 213
     6bc:	9a e9       	ldi	r25, 0x9A	; 154
     6be:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <tinyDebugger_send_uint8>
	
	
	return potential;
}
     6c2:	c7 01       	movw	r24, r14
     6c4:	b6 01       	movw	r22, r12
     6c6:	ff 90       	pop	r15
     6c8:	ef 90       	pop	r14
     6ca:	df 90       	pop	r13
     6cc:	cf 90       	pop	r12
     6ce:	08 95       	ret

000006d0 <tinyAxon_check_charge_level>:


_Bool tinyAxon_check_charge_level(void)
{
	// We check the AXON_CHECK_PIN. If it is hight while the axon is not firing, it must be connected to a charger
	return (AXON_CHECK_PIN_get_level() && !tinyAxon_has_just_fired);
     6d0:	37 9b       	sbis	0x06, 7	; 6
     6d2:	05 c0       	rjmp	.+10     	; 0x6de <tinyAxon_check_charge_level+0xe>
     6d4:	90 91 2d 38 	lds	r25, 0x382D	; 0x80382d <tinyAxon_has_just_fired>
     6d8:	81 e0       	ldi	r24, 0x01	; 1
     6da:	89 27       	eor	r24, r25
     6dc:	02 c0       	rjmp	.+4      	; 0x6e2 <tinyAxon_check_charge_level+0x12>
     6de:	80 e0       	ldi	r24, 0x00	; 0
     6e0:	90 e0       	ldi	r25, 0x00	; 0
     6e2:	81 70       	andi	r24, 0x01	; 1
     6e4:	08 95       	ret

000006e6 <tinyButton_update>:
/*
If the button has been let go, we change button_press to true. This only lasts one cycle, before it is set to false again.
If the button is held down for longer than PULSEMODE_BUTTON_PRESS_TIME, we toggle the pulse mode state.
*/
void tinyButton_update(void)
{
     6e6:	0f 93       	push	r16
     6e8:	1f 93       	push	r17
     6ea:	cf 93       	push	r28
     6ec:	df 93       	push	r29
	button_press = false;
     6ee:	10 92 33 38 	sts	0x3833, r1	; 0x803833 <button_press>
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTC_get_pin_level(const uint8_t pin)
{
	return VPORTC.IN & (1 << pin);
     6f2:	8a b1       	in	r24, 0x0a	; 10
	_Bool button_is_pushed_down = !BUTTON_PIN_get_level(); // The digital port will be read as low if the button is pushed down.
     6f4:	d1 e0       	ldi	r29, 0x01	; 1
     6f6:	c8 2f       	mov	r28, r24
     6f8:	c4 70       	andi	r28, 0x04	; 4
     6fa:	82 fd       	sbrc	r24, 2
     6fc:	d0 e0       	ldi	r29, 0x00	; 0

	if (button_is_pushed_down && !button_was_pushed_down)
     6fe:	c1 11       	cpse	r28, r1
     700:	36 c0       	rjmp	.+108    	; 0x76e <tinyButton_update+0x88>
     702:	80 91 34 38 	lds	r24, 0x3834	; 0x803834 <button_was_pushed_down>
     706:	81 11       	cpse	r24, r1
     708:	0e c0       	rjmp	.+28     	; 0x726 <tinyButton_update+0x40>
	{
		tinyButton_start_time = tinyTime_now();
     70a:	0e 94 96 09 	call	0x132c	; 0x132c <tinyTime_now>
     70e:	60 93 2e 38 	sts	0x382E, r22	; 0x80382e <tinyButton_start_time>
     712:	70 93 2f 38 	sts	0x382F, r23	; 0x80382f <tinyButton_start_time+0x1>
     716:	80 93 30 38 	sts	0x3830, r24	; 0x803830 <tinyButton_start_time+0x2>
     71a:	90 93 31 38 	sts	0x3831, r25	; 0x803831 <tinyButton_start_time+0x3>
	}
	if (button_is_pushed_down && button_was_pushed_down)
     71e:	80 91 34 38 	lds	r24, 0x3834	; 0x803834 <button_was_pushed_down>
     722:	88 23       	and	r24, r24
     724:	a1 f1       	breq	.+104    	; 0x78e <tinyButton_update+0xa8>
	{
		if ((tinyTime_now() - tinyButton_start_time) > PULSEMODE_BUTTON_PRESS_TIME)
     726:	0e 94 96 09 	call	0x132c	; 0x132c <tinyTime_now>
     72a:	00 91 2e 38 	lds	r16, 0x382E	; 0x80382e <tinyButton_start_time>
     72e:	10 91 2f 38 	lds	r17, 0x382F	; 0x80382f <tinyButton_start_time+0x1>
     732:	20 91 30 38 	lds	r18, 0x3830	; 0x803830 <tinyButton_start_time+0x2>
     736:	30 91 31 38 	lds	r19, 0x3831	; 0x803831 <tinyButton_start_time+0x3>
     73a:	dc 01       	movw	r26, r24
     73c:	cb 01       	movw	r24, r22
     73e:	80 1b       	sub	r24, r16
     740:	91 0b       	sbc	r25, r17
     742:	a2 0b       	sbc	r26, r18
     744:	b3 0b       	sbc	r27, r19
     746:	81 3d       	cpi	r24, 0xD1	; 209
     748:	97 40       	sbci	r25, 0x07	; 7
     74a:	a1 05       	cpc	r26, r1
     74c:	b1 05       	cpc	r27, r1
     74e:	78 f0       	brcs	.+30     	; 0x76e <tinyButton_update+0x88>
		{
			tinyPulse_toggle_pulse_mode();
     750:	0e 94 31 09 	call	0x1262	; 0x1262 <tinyPulse_toggle_pulse_mode>
			tinyButton_start_time = tinyTime_now();
     754:	0e 94 96 09 	call	0x132c	; 0x132c <tinyTime_now>
     758:	60 93 2e 38 	sts	0x382E, r22	; 0x80382e <tinyButton_start_time>
     75c:	70 93 2f 38 	sts	0x382F, r23	; 0x80382f <tinyButton_start_time+0x1>
     760:	80 93 30 38 	sts	0x3830, r24	; 0x803830 <tinyButton_start_time+0x2>
     764:	90 93 31 38 	sts	0x3831, r25	; 0x803831 <tinyButton_start_time+0x3>
			// We don't want switching to pulse mode to count as a button press, so we ignore the next button press
			ignore_next_button_press = true;
     768:	81 e0       	ldi	r24, 0x01	; 1
     76a:	80 93 32 38 	sts	0x3832, r24	; 0x803832 <ignore_next_button_press>
		}
	}
	if (!button_is_pushed_down && button_was_pushed_down)
     76e:	cc 23       	and	r28, r28
     770:	71 f0       	breq	.+28     	; 0x78e <tinyButton_update+0xa8>
     772:	80 91 34 38 	lds	r24, 0x3834	; 0x803834 <button_was_pushed_down>
     776:	88 23       	and	r24, r24
     778:	51 f0       	breq	.+20     	; 0x78e <tinyButton_update+0xa8>
	{
		if(!ignore_next_button_press){
     77a:	80 91 32 38 	lds	r24, 0x3832	; 0x803832 <ignore_next_button_press>
     77e:	81 11       	cpse	r24, r1
     780:	04 c0       	rjmp	.+8      	; 0x78a <tinyButton_update+0xa4>
			button_press = true;
     782:	81 e0       	ldi	r24, 0x01	; 1
     784:	80 93 33 38 	sts	0x3833, r24	; 0x803833 <button_press>
     788:	02 c0       	rjmp	.+4      	; 0x78e <tinyButton_update+0xa8>
		}
		else{
			ignore_next_button_press = false;
     78a:	10 92 32 38 	sts	0x3832, r1	; 0x803832 <ignore_next_button_press>
		}
		
	}
	button_was_pushed_down = button_is_pushed_down;
     78e:	d0 93 34 38 	sts	0x3834, r29	; 0x803834 <button_was_pushed_down>
}
     792:	df 91       	pop	r29
     794:	cf 91       	pop	r28
     796:	1f 91       	pop	r17
     798:	0f 91       	pop	r16
     79a:	08 95       	ret

0000079c <tinyButton_update_potential>:

double tinyButton_update_potential(double potential){
	if(button_press){
     79c:	20 91 33 38 	lds	r18, 0x3833	; 0x803833 <button_press>
     7a0:	22 23       	and	r18, r18
     7a2:	31 f0       	breq	.+12     	; 0x7b0 <tinyButton_update_potential+0x14>
		potential += BUTTON_PRESS_REACTION;
     7a4:	20 e0       	ldi	r18, 0x00	; 0
     7a6:	30 e0       	ldi	r19, 0x00	; 0
     7a8:	40 ed       	ldi	r20, 0xD0	; 208
     7aa:	51 e4       	ldi	r21, 0x41	; 65
     7ac:	0e 94 a0 09 	call	0x1340	; 0x1340 <__addsf3>
	}
	return potential;
}
     7b0:	08 95       	ret

000007b2 <tinyCharge_is_connected_to_charger>:
*/
uint8_t charge_counter = 0; 

_Bool tinyCharge_is_connected_to_charger(){
	return connected_to_charger;
}
     7b2:	80 91 67 38 	lds	r24, 0x3867	; 0x803867 <connected_to_charger>
     7b6:	08 95       	ret

000007b8 <tinyCharge_is_fully_charged>:
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTB_get_pin_level(const uint8_t pin)
{
	return VPORTB.IN & (1 << pin);
     7b8:	86 b1       	in	r24, 0x06	; 6

_Bool tinyCharge_is_fully_charged(){
	return CHARGING_STATUS_PIN_get_level();
}
     7ba:	86 fb       	bst	r24, 6
     7bc:	88 27       	eor	r24, r24
     7be:	80 f9       	bld	r24, 0
     7c0:	08 95       	ret

000007c2 <tinyCharge_DAC_dissable>:
void tinyCharge_DAC_dissable(){
	
	// We need some way to disable the DAC to prevent huge current draw when charging (64mA). When there is no code uploaded to the attiny, there is no problem.
	// We're going to try to enable the pin as a dendrite, since they seem to be doing fine. Completely uninitializing the pin probably caused a microchip to be fried.
	
	DAC_0_uninit();
     7c2:	0e 94 14 01 	call	0x228	; 0x228 <DAC_0_uninit>
	DAC_0_disable();
     7c6:	0e 94 1f 01 	call	0x23e	; 0x23e <DAC_0_disable>
     7ca:	08 95       	ret

000007cc <tinyCharge_DAC_enable>:
void tinyCharge_DAC_enable(){
	
	// We need some way to disable the DAC to prevent huge current draw when charging (64mA). When there is no code uploaded to the attiny, there is no problem.
	// We're going to try to enable the pin as a dendrite, since they seem to be doing fine. Completely uninitializing the pin probably caused a microchip to be fried.
	
	DAC_0_init();
     7cc:	0e 94 0f 01 	call	0x21e	; 0x21e <DAC_0_init>
	DAC_0_enable();
     7d0:	0e 94 19 01 	call	0x232	; 0x232 <DAC_0_enable>
     7d4:	08 95       	ret

000007d6 <tinyCharge_switch_mode>:
}


void tinyCharge_switch_mode(){
	
	if(connected_to_charger){
     7d6:	80 91 67 38 	lds	r24, 0x3867	; 0x803867 <connected_to_charger>
     7da:	88 23       	and	r24, r24
     7dc:	89 f0       	breq	.+34     	; 0x800 <tinyCharge_switch_mode+0x2a>
		// Switch from main to charging mode
		
		// Set LED
		tinyLED_set_color_mode(OUT_LED, CHARGING_COLOR, SWING);
     7de:	43 e0       	ldi	r20, 0x03	; 3
     7e0:	62 e0       	ldi	r22, 0x02	; 2
     7e2:	81 e0       	ldi	r24, 0x01	; 1
     7e4:	0e 94 9d 05 	call	0xb3a	; 0xb3a <tinyLED_set_color_mode>
		tinyLED_set_color(INN_LED, LED_OFF);
     7e8:	60 e0       	ldi	r22, 0x00	; 0
     7ea:	80 e0       	ldi	r24, 0x00	; 0
     7ec:	0e 94 c5 05 	call	0xb8a	; 0xb8a <tinyLED_set_color>


		// Stop axon from firing
		// (There is a small chance that the neuron is put into charging mode as it is firing. The axon is then never told to stop firing)
		tinyAxon_stop_sending_pulse();
     7f0:	0e 94 92 02 	call	0x524	; 0x524 <tinyAxon_stop_sending_pulse>

		// disable DAC
		tinyCharge_DAC_dissable();
     7f4:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <tinyCharge_DAC_dissable>
		
		// We also turn off pulse mode, because it's confusing if it suddenly comes on
		// after it has been charging
		tinyPulse_set_pulse_mode(false);
     7f8:	80 e0       	ldi	r24, 0x00	; 0
     7fa:	0e 94 44 09 	call	0x1288	; 0x1288 <tinyPulse_set_pulse_mode>
     7fe:	08 95       	ret
	}
	else{
		// Switch from charge to main mode
		
		// Set LED
		tinyLED_set_color(OUT_LED, LED_OFF);
     800:	60 e0       	ldi	r22, 0x00	; 0
     802:	81 e0       	ldi	r24, 0x01	; 1
     804:	0e 94 c5 05 	call	0xb8a	; 0xb8a <tinyLED_set_color>
		tinyLED_set_color(INN_LED, LED_OFF);
     808:	60 e0       	ldi	r22, 0x00	; 0
     80a:	80 e0       	ldi	r24, 0x00	; 0
     80c:	0e 94 c5 05 	call	0xb8a	; 0xb8a <tinyLED_set_color>
		
		// enable DAC
		tinyCharge_DAC_enable();
     810:	0e 94 e6 03 	call	0x7cc	; 0x7cc <tinyCharge_DAC_enable>
     814:	08 95       	ret

00000816 <tinyCharge_set_charging_mode>:
	}
}

void tinyCharge_set_charging_mode(_Bool charging_status){
	if(charging_status != connected_to_charger){
     816:	90 91 67 38 	lds	r25, 0x3867	; 0x803867 <connected_to_charger>
     81a:	98 17       	cp	r25, r24
     81c:	21 f0       	breq	.+8      	; 0x826 <tinyCharge_set_charging_mode+0x10>
		connected_to_charger = charging_status;
     81e:	80 93 67 38 	sts	0x3867, r24	; 0x803867 <connected_to_charger>
		tinyCharge_switch_mode();
     822:	0e 94 eb 03 	call	0x7d6	; 0x7d6 <tinyCharge_switch_mode>
     826:	08 95       	ret

00000828 <tinyCharge_update_charging_mode>:

/*
Checks if the levels of the dendrites and axon are at charging levels
and updates the mode accordingly
*/
void tinyCharge_update_charging_mode(){
     828:	cf 93       	push	r28
	// For complicated reasons, the axon_check_level will be high even when the charger is not connected
	// WHEN the neuron is in charging mode, hence we ignore the axon level when the neuron is in charging mode
	_Bool charging;
	if(connected_to_charger){
     82a:	80 91 67 38 	lds	r24, 0x3867	; 0x803867 <connected_to_charger>
     82e:	88 23       	and	r24, r24
     830:	21 f0       	breq	.+8      	; 0x83a <tinyCharge_update_charging_mode+0x12>
		charging = tinyDendrite_check_charge_level();
     832:	0e 94 7d 04 	call	0x8fa	; 0x8fa <tinyDendrite_check_charge_level>
     836:	c8 2f       	mov	r28, r24
     838:	0b c0       	rjmp	.+22     	; 0x850 <tinyCharge_update_charging_mode+0x28>
	} else{
		charging = tinyDendrite_check_charge_level() || tinyAxon_check_charge_level();
     83a:	0e 94 7d 04 	call	0x8fa	; 0x8fa <tinyDendrite_check_charge_level>
     83e:	81 11       	cpse	r24, r1
     840:	03 c0       	rjmp	.+6      	; 0x848 <tinyCharge_update_charging_mode+0x20>
     842:	0e 94 68 03 	call	0x6d0	; 0x6d0 <tinyAxon_check_charge_level>
     846:	02 c0       	rjmp	.+4      	; 0x84c <tinyCharge_update_charging_mode+0x24>
     848:	81 e0       	ldi	r24, 0x01	; 1
     84a:	90 e0       	ldi	r25, 0x00	; 0
     84c:	c8 2f       	mov	r28, r24
     84e:	c1 70       	andi	r28, 0x01	; 1
	}
	
	// In order to prevent the axon from stimulating itself, we only switch into charging mode when the conditions have been right for several cycles
	if(!connected_to_charger && charging){
     850:	80 91 67 38 	lds	r24, 0x3867	; 0x803867 <connected_to_charger>
     854:	81 11       	cpse	r24, r1
     856:	0d c0       	rjmp	.+26     	; 0x872 <tinyCharge_update_charging_mode+0x4a>
     858:	cc 23       	and	r28, r28
     85a:	d1 f0       	breq	.+52     	; 0x890 <tinyCharge_update_charging_mode+0x68>
		charge_counter++;
     85c:	80 91 35 38 	lds	r24, 0x3835	; 0x803835 <charge_counter>
     860:	8f 5f       	subi	r24, 0xFF	; 255
		if(charge_counter > CYCLES_REQUIRED_FOR_CHARGING_MODE_SWITCH){
     862:	8b 30       	cpi	r24, 0x0B	; 11
     864:	90 f0       	brcs	.+36     	; 0x88a <tinyCharge_update_charging_mode+0x62>
			charge_counter = 0;
     866:	10 92 35 38 	sts	0x3835, r1	; 0x803835 <charge_counter>
			tinyCharge_set_charging_mode(charging);
     86a:	81 e0       	ldi	r24, 0x01	; 1
     86c:	0e 94 0b 04 	call	0x816	; 0x816 <tinyCharge_set_charging_mode>
     870:	13 c0       	rjmp	.+38     	; 0x898 <tinyCharge_update_charging_mode+0x70>
		}
	}
	else{
		tinyCharge_set_charging_mode(charging);
     872:	8c 2f       	mov	r24, r28
     874:	0e 94 0b 04 	call	0x816	; 0x816 <tinyCharge_set_charging_mode>
	}
	
	// We have to prevent charge_counters from accumulating over time
	if(!charging && charge_counter>0){
     878:	c1 11       	cpse	r28, r1
     87a:	0e c0       	rjmp	.+28     	; 0x898 <tinyCharge_update_charging_mode+0x70>
     87c:	80 91 35 38 	lds	r24, 0x3835	; 0x803835 <charge_counter>
     880:	88 23       	and	r24, r24
     882:	51 f0       	breq	.+20     	; 0x898 <tinyCharge_update_charging_mode+0x70>
		charge_counter = 0;
     884:	10 92 35 38 	sts	0x3835, r1	; 0x803835 <charge_counter>
	}
	
}
     888:	07 c0       	rjmp	.+14     	; 0x898 <tinyCharge_update_charging_mode+0x70>
		charging = tinyDendrite_check_charge_level() || tinyAxon_check_charge_level();
	}
	
	// In order to prevent the axon from stimulating itself, we only switch into charging mode when the conditions have been right for several cycles
	if(!connected_to_charger && charging){
		charge_counter++;
     88a:	80 93 35 38 	sts	0x3835, r24	; 0x803835 <charge_counter>
     88e:	04 c0       	rjmp	.+8      	; 0x898 <tinyCharge_update_charging_mode+0x70>
			charge_counter = 0;
			tinyCharge_set_charging_mode(charging);
		}
	}
	else{
		tinyCharge_set_charging_mode(charging);
     890:	8c 2f       	mov	r24, r28
     892:	0e 94 0b 04 	call	0x816	; 0x816 <tinyCharge_set_charging_mode>
     896:	f2 cf       	rjmp	.-28     	; 0x87c <tinyCharge_update_charging_mode+0x54>
	// We have to prevent charge_counters from accumulating over time
	if(!charging && charge_counter>0){
		charge_counter = 0;
	}
	
}
     898:	cf 91       	pop	r28
     89a:	08 95       	ret

0000089c <tinyCharge_set_transistors>:



void tinyCharge_set_transistors(){
	if(connected_to_charger){
     89c:	80 91 67 38 	lds	r24, 0x3867	; 0x803867 <connected_to_charger>
     8a0:	88 23       	and	r24, r24
     8a2:	19 f0       	breq	.+6      	; 0x8aa <tinyCharge_set_transistors+0xe>
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
	} else {
		VPORTC.OUT &= ~(1 << pin);
     8a4:	4d 98       	cbi	0x09, 5	; 9
 *                  false = Pin level set to "low" state
 */
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
     8a6:	29 9a       	sbi	0x05, 1	; 5
     8a8:	08 95       	ret
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     8aa:	4d 9a       	sbi	0x09, 5	; 9
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     8ac:	29 98       	cbi	0x05, 1	; 5
     8ae:	08 95       	ret

000008b0 <tinyDebugger_send_int>:
		char number[20]; // Arbitrary max
		dtostrf(value,1,NUMBER_OF_DECIMALS, number);
		printf("%s:%5s\t", name, number);
	}
}
void tinyDebugger_send_string(const char* name, char * value){
     8b0:	08 95       	ret

000008b2 <tinyDebugger_send_uint32>:
     8b2:	08 95       	ret

000008b4 <tinyDebugger_send_uint8>:
     8b4:	08 95       	ret

000008b6 <tinyDebugger_send_double>:
     8b6:	08 95       	ret

000008b8 <tinyDebugger_end_line>:
	if(DEBUGGING){
		printf("%s:%s\t", name, value);
	}
}
void tinyDebugger_end_line(){
     8b8:	08 95       	ret

000008ba <tinyDendrite_read_signals>:
	}
}

uint8_t tinyDendrite_get_value(uint8_t dendrite_number){
	return tinyDendrite_values[dendrite_number];
}
     8ba:	ef 92       	push	r14
     8bc:	ff 92       	push	r15
     8be:	0f 93       	push	r16
     8c0:	1f 93       	push	r17
     8c2:	cf 93       	push	r28
     8c4:	df 93       	push	r29
     8c6:	ce e0       	ldi	r28, 0x0E	; 14
     8c8:	d8 e3       	ldi	r29, 0x38	; 56
     8ca:	00 e4       	ldi	r16, 0x40	; 64
     8cc:	18 e3       	ldi	r17, 0x38	; 56
     8ce:	0f 2e       	mov	r0, r31
     8d0:	f3 e1       	ldi	r31, 0x13	; 19
     8d2:	ef 2e       	mov	r14, r31
     8d4:	f8 e3       	ldi	r31, 0x38	; 56
     8d6:	ff 2e       	mov	r15, r31
     8d8:	f0 2d       	mov	r31, r0
     8da:	89 91       	ld	r24, Y+
     8dc:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <ADC_0_get_conversion>
     8e0:	f8 01       	movw	r30, r16
     8e2:	81 93       	st	Z+, r24
     8e4:	8f 01       	movw	r16, r30
     8e6:	ce 15       	cp	r28, r14
     8e8:	df 05       	cpc	r29, r15
     8ea:	b9 f7       	brne	.-18     	; 0x8da <tinyDendrite_read_signals+0x20>
     8ec:	df 91       	pop	r29
     8ee:	cf 91       	pop	r28
     8f0:	1f 91       	pop	r17
     8f2:	0f 91       	pop	r16
     8f4:	ff 90       	pop	r15
     8f6:	ef 90       	pop	r14
     8f8:	08 95       	ret

000008fa <tinyDendrite_check_charge_level>:

_Bool tinyDendrite_check_charge_level(void)
{
     8fa:	cf 93       	push	r28
     8fc:	df 93       	push	r29
	_Bool charging = false;
	
	tinyDendrite_read_signals();
     8fe:	0e 94 5d 04 	call	0x8ba	; 0x8ba <tinyDendrite_read_signals>
     902:	eb e3       	ldi	r30, 0x3B	; 59
     904:	f8 e3       	ldi	r31, 0x38	; 56
     906:	c6 e3       	ldi	r28, 0x36	; 54
     908:	d8 e3       	ldi	r29, 0x38	; 56
     90a:	a0 e4       	ldi	r26, 0x40	; 64
     90c:	b8 e3       	ldi	r27, 0x38	; 56
     90e:	20 e4       	ldi	r18, 0x40	; 64
     910:	38 e3       	ldi	r19, 0x38	; 56
	return tinyDendrite_values[dendrite_number];
}

_Bool tinyDendrite_check_charge_level(void)
{
	_Bool charging = false;
     912:	80 e0       	ldi	r24, 0x00	; 0
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = CHARGING;
     914:	47 e0       	ldi	r20, 0x07	; 7
	_Bool charging = false;
	
	tinyDendrite_read_signals();
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
     916:	90 81       	ld	r25, Z
     918:	99 93       	st	Y+, r25
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
     91a:	9d 91       	ld	r25, X+
     91c:	9f 3f       	cpi	r25, 0xFF	; 255
     91e:	11 f4       	brne	.+4      	; 0x924 <tinyDendrite_check_charge_level+0x2a>
		{
			tinyDendrite_current_signals[i] = CHARGING;
     920:	40 83       	st	Z, r20
			charging = true;
     922:	81 e0       	ldi	r24, 0x01	; 1
     924:	31 96       	adiw	r30, 0x01	; 1
_Bool tinyDendrite_check_charge_level(void)
{
	_Bool charging = false;
	
	tinyDendrite_read_signals();
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
     926:	e2 17       	cp	r30, r18
     928:	f3 07       	cpc	r31, r19
     92a:	a9 f7       	brne	.-22     	; 0x916 <tinyDendrite_check_charge_level+0x1c>
			tinyDendrite_current_signals[i] = CHARGING;
			charging = true;
		}
	}
	return charging;
}
     92c:	df 91       	pop	r29
     92e:	cf 91       	pop	r28
     930:	08 95       	ret

00000932 <tinyDendrite_update_signals>:

/*
This function converts the 8 bit value from the ADC into one of the signal types defined in DendriteSignal
*/
void tinyDendrite_update_signals(void)
{
     932:	af 92       	push	r10
     934:	bf 92       	push	r11
     936:	df 92       	push	r13
     938:	ef 92       	push	r14
     93a:	ff 92       	push	r15
     93c:	0f 93       	push	r16
     93e:	1f 93       	push	r17
     940:	cf 93       	push	r28
     942:	df 93       	push	r29
	
	// This function does not read the dendrite values! Read_signals must be called somewhere prior to this function!
	// As of writing this, the update_charging_mode function in main runs check_charge_level, so 
	// the tinyDendrite_values are updated when update_signals is called later
	
	tinyDebugger_send_uint8("D1", tinyDendrite_values[0]);
     944:	c0 e4       	ldi	r28, 0x40	; 64
     946:	d8 e3       	ldi	r29, 0x38	; 56
     948:	68 81       	ld	r22, Y
     94a:	8c ed       	ldi	r24, 0xDC	; 220
     94c:	9a e9       	ldi	r25, 0x9A	; 154
     94e:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D2", tinyDendrite_values[1]);
     952:	69 81       	ldd	r22, Y+1	; 0x01
     954:	8f ed       	ldi	r24, 0xDF	; 223
     956:	9a e9       	ldi	r25, 0x9A	; 154
     958:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D3", tinyDendrite_values[2]);
     95c:	6a 81       	ldd	r22, Y+2	; 0x02
     95e:	82 ee       	ldi	r24, 0xE2	; 226
     960:	9a e9       	ldi	r25, 0x9A	; 154
     962:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D4", tinyDendrite_values[3]);
     966:	6b 81       	ldd	r22, Y+3	; 0x03
     968:	85 ee       	ldi	r24, 0xE5	; 229
     96a:	9a e9       	ldi	r25, 0x9A	; 154
     96c:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D5", tinyDendrite_values[4]);
     970:	6c 81       	ldd	r22, Y+4	; 0x04
     972:	88 ee       	ldi	r24, 0xE8	; 232
     974:	9a e9       	ldi	r25, 0x9A	; 154
     976:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <tinyDebugger_send_uint8>
     97a:	eb e3       	ldi	r30, 0x3B	; 59
     97c:	f8 e3       	ldi	r31, 0x38	; 56
     97e:	26 e3       	ldi	r18, 0x36	; 54
     980:	38 e3       	ldi	r19, 0x38	; 56
     982:	5e 01       	movw	r10, r28
     984:	40 e4       	ldi	r20, 0x40	; 64
     986:	58 e3       	ldi	r21, 0x38	; 56
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     988:	dd 24       	eor	r13, r13
     98a:	d3 94       	inc	r13
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
		}
		else if (tinyDendrite_values[i] > HIGH_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
     98c:	0f 2e       	mov	r0, r31
     98e:	f3 e0       	ldi	r31, 0x03	; 3
     990:	ef 2e       	mov	r14, r31
     992:	f0 2d       	mov	r31, r0
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     994:	68 94       	set
     996:	ff 24       	eor	r15, r15
     998:	f1 f8       	bld	r15, 1
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     99a:	04 e0       	ldi	r16, 0x04	; 4
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     99c:	16 e0       	ldi	r17, 0x06	; 6
			// been moved to tinyDendrite_check_charging.
			//charging = true;
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     99e:	65 e0       	ldi	r22, 0x05	; 5
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = CHARGING;
     9a0:	77 e0       	ldi	r23, 0x07	; 7
     9a2:	df 01       	movw	r26, r30
	tinyDebugger_send_uint8("D4", tinyDendrite_values[3]);
	tinyDebugger_send_uint8("D5", tinyDendrite_values[4]);
	
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
     9a4:	90 81       	ld	r25, Z
     9a6:	e9 01       	movw	r28, r18
     9a8:	99 93       	st	Y+, r25
     9aa:	9e 01       	movw	r18, r28
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
     9ac:	e5 01       	movw	r28, r10
     9ae:	89 91       	ld	r24, Y+
     9b0:	5e 01       	movw	r10, r28
     9b2:	8f 3f       	cpi	r24, 0xFF	; 255
     9b4:	11 f4       	brne	.+4      	; 0x9ba <tinyDendrite_update_signals+0x88>
		{
			tinyDendrite_current_signals[i] = CHARGING;
     9b6:	70 83       	st	Z, r23
     9b8:	19 c0       	rjmp	.+50     	; 0x9ec <tinyDendrite_update_signals+0xba>
			// Previously, we used this function to check charging, but this has now
			// been moved to tinyDendrite_check_charging.
			//charging = true;
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
     9ba:	8b 3d       	cpi	r24, 0xDB	; 219
     9bc:	10 f0       	brcs	.+4      	; 0x9c2 <tinyDendrite_update_signals+0x90>
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     9be:	60 83       	st	Z, r22
     9c0:	15 c0       	rjmp	.+42     	; 0x9ec <tinyDendrite_update_signals+0xba>
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
     9c2:	86 3b       	cpi	r24, 0xB6	; 182
     9c4:	10 f0       	brcs	.+4      	; 0x9ca <tinyDendrite_update_signals+0x98>
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     9c6:	10 83       	st	Z, r17
     9c8:	11 c0       	rjmp	.+34     	; 0x9ec <tinyDendrite_update_signals+0xba>
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
     9ca:	82 39       	cpi	r24, 0x92	; 146
     9cc:	10 f0       	brcs	.+4      	; 0x9d2 <tinyDendrite_update_signals+0xa0>
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     9ce:	00 83       	st	Z, r16
     9d0:	0d c0       	rjmp	.+26     	; 0x9ec <tinyDendrite_update_signals+0xba>
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
     9d2:	85 36       	cpi	r24, 0x65	; 101
     9d4:	10 f0       	brcs	.+4      	; 0x9da <tinyDendrite_update_signals+0xa8>
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     9d6:	f0 82       	st	Z, r15
     9d8:	09 c0       	rjmp	.+18     	; 0x9ec <tinyDendrite_update_signals+0xba>
		}
		else if (tinyDendrite_values[i] > HIGH_INHIB_THRESHOLD)
     9da:	8a 34       	cpi	r24, 0x4A	; 74
     9dc:	10 f0       	brcs	.+4      	; 0x9e2 <tinyDendrite_update_signals+0xb0>
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
     9de:	e0 82       	st	Z, r14
     9e0:	05 c0       	rjmp	.+10     	; 0x9ec <tinyDendrite_update_signals+0xba>
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
     9e2:	85 32       	cpi	r24, 0x25	; 37
     9e4:	10 f0       	brcs	.+4      	; 0x9ea <tinyDendrite_update_signals+0xb8>
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     9e6:	d0 82       	st	Z, r13
     9e8:	01 c0       	rjmp	.+2      	; 0x9ec <tinyDendrite_update_signals+0xba>
		}
		else
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     9ea:	10 82       	st	Z, r1
		}
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
     9ec:	8c 91       	ld	r24, X
     9ee:	98 13       	cpse	r25, r24
     9f0:	01 c0       	rjmp	.+2      	; 0x9f4 <tinyDendrite_update_signals+0xc2>
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     9f2:	1c 92       	st	X, r1
     9f4:	31 96       	adiw	r30, 0x01	; 1
	tinyDebugger_send_uint8("D2", tinyDendrite_values[1]);
	tinyDebugger_send_uint8("D3", tinyDendrite_values[2]);
	tinyDebugger_send_uint8("D4", tinyDendrite_values[3]);
	tinyDebugger_send_uint8("D5", tinyDendrite_values[4]);
	
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
     9f6:	e4 17       	cp	r30, r20
     9f8:	f5 07       	cpc	r31, r21
     9fa:	99 f6       	brne	.-90     	; 0x9a2 <tinyDendrite_update_signals+0x70>
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
		}
	}
}
     9fc:	df 91       	pop	r29
     9fe:	cf 91       	pop	r28
     a00:	1f 91       	pop	r17
     a02:	0f 91       	pop	r16
     a04:	ff 90       	pop	r15
     a06:	ef 90       	pop	r14
     a08:	df 90       	pop	r13
     a0a:	bf 90       	pop	r11
     a0c:	af 90       	pop	r10
     a0e:	08 95       	ret

00000a10 <tinyDendrite_get_potential>:
/*
This is the master function of the module that is callable from
outside. It uses the previously declared functions to return the potential.
*/
int16_t tinyDendrite_get_potential()
{
     a10:	cf 93       	push	r28
     a12:	df 93       	push	r29
	if(tinyAxon_is_firing() && IGNORE_INPUT_WHILE_FIRING){
     a14:	0e 94 57 02 	call	0x4ae	; 0x4ae <tinyAxon_is_firing>
		
		return NO_SIGNAL_REACTION;
	}
	
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
     a18:	0e 94 99 04 	call	0x932	; 0x932 <tinyDendrite_update_signals>
     a1c:	eb e3       	ldi	r30, 0x3B	; 59
     a1e:	f8 e3       	ldi	r31, 0x38	; 56
     a20:	20 e4       	ldi	r18, 0x40	; 64
     a22:	38 e3       	ldi	r19, 0x38	; 56
	
	int16_t return_potential_val = 0;
     a24:	c0 e0       	ldi	r28, 0x00	; 0
     a26:	d0 e0       	ldi	r29, 0x00	; 0
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		switch(tinyDendrite_current_signals[i])
     a28:	81 91       	ld	r24, Z+
     a2a:	83 30       	cpi	r24, 0x03	; 3
     a2c:	89 f0       	breq	.+34     	; 0xa50 <tinyDendrite_get_potential+0x40>
     a2e:	28 f4       	brcc	.+10     	; 0xa3a <tinyDendrite_get_potential+0x2a>
     a30:	81 30       	cpi	r24, 0x01	; 1
     a32:	91 f0       	breq	.+36     	; 0xa58 <tinyDendrite_get_potential+0x48>
     a34:	82 30       	cpi	r24, 0x02	; 2
     a36:	71 f0       	breq	.+28     	; 0xa54 <tinyDendrite_get_potential+0x44>
     a38:	10 c0       	rjmp	.+32     	; 0xa5a <tinyDendrite_get_potential+0x4a>
     a3a:	85 30       	cpi	r24, 0x05	; 5
     a3c:	29 f0       	breq	.+10     	; 0xa48 <tinyDendrite_get_potential+0x38>
     a3e:	30 f0       	brcs	.+12     	; 0xa4c <tinyDendrite_get_potential+0x3c>
     a40:	86 30       	cpi	r24, 0x06	; 6
     a42:	59 f4       	brne	.+22     	; 0xa5a <tinyDendrite_get_potential+0x4a>
		{
			case NO_SIGNAL:
				return_potential_val += NO_SIGNAL_REACTION;
				break;
			case HIGH_EXCITE:
				return_potential_val += HIGH_EXCITE_REACTION;
     a44:	e4 96       	adiw	r28, 0x34	; 52
				//tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
				// Used for signaling modified signals
				//tinyLED_set_color_mode(OUT_LED, BLUE, FLASH_ONCE);
				break;
     a46:	09 c0       	rjmp	.+18     	; 0xa5a <tinyDendrite_get_potential+0x4a>
			case NORMAL_EXCITE:
				return_potential_val += NORMAL_EXCITE_REACTION;
     a48:	69 96       	adiw	r28, 0x19	; 25
				//tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
				break;
     a4a:	07 c0       	rjmp	.+14     	; 0xa5a <tinyDendrite_get_potential+0x4a>
			case LOW_EXCITE:
				return_potential_val += LOW_EXCITE_REACTION;
     a4c:	64 96       	adiw	r28, 0x14	; 20
				//tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
				//tinyLED_set_color_mode(OUT_LED, YELLOW, FLASH_ONCE);
				break;
     a4e:	05 c0       	rjmp	.+10     	; 0xa5a <tinyDendrite_get_potential+0x4a>
			case HIGH_INHIB:
				return_potential_val += HIGH_INHIB_REACTION;
     a50:	e2 97       	sbiw	r28, 0x32	; 50
				//tinyLED_set_color_mode(INN_LED, RED, FLASH_ONCE);
				//tinyLED_set_color_mode(OUT_LED, BLUE, FLASH_ONCE);
				break;
     a52:	03 c0       	rjmp	.+6      	; 0xa5a <tinyDendrite_get_potential+0x4a>
			case NORMAL_INHIB:
				return_potential_val += NORMAL_INHIB_REACTION;
     a54:	69 97       	sbiw	r28, 0x19	; 25
				//tinyLED_set_color_mode(INN_LED, RED, FLASH_ONCE);
				break;
     a56:	01 c0       	rjmp	.+2      	; 0xa5a <tinyDendrite_get_potential+0x4a>
			case LOW_INHIB:
				return_potential_val += LOW_INHIB_REACTION;
     a58:	64 97       	sbiw	r28, 0x14	; 20
	
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
	
	int16_t return_potential_val = 0;
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
     a5a:	e2 17       	cp	r30, r18
     a5c:	f3 07       	cpc	r31, r19
     a5e:	21 f7       	brne	.-56     	; 0xa28 <tinyDendrite_get_potential+0x18>
			default:
				break;
		}
	}
	
	tinyDebugger_send_int("ReturnP", return_potential_val);
     a60:	be 01       	movw	r22, r28
     a62:	8b ee       	ldi	r24, 0xEB	; 235
     a64:	9a e9       	ldi	r25, 0x9A	; 154
     a66:	0e 94 58 04 	call	0x8b0	; 0x8b0 <tinyDebugger_send_int>
	
	
	return return_potential_val;
	
}
     a6a:	ce 01       	movw	r24, r28
     a6c:	df 91       	pop	r29
     a6e:	cf 91       	pop	r28
     a70:	08 95       	ret

00000a72 <tinyDendrite_update_potential>:

double tinyDendrite_update_potential(double potential){
     a72:	cf 92       	push	r12
     a74:	df 92       	push	r13
     a76:	ef 92       	push	r14
     a78:	ff 92       	push	r15
     a7a:	6b 01       	movw	r12, r22
     a7c:	7c 01       	movw	r14, r24
	
	int16_t potential_change = tinyDendrite_get_potential();
     a7e:	0e 94 08 05 	call	0xa10	; 0xa10 <tinyDendrite_get_potential>
	/*
	We DON'T want to signal that we have recived a signal, we want to signal that the potential has changed!
	We could send flashes from here, but instead, I'll try to implement a light mode that is constantly communicating the value of the potential.
	*/
	
	return potential;
     a82:	bc 01       	movw	r22, r24
     a84:	99 0f       	add	r25, r25
     a86:	88 0b       	sbc	r24, r24
     a88:	99 0b       	sbc	r25, r25
     a8a:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <__floatsisf>
     a8e:	a7 01       	movw	r20, r14
     a90:	96 01       	movw	r18, r12
     a92:	0e 94 a0 09 	call	0x1340	; 0x1340 <__addsf3>
     a96:	ff 90       	pop	r15
     a98:	ef 90       	pop	r14
     a9a:	df 90       	pop	r13
     a9c:	cf 90       	pop	r12
     a9e:	08 95       	ret

00000aa0 <__vector_6>:
This function is called every time the RTC (Real Time Clock) counter overflows.
With the current settings, it will be called every ms.
The RTC clock runs at 1kHz, and the number of cycles before overflow is set with RTC.PER = someHexValue (e.g. 0x20) in src/rtc.c
*/
ISR(RTC_CNT_vect)
{
     aa0:	1f 92       	push	r1
     aa2:	0f 92       	push	r0
     aa4:	0f b6       	in	r0, 0x3f	; 63
     aa6:	0f 92       	push	r0
     aa8:	11 24       	eor	r1, r1
     aaa:	2f 93       	push	r18
     aac:	3f 93       	push	r19
     aae:	4f 93       	push	r20
     ab0:	5f 93       	push	r21
     ab2:	6f 93       	push	r22
     ab4:	7f 93       	push	r23
     ab6:	8f 93       	push	r24
     ab8:	9f 93       	push	r25
     aba:	af 93       	push	r26
     abc:	bf 93       	push	r27
     abe:	cf 93       	push	r28
     ac0:	ef 93       	push	r30
     ac2:	ff 93       	push	r31
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     ac4:	c1 e0       	ldi	r28, 0x01	; 1
     ac6:	c0 93 45 38 	sts	0x3845, r28	; 0x803845 <tinyISR_interrupt_flag>
{
	// Set flag to let main loop run a new cycle
	tinyISR_setflag(true);
	
	// Timer counter incrementation
	tinyTime_counter_increment();
     aca:	0e 94 82 09 	call	0x1304	; 0x1304 <tinyTime_counter_increment>

	/* Overflow interrupt flag has to be cleared manually */
	RTC.INTFLAGS = RTC_OVF_bm;
     ace:	c0 93 43 01 	sts	0x0143, r28	; 0x800143 <__TEXT_REGION_LENGTH__+0x700143>
}
     ad2:	ff 91       	pop	r31
     ad4:	ef 91       	pop	r30
     ad6:	cf 91       	pop	r28
     ad8:	bf 91       	pop	r27
     ada:	af 91       	pop	r26
     adc:	9f 91       	pop	r25
     ade:	8f 91       	pop	r24
     ae0:	7f 91       	pop	r23
     ae2:	6f 91       	pop	r22
     ae4:	5f 91       	pop	r21
     ae6:	4f 91       	pop	r20
     ae8:	3f 91       	pop	r19
     aea:	2f 91       	pop	r18
     aec:	0f 90       	pop	r0
     aee:	0f be       	out	0x3f, r0	; 63
     af0:	0f 90       	pop	r0
     af2:	1f 90       	pop	r1
     af4:	18 95       	reti

00000af6 <tinyISR_setflag>:
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     af6:	80 93 45 38 	sts	0x3845, r24	; 0x803845 <tinyISR_interrupt_flag>
     afa:	08 95       	ret

00000afc <tinyISR_getflag>:
}

_Bool tinyISR_getflag(void)
{
	return tinyISR_interrupt_flag;
}
     afc:	80 91 45 38 	lds	r24, 0x3845	; 0x803845 <tinyISR_interrupt_flag>
     b00:	08 95       	ret

00000b02 <tinyLED_SPIWriteByte>:
Function used to send a byte over SPI, which in turn gets
translated to the bit-sequence required by the LEDs over the CCL.
*/
static void tinyLED_SPIWriteByte(uint8_t byte)
{
	SPI0.INTFLAGS = SPI0_INTFLAGS; // clear the write collision flag to allow writing
     b02:	90 91 23 08 	lds	r25, 0x0823	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
     b06:	90 93 23 08 	sts	0x0823, r25	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
	TCA0.SINGLE.CNT = 0; // reset TCA counter register to ensure the first rising edge of the PWM is predictable
     b0a:	e0 e0       	ldi	r30, 0x00	; 0
     b0c:	fa e0       	ldi	r31, 0x0A	; 10
     b0e:	10 a2       	std	Z+32, r1	; 0x20
     b10:	11 a2       	std	Z+33, r1	; 0x21
	
	// start TCA
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 1 << TCA_SPLIT_ENABLE_bp;
     b12:	91 e0       	ldi	r25, 0x01	; 1
     b14:	90 83       	st	Z, r25
	SPI0_DATA = byte;
     b16:	80 93 24 08 	sts	0x0824, r24	; 0x800824 <__TEXT_REGION_LENGTH__+0x700824>

	while((SPI0.INTFLAGS & SPI_RXCIE_bm) == 0){} // wait for transfer to complete
     b1a:	e0 e2       	ldi	r30, 0x20	; 32
     b1c:	f8 e0       	ldi	r31, 0x08	; 8
     b1e:	83 81       	ldd	r24, Z+3	; 0x03
     b20:	88 23       	and	r24, r24
     b22:	ec f7       	brge	.-6      	; 0xb1e <tinyLED_SPIWriteByte+0x1c>
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 0 << TCA_SPLIT_ENABLE_bp; //Stop TCA
     b24:	10 92 00 0a 	sts	0x0A00, r1	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
     b28:	08 95       	ret

00000b2a <tinyLED_get_color>:
	tinyLED_set_color_mode(LED_id, color, STABLE);
}

enum Colors tinyLED_get_color(uint8_t LED_id)
{
	return tinyLED_settings[LED_id].color;
     b2a:	e8 2f       	mov	r30, r24
     b2c:	f0 e0       	ldi	r31, 0x00	; 0
     b2e:	ee 0f       	add	r30, r30
     b30:	ff 1f       	adc	r31, r31
     b32:	e0 5b       	subi	r30, 0xB0	; 176
     b34:	f7 4c       	sbci	r31, 0xC7	; 199
}
     b36:	80 81       	ld	r24, Z
     b38:	08 95       	ret

00000b3a <tinyLED_set_color_mode>:
{
	// If we are in pulse mode, we want to stay in pulse mode after we have flashed a light.
	// We do this by storing the previous mode in old settings.
	// However, it can happen that two flashes comes very quickly after one another, that leads
	// to an infinite flash loop, therefore, we only store the settings if it is not flash mode.
	if(tinyLED_settings[LED_id].mode != FLASH_ONCE){
     b3a:	90 e0       	ldi	r25, 0x00	; 0
     b3c:	fc 01       	movw	r30, r24
     b3e:	ee 0f       	add	r30, r30
     b40:	ff 1f       	adc	r31, r31
     b42:	e0 5b       	subi	r30, 0xB0	; 176
     b44:	f7 4c       	sbci	r31, 0xC7	; 199
     b46:	51 81       	ldd	r21, Z+1	; 0x01
     b48:	55 30       	cpi	r21, 0x05	; 5
     b4a:	61 f0       	breq	.+24     	; 0xb64 <tinyLED_set_color_mode+0x2a>
		// We use two lines to avoid pointer trouble. (I'm not good with pointers)
		tinyLED_old_settings[LED_id].color = tinyLED_settings[LED_id].color;
     b4c:	9c 01       	movw	r18, r24
     b4e:	22 0f       	add	r18, r18
     b50:	33 1f       	adc	r19, r19
     b52:	f9 01       	movw	r30, r18
     b54:	e4 5b       	subi	r30, 0xB4	; 180
     b56:	f7 4c       	sbci	r31, 0xC7	; 199
     b58:	d9 01       	movw	r26, r18
     b5a:	a0 5b       	subi	r26, 0xB0	; 176
     b5c:	b7 4c       	sbci	r27, 0xC7	; 199
     b5e:	2c 91       	ld	r18, X
     b60:	20 83       	st	Z, r18
		tinyLED_old_settings[LED_id].mode = tinyLED_settings[LED_id].mode;
     b62:	51 83       	std	Z+1, r21	; 0x01
	}
	
	struct ColorSetting new_setting = {.color=color, .mode=mode};
	tinyLED_settings[LED_id] = new_setting;
     b64:	fc 01       	movw	r30, r24
     b66:	ee 0f       	add	r30, r30
     b68:	ff 1f       	adc	r31, r31
     b6a:	e0 5b       	subi	r30, 0xB0	; 176
     b6c:	f7 4c       	sbci	r31, 0xC7	; 199
     b6e:	60 83       	st	Z, r22
     b70:	41 83       	std	Z+1, r20	; 0x01
	if (mode == FLASH_ONCE)
     b72:	45 30       	cpi	r20, 0x05	; 5
     b74:	49 f4       	brne	.+18     	; 0xb88 <tinyLED_set_color_mode+0x4e>
	{
		tinyLED_flash_once_time[LED_id] = 1000*FLASH_TIME;
     b76:	88 0f       	add	r24, r24
     b78:	99 1f       	adc	r25, r25
     b7a:	fc 01       	movw	r30, r24
     b7c:	e8 59       	subi	r30, 0x98	; 152
     b7e:	f7 4c       	sbci	r31, 0xC7	; 199
     b80:	84 e6       	ldi	r24, 0x64	; 100
     b82:	90 e0       	ldi	r25, 0x00	; 0
     b84:	80 83       	st	Z, r24
     b86:	91 83       	std	Z+1, r25	; 0x01
     b88:	08 95       	ret

00000b8a <tinyLED_set_color>:
/*
changes the values in the variables stored in the LED-array.
*/
void tinyLED_set_color(uint8_t LED_id, enum Colors color)
{
	tinyLED_set_color_mode(LED_id, color, STABLE);
     b8a:	40 e0       	ldi	r20, 0x00	; 0
     b8c:	0e 94 9d 05 	call	0xb3a	; 0xb3a <tinyLED_set_color_mode>
     b90:	08 95       	ret

00000b92 <tinyLED_RGB_Color_Compare>:
	return rgb_color;
			
};
// This might be cause of strange light behavior?
//Message		expected 'struct RGB_Color *' but argument is of type 'struct RGB_Color (*)[2]'	Hjernebyggesett_V4	C:\Users\Elias Lundheim\Documents\GitHub\neural\Hjernebyggesett_V4\Hjernebyggesett_V4\tinyLED\tinyLED.c	121
_Bool tinyLED_RGB_Color_Compare(struct RGB_Color (*a)[NUMBER_OF_LEDS], struct RGB_Color (*b)[NUMBER_OF_LEDS]){
     b92:	dc 01       	movw	r26, r24
     b94:	fb 01       	movw	r30, r22
	for (int i=0; i<NUMBER_OF_LEDS; i++)
	{
		if(!((*a)[i].red==(*b)[i].red && (*a)[i].green==(*b)[i].green && (*a)[i].blue==(*b)[i].blue)){
     b96:	9c 91       	ld	r25, X
     b98:	80 81       	ld	r24, Z
     b9a:	98 13       	cpse	r25, r24
     b9c:	20 c0       	rjmp	.+64     	; 0xbde <tinyLED_RGB_Color_Compare+0x4c>
     b9e:	11 96       	adiw	r26, 0x01	; 1
     ba0:	9c 91       	ld	r25, X
     ba2:	11 97       	sbiw	r26, 0x01	; 1
     ba4:	81 81       	ldd	r24, Z+1	; 0x01
     ba6:	98 13       	cpse	r25, r24
     ba8:	1c c0       	rjmp	.+56     	; 0xbe2 <tinyLED_RGB_Color_Compare+0x50>
     baa:	12 96       	adiw	r26, 0x02	; 2
     bac:	9c 91       	ld	r25, X
     bae:	12 97       	sbiw	r26, 0x02	; 2
     bb0:	82 81       	ldd	r24, Z+2	; 0x02
     bb2:	98 13       	cpse	r25, r24
     bb4:	18 c0       	rjmp	.+48     	; 0xbe6 <tinyLED_RGB_Color_Compare+0x54>
     bb6:	13 96       	adiw	r26, 0x03	; 3
     bb8:	9c 91       	ld	r25, X
     bba:	13 97       	sbiw	r26, 0x03	; 3
     bbc:	83 81       	ldd	r24, Z+3	; 0x03
     bbe:	98 13       	cpse	r25, r24
     bc0:	14 c0       	rjmp	.+40     	; 0xbea <tinyLED_RGB_Color_Compare+0x58>
     bc2:	14 96       	adiw	r26, 0x04	; 4
     bc4:	9c 91       	ld	r25, X
     bc6:	14 97       	sbiw	r26, 0x04	; 4
     bc8:	84 81       	ldd	r24, Z+4	; 0x04
     bca:	98 13       	cpse	r25, r24
     bcc:	10 c0       	rjmp	.+32     	; 0xbee <tinyLED_RGB_Color_Compare+0x5c>
     bce:	81 e0       	ldi	r24, 0x01	; 1
     bd0:	15 96       	adiw	r26, 0x05	; 5
     bd2:	2c 91       	ld	r18, X
     bd4:	95 81       	ldd	r25, Z+5	; 0x05
     bd6:	29 17       	cp	r18, r25
     bd8:	59 f0       	breq	.+22     	; 0xbf0 <tinyLED_RGB_Color_Compare+0x5e>
     bda:	80 e0       	ldi	r24, 0x00	; 0
     bdc:	08 95       	ret
			return false;
     bde:	80 e0       	ldi	r24, 0x00	; 0
     be0:	08 95       	ret
     be2:	80 e0       	ldi	r24, 0x00	; 0
     be4:	08 95       	ret
     be6:	80 e0       	ldi	r24, 0x00	; 0
     be8:	08 95       	ret
     bea:	80 e0       	ldi	r24, 0x00	; 0
     bec:	08 95       	ret
     bee:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	return true;
}
     bf0:	08 95       	ret

00000bf2 <tinyLED_update>:
/*
function to write the current LED-array on to the LEDs and
effectively update the values stored in the LEDs to the values stored in the MCU.
*/
void tinyLED_update(void)
{
     bf2:	2f 92       	push	r2
     bf4:	3f 92       	push	r3
     bf6:	4f 92       	push	r4
     bf8:	5f 92       	push	r5
     bfa:	6f 92       	push	r6
     bfc:	7f 92       	push	r7
     bfe:	8f 92       	push	r8
     c00:	9f 92       	push	r9
     c02:	af 92       	push	r10
     c04:	bf 92       	push	r11
     c06:	cf 92       	push	r12
     c08:	df 92       	push	r13
     c0a:	ef 92       	push	r14
     c0c:	ff 92       	push	r15
     c0e:	0f 93       	push	r16
     c10:	1f 93       	push	r17
     c12:	cf 93       	push	r28
     c14:	df 93       	push	r29
     c16:	cd b7       	in	r28, 0x3d	; 61
     c18:	de b7       	in	r29, 0x3e	; 62
     c1a:	ae 97       	sbiw	r28, 0x2e	; 46
     c1c:	cd bf       	out	0x3d, r28	; 61
     c1e:	de bf       	out	0x3e, r29	; 62
			
	uint32_t now = tinyTime_now();
     c20:	0e 94 96 09 	call	0x132c	; 0x132c <tinyTime_now>
     c24:	6b 01       	movw	r12, r22
     c26:	7c 01       	movw	r14, r24
	uint8_t red = 0;
	uint8_t green = 0;
	
	// This is a sin curve, but between 0 and 1 instead of -1 and 1
	double sinValue = 0.5+sin((double)now/(100*M_PI/SWING_RATE))/2;
     c28:	0e 94 f3 0a 	call	0x15e6	; 0x15e6 <__floatunsisf>
     c2c:	23 e6       	ldi	r18, 0x63	; 99
     c2e:	34 e1       	ldi	r19, 0x14	; 20
     c30:	4d e1       	ldi	r20, 0x1D	; 29
     c32:	54 e4       	ldi	r21, 0x44	; 68
     c34:	0e 94 11 0a 	call	0x1422	; 0x1422 <__divsf3>
     c38:	0e 94 d3 0c 	call	0x19a6	; 0x19a6 <sin>
     c3c:	20 e0       	ldi	r18, 0x00	; 0
     c3e:	30 e0       	ldi	r19, 0x00	; 0
     c40:	40 e0       	ldi	r20, 0x00	; 0
     c42:	5f e3       	ldi	r21, 0x3F	; 63
     c44:	0e 94 66 0c 	call	0x18cc	; 0x18cc <__mulsf3>
     c48:	20 e0       	ldi	r18, 0x00	; 0
     c4a:	30 e0       	ldi	r19, 0x00	; 0
     c4c:	40 e0       	ldi	r20, 0x00	; 0
     c4e:	5f e3       	ldi	r21, 0x3F	; 63
     c50:	0e 94 a0 09 	call	0x1340	; 0x1340 <__addsf3>
     c54:	69 87       	std	Y+9, r22	; 0x09
     c56:	7a 87       	std	Y+10, r23	; 0x0a
     c58:	8b 87       	std	Y+11, r24	; 0x0b
     c5a:	9c 87       	std	Y+12, r25	; 0x0c
	
	// If FLASH_RATE is one, then that means that the left side of the "<" will just count from 0 to 1000, and flash_on will be true for half of the time
	_Bool flash_on = now%(uint32_t)(1000/FLASH_RATE)  <   500/FLASH_RATE;
     c5c:	c7 01       	movw	r24, r14
     c5e:	b6 01       	movw	r22, r12
     c60:	28 ee       	ldi	r18, 0xE8	; 232
     c62:	33 e0       	ldi	r19, 0x03	; 3
     c64:	40 e0       	ldi	r20, 0x00	; 0
     c66:	50 e0       	ldi	r21, 0x00	; 0
     c68:	0e 94 3c 0d 	call	0x1a78	; 0x1a78 <__udivmodsi4>
     c6c:	21 e0       	ldi	r18, 0x01	; 1
     c6e:	2f 83       	std	Y+7, r18	; 0x07
     c70:	64 3f       	cpi	r22, 0xF4	; 244
     c72:	71 40       	sbci	r23, 0x01	; 1
     c74:	81 05       	cpc	r24, r1
     c76:	91 05       	cpc	r25, r1
     c78:	08 f0       	brcs	.+2      	; 0xc7c <tinyLED_update+0x8a>
     c7a:	1f 82       	std	Y+7, r1	; 0x07
	
	// PING_RATE is usually small, so the left side counts to some large number. Since flash_time usually is also quite small,
	// the left side will usually be larger than the right
	_Bool ping_on =  now%(uint32_t)(1000/PING_RATE)   <   1000*FLASH_TIME;
     c7c:	c7 01       	movw	r24, r14
     c7e:	b6 01       	movw	r22, r12
     c80:	20 e1       	ldi	r18, 0x10	; 16
     c82:	37 e2       	ldi	r19, 0x27	; 39
     c84:	40 e0       	ldi	r20, 0x00	; 0
     c86:	50 e0       	ldi	r21, 0x00	; 0
     c88:	0e 94 3c 0d 	call	0x1a78	; 0x1a78 <__udivmodsi4>
     c8c:	0e 94 f3 0a 	call	0x15e6	; 0x15e6 <__floatunsisf>
     c90:	20 e0       	ldi	r18, 0x00	; 0
     c92:	30 e0       	ldi	r19, 0x00	; 0
     c94:	48 ec       	ldi	r20, 0xC8	; 200
     c96:	52 e4       	ldi	r21, 0x42	; 66
     c98:	0e 94 0c 0a 	call	0x1418	; 0x1418 <__cmpsf2>
     c9c:	18 2f       	mov	r17, r24
     c9e:	11 1f       	adc	r17, r17
     ca0:	11 27       	eor	r17, r17
     ca2:	11 1f       	adc	r17, r17
	
	// Find potential 
	double tinyPotential_potental = tinyPotential_get_potential();
     ca4:	0e 94 9e 08 	call	0x113c	; 0x113c <tinyPotential_get_potential>
     ca8:	6d 87       	std	Y+13, r22	; 0x0d
     caa:	7e 87       	std	Y+14, r23	; 0x0e
     cac:	8f 87       	std	Y+15, r24	; 0x0f
     cae:	98 8b       	std	Y+16, r25	; 0x10
	uint8_t tinyAxon_pulses_in_queue = tinyAxon_get_pulses_in_queue();
     cb0:	0e 94 5e 02 	call	0x4bc	; 0x4bc <tinyAxon_get_pulses_in_queue>
     cb4:	88 87       	std	Y+8, r24	; 0x08
	uint16_t time_until_next_pulse = tinyAxon_time_until_next_pulse();
     cb6:	0e 94 74 02 	call	0x4e8	; 0x4e8 <tinyAxon_time_until_next_pulse>
			
			case POTENTIAL:
				// In this mode, we try to communicate the level of the potential with color and brightness
				
				if(tinyPotential_potental > 0 || tinyAxon_pulses_in_queue > 0){
					green = fmin(255*LED_BRIGHTNESS * (tinyPotential_potental+tinyAxon_pulses_in_queue*THRESHOLD_POTENTIAL)/FULL_BRIGHTNESS_POTENTIAL, 255);
     cba:	68 85       	ldd	r22, Y+8	; 0x08
     cbc:	59 e1       	ldi	r21, 0x19	; 25
     cbe:	65 9f       	mul	r22, r21
     cc0:	90 01       	movw	r18, r0
     cc2:	11 24       	eor	r1, r1
     cc4:	0f 2e       	mov	r0, r31
     cc6:	f0 e5       	ldi	r31, 0x50	; 80
     cc8:	2f 2e       	mov	r2, r31
     cca:	f8 e3       	ldi	r31, 0x38	; 56
     ccc:	3f 2e       	mov	r3, r31
     cce:	f0 2d       	mov	r31, r0
     cd0:	de 01       	movw	r26, r28
     cd2:	11 96       	adiw	r26, 0x01	; 1
     cd4:	5d 01       	movw	r10, r26
     cd6:	0f 2e       	mov	r0, r31
     cd8:	fc e4       	ldi	r31, 0x4C	; 76
     cda:	4f 2e       	mov	r4, r31
     cdc:	f8 e3       	ldi	r31, 0x38	; 56
     cde:	5f 2e       	mov	r5, r31
     ce0:	f0 2d       	mov	r31, r0
     ce2:	0f 2e       	mov	r0, r31
     ce4:	f8 e6       	ldi	r31, 0x68	; 104
     ce6:	6f 2e       	mov	r6, r31
     ce8:	f8 e3       	ldi	r31, 0x38	; 56
     cea:	7f 2e       	mov	r7, r31
     cec:	f0 2d       	mov	r31, r0
     cee:	0f 2e       	mov	r0, r31
     cf0:	f4 e5       	ldi	r31, 0x54	; 84
     cf2:	8f 2e       	mov	r8, r31
     cf4:	f8 e3       	ldi	r31, 0x38	; 56
     cf6:	9f 2e       	mov	r9, r31
     cf8:	f0 2d       	mov	r31, r0
     cfa:	6d 01       	movw	r12, r26
void tinyLED_update(void)
{
			
	uint32_t now = tinyTime_now();
	uint8_t red = 0;
	uint8_t green = 0;
     cfc:	1d 8a       	std	Y+21, r1	; 0x15
*/
void tinyLED_update(void)
{
			
	uint32_t now = tinyTime_now();
	uint8_t red = 0;
     cfe:	1e 8a       	std	Y+22, r1	; 0x16
				break;
				
			case FLASH_ONCE:
				if(tinyLED_flash_once_time[i]>0){
					// Check if flash is inside off period
					if(time_until_next_pulse < FLASH_OFF_TIME*1000){
     d00:	ac 01       	movw	r20, r24
     d02:	60 e0       	ldi	r22, 0x00	; 0
     d04:	70 e0       	ldi	r23, 0x00	; 0
     d06:	4f 8f       	std	Y+31, r20	; 0x1f
     d08:	58 a3       	std	Y+32, r21	; 0x20
     d0a:	69 a3       	std	Y+33, r22	; 0x21
     d0c:	7a a3       	std	Y+34, r23	; 0x22
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*sinValue, rgb_colors[i].green*sinValue, rgb_colors[i].blue*sinValue};
				break;
				
			case PING:
				// in the line below, fmin will either return 1 or 0, so each rgb color is either 0 or 255*PING_BRIGHTNESS
				rgb_colors[i] = (struct RGB_Color){255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].red)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].green)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].blue)*ping_on};
     d0e:	61 2f       	mov	r22, r17
     d10:	70 e0       	ldi	r23, 0x00	; 0
     d12:	80 e0       	ldi	r24, 0x00	; 0
     d14:	90 e0       	ldi	r25, 0x00	; 0
     d16:	6f 8b       	std	Y+23, r22	; 0x17
     d18:	78 8f       	std	Y+24, r23	; 0x18
     d1a:	89 8f       	std	Y+25, r24	; 0x19
     d1c:	9a 8f       	std	Y+26, r25	; 0x1a
			
			case POTENTIAL:
				// In this mode, we try to communicate the level of the potential with color and brightness
				
				if(tinyPotential_potental > 0 || tinyAxon_pulses_in_queue > 0){
					green = fmin(255*LED_BRIGHTNESS * (tinyPotential_potental+tinyAxon_pulses_in_queue*THRESHOLD_POTENTIAL)/FULL_BRIGHTNESS_POTENTIAL, 255);
     d1e:	c9 01       	movw	r24, r18
     d20:	33 0f       	add	r19, r19
     d22:	aa 0b       	sbc	r26, r26
     d24:	bb 0b       	sbc	r27, r27
     d26:	8b 8f       	std	Y+27, r24	; 0x1b
     d28:	9c 8f       	std	Y+28, r25	; 0x1c
     d2a:	ad 8f       	std	Y+29, r26	; 0x1d
     d2c:	be 8f       	std	Y+30, r27	; 0x1e
     d2e:	f1 01       	movw	r30, r2
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 0 << TCA_SPLIT_ENABLE_bp; //Stop TCA
}

static struct RGB_Color tinyLED_enum_to_RGB_Color(enum Colors color){
	struct RGB_Color rgb_color;
	switch(color)
     d30:	80 81       	ld	r24, Z
     d32:	84 30       	cpi	r24, 0x04	; 4
     d34:	79 f0       	breq	.+30     	; 0xd54 <tinyLED_update+0x162>
     d36:	28 f4       	brcc	.+10     	; 0xd42 <tinyLED_update+0x150>
     d38:	82 30       	cpi	r24, 0x02	; 2
     d3a:	41 f0       	breq	.+16     	; 0xd4c <tinyLED_update+0x15a>
     d3c:	83 30       	cpi	r24, 0x03	; 3
     d3e:	71 f0       	breq	.+28     	; 0xd5c <tinyLED_update+0x16a>
     d40:	19 c0       	rjmp	.+50     	; 0xd74 <tinyLED_update+0x182>
     d42:	85 30       	cpi	r24, 0x05	; 5
     d44:	79 f0       	breq	.+30     	; 0xd64 <tinyLED_update+0x172>
     d46:	86 30       	cpi	r24, 0x06	; 6
     d48:	89 f0       	breq	.+34     	; 0xd6c <tinyLED_update+0x17a>
     d4a:	14 c0       	rjmp	.+40     	; 0xd74 <tinyLED_update+0x182>
	{
		case LED_OFF:
			rgb_color = (struct RGB_Color){0, 0, 0};
			break;
		case RED:
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 0, 0};
     d4c:	10 e0       	ldi	r17, 0x00	; 0
     d4e:	00 e0       	ldi	r16, 0x00	; 0
     d50:	69 e1       	ldi	r22, 0x19	; 25
     d52:	13 c0       	rjmp	.+38     	; 0xd7a <tinyLED_update+0x188>
			break;
		case GREEN:
			rgb_color = (struct RGB_Color){0, 255*LED_BRIGHTNESS, 0};
     d54:	10 e0       	ldi	r17, 0x00	; 0
     d56:	09 e1       	ldi	r16, 0x19	; 25
     d58:	60 e0       	ldi	r22, 0x00	; 0
     d5a:	0f c0       	rjmp	.+30     	; 0xd7a <tinyLED_update+0x188>
			break;
		case BLUE:
			rgb_color = (struct RGB_Color){0, 0, 255*LED_BRIGHTNESS};
     d5c:	19 e1       	ldi	r17, 0x19	; 25
     d5e:	00 e0       	ldi	r16, 0x00	; 0
     d60:	60 e0       	ldi	r22, 0x00	; 0
     d62:	0b c0       	rjmp	.+22     	; 0xd7a <tinyLED_update+0x188>
			break;
		case YELLOW:
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS, 0};
     d64:	10 e0       	ldi	r17, 0x00	; 0
     d66:	09 e1       	ldi	r16, 0x19	; 25
     d68:	69 e1       	ldi	r22, 0x19	; 25
     d6a:	07 c0       	rjmp	.+14     	; 0xd7a <tinyLED_update+0x188>
			// Should the /3 be there? This requires testing.
			// After testing, findings were that at 0.1 brightness, one would see the three LEDs instead of one white led
			// We try with /2 instead.
			// We find that the best results come from not dividing by anything. At leasts in the lower brightness settings, and that
			// is where we suspect it will be most of the time. When we divide, the LEDs are so weak, that they appear as three lights instead of one.
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS};
     d6c:	19 e1       	ldi	r17, 0x19	; 25
     d6e:	09 e1       	ldi	r16, 0x19	; 25
     d70:	69 e1       	ldi	r22, 0x19	; 25
     d72:	03 c0       	rjmp	.+6      	; 0xd7a <tinyLED_update+0x188>
static struct RGB_Color tinyLED_enum_to_RGB_Color(enum Colors color){
	struct RGB_Color rgb_color;
	switch(color)
	{
		case LED_OFF:
			rgb_color = (struct RGB_Color){0, 0, 0};
     d74:	10 e0       	ldi	r17, 0x00	; 0
     d76:	00 e0       	ldi	r16, 0x00	; 0
     d78:	60 e0       	ldi	r22, 0x00	; 0
     d7a:	76 01       	movw	r14, r12
	
	
	for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
	{		
		// Convert enum to RGB_Color
		rgb_colors[i] = tinyLED_enum_to_RGB_Color(tinyLED_settings[i].color);
     d7c:	d6 01       	movw	r26, r12
     d7e:	6c 93       	st	X, r22
     d80:	11 96       	adiw	r26, 0x01	; 1
     d82:	0c 93       	st	X, r16
     d84:	11 97       	sbiw	r26, 0x01	; 1
     d86:	12 96       	adiw	r26, 0x02	; 2
     d88:	1c 93       	st	X, r17
		
		// Adjust colors according to mode
		switch(tinyLED_settings[i].mode)
     d8a:	81 81       	ldd	r24, Z+1	; 0x01
     d8c:	83 30       	cpi	r24, 0x03	; 3
     d8e:	09 f4       	brne	.+2      	; 0xd92 <tinyLED_update+0x1a0>
     d90:	52 c0       	rjmp	.+164    	; 0xe36 <tinyLED_update+0x244>
     d92:	28 f4       	brcc	.+10     	; 0xd9e <tinyLED_update+0x1ac>
     d94:	81 30       	cpi	r24, 0x01	; 1
     d96:	61 f0       	breq	.+24     	; 0xdb0 <tinyLED_update+0x1be>
     d98:	82 30       	cpi	r24, 0x02	; 2
     d9a:	d9 f1       	breq	.+118    	; 0xe12 <tinyLED_update+0x220>
     d9c:	80 c1       	rjmp	.+768    	; 0x109e <tinyLED_update+0x4ac>
     d9e:	85 30       	cpi	r24, 0x05	; 5
     da0:	09 f4       	brne	.+2      	; 0xda4 <tinyLED_update+0x1b2>
     da2:	f7 c0       	rjmp	.+494    	; 0xf92 <tinyLED_update+0x3a0>
     da4:	08 f4       	brcc	.+2      	; 0xda8 <tinyLED_update+0x1b6>
     da6:	78 c0       	rjmp	.+240    	; 0xe98 <tinyLED_update+0x2a6>
     da8:	86 30       	cpi	r24, 0x06	; 6
     daa:	09 f4       	brne	.+2      	; 0xdae <tinyLED_update+0x1bc>
     dac:	1a c1       	rjmp	.+564    	; 0xfe2 <tinyLED_update+0x3f0>
     dae:	77 c1       	rjmp	.+750    	; 0x109e <tinyLED_update+0x4ac>
		{
			case STABLE:
				break;
				
			case WEAK:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*WEAK_BRIGHTNESS, rgb_colors[i].green*WEAK_BRIGHTNESS, rgb_colors[i].blue*WEAK_BRIGHTNESS};
     db0:	70 e0       	ldi	r23, 0x00	; 0
     db2:	80 e0       	ldi	r24, 0x00	; 0
     db4:	90 e0       	ldi	r25, 0x00	; 0
     db6:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <__floatsisf>
     dba:	2d ec       	ldi	r18, 0xCD	; 205
     dbc:	3c ec       	ldi	r19, 0xCC	; 204
     dbe:	4c ec       	ldi	r20, 0xCC	; 204
     dc0:	5d e3       	ldi	r21, 0x3D	; 61
     dc2:	0e 94 66 0c 	call	0x18cc	; 0x18cc <__mulsf3>
     dc6:	0e 94 c4 0a 	call	0x1588	; 0x1588 <__fixunssfsi>
     dca:	f6 01       	movw	r30, r12
     dcc:	60 83       	st	Z, r22
     dce:	60 2f       	mov	r22, r16
     dd0:	70 e0       	ldi	r23, 0x00	; 0
     dd2:	80 e0       	ldi	r24, 0x00	; 0
     dd4:	90 e0       	ldi	r25, 0x00	; 0
     dd6:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <__floatsisf>
     dda:	2d ec       	ldi	r18, 0xCD	; 205
     ddc:	3c ec       	ldi	r19, 0xCC	; 204
     dde:	4c ec       	ldi	r20, 0xCC	; 204
     de0:	5d e3       	ldi	r21, 0x3D	; 61
     de2:	0e 94 66 0c 	call	0x18cc	; 0x18cc <__mulsf3>
     de6:	0e 94 c4 0a 	call	0x1588	; 0x1588 <__fixunssfsi>
     dea:	d6 01       	movw	r26, r12
     dec:	11 96       	adiw	r26, 0x01	; 1
     dee:	6c 93       	st	X, r22
     df0:	61 2f       	mov	r22, r17
     df2:	70 e0       	ldi	r23, 0x00	; 0
     df4:	80 e0       	ldi	r24, 0x00	; 0
     df6:	90 e0       	ldi	r25, 0x00	; 0
     df8:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <__floatsisf>
     dfc:	2d ec       	ldi	r18, 0xCD	; 205
     dfe:	3c ec       	ldi	r19, 0xCC	; 204
     e00:	4c ec       	ldi	r20, 0xCC	; 204
     e02:	5d e3       	ldi	r21, 0x3D	; 61
     e04:	0e 94 66 0c 	call	0x18cc	; 0x18cc <__mulsf3>
     e08:	0e 94 c4 0a 	call	0x1588	; 0x1588 <__fixunssfsi>
     e0c:	f6 01       	movw	r30, r12
     e0e:	62 83       	std	Z+2, r22	; 0x02
				break;
     e10:	46 c1       	rjmp	.+652    	; 0x109e <tinyLED_update+0x4ac>
				
			case FLASH:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*flash_on, rgb_colors[i].green*flash_on, rgb_colors[i].blue*flash_on};
     e12:	ff 81       	ldd	r31, Y+7	; 0x07
     e14:	f6 9f       	mul	r31, r22
     e16:	60 2d       	mov	r22, r0
     e18:	11 24       	eor	r1, r1
     e1a:	d6 01       	movw	r26, r12
     e1c:	6c 93       	st	X, r22
     e1e:	f0 9f       	mul	r31, r16
     e20:	00 2d       	mov	r16, r0
     e22:	11 24       	eor	r1, r1
     e24:	11 96       	adiw	r26, 0x01	; 1
     e26:	0c 93       	st	X, r16
     e28:	11 97       	sbiw	r26, 0x01	; 1
     e2a:	f1 9f       	mul	r31, r17
     e2c:	10 2d       	mov	r17, r0
     e2e:	11 24       	eor	r1, r1
     e30:	12 96       	adiw	r26, 0x02	; 2
     e32:	1c 93       	st	X, r17
				break;
     e34:	34 c1       	rjmp	.+616    	; 0x109e <tinyLED_update+0x4ac>
				
			case SWING:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*sinValue, rgb_colors[i].green*sinValue, rgb_colors[i].blue*sinValue};
     e36:	70 e0       	ldi	r23, 0x00	; 0
     e38:	80 e0       	ldi	r24, 0x00	; 0
     e3a:	90 e0       	ldi	r25, 0x00	; 0
     e3c:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <__floatsisf>
     e40:	29 85       	ldd	r18, Y+9	; 0x09
     e42:	3a 85       	ldd	r19, Y+10	; 0x0a
     e44:	4b 85       	ldd	r20, Y+11	; 0x0b
     e46:	5c 85       	ldd	r21, Y+12	; 0x0c
     e48:	0e 94 66 0c 	call	0x18cc	; 0x18cc <__mulsf3>
     e4c:	0e 94 c4 0a 	call	0x1588	; 0x1588 <__fixunssfsi>
     e50:	f6 01       	movw	r30, r12
     e52:	60 83       	st	Z, r22
     e54:	60 2f       	mov	r22, r16
     e56:	70 e0       	ldi	r23, 0x00	; 0
     e58:	80 e0       	ldi	r24, 0x00	; 0
     e5a:	90 e0       	ldi	r25, 0x00	; 0
     e5c:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <__floatsisf>
     e60:	29 85       	ldd	r18, Y+9	; 0x09
     e62:	3a 85       	ldd	r19, Y+10	; 0x0a
     e64:	4b 85       	ldd	r20, Y+11	; 0x0b
     e66:	5c 85       	ldd	r21, Y+12	; 0x0c
     e68:	0e 94 66 0c 	call	0x18cc	; 0x18cc <__mulsf3>
     e6c:	0e 94 c4 0a 	call	0x1588	; 0x1588 <__fixunssfsi>
     e70:	d6 01       	movw	r26, r12
     e72:	11 96       	adiw	r26, 0x01	; 1
     e74:	6c 93       	st	X, r22
     e76:	61 2f       	mov	r22, r17
     e78:	70 e0       	ldi	r23, 0x00	; 0
     e7a:	80 e0       	ldi	r24, 0x00	; 0
     e7c:	90 e0       	ldi	r25, 0x00	; 0
     e7e:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <__floatsisf>
     e82:	29 85       	ldd	r18, Y+9	; 0x09
     e84:	3a 85       	ldd	r19, Y+10	; 0x0a
     e86:	4b 85       	ldd	r20, Y+11	; 0x0b
     e88:	5c 85       	ldd	r21, Y+12	; 0x0c
     e8a:	0e 94 66 0c 	call	0x18cc	; 0x18cc <__mulsf3>
     e8e:	0e 94 c4 0a 	call	0x1588	; 0x1588 <__fixunssfsi>
     e92:	f6 01       	movw	r30, r12
     e94:	62 83       	std	Z+2, r22	; 0x02
				break;
     e96:	03 c1       	rjmp	.+518    	; 0x109e <tinyLED_update+0x4ac>
				
			case PING:
				// in the line below, fmin will either return 1 or 0, so each rgb color is either 0 or 255*PING_BRIGHTNESS
				rgb_colors[i] = (struct RGB_Color){255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].red)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].green)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].blue)*ping_on};
     e98:	70 e0       	ldi	r23, 0x00	; 0
     e9a:	80 e0       	ldi	r24, 0x00	; 0
     e9c:	90 e0       	ldi	r25, 0x00	; 0
     e9e:	0e 94 f3 0a 	call	0x15e6	; 0x15e6 <__floatunsisf>
     ea2:	9b 01       	movw	r18, r22
     ea4:	ac 01       	movw	r20, r24
     ea6:	60 e0       	ldi	r22, 0x00	; 0
     ea8:	70 e0       	ldi	r23, 0x00	; 0
     eaa:	80 e8       	ldi	r24, 0x80	; 128
     eac:	9f e3       	ldi	r25, 0x3F	; 63
     eae:	0e 94 30 0b 	call	0x1660	; 0x1660 <fmin>
     eb2:	6b a3       	std	Y+35, r22	; 0x23
     eb4:	7c a3       	std	Y+36, r23	; 0x24
     eb6:	8d a3       	std	Y+37, r24	; 0x25
     eb8:	9e a3       	std	Y+38, r25	; 0x26
     eba:	6f 89       	ldd	r22, Y+23	; 0x17
     ebc:	78 8d       	ldd	r23, Y+24	; 0x18
     ebe:	89 8d       	ldd	r24, Y+25	; 0x19
     ec0:	9a 8d       	ldd	r25, Y+26	; 0x1a
     ec2:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <__floatsisf>
     ec6:	69 8b       	std	Y+17, r22	; 0x11
     ec8:	7a 8b       	std	Y+18, r23	; 0x12
     eca:	8b 8b       	std	Y+19, r24	; 0x13
     ecc:	9c 8b       	std	Y+20, r25	; 0x14
     ece:	60 2f       	mov	r22, r16
     ed0:	70 e0       	ldi	r23, 0x00	; 0
     ed2:	80 e0       	ldi	r24, 0x00	; 0
     ed4:	90 e0       	ldi	r25, 0x00	; 0
     ed6:	0e 94 f3 0a 	call	0x15e6	; 0x15e6 <__floatunsisf>
     eda:	9b 01       	movw	r18, r22
     edc:	ac 01       	movw	r20, r24
     ede:	60 e0       	ldi	r22, 0x00	; 0
     ee0:	70 e0       	ldi	r23, 0x00	; 0
     ee2:	80 e8       	ldi	r24, 0x80	; 128
     ee4:	9f e3       	ldi	r25, 0x3F	; 63
     ee6:	0e 94 30 0b 	call	0x1660	; 0x1660 <fmin>
     eea:	6f a3       	std	Y+39, r22	; 0x27
     eec:	78 a7       	std	Y+40, r23	; 0x28
     eee:	89 a7       	std	Y+41, r24	; 0x29
     ef0:	9a a7       	std	Y+42, r25	; 0x2a
     ef2:	61 2f       	mov	r22, r17
     ef4:	70 e0       	ldi	r23, 0x00	; 0
     ef6:	80 e0       	ldi	r24, 0x00	; 0
     ef8:	90 e0       	ldi	r25, 0x00	; 0
     efa:	0e 94 f3 0a 	call	0x15e6	; 0x15e6 <__floatunsisf>
     efe:	9b 01       	movw	r18, r22
     f00:	ac 01       	movw	r20, r24
     f02:	60 e0       	ldi	r22, 0x00	; 0
     f04:	70 e0       	ldi	r23, 0x00	; 0
     f06:	80 e8       	ldi	r24, 0x80	; 128
     f08:	9f e3       	ldi	r25, 0x3F	; 63
     f0a:	0e 94 30 0b 	call	0x1660	; 0x1660 <fmin>
     f0e:	6b a7       	std	Y+43, r22	; 0x2b
     f10:	7c a7       	std	Y+44, r23	; 0x2c
     f12:	8d a7       	std	Y+45, r24	; 0x2d
     f14:	9e a7       	std	Y+46, r25	; 0x2e
     f16:	23 e3       	ldi	r18, 0x33	; 51
     f18:	33 e3       	ldi	r19, 0x33	; 51
     f1a:	43 ea       	ldi	r20, 0xA3	; 163
     f1c:	50 e4       	ldi	r21, 0x40	; 64
     f1e:	6b a1       	ldd	r22, Y+35	; 0x23
     f20:	7c a1       	ldd	r23, Y+36	; 0x24
     f22:	8d a1       	ldd	r24, Y+37	; 0x25
     f24:	9e a1       	ldd	r25, Y+38	; 0x26
     f26:	0e 94 66 0c 	call	0x18cc	; 0x18cc <__mulsf3>
     f2a:	29 89       	ldd	r18, Y+17	; 0x11
     f2c:	3a 89       	ldd	r19, Y+18	; 0x12
     f2e:	4b 89       	ldd	r20, Y+19	; 0x13
     f30:	5c 89       	ldd	r21, Y+20	; 0x14
     f32:	0e 94 66 0c 	call	0x18cc	; 0x18cc <__mulsf3>
     f36:	0e 94 c4 0a 	call	0x1588	; 0x1588 <__fixunssfsi>
     f3a:	d6 01       	movw	r26, r12
     f3c:	6c 93       	st	X, r22
     f3e:	23 e3       	ldi	r18, 0x33	; 51
     f40:	33 e3       	ldi	r19, 0x33	; 51
     f42:	43 ea       	ldi	r20, 0xA3	; 163
     f44:	50 e4       	ldi	r21, 0x40	; 64
     f46:	6f a1       	ldd	r22, Y+39	; 0x27
     f48:	78 a5       	ldd	r23, Y+40	; 0x28
     f4a:	89 a5       	ldd	r24, Y+41	; 0x29
     f4c:	9a a5       	ldd	r25, Y+42	; 0x2a
     f4e:	0e 94 66 0c 	call	0x18cc	; 0x18cc <__mulsf3>
     f52:	29 89       	ldd	r18, Y+17	; 0x11
     f54:	3a 89       	ldd	r19, Y+18	; 0x12
     f56:	4b 89       	ldd	r20, Y+19	; 0x13
     f58:	5c 89       	ldd	r21, Y+20	; 0x14
     f5a:	0e 94 66 0c 	call	0x18cc	; 0x18cc <__mulsf3>
     f5e:	0e 94 c4 0a 	call	0x1588	; 0x1588 <__fixunssfsi>
     f62:	f6 01       	movw	r30, r12
     f64:	61 83       	std	Z+1, r22	; 0x01
     f66:	23 e3       	ldi	r18, 0x33	; 51
     f68:	33 e3       	ldi	r19, 0x33	; 51
     f6a:	43 ea       	ldi	r20, 0xA3	; 163
     f6c:	50 e4       	ldi	r21, 0x40	; 64
     f6e:	6b a5       	ldd	r22, Y+43	; 0x2b
     f70:	7c a5       	ldd	r23, Y+44	; 0x2c
     f72:	8d a5       	ldd	r24, Y+45	; 0x2d
     f74:	9e a5       	ldd	r25, Y+46	; 0x2e
     f76:	0e 94 66 0c 	call	0x18cc	; 0x18cc <__mulsf3>
     f7a:	29 89       	ldd	r18, Y+17	; 0x11
     f7c:	3a 89       	ldd	r19, Y+18	; 0x12
     f7e:	4b 89       	ldd	r20, Y+19	; 0x13
     f80:	5c 89       	ldd	r21, Y+20	; 0x14
     f82:	0e 94 66 0c 	call	0x18cc	; 0x18cc <__mulsf3>
     f86:	0e 94 c4 0a 	call	0x1588	; 0x1588 <__fixunssfsi>
     f8a:	d6 01       	movw	r26, r12
     f8c:	12 96       	adiw	r26, 0x02	; 2
     f8e:	6c 93       	st	X, r22
				break;
     f90:	86 c0       	rjmp	.+268    	; 0x109e <tinyLED_update+0x4ac>
     f92:	69 8a       	std	Y+17, r6	; 0x11
     f94:	7a 8a       	std	Y+18, r7	; 0x12
				
			case FLASH_ONCE:
				if(tinyLED_flash_once_time[i]>0){
     f96:	d3 01       	movw	r26, r6
     f98:	0d 91       	ld	r16, X+
     f9a:	1c 91       	ld	r17, X
     f9c:	01 15       	cp	r16, r1
     f9e:	11 05       	cpc	r17, r1
     fa0:	c9 f0       	breq	.+50     	; 0xfd4 <tinyLED_update+0x3e2>
					// Check if flash is inside off period
					if(time_until_next_pulse < FLASH_OFF_TIME*1000){
     fa2:	6f 8d       	ldd	r22, Y+31	; 0x1f
     fa4:	78 a1       	ldd	r23, Y+32	; 0x20
     fa6:	89 a1       	ldd	r24, Y+33	; 0x21
     fa8:	9a a1       	ldd	r25, Y+34	; 0x22
     faa:	0e 94 f3 0a 	call	0x15e6	; 0x15e6 <__floatunsisf>
     fae:	20 e0       	ldi	r18, 0x00	; 0
     fb0:	30 e0       	ldi	r19, 0x00	; 0
     fb2:	40 e4       	ldi	r20, 0x40	; 64
     fb4:	51 e4       	ldi	r21, 0x41	; 65
     fb6:	0e 94 0c 0a 	call	0x1418	; 0x1418 <__cmpsf2>
     fba:	88 23       	and	r24, r24
     fbc:	24 f4       	brge	.+8      	; 0xfc6 <tinyLED_update+0x3d4>
						// This is used to separate flashes
						rgb_colors[i] = (struct RGB_Color){0, 0, 0};
     fbe:	f6 01       	movw	r30, r12
     fc0:	10 82       	st	Z, r1
     fc2:	11 82       	std	Z+1, r1	; 0x01
     fc4:	12 82       	std	Z+2, r1	; 0x02
					}
					tinyLED_flash_once_time[i]--;
     fc6:	01 50       	subi	r16, 0x01	; 1
     fc8:	11 09       	sbc	r17, r1
     fca:	a9 89       	ldd	r26, Y+17	; 0x11
     fcc:	ba 89       	ldd	r27, Y+18	; 0x12
     fce:	0d 93       	st	X+, r16
     fd0:	1c 93       	st	X, r17
     fd2:	65 c0       	rjmp	.+202    	; 0x109e <tinyLED_update+0x4ac>
				}
				else{
					// Here we return to the previous color and mode
					tinyLED_settings[i].color = tinyLED_old_settings[i].color;
     fd4:	d2 01       	movw	r26, r4
     fd6:	8c 91       	ld	r24, X
     fd8:	80 83       	st	Z, r24
					tinyLED_settings[i].mode = tinyLED_old_settings[i].mode;
     fda:	11 96       	adiw	r26, 0x01	; 1
     fdc:	8c 91       	ld	r24, X
     fde:	81 83       	std	Z+1, r24	; 0x01
     fe0:	5e c0       	rjmp	.+188    	; 0x109e <tinyLED_update+0x4ac>
				break;
			
			case POTENTIAL:
				// In this mode, we try to communicate the level of the potential with color and brightness
				
				if(tinyPotential_potental > 0 || tinyAxon_pulses_in_queue > 0){
     fe2:	20 e0       	ldi	r18, 0x00	; 0
     fe4:	30 e0       	ldi	r19, 0x00	; 0
     fe6:	a9 01       	movw	r20, r18
     fe8:	6d 85       	ldd	r22, Y+13	; 0x0d
     fea:	7e 85       	ldd	r23, Y+14	; 0x0e
     fec:	8f 85       	ldd	r24, Y+15	; 0x0f
     fee:	98 89       	ldd	r25, Y+16	; 0x10
     ff0:	0e 94 eb 0b 	call	0x17d6	; 0x17d6 <__gesf2>
     ff4:	18 16       	cp	r1, r24
     ff6:	1c f0       	brlt	.+6      	; 0xffe <tinyLED_update+0x40c>
     ff8:	b8 85       	ldd	r27, Y+8	; 0x08
     ffa:	bb 23       	and	r27, r27
     ffc:	11 f1       	breq	.+68     	; 0x1042 <tinyLED_update+0x450>
					green = fmin(255*LED_BRIGHTNESS * (tinyPotential_potental+tinyAxon_pulses_in_queue*THRESHOLD_POTENTIAL)/FULL_BRIGHTNESS_POTENTIAL, 255);
     ffe:	6b 8d       	ldd	r22, Y+27	; 0x1b
    1000:	7c 8d       	ldd	r23, Y+28	; 0x1c
    1002:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1004:	9e 8d       	ldd	r25, Y+30	; 0x1e
    1006:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <__floatsisf>
    100a:	2d 85       	ldd	r18, Y+13	; 0x0d
    100c:	3e 85       	ldd	r19, Y+14	; 0x0e
    100e:	4f 85       	ldd	r20, Y+15	; 0x0f
    1010:	58 89       	ldd	r21, Y+16	; 0x10
    1012:	0e 94 a0 09 	call	0x1340	; 0x1340 <__addsf3>
    1016:	20 e0       	ldi	r18, 0x00	; 0
    1018:	30 e0       	ldi	r19, 0x00	; 0
    101a:	4c ec       	ldi	r20, 0xCC	; 204
    101c:	51 e4       	ldi	r21, 0x41	; 65
    101e:	0e 94 66 0c 	call	0x18cc	; 0x18cc <__mulsf3>
    1022:	20 e0       	ldi	r18, 0x00	; 0
    1024:	30 e0       	ldi	r19, 0x00	; 0
    1026:	48 ec       	ldi	r20, 0xC8	; 200
    1028:	51 e4       	ldi	r21, 0x41	; 65
    102a:	0e 94 11 0a 	call	0x1422	; 0x1422 <__divsf3>
    102e:	20 e0       	ldi	r18, 0x00	; 0
    1030:	30 e0       	ldi	r19, 0x00	; 0
    1032:	4f e7       	ldi	r20, 0x7F	; 127
    1034:	53 e4       	ldi	r21, 0x43	; 67
    1036:	0e 94 30 0b 	call	0x1660	; 0x1660 <fmin>
    103a:	0e 94 c4 0a 	call	0x1588	; 0x1588 <__fixunssfsi>
    103e:	6d 8b       	std	Y+21, r22	; 0x15
    1040:	28 c0       	rjmp	.+80     	; 0x1092 <tinyLED_update+0x4a0>
				}
				else{
					red = fmin(255*LED_BRIGHTNESS * abs(tinyPotential_potental)/FULL_BRIGHTNESS_POTENTIAL, 255);
    1042:	6d 85       	ldd	r22, Y+13	; 0x0d
    1044:	7e 85       	ldd	r23, Y+14	; 0x0e
    1046:	8f 85       	ldd	r24, Y+15	; 0x0f
    1048:	98 89       	ldd	r25, Y+16	; 0x10
    104a:	0e 94 bd 0a 	call	0x157a	; 0x157a <__fixsfsi>
    104e:	9b 01       	movw	r18, r22
    1050:	77 23       	and	r23, r23
    1052:	24 f4       	brge	.+8      	; 0x105c <tinyLED_update+0x46a>
    1054:	22 27       	eor	r18, r18
    1056:	33 27       	eor	r19, r19
    1058:	26 1b       	sub	r18, r22
    105a:	37 0b       	sbc	r19, r23
    105c:	b9 01       	movw	r22, r18
    105e:	33 0f       	add	r19, r19
    1060:	88 0b       	sbc	r24, r24
    1062:	99 0b       	sbc	r25, r25
    1064:	0e 94 f5 0a 	call	0x15ea	; 0x15ea <__floatsisf>
    1068:	20 e0       	ldi	r18, 0x00	; 0
    106a:	30 e0       	ldi	r19, 0x00	; 0
    106c:	4c ec       	ldi	r20, 0xCC	; 204
    106e:	51 e4       	ldi	r21, 0x41	; 65
    1070:	0e 94 66 0c 	call	0x18cc	; 0x18cc <__mulsf3>
    1074:	20 e0       	ldi	r18, 0x00	; 0
    1076:	30 e0       	ldi	r19, 0x00	; 0
    1078:	48 ec       	ldi	r20, 0xC8	; 200
    107a:	51 e4       	ldi	r21, 0x41	; 65
    107c:	0e 94 11 0a 	call	0x1422	; 0x1422 <__divsf3>
    1080:	20 e0       	ldi	r18, 0x00	; 0
    1082:	30 e0       	ldi	r19, 0x00	; 0
    1084:	4f e7       	ldi	r20, 0x7F	; 127
    1086:	53 e4       	ldi	r21, 0x43	; 67
    1088:	0e 94 30 0b 	call	0x1660	; 0x1660 <fmin>
    108c:	0e 94 c4 0a 	call	0x1588	; 0x1588 <__fixunssfsi>
    1090:	6e 8b       	std	Y+22, r22	; 0x16
				}
				
				rgb_colors[i] = (struct RGB_Color){red, green, 0};
    1092:	2e 89       	ldd	r18, Y+22	; 0x16
    1094:	f7 01       	movw	r30, r14
    1096:	20 83       	st	Z, r18
    1098:	4d 89       	ldd	r20, Y+21	; 0x15
    109a:	41 83       	std	Z+1, r20	; 0x01
    109c:	12 82       	std	Z+2, r1	; 0x02
    109e:	52 e0       	ldi	r21, 0x02	; 2
    10a0:	25 0e       	add	r2, r21
    10a2:	31 1c       	adc	r3, r1
    10a4:	63 e0       	ldi	r22, 0x03	; 3
    10a6:	c6 0e       	add	r12, r22
    10a8:	d1 1c       	adc	r13, r1
    10aa:	72 e0       	ldi	r23, 0x02	; 2
    10ac:	47 0e       	add	r4, r23
    10ae:	51 1c       	adc	r5, r1
    10b0:	82 e0       	ldi	r24, 0x02	; 2
    10b2:	68 0e       	add	r6, r24
    10b4:	71 1c       	adc	r7, r1
	
	// This is where we store all the actual color values we want to send to the LED
	struct RGB_Color rgb_colors[NUMBER_OF_LEDS];
	
	
	for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
    10b6:	28 14       	cp	r2, r8
    10b8:	39 04       	cpc	r3, r9
    10ba:	09 f0       	breq	.+2      	; 0x10be <tinyLED_update+0x4cc>
    10bc:	38 ce       	rjmp	.-912    	; 0xd2e <tinyLED_update+0x13c>
				break;
		}
	}
	
	// We only write to the LEDs if there is something to change. (eg. in SWING mode, we update the LEDs almost every cycle)
	if(!tinyLED_RGB_Color_Compare(&rgb_colors, &tinyLED_old_colors)){
    10be:	66 e4       	ldi	r22, 0x46	; 70
    10c0:	78 e3       	ldi	r23, 0x38	; 56
    10c2:	ce 01       	movw	r24, r28
    10c4:	01 96       	adiw	r24, 0x01	; 1
    10c6:	0e 94 c9 05 	call	0xb92	; 0xb92 <tinyLED_RGB_Color_Compare>
    10ca:	81 11       	cpse	r24, r1
    10cc:	21 c0       	rjmp	.+66     	; 0x1110 <tinyLED_update+0x51e>
    10ce:	06 e4       	ldi	r16, 0x46	; 70
    10d0:	18 e3       	ldi	r17, 0x38	; 56
    10d2:	7e 01       	movw	r14, r28
    10d4:	97 e0       	ldi	r25, 0x07	; 7
    10d6:	e9 0e       	add	r14, r25
    10d8:	f1 1c       	adc	r15, r1
		for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
		{
			// Write to LEDs
			//For some reason, the data-bus to the LEDs is serialized as GRB
			//which means the 24-bit data-bus will look like [Green[0:7], Red[0:7], Blue[0:7]]
			tinyLED_SPIWriteByte(rgb_colors[i].green);
    10da:	d5 01       	movw	r26, r10
    10dc:	11 96       	adiw	r26, 0x01	; 1
    10de:	8c 91       	ld	r24, X
    10e0:	0e 94 81 05 	call	0xb02	; 0xb02 <tinyLED_SPIWriteByte>
			tinyLED_SPIWriteByte(rgb_colors[i].red);
    10e4:	f5 01       	movw	r30, r10
    10e6:	80 81       	ld	r24, Z
    10e8:	0e 94 81 05 	call	0xb02	; 0xb02 <tinyLED_SPIWriteByte>
			tinyLED_SPIWriteByte(rgb_colors[i].blue);
    10ec:	d5 01       	movw	r26, r10
    10ee:	12 96       	adiw	r26, 0x02	; 2
    10f0:	8c 91       	ld	r24, X
    10f2:	0e 94 81 05 	call	0xb02	; 0xb02 <tinyLED_SPIWriteByte>
			tinyLED_old_colors[i] = rgb_colors[i];
    10f6:	f5 01       	movw	r30, r10
    10f8:	81 91       	ld	r24, Z+
    10fa:	91 91       	ld	r25, Z+
    10fc:	a1 91       	ld	r26, Z+
    10fe:	5f 01       	movw	r10, r30
    1100:	f8 01       	movw	r30, r16
    1102:	81 93       	st	Z+, r24
    1104:	91 93       	st	Z+, r25
    1106:	a1 93       	st	Z+, r26
    1108:	8f 01       	movw	r16, r30
		}
	}
	
	// We only write to the LEDs if there is something to change. (eg. in SWING mode, we update the LEDs almost every cycle)
	if(!tinyLED_RGB_Color_Compare(&rgb_colors, &tinyLED_old_colors)){
		for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
    110a:	ae 14       	cp	r10, r14
    110c:	bf 04       	cpc	r11, r15
    110e:	29 f7       	brne	.-54     	; 0x10da <tinyLED_update+0x4e8>
			tinyLED_SPIWriteByte(rgb_colors[i].red);
			tinyLED_SPIWriteByte(rgb_colors[i].blue);
			tinyLED_old_colors[i] = rgb_colors[i];
		}
	}
}
    1110:	ae 96       	adiw	r28, 0x2e	; 46
    1112:	cd bf       	out	0x3d, r28	; 61
    1114:	de bf       	out	0x3e, r29	; 62
    1116:	df 91       	pop	r29
    1118:	cf 91       	pop	r28
    111a:	1f 91       	pop	r17
    111c:	0f 91       	pop	r16
    111e:	ff 90       	pop	r15
    1120:	ef 90       	pop	r14
    1122:	df 90       	pop	r13
    1124:	cf 90       	pop	r12
    1126:	bf 90       	pop	r11
    1128:	af 90       	pop	r10
    112a:	9f 90       	pop	r9
    112c:	8f 90       	pop	r8
    112e:	7f 90       	pop	r7
    1130:	6f 90       	pop	r6
    1132:	5f 90       	pop	r5
    1134:	4f 90       	pop	r4
    1136:	3f 90       	pop	r3
    1138:	2f 90       	pop	r2
    113a:	08 95       	ret

0000113c <tinyPotential_get_potential>:
/*
Sends the potential
*/
double tinyPotential_get_potential()
{
	return tinyPotential_potential;
    113c:	60 91 58 38 	lds	r22, 0x3858	; 0x803858 <tinyPotential_potential>
    1140:	70 91 59 38 	lds	r23, 0x3859	; 0x803859 <tinyPotential_potential+0x1>
    1144:	80 91 5a 38 	lds	r24, 0x385A	; 0x80385a <tinyPotential_potential+0x2>
    1148:	90 91 5b 38 	lds	r25, 0x385B	; 0x80385b <tinyPotential_potential+0x3>
}
    114c:	08 95       	ret

0000114e <tinyPotential_update>:

/*
Update the potential
*/
void tinyPotential_update()
{
    114e:	cf 92       	push	r12
    1150:	df 92       	push	r13
    1152:	ef 92       	push	r14
    1154:	ff 92       	push	r15
Function to decay the potential towards 0
*/
static void tinyPotential_decay()
{
		
	uint8_t time_since_last_update = tinyTime_now() - previous_update_time;
    1156:	0e 94 96 09 	call	0x132c	; 0x132c <tinyTime_now>
	tinyPotential_potential *= (exp(-((float)time_since_last_update/(float)TINYPOTENTIAL_TIME_CONST)));
    115a:	80 91 54 38 	lds	r24, 0x3854	; 0x803854 <previous_update_time>
    115e:	68 1b       	sub	r22, r24
    1160:	70 e0       	ldi	r23, 0x00	; 0
    1162:	80 e0       	ldi	r24, 0x00	; 0
    1164:	90 e0       	ldi	r25, 0x00	; 0
    1166:	0e 94 f3 0a 	call	0x15e6	; 0x15e6 <__floatunsisf>
    116a:	20 e0       	ldi	r18, 0x00	; 0
    116c:	30 e0       	ldi	r19, 0x00	; 0
    116e:	48 ec       	ldi	r20, 0xC8	; 200
    1170:	52 e4       	ldi	r21, 0x42	; 66
    1172:	0e 94 11 0a 	call	0x1422	; 0x1422 <__divsf3>
    1176:	90 58       	subi	r25, 0x80	; 128
    1178:	0e 94 8b 0a 	call	0x1516	; 0x1516 <exp>
    117c:	20 91 58 38 	lds	r18, 0x3858	; 0x803858 <tinyPotential_potential>
    1180:	30 91 59 38 	lds	r19, 0x3859	; 0x803859 <tinyPotential_potential+0x1>
    1184:	40 91 5a 38 	lds	r20, 0x385A	; 0x80385a <tinyPotential_potential+0x2>
    1188:	50 91 5b 38 	lds	r21, 0x385B	; 0x80385b <tinyPotential_potential+0x3>
    118c:	0e 94 66 0c 	call	0x18cc	; 0x18cc <__mulsf3>
    1190:	6b 01       	movw	r12, r22
    1192:	7c 01       	movw	r14, r24
	// If the potential is very close to 0, we set it to 0
	if(fabs(tinyPotential_potential)<POLARIZATION_OFFSET){
    1194:	9f 77       	andi	r25, 0x7F	; 127
    1196:	2d ec       	ldi	r18, 0xCD	; 205
    1198:	3c ec       	ldi	r19, 0xCC	; 204
    119a:	4c ec       	ldi	r20, 0xCC	; 204
    119c:	5d e3       	ldi	r21, 0x3D	; 61
    119e:	0e 94 0c 0a 	call	0x1418	; 0x1418 <__cmpsf2>
    11a2:	88 23       	and	r24, r24
    11a4:	4c f0       	brlt	.+18     	; 0x11b8 <tinyPotential_update+0x6a>
*/
static void tinyPotential_decay()
{
		
	uint8_t time_since_last_update = tinyTime_now() - previous_update_time;
	tinyPotential_potential *= (exp(-((float)time_since_last_update/(float)TINYPOTENTIAL_TIME_CONST)));
    11a6:	c0 92 58 38 	sts	0x3858, r12	; 0x803858 <tinyPotential_potential>
    11aa:	d0 92 59 38 	sts	0x3859, r13	; 0x803859 <tinyPotential_potential+0x1>
    11ae:	e0 92 5a 38 	sts	0x385A, r14	; 0x80385a <tinyPotential_potential+0x2>
    11b2:	f0 92 5b 38 	sts	0x385B, r15	; 0x80385b <tinyPotential_potential+0x3>
    11b6:	08 c0       	rjmp	.+16     	; 0x11c8 <tinyPotential_update+0x7a>
	// If the potential is very close to 0, we set it to 0
	if(fabs(tinyPotential_potential)<POLARIZATION_OFFSET){
		tinyPotential_potential=0;
    11b8:	10 92 58 38 	sts	0x3858, r1	; 0x803858 <tinyPotential_potential>
    11bc:	10 92 59 38 	sts	0x3859, r1	; 0x803859 <tinyPotential_potential+0x1>
    11c0:	10 92 5a 38 	sts	0x385A, r1	; 0x80385a <tinyPotential_potential+0x2>
    11c4:	10 92 5b 38 	sts	0x385B, r1	; 0x80385b <tinyPotential_potential+0x3>
	}
	previous_update_time = tinyTime_now();
    11c8:	0e 94 96 09 	call	0x132c	; 0x132c <tinyTime_now>
    11cc:	60 93 54 38 	sts	0x3854, r22	; 0x803854 <previous_update_time>
    11d0:	70 93 55 38 	sts	0x3855, r23	; 0x803855 <previous_update_time+0x1>
    11d4:	80 93 56 38 	sts	0x3856, r24	; 0x803856 <previous_update_time+0x2>
    11d8:	90 93 57 38 	sts	0x3857, r25	; 0x803857 <previous_update_time+0x3>
void tinyPotential_update()
{
	//Some of the potential in the neuron has decayed away
	tinyPotential_decay();
	// Update potential with values from Dendrites
	tinyPotential_potential = tinyDendrite_update_potential(tinyPotential_potential);
    11dc:	60 91 58 38 	lds	r22, 0x3858	; 0x803858 <tinyPotential_potential>
    11e0:	70 91 59 38 	lds	r23, 0x3859	; 0x803859 <tinyPotential_potential+0x1>
    11e4:	80 91 5a 38 	lds	r24, 0x385A	; 0x80385a <tinyPotential_potential+0x2>
    11e8:	90 91 5b 38 	lds	r25, 0x385B	; 0x80385b <tinyPotential_potential+0x3>
    11ec:	0e 94 39 05 	call	0xa72	; 0xa72 <tinyDendrite_update_potential>
    11f0:	60 93 58 38 	sts	0x3858, r22	; 0x803858 <tinyPotential_potential>
    11f4:	70 93 59 38 	sts	0x3859, r23	; 0x803859 <tinyPotential_potential+0x1>
    11f8:	80 93 5a 38 	sts	0x385A, r24	; 0x80385a <tinyPotential_potential+0x2>
    11fc:	90 93 5b 38 	sts	0x385B, r25	; 0x80385b <tinyPotential_potential+0x3>
	
	// Update potential from button press
	tinyPotential_potential = tinyButton_update_potential(tinyPotential_potential);
    1200:	0e 94 ce 03 	call	0x79c	; 0x79c <tinyButton_update_potential>
    1204:	60 93 58 38 	sts	0x3858, r22	; 0x803858 <tinyPotential_potential>
    1208:	70 93 59 38 	sts	0x3859, r23	; 0x803859 <tinyPotential_potential+0x1>
    120c:	80 93 5a 38 	sts	0x385A, r24	; 0x80385a <tinyPotential_potential+0x2>
    1210:	90 93 5b 38 	sts	0x385B, r25	; 0x80385b <tinyPotential_potential+0x3>
	
	// Update potential with values from spontaneous pulse.
	tinyPotential_potential = tinyPulse_update_potential(tinyPotential_potential);
    1214:	0e 94 4a 09 	call	0x1294	; 0x1294 <tinyPulse_update_potential>
    1218:	ab 01       	movw	r20, r22
    121a:	bc 01       	movw	r22, r24
    121c:	40 93 58 38 	sts	0x3858, r20	; 0x803858 <tinyPotential_potential>
    1220:	50 93 59 38 	sts	0x3859, r21	; 0x803859 <tinyPotential_potential+0x1>
    1224:	60 93 5a 38 	sts	0x385A, r22	; 0x80385a <tinyPotential_potential+0x2>
    1228:	70 93 5b 38 	sts	0x385B, r23	; 0x80385b <tinyPotential_potential+0x3>
	
	tinyDebugger_send_double("Potential", tinyPotential_potential);
    122c:	83 ef       	ldi	r24, 0xF3	; 243
    122e:	9a e9       	ldi	r25, 0x9A	; 154
    1230:	0e 94 5b 04 	call	0x8b6	; 0x8b6 <tinyDebugger_send_double>
	
	
	// Let the axon affect the potential
	// This is also where we decide whether or not the axon should fire
	tinyPotential_potential = tinyAxon_update_potential(tinyPotential_potential);
    1234:	60 91 58 38 	lds	r22, 0x3858	; 0x803858 <tinyPotential_potential>
    1238:	70 91 59 38 	lds	r23, 0x3859	; 0x803859 <tinyPotential_potential+0x1>
    123c:	80 91 5a 38 	lds	r24, 0x385A	; 0x80385a <tinyPotential_potential+0x2>
    1240:	90 91 5b 38 	lds	r25, 0x385B	; 0x80385b <tinyPotential_potential+0x3>
    1244:	0e 94 bb 02 	call	0x576	; 0x576 <tinyAxon_update_potential>
    1248:	60 93 58 38 	sts	0x3858, r22	; 0x803858 <tinyPotential_potential>
    124c:	70 93 59 38 	sts	0x3859, r23	; 0x803859 <tinyPotential_potential+0x1>
    1250:	80 93 5a 38 	sts	0x385A, r24	; 0x80385a <tinyPotential_potential+0x2>
    1254:	90 93 5b 38 	sts	0x385B, r25	; 0x80385b <tinyPotential_potential+0x3>
}
    1258:	ff 90       	pop	r15
    125a:	ef 90       	pop	r14
    125c:	df 90       	pop	r13
    125e:	cf 90       	pop	r12
    1260:	08 95       	ret

00001262 <tinyPulse_toggle_pulse_mode>:
_Bool tinyPulse_is_in_pulse_mode(){
	return pulse_mode;
}

void tinyPulse_toggle_pulse_mode(){
	pulse_mode = !pulse_mode;
    1262:	90 91 62 38 	lds	r25, 0x3862	; 0x803862 <pulse_mode>
    1266:	81 e0       	ldi	r24, 0x01	; 1
    1268:	89 27       	eor	r24, r25
    126a:	80 93 62 38 	sts	0x3862, r24	; 0x803862 <pulse_mode>
	
	if(tinyPulse_is_in_pulse_mode()){
    126e:	88 23       	and	r24, r24
    1270:	31 f0       	breq	.+12     	; 0x127e <tinyPulse_toggle_pulse_mode+0x1c>
		tinyLED_set_color_mode(OUT_LED, PULSEMODE_COLOR, WEAK);
    1272:	41 e0       	ldi	r20, 0x01	; 1
    1274:	60 e0       	ldi	r22, 0x00	; 0
    1276:	81 e0       	ldi	r24, 0x01	; 1
    1278:	0e 94 9d 05 	call	0xb3a	; 0xb3a <tinyLED_set_color_mode>
    127c:	08 95       	ret
		//tinyLED_set_color_mode(INN_LED, PULSEMODE_COLOR, WEAK);
	}
	else{
		tinyLED_set_color(OUT_LED, LED_OFF);
    127e:	60 e0       	ldi	r22, 0x00	; 0
    1280:	81 e0       	ldi	r24, 0x01	; 1
    1282:	0e 94 c5 05 	call	0xb8a	; 0xb8a <tinyLED_set_color>
    1286:	08 95       	ret

00001288 <tinyPulse_set_pulse_mode>:
		//tinyLED_set_color(INN_LED, LED_OFF);
	}
}

void tinyPulse_set_pulse_mode(_Bool mode){
	if (pulse_mode != mode)
    1288:	90 91 62 38 	lds	r25, 0x3862	; 0x803862 <pulse_mode>
    128c:	98 13       	cpse	r25, r24
	{
		tinyPulse_toggle_pulse_mode();
    128e:	0e 94 31 09 	call	0x1262	; 0x1262 <tinyPulse_toggle_pulse_mode>
    1292:	08 95       	ret

00001294 <tinyPulse_update_potential>:
	}
}

double tinyPulse_update_potential(double potential){
    1294:	cf 92       	push	r12
    1296:	df 92       	push	r13
    1298:	ef 92       	push	r14
    129a:	ff 92       	push	r15
    129c:	6b 01       	movw	r12, r22
    129e:	7c 01       	movw	r14, r24
	if(pulse_mode){
    12a0:	80 91 62 38 	lds	r24, 0x3862	; 0x803862 <pulse_mode>
    12a4:	88 23       	and	r24, r24
    12a6:	39 f1       	breq	.+78     	; 0x12f6 <tinyPulse_update_potential+0x62>
		
		time_since_last_pulse = tinyTime_now() - time_of_last_pulse;
    12a8:	0e 94 96 09 	call	0x132c	; 0x132c <tinyTime_now>
    12ac:	20 91 5e 38 	lds	r18, 0x385E	; 0x80385e <time_of_last_pulse>
    12b0:	30 91 5f 38 	lds	r19, 0x385F	; 0x80385f <time_of_last_pulse+0x1>
    12b4:	62 1b       	sub	r22, r18
    12b6:	73 0b       	sbc	r23, r19
    12b8:	60 93 5c 38 	sts	0x385C, r22	; 0x80385c <time_since_last_pulse>
    12bc:	70 93 5d 38 	sts	0x385D, r23	; 0x80385d <time_since_last_pulse+0x1>
		
		if(time_since_last_pulse >= ideal_time_between_pulses){
    12c0:	80 91 13 38 	lds	r24, 0x3813	; 0x803813 <ideal_time_between_pulses>
    12c4:	90 91 14 38 	lds	r25, 0x3814	; 0x803814 <ideal_time_between_pulses+0x1>
    12c8:	68 17       	cp	r22, r24
    12ca:	79 07       	cpc	r23, r25
    12cc:	a0 f0       	brcs	.+40     	; 0x12f6 <tinyPulse_update_potential+0x62>
			// This isn't actually a button press. You could have a separate variable for this, but it seems unnecessary.
			potential += BUTTON_PRESS_REACTION;
    12ce:	20 e0       	ldi	r18, 0x00	; 0
    12d0:	30 e0       	ldi	r19, 0x00	; 0
    12d2:	40 ed       	ldi	r20, 0xD0	; 208
    12d4:	51 e4       	ldi	r21, 0x41	; 65
    12d6:	c7 01       	movw	r24, r14
    12d8:	b6 01       	movw	r22, r12
    12da:	0e 94 a0 09 	call	0x1340	; 0x1340 <__addsf3>
    12de:	6b 01       	movw	r12, r22
    12e0:	7c 01       	movw	r14, r24
			time_of_last_pulse = tinyTime_now();			
    12e2:	0e 94 96 09 	call	0x132c	; 0x132c <tinyTime_now>
    12e6:	60 93 5e 38 	sts	0x385E, r22	; 0x80385e <time_of_last_pulse>
    12ea:	70 93 5f 38 	sts	0x385F, r23	; 0x80385f <time_of_last_pulse+0x1>
    12ee:	80 93 60 38 	sts	0x3860, r24	; 0x803860 <time_of_last_pulse+0x2>
    12f2:	90 93 61 38 	sts	0x3861, r25	; 0x803861 <time_of_last_pulse+0x3>
		}
	}
	return potential;
}
    12f6:	c7 01       	movw	r24, r14
    12f8:	b6 01       	movw	r22, r12
    12fa:	ff 90       	pop	r15
    12fc:	ef 90       	pop	r14
    12fe:	df 90       	pop	r13
    1300:	cf 90       	pop	r12
    1302:	08 95       	ret

00001304 <tinyTime_counter_increment>:
If the Interrupt Service Routine is clocked by a crystal oscillator
it gives a very precise timer-counter.
*/
void tinyTime_counter_increment(void)
{
	time_counter++;
    1304:	80 91 63 38 	lds	r24, 0x3863	; 0x803863 <time_counter>
    1308:	90 91 64 38 	lds	r25, 0x3864	; 0x803864 <time_counter+0x1>
    130c:	a0 91 65 38 	lds	r26, 0x3865	; 0x803865 <time_counter+0x2>
    1310:	b0 91 66 38 	lds	r27, 0x3866	; 0x803866 <time_counter+0x3>
    1314:	01 96       	adiw	r24, 0x01	; 1
    1316:	a1 1d       	adc	r26, r1
    1318:	b1 1d       	adc	r27, r1
    131a:	80 93 63 38 	sts	0x3863, r24	; 0x803863 <time_counter>
    131e:	90 93 64 38 	sts	0x3864, r25	; 0x803864 <time_counter+0x1>
    1322:	a0 93 65 38 	sts	0x3865, r26	; 0x803865 <time_counter+0x2>
    1326:	b0 93 66 38 	sts	0x3866, r27	; 0x803866 <time_counter+0x3>
    132a:	08 95       	ret

0000132c <tinyTime_now>:
/*
This function is callable by external libraries to give them the counted time so far.
*/
uint32_t tinyTime_now(void)
{
	return time_counter;
    132c:	60 91 63 38 	lds	r22, 0x3863	; 0x803863 <time_counter>
    1330:	70 91 64 38 	lds	r23, 0x3864	; 0x803864 <time_counter+0x1>
    1334:	80 91 65 38 	lds	r24, 0x3865	; 0x803865 <time_counter+0x2>
    1338:	90 91 66 38 	lds	r25, 0x3866	; 0x803866 <time_counter+0x3>
    133c:	08 95       	ret

0000133e <__subsf3>:
    133e:	50 58       	subi	r21, 0x80	; 128

00001340 <__addsf3>:
    1340:	bb 27       	eor	r27, r27
    1342:	aa 27       	eor	r26, r26
    1344:	0e 94 b7 09 	call	0x136e	; 0x136e <__addsf3x>
    1348:	0c 94 b1 0b 	jmp	0x1762	; 0x1762 <__fp_round>
    134c:	0e 94 a3 0b 	call	0x1746	; 0x1746 <__fp_pscA>
    1350:	38 f0       	brcs	.+14     	; 0x1360 <__addsf3+0x20>
    1352:	0e 94 aa 0b 	call	0x1754	; 0x1754 <__fp_pscB>
    1356:	20 f0       	brcs	.+8      	; 0x1360 <__addsf3+0x20>
    1358:	39 f4       	brne	.+14     	; 0x1368 <__addsf3+0x28>
    135a:	9f 3f       	cpi	r25, 0xFF	; 255
    135c:	19 f4       	brne	.+6      	; 0x1364 <__addsf3+0x24>
    135e:	26 f4       	brtc	.+8      	; 0x1368 <__addsf3+0x28>
    1360:	0c 94 79 0b 	jmp	0x16f2	; 0x16f2 <__fp_nan>
    1364:	0e f4       	brtc	.+2      	; 0x1368 <__addsf3+0x28>
    1366:	e0 95       	com	r30
    1368:	e7 fb       	bst	r30, 7
    136a:	0c 94 73 0b 	jmp	0x16e6	; 0x16e6 <__fp_inf>

0000136e <__addsf3x>:
    136e:	e9 2f       	mov	r30, r25
    1370:	0e 94 c2 0b 	call	0x1784	; 0x1784 <__fp_split3>
    1374:	58 f3       	brcs	.-42     	; 0x134c <__addsf3+0xc>
    1376:	ba 17       	cp	r27, r26
    1378:	62 07       	cpc	r22, r18
    137a:	73 07       	cpc	r23, r19
    137c:	84 07       	cpc	r24, r20
    137e:	95 07       	cpc	r25, r21
    1380:	20 f0       	brcs	.+8      	; 0x138a <__addsf3x+0x1c>
    1382:	79 f4       	brne	.+30     	; 0x13a2 <__addsf3x+0x34>
    1384:	a6 f5       	brtc	.+104    	; 0x13ee <__addsf3x+0x80>
    1386:	0c 94 e4 0b 	jmp	0x17c8	; 0x17c8 <__fp_zero>
    138a:	0e f4       	brtc	.+2      	; 0x138e <__addsf3x+0x20>
    138c:	e0 95       	com	r30
    138e:	0b 2e       	mov	r0, r27
    1390:	ba 2f       	mov	r27, r26
    1392:	a0 2d       	mov	r26, r0
    1394:	0b 01       	movw	r0, r22
    1396:	b9 01       	movw	r22, r18
    1398:	90 01       	movw	r18, r0
    139a:	0c 01       	movw	r0, r24
    139c:	ca 01       	movw	r24, r20
    139e:	a0 01       	movw	r20, r0
    13a0:	11 24       	eor	r1, r1
    13a2:	ff 27       	eor	r31, r31
    13a4:	59 1b       	sub	r21, r25
    13a6:	99 f0       	breq	.+38     	; 0x13ce <__addsf3x+0x60>
    13a8:	59 3f       	cpi	r21, 0xF9	; 249
    13aa:	50 f4       	brcc	.+20     	; 0x13c0 <__addsf3x+0x52>
    13ac:	50 3e       	cpi	r21, 0xE0	; 224
    13ae:	68 f1       	brcs	.+90     	; 0x140a <__addsf3x+0x9c>
    13b0:	1a 16       	cp	r1, r26
    13b2:	f0 40       	sbci	r31, 0x00	; 0
    13b4:	a2 2f       	mov	r26, r18
    13b6:	23 2f       	mov	r18, r19
    13b8:	34 2f       	mov	r19, r20
    13ba:	44 27       	eor	r20, r20
    13bc:	58 5f       	subi	r21, 0xF8	; 248
    13be:	f3 cf       	rjmp	.-26     	; 0x13a6 <__addsf3x+0x38>
    13c0:	46 95       	lsr	r20
    13c2:	37 95       	ror	r19
    13c4:	27 95       	ror	r18
    13c6:	a7 95       	ror	r26
    13c8:	f0 40       	sbci	r31, 0x00	; 0
    13ca:	53 95       	inc	r21
    13cc:	c9 f7       	brne	.-14     	; 0x13c0 <__addsf3x+0x52>
    13ce:	7e f4       	brtc	.+30     	; 0x13ee <__addsf3x+0x80>
    13d0:	1f 16       	cp	r1, r31
    13d2:	ba 0b       	sbc	r27, r26
    13d4:	62 0b       	sbc	r22, r18
    13d6:	73 0b       	sbc	r23, r19
    13d8:	84 0b       	sbc	r24, r20
    13da:	ba f0       	brmi	.+46     	; 0x140a <__addsf3x+0x9c>
    13dc:	91 50       	subi	r25, 0x01	; 1
    13de:	a1 f0       	breq	.+40     	; 0x1408 <__addsf3x+0x9a>
    13e0:	ff 0f       	add	r31, r31
    13e2:	bb 1f       	adc	r27, r27
    13e4:	66 1f       	adc	r22, r22
    13e6:	77 1f       	adc	r23, r23
    13e8:	88 1f       	adc	r24, r24
    13ea:	c2 f7       	brpl	.-16     	; 0x13dc <__addsf3x+0x6e>
    13ec:	0e c0       	rjmp	.+28     	; 0x140a <__addsf3x+0x9c>
    13ee:	ba 0f       	add	r27, r26
    13f0:	62 1f       	adc	r22, r18
    13f2:	73 1f       	adc	r23, r19
    13f4:	84 1f       	adc	r24, r20
    13f6:	48 f4       	brcc	.+18     	; 0x140a <__addsf3x+0x9c>
    13f8:	87 95       	ror	r24
    13fa:	77 95       	ror	r23
    13fc:	67 95       	ror	r22
    13fe:	b7 95       	ror	r27
    1400:	f7 95       	ror	r31
    1402:	9e 3f       	cpi	r25, 0xFE	; 254
    1404:	08 f0       	brcs	.+2      	; 0x1408 <__addsf3x+0x9a>
    1406:	b0 cf       	rjmp	.-160    	; 0x1368 <__addsf3+0x28>
    1408:	93 95       	inc	r25
    140a:	88 0f       	add	r24, r24
    140c:	08 f0       	brcs	.+2      	; 0x1410 <__addsf3x+0xa2>
    140e:	99 27       	eor	r25, r25
    1410:	ee 0f       	add	r30, r30
    1412:	97 95       	ror	r25
    1414:	87 95       	ror	r24
    1416:	08 95       	ret

00001418 <__cmpsf2>:
    1418:	0e 94 4f 0b 	call	0x169e	; 0x169e <__fp_cmp>
    141c:	08 f4       	brcc	.+2      	; 0x1420 <__cmpsf2+0x8>
    141e:	81 e0       	ldi	r24, 0x01	; 1
    1420:	08 95       	ret

00001422 <__divsf3>:
    1422:	0e 94 25 0a 	call	0x144a	; 0x144a <__divsf3x>
    1426:	0c 94 b1 0b 	jmp	0x1762	; 0x1762 <__fp_round>
    142a:	0e 94 aa 0b 	call	0x1754	; 0x1754 <__fp_pscB>
    142e:	58 f0       	brcs	.+22     	; 0x1446 <__divsf3+0x24>
    1430:	0e 94 a3 0b 	call	0x1746	; 0x1746 <__fp_pscA>
    1434:	40 f0       	brcs	.+16     	; 0x1446 <__divsf3+0x24>
    1436:	29 f4       	brne	.+10     	; 0x1442 <__divsf3+0x20>
    1438:	5f 3f       	cpi	r21, 0xFF	; 255
    143a:	29 f0       	breq	.+10     	; 0x1446 <__divsf3+0x24>
    143c:	0c 94 73 0b 	jmp	0x16e6	; 0x16e6 <__fp_inf>
    1440:	51 11       	cpse	r21, r1
    1442:	0c 94 e5 0b 	jmp	0x17ca	; 0x17ca <__fp_szero>
    1446:	0c 94 79 0b 	jmp	0x16f2	; 0x16f2 <__fp_nan>

0000144a <__divsf3x>:
    144a:	0e 94 c2 0b 	call	0x1784	; 0x1784 <__fp_split3>
    144e:	68 f3       	brcs	.-38     	; 0x142a <__divsf3+0x8>

00001450 <__divsf3_pse>:
    1450:	99 23       	and	r25, r25
    1452:	b1 f3       	breq	.-20     	; 0x1440 <__divsf3+0x1e>
    1454:	55 23       	and	r21, r21
    1456:	91 f3       	breq	.-28     	; 0x143c <__divsf3+0x1a>
    1458:	95 1b       	sub	r25, r21
    145a:	55 0b       	sbc	r21, r21
    145c:	bb 27       	eor	r27, r27
    145e:	aa 27       	eor	r26, r26
    1460:	62 17       	cp	r22, r18
    1462:	73 07       	cpc	r23, r19
    1464:	84 07       	cpc	r24, r20
    1466:	38 f0       	brcs	.+14     	; 0x1476 <__divsf3_pse+0x26>
    1468:	9f 5f       	subi	r25, 0xFF	; 255
    146a:	5f 4f       	sbci	r21, 0xFF	; 255
    146c:	22 0f       	add	r18, r18
    146e:	33 1f       	adc	r19, r19
    1470:	44 1f       	adc	r20, r20
    1472:	aa 1f       	adc	r26, r26
    1474:	a9 f3       	breq	.-22     	; 0x1460 <__divsf3_pse+0x10>
    1476:	35 d0       	rcall	.+106    	; 0x14e2 <__divsf3_pse+0x92>
    1478:	0e 2e       	mov	r0, r30
    147a:	3a f0       	brmi	.+14     	; 0x148a <__divsf3_pse+0x3a>
    147c:	e0 e8       	ldi	r30, 0x80	; 128
    147e:	32 d0       	rcall	.+100    	; 0x14e4 <__divsf3_pse+0x94>
    1480:	91 50       	subi	r25, 0x01	; 1
    1482:	50 40       	sbci	r21, 0x00	; 0
    1484:	e6 95       	lsr	r30
    1486:	00 1c       	adc	r0, r0
    1488:	ca f7       	brpl	.-14     	; 0x147c <__divsf3_pse+0x2c>
    148a:	2b d0       	rcall	.+86     	; 0x14e2 <__divsf3_pse+0x92>
    148c:	fe 2f       	mov	r31, r30
    148e:	29 d0       	rcall	.+82     	; 0x14e2 <__divsf3_pse+0x92>
    1490:	66 0f       	add	r22, r22
    1492:	77 1f       	adc	r23, r23
    1494:	88 1f       	adc	r24, r24
    1496:	bb 1f       	adc	r27, r27
    1498:	26 17       	cp	r18, r22
    149a:	37 07       	cpc	r19, r23
    149c:	48 07       	cpc	r20, r24
    149e:	ab 07       	cpc	r26, r27
    14a0:	b0 e8       	ldi	r27, 0x80	; 128
    14a2:	09 f0       	breq	.+2      	; 0x14a6 <__divsf3_pse+0x56>
    14a4:	bb 0b       	sbc	r27, r27
    14a6:	80 2d       	mov	r24, r0
    14a8:	bf 01       	movw	r22, r30
    14aa:	ff 27       	eor	r31, r31
    14ac:	93 58       	subi	r25, 0x83	; 131
    14ae:	5f 4f       	sbci	r21, 0xFF	; 255
    14b0:	3a f0       	brmi	.+14     	; 0x14c0 <__divsf3_pse+0x70>
    14b2:	9e 3f       	cpi	r25, 0xFE	; 254
    14b4:	51 05       	cpc	r21, r1
    14b6:	78 f0       	brcs	.+30     	; 0x14d6 <__divsf3_pse+0x86>
    14b8:	0c 94 73 0b 	jmp	0x16e6	; 0x16e6 <__fp_inf>
    14bc:	0c 94 e5 0b 	jmp	0x17ca	; 0x17ca <__fp_szero>
    14c0:	5f 3f       	cpi	r21, 0xFF	; 255
    14c2:	e4 f3       	brlt	.-8      	; 0x14bc <__divsf3_pse+0x6c>
    14c4:	98 3e       	cpi	r25, 0xE8	; 232
    14c6:	d4 f3       	brlt	.-12     	; 0x14bc <__divsf3_pse+0x6c>
    14c8:	86 95       	lsr	r24
    14ca:	77 95       	ror	r23
    14cc:	67 95       	ror	r22
    14ce:	b7 95       	ror	r27
    14d0:	f7 95       	ror	r31
    14d2:	9f 5f       	subi	r25, 0xFF	; 255
    14d4:	c9 f7       	brne	.-14     	; 0x14c8 <__divsf3_pse+0x78>
    14d6:	88 0f       	add	r24, r24
    14d8:	91 1d       	adc	r25, r1
    14da:	96 95       	lsr	r25
    14dc:	87 95       	ror	r24
    14de:	97 f9       	bld	r25, 7
    14e0:	08 95       	ret
    14e2:	e1 e0       	ldi	r30, 0x01	; 1
    14e4:	66 0f       	add	r22, r22
    14e6:	77 1f       	adc	r23, r23
    14e8:	88 1f       	adc	r24, r24
    14ea:	bb 1f       	adc	r27, r27
    14ec:	62 17       	cp	r22, r18
    14ee:	73 07       	cpc	r23, r19
    14f0:	84 07       	cpc	r24, r20
    14f2:	ba 07       	cpc	r27, r26
    14f4:	20 f0       	brcs	.+8      	; 0x14fe <__divsf3_pse+0xae>
    14f6:	62 1b       	sub	r22, r18
    14f8:	73 0b       	sbc	r23, r19
    14fa:	84 0b       	sbc	r24, r20
    14fc:	ba 0b       	sbc	r27, r26
    14fe:	ee 1f       	adc	r30, r30
    1500:	88 f7       	brcc	.-30     	; 0x14e4 <__divsf3_pse+0x94>
    1502:	e0 95       	com	r30
    1504:	08 95       	ret
    1506:	29 f4       	brne	.+10     	; 0x1512 <__divsf3_pse+0xc2>
    1508:	16 f0       	brts	.+4      	; 0x150e <__divsf3_pse+0xbe>
    150a:	0c 94 73 0b 	jmp	0x16e6	; 0x16e6 <__fp_inf>
    150e:	0c 94 e4 0b 	jmp	0x17c8	; 0x17c8 <__fp_zero>
    1512:	0c 94 79 0b 	jmp	0x16f2	; 0x16f2 <__fp_nan>

00001516 <exp>:
    1516:	0e 94 ca 0b 	call	0x1794	; 0x1794 <__fp_splitA>
    151a:	a8 f3       	brcs	.-22     	; 0x1506 <__divsf3_pse+0xb6>
    151c:	96 38       	cpi	r25, 0x86	; 134
    151e:	a0 f7       	brcc	.-24     	; 0x1508 <__divsf3_pse+0xb8>
    1520:	07 f8       	bld	r0, 7
    1522:	0f 92       	push	r0
    1524:	e8 94       	clt
    1526:	2b e3       	ldi	r18, 0x3B	; 59
    1528:	3a ea       	ldi	r19, 0xAA	; 170
    152a:	48 eb       	ldi	r20, 0xB8	; 184
    152c:	5f e7       	ldi	r21, 0x7F	; 127
    152e:	0e 94 7c 0c 	call	0x18f8	; 0x18f8 <__mulsf3_pse>
    1532:	0f 92       	push	r0
    1534:	0f 92       	push	r0
    1536:	0f 92       	push	r0
    1538:	4d b7       	in	r20, 0x3d	; 61
    153a:	5e b7       	in	r21, 0x3e	; 62
    153c:	0f 92       	push	r0
    153e:	0e 94 32 0c 	call	0x1864	; 0x1864 <modf>
    1542:	ec e7       	ldi	r30, 0x7C	; 124
    1544:	f0 e0       	ldi	r31, 0x00	; 0
    1546:	0e 94 7c 0b 	call	0x16f8	; 0x16f8 <__fp_powser>
    154a:	4f 91       	pop	r20
    154c:	5f 91       	pop	r21
    154e:	ef 91       	pop	r30
    1550:	ff 91       	pop	r31
    1552:	e5 95       	asr	r30
    1554:	ee 1f       	adc	r30, r30
    1556:	ff 1f       	adc	r31, r31
    1558:	49 f0       	breq	.+18     	; 0x156c <exp+0x56>
    155a:	fe 57       	subi	r31, 0x7E	; 126
    155c:	e0 68       	ori	r30, 0x80	; 128
    155e:	44 27       	eor	r20, r20
    1560:	ee 0f       	add	r30, r30
    1562:	44 1f       	adc	r20, r20
    1564:	fa 95       	dec	r31
    1566:	e1 f7       	brne	.-8      	; 0x1560 <exp+0x4a>
    1568:	41 95       	neg	r20
    156a:	55 0b       	sbc	r21, r21
    156c:	0e 94 fc 0b 	call	0x17f8	; 0x17f8 <ldexp>
    1570:	0f 90       	pop	r0
    1572:	07 fe       	sbrs	r0, 7
    1574:	0c 94 f0 0b 	jmp	0x17e0	; 0x17e0 <inverse>
    1578:	08 95       	ret

0000157a <__fixsfsi>:
    157a:	0e 94 c4 0a 	call	0x1588	; 0x1588 <__fixunssfsi>
    157e:	68 94       	set
    1580:	b1 11       	cpse	r27, r1
    1582:	0c 94 e5 0b 	jmp	0x17ca	; 0x17ca <__fp_szero>
    1586:	08 95       	ret

00001588 <__fixunssfsi>:
    1588:	0e 94 ca 0b 	call	0x1794	; 0x1794 <__fp_splitA>
    158c:	88 f0       	brcs	.+34     	; 0x15b0 <__fixunssfsi+0x28>
    158e:	9f 57       	subi	r25, 0x7F	; 127
    1590:	98 f0       	brcs	.+38     	; 0x15b8 <__fixunssfsi+0x30>
    1592:	b9 2f       	mov	r27, r25
    1594:	99 27       	eor	r25, r25
    1596:	b7 51       	subi	r27, 0x17	; 23
    1598:	b0 f0       	brcs	.+44     	; 0x15c6 <__fixunssfsi+0x3e>
    159a:	e1 f0       	breq	.+56     	; 0x15d4 <__fixunssfsi+0x4c>
    159c:	66 0f       	add	r22, r22
    159e:	77 1f       	adc	r23, r23
    15a0:	88 1f       	adc	r24, r24
    15a2:	99 1f       	adc	r25, r25
    15a4:	1a f0       	brmi	.+6      	; 0x15ac <__fixunssfsi+0x24>
    15a6:	ba 95       	dec	r27
    15a8:	c9 f7       	brne	.-14     	; 0x159c <__fixunssfsi+0x14>
    15aa:	14 c0       	rjmp	.+40     	; 0x15d4 <__fixunssfsi+0x4c>
    15ac:	b1 30       	cpi	r27, 0x01	; 1
    15ae:	91 f0       	breq	.+36     	; 0x15d4 <__fixunssfsi+0x4c>
    15b0:	0e 94 e4 0b 	call	0x17c8	; 0x17c8 <__fp_zero>
    15b4:	b1 e0       	ldi	r27, 0x01	; 1
    15b6:	08 95       	ret
    15b8:	0c 94 e4 0b 	jmp	0x17c8	; 0x17c8 <__fp_zero>
    15bc:	67 2f       	mov	r22, r23
    15be:	78 2f       	mov	r23, r24
    15c0:	88 27       	eor	r24, r24
    15c2:	b8 5f       	subi	r27, 0xF8	; 248
    15c4:	39 f0       	breq	.+14     	; 0x15d4 <__fixunssfsi+0x4c>
    15c6:	b9 3f       	cpi	r27, 0xF9	; 249
    15c8:	cc f3       	brlt	.-14     	; 0x15bc <__fixunssfsi+0x34>
    15ca:	86 95       	lsr	r24
    15cc:	77 95       	ror	r23
    15ce:	67 95       	ror	r22
    15d0:	b3 95       	inc	r27
    15d2:	d9 f7       	brne	.-10     	; 0x15ca <__fixunssfsi+0x42>
    15d4:	3e f4       	brtc	.+14     	; 0x15e4 <__fixunssfsi+0x5c>
    15d6:	90 95       	com	r25
    15d8:	80 95       	com	r24
    15da:	70 95       	com	r23
    15dc:	61 95       	neg	r22
    15de:	7f 4f       	sbci	r23, 0xFF	; 255
    15e0:	8f 4f       	sbci	r24, 0xFF	; 255
    15e2:	9f 4f       	sbci	r25, 0xFF	; 255
    15e4:	08 95       	ret

000015e6 <__floatunsisf>:
    15e6:	e8 94       	clt
    15e8:	09 c0       	rjmp	.+18     	; 0x15fc <__floatsisf+0x12>

000015ea <__floatsisf>:
    15ea:	97 fb       	bst	r25, 7
    15ec:	3e f4       	brtc	.+14     	; 0x15fc <__floatsisf+0x12>
    15ee:	90 95       	com	r25
    15f0:	80 95       	com	r24
    15f2:	70 95       	com	r23
    15f4:	61 95       	neg	r22
    15f6:	7f 4f       	sbci	r23, 0xFF	; 255
    15f8:	8f 4f       	sbci	r24, 0xFF	; 255
    15fa:	9f 4f       	sbci	r25, 0xFF	; 255
    15fc:	99 23       	and	r25, r25
    15fe:	a9 f0       	breq	.+42     	; 0x162a <__floatsisf+0x40>
    1600:	f9 2f       	mov	r31, r25
    1602:	96 e9       	ldi	r25, 0x96	; 150
    1604:	bb 27       	eor	r27, r27
    1606:	93 95       	inc	r25
    1608:	f6 95       	lsr	r31
    160a:	87 95       	ror	r24
    160c:	77 95       	ror	r23
    160e:	67 95       	ror	r22
    1610:	b7 95       	ror	r27
    1612:	f1 11       	cpse	r31, r1
    1614:	f8 cf       	rjmp	.-16     	; 0x1606 <__floatsisf+0x1c>
    1616:	fa f4       	brpl	.+62     	; 0x1656 <__floatsisf+0x6c>
    1618:	bb 0f       	add	r27, r27
    161a:	11 f4       	brne	.+4      	; 0x1620 <__floatsisf+0x36>
    161c:	60 ff       	sbrs	r22, 0
    161e:	1b c0       	rjmp	.+54     	; 0x1656 <__floatsisf+0x6c>
    1620:	6f 5f       	subi	r22, 0xFF	; 255
    1622:	7f 4f       	sbci	r23, 0xFF	; 255
    1624:	8f 4f       	sbci	r24, 0xFF	; 255
    1626:	9f 4f       	sbci	r25, 0xFF	; 255
    1628:	16 c0       	rjmp	.+44     	; 0x1656 <__floatsisf+0x6c>
    162a:	88 23       	and	r24, r24
    162c:	11 f0       	breq	.+4      	; 0x1632 <__floatsisf+0x48>
    162e:	96 e9       	ldi	r25, 0x96	; 150
    1630:	11 c0       	rjmp	.+34     	; 0x1654 <__floatsisf+0x6a>
    1632:	77 23       	and	r23, r23
    1634:	21 f0       	breq	.+8      	; 0x163e <__floatsisf+0x54>
    1636:	9e e8       	ldi	r25, 0x8E	; 142
    1638:	87 2f       	mov	r24, r23
    163a:	76 2f       	mov	r23, r22
    163c:	05 c0       	rjmp	.+10     	; 0x1648 <__floatsisf+0x5e>
    163e:	66 23       	and	r22, r22
    1640:	71 f0       	breq	.+28     	; 0x165e <__floatsisf+0x74>
    1642:	96 e8       	ldi	r25, 0x86	; 134
    1644:	86 2f       	mov	r24, r22
    1646:	70 e0       	ldi	r23, 0x00	; 0
    1648:	60 e0       	ldi	r22, 0x00	; 0
    164a:	2a f0       	brmi	.+10     	; 0x1656 <__floatsisf+0x6c>
    164c:	9a 95       	dec	r25
    164e:	66 0f       	add	r22, r22
    1650:	77 1f       	adc	r23, r23
    1652:	88 1f       	adc	r24, r24
    1654:	da f7       	brpl	.-10     	; 0x164c <__floatsisf+0x62>
    1656:	88 0f       	add	r24, r24
    1658:	96 95       	lsr	r25
    165a:	87 95       	ror	r24
    165c:	97 f9       	bld	r25, 7
    165e:	08 95       	ret

00001660 <fmin>:
    1660:	99 0f       	add	r25, r25
    1662:	bb 0b       	sbc	r27, r27
    1664:	55 0f       	add	r21, r21
    1666:	aa 0b       	sbc	r26, r26
    1668:	e0 e8       	ldi	r30, 0x80	; 128
    166a:	fe ef       	ldi	r31, 0xFE	; 254
    166c:	16 16       	cp	r1, r22
    166e:	17 06       	cpc	r1, r23
    1670:	e8 07       	cpc	r30, r24
    1672:	f9 07       	cpc	r31, r25
    1674:	70 f0       	brcs	.+28     	; 0x1692 <fmin+0x32>
    1676:	12 16       	cp	r1, r18
    1678:	13 06       	cpc	r1, r19
    167a:	e4 07       	cpc	r30, r20
    167c:	f5 07       	cpc	r31, r21
    167e:	60 f0       	brcs	.+24     	; 0x1698 <fmin+0x38>
    1680:	ba 17       	cp	r27, r26
    1682:	54 f0       	brlt	.+20     	; 0x1698 <fmin+0x38>
    1684:	31 f4       	brne	.+12     	; 0x1692 <fmin+0x32>
    1686:	26 17       	cp	r18, r22
    1688:	37 07       	cpc	r19, r23
    168a:	48 07       	cpc	r20, r24
    168c:	59 07       	cpc	r21, r25
    168e:	a7 95       	ror	r26
    1690:	1b f4       	brvc	.+6      	; 0x1698 <fmin+0x38>
    1692:	b9 01       	movw	r22, r18
    1694:	ca 01       	movw	r24, r20
    1696:	ba 2f       	mov	r27, r26
    1698:	b6 95       	lsr	r27
    169a:	97 95       	ror	r25
    169c:	08 95       	ret

0000169e <__fp_cmp>:
    169e:	99 0f       	add	r25, r25
    16a0:	00 08       	sbc	r0, r0
    16a2:	55 0f       	add	r21, r21
    16a4:	aa 0b       	sbc	r26, r26
    16a6:	e0 e8       	ldi	r30, 0x80	; 128
    16a8:	fe ef       	ldi	r31, 0xFE	; 254
    16aa:	16 16       	cp	r1, r22
    16ac:	17 06       	cpc	r1, r23
    16ae:	e8 07       	cpc	r30, r24
    16b0:	f9 07       	cpc	r31, r25
    16b2:	c0 f0       	brcs	.+48     	; 0x16e4 <__fp_cmp+0x46>
    16b4:	12 16       	cp	r1, r18
    16b6:	13 06       	cpc	r1, r19
    16b8:	e4 07       	cpc	r30, r20
    16ba:	f5 07       	cpc	r31, r21
    16bc:	98 f0       	brcs	.+38     	; 0x16e4 <__fp_cmp+0x46>
    16be:	62 1b       	sub	r22, r18
    16c0:	73 0b       	sbc	r23, r19
    16c2:	84 0b       	sbc	r24, r20
    16c4:	95 0b       	sbc	r25, r21
    16c6:	39 f4       	brne	.+14     	; 0x16d6 <__fp_cmp+0x38>
    16c8:	0a 26       	eor	r0, r26
    16ca:	61 f0       	breq	.+24     	; 0x16e4 <__fp_cmp+0x46>
    16cc:	23 2b       	or	r18, r19
    16ce:	24 2b       	or	r18, r20
    16d0:	25 2b       	or	r18, r21
    16d2:	21 f4       	brne	.+8      	; 0x16dc <__fp_cmp+0x3e>
    16d4:	08 95       	ret
    16d6:	0a 26       	eor	r0, r26
    16d8:	09 f4       	brne	.+2      	; 0x16dc <__fp_cmp+0x3e>
    16da:	a1 40       	sbci	r26, 0x01	; 1
    16dc:	a6 95       	lsr	r26
    16de:	8f ef       	ldi	r24, 0xFF	; 255
    16e0:	81 1d       	adc	r24, r1
    16e2:	81 1d       	adc	r24, r1
    16e4:	08 95       	ret

000016e6 <__fp_inf>:
    16e6:	97 f9       	bld	r25, 7
    16e8:	9f 67       	ori	r25, 0x7F	; 127
    16ea:	80 e8       	ldi	r24, 0x80	; 128
    16ec:	70 e0       	ldi	r23, 0x00	; 0
    16ee:	60 e0       	ldi	r22, 0x00	; 0
    16f0:	08 95       	ret

000016f2 <__fp_nan>:
    16f2:	9f ef       	ldi	r25, 0xFF	; 255
    16f4:	80 ec       	ldi	r24, 0xC0	; 192
    16f6:	08 95       	ret

000016f8 <__fp_powser>:
    16f8:	df 93       	push	r29
    16fa:	cf 93       	push	r28
    16fc:	1f 93       	push	r17
    16fe:	0f 93       	push	r16
    1700:	ff 92       	push	r15
    1702:	ef 92       	push	r14
    1704:	df 92       	push	r13
    1706:	7b 01       	movw	r14, r22
    1708:	8c 01       	movw	r16, r24
    170a:	68 94       	set
    170c:	06 c0       	rjmp	.+12     	; 0x171a <__fp_powser+0x22>
    170e:	da 2e       	mov	r13, r26
    1710:	ef 01       	movw	r28, r30
    1712:	0e 94 79 0c 	call	0x18f2	; 0x18f2 <__mulsf3x>
    1716:	fe 01       	movw	r30, r28
    1718:	e8 94       	clt
    171a:	a5 91       	lpm	r26, Z+
    171c:	25 91       	lpm	r18, Z+
    171e:	35 91       	lpm	r19, Z+
    1720:	45 91       	lpm	r20, Z+
    1722:	55 91       	lpm	r21, Z+
    1724:	a6 f3       	brts	.-24     	; 0x170e <__fp_powser+0x16>
    1726:	ef 01       	movw	r28, r30
    1728:	0e 94 b7 09 	call	0x136e	; 0x136e <__addsf3x>
    172c:	fe 01       	movw	r30, r28
    172e:	97 01       	movw	r18, r14
    1730:	a8 01       	movw	r20, r16
    1732:	da 94       	dec	r13
    1734:	69 f7       	brne	.-38     	; 0x1710 <__fp_powser+0x18>
    1736:	df 90       	pop	r13
    1738:	ef 90       	pop	r14
    173a:	ff 90       	pop	r15
    173c:	0f 91       	pop	r16
    173e:	1f 91       	pop	r17
    1740:	cf 91       	pop	r28
    1742:	df 91       	pop	r29
    1744:	08 95       	ret

00001746 <__fp_pscA>:
    1746:	00 24       	eor	r0, r0
    1748:	0a 94       	dec	r0
    174a:	16 16       	cp	r1, r22
    174c:	17 06       	cpc	r1, r23
    174e:	18 06       	cpc	r1, r24
    1750:	09 06       	cpc	r0, r25
    1752:	08 95       	ret

00001754 <__fp_pscB>:
    1754:	00 24       	eor	r0, r0
    1756:	0a 94       	dec	r0
    1758:	12 16       	cp	r1, r18
    175a:	13 06       	cpc	r1, r19
    175c:	14 06       	cpc	r1, r20
    175e:	05 06       	cpc	r0, r21
    1760:	08 95       	ret

00001762 <__fp_round>:
    1762:	09 2e       	mov	r0, r25
    1764:	03 94       	inc	r0
    1766:	00 0c       	add	r0, r0
    1768:	11 f4       	brne	.+4      	; 0x176e <__fp_round+0xc>
    176a:	88 23       	and	r24, r24
    176c:	52 f0       	brmi	.+20     	; 0x1782 <__fp_round+0x20>
    176e:	bb 0f       	add	r27, r27
    1770:	40 f4       	brcc	.+16     	; 0x1782 <__fp_round+0x20>
    1772:	bf 2b       	or	r27, r31
    1774:	11 f4       	brne	.+4      	; 0x177a <__fp_round+0x18>
    1776:	60 ff       	sbrs	r22, 0
    1778:	04 c0       	rjmp	.+8      	; 0x1782 <__fp_round+0x20>
    177a:	6f 5f       	subi	r22, 0xFF	; 255
    177c:	7f 4f       	sbci	r23, 0xFF	; 255
    177e:	8f 4f       	sbci	r24, 0xFF	; 255
    1780:	9f 4f       	sbci	r25, 0xFF	; 255
    1782:	08 95       	ret

00001784 <__fp_split3>:
    1784:	57 fd       	sbrc	r21, 7
    1786:	90 58       	subi	r25, 0x80	; 128
    1788:	44 0f       	add	r20, r20
    178a:	55 1f       	adc	r21, r21
    178c:	59 f0       	breq	.+22     	; 0x17a4 <__fp_splitA+0x10>
    178e:	5f 3f       	cpi	r21, 0xFF	; 255
    1790:	71 f0       	breq	.+28     	; 0x17ae <__fp_splitA+0x1a>
    1792:	47 95       	ror	r20

00001794 <__fp_splitA>:
    1794:	88 0f       	add	r24, r24
    1796:	97 fb       	bst	r25, 7
    1798:	99 1f       	adc	r25, r25
    179a:	61 f0       	breq	.+24     	; 0x17b4 <__fp_splitA+0x20>
    179c:	9f 3f       	cpi	r25, 0xFF	; 255
    179e:	79 f0       	breq	.+30     	; 0x17be <__fp_splitA+0x2a>
    17a0:	87 95       	ror	r24
    17a2:	08 95       	ret
    17a4:	12 16       	cp	r1, r18
    17a6:	13 06       	cpc	r1, r19
    17a8:	14 06       	cpc	r1, r20
    17aa:	55 1f       	adc	r21, r21
    17ac:	f2 cf       	rjmp	.-28     	; 0x1792 <__fp_split3+0xe>
    17ae:	46 95       	lsr	r20
    17b0:	f1 df       	rcall	.-30     	; 0x1794 <__fp_splitA>
    17b2:	08 c0       	rjmp	.+16     	; 0x17c4 <__fp_splitA+0x30>
    17b4:	16 16       	cp	r1, r22
    17b6:	17 06       	cpc	r1, r23
    17b8:	18 06       	cpc	r1, r24
    17ba:	99 1f       	adc	r25, r25
    17bc:	f1 cf       	rjmp	.-30     	; 0x17a0 <__fp_splitA+0xc>
    17be:	86 95       	lsr	r24
    17c0:	71 05       	cpc	r23, r1
    17c2:	61 05       	cpc	r22, r1
    17c4:	08 94       	sec
    17c6:	08 95       	ret

000017c8 <__fp_zero>:
    17c8:	e8 94       	clt

000017ca <__fp_szero>:
    17ca:	bb 27       	eor	r27, r27
    17cc:	66 27       	eor	r22, r22
    17ce:	77 27       	eor	r23, r23
    17d0:	cb 01       	movw	r24, r22
    17d2:	97 f9       	bld	r25, 7
    17d4:	08 95       	ret

000017d6 <__gesf2>:
    17d6:	0e 94 4f 0b 	call	0x169e	; 0x169e <__fp_cmp>
    17da:	08 f4       	brcc	.+2      	; 0x17de <__gesf2+0x8>
    17dc:	8f ef       	ldi	r24, 0xFF	; 255
    17de:	08 95       	ret

000017e0 <inverse>:
    17e0:	9b 01       	movw	r18, r22
    17e2:	ac 01       	movw	r20, r24
    17e4:	60 e0       	ldi	r22, 0x00	; 0
    17e6:	70 e0       	ldi	r23, 0x00	; 0
    17e8:	80 e8       	ldi	r24, 0x80	; 128
    17ea:	9f e3       	ldi	r25, 0x3F	; 63
    17ec:	0c 94 11 0a 	jmp	0x1422	; 0x1422 <__divsf3>
    17f0:	0c 94 73 0b 	jmp	0x16e6	; 0x16e6 <__fp_inf>
    17f4:	0c 94 db 0c 	jmp	0x19b6	; 0x19b6 <__fp_mpack>

000017f8 <ldexp>:
    17f8:	0e 94 ca 0b 	call	0x1794	; 0x1794 <__fp_splitA>
    17fc:	d8 f3       	brcs	.-10     	; 0x17f4 <inverse+0x14>
    17fe:	99 23       	and	r25, r25
    1800:	c9 f3       	breq	.-14     	; 0x17f4 <inverse+0x14>
    1802:	94 0f       	add	r25, r20
    1804:	51 1d       	adc	r21, r1
    1806:	a3 f3       	brvs	.-24     	; 0x17f0 <inverse+0x10>
    1808:	91 50       	subi	r25, 0x01	; 1
    180a:	50 40       	sbci	r21, 0x00	; 0
    180c:	94 f0       	brlt	.+36     	; 0x1832 <ldexp+0x3a>
    180e:	59 f0       	breq	.+22     	; 0x1826 <ldexp+0x2e>
    1810:	88 23       	and	r24, r24
    1812:	32 f0       	brmi	.+12     	; 0x1820 <ldexp+0x28>
    1814:	66 0f       	add	r22, r22
    1816:	77 1f       	adc	r23, r23
    1818:	88 1f       	adc	r24, r24
    181a:	91 50       	subi	r25, 0x01	; 1
    181c:	50 40       	sbci	r21, 0x00	; 0
    181e:	c1 f7       	brne	.-16     	; 0x1810 <ldexp+0x18>
    1820:	9e 3f       	cpi	r25, 0xFE	; 254
    1822:	51 05       	cpc	r21, r1
    1824:	2c f7       	brge	.-54     	; 0x17f0 <inverse+0x10>
    1826:	88 0f       	add	r24, r24
    1828:	91 1d       	adc	r25, r1
    182a:	96 95       	lsr	r25
    182c:	87 95       	ror	r24
    182e:	97 f9       	bld	r25, 7
    1830:	08 95       	ret
    1832:	5f 3f       	cpi	r21, 0xFF	; 255
    1834:	ac f0       	brlt	.+42     	; 0x1860 <ldexp+0x68>
    1836:	98 3e       	cpi	r25, 0xE8	; 232
    1838:	9c f0       	brlt	.+38     	; 0x1860 <ldexp+0x68>
    183a:	bb 27       	eor	r27, r27
    183c:	86 95       	lsr	r24
    183e:	77 95       	ror	r23
    1840:	67 95       	ror	r22
    1842:	b7 95       	ror	r27
    1844:	08 f4       	brcc	.+2      	; 0x1848 <ldexp+0x50>
    1846:	b1 60       	ori	r27, 0x01	; 1
    1848:	93 95       	inc	r25
    184a:	c1 f7       	brne	.-16     	; 0x183c <ldexp+0x44>
    184c:	bb 0f       	add	r27, r27
    184e:	58 f7       	brcc	.-42     	; 0x1826 <ldexp+0x2e>
    1850:	11 f4       	brne	.+4      	; 0x1856 <ldexp+0x5e>
    1852:	60 ff       	sbrs	r22, 0
    1854:	e8 cf       	rjmp	.-48     	; 0x1826 <ldexp+0x2e>
    1856:	6f 5f       	subi	r22, 0xFF	; 255
    1858:	7f 4f       	sbci	r23, 0xFF	; 255
    185a:	8f 4f       	sbci	r24, 0xFF	; 255
    185c:	9f 4f       	sbci	r25, 0xFF	; 255
    185e:	e3 cf       	rjmp	.-58     	; 0x1826 <ldexp+0x2e>
    1860:	0c 94 e5 0b 	jmp	0x17ca	; 0x17ca <__fp_szero>

00001864 <modf>:
    1864:	fa 01       	movw	r30, r20
    1866:	dc 01       	movw	r26, r24
    1868:	aa 0f       	add	r26, r26
    186a:	bb 1f       	adc	r27, r27
    186c:	9b 01       	movw	r18, r22
    186e:	ac 01       	movw	r20, r24
    1870:	bf 57       	subi	r27, 0x7F	; 127
    1872:	28 f4       	brcc	.+10     	; 0x187e <modf+0x1a>
    1874:	22 27       	eor	r18, r18
    1876:	33 27       	eor	r19, r19
    1878:	44 27       	eor	r20, r20
    187a:	50 78       	andi	r21, 0x80	; 128
    187c:	20 c0       	rjmp	.+64     	; 0x18be <modf+0x5a>
    187e:	b7 51       	subi	r27, 0x17	; 23
    1880:	90 f4       	brcc	.+36     	; 0x18a6 <modf+0x42>
    1882:	ab 2f       	mov	r26, r27
    1884:	00 24       	eor	r0, r0
    1886:	46 95       	lsr	r20
    1888:	37 95       	ror	r19
    188a:	27 95       	ror	r18
    188c:	01 1c       	adc	r0, r1
    188e:	a3 95       	inc	r26
    1890:	d2 f3       	brmi	.-12     	; 0x1886 <modf+0x22>
    1892:	00 20       	and	r0, r0
    1894:	71 f0       	breq	.+28     	; 0x18b2 <modf+0x4e>
    1896:	22 0f       	add	r18, r18
    1898:	33 1f       	adc	r19, r19
    189a:	44 1f       	adc	r20, r20
    189c:	b3 95       	inc	r27
    189e:	da f3       	brmi	.-10     	; 0x1896 <modf+0x32>
    18a0:	0e d0       	rcall	.+28     	; 0x18be <modf+0x5a>
    18a2:	0c 94 9f 09 	jmp	0x133e	; 0x133e <__subsf3>
    18a6:	61 30       	cpi	r22, 0x01	; 1
    18a8:	71 05       	cpc	r23, r1
    18aa:	a0 e8       	ldi	r26, 0x80	; 128
    18ac:	8a 07       	cpc	r24, r26
    18ae:	b9 46       	sbci	r27, 0x69	; 105
    18b0:	30 f4       	brcc	.+12     	; 0x18be <modf+0x5a>
    18b2:	9b 01       	movw	r18, r22
    18b4:	ac 01       	movw	r20, r24
    18b6:	66 27       	eor	r22, r22
    18b8:	77 27       	eor	r23, r23
    18ba:	88 27       	eor	r24, r24
    18bc:	90 78       	andi	r25, 0x80	; 128
    18be:	30 96       	adiw	r30, 0x00	; 0
    18c0:	21 f0       	breq	.+8      	; 0x18ca <modf+0x66>
    18c2:	20 83       	st	Z, r18
    18c4:	31 83       	std	Z+1, r19	; 0x01
    18c6:	42 83       	std	Z+2, r20	; 0x02
    18c8:	53 83       	std	Z+3, r21	; 0x03
    18ca:	08 95       	ret

000018cc <__mulsf3>:
    18cc:	0e 94 79 0c 	call	0x18f2	; 0x18f2 <__mulsf3x>
    18d0:	0c 94 b1 0b 	jmp	0x1762	; 0x1762 <__fp_round>
    18d4:	0e 94 a3 0b 	call	0x1746	; 0x1746 <__fp_pscA>
    18d8:	38 f0       	brcs	.+14     	; 0x18e8 <__mulsf3+0x1c>
    18da:	0e 94 aa 0b 	call	0x1754	; 0x1754 <__fp_pscB>
    18de:	20 f0       	brcs	.+8      	; 0x18e8 <__mulsf3+0x1c>
    18e0:	95 23       	and	r25, r21
    18e2:	11 f0       	breq	.+4      	; 0x18e8 <__mulsf3+0x1c>
    18e4:	0c 94 73 0b 	jmp	0x16e6	; 0x16e6 <__fp_inf>
    18e8:	0c 94 79 0b 	jmp	0x16f2	; 0x16f2 <__fp_nan>
    18ec:	11 24       	eor	r1, r1
    18ee:	0c 94 e5 0b 	jmp	0x17ca	; 0x17ca <__fp_szero>

000018f2 <__mulsf3x>:
    18f2:	0e 94 c2 0b 	call	0x1784	; 0x1784 <__fp_split3>
    18f6:	70 f3       	brcs	.-36     	; 0x18d4 <__mulsf3+0x8>

000018f8 <__mulsf3_pse>:
    18f8:	95 9f       	mul	r25, r21
    18fa:	c1 f3       	breq	.-16     	; 0x18ec <__mulsf3+0x20>
    18fc:	95 0f       	add	r25, r21
    18fe:	50 e0       	ldi	r21, 0x00	; 0
    1900:	55 1f       	adc	r21, r21
    1902:	62 9f       	mul	r22, r18
    1904:	f0 01       	movw	r30, r0
    1906:	72 9f       	mul	r23, r18
    1908:	bb 27       	eor	r27, r27
    190a:	f0 0d       	add	r31, r0
    190c:	b1 1d       	adc	r27, r1
    190e:	63 9f       	mul	r22, r19
    1910:	aa 27       	eor	r26, r26
    1912:	f0 0d       	add	r31, r0
    1914:	b1 1d       	adc	r27, r1
    1916:	aa 1f       	adc	r26, r26
    1918:	64 9f       	mul	r22, r20
    191a:	66 27       	eor	r22, r22
    191c:	b0 0d       	add	r27, r0
    191e:	a1 1d       	adc	r26, r1
    1920:	66 1f       	adc	r22, r22
    1922:	82 9f       	mul	r24, r18
    1924:	22 27       	eor	r18, r18
    1926:	b0 0d       	add	r27, r0
    1928:	a1 1d       	adc	r26, r1
    192a:	62 1f       	adc	r22, r18
    192c:	73 9f       	mul	r23, r19
    192e:	b0 0d       	add	r27, r0
    1930:	a1 1d       	adc	r26, r1
    1932:	62 1f       	adc	r22, r18
    1934:	83 9f       	mul	r24, r19
    1936:	a0 0d       	add	r26, r0
    1938:	61 1d       	adc	r22, r1
    193a:	22 1f       	adc	r18, r18
    193c:	74 9f       	mul	r23, r20
    193e:	33 27       	eor	r19, r19
    1940:	a0 0d       	add	r26, r0
    1942:	61 1d       	adc	r22, r1
    1944:	23 1f       	adc	r18, r19
    1946:	84 9f       	mul	r24, r20
    1948:	60 0d       	add	r22, r0
    194a:	21 1d       	adc	r18, r1
    194c:	82 2f       	mov	r24, r18
    194e:	76 2f       	mov	r23, r22
    1950:	6a 2f       	mov	r22, r26
    1952:	11 24       	eor	r1, r1
    1954:	9f 57       	subi	r25, 0x7F	; 127
    1956:	50 40       	sbci	r21, 0x00	; 0
    1958:	9a f0       	brmi	.+38     	; 0x1980 <__mulsf3_pse+0x88>
    195a:	f1 f0       	breq	.+60     	; 0x1998 <__mulsf3_pse+0xa0>
    195c:	88 23       	and	r24, r24
    195e:	4a f0       	brmi	.+18     	; 0x1972 <__mulsf3_pse+0x7a>
    1960:	ee 0f       	add	r30, r30
    1962:	ff 1f       	adc	r31, r31
    1964:	bb 1f       	adc	r27, r27
    1966:	66 1f       	adc	r22, r22
    1968:	77 1f       	adc	r23, r23
    196a:	88 1f       	adc	r24, r24
    196c:	91 50       	subi	r25, 0x01	; 1
    196e:	50 40       	sbci	r21, 0x00	; 0
    1970:	a9 f7       	brne	.-22     	; 0x195c <__mulsf3_pse+0x64>
    1972:	9e 3f       	cpi	r25, 0xFE	; 254
    1974:	51 05       	cpc	r21, r1
    1976:	80 f0       	brcs	.+32     	; 0x1998 <__mulsf3_pse+0xa0>
    1978:	0c 94 73 0b 	jmp	0x16e6	; 0x16e6 <__fp_inf>
    197c:	0c 94 e5 0b 	jmp	0x17ca	; 0x17ca <__fp_szero>
    1980:	5f 3f       	cpi	r21, 0xFF	; 255
    1982:	e4 f3       	brlt	.-8      	; 0x197c <__mulsf3_pse+0x84>
    1984:	98 3e       	cpi	r25, 0xE8	; 232
    1986:	d4 f3       	brlt	.-12     	; 0x197c <__mulsf3_pse+0x84>
    1988:	86 95       	lsr	r24
    198a:	77 95       	ror	r23
    198c:	67 95       	ror	r22
    198e:	b7 95       	ror	r27
    1990:	f7 95       	ror	r31
    1992:	e7 95       	ror	r30
    1994:	9f 5f       	subi	r25, 0xFF	; 255
    1996:	c1 f7       	brne	.-16     	; 0x1988 <__mulsf3_pse+0x90>
    1998:	fe 2b       	or	r31, r30
    199a:	88 0f       	add	r24, r24
    199c:	91 1d       	adc	r25, r1
    199e:	96 95       	lsr	r25
    19a0:	87 95       	ror	r24
    19a2:	97 f9       	bld	r25, 7
    19a4:	08 95       	ret

000019a6 <sin>:
    19a6:	9f 93       	push	r25
    19a8:	0e 94 eb 0c 	call	0x19d6	; 0x19d6 <__fp_rempio2>
    19ac:	0f 90       	pop	r0
    19ae:	07 fc       	sbrc	r0, 7
    19b0:	ee 5f       	subi	r30, 0xFE	; 254
    19b2:	0c 94 14 0d 	jmp	0x1a28	; 0x1a28 <__fp_sinus>

000019b6 <__fp_mpack>:
    19b6:	9f 3f       	cpi	r25, 0xFF	; 255
    19b8:	31 f0       	breq	.+12     	; 0x19c6 <__fp_mpack_finite+0xc>

000019ba <__fp_mpack_finite>:
    19ba:	91 50       	subi	r25, 0x01	; 1
    19bc:	20 f4       	brcc	.+8      	; 0x19c6 <__fp_mpack_finite+0xc>
    19be:	87 95       	ror	r24
    19c0:	77 95       	ror	r23
    19c2:	67 95       	ror	r22
    19c4:	b7 95       	ror	r27
    19c6:	88 0f       	add	r24, r24
    19c8:	91 1d       	adc	r25, r1
    19ca:	96 95       	lsr	r25
    19cc:	87 95       	ror	r24
    19ce:	97 f9       	bld	r25, 7
    19d0:	08 95       	ret
    19d2:	0c 94 79 0b 	jmp	0x16f2	; 0x16f2 <__fp_nan>

000019d6 <__fp_rempio2>:
    19d6:	0e 94 ca 0b 	call	0x1794	; 0x1794 <__fp_splitA>
    19da:	d8 f3       	brcs	.-10     	; 0x19d2 <__fp_mpack_finite+0x18>
    19dc:	e8 94       	clt
    19de:	e0 e0       	ldi	r30, 0x00	; 0
    19e0:	bb 27       	eor	r27, r27
    19e2:	9f 57       	subi	r25, 0x7F	; 127
    19e4:	f0 f0       	brcs	.+60     	; 0x1a22 <__fp_rempio2+0x4c>
    19e6:	2a ed       	ldi	r18, 0xDA	; 218
    19e8:	3f e0       	ldi	r19, 0x0F	; 15
    19ea:	49 ec       	ldi	r20, 0xC9	; 201
    19ec:	06 c0       	rjmp	.+12     	; 0x19fa <__fp_rempio2+0x24>
    19ee:	ee 0f       	add	r30, r30
    19f0:	bb 0f       	add	r27, r27
    19f2:	66 1f       	adc	r22, r22
    19f4:	77 1f       	adc	r23, r23
    19f6:	88 1f       	adc	r24, r24
    19f8:	28 f0       	brcs	.+10     	; 0x1a04 <__fp_rempio2+0x2e>
    19fa:	b2 3a       	cpi	r27, 0xA2	; 162
    19fc:	62 07       	cpc	r22, r18
    19fe:	73 07       	cpc	r23, r19
    1a00:	84 07       	cpc	r24, r20
    1a02:	28 f0       	brcs	.+10     	; 0x1a0e <__fp_rempio2+0x38>
    1a04:	b2 5a       	subi	r27, 0xA2	; 162
    1a06:	62 0b       	sbc	r22, r18
    1a08:	73 0b       	sbc	r23, r19
    1a0a:	84 0b       	sbc	r24, r20
    1a0c:	e3 95       	inc	r30
    1a0e:	9a 95       	dec	r25
    1a10:	72 f7       	brpl	.-36     	; 0x19ee <__fp_rempio2+0x18>
    1a12:	80 38       	cpi	r24, 0x80	; 128
    1a14:	30 f4       	brcc	.+12     	; 0x1a22 <__fp_rempio2+0x4c>
    1a16:	9a 95       	dec	r25
    1a18:	bb 0f       	add	r27, r27
    1a1a:	66 1f       	adc	r22, r22
    1a1c:	77 1f       	adc	r23, r23
    1a1e:	88 1f       	adc	r24, r24
    1a20:	d2 f7       	brpl	.-12     	; 0x1a16 <__fp_rempio2+0x40>
    1a22:	90 48       	sbci	r25, 0x80	; 128
    1a24:	0c 94 dd 0c 	jmp	0x19ba	; 0x19ba <__fp_mpack_finite>

00001a28 <__fp_sinus>:
    1a28:	ef 93       	push	r30
    1a2a:	e0 ff       	sbrs	r30, 0
    1a2c:	07 c0       	rjmp	.+14     	; 0x1a3c <__fp_sinus+0x14>
    1a2e:	a2 ea       	ldi	r26, 0xA2	; 162
    1a30:	2a ed       	ldi	r18, 0xDA	; 218
    1a32:	3f e0       	ldi	r19, 0x0F	; 15
    1a34:	49 ec       	ldi	r20, 0xC9	; 201
    1a36:	5f eb       	ldi	r21, 0xBF	; 191
    1a38:	0e 94 b7 09 	call	0x136e	; 0x136e <__addsf3x>
    1a3c:	0e 94 b1 0b 	call	0x1762	; 0x1762 <__fp_round>
    1a40:	0f 90       	pop	r0
    1a42:	03 94       	inc	r0
    1a44:	01 fc       	sbrc	r0, 1
    1a46:	90 58       	subi	r25, 0x80	; 128
    1a48:	e4 ea       	ldi	r30, 0xA4	; 164
    1a4a:	f0 e0       	ldi	r31, 0x00	; 0
    1a4c:	0c 94 28 0d 	jmp	0x1a50	; 0x1a50 <__fp_powsodd>

00001a50 <__fp_powsodd>:
    1a50:	9f 93       	push	r25
    1a52:	8f 93       	push	r24
    1a54:	7f 93       	push	r23
    1a56:	6f 93       	push	r22
    1a58:	ff 93       	push	r31
    1a5a:	ef 93       	push	r30
    1a5c:	9b 01       	movw	r18, r22
    1a5e:	ac 01       	movw	r20, r24
    1a60:	0e 94 66 0c 	call	0x18cc	; 0x18cc <__mulsf3>
    1a64:	ef 91       	pop	r30
    1a66:	ff 91       	pop	r31
    1a68:	0e 94 7c 0b 	call	0x16f8	; 0x16f8 <__fp_powser>
    1a6c:	2f 91       	pop	r18
    1a6e:	3f 91       	pop	r19
    1a70:	4f 91       	pop	r20
    1a72:	5f 91       	pop	r21
    1a74:	0c 94 66 0c 	jmp	0x18cc	; 0x18cc <__mulsf3>

00001a78 <__udivmodsi4>:
    1a78:	a1 e2       	ldi	r26, 0x21	; 33
    1a7a:	1a 2e       	mov	r1, r26
    1a7c:	aa 1b       	sub	r26, r26
    1a7e:	bb 1b       	sub	r27, r27
    1a80:	fd 01       	movw	r30, r26
    1a82:	0d c0       	rjmp	.+26     	; 0x1a9e <__udivmodsi4_ep>

00001a84 <__udivmodsi4_loop>:
    1a84:	aa 1f       	adc	r26, r26
    1a86:	bb 1f       	adc	r27, r27
    1a88:	ee 1f       	adc	r30, r30
    1a8a:	ff 1f       	adc	r31, r31
    1a8c:	a2 17       	cp	r26, r18
    1a8e:	b3 07       	cpc	r27, r19
    1a90:	e4 07       	cpc	r30, r20
    1a92:	f5 07       	cpc	r31, r21
    1a94:	20 f0       	brcs	.+8      	; 0x1a9e <__udivmodsi4_ep>
    1a96:	a2 1b       	sub	r26, r18
    1a98:	b3 0b       	sbc	r27, r19
    1a9a:	e4 0b       	sbc	r30, r20
    1a9c:	f5 0b       	sbc	r31, r21

00001a9e <__udivmodsi4_ep>:
    1a9e:	66 1f       	adc	r22, r22
    1aa0:	77 1f       	adc	r23, r23
    1aa2:	88 1f       	adc	r24, r24
    1aa4:	99 1f       	adc	r25, r25
    1aa6:	1a 94       	dec	r1
    1aa8:	69 f7       	brne	.-38     	; 0x1a84 <__udivmodsi4_loop>
    1aaa:	60 95       	com	r22
    1aac:	70 95       	com	r23
    1aae:	80 95       	com	r24
    1ab0:	90 95       	com	r25
    1ab2:	9b 01       	movw	r18, r22
    1ab4:	ac 01       	movw	r20, r24
    1ab6:	bd 01       	movw	r22, r26
    1ab8:	cf 01       	movw	r24, r30
    1aba:	08 95       	ret

00001abc <_exit>:
    1abc:	f8 94       	cli

00001abe <__stop_program>:
    1abe:	ff cf       	rjmp	.-2      	; 0x1abe <__stop_program>
