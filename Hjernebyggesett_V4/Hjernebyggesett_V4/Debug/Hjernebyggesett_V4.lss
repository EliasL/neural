
Hjernebyggesett_V4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000016  00803800  00001a8a  00001b3e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001a58  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000032  00009a58  00001a58  00001b0c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .bss          0000007d  00803816  00803816  00001b54  2**0
                  ALLOC
  4 .comment      00000030  00000000  00000000  00001b54  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001b84  2**2
                  CONTENTS, READONLY
  6 .debug_aranges 00000560  00000000  00000000  00001bc8  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00008cb6  00000000  00000000  00002128  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000370e  00000000  00000000  0000adde  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00002c9a  00000000  00000000  0000e4ec  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00000960  00000000  00000000  00011188  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000036dc  00000000  00000000  00011ae8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000015f1  00000000  00000000  000151c4  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 000003c8  00000000  00000000  000167b5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 61 00 	jmp	0xc2	; 0xc2 <__ctors_end>
       4:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
       8:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
       c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      10:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      14:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      18:	0c 94 62 05 	jmp	0xac4	; 0xac4 <__vector_6>
      1c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      20:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      24:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      28:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      2c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      30:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      34:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      38:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      3c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      40:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      44:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      48:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      4c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      50:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      54:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      58:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      5c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      60:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      64:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      68:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      6c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      70:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      74:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      78:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      7c:	07 63       	ori	r16, 0x37	; 55
      7e:	42 36       	cpi	r20, 0x62	; 98
      80:	b7 9b       	sbis	0x16, 7	; 22
      82:	d8 a7       	std	Y+40, r29	; 0x28
      84:	1a 39       	cpi	r17, 0x9A	; 154
      86:	68 56       	subi	r22, 0x68	; 104
      88:	18 ae       	std	Y+56, r1	; 0x38
      8a:	ba ab       	std	Y+50, r27	; 0x32
      8c:	55 8c       	ldd	r5, Z+29	; 0x1d
      8e:	1d 3c       	cpi	r17, 0xCD	; 205
      90:	b7 cc       	rjmp	.-1682   	; 0xfffffa00 <__eeprom_end+0xff7efa00>
      92:	57 63       	ori	r21, 0x37	; 55
      94:	bd 6d       	ori	r27, 0xDD	; 221
      96:	ed fd       	.word	0xfded	; ????
      98:	75 3e       	cpi	r23, 0xE5	; 229
      9a:	f6 17       	cp	r31, r22
      9c:	72 31       	cpi	r23, 0x12	; 18
      9e:	bf 00       	.word	0x00bf	; ????
      a0:	00 00       	nop
      a2:	80 3f       	cpi	r24, 0xF0	; 240
      a4:	05 a8       	ldd	r0, Z+53	; 0x35
      a6:	4c cd       	rjmp	.-1384   	; 0xfffffb40 <__eeprom_end+0xff7efb40>
      a8:	b2 d4       	rcall	.+2404   	; 0xa0e <tinyDendrite_get_potential+0x3c>
      aa:	4e b9       	out	0x0e, r20	; 14
      ac:	38 36       	cpi	r19, 0x68	; 104
      ae:	a9 02       	muls	r26, r25
      b0:	0c 50       	subi	r16, 0x0C	; 12
      b2:	b9 91       	ld	r27, Y+
      b4:	86 88       	ldd	r8, Z+22	; 0x16
      b6:	08 3c       	cpi	r16, 0xC8	; 200
      b8:	a6 aa       	std	Z+54, r10	; 0x36
      ba:	aa 2a       	or	r10, r26
      bc:	be 00       	.word	0x00be	; ????
      be:	00 00       	nop
      c0:	80 3f       	cpi	r24, 0xF0	; 240

000000c2 <__ctors_end>:
      c2:	11 24       	eor	r1, r1
      c4:	1f be       	out	0x3f, r1	; 63
      c6:	cf ef       	ldi	r28, 0xFF	; 255
      c8:	cd bf       	out	0x3d, r28	; 61
      ca:	df e3       	ldi	r29, 0x3F	; 63
      cc:	de bf       	out	0x3e, r29	; 62

000000ce <__do_copy_data>:
      ce:	18 e3       	ldi	r17, 0x38	; 56
      d0:	a0 e0       	ldi	r26, 0x00	; 0
      d2:	b8 e3       	ldi	r27, 0x38	; 56
      d4:	ea e8       	ldi	r30, 0x8A	; 138
      d6:	fa e1       	ldi	r31, 0x1A	; 26
      d8:	02 c0       	rjmp	.+4      	; 0xde <__do_copy_data+0x10>
      da:	05 90       	lpm	r0, Z+
      dc:	0d 92       	st	X+, r0
      de:	a6 31       	cpi	r26, 0x16	; 22
      e0:	b1 07       	cpc	r27, r17
      e2:	d9 f7       	brne	.-10     	; 0xda <__do_copy_data+0xc>

000000e4 <__do_clear_bss>:
      e4:	28 e3       	ldi	r18, 0x38	; 56
      e6:	a6 e1       	ldi	r26, 0x16	; 22
      e8:	b8 e3       	ldi	r27, 0x38	; 56
      ea:	01 c0       	rjmp	.+2      	; 0xee <.do_clear_bss_start>

000000ec <.do_clear_bss_loop>:
      ec:	1d 92       	st	X+, r1

000000ee <.do_clear_bss_start>:
      ee:	a3 39       	cpi	r26, 0x93	; 147
      f0:	b2 07       	cpc	r27, r18
      f2:	e1 f7       	brne	.-8      	; 0xec <.do_clear_bss_loop>
      f4:	0e 94 83 00 	call	0x106	; 0x106 <main>
      f8:	0c 94 2a 0d 	jmp	0x1a54	; 0x1a54 <_exit>

000000fc <__bad_interrupt>:
      fc:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000100 <atmel_start_init>:
/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
	system_init();
     100:	0e 94 a9 01 	call	0x352	; 0x352 <system_init>
     104:	08 95       	ret

00000106 <main>:

int main(void)
{	
	
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
     106:	0e 94 80 00 	call	0x100	; 0x100 <atmel_start_init>
	Setting this value will mean that the ADC (Analog to Digital Converter) will read 4.32v as 255, and 0v as 0.
	For some reason, instead of the reference voltage being 4.32v, it is 3.3v. 
	A plausible explanation is that the microchip does not up the voltage, so that if the microchip is only ever 
	supplied with 3.3v, it will output 3.3v as the max.
	*/
	VREF.CTRLA |= VREF_DAC0REFSEL_4V34_gc;
     10a:	e0 ea       	ldi	r30, 0xA0	; 160
     10c:	f0 e0       	ldi	r31, 0x00	; 0
     10e:	80 81       	ld	r24, Z
     110:	83 60       	ori	r24, 0x03	; 3
     112:	80 83       	st	Z, r24
	
	//tinyTester_test();
	
	tinySleep_prepare_sleep();
     114:	0e 94 43 09 	call	0x1286	; 0x1286 <tinySleep_prepare_sleep>
	
	tinySleep_enter_sleep();
     118:	0e 94 4c 09 	call	0x1298	; 0x1298 <tinySleep_enter_sleep>
	
	while (1)
	{
		// We don't want to update the neuron too often because of various reasons. The tinyISR_getflag is set every ms, and so the loop is only run once every ms.  
		if(tinyISR_getflag())
     11c:	0e 94 90 05 	call	0xb20	; 0xb20 <tinyISR_getflag>
     120:	88 23       	and	r24, r24
     122:	e1 f3       	breq	.-8      	; 0x11c <main+0x16>
		{
			//Testing sleep mode
			//tinySleep_enter_sleep();
			tinyCharge_update_charging_mode();
     124:	0e 94 f5 03 	call	0x7ea	; 0x7ea <tinyCharge_update_charging_mode>
			
			if(tinyCharge_is_connected_to_charger()){
     128:	0e 94 ba 03 	call	0x774	; 0x774 <tinyCharge_is_connected_to_charger>
     12c:	88 23       	and	r24, r24
     12e:	b9 f0       	breq	.+46     	; 0x15e <main+0x58>
				// Charge loop
				
				if(tinyCharge_is_fully_charged()){
     130:	0e 94 bd 03 	call	0x77a	; 0x77a <tinyCharge_is_fully_charged>
     134:	88 23       	and	r24, r24
     136:	49 f0       	breq	.+18     	; 0x14a <main+0x44>
					// When the neuron is connected to a charger, and fully charged:
					tinyLED_set_color(INN_LED, CHARGING_DONE_COLOR);
     138:	63 e0       	ldi	r22, 0x03	; 3
     13a:	80 e0       	ldi	r24, 0x00	; 0
     13c:	0e 94 e5 05 	call	0xbca	; 0xbca <tinyLED_set_color>
					tinyLED_set_color(OUT_LED, LED_OFF);
     140:	60 e0       	ldi	r22, 0x00	; 0
     142:	81 e0       	ldi	r24, 0x01	; 1
     144:	0e 94 e5 05 	call	0xbca	; 0xbca <tinyLED_set_color>
     148:	11 c0       	rjmp	.+34     	; 0x16c <main+0x66>
				}
				else{
					// When the neuron is charging and is not fully charged
					tinyLED_set_color_mode(OUT_LED, CHARGING_COLOR, SWING);
     14a:	43 e0       	ldi	r20, 0x03	; 3
     14c:	61 e0       	ldi	r22, 0x01	; 1
     14e:	81 e0       	ldi	r24, 0x01	; 1
     150:	0e 94 af 05 	call	0xb5e	; 0xb5e <tinyLED_set_color_mode>
					tinyLED_set_color(INN_LED, LED_OFF);
     154:	60 e0       	ldi	r22, 0x00	; 0
     156:	80 e0       	ldi	r24, 0x00	; 0
     158:	0e 94 e5 05 	call	0xbca	; 0xbca <tinyLED_set_color>
     15c:	07 c0       	rjmp	.+14     	; 0x16c <main+0x66>
				// Main loop			
				
				// Set LED
				// If the out led is turned LED_OFF, and the ping color is not disabled,
				// we turn on ping mode
				if(tinyLED_get_color(OUT_LED) == LED_OFF && PING_COLOR != LED_OFF){
     15e:	81 e0       	ldi	r24, 0x01	; 1
     160:	0e 94 a7 05 	call	0xb4e	; 0xb4e <tinyLED_get_color>
					tinyLED_set_color_mode(OUT_LED, PING_COLOR, PING);
				}				
				
				// Update button	
				tinyButton_update();
     164:	0e 94 54 03 	call	0x6a8	; 0x6a8 <tinyButton_update>
				
				// Update the potential (This is where most of the important stuff happens)
				tinyPotential_update();
     168:	0e 94 5f 08 	call	0x10be	; 0x10be <tinyPotential_update>
			}
			
			// Update LED
			tinyLED_update();
     16c:	0e 94 19 06 	call	0xc32	; 0xc32 <tinyLED_update>
				
			// Switch transistors
			tinyCharge_set_transistors();
     170:	0e 94 2f 04 	call	0x85e	; 0x85e <tinyCharge_set_transistors>
			
			// Prepare for next cycle
			tinyISR_setflag(false);
     174:	80 e0       	ldi	r24, 0x00	; 0
     176:	0e 94 8d 05 	call	0xb1a	; 0xb1a <tinyISR_setflag>
			tinyDebugger_send_uint32("time", tinyTime_now());
     17a:	0e 94 69 09 	call	0x12d2	; 0x12d2 <tinyTime_now>
     17e:	ab 01       	movw	r20, r22
     180:	bc 01       	movw	r22, r24
     182:	88 e5       	ldi	r24, 0x58	; 88
     184:	9a e9       	ldi	r25, 0x9A	; 154
     186:	0e 94 3a 04 	call	0x874	; 0x874 <tinyDebugger_send_uint32>
			tinyDebugger_end_line();
     18a:	0e 94 3d 04 	call	0x87a	; 0x87a <tinyDebugger_end_line>
     18e:	c6 cf       	rjmp	.-116    	; 0x11c <main+0x16>

00000190 <ADC_0_init>:
 * \return Conversion result read from the ADC_0 ADC module
 */
adc_result_t ADC_0_get_conversion_result(void)
{
	return (ADC1.RES);
}
     190:	e0 e4       	ldi	r30, 0x40	; 64
     192:	f6 e0       	ldi	r31, 0x06	; 6
     194:	80 e1       	ldi	r24, 0x10	; 16
     196:	82 83       	std	Z+2, r24	; 0x02
     198:	85 e0       	ldi	r24, 0x05	; 5
     19a:	80 83       	st	Z, r24
     19c:	80 e0       	ldi	r24, 0x00	; 0
     19e:	08 95       	ret

000001a0 <ADC_0_is_conversion_done>:
     1a0:	80 91 4b 06 	lds	r24, 0x064B	; 0x80064b <__TEXT_REGION_LENGTH__+0x70064b>
     1a4:	81 70       	andi	r24, 0x01	; 1
     1a6:	08 95       	ret

000001a8 <ADC_0_get_conversion>:
 *
 * \return Nothing
 */
void ADC_0_start_conversion(adc_1_channel_t channel)
{
	ADC1.MUXPOS  = channel;
     1a8:	e0 e4       	ldi	r30, 0x40	; 64
     1aa:	f6 e0       	ldi	r31, 0x06	; 6
     1ac:	86 83       	std	Z+6, r24	; 0x06
	ADC1.COMMAND = ADC_STCONV_bm;
     1ae:	81 e0       	ldi	r24, 0x01	; 1
     1b0:	80 87       	std	Z+8, r24	; 0x08
adc_result_t ADC_0_get_conversion(adc_1_channel_t channel)
{
	adc_result_t res;

	ADC_0_start_conversion(channel);
	while (!ADC_0_is_conversion_done())
     1b2:	0e 94 d0 00 	call	0x1a0	; 0x1a0 <ADC_0_is_conversion_done>
     1b6:	88 23       	and	r24, r24
     1b8:	e1 f3       	breq	.-8      	; 0x1b2 <ADC_0_get_conversion+0xa>
 *
 * \return Conversion result read from the ADC_0 ADC module
 */
adc_result_t ADC_0_get_conversion_result(void)
{
	return (ADC1.RES);
     1ba:	e0 e4       	ldi	r30, 0x40	; 64
     1bc:	f6 e0       	ldi	r31, 0x06	; 6
     1be:	20 89       	ldd	r18, Z+16	; 0x10
     1c0:	31 89       	ldd	r19, Z+17	; 0x11

	ADC_0_start_conversion(channel);
	while (!ADC_0_is_conversion_done())
		;
	res = ADC_0_get_conversion_result();
	ADC1.INTFLAGS |= ADC_RESRDY_bm;
     1c2:	93 85       	ldd	r25, Z+11	; 0x0b
     1c4:	91 60       	ori	r25, 0x01	; 1
     1c6:	93 87       	std	Z+11, r25	; 0x0b
	return res;
}
     1c8:	c9 01       	movw	r24, r18
     1ca:	08 95       	ret

000001cc <BOD_init>:
	//		 | BOD_VLMCFG_BELOW_gc; /* Interrupt when supply goes below VLM level */

	// BOD.VLMCTRLA = BOD_VLMLVL_5ABOVE_gc; /* VLM threshold 5% above BOD level */

	return 0;
}
     1cc:	80 e0       	ldi	r24, 0x00	; 0
     1ce:	08 95       	ret

000001d0 <DIGITAL_GLUE_LOGIC_0_init>:

	// Enable Protected register, peripheral must be disabled (ENABLE=0, in TCD.LUT0CTRLA).

	// CCL.SEQCTRL0 = CCL_SEQSEL_DISABLE_gc /* Sequential logic disabled */;

	CCL.TRUTH0 = 168; /* Truth 0: 168 */
     1d0:	e0 ec       	ldi	r30, 0xC0	; 192
     1d2:	f1 e0       	ldi	r31, 0x01	; 1
     1d4:	28 ea       	ldi	r18, 0xA8	; 168
     1d6:	20 87       	std	Z+8, r18	; 0x08

	CCL.LUT0CTRLC = CCL_INSEL2_TCA0_gc /* TCA0 WO2 input source */;
     1d8:	98 e0       	ldi	r25, 0x08	; 8
     1da:	97 83       	std	Z+7, r25	; 0x07

	CCL.LUT0CTRLB = CCL_INSEL0_SPI0_gc /* SPI0 SCK source */
     1dc:	8b eb       	ldi	r24, 0xBB	; 187
     1de:	86 83       	std	Z+6, r24	; 0x06
	                | CCL_INSEL1_SPI0_gc /* SPI0 MOSI input source */;

	CCL.LUT0CTRLA = 0 << CCL_CLKSRC_bp       /* Clock Source Selection: disabled */
     1e0:	39 e0       	ldi	r19, 0x09	; 9
     1e2:	35 83       	std	Z+5, r19	; 0x05
	                | CCL_EDGEDET_DIS_gc     /* Edge detector is disabled */
	                | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	                | 1 << CCL_ENABLE_bp     /* LUT Enable: enabled */
	                | 1 << CCL_OUTEN_bp;     /* Output Enable: enabled */

	CCL.TRUTH1 = 168; /* Truth 1: 168 */
     1e4:	24 87       	std	Z+12, r18	; 0x0c

	CCL.LUT1CTRLC = CCL_INSEL2_TCA0_gc /* TCA0 WO2 input source */;
     1e6:	93 87       	std	Z+11, r25	; 0x0b

	CCL.LUT1CTRLB = CCL_INSEL0_SPI0_gc /* SPI0 SCK source */
     1e8:	82 87       	std	Z+10, r24	; 0x0a
	//		 | CCL_EDGEDET_DIS_gc /* Edge detector is disabled */
	//		 | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	//		 | 0 << CCL_ENABLE_bp /* LUT Enable: disabled */
	//		 | 0 << CCL_OUTEN_bp; /* Output Enable: disabled */

	CCL.CTRLA = 1 << CCL_ENABLE_bp      /* Enable: enabled */
     1ea:	81 e4       	ldi	r24, 0x41	; 65
     1ec:	80 83       	st	Z, r24
	            | 1 << CCL_RUNSTDBY_bp; /* Run in Standby: enabled */

	return 0;
}
     1ee:	80 e0       	ldi	r24, 0x00	; 0
     1f0:	08 95       	ret

000001f2 <CLKCTRL_init>:
 *       on calling convention. The memory model is not visible to the
 *       preprocessor, so it must be defined in the Assembler preprocessor directives.
 */
static inline void ccp_write_io(void *addr, uint8_t value)
{
	protected_write_io(addr, CCP_IOREG_gc, value);
     1f2:	47 e0       	ldi	r20, 0x07	; 7
     1f4:	68 ed       	ldi	r22, 0xD8	; 216
     1f6:	8c e7       	ldi	r24, 0x7C	; 124
     1f8:	90 e0       	ldi	r25, 0x00	; 0
     1fa:	0e 94 d8 01 	call	0x3b0	; 0x3b0 <protected_write_io>
     1fe:	41 e0       	ldi	r20, 0x01	; 1
     200:	68 ed       	ldi	r22, 0xD8	; 216
     202:	81 e6       	ldi	r24, 0x61	; 97
     204:	90 e0       	ldi	r25, 0x00	; 0
     206:	0e 94 d8 01 	call	0x3b0	; 0x3b0 <protected_write_io>
	//		 | 0 << CLKCTRL_CLKOUT_bp /* System clock out: disabled */);

	// ccp_write_io((void*)&(CLKCTRL.MCLKLOCK),0 << CLKCTRL_LOCKEN_bp /* lock enable: disabled */);

	return 0;
}
     20a:	80 e0       	ldi	r24, 0x00	; 0
     20c:	08 95       	ret

0000020e <CPUINT_init>:

	// CPUINT.LVL0PRI = 0x0 << CPUINT_LVL0PRI_gp; /* Interrupt Level Priority: 0x0 */

	// CPUINT.LVL1VEC = 0x0 << CPUINT_LVL1VEC_gp; /* Interrupt Vector with High Priority: 0x0 */

	ENABLE_INTERRUPTS();
     20e:	78 94       	sei

	return 0;
}
     210:	80 e0       	ldi	r24, 0x00	; 0
     212:	08 95       	ret

00000214 <DAC_0_init>:
int8_t DAC_0_init()
{

	// DAC0.DATA = 0x0; /* DATA Register: 0x0 */

	DAC0.CTRLA = 1 << DAC_ENABLE_bp      /* DAC Enable: enabled */
     214:	81 e4       	ldi	r24, 0x41	; 65
     216:	80 93 a0 06 	sts	0x06A0, r24	; 0x8006a0 <__TEXT_REGION_LENGTH__+0x7006a0>
	             | 1 << DAC_OUTEN_bp     /* Output Buffer Enable: enabled */
	             | 0 << DAC_RUNSTDBY_bp; /* Run in Standby Mode: disabled */

	return 0;
}
     21a:	80 e0       	ldi	r24, 0x00	; 0
     21c:	08 95       	ret

0000021e <DAC_0_uninit>:
int8_t DAC_0_uninit()
{

	// DAC0.DATA = 0x0; /* DATA Register: 0x0 */

	DAC0.CTRLA = 1 << DAC_ENABLE_bp      /* DAC Enable: enabled */
     21e:	81 e0       	ldi	r24, 0x01	; 1
     220:	80 93 a0 06 	sts	0x06A0, r24	; 0x8006a0 <__TEXT_REGION_LENGTH__+0x7006a0>
	| 0 << DAC_OUTEN_bp     /* Output Buffer Enable: disabled */
	| 0 << DAC_RUNSTDBY_bp; /* Run in Standby Mode: disabled */

	return 0;
}
     224:	80 e0       	ldi	r24, 0x00	; 0
     226:	08 95       	ret

00000228 <DAC_0_enable>:
 *
 * \return Nothing
 */
void DAC_0_enable()
{
	DAC0.CTRLA |= DAC_ENABLE_bm;
     228:	e0 ea       	ldi	r30, 0xA0	; 160
     22a:	f6 e0       	ldi	r31, 0x06	; 6
     22c:	80 81       	ld	r24, Z
     22e:	81 60       	ori	r24, 0x01	; 1
     230:	80 83       	st	Z, r24
     232:	08 95       	ret

00000234 <DAC_0_disable>:
 *
 * \return Nothing
 */
void DAC_0_disable()
{
	DAC0.CTRLA &= ~DAC_ENABLE_bm;
     234:	e0 ea       	ldi	r30, 0xA0	; 160
     236:	f6 e0       	ldi	r31, 0x06	; 6
     238:	80 81       	ld	r24, Z
     23a:	8e 7f       	andi	r24, 0xFE	; 254
     23c:	80 83       	st	Z, r24
     23e:	08 95       	ret

00000240 <DAC_0_set_output>:
 *
 * \return Nothing
 */
void DAC_0_set_output(dac_resolution_t value)
{
	DAC0.DATA = value;
     240:	80 93 a1 06 	sts	0x06A1, r24	; 0x8006a1 <__TEXT_REGION_LENGTH__+0x7006a1>
     244:	08 95       	ret

00000246 <mcu_init>:
#ifdef __cplusplus
extern "C" {
#endif

void mcu_init(void)
{
     246:	e0 e1       	ldi	r30, 0x10	; 16
     248:	f4 e0       	ldi	r31, 0x04	; 4
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     24a:	80 81       	ld	r24, Z
     24c:	88 60       	ori	r24, 0x08	; 8
     24e:	81 93       	st	Z+, r24
	 * disables all peripherals to save power. Driver shall enable
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
     250:	e8 31       	cpi	r30, 0x18	; 24
     252:	84 e0       	ldi	r24, 0x04	; 4
     254:	f8 07       	cpc	r31, r24
     256:	c9 f7       	brne	.-14     	; 0x24a <mcu_init+0x4>
     258:	e0 e3       	ldi	r30, 0x30	; 48
     25a:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     25c:	80 81       	ld	r24, Z
     25e:	88 60       	ori	r24, 0x08	; 8
     260:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     262:	e8 33       	cpi	r30, 0x38	; 56
     264:	84 e0       	ldi	r24, 0x04	; 4
     266:	f8 07       	cpc	r31, r24
     268:	c9 f7       	brne	.-14     	; 0x25c <mcu_init+0x16>
     26a:	e0 e5       	ldi	r30, 0x50	; 80
     26c:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     26e:	80 81       	ld	r24, Z
     270:	88 60       	ori	r24, 0x08	; 8
     272:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     274:	e8 35       	cpi	r30, 0x58	; 88
     276:	84 e0       	ldi	r24, 0x04	; 4
     278:	f8 07       	cpc	r31, r24
     27a:	c9 f7       	brne	.-14     	; 0x26e <mcu_init+0x28>
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}
}
     27c:	08 95       	ret

0000027e <ADC_0_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     27e:	e5 e1       	ldi	r30, 0x15	; 21
     280:	f4 e0       	ldi	r31, 0x04	; 4
     282:	80 81       	ld	r24, Z
     284:	88 7f       	andi	r24, 0xF8	; 248
     286:	84 60       	ori	r24, 0x04	; 4
     288:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     28a:	80 81       	ld	r24, Z
     28c:	87 7f       	andi	r24, 0xF7	; 247
     28e:	80 83       	st	Z, r24
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     290:	e7 e1       	ldi	r30, 0x17	; 23
     292:	f4 e0       	ldi	r31, 0x04	; 4
     294:	80 81       	ld	r24, Z
     296:	88 7f       	andi	r24, 0xF8	; 248
     298:	84 60       	ori	r24, 0x04	; 4
     29a:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     29c:	80 81       	ld	r24, Z
     29e:	87 7f       	andi	r24, 0xF7	; 247
     2a0:	80 83       	st	Z, r24
 */
static inline void PORTC_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     2a2:	e0 e5       	ldi	r30, 0x50	; 80
     2a4:	f4 e0       	ldi	r31, 0x04	; 4
     2a6:	80 81       	ld	r24, Z
     2a8:	88 7f       	andi	r24, 0xF8	; 248
     2aa:	84 60       	ori	r24, 0x04	; 4
     2ac:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2ae:	80 81       	ld	r24, Z
     2b0:	87 7f       	andi	r24, 0xF7	; 247
     2b2:	80 83       	st	Z, r24
 */
static inline void PORTC_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     2b4:	e1 e5       	ldi	r30, 0x51	; 81
     2b6:	f4 e0       	ldi	r31, 0x04	; 4
     2b8:	80 81       	ld	r24, Z
     2ba:	88 7f       	andi	r24, 0xF8	; 248
     2bc:	84 60       	ori	r24, 0x04	; 4
     2be:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2c0:	80 81       	ld	r24, Z
     2c2:	87 7f       	andi	r24, 0xF7	; 247
     2c4:	80 83       	st	Z, r24
 */
static inline void PORTC_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     2c6:	e3 e5       	ldi	r30, 0x53	; 83
     2c8:	f4 e0       	ldi	r31, 0x04	; 4
     2ca:	80 81       	ld	r24, Z
     2cc:	88 7f       	andi	r24, 0xF8	; 248
     2ce:	84 60       	ori	r24, 0x04	; 4
     2d0:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2d2:	80 81       	ld	r24, Z
     2d4:	87 7f       	andi	r24, 0xF7	; 247
     2d6:	80 83       	st	Z, r24
	// Disable digital input buffer
	DEN4_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	DEN4_PIN_set_pull_mode(PORT_PULL_OFF);

	ADC_0_init();
     2d8:	0e 94 c8 00 	call	0x190	; 0x190 <ADC_0_init>
     2dc:	08 95       	ret

000002de <USART_0_initialization>:
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     2de:	23 98       	cbi	0x04, 3	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2e0:	e3 e3       	ldi	r30, 0x33	; 51
     2e2:	f4 e0       	ldi	r31, 0x04	; 4
     2e4:	80 81       	ld	r24, Z
     2e6:	87 7f       	andi	r24, 0xF7	; 247
     2e8:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     2ea:	22 9a       	sbi	0x04, 2	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     2ec:	2a 98       	cbi	0x05, 2	; 5
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	USART_0_init();
     2ee:	0e 94 10 02 	call	0x420	; 0x420 <USART_0_init>
     2f2:	08 95       	ret

000002f4 <TIMER_0_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     2f4:	25 9a       	sbi	0x04, 5	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     2f6:	2d 98       	cbi	0x05, 5	; 5
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLC |= PORTMUX_TCA02_bm;
     2f8:	e0 e0       	ldi	r30, 0x00	; 0
     2fa:	f2 e0       	ldi	r31, 0x02	; 2
     2fc:	82 81       	ldd	r24, Z+2	; 0x02
     2fe:	84 60       	ori	r24, 0x04	; 4
     300:	82 83       	std	Z+2, r24	; 0x02

	TIMER_0_init();
     302:	0e 94 00 02 	call	0x400	; 0x400 <TIMER_0_init>
     306:	08 95       	ret

00000308 <DIGITAL_GLUE_LOGIC_0_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     308:	24 9a       	sbi	0x04, 4	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     30a:	2c 98       	cbi	0x05, 4	; 5
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLA |= PORTMUX_LUT0_bm;
     30c:	e0 e0       	ldi	r30, 0x00	; 0
     30e:	f2 e0       	ldi	r31, 0x02	; 2
     310:	80 81       	ld	r24, Z
     312:	80 61       	ori	r24, 0x10	; 16
     314:	80 83       	st	Z, r24

	DIGITAL_GLUE_LOGIC_0_init();
     316:	0e 94 e8 00 	call	0x1d0	; 0x1d0 <DIGITAL_GLUE_LOGIC_0_init>
     31a:	08 95       	ret

0000031c <SPI_0_initialization>:
 */
static inline void PORTA_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
     31c:	02 98       	cbi	0x00, 2	; 0
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     31e:	e2 e1       	ldi	r30, 0x12	; 18
     320:	f4 e0       	ldi	r31, 0x04	; 4
     322:	80 81       	ld	r24, Z
     324:	87 7f       	andi	r24, 0xF7	; 247
     326:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     328:	01 9a       	sbi	0x00, 1	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     32a:	09 98       	cbi	0x01, 1	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     32c:	03 9a       	sbi	0x00, 3	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     32e:	0b 98       	cbi	0x01, 3	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     330:	04 9a       	sbi	0x00, 4	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     332:	0c 98       	cbi	0x01, 4	; 1
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	SPI_0_init();
     334:	0e 94 f8 01 	call	0x3f0	; 0x3f0 <SPI_0_init>
     338:	08 95       	ret

0000033a <DAC_0_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     33a:	e6 e1       	ldi	r30, 0x16	; 22
     33c:	f4 e0       	ldi	r31, 0x04	; 4
     33e:	80 81       	ld	r24, Z
     340:	88 7f       	andi	r24, 0xF8	; 248
     342:	84 60       	ori	r24, 0x04	; 4
     344:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     346:	80 81       	ld	r24, Z
     348:	87 7f       	andi	r24, 0xF7	; 247
     34a:	80 83       	st	Z, r24
	// Disable digital input buffer
	AXON_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	AXON_PIN_set_pull_mode(PORT_PULL_OFF);

	DAC_0_init();
     34c:	0e 94 0a 01 	call	0x214	; 0x214 <DAC_0_init>
     350:	08 95       	ret

00000352 <system_init>:
/**
 * \brief System initialization
 */
void system_init()
{
	mcu_init();
     352:	0e 94 23 01 	call	0x246	; 0x246 <mcu_init>
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     356:	21 9a       	sbi	0x04, 1	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     358:	29 98       	cbi	0x05, 1	; 5
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     35a:	26 98       	cbi	0x04, 6	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     35c:	e6 e3       	ldi	r30, 0x36	; 54
     35e:	f4 e0       	ldi	r31, 0x04	; 4
     360:	80 81       	ld	r24, Z
     362:	87 7f       	andi	r24, 0xF7	; 247
     364:	80 83       	st	Z, r24
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     366:	27 98       	cbi	0x04, 7	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     368:	e7 e3       	ldi	r30, 0x37	; 55
     36a:	f4 e0       	ldi	r31, 0x04	; 4
     36c:	80 81       	ld	r24, Z
     36e:	87 7f       	andi	r24, 0xF7	; 247
     370:	80 83       	st	Z, r24
 */
static inline void PORTC_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
     372:	42 98       	cbi	0x08, 2	; 8
static inline void PORTC_set_pin_pull_mode(const uint8_t pin, const enum port_pull_mode pull_mode)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
     374:	e2 e5       	ldi	r30, 0x52	; 82
     376:	f4 e0       	ldi	r31, 0x04	; 4
     378:	80 81       	ld	r24, Z
     37a:	88 60       	ori	r24, 0x08	; 8
     37c:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTC.DIR |= (1 << pin);
     37e:	45 9a       	sbi	0x08, 5	; 8
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     380:	4d 9a       	sbi	0x09, 5	; 9
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    true);

	CLKCTRL_init();
     382:	0e 94 f9 00 	call	0x1f2	; 0x1f2 <CLKCTRL_init>

	RTC_0_init();
     386:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <RTC_0_init>

	ADC_0_initialization();
     38a:	0e 94 3f 01 	call	0x27e	; 0x27e <ADC_0_initialization>

	USART_0_initialization();
     38e:	0e 94 6f 01 	call	0x2de	; 0x2de <USART_0_initialization>

	TIMER_0_initialization();
     392:	0e 94 7a 01 	call	0x2f4	; 0x2f4 <TIMER_0_initialization>

	DIGITAL_GLUE_LOGIC_0_initialization();
     396:	0e 94 84 01 	call	0x308	; 0x308 <DIGITAL_GLUE_LOGIC_0_initialization>

	SPI_0_initialization();
     39a:	0e 94 8e 01 	call	0x31c	; 0x31c <SPI_0_initialization>

	DAC_0_initialization();
     39e:	0e 94 9d 01 	call	0x33a	; 0x33a <DAC_0_initialization>

	CPUINT_init();
     3a2:	0e 94 07 01 	call	0x20e	; 0x20e <CPUINT_init>

	SLPCTRL_init();
     3a6:	0e 94 f6 01 	call	0x3ec	; 0x3ec <SLPCTRL_init>

	BOD_init();
     3aa:	0e 94 e6 00 	call	0x1cc	; 0x1cc <BOD_init>
     3ae:	08 95       	ret

000003b0 <protected_write_io>:
#if defined(__GNUC__)
  
#ifdef RAMPZ
	out     _SFR_IO_ADDR(RAMPZ), r1         // Clear bits 23:16 of Z
#endif
	movw    r30, r24                // Load addr into Z
     3b0:	fc 01       	movw	r30, r24
	out     CCP, r22                // Start CCP handshake
     3b2:	64 bf       	out	0x34, r22	; 52
	st      Z, r20                  // Write value to I/O register
     3b4:	40 83       	st	Z, r20
	ret                             // Return to caller
     3b6:	08 95       	ret

000003b8 <RTC_0_init>:
 * \return Initialization status.
 */
int8_t RTC_0_init()
{

	while (RTC.STATUS > 0) { /* Wait for all register to be synchronized */
     3b8:	e0 e4       	ldi	r30, 0x40	; 64
     3ba:	f1 e0       	ldi	r31, 0x01	; 1
     3bc:	81 81       	ldd	r24, Z+1	; 0x01
     3be:	81 11       	cpse	r24, r1
     3c0:	fd cf       	rjmp	.-6      	; 0x3bc <RTC_0_init+0x4>
	}

	// RTC.CMP = 0x0; /* Compare: 0x0 */

	RTC.CNT = 0x20; /* Counter: 0x20 */
     3c2:	e0 e4       	ldi	r30, 0x40	; 64
     3c4:	f1 e0       	ldi	r31, 0x01	; 1
     3c6:	80 e2       	ldi	r24, 0x20	; 32
     3c8:	90 e0       	ldi	r25, 0x00	; 0
     3ca:	80 87       	std	Z+8, r24	; 0x08
     3cc:	91 87       	std	Z+9, r25	; 0x09

	RTC.CTRLA = RTC_PRESCALER_DIV1_gc   /* 1 */
     3ce:	21 e8       	ldi	r18, 0x81	; 129
     3d0:	20 83       	st	Z, r18
	            | 1 << RTC_RTCEN_bp     /* Enable: enabled */
	            | 1 << RTC_RUNSTDBY_bp; /* Run In Standby: enabled */

	RTC.PER = 0x20 / TIMESCALE; /* Period: 0x20 */
     3d2:	82 87       	std	Z+10, r24	; 0x0a
     3d4:	93 87       	std	Z+11, r25	; 0x0b

	// RTC.CLKSEL = RTC_CLKSEL_INT32K_gc; /* 32KHz Internal Ultra Low Power Oscillator (OSCULP32K) */

	RTC.DBGCTRL = 1 << RTC_DBGRUN_bp; /* Run in debug: enabled */
     3d6:	81 e0       	ldi	r24, 0x01	; 1
     3d8:	85 83       	std	Z+5, r24	; 0x05

	RTC.INTCTRL = 0 << RTC_CMP_bp    /* Compare Match Interrupt enable: disabled */
     3da:	82 83       	std	Z+2, r24	; 0x02
	              | 1 << RTC_OVF_bp; /* Overflow Interrupt enable: enabled */

	while (RTC.PITSTATUS > 0) { /* Wait for all register to be synchronized */
     3dc:	81 89       	ldd	r24, Z+17	; 0x11
     3de:	81 11       	cpse	r24, r1
     3e0:	fd cf       	rjmp	.-6      	; 0x3dc <RTC_0_init+0x24>
	}

	RTC.PITCTRLA = RTC_PERIOD_OFF_gc    /* Off */
     3e2:	81 e0       	ldi	r24, 0x01	; 1
     3e4:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <__TEXT_REGION_LENGTH__+0x700150>
	// RTC.PITDBGCTRL = 0 << RTC_DBGRUN_bp; /* Run in debug: disabled */

	// RTC.PITINTCTRL = 0 << RTC_PI_bp; /* Periodic Interrupt: disabled */

	return 0;
}
     3e8:	80 e0       	ldi	r24, 0x00	; 0
     3ea:	08 95       	ret

000003ec <SLPCTRL_init>:

	// SLPCTRL.CTRLA = 0 << SLPCTRL_SEN_bp /* Sleep enable: disabled */
	//		 | SLPCTRL_SMODE_IDLE_gc; /* Idle mode */

	return 0;
}
     3ec:	80 e0       	ldi	r24, 0x00	; 0
     3ee:	08 95       	ret

000003f0 <SPI_0_init>:
 * \return Initialization status
 */
int8_t SPI_0_init()
{

	SPI0.CTRLA = 0 << SPI_CLK2X_bp     /* Enable Double Speed: disabled */
     3f0:	e0 e2       	ldi	r30, 0x20	; 32
     3f2:	f8 e0       	ldi	r31, 0x08	; 8
     3f4:	83 e2       	ldi	r24, 0x23	; 35
     3f6:	80 83       	st	Z, r24
	             | 0 << SPI_DORD_bp    /* Data Order Setting: disabled */
	             | 1 << SPI_ENABLE_bp  /* Enable Module: enabled */
	             | 1 << SPI_MASTER_bp  /* SPI module in master mode */
	             | SPI_PRESC_DIV16_gc; /* System Clock / 16 */

	SPI0.CTRLB = 0 << SPI_BUFEN_bp   /* Buffer Mode Enable: disabled */
     3f8:	84 e0       	ldi	r24, 0x04	; 4
     3fa:	81 83       	std	Z+1, r24	; 0x01
	//		 | 0 << SPI_RXCIE_bp /* Receive Complete Interrupt Enable: disabled */
	//		 | 0 << SPI_SSIE_bp /* Slave Select Trigger Interrupt Enable: disabled */
	//		 | 0 << SPI_TXCIE_bp; /* Transfer Complete Interrupt Enable: disabled */

	return 0;
}
     3fc:	80 e0       	ldi	r24, 0x00	; 0
     3fe:	08 95       	ret

00000400 <TIMER_0_init>:

	// TCA0.SINGLE.CMP0 = 0x0; /* Compare Register 0: 0x0 */

	// TCA0.SINGLE.CMP1 = 0x0; /* Compare Register 1: 0x0 */

	TCA0.SINGLE.CMP2 = 0x4; /* Compare Register 2: 0x4 */
     400:	e0 e0       	ldi	r30, 0x00	; 0
     402:	fa e0       	ldi	r31, 0x0A	; 10
     404:	84 e0       	ldi	r24, 0x04	; 4
     406:	90 e0       	ldi	r25, 0x00	; 0
     408:	84 a7       	std	Z+44, r24	; 0x2c
     40a:	95 a7       	std	Z+45, r25	; 0x2d

	// TCA0.SINGLE.CNT = 0x0; /* Count: 0x0 */

	TCA0.SINGLE.CTRLB = 0 << TCA_SINGLE_ALUPD_bp            /* Auto Lock Update: disabled */
     40c:	83 e4       	ldi	r24, 0x43	; 67
     40e:	81 83       	std	Z+1, r24	; 0x01
	                    | 0 << TCA_SINGLE_CMP0EN_bp         /* Compare 0 Enable: disabled */
	                    | 0 << TCA_SINGLE_CMP1EN_bp         /* Compare 1 Enable: disabled */
	                    | 1 << TCA_SINGLE_CMP2EN_bp         /* Compare 2 Enable: enabled */
	                    | TCA_SINGLE_WGMODE_SINGLESLOPE_gc; /*  */

	TCA0.SINGLE.CTRLC = 0 << TCA_SINGLE_CMP0OV_bp    /* Compare 0 Waveform Output Value: disabled */
     410:	84 e0       	ldi	r24, 0x04	; 4
     412:	82 83       	std	Z+2, r24	; 0x02
	// TCA0.SINGLE.INTCTRL = 0 << TCA_SINGLE_CMP0_bp /* Compare 0 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP1_bp /* Compare 1 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP2_bp /* Compare 2 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_OVF_bp; /* Overflow Interrupt: disabled */

	TCA0.SINGLE.PER = 0x7; /* Period: 0x7 */
     414:	87 e0       	ldi	r24, 0x07	; 7
     416:	90 e0       	ldi	r25, 0x00	; 0
     418:	86 a3       	std	Z+38, r24	; 0x26
     41a:	97 a3       	std	Z+39, r25	; 0x27

	// TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV1_gc /* System Clock */
	//		 | 0 << TCA_SINGLE_ENABLE_bp; /* Module Enable: disabled */

	return 0;
}
     41c:	80 e0       	ldi	r24, 0x00	; 0
     41e:	08 95       	ret

00000420 <USART_0_init>:
uint8_t USART_0_read()
{
	while (!(USART0.STATUS & USART_RXCIF_bm))
		;
	return USART0.RXDATAL;
}
     420:	e0 e0       	ldi	r30, 0x00	; 0
     422:	f8 e0       	ldi	r31, 0x08	; 8
     424:	8b e5       	ldi	r24, 0x5B	; 91
     426:	91 e0       	ldi	r25, 0x01	; 1
     428:	80 87       	std	Z+8, r24	; 0x08
     42a:	91 87       	std	Z+9, r25	; 0x09
     42c:	80 ec       	ldi	r24, 0xC0	; 192
     42e:	86 83       	std	Z+6, r24	; 0x06
     430:	80 e0       	ldi	r24, 0x00	; 0
     432:	98 e3       	ldi	r25, 0x38	; 56
     434:	80 93 8f 38 	sts	0x388F, r24	; 0x80388f <__iob+0x2>
     438:	90 93 90 38 	sts	0x3890, r25	; 0x803890 <__iob+0x3>
     43c:	80 e0       	ldi	r24, 0x00	; 0
     43e:	08 95       	ret

00000440 <USART_0_write>:
 *
 * \return Nothing
 */
void USART_0_write(const uint8_t data)
{
	while (!(USART0.STATUS & USART_DREIF_bm))
     440:	e0 e0       	ldi	r30, 0x00	; 0
     442:	f8 e0       	ldi	r31, 0x08	; 8
     444:	94 81       	ldd	r25, Z+4	; 0x04
     446:	95 ff       	sbrs	r25, 5
     448:	fd cf       	rjmp	.-6      	; 0x444 <USART_0_write+0x4>
		;
	USART0.TXDATAL = data;
     44a:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <__TEXT_REGION_LENGTH__+0x700802>
     44e:	08 95       	ret

00000450 <USART_0_printCHAR>:

#if defined(__GNUC__)

int USART_0_printCHAR(char character, FILE *stream)
{
	USART_0_write(character);
     450:	0e 94 20 02 	call	0x440	; 0x440 <USART_0_write>
	return 0;
}
     454:	80 e0       	ldi	r24, 0x00	; 0
     456:	90 e0       	ldi	r25, 0x00	; 0
     458:	08 95       	ret

0000045a <tinyAxon_add_pulse>:
{
	// We want to check each slot in the pulse_queue, and
	// if we find an empty slot (0), we add a pulse.
	for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
	{
		if(pulse_queue[i] == 0){
     45a:	20 91 16 38 	lds	r18, 0x3816	; 0x803816 <__data_end>
     45e:	30 91 17 38 	lds	r19, 0x3817	; 0x803817 <__data_end+0x1>
     462:	23 2b       	or	r18, r19
     464:	51 f0       	breq	.+20     	; 0x47a <tinyAxon_add_pulse+0x20>
     466:	e8 e1       	ldi	r30, 0x18	; 24
     468:	f8 e3       	ldi	r31, 0x38	; 56
     46a:	21 e0       	ldi	r18, 0x01	; 1
     46c:	30 e0       	ldi	r19, 0x00	; 0
     46e:	b9 01       	movw	r22, r18
     470:	41 91       	ld	r20, Z+
     472:	51 91       	ld	r21, Z+
     474:	45 2b       	or	r20, r21
     476:	81 f4       	brne	.+32     	; 0x498 <tinyAxon_add_pulse+0x3e>
     478:	02 c0       	rjmp	.+4      	; 0x47e <tinyAxon_add_pulse+0x24>
     47a:	60 e0       	ldi	r22, 0x00	; 0
     47c:	70 e0       	ldi	r23, 0x00	; 0
			pulse_queue[i] = new_pulse;
     47e:	66 0f       	add	r22, r22
     480:	77 1f       	adc	r23, r23
     482:	fb 01       	movw	r30, r22
     484:	ea 5e       	subi	r30, 0xEA	; 234
     486:	f7 4c       	sbci	r31, 0xC7	; 199
     488:	80 83       	st	Z, r24
     48a:	91 83       	std	Z+1, r25	; 0x01
			pulses_in_queue++;
     48c:	80 91 2a 38 	lds	r24, 0x382A	; 0x80382a <pulses_in_queue>
     490:	8f 5f       	subi	r24, 0xFF	; 255
     492:	80 93 2a 38 	sts	0x382A, r24	; 0x80382a <pulses_in_queue>
			// We return so we only ever add one
			break;
     496:	08 95       	ret
     498:	2f 5f       	subi	r18, 0xFF	; 255
     49a:	3f 4f       	sbci	r19, 0xFF	; 255
*/
static void tinyAxon_add_pulse(uint16_t new_pulse)
{
	// We want to check each slot in the pulse_queue, and
	// if we find an empty slot (0), we add a pulse.
	for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
     49c:	2a 30       	cpi	r18, 0x0A	; 10
     49e:	31 05       	cpc	r19, r1
     4a0:	31 f7       	brne	.-52     	; 0x46e <tinyAxon_add_pulse+0x14>
     4a2:	08 95       	ret

000004a4 <tinyAxon_is_firing>:
// DAC has no DAC_0_get_output, so we keep track of this here.
uint8_t axonOutputValue = 0;


_Bool tinyAxon_is_firing(){
	return axonOutputValue != NO_SIGNAL_OUTPUT;
     4a4:	81 e0       	ldi	r24, 0x01	; 1
     4a6:	90 91 2b 38 	lds	r25, 0x382B	; 0x80382b <axonOutputValue>
     4aa:	91 11       	cpse	r25, r1
     4ac:	01 c0       	rjmp	.+2      	; 0x4b0 <tinyAxon_is_firing+0xc>
     4ae:	80 e0       	ldi	r24, 0x00	; 0
}
     4b0:	08 95       	ret

000004b2 <find_newest_pulse>:
uint8_t find_newest_pulse() {
	uint16_t max;
	uint8_t current_index = 0;
	uint8_t return_index = 0;
	
	max = pulse_queue[current_index];
     4b2:	40 91 16 38 	lds	r20, 0x3816	; 0x803816 <__data_end>
     4b6:	50 91 17 38 	lds	r21, 0x3817	; 0x803817 <__data_end+0x1>
     4ba:	e8 e1       	ldi	r30, 0x18	; 24
     4bc:	f8 e3       	ldi	r31, 0x38	; 56
	
// This function will be used with pulse_queue to find the newest pulse
uint8_t find_newest_pulse() {
	uint16_t max;
	uint8_t current_index = 0;
	uint8_t return_index = 0;
     4be:	80 e0       	ldi	r24, 0x00	; 0
	
	max = pulse_queue[current_index];
	
	for (current_index = 1; current_index < MAX_NUMBER_OF_PULSES; current_index++) {
     4c0:	91 e0       	ldi	r25, 0x01	; 1
		if (pulse_queue[current_index] > max) {
     4c2:	21 91       	ld	r18, Z+
     4c4:	31 91       	ld	r19, Z+
     4c6:	42 17       	cp	r20, r18
     4c8:	53 07       	cpc	r21, r19
     4ca:	10 f4       	brcc	.+4      	; 0x4d0 <find_newest_pulse+0x1e>
     4cc:	89 2f       	mov	r24, r25
			return_index = current_index;
			max = pulse_queue[current_index];
     4ce:	a9 01       	movw	r20, r18
	uint8_t current_index = 0;
	uint8_t return_index = 0;
	
	max = pulse_queue[current_index];
	
	for (current_index = 1; current_index < MAX_NUMBER_OF_PULSES; current_index++) {
     4d0:	9f 5f       	subi	r25, 0xFF	; 255
     4d2:	9a 30       	cpi	r25, 0x0A	; 10
     4d4:	b1 f7       	brne	.-20     	; 0x4c2 <find_newest_pulse+0x10>
			return_index = current_index;
			max = pulse_queue[current_index];
		}
	}
	return return_index;
}
     4d6:	08 95       	ret

000004d8 <tinyAxon_stop_sending_pulse>:
	tinyLED_set_color_mode(OUT_LED, WHITE, FLASH_ONCE);
}

void tinyAxon_stop_sending_pulse()
{
	DAC_0_set_output(NO_SIGNAL_OUTPUT);
     4d8:	80 e0       	ldi	r24, 0x00	; 0
     4da:	90 e0       	ldi	r25, 0x00	; 0
     4dc:	0e 94 20 01 	call	0x240	; 0x240 <DAC_0_set_output>
	axonOutputValue=NO_SIGNAL_OUTPUT;
     4e0:	10 92 2b 38 	sts	0x382B, r1	; 0x80382b <axonOutputValue>
     4e4:	08 95       	ret

000004e6 <tinyAxon_remove_pulse>:

/*
If the potential is very low, we want to try to remove a pulse.
*/
bool tinyAxon_remove_pulse(void)
{
     4e6:	cf 93       	push	r28
	// We want to return a bool indicating whether or not a pulse actually was removed.
	if(pulses_in_queue == 0){
     4e8:	c0 91 2a 38 	lds	r28, 0x382A	; 0x80382a <pulses_in_queue>
     4ec:	cc 23       	and	r28, r28
     4ee:	c1 f0       	breq	.+48     	; 0x520 <tinyAxon_remove_pulse+0x3a>
		//There was no pulse to remove.
		return false;
	}
	else{
		// If we are to remove a pulse, we want to remove the one that will fire last.
		uint8_t pulse_index = find_newest_pulse();
     4f0:	0e 94 59 02 	call	0x4b2	; 0x4b2 <find_newest_pulse>
		uint16_t newest_pulse = pulse_queue[pulse_index];
     4f4:	90 e0       	ldi	r25, 0x00	; 0
     4f6:	fc 01       	movw	r30, r24
     4f8:	ee 0f       	add	r30, r30
     4fa:	ff 1f       	adc	r31, r31
     4fc:	ea 5e       	subi	r30, 0xEA	; 234
     4fe:	f7 4c       	sbci	r31, 0xC7	; 199
	
		// Now we want to check if the pulse is too far away to be affected by the low potential, or close enough that we decide to remove it.
		// (When we say that the pulse is too far away, it refers to the biological process of how the potential spreads from Dendrites to axon).
		if(newest_pulse > PULSE_NO_RETURN_TIME){
     500:	20 81       	ld	r18, Z
     502:	31 81       	ldd	r19, Z+1	; 0x01
     504:	23 2b       	or	r18, r19
     506:	71 f0       	breq	.+28     	; 0x524 <tinyAxon_remove_pulse+0x3e>
			// We decided to remove the pulse
			pulse_queue[pulse_index] = 0;
     508:	88 0f       	add	r24, r24
     50a:	99 1f       	adc	r25, r25
     50c:	fc 01       	movw	r30, r24
     50e:	ea 5e       	subi	r30, 0xEA	; 234
     510:	f7 4c       	sbci	r31, 0xC7	; 199
     512:	10 82       	st	Z, r1
     514:	11 82       	std	Z+1, r1	; 0x01
			pulses_in_queue--;
     516:	c1 50       	subi	r28, 0x01	; 1
     518:	c0 93 2a 38 	sts	0x382A, r28	; 0x80382a <pulses_in_queue>
			return true;
     51c:	81 e0       	ldi	r24, 0x01	; 1
     51e:	03 c0       	rjmp	.+6      	; 0x526 <tinyAxon_remove_pulse+0x40>
bool tinyAxon_remove_pulse(void)
{
	// We want to return a bool indicating whether or not a pulse actually was removed.
	if(pulses_in_queue == 0){
		//There was no pulse to remove.
		return false;
     520:	80 e0       	ldi	r24, 0x00	; 0
     522:	01 c0       	rjmp	.+2      	; 0x526 <tinyAxon_remove_pulse+0x40>
			pulses_in_queue--;
			return true;
		}
		// Here we have found that there is a pulse queued, but it is old enough to let pass anyway, so now we need to put it back into the queue.
		else{
			return false;
     524:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     526:	cf 91       	pop	r28
     528:	08 95       	ret

0000052a <tinyAxon_update_potential>:
/*
Decides whether or not the axon should fire
If the axon does fire, the potential is reduced
*/
double tinyAxon_update_potential(double potential)
{	
     52a:	cf 92       	push	r12
     52c:	df 92       	push	r13
     52e:	ef 92       	push	r14
     530:	ff 92       	push	r15
     532:	6b 01       	movw	r12, r22
     534:	7c 01       	movw	r14, r24
	//While the neuron has enough potential to fire, we want to fire more
	while (potential >= THRESHOLD_POTENTIAL)
     536:	20 e0       	ldi	r18, 0x00	; 0
     538:	30 e0       	ldi	r19, 0x00	; 0
     53a:	48 ec       	ldi	r20, 0xC8	; 200
     53c:	51 e4       	ldi	r21, 0x41	; 65
     53e:	0e 94 b7 0b 	call	0x176e	; 0x176e <__gesf2>
     542:	88 23       	and	r24, r24
     544:	bc f1       	brlt	.+110    	; 0x5b4 <tinyAxon_update_potential+0x8a>
	{
		// We have to check if there are already queued pulses, so that the frequency never exceeds FIRE_DELAY
		if(pulses_in_queue>0){
     546:	80 91 2a 38 	lds	r24, 0x382A	; 0x80382a <pulses_in_queue>
     54a:	88 23       	and	r24, r24
     54c:	b1 f0       	breq	.+44     	; 0x57a <tinyAxon_update_potential+0x50>
			uint16_t newest_pulse = pulse_queue[find_newest_pulse()];
     54e:	0e 94 59 02 	call	0x4b2	; 0x4b2 <find_newest_pulse>
     552:	e8 2f       	mov	r30, r24
     554:	f0 e0       	ldi	r31, 0x00	; 0
     556:	ee 0f       	add	r30, r30
     558:	ff 1f       	adc	r31, r31
     55a:	ea 5e       	subi	r30, 0xEA	; 234
     55c:	f7 4c       	sbci	r31, 0xC7	; 199
			
			// There is at least one pulse in the queue, and it is "so close", that we need to offset the new pulse, so that we keep at least
			// one FIRE_DELAY between each pulse
			if(newest_pulse + FIRE_DELAY > TRAVLE_DELAY){
     55e:	80 81       	ld	r24, Z
     560:	91 81       	ldd	r25, Z+1	; 0x01
     562:	0a 96       	adiw	r24, 0x0a	; 10
     564:	85 36       	cpi	r24, 0x65	; 101
     566:	91 05       	cpc	r25, r1
     568:	18 f0       	brcs	.+6      	; 0x570 <tinyAxon_update_potential+0x46>
				tinyAxon_add_pulse(newest_pulse + FIRE_DELAY);
     56a:	0e 94 2d 02 	call	0x45a	; 0x45a <tinyAxon_add_pulse>
     56e:	09 c0       	rjmp	.+18     	; 0x582 <tinyAxon_update_potential+0x58>
			}
			// There is at least one pulse in the queue, but it's "far enough away" to ignore
			else{
				tinyAxon_add_pulse(TRAVLE_DELAY);
     570:	84 e6       	ldi	r24, 0x64	; 100
     572:	90 e0       	ldi	r25, 0x00	; 0
     574:	0e 94 2d 02 	call	0x45a	; 0x45a <tinyAxon_add_pulse>
     578:	04 c0       	rjmp	.+8      	; 0x582 <tinyAxon_update_potential+0x58>
			}
		}
		// There are no pulses in the queue, so we add a pulse as normal
		else{
			tinyAxon_add_pulse(TRAVLE_DELAY);		
     57a:	84 e6       	ldi	r24, 0x64	; 100
     57c:	90 e0       	ldi	r25, 0x00	; 0
     57e:	0e 94 2d 02 	call	0x45a	; 0x45a <tinyAxon_add_pulse>
		}
		
		potential += POSTFIRE_POTENTIAL_REACTION; // This is usually defined as a negative value, don't be confused by the +=
     582:	20 e0       	ldi	r18, 0x00	; 0
     584:	30 e0       	ldi	r19, 0x00	; 0
     586:	48 ec       	ldi	r20, 0xC8	; 200
     588:	51 e4       	ldi	r21, 0x41	; 65
     58a:	c7 01       	movw	r24, r14
     58c:	b6 01       	movw	r22, r12
     58e:	0e 94 72 09 	call	0x12e4	; 0x12e4 <__subsf3>
     592:	6b 01       	movw	r12, r22
     594:	7c 01       	movw	r14, r24
		
		tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
     596:	45 e0       	ldi	r20, 0x05	; 5
     598:	63 e0       	ldi	r22, 0x03	; 3
     59a:	80 e0       	ldi	r24, 0x00	; 0
     59c:	0e 94 af 05 	call	0xb5e	; 0xb5e <tinyLED_set_color_mode>
If the axon does fire, the potential is reduced
*/
double tinyAxon_update_potential(double potential)
{	
	//While the neuron has enough potential to fire, we want to fire more
	while (potential >= THRESHOLD_POTENTIAL)
     5a0:	20 e0       	ldi	r18, 0x00	; 0
     5a2:	30 e0       	ldi	r19, 0x00	; 0
     5a4:	48 ec       	ldi	r20, 0xC8	; 200
     5a6:	51 e4       	ldi	r21, 0x41	; 65
     5a8:	c7 01       	movw	r24, r14
     5aa:	b6 01       	movw	r22, r12
     5ac:	0e 94 b7 0b 	call	0x176e	; 0x176e <__gesf2>
     5b0:	88 23       	and	r24, r24
     5b2:	4c f6       	brge	.-110    	; 0x546 <tinyAxon_update_potential+0x1c>
		
		tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
	}
	
	// If the neuron has a very low potential, we want to remove a pulse from the queue (if there is one)
	if(potential < REMOVE_PULSE_THRESHOLD) // REMOVE_PULSE_THRESHOLD is a negative number
     5b4:	20 e0       	ldi	r18, 0x00	; 0
     5b6:	30 e0       	ldi	r19, 0x00	; 0
     5b8:	40 ea       	ldi	r20, 0xA0	; 160
     5ba:	51 ec       	ldi	r21, 0xC1	; 193
     5bc:	c7 01       	movw	r24, r14
     5be:	b6 01       	movw	r22, r12
     5c0:	0e 94 df 09 	call	0x13be	; 0x13be <__cmpsf2>
     5c4:	88 23       	and	r24, r24
     5c6:	0c f0       	brlt	.+2      	; 0x5ca <tinyAxon_update_potential+0xa0>
     5c8:	46 c0       	rjmp	.+140    	; 0x656 <tinyAxon_update_potential+0x12c>
	{
		if(pulses_in_queue > 0)
     5ca:	80 91 2a 38 	lds	r24, 0x382A	; 0x80382a <pulses_in_queue>
     5ce:	88 23       	and	r24, r24
     5d0:	11 f1       	breq	.+68     	; 0x616 <tinyAxon_update_potential+0xec>
		{
			// The neurons potential is low enough to attempt to remove a queued fire (Fire less)
			if(tinyAxon_remove_pulse())
     5d2:	0e 94 73 02 	call	0x4e6	; 0x4e6 <tinyAxon_remove_pulse>
     5d6:	88 23       	and	r24, r24
     5d8:	f1 f1       	breq	.+124    	; 0x656 <tinyAxon_update_potential+0x12c>
			{
				// The potential has evened out a bit
				potential += THRESHOLD_POTENTIAL;
     5da:	20 e0       	ldi	r18, 0x00	; 0
     5dc:	30 e0       	ldi	r19, 0x00	; 0
     5de:	48 ec       	ldi	r20, 0xC8	; 200
     5e0:	51 e4       	ldi	r21, 0x41	; 65
     5e2:	c7 01       	movw	r24, r14
     5e4:	b6 01       	movw	r22, r12
     5e6:	0e 94 73 09 	call	0x12e6	; 0x12e6 <__addsf3>
     5ea:	6b 01       	movw	r12, r22
     5ec:	7c 01       	movw	r14, r24
     5ee:	33 c0       	rjmp	.+102    	; 0x656 <tinyAxon_update_potential+0x12c>
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
	{
		for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
		{
			if(pulse_queue[i] != 0){
     5f0:	80 81       	ld	r24, Z
     5f2:	91 81       	ldd	r25, Z+1	; 0x01
     5f4:	00 97       	sbiw	r24, 0x00	; 0
     5f6:	39 f0       	breq	.+14     	; 0x606 <tinyAxon_update_potential+0xdc>
				pulse_queue[i]--;
     5f8:	01 97       	sbiw	r24, 0x01	; 1
     5fa:	80 83       	st	Z, r24
     5fc:	91 83       	std	Z+1, r25	; 0x01
				
				// If the time went from 1 to 0, we fire the axon
				if(pulse_queue[i] == 0){
     5fe:	89 2b       	or	r24, r25
     600:	11 f4       	brne	.+4      	; 0x606 <tinyAxon_update_potential+0xdc>
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
	pulses_in_queue--;
     602:	41 50       	subi	r20, 0x01	; 1
Function to set firing.
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
     604:	51 e0       	ldi	r21, 0x01	; 1
     606:	32 96       	adiw	r30, 0x02	; 2
	}
	
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
	{
		for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
     608:	e2 17       	cp	r30, r18
     60a:	f3 07       	cpc	r31, r19
     60c:	89 f7       	brne	.-30     	; 0x5f0 <tinyAxon_update_potential+0xc6>
     60e:	50 93 2c 38 	sts	0x382C, r21	; 0x80382c <tinyAxon_should_fire>
     612:	40 93 2a 38 	sts	0x382A, r20	; 0x80382a <pulses_in_queue>
The function should set the DAC to fire for two
update cycles once the pulse flag is set high.
*/
static void tinyAxon_update_pulse_transmitter(void)
{
	if (tinyAxon_should_fire)
     616:	80 91 2c 38 	lds	r24, 0x382C	; 0x80382c <tinyAxon_should_fire>
     61a:	88 23       	and	r24, r24
     61c:	91 f0       	breq	.+36     	; 0x642 <tinyAxon_update_potential+0x118>
	{
		tinyAxon_should_fire = false;
     61e:	10 92 2c 38 	sts	0x382C, r1	; 0x80382c <tinyAxon_should_fire>
*/
static void tinyAxon_start_sending_pulse()
{
	if (NEURONTYPE == EXCITATORY_NEURON)
	{
		DAC_0_set_output(EXCITATORY_NEURON_OUTPUT);
     622:	8c ee       	ldi	r24, 0xEC	; 236
     624:	90 e0       	ldi	r25, 0x00	; 0
     626:	0e 94 20 01 	call	0x240	; 0x240 <DAC_0_set_output>
		axonOutputValue=EXCITATORY_NEURON_OUTPUT;
     62a:	8c ee       	ldi	r24, 0xEC	; 236
     62c:	80 93 2b 38 	sts	0x382B, r24	; 0x80382b <axonOutputValue>
	{
		DAC_0_set_output(INHIBITORY_NEURON_OUTPUT);
		axonOutputValue=INHIBITORY_NEURON_OUTPUT;
	}
	
	tinyLED_set_color_mode(OUT_LED, WHITE, FLASH_ONCE);
     630:	45 e0       	ldi	r20, 0x05	; 5
     632:	65 e0       	ldi	r22, 0x05	; 5
     634:	81 e0       	ldi	r24, 0x01	; 1
     636:	0e 94 af 05 	call	0xb5e	; 0xb5e <tinyLED_set_color_mode>
{
	if (tinyAxon_should_fire)
	{
		tinyAxon_should_fire = false;
		tinyAxon_start_sending_pulse();
		tinyAxon_has_just_fired = true;
     63a:	81 e0       	ldi	r24, 0x01	; 1
     63c:	80 93 2d 38 	sts	0x382D, r24	; 0x80382d <tinyAxon_has_just_fired>
     640:	15 c0       	rjmp	.+42     	; 0x66c <tinyAxon_update_potential+0x142>
		
	}
	else if (tinyAxon_has_just_fired)
     642:	80 91 2d 38 	lds	r24, 0x382D	; 0x80382d <tinyAxon_has_just_fired>
     646:	88 23       	and	r24, r24
     648:	19 f0       	breq	.+6      	; 0x650 <tinyAxon_update_potential+0x126>
	{
		tinyAxon_has_just_fired = false;
     64a:	10 92 2d 38 	sts	0x382D, r1	; 0x80382d <tinyAxon_has_just_fired>
     64e:	0e c0       	rjmp	.+28     	; 0x66c <tinyAxon_update_potential+0x142>
	}
	else if (!tinyAxon_has_just_fired && !tinyAxon_should_fire)
	{
		tinyAxon_stop_sending_pulse();
     650:	0e 94 6c 02 	call	0x4d8	; 0x4d8 <tinyAxon_stop_sending_pulse>
     654:	0b c0       	rjmp	.+22     	; 0x66c <tinyAxon_update_potential+0x142>
			}
		}
	}
	
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
     656:	40 91 2a 38 	lds	r20, 0x382A	; 0x80382a <pulses_in_queue>
     65a:	44 23       	and	r20, r20
     65c:	e1 f2       	breq	.-72     	; 0x616 <tinyAxon_update_potential+0xec>
     65e:	50 91 2c 38 	lds	r21, 0x382C	; 0x80382c <tinyAxon_should_fire>
     662:	e6 e1       	ldi	r30, 0x16	; 22
     664:	f8 e3       	ldi	r31, 0x38	; 56
     666:	2a e2       	ldi	r18, 0x2A	; 42
     668:	38 e3       	ldi	r19, 0x38	; 56
     66a:	c2 cf       	rjmp	.-124    	; 0x5f0 <tinyAxon_update_potential+0xc6>
	}
	
	// Here we set the actual output of the DAC (Digital to Analog Converter)
	tinyAxon_update_pulse_transmitter();
	
	tinyDebugger_send_uint8("Axon", axonOutputValue);
     66c:	60 91 2b 38 	lds	r22, 0x382B	; 0x80382b <axonOutputValue>
     670:	8d e5       	ldi	r24, 0x5D	; 93
     672:	9a e9       	ldi	r25, 0x9A	; 154
     674:	0e 94 3b 04 	call	0x876	; 0x876 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("Pulses", pulses_in_queue);
     678:	60 91 2a 38 	lds	r22, 0x382A	; 0x80382a <pulses_in_queue>
     67c:	82 e6       	ldi	r24, 0x62	; 98
     67e:	9a e9       	ldi	r25, 0x9A	; 154
     680:	0e 94 3b 04 	call	0x876	; 0x876 <tinyDebugger_send_uint8>
	
	
	return potential;
}
     684:	c7 01       	movw	r24, r14
     686:	b6 01       	movw	r22, r12
     688:	ff 90       	pop	r15
     68a:	ef 90       	pop	r14
     68c:	df 90       	pop	r13
     68e:	cf 90       	pop	r12
     690:	08 95       	ret

00000692 <tinyAxon_check_charge_level>:


_Bool tinyAxon_check_charge_level(void)
{
	// We check the AXON_CHECK_PIN. If it is hight while the axon is not firing, it must be connected to a charger
	return (AXON_CHECK_PIN_get_level() && !tinyAxon_has_just_fired);
     692:	37 9b       	sbis	0x06, 7	; 6
     694:	05 c0       	rjmp	.+10     	; 0x6a0 <tinyAxon_check_charge_level+0xe>
     696:	90 91 2d 38 	lds	r25, 0x382D	; 0x80382d <tinyAxon_has_just_fired>
     69a:	81 e0       	ldi	r24, 0x01	; 1
     69c:	89 27       	eor	r24, r25
     69e:	02 c0       	rjmp	.+4      	; 0x6a4 <tinyAxon_check_charge_level+0x12>
     6a0:	80 e0       	ldi	r24, 0x00	; 0
     6a2:	90 e0       	ldi	r25, 0x00	; 0
     6a4:	81 70       	andi	r24, 0x01	; 1
     6a6:	08 95       	ret

000006a8 <tinyButton_update>:
/*
If the button has been let go, we change button_press to true. This only lasts one cycle, before it is set to false again.
If the button is held down for longer than PULSEMODE_BUTTON_PRESS_TIME, we toggle the pulse mode state.
*/
void tinyButton_update(void)
{
     6a8:	0f 93       	push	r16
     6aa:	1f 93       	push	r17
     6ac:	cf 93       	push	r28
     6ae:	df 93       	push	r29
	button_press = false;
     6b0:	10 92 33 38 	sts	0x3833, r1	; 0x803833 <button_press>
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTC_get_pin_level(const uint8_t pin)
{
	return VPORTC.IN & (1 << pin);
     6b4:	8a b1       	in	r24, 0x0a	; 10
	_Bool button_is_pushed_down = !BUTTON_PIN_get_level(); // The digital port will be read as low if the button is pushed down.
     6b6:	d1 e0       	ldi	r29, 0x01	; 1
     6b8:	c8 2f       	mov	r28, r24
     6ba:	c4 70       	andi	r28, 0x04	; 4
     6bc:	82 fd       	sbrc	r24, 2
     6be:	d0 e0       	ldi	r29, 0x00	; 0

	if (button_is_pushed_down && !button_was_pushed_down)
     6c0:	c1 11       	cpse	r28, r1
     6c2:	36 c0       	rjmp	.+108    	; 0x730 <tinyButton_update+0x88>
     6c4:	80 91 34 38 	lds	r24, 0x3834	; 0x803834 <button_was_pushed_down>
     6c8:	81 11       	cpse	r24, r1
     6ca:	0e c0       	rjmp	.+28     	; 0x6e8 <tinyButton_update+0x40>
	{
		tinyButton_start_time = tinyTime_now();
     6cc:	0e 94 69 09 	call	0x12d2	; 0x12d2 <tinyTime_now>
     6d0:	60 93 2e 38 	sts	0x382E, r22	; 0x80382e <tinyButton_start_time>
     6d4:	70 93 2f 38 	sts	0x382F, r23	; 0x80382f <tinyButton_start_time+0x1>
     6d8:	80 93 30 38 	sts	0x3830, r24	; 0x803830 <tinyButton_start_time+0x2>
     6dc:	90 93 31 38 	sts	0x3831, r25	; 0x803831 <tinyButton_start_time+0x3>
	}
	if (button_is_pushed_down && button_was_pushed_down)
     6e0:	80 91 34 38 	lds	r24, 0x3834	; 0x803834 <button_was_pushed_down>
     6e4:	88 23       	and	r24, r24
     6e6:	a1 f1       	breq	.+104    	; 0x750 <tinyButton_update+0xa8>
	{
		if ((tinyTime_now() - tinyButton_start_time) > PULSEMODE_BUTTON_PRESS_TIME)
     6e8:	0e 94 69 09 	call	0x12d2	; 0x12d2 <tinyTime_now>
     6ec:	00 91 2e 38 	lds	r16, 0x382E	; 0x80382e <tinyButton_start_time>
     6f0:	10 91 2f 38 	lds	r17, 0x382F	; 0x80382f <tinyButton_start_time+0x1>
     6f4:	20 91 30 38 	lds	r18, 0x3830	; 0x803830 <tinyButton_start_time+0x2>
     6f8:	30 91 31 38 	lds	r19, 0x3831	; 0x803831 <tinyButton_start_time+0x3>
     6fc:	dc 01       	movw	r26, r24
     6fe:	cb 01       	movw	r24, r22
     700:	80 1b       	sub	r24, r16
     702:	91 0b       	sbc	r25, r17
     704:	a2 0b       	sbc	r26, r18
     706:	b3 0b       	sbc	r27, r19
     708:	81 3d       	cpi	r24, 0xD1	; 209
     70a:	97 40       	sbci	r25, 0x07	; 7
     70c:	a1 05       	cpc	r26, r1
     70e:	b1 05       	cpc	r27, r1
     710:	78 f0       	brcs	.+30     	; 0x730 <tinyButton_update+0x88>
		{
			tinyPulse_toggle_pulse_mode();
     712:	0e 94 e9 08 	call	0x11d2	; 0x11d2 <tinyPulse_toggle_pulse_mode>
			tinyButton_start_time = tinyTime_now();
     716:	0e 94 69 09 	call	0x12d2	; 0x12d2 <tinyTime_now>
     71a:	60 93 2e 38 	sts	0x382E, r22	; 0x80382e <tinyButton_start_time>
     71e:	70 93 2f 38 	sts	0x382F, r23	; 0x80382f <tinyButton_start_time+0x1>
     722:	80 93 30 38 	sts	0x3830, r24	; 0x803830 <tinyButton_start_time+0x2>
     726:	90 93 31 38 	sts	0x3831, r25	; 0x803831 <tinyButton_start_time+0x3>
			// We don't want switching to pulse mode to count as a button press, so we ignore the next button press
			ignore_next_button_press = true;
     72a:	81 e0       	ldi	r24, 0x01	; 1
     72c:	80 93 32 38 	sts	0x3832, r24	; 0x803832 <ignore_next_button_press>
		}
	}
	if (!button_is_pushed_down && button_was_pushed_down)
     730:	cc 23       	and	r28, r28
     732:	71 f0       	breq	.+28     	; 0x750 <tinyButton_update+0xa8>
     734:	80 91 34 38 	lds	r24, 0x3834	; 0x803834 <button_was_pushed_down>
     738:	88 23       	and	r24, r24
     73a:	51 f0       	breq	.+20     	; 0x750 <tinyButton_update+0xa8>
	{
		if(!ignore_next_button_press){
     73c:	80 91 32 38 	lds	r24, 0x3832	; 0x803832 <ignore_next_button_press>
     740:	81 11       	cpse	r24, r1
     742:	04 c0       	rjmp	.+8      	; 0x74c <tinyButton_update+0xa4>
			button_press = true;
     744:	81 e0       	ldi	r24, 0x01	; 1
     746:	80 93 33 38 	sts	0x3833, r24	; 0x803833 <button_press>
     74a:	02 c0       	rjmp	.+4      	; 0x750 <tinyButton_update+0xa8>
		}
		else{
			ignore_next_button_press = false;
     74c:	10 92 32 38 	sts	0x3832, r1	; 0x803832 <ignore_next_button_press>
		}
		
	}
	button_was_pushed_down = button_is_pushed_down;
     750:	d0 93 34 38 	sts	0x3834, r29	; 0x803834 <button_was_pushed_down>
}
     754:	df 91       	pop	r29
     756:	cf 91       	pop	r28
     758:	1f 91       	pop	r17
     75a:	0f 91       	pop	r16
     75c:	08 95       	ret

0000075e <tinyButton_update_potential>:

double tinyButton_update_potential(double potential){
	if(button_press){
     75e:	20 91 33 38 	lds	r18, 0x3833	; 0x803833 <button_press>
     762:	22 23       	and	r18, r18
     764:	31 f0       	breq	.+12     	; 0x772 <tinyButton_update_potential+0x14>
		potential += BUTTON_PRESS_REACTION;
     766:	20 e0       	ldi	r18, 0x00	; 0
     768:	30 e0       	ldi	r19, 0x00	; 0
     76a:	40 ed       	ldi	r20, 0xD0	; 208
     76c:	51 e4       	ldi	r21, 0x41	; 65
     76e:	0e 94 73 09 	call	0x12e6	; 0x12e6 <__addsf3>
	}
	return potential;
}
     772:	08 95       	ret

00000774 <tinyCharge_is_connected_to_charger>:
*/
uint8_t charge_counter = 0; 

_Bool tinyCharge_is_connected_to_charger(){
	return connected_to_charger;
}
     774:	80 91 5a 38 	lds	r24, 0x385A	; 0x80385a <connected_to_charger>
     778:	08 95       	ret

0000077a <tinyCharge_is_fully_charged>:
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTB_get_pin_level(const uint8_t pin)
{
	return VPORTB.IN & (1 << pin);
     77a:	86 b1       	in	r24, 0x06	; 6

_Bool tinyCharge_is_fully_charged(){
	return CHARGING_STATUS_PIN_get_level();
}
     77c:	86 fb       	bst	r24, 6
     77e:	88 27       	eor	r24, r24
     780:	80 f9       	bld	r24, 0
     782:	08 95       	ret

00000784 <tinyCharge_DAC_dissable>:
void tinyCharge_DAC_dissable(){
	
	// We need some way to disable the DAC to prevent huge current draw when charging (64mA). When there is no code uploaded to the attiny, there is no problem.
	// We're going to try to enable the pin as a dendrite, since they seem to be doing fine. Completely uninitializing the pin probably caused a microchip to be fried.
	
	DAC_0_uninit();
     784:	0e 94 0f 01 	call	0x21e	; 0x21e <DAC_0_uninit>
	DAC_0_disable();
     788:	0e 94 1a 01 	call	0x234	; 0x234 <DAC_0_disable>
     78c:	08 95       	ret

0000078e <tinyCharge_DAC_enable>:
void tinyCharge_DAC_enable(){
	
	// We need some way to disable the DAC to prevent huge current draw when charging (64mA). When there is no code uploaded to the attiny, there is no problem.
	// We're going to try to enable the pin as a dendrite, since they seem to be doing fine. Completely uninitializing the pin probably caused a microchip to be fried.
	
	DAC_0_init();
     78e:	0e 94 0a 01 	call	0x214	; 0x214 <DAC_0_init>
	DAC_0_enable();
     792:	0e 94 14 01 	call	0x228	; 0x228 <DAC_0_enable>
     796:	08 95       	ret

00000798 <tinyCharge_switch_mode>:
}


void tinyCharge_switch_mode(){
	
	if(connected_to_charger){
     798:	80 91 5a 38 	lds	r24, 0x385A	; 0x80385a <connected_to_charger>
     79c:	88 23       	and	r24, r24
     79e:	89 f0       	breq	.+34     	; 0x7c2 <tinyCharge_switch_mode+0x2a>
		// Switch from main to charging mode
		
		// Set LED
		tinyLED_set_color_mode(OUT_LED, CHARGING_COLOR, SWING);
     7a0:	43 e0       	ldi	r20, 0x03	; 3
     7a2:	61 e0       	ldi	r22, 0x01	; 1
     7a4:	81 e0       	ldi	r24, 0x01	; 1
     7a6:	0e 94 af 05 	call	0xb5e	; 0xb5e <tinyLED_set_color_mode>
		tinyLED_set_color(INN_LED, LED_OFF);
     7aa:	60 e0       	ldi	r22, 0x00	; 0
     7ac:	80 e0       	ldi	r24, 0x00	; 0
     7ae:	0e 94 e5 05 	call	0xbca	; 0xbca <tinyLED_set_color>


		// Stop axon from firing
		// (There is a small chance that the neuron is put into charging mode as it is firing. The axon is then never told to stop firing)
		tinyAxon_stop_sending_pulse();
     7b2:	0e 94 6c 02 	call	0x4d8	; 0x4d8 <tinyAxon_stop_sending_pulse>

		// disable DAC
		tinyCharge_DAC_dissable();
     7b6:	0e 94 c2 03 	call	0x784	; 0x784 <tinyCharge_DAC_dissable>
		
		// We also turn off pulse mode, because it's confusing if it suddenly comes on
		// after it has been charging
		tinyPulse_set_pulse_mode(false);
     7ba:	80 e0       	ldi	r24, 0x00	; 0
     7bc:	0e 94 05 09 	call	0x120a	; 0x120a <tinyPulse_set_pulse_mode>
     7c0:	08 95       	ret
	}
	else{
		// Switch from charge to main mode
		
		// Set LED
		tinyLED_set_color(OUT_LED, LED_OFF);
     7c2:	60 e0       	ldi	r22, 0x00	; 0
     7c4:	81 e0       	ldi	r24, 0x01	; 1
     7c6:	0e 94 e5 05 	call	0xbca	; 0xbca <tinyLED_set_color>
		tinyLED_set_color(INN_LED, LED_OFF);
     7ca:	60 e0       	ldi	r22, 0x00	; 0
     7cc:	80 e0       	ldi	r24, 0x00	; 0
     7ce:	0e 94 e5 05 	call	0xbca	; 0xbca <tinyLED_set_color>
		
		// enable DAC
		tinyCharge_DAC_enable();
     7d2:	0e 94 c7 03 	call	0x78e	; 0x78e <tinyCharge_DAC_enable>
     7d6:	08 95       	ret

000007d8 <tinyCharge_set_charging_mode>:
	}
}

void tinyCharge_set_charging_mode(_Bool charging_status){
	if(charging_status != connected_to_charger){
     7d8:	90 91 5a 38 	lds	r25, 0x385A	; 0x80385a <connected_to_charger>
     7dc:	98 17       	cp	r25, r24
     7de:	21 f0       	breq	.+8      	; 0x7e8 <tinyCharge_set_charging_mode+0x10>
		connected_to_charger = charging_status;
     7e0:	80 93 5a 38 	sts	0x385A, r24	; 0x80385a <connected_to_charger>
		tinyCharge_switch_mode();
     7e4:	0e 94 cc 03 	call	0x798	; 0x798 <tinyCharge_switch_mode>
     7e8:	08 95       	ret

000007ea <tinyCharge_update_charging_mode>:

/*
Checks if the levels of the dendrites and axon are at charging levels
and updates the mode accordingly
*/
void tinyCharge_update_charging_mode(){
     7ea:	cf 93       	push	r28
	// For complicated reasons, the axon_check_level will be high even when the charger is not connected
	// WHEN the neuron is in charging mode, hence we ignore the axon level when the neuron is in charging mode
	_Bool charging;
	if(connected_to_charger){
     7ec:	80 91 5a 38 	lds	r24, 0x385A	; 0x80385a <connected_to_charger>
     7f0:	88 23       	and	r24, r24
     7f2:	21 f0       	breq	.+8      	; 0x7fc <tinyCharge_update_charging_mode+0x12>
		charging = tinyDendrite_check_charge_level();
     7f4:	0e 94 5e 04 	call	0x8bc	; 0x8bc <tinyDendrite_check_charge_level>
     7f8:	c8 2f       	mov	r28, r24
     7fa:	0b c0       	rjmp	.+22     	; 0x812 <tinyCharge_update_charging_mode+0x28>
	} else{
		charging = tinyDendrite_check_charge_level() || tinyAxon_check_charge_level();
     7fc:	0e 94 5e 04 	call	0x8bc	; 0x8bc <tinyDendrite_check_charge_level>
     800:	81 11       	cpse	r24, r1
     802:	03 c0       	rjmp	.+6      	; 0x80a <tinyCharge_update_charging_mode+0x20>
     804:	0e 94 49 03 	call	0x692	; 0x692 <tinyAxon_check_charge_level>
     808:	02 c0       	rjmp	.+4      	; 0x80e <tinyCharge_update_charging_mode+0x24>
     80a:	81 e0       	ldi	r24, 0x01	; 1
     80c:	90 e0       	ldi	r25, 0x00	; 0
     80e:	c8 2f       	mov	r28, r24
     810:	c1 70       	andi	r28, 0x01	; 1
	}
	
	// In order to prevent the axon from stimulating itself, we only switch into charging mode when the conditions have been right for several cycles
	if(!connected_to_charger && charging){
     812:	80 91 5a 38 	lds	r24, 0x385A	; 0x80385a <connected_to_charger>
     816:	81 11       	cpse	r24, r1
     818:	0d c0       	rjmp	.+26     	; 0x834 <tinyCharge_update_charging_mode+0x4a>
     81a:	cc 23       	and	r28, r28
     81c:	d1 f0       	breq	.+52     	; 0x852 <tinyCharge_update_charging_mode+0x68>
		charge_counter++;
     81e:	80 91 35 38 	lds	r24, 0x3835	; 0x803835 <charge_counter>
     822:	8f 5f       	subi	r24, 0xFF	; 255
		if(charge_counter > CYCLES_REQUIRED_FOR_CHARGING_MODE_SWITCH){
     824:	8b 30       	cpi	r24, 0x0B	; 11
     826:	90 f0       	brcs	.+36     	; 0x84c <tinyCharge_update_charging_mode+0x62>
			charge_counter = 0;
     828:	10 92 35 38 	sts	0x3835, r1	; 0x803835 <charge_counter>
			tinyCharge_set_charging_mode(charging);
     82c:	81 e0       	ldi	r24, 0x01	; 1
     82e:	0e 94 ec 03 	call	0x7d8	; 0x7d8 <tinyCharge_set_charging_mode>
     832:	13 c0       	rjmp	.+38     	; 0x85a <tinyCharge_update_charging_mode+0x70>
		}
	}
	else{
		tinyCharge_set_charging_mode(charging);
     834:	8c 2f       	mov	r24, r28
     836:	0e 94 ec 03 	call	0x7d8	; 0x7d8 <tinyCharge_set_charging_mode>
	}
	
	// We have to prevent charge_counters from accumulating over time
	if(!charging && charge_counter>0){
     83a:	c1 11       	cpse	r28, r1
     83c:	0e c0       	rjmp	.+28     	; 0x85a <tinyCharge_update_charging_mode+0x70>
     83e:	80 91 35 38 	lds	r24, 0x3835	; 0x803835 <charge_counter>
     842:	88 23       	and	r24, r24
     844:	51 f0       	breq	.+20     	; 0x85a <tinyCharge_update_charging_mode+0x70>
		charge_counter = 0;
     846:	10 92 35 38 	sts	0x3835, r1	; 0x803835 <charge_counter>
	}
	
}
     84a:	07 c0       	rjmp	.+14     	; 0x85a <tinyCharge_update_charging_mode+0x70>
		charging = tinyDendrite_check_charge_level() || tinyAxon_check_charge_level();
	}
	
	// In order to prevent the axon from stimulating itself, we only switch into charging mode when the conditions have been right for several cycles
	if(!connected_to_charger && charging){
		charge_counter++;
     84c:	80 93 35 38 	sts	0x3835, r24	; 0x803835 <charge_counter>
     850:	04 c0       	rjmp	.+8      	; 0x85a <tinyCharge_update_charging_mode+0x70>
			charge_counter = 0;
			tinyCharge_set_charging_mode(charging);
		}
	}
	else{
		tinyCharge_set_charging_mode(charging);
     852:	8c 2f       	mov	r24, r28
     854:	0e 94 ec 03 	call	0x7d8	; 0x7d8 <tinyCharge_set_charging_mode>
     858:	f2 cf       	rjmp	.-28     	; 0x83e <tinyCharge_update_charging_mode+0x54>
	// We have to prevent charge_counters from accumulating over time
	if(!charging && charge_counter>0){
		charge_counter = 0;
	}
	
}
     85a:	cf 91       	pop	r28
     85c:	08 95       	ret

0000085e <tinyCharge_set_transistors>:



void tinyCharge_set_transistors(){
	if(connected_to_charger){
     85e:	80 91 5a 38 	lds	r24, 0x385A	; 0x80385a <connected_to_charger>
     862:	88 23       	and	r24, r24
     864:	19 f0       	breq	.+6      	; 0x86c <tinyCharge_set_transistors+0xe>
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
	} else {
		VPORTC.OUT &= ~(1 << pin);
     866:	4d 98       	cbi	0x09, 5	; 9
 *                  false = Pin level set to "low" state
 */
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
     868:	29 9a       	sbi	0x05, 1	; 5
     86a:	08 95       	ret
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     86c:	4d 9a       	sbi	0x09, 5	; 9
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     86e:	29 98       	cbi	0x05, 1	; 5
     870:	08 95       	ret

00000872 <tinyDebugger_send_int>:
		char number[20]; // Arbitrary max
		dtostrf(value,1,NUMBER_OF_DECIMALS, number);
		printf("%s:%5s\t", name, number);
	}
}
void tinyDebugger_send_string(const char* name, char * value){
     872:	08 95       	ret

00000874 <tinyDebugger_send_uint32>:
     874:	08 95       	ret

00000876 <tinyDebugger_send_uint8>:
     876:	08 95       	ret

00000878 <tinyDebugger_send_double>:
     878:	08 95       	ret

0000087a <tinyDebugger_end_line>:
	if(DEBUGGING){
		printf("%s:%s\t", name, value);
	}
}
void tinyDebugger_end_line(){
     87a:	08 95       	ret

0000087c <tinyDendrite_read_signals>:
	}
}

uint8_t tinyDendrite_get_value(uint8_t dendrite_number){
	return tinyDendrite_values[dendrite_number];
}
     87c:	ef 92       	push	r14
     87e:	ff 92       	push	r15
     880:	0f 93       	push	r16
     882:	1f 93       	push	r17
     884:	cf 93       	push	r28
     886:	df 93       	push	r29
     888:	ce e0       	ldi	r28, 0x0E	; 14
     88a:	d8 e3       	ldi	r29, 0x38	; 56
     88c:	00 e4       	ldi	r16, 0x40	; 64
     88e:	18 e3       	ldi	r17, 0x38	; 56
     890:	0f 2e       	mov	r0, r31
     892:	f3 e1       	ldi	r31, 0x13	; 19
     894:	ef 2e       	mov	r14, r31
     896:	f8 e3       	ldi	r31, 0x38	; 56
     898:	ff 2e       	mov	r15, r31
     89a:	f0 2d       	mov	r31, r0
     89c:	89 91       	ld	r24, Y+
     89e:	0e 94 d4 00 	call	0x1a8	; 0x1a8 <ADC_0_get_conversion>
     8a2:	f8 01       	movw	r30, r16
     8a4:	81 93       	st	Z+, r24
     8a6:	8f 01       	movw	r16, r30
     8a8:	ce 15       	cp	r28, r14
     8aa:	df 05       	cpc	r29, r15
     8ac:	b9 f7       	brne	.-18     	; 0x89c <tinyDendrite_read_signals+0x20>
     8ae:	df 91       	pop	r29
     8b0:	cf 91       	pop	r28
     8b2:	1f 91       	pop	r17
     8b4:	0f 91       	pop	r16
     8b6:	ff 90       	pop	r15
     8b8:	ef 90       	pop	r14
     8ba:	08 95       	ret

000008bc <tinyDendrite_check_charge_level>:

_Bool tinyDendrite_check_charge_level(void)
{
     8bc:	cf 93       	push	r28
     8be:	df 93       	push	r29
	_Bool charging = false;
	
	tinyDendrite_read_signals();
     8c0:	0e 94 3e 04 	call	0x87c	; 0x87c <tinyDendrite_read_signals>
     8c4:	eb e3       	ldi	r30, 0x3B	; 59
     8c6:	f8 e3       	ldi	r31, 0x38	; 56
     8c8:	c6 e3       	ldi	r28, 0x36	; 54
     8ca:	d8 e3       	ldi	r29, 0x38	; 56
     8cc:	a0 e4       	ldi	r26, 0x40	; 64
     8ce:	b8 e3       	ldi	r27, 0x38	; 56
     8d0:	20 e4       	ldi	r18, 0x40	; 64
     8d2:	38 e3       	ldi	r19, 0x38	; 56
	return tinyDendrite_values[dendrite_number];
}

_Bool tinyDendrite_check_charge_level(void)
{
	_Bool charging = false;
     8d4:	80 e0       	ldi	r24, 0x00	; 0
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = CHARGING;
     8d6:	47 e0       	ldi	r20, 0x07	; 7
	_Bool charging = false;
	
	tinyDendrite_read_signals();
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
     8d8:	90 81       	ld	r25, Z
     8da:	99 93       	st	Y+, r25
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
     8dc:	9d 91       	ld	r25, X+
     8de:	9f 3f       	cpi	r25, 0xFF	; 255
     8e0:	11 f4       	brne	.+4      	; 0x8e6 <tinyDendrite_check_charge_level+0x2a>
		{
			tinyDendrite_current_signals[i] = CHARGING;
     8e2:	40 83       	st	Z, r20
			charging = true;
     8e4:	81 e0       	ldi	r24, 0x01	; 1
     8e6:	31 96       	adiw	r30, 0x01	; 1
_Bool tinyDendrite_check_charge_level(void)
{
	_Bool charging = false;
	
	tinyDendrite_read_signals();
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
     8e8:	e2 17       	cp	r30, r18
     8ea:	f3 07       	cpc	r31, r19
     8ec:	a9 f7       	brne	.-22     	; 0x8d8 <tinyDendrite_check_charge_level+0x1c>
			tinyDendrite_current_signals[i] = CHARGING;
			charging = true;
		}
	}
	return charging;
}
     8ee:	df 91       	pop	r29
     8f0:	cf 91       	pop	r28
     8f2:	08 95       	ret

000008f4 <tinyDendrite_update_signals>:

/*
This function converts the 8 bit value from the ADC into one of the signal types defined in DendriteSignal
*/
void tinyDendrite_update_signals(void)
{
     8f4:	af 92       	push	r10
     8f6:	bf 92       	push	r11
     8f8:	df 92       	push	r13
     8fa:	ef 92       	push	r14
     8fc:	ff 92       	push	r15
     8fe:	0f 93       	push	r16
     900:	1f 93       	push	r17
     902:	cf 93       	push	r28
     904:	df 93       	push	r29
	
	// This function does not read the dendrite values! Read_signals must be called somewhere prior to this function!
	// As of writing this, the update_charging_mode function in main runs check_charge_level, so 
	// the tinyDendrite_values are updated when update_signals is called later
	
	tinyDebugger_send_uint8("D1", tinyDendrite_values[0]);
     906:	c0 e4       	ldi	r28, 0x40	; 64
     908:	d8 e3       	ldi	r29, 0x38	; 56
     90a:	68 81       	ld	r22, Y
     90c:	89 e6       	ldi	r24, 0x69	; 105
     90e:	9a e9       	ldi	r25, 0x9A	; 154
     910:	0e 94 3b 04 	call	0x876	; 0x876 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D2", tinyDendrite_values[1]);
     914:	69 81       	ldd	r22, Y+1	; 0x01
     916:	8c e6       	ldi	r24, 0x6C	; 108
     918:	9a e9       	ldi	r25, 0x9A	; 154
     91a:	0e 94 3b 04 	call	0x876	; 0x876 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D3", tinyDendrite_values[2]);
     91e:	6a 81       	ldd	r22, Y+2	; 0x02
     920:	8f e6       	ldi	r24, 0x6F	; 111
     922:	9a e9       	ldi	r25, 0x9A	; 154
     924:	0e 94 3b 04 	call	0x876	; 0x876 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D4", tinyDendrite_values[3]);
     928:	6b 81       	ldd	r22, Y+3	; 0x03
     92a:	82 e7       	ldi	r24, 0x72	; 114
     92c:	9a e9       	ldi	r25, 0x9A	; 154
     92e:	0e 94 3b 04 	call	0x876	; 0x876 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D5", tinyDendrite_values[4]);
     932:	6c 81       	ldd	r22, Y+4	; 0x04
     934:	85 e7       	ldi	r24, 0x75	; 117
     936:	9a e9       	ldi	r25, 0x9A	; 154
     938:	0e 94 3b 04 	call	0x876	; 0x876 <tinyDebugger_send_uint8>
     93c:	eb e3       	ldi	r30, 0x3B	; 59
     93e:	f8 e3       	ldi	r31, 0x38	; 56
     940:	26 e3       	ldi	r18, 0x36	; 54
     942:	38 e3       	ldi	r19, 0x38	; 56
     944:	5e 01       	movw	r10, r28
     946:	40 e4       	ldi	r20, 0x40	; 64
     948:	58 e3       	ldi	r21, 0x38	; 56
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     94a:	dd 24       	eor	r13, r13
     94c:	d3 94       	inc	r13
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
		}
		else if (tinyDendrite_values[i] > HIGH_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
     94e:	0f 2e       	mov	r0, r31
     950:	f3 e0       	ldi	r31, 0x03	; 3
     952:	ef 2e       	mov	r14, r31
     954:	f0 2d       	mov	r31, r0
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     956:	68 94       	set
     958:	ff 24       	eor	r15, r15
     95a:	f1 f8       	bld	r15, 1
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     95c:	04 e0       	ldi	r16, 0x04	; 4
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     95e:	16 e0       	ldi	r17, 0x06	; 6
			// been moved to tinyDendrite_check_charging.
			//charging = true;
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     960:	65 e0       	ldi	r22, 0x05	; 5
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = CHARGING;
     962:	77 e0       	ldi	r23, 0x07	; 7
     964:	df 01       	movw	r26, r30
	tinyDebugger_send_uint8("D4", tinyDendrite_values[3]);
	tinyDebugger_send_uint8("D5", tinyDendrite_values[4]);
	
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
     966:	90 81       	ld	r25, Z
     968:	e9 01       	movw	r28, r18
     96a:	99 93       	st	Y+, r25
     96c:	9e 01       	movw	r18, r28
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
     96e:	e5 01       	movw	r28, r10
     970:	89 91       	ld	r24, Y+
     972:	5e 01       	movw	r10, r28
     974:	8f 3f       	cpi	r24, 0xFF	; 255
     976:	11 f4       	brne	.+4      	; 0x97c <tinyDendrite_update_signals+0x88>
		{
			tinyDendrite_current_signals[i] = CHARGING;
     978:	70 83       	st	Z, r23
     97a:	19 c0       	rjmp	.+50     	; 0x9ae <tinyDendrite_update_signals+0xba>
			// Previously, we used this function to check charging, but this has now
			// been moved to tinyDendrite_check_charging.
			//charging = true;
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
     97c:	8b 3d       	cpi	r24, 0xDB	; 219
     97e:	10 f0       	brcs	.+4      	; 0x984 <tinyDendrite_update_signals+0x90>
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     980:	60 83       	st	Z, r22
     982:	15 c0       	rjmp	.+42     	; 0x9ae <tinyDendrite_update_signals+0xba>
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
     984:	86 3b       	cpi	r24, 0xB6	; 182
     986:	10 f0       	brcs	.+4      	; 0x98c <tinyDendrite_update_signals+0x98>
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     988:	10 83       	st	Z, r17
     98a:	11 c0       	rjmp	.+34     	; 0x9ae <tinyDendrite_update_signals+0xba>
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
     98c:	82 39       	cpi	r24, 0x92	; 146
     98e:	10 f0       	brcs	.+4      	; 0x994 <tinyDendrite_update_signals+0xa0>
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     990:	00 83       	st	Z, r16
     992:	0d c0       	rjmp	.+26     	; 0x9ae <tinyDendrite_update_signals+0xba>
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
     994:	8e 36       	cpi	r24, 0x6E	; 110
     996:	10 f0       	brcs	.+4      	; 0x99c <tinyDendrite_update_signals+0xa8>
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     998:	f0 82       	st	Z, r15
     99a:	09 c0       	rjmp	.+18     	; 0x9ae <tinyDendrite_update_signals+0xba>
		}
		else if (tinyDendrite_values[i] > HIGH_INHIB_THRESHOLD)
     99c:	8a 34       	cpi	r24, 0x4A	; 74
     99e:	10 f0       	brcs	.+4      	; 0x9a4 <tinyDendrite_update_signals+0xb0>
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
     9a0:	e0 82       	st	Z, r14
     9a2:	05 c0       	rjmp	.+10     	; 0x9ae <tinyDendrite_update_signals+0xba>
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
     9a4:	85 32       	cpi	r24, 0x25	; 37
     9a6:	10 f0       	brcs	.+4      	; 0x9ac <tinyDendrite_update_signals+0xb8>
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     9a8:	d0 82       	st	Z, r13
     9aa:	01 c0       	rjmp	.+2      	; 0x9ae <tinyDendrite_update_signals+0xba>
		}
		else
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     9ac:	10 82       	st	Z, r1
		}
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
     9ae:	8c 91       	ld	r24, X
     9b0:	98 13       	cpse	r25, r24
     9b2:	01 c0       	rjmp	.+2      	; 0x9b6 <tinyDendrite_update_signals+0xc2>
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     9b4:	1c 92       	st	X, r1
     9b6:	31 96       	adiw	r30, 0x01	; 1
	tinyDebugger_send_uint8("D2", tinyDendrite_values[1]);
	tinyDebugger_send_uint8("D3", tinyDendrite_values[2]);
	tinyDebugger_send_uint8("D4", tinyDendrite_values[3]);
	tinyDebugger_send_uint8("D5", tinyDendrite_values[4]);
	
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
     9b8:	e4 17       	cp	r30, r20
     9ba:	f5 07       	cpc	r31, r21
     9bc:	99 f6       	brne	.-90     	; 0x964 <tinyDendrite_update_signals+0x70>
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
		}
	}
}
     9be:	df 91       	pop	r29
     9c0:	cf 91       	pop	r28
     9c2:	1f 91       	pop	r17
     9c4:	0f 91       	pop	r16
     9c6:	ff 90       	pop	r15
     9c8:	ef 90       	pop	r14
     9ca:	df 90       	pop	r13
     9cc:	bf 90       	pop	r11
     9ce:	af 90       	pop	r10
     9d0:	08 95       	ret

000009d2 <tinyDendrite_get_potential>:
/*
This is the master function of the module that is callable from
outside. It uses the previously declared functions to return the potential.
*/
int16_t tinyDendrite_get_potential()
{
     9d2:	ef 92       	push	r14
     9d4:	ff 92       	push	r15
     9d6:	0f 93       	push	r16
     9d8:	1f 93       	push	r17
     9da:	cf 93       	push	r28
     9dc:	df 93       	push	r29
	if(tinyAxon_is_firing() && IGNORE_INPUT_WHILE_FIRING){
     9de:	0e 94 52 02 	call	0x4a4	; 0x4a4 <tinyAxon_is_firing>
		
		return NO_SIGNAL_REACTION;
	}
	
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
     9e2:	0e 94 7a 04 	call	0x8f4	; 0x8f4 <tinyDendrite_update_signals>
     9e6:	cb e3       	ldi	r28, 0x3B	; 59
     9e8:	d8 e3       	ldi	r29, 0x38	; 56
     9ea:	0f 2e       	mov	r0, r31
     9ec:	f0 e4       	ldi	r31, 0x40	; 64
     9ee:	ef 2e       	mov	r14, r31
     9f0:	f8 e3       	ldi	r31, 0x38	; 56
     9f2:	ff 2e       	mov	r15, r31
     9f4:	f0 2d       	mov	r31, r0
	
	int16_t return_potential_val = 0;
     9f6:	00 e0       	ldi	r16, 0x00	; 0
     9f8:	10 e0       	ldi	r17, 0x00	; 0
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		switch(tinyDendrite_current_signals[i])
     9fa:	89 91       	ld	r24, Y+
     9fc:	83 30       	cpi	r24, 0x03	; 3
     9fe:	19 f1       	breq	.+70     	; 0xa46 <tinyDendrite_get_potential+0x74>
     a00:	28 f4       	brcc	.+10     	; 0xa0c <tinyDendrite_get_potential+0x3a>
     a02:	81 30       	cpi	r24, 0x01	; 1
     a04:	81 f1       	breq	.+96     	; 0xa66 <tinyDendrite_get_potential+0x94>
     a06:	82 30       	cpi	r24, 0x02	; 2
     a08:	31 f1       	breq	.+76     	; 0xa56 <tinyDendrite_get_potential+0x84>
     a0a:	34 c0       	rjmp	.+104    	; 0xa74 <tinyDendrite_get_potential+0xa2>
     a0c:	85 30       	cpi	r24, 0x05	; 5
     a0e:	59 f0       	breq	.+22     	; 0xa26 <tinyDendrite_get_potential+0x54>
     a10:	90 f0       	brcs	.+36     	; 0xa36 <tinyDendrite_get_potential+0x64>
     a12:	86 30       	cpi	r24, 0x06	; 6
     a14:	79 f5       	brne	.+94     	; 0xa74 <tinyDendrite_get_potential+0xa2>
		{
			case NO_SIGNAL:
				return_potential_val += NO_SIGNAL_REACTION;
				break;
			case HIGH_EXCITE:
				return_potential_val += HIGH_EXCITE_REACTION;
     a16:	0c 5c       	subi	r16, 0xCC	; 204
     a18:	1f 4f       	sbci	r17, 0xFF	; 255
				tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
     a1a:	45 e0       	ldi	r20, 0x05	; 5
     a1c:	63 e0       	ldi	r22, 0x03	; 3
     a1e:	80 e0       	ldi	r24, 0x00	; 0
     a20:	0e 94 af 05 	call	0xb5e	; 0xb5e <tinyLED_set_color_mode>
				break;
     a24:	27 c0       	rjmp	.+78     	; 0xa74 <tinyDendrite_get_potential+0xa2>
			case NORMAL_EXCITE:
				return_potential_val += NORMAL_EXCITE_REACTION;
     a26:	07 5e       	subi	r16, 0xE7	; 231
     a28:	1f 4f       	sbci	r17, 0xFF	; 255
				tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
     a2a:	45 e0       	ldi	r20, 0x05	; 5
     a2c:	63 e0       	ldi	r22, 0x03	; 3
     a2e:	80 e0       	ldi	r24, 0x00	; 0
     a30:	0e 94 af 05 	call	0xb5e	; 0xb5e <tinyLED_set_color_mode>
				break;
     a34:	1f c0       	rjmp	.+62     	; 0xa74 <tinyDendrite_get_potential+0xa2>
			case LOW_EXCITE:
				return_potential_val += LOW_EXCITE_REACTION;
     a36:	0c 5e       	subi	r16, 0xEC	; 236
     a38:	1f 4f       	sbci	r17, 0xFF	; 255
				tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
     a3a:	45 e0       	ldi	r20, 0x05	; 5
     a3c:	63 e0       	ldi	r22, 0x03	; 3
     a3e:	80 e0       	ldi	r24, 0x00	; 0
     a40:	0e 94 af 05 	call	0xb5e	; 0xb5e <tinyLED_set_color_mode>
				break;
     a44:	17 c0       	rjmp	.+46     	; 0xa74 <tinyDendrite_get_potential+0xa2>
			case HIGH_INHIB:
				return_potential_val += HIGH_INHIB_REACTION;
     a46:	02 53       	subi	r16, 0x32	; 50
     a48:	11 09       	sbc	r17, r1
				tinyLED_set_color_mode(INN_LED, RED, FLASH_ONCE);
     a4a:	45 e0       	ldi	r20, 0x05	; 5
     a4c:	61 e0       	ldi	r22, 0x01	; 1
     a4e:	80 e0       	ldi	r24, 0x00	; 0
     a50:	0e 94 af 05 	call	0xb5e	; 0xb5e <tinyLED_set_color_mode>
				break;
     a54:	0f c0       	rjmp	.+30     	; 0xa74 <tinyDendrite_get_potential+0xa2>
			case NORMAL_INHIB:
				return_potential_val += NORMAL_INHIB_REACTION;
     a56:	09 51       	subi	r16, 0x19	; 25
     a58:	11 09       	sbc	r17, r1
				tinyLED_set_color_mode(INN_LED, RED, FLASH_ONCE);
     a5a:	45 e0       	ldi	r20, 0x05	; 5
     a5c:	61 e0       	ldi	r22, 0x01	; 1
     a5e:	80 e0       	ldi	r24, 0x00	; 0
     a60:	0e 94 af 05 	call	0xb5e	; 0xb5e <tinyLED_set_color_mode>
				break;
     a64:	07 c0       	rjmp	.+14     	; 0xa74 <tinyDendrite_get_potential+0xa2>
			case LOW_INHIB:
				return_potential_val += LOW_INHIB_REACTION;
     a66:	04 51       	subi	r16, 0x14	; 20
     a68:	11 09       	sbc	r17, r1
				tinyLED_set_color_mode(INN_LED, RED, FLASH_ONCE);
     a6a:	45 e0       	ldi	r20, 0x05	; 5
     a6c:	61 e0       	ldi	r22, 0x01	; 1
     a6e:	80 e0       	ldi	r24, 0x00	; 0
     a70:	0e 94 af 05 	call	0xb5e	; 0xb5e <tinyLED_set_color_mode>
	
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
	
	int16_t return_potential_val = 0;
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
     a74:	ce 15       	cp	r28, r14
     a76:	df 05       	cpc	r29, r15
     a78:	09 f0       	breq	.+2      	; 0xa7c <tinyDendrite_get_potential+0xaa>
     a7a:	bf cf       	rjmp	.-130    	; 0x9fa <tinyDendrite_get_potential+0x28>
			default:
				break;
		}
	}
	
	tinyDebugger_send_int("ReturnP", return_potential_val);
     a7c:	b8 01       	movw	r22, r16
     a7e:	88 e7       	ldi	r24, 0x78	; 120
     a80:	9a e9       	ldi	r25, 0x9A	; 154
     a82:	0e 94 39 04 	call	0x872	; 0x872 <tinyDebugger_send_int>
	
	
	return return_potential_val;
	
}
     a86:	c8 01       	movw	r24, r16
     a88:	df 91       	pop	r29
     a8a:	cf 91       	pop	r28
     a8c:	1f 91       	pop	r17
     a8e:	0f 91       	pop	r16
     a90:	ff 90       	pop	r15
     a92:	ef 90       	pop	r14
     a94:	08 95       	ret

00000a96 <tinyDendrite_update_potential>:

double tinyDendrite_update_potential(double potential){
     a96:	cf 92       	push	r12
     a98:	df 92       	push	r13
     a9a:	ef 92       	push	r14
     a9c:	ff 92       	push	r15
     a9e:	6b 01       	movw	r12, r22
     aa0:	7c 01       	movw	r14, r24
	
	int16_t potential_change = tinyDendrite_get_potential();
     aa2:	0e 94 e9 04 	call	0x9d2	; 0x9d2 <tinyDendrite_get_potential>
	potential += potential_change;
	return potential;
     aa6:	bc 01       	movw	r22, r24
     aa8:	99 0f       	add	r25, r25
     aaa:	88 0b       	sbc	r24, r24
     aac:	99 0b       	sbc	r25, r25
     aae:	0e 94 c1 0a 	call	0x1582	; 0x1582 <__floatsisf>
     ab2:	a7 01       	movw	r20, r14
     ab4:	96 01       	movw	r18, r12
     ab6:	0e 94 73 09 	call	0x12e6	; 0x12e6 <__addsf3>
     aba:	ff 90       	pop	r15
     abc:	ef 90       	pop	r14
     abe:	df 90       	pop	r13
     ac0:	cf 90       	pop	r12
     ac2:	08 95       	ret

00000ac4 <__vector_6>:
This function is called every time the RTC (Real Time Clock) counter overflows.
With the current settings, it will be called every ms.
The RTC clock runs at 1kHz, and the number of cycles before overflow is set with RTC.PER = someHexValue (e.g. 0x20) in src/rtc.c
*/
ISR(RTC_CNT_vect)
{
     ac4:	1f 92       	push	r1
     ac6:	0f 92       	push	r0
     ac8:	0f b6       	in	r0, 0x3f	; 63
     aca:	0f 92       	push	r0
     acc:	11 24       	eor	r1, r1
     ace:	2f 93       	push	r18
     ad0:	3f 93       	push	r19
     ad2:	4f 93       	push	r20
     ad4:	5f 93       	push	r21
     ad6:	6f 93       	push	r22
     ad8:	7f 93       	push	r23
     ada:	8f 93       	push	r24
     adc:	9f 93       	push	r25
     ade:	af 93       	push	r26
     ae0:	bf 93       	push	r27
     ae2:	cf 93       	push	r28
     ae4:	ef 93       	push	r30
     ae6:	ff 93       	push	r31
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     ae8:	c1 e0       	ldi	r28, 0x01	; 1
     aea:	c0 93 45 38 	sts	0x3845, r28	; 0x803845 <tinyISR_interrupt_flag>
{
	// Set flag to let main loop run a new cycle
	tinyISR_setflag(true);
	
	// Timer counter incrementation
	tinyTime_counter_increment();
     aee:	0e 94 55 09 	call	0x12aa	; 0x12aa <tinyTime_counter_increment>

	/* Overflow interrupt flag has to be cleared manually */
	RTC.INTFLAGS = RTC_OVF_bm;
     af2:	c0 93 43 01 	sts	0x0143, r28	; 0x800143 <__TEXT_REGION_LENGTH__+0x700143>
}
     af6:	ff 91       	pop	r31
     af8:	ef 91       	pop	r30
     afa:	cf 91       	pop	r28
     afc:	bf 91       	pop	r27
     afe:	af 91       	pop	r26
     b00:	9f 91       	pop	r25
     b02:	8f 91       	pop	r24
     b04:	7f 91       	pop	r23
     b06:	6f 91       	pop	r22
     b08:	5f 91       	pop	r21
     b0a:	4f 91       	pop	r20
     b0c:	3f 91       	pop	r19
     b0e:	2f 91       	pop	r18
     b10:	0f 90       	pop	r0
     b12:	0f be       	out	0x3f, r0	; 63
     b14:	0f 90       	pop	r0
     b16:	1f 90       	pop	r1
     b18:	18 95       	reti

00000b1a <tinyISR_setflag>:
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     b1a:	80 93 45 38 	sts	0x3845, r24	; 0x803845 <tinyISR_interrupt_flag>
     b1e:	08 95       	ret

00000b20 <tinyISR_getflag>:
}

_Bool tinyISR_getflag(void)
{
	return tinyISR_interrupt_flag;
}
     b20:	80 91 45 38 	lds	r24, 0x3845	; 0x803845 <tinyISR_interrupt_flag>
     b24:	08 95       	ret

00000b26 <tinyLED_SPIWriteByte>:
{
	// We ignore a request to queue a flash if the queue is full
	if(flashes_in_queue < 16){
		flash_queue[flashes_in_queue] = color;
		flash_queue_ids[flashes_in_queue] = LED_id;
		flashes_in_queue++;
     b26:	90 91 23 08 	lds	r25, 0x0823	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
     b2a:	90 93 23 08 	sts	0x0823, r25	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
     b2e:	e0 e0       	ldi	r30, 0x00	; 0
     b30:	fa e0       	ldi	r31, 0x0A	; 10
     b32:	10 a2       	std	Z+32, r1	; 0x20
     b34:	11 a2       	std	Z+33, r1	; 0x21
     b36:	91 e0       	ldi	r25, 0x01	; 1
     b38:	90 83       	st	Z, r25
     b3a:	80 93 24 08 	sts	0x0824, r24	; 0x800824 <__TEXT_REGION_LENGTH__+0x700824>
     b3e:	e0 e2       	ldi	r30, 0x20	; 32
     b40:	f8 e0       	ldi	r31, 0x08	; 8
     b42:	83 81       	ldd	r24, Z+3	; 0x03
     b44:	88 23       	and	r24, r24
     b46:	ec f7       	brge	.-6      	; 0xb42 <tinyLED_SPIWriteByte+0x1c>
     b48:	10 92 00 0a 	sts	0x0A00, r1	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
     b4c:	08 95       	ret

00000b4e <tinyLED_get_color>:
	tinyLED_set_color_mode(LED_id, color, STABLE);
}

enum Colors tinyLED_get_color(uint8_t LED_id)
{
	return tinyLED_settings[LED_id].color;
     b4e:	e8 2f       	mov	r30, r24
     b50:	f0 e0       	ldi	r31, 0x00	; 0
     b52:	ee 0f       	add	r30, r30
     b54:	ff 1f       	adc	r31, r31
     b56:	eb 58       	subi	r30, 0x8B	; 139
     b58:	f7 4c       	sbci	r31, 0xC7	; 199
}
     b5a:	80 81       	ld	r24, Z
     b5c:	08 95       	ret

00000b5e <tinyLED_set_color_mode>:
{
	// If we are in pulse mode, we want to stay in pulse mode after we have flashed a light.
	// We do this by storing the previous mode in old settings.
	// However, it can happen that two flashes comes very quickly after one another, that leads
	// to an infinite flash loop, therefore, we only store the settings if it is not flash mode.
	if(tinyLED_settings[LED_id].mode != FLASH_ONCE){
     b5e:	90 e0       	ldi	r25, 0x00	; 0
     b60:	fc 01       	movw	r30, r24
     b62:	ee 0f       	add	r30, r30
     b64:	ff 1f       	adc	r31, r31
     b66:	eb 58       	subi	r30, 0x8B	; 139
     b68:	f7 4c       	sbci	r31, 0xC7	; 199
     b6a:	51 81       	ldd	r21, Z+1	; 0x01
     b6c:	55 30       	cpi	r21, 0x05	; 5
     b6e:	61 f0       	breq	.+24     	; 0xb88 <tinyLED_set_color_mode+0x2a>
		// We use two lines to avoid pointer trouble. (I'm not good with pointers)
		tinyLED_old_settings[LED_id].color = tinyLED_settings[LED_id].color;
     b70:	9c 01       	movw	r18, r24
     b72:	22 0f       	add	r18, r18
     b74:	33 1f       	adc	r19, r19
     b76:	f9 01       	movw	r30, r18
     b78:	e7 58       	subi	r30, 0x87	; 135
     b7a:	f7 4c       	sbci	r31, 0xC7	; 199
     b7c:	d9 01       	movw	r26, r18
     b7e:	ab 58       	subi	r26, 0x8B	; 139
     b80:	b7 4c       	sbci	r27, 0xC7	; 199
     b82:	2c 91       	ld	r18, X
     b84:	20 83       	st	Z, r18
		tinyLED_old_settings[LED_id].mode = tinyLED_settings[LED_id].mode;
     b86:	51 83       	std	Z+1, r21	; 0x01
	}
	
	struct ColorSetting new_setting = {.color=color, .mode=mode};
	tinyLED_settings[LED_id] = new_setting;
     b88:	fc 01       	movw	r30, r24
     b8a:	ee 0f       	add	r30, r30
     b8c:	ff 1f       	adc	r31, r31
     b8e:	eb 58       	subi	r30, 0x8B	; 139
     b90:	f7 4c       	sbci	r31, 0xC7	; 199
     b92:	60 83       	st	Z, r22
     b94:	41 83       	std	Z+1, r20	; 0x01
	if (mode == FLASH_ONCE)
     b96:	45 30       	cpi	r20, 0x05	; 5
     b98:	b9 f4       	brne	.+46     	; 0xbc8 <tinyLED_set_color_mode+0x6a>
	{
		// If there is only one flash in the queue, we can let it flash longer
		if(flashes_in_queue>1){
     b9a:	20 91 46 38 	lds	r18, 0x3846	; 0x803846 <flashes_in_queue>
     b9e:	22 30       	cpi	r18, 0x02	; 2
     ba0:	50 f0       	brcs	.+20     	; 0xbb6 <tinyLED_set_color_mode+0x58>
			tinyLED_flash_once_time[LED_id] = 1000*QUEUE_FLASH_TIME;
     ba2:	88 0f       	add	r24, r24
     ba4:	99 1f       	adc	r25, r25
     ba6:	fc 01       	movw	r30, r24
     ba8:	e5 5a       	subi	r30, 0xA5	; 165
     baa:	f7 4c       	sbci	r31, 0xC7	; 199
     bac:	84 e6       	ldi	r24, 0x64	; 100
     bae:	90 e0       	ldi	r25, 0x00	; 0
     bb0:	80 83       	st	Z, r24
     bb2:	91 83       	std	Z+1, r25	; 0x01
     bb4:	08 95       	ret
		}
		else{
			tinyLED_flash_once_time[LED_id] = 1000*FLASH_TIME;
     bb6:	88 0f       	add	r24, r24
     bb8:	99 1f       	adc	r25, r25
     bba:	fc 01       	movw	r30, r24
     bbc:	e5 5a       	subi	r30, 0xA5	; 165
     bbe:	f7 4c       	sbci	r31, 0xC7	; 199
     bc0:	88 ec       	ldi	r24, 0xC8	; 200
     bc2:	90 e0       	ldi	r25, 0x00	; 0
     bc4:	80 83       	st	Z, r24
     bc6:	91 83       	std	Z+1, r25	; 0x01
     bc8:	08 95       	ret

00000bca <tinyLED_set_color>:
/*
changes the values in the variables stored in the LED-array.
*/
void tinyLED_set_color(uint8_t LED_id, enum Colors color)
{
	tinyLED_set_color_mode(LED_id, color, STABLE);
     bca:	40 e0       	ldi	r20, 0x00	; 0
     bcc:	0e 94 af 05 	call	0xb5e	; 0xb5e <tinyLED_set_color_mode>
     bd0:	08 95       	ret

00000bd2 <tinyLED_RGB_Color_Compare>:
	return rgb_color;
			
};
// This might be cause of strange light behavior?
//Message		expected 'struct RGB_Color *' but argument is of type 'struct RGB_Color (*)[2]'	Hjernebyggesett_V4	C:\Users\Elias Lundheim\Documents\GitHub\neural\Hjernebyggesett_V4\Hjernebyggesett_V4\tinyLED\tinyLED.c	121
_Bool tinyLED_RGB_Color_Compare(struct RGB_Color (*a)[NUMBER_OF_LEDS], struct RGB_Color (*b)[NUMBER_OF_LEDS]){
     bd2:	dc 01       	movw	r26, r24
     bd4:	fb 01       	movw	r30, r22
	for (int i=0; i<NUMBER_OF_LEDS; i++)
	{
		if(!((*a)[i].red==(*b)[i].red && (*a)[i].green==(*b)[i].green && (*a)[i].blue==(*b)[i].blue)){
     bd6:	9c 91       	ld	r25, X
     bd8:	80 81       	ld	r24, Z
     bda:	98 13       	cpse	r25, r24
     bdc:	20 c0       	rjmp	.+64     	; 0xc1e <tinyLED_RGB_Color_Compare+0x4c>
     bde:	11 96       	adiw	r26, 0x01	; 1
     be0:	9c 91       	ld	r25, X
     be2:	11 97       	sbiw	r26, 0x01	; 1
     be4:	81 81       	ldd	r24, Z+1	; 0x01
     be6:	98 13       	cpse	r25, r24
     be8:	1c c0       	rjmp	.+56     	; 0xc22 <tinyLED_RGB_Color_Compare+0x50>
     bea:	12 96       	adiw	r26, 0x02	; 2
     bec:	9c 91       	ld	r25, X
     bee:	12 97       	sbiw	r26, 0x02	; 2
     bf0:	82 81       	ldd	r24, Z+2	; 0x02
     bf2:	98 13       	cpse	r25, r24
     bf4:	18 c0       	rjmp	.+48     	; 0xc26 <tinyLED_RGB_Color_Compare+0x54>
     bf6:	13 96       	adiw	r26, 0x03	; 3
     bf8:	9c 91       	ld	r25, X
     bfa:	13 97       	sbiw	r26, 0x03	; 3
     bfc:	83 81       	ldd	r24, Z+3	; 0x03
     bfe:	98 13       	cpse	r25, r24
     c00:	14 c0       	rjmp	.+40     	; 0xc2a <tinyLED_RGB_Color_Compare+0x58>
     c02:	14 96       	adiw	r26, 0x04	; 4
     c04:	9c 91       	ld	r25, X
     c06:	14 97       	sbiw	r26, 0x04	; 4
     c08:	84 81       	ldd	r24, Z+4	; 0x04
     c0a:	98 13       	cpse	r25, r24
     c0c:	10 c0       	rjmp	.+32     	; 0xc2e <tinyLED_RGB_Color_Compare+0x5c>
     c0e:	81 e0       	ldi	r24, 0x01	; 1
     c10:	15 96       	adiw	r26, 0x05	; 5
     c12:	2c 91       	ld	r18, X
     c14:	95 81       	ldd	r25, Z+5	; 0x05
     c16:	29 17       	cp	r18, r25
     c18:	59 f0       	breq	.+22     	; 0xc30 <tinyLED_RGB_Color_Compare+0x5e>
     c1a:	80 e0       	ldi	r24, 0x00	; 0
     c1c:	08 95       	ret
			return false;
     c1e:	80 e0       	ldi	r24, 0x00	; 0
     c20:	08 95       	ret
     c22:	80 e0       	ldi	r24, 0x00	; 0
     c24:	08 95       	ret
     c26:	80 e0       	ldi	r24, 0x00	; 0
     c28:	08 95       	ret
     c2a:	80 e0       	ldi	r24, 0x00	; 0
     c2c:	08 95       	ret
     c2e:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	return true;
}
     c30:	08 95       	ret

00000c32 <tinyLED_update>:
/*
function to write the current LED-array on to the LEDs and
effectively update the values stored in the LEDs to the values stored in the MCU.
*/
void tinyLED_update(void)
{
     c32:	2f 92       	push	r2
     c34:	3f 92       	push	r3
     c36:	4f 92       	push	r4
     c38:	5f 92       	push	r5
     c3a:	6f 92       	push	r6
     c3c:	7f 92       	push	r7
     c3e:	8f 92       	push	r8
     c40:	9f 92       	push	r9
     c42:	af 92       	push	r10
     c44:	bf 92       	push	r11
     c46:	cf 92       	push	r12
     c48:	df 92       	push	r13
     c4a:	ef 92       	push	r14
     c4c:	ff 92       	push	r15
     c4e:	0f 93       	push	r16
     c50:	1f 93       	push	r17
     c52:	cf 93       	push	r28
     c54:	df 93       	push	r29
     c56:	cd b7       	in	r28, 0x3d	; 61
     c58:	de b7       	in	r29, 0x3e	; 62
     c5a:	6e 97       	sbiw	r28, 0x1e	; 30
     c5c:	cd bf       	out	0x3d, r28	; 61
     c5e:	de bf       	out	0x3e, r29	; 62
			
	uint32_t now = tinyTime_now();	
     c60:	0e 94 69 09 	call	0x12d2	; 0x12d2 <tinyTime_now>
     c64:	6b 01       	movw	r12, r22
     c66:	7c 01       	movw	r14, r24
	
	// This is a sin curve, but between 0 and 1 instead of -1 and 1
	double sinValue = 0.5+sin((double)now/(100*M_PI/SWING_RATE))/2;
     c68:	0e 94 bf 0a 	call	0x157e	; 0x157e <__floatunsisf>
     c6c:	23 e6       	ldi	r18, 0x63	; 99
     c6e:	34 e1       	ldi	r19, 0x14	; 20
     c70:	4d e1       	ldi	r20, 0x1D	; 29
     c72:	54 e4       	ldi	r21, 0x44	; 68
     c74:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <__divsf3>
     c78:	0e 94 9f 0c 	call	0x193e	; 0x193e <sin>
     c7c:	20 e0       	ldi	r18, 0x00	; 0
     c7e:	30 e0       	ldi	r19, 0x00	; 0
     c80:	40 e0       	ldi	r20, 0x00	; 0
     c82:	5f e3       	ldi	r21, 0x3F	; 63
     c84:	0e 94 32 0c 	call	0x1864	; 0x1864 <__mulsf3>
     c88:	20 e0       	ldi	r18, 0x00	; 0
     c8a:	30 e0       	ldi	r19, 0x00	; 0
     c8c:	40 e0       	ldi	r20, 0x00	; 0
     c8e:	5f e3       	ldi	r21, 0x3F	; 63
     c90:	0e 94 73 09 	call	0x12e6	; 0x12e6 <__addsf3>
     c94:	6b 87       	std	Y+11, r22	; 0x0b
     c96:	7c 87       	std	Y+12, r23	; 0x0c
     c98:	8d 87       	std	Y+13, r24	; 0x0d
     c9a:	9e 87       	std	Y+14, r25	; 0x0e
	
	// If FLASH_RATE is one, then that means that the left side of the "<" will just count from 0 to 1000, and flash_on will be true for half of the time
	_Bool flash_on = now%(uint32_t)(1000/FLASH_RATE)  <   500/FLASH_RATE;
     c9c:	c7 01       	movw	r24, r14
     c9e:	b6 01       	movw	r22, r12
     ca0:	28 ee       	ldi	r18, 0xE8	; 232
     ca2:	33 e0       	ldi	r19, 0x03	; 3
     ca4:	40 e0       	ldi	r20, 0x00	; 0
     ca6:	50 e0       	ldi	r21, 0x00	; 0
     ca8:	0e 94 08 0d 	call	0x1a10	; 0x1a10 <__udivmodsi4>
     cac:	22 24       	eor	r2, r2
     cae:	23 94       	inc	r2
     cb0:	64 3f       	cpi	r22, 0xF4	; 244
     cb2:	71 40       	sbci	r23, 0x01	; 1
     cb4:	81 05       	cpc	r24, r1
     cb6:	91 05       	cpc	r25, r1
     cb8:	08 f0       	brcs	.+2      	; 0xcbc <tinyLED_update+0x8a>
     cba:	21 2c       	mov	r2, r1
	
	// PING_RATE is usually small, so the left side counts to some large number. Since flash_time usually is also quite small,
	// the left side will usually be larger than the right
	_Bool ping_on =  now%(uint32_t)(1000/PING_RATE)   <   1000*FLASH_TIME;
     cbc:	c7 01       	movw	r24, r14
     cbe:	b6 01       	movw	r22, r12
     cc0:	20 e1       	ldi	r18, 0x10	; 16
     cc2:	37 e2       	ldi	r19, 0x27	; 39
     cc4:	40 e0       	ldi	r20, 0x00	; 0
     cc6:	50 e0       	ldi	r21, 0x00	; 0
     cc8:	0e 94 08 0d 	call	0x1a10	; 0x1a10 <__udivmodsi4>
     ccc:	0e 94 bf 0a 	call	0x157e	; 0x157e <__floatunsisf>
     cd0:	20 e0       	ldi	r18, 0x00	; 0
     cd2:	30 e0       	ldi	r19, 0x00	; 0
     cd4:	48 e4       	ldi	r20, 0x48	; 72
     cd6:	53 e4       	ldi	r21, 0x43	; 67
     cd8:	0e 94 df 09 	call	0x13be	; 0x13be <__cmpsf2>
     cdc:	88 1f       	adc	r24, r24
     cde:	88 27       	eor	r24, r24
     ce0:	88 1f       	adc	r24, r24
     ce2:	0f 2e       	mov	r0, r31
     ce4:	f5 e7       	ldi	r31, 0x75	; 117
     ce6:	4f 2e       	mov	r4, r31
     ce8:	f8 e3       	ldi	r31, 0x38	; 56
     cea:	5f 2e       	mov	r5, r31
     cec:	f0 2d       	mov	r31, r0
     cee:	ae 01       	movw	r20, r28
     cf0:	4f 5f       	subi	r20, 0xFF	; 255
     cf2:	5f 4f       	sbci	r21, 0xFF	; 255
     cf4:	4a 01       	movw	r8, r20
     cf6:	0f 2e       	mov	r0, r31
     cf8:	f9 e7       	ldi	r31, 0x79	; 121
     cfa:	6f 2e       	mov	r6, r31
     cfc:	f8 e3       	ldi	r31, 0x38	; 56
     cfe:	7f 2e       	mov	r7, r31
     d00:	f0 2d       	mov	r31, r0
     d02:	0f 2e       	mov	r0, r31
     d04:	fb e5       	ldi	r31, 0x5B	; 91
     d06:	cf 2e       	mov	r12, r31
     d08:	f8 e3       	ldi	r31, 0x38	; 56
     d0a:	df 2e       	mov	r13, r31
     d0c:	f0 2d       	mov	r31, r0
     d0e:	5a 01       	movw	r10, r20
	
	// This is where we store all the actual color values we want to send to the LED
	struct RGB_Color rgb_colors[NUMBER_OF_LEDS];
	
	
	for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
     d10:	31 2c       	mov	r3, r1
			case SWING:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*sinValue, rgb_colors[i].green*sinValue, rgb_colors[i].blue*sinValue};
				break;
			case PING:
				// in the line below, fmin will either return 1 or 0, so each rgb color is either 0 or 255*PING_BRIGHTNESS
				rgb_colors[i] = (struct RGB_Color){255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].red)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].green)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].blue)*ping_on};
     d12:	28 2f       	mov	r18, r24
     d14:	30 e0       	ldi	r19, 0x00	; 0
     d16:	40 e0       	ldi	r20, 0x00	; 0
     d18:	50 e0       	ldi	r21, 0x00	; 0
     d1a:	2f 87       	std	Y+15, r18	; 0x0f
     d1c:	38 8b       	std	Y+16, r19	; 0x10
     d1e:	49 8b       	std	Y+17, r20	; 0x11
     d20:	5a 8b       	std	Y+18, r21	; 0x12
     d22:	82 01       	movw	r16, r4
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 0 << TCA_SPLIT_ENABLE_bp; //Stop TCA
}

static struct RGB_Color tinyLED_enum_to_RGB_Color(enum Colors color){
	struct RGB_Color rgb_color;
	switch(color)
     d24:	f2 01       	movw	r30, r4
     d26:	80 81       	ld	r24, Z
     d28:	83 30       	cpi	r24, 0x03	; 3
     d2a:	79 f0       	breq	.+30     	; 0xd4a <tinyLED_update+0x118>
     d2c:	28 f4       	brcc	.+10     	; 0xd38 <tinyLED_update+0x106>
     d2e:	81 30       	cpi	r24, 0x01	; 1
     d30:	41 f0       	breq	.+16     	; 0xd42 <tinyLED_update+0x110>
     d32:	82 30       	cpi	r24, 0x02	; 2
     d34:	71 f0       	breq	.+28     	; 0xd52 <tinyLED_update+0x120>
     d36:	19 c0       	rjmp	.+50     	; 0xd6a <tinyLED_update+0x138>
     d38:	84 30       	cpi	r24, 0x04	; 4
     d3a:	79 f0       	breq	.+30     	; 0xd5a <tinyLED_update+0x128>
     d3c:	85 30       	cpi	r24, 0x05	; 5
     d3e:	89 f0       	breq	.+34     	; 0xd62 <tinyLED_update+0x130>
     d40:	14 c0       	rjmp	.+40     	; 0xd6a <tinyLED_update+0x138>
	{
		case LED_OFF:
			rgb_color = (struct RGB_Color){0, 0, 0};
			break;
		case RED:
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 0, 0};
     d42:	80 e0       	ldi	r24, 0x00	; 0
     d44:	90 e0       	ldi	r25, 0x00	; 0
     d46:	29 e1       	ldi	r18, 0x19	; 25
     d48:	13 c0       	rjmp	.+38     	; 0xd70 <tinyLED_update+0x13e>
			break;
		case GREEN:
			rgb_color = (struct RGB_Color){0, 255*LED_BRIGHTNESS, 0};
     d4a:	80 e0       	ldi	r24, 0x00	; 0
     d4c:	99 e1       	ldi	r25, 0x19	; 25
     d4e:	20 e0       	ldi	r18, 0x00	; 0
     d50:	0f c0       	rjmp	.+30     	; 0xd70 <tinyLED_update+0x13e>
			break;
		case BLUE:
			rgb_color = (struct RGB_Color){0, 0, 255*LED_BRIGHTNESS};
     d52:	89 e1       	ldi	r24, 0x19	; 25
     d54:	90 e0       	ldi	r25, 0x00	; 0
     d56:	20 e0       	ldi	r18, 0x00	; 0
     d58:	0b c0       	rjmp	.+22     	; 0xd70 <tinyLED_update+0x13e>
			break;
		case YELLOW:
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS, 0};
     d5a:	80 e0       	ldi	r24, 0x00	; 0
     d5c:	99 e1       	ldi	r25, 0x19	; 25
     d5e:	29 e1       	ldi	r18, 0x19	; 25
     d60:	07 c0       	rjmp	.+14     	; 0xd70 <tinyLED_update+0x13e>
			// Should the /3 be there? This requires testing.
			// After testing, findings were that at 0.1 brightness, one would see the three LEDs instead of one white led
			// We try with /2 instead.
			// We find that the best results come from not dividing by anything. At leasts in the lower brightness settings, and that
			// is where we suspect it will be most of the time. When we divide, the LEDs are so weak, that they appear as three lights instead of one.
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS};
     d62:	89 e1       	ldi	r24, 0x19	; 25
     d64:	99 e1       	ldi	r25, 0x19	; 25
     d66:	29 e1       	ldi	r18, 0x19	; 25
     d68:	03 c0       	rjmp	.+6      	; 0xd70 <tinyLED_update+0x13e>
static struct RGB_Color tinyLED_enum_to_RGB_Color(enum Colors color){
	struct RGB_Color rgb_color;
	switch(color)
	{
		case LED_OFF:
			rgb_color = (struct RGB_Color){0, 0, 0};
     d6a:	80 e0       	ldi	r24, 0x00	; 0
     d6c:	90 e0       	ldi	r25, 0x00	; 0
     d6e:	20 e0       	ldi	r18, 0x00	; 0
     d70:	75 01       	movw	r14, r10
	
	
	for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
	{		
		// Convert enum to RGB_Color
		rgb_colors[i] = tinyLED_enum_to_RGB_Color(tinyLED_settings[i].color);
     d72:	f5 01       	movw	r30, r10
     d74:	20 83       	st	Z, r18
     d76:	91 83       	std	Z+1, r25	; 0x01
     d78:	82 83       	std	Z+2, r24	; 0x02
		// Check if there is a flash that can be queued
		// Complicated code (bad code): The best implementation would be to have a separate flash queue for each
		// LED, but I can't be bothered to deal with nested arrays. So we check a couple of things
		// It should work well so long as two LEDs aren't being queued to at the same time. If that does happen, 
		// nothing should break, but it will be slower to get the flashes out.
		if (flashes_in_queue>0 && tinyLED_settings[i].mode !=FLASH_ONCE && flash_queue_ids[flashes_in_queue] == i)
     d7a:	80 91 46 38 	lds	r24, 0x3846	; 0x803846 <flashes_in_queue>
     d7e:	88 23       	and	r24, r24
     d80:	c9 f0       	breq	.+50     	; 0xdb4 <tinyLED_update+0x182>
     d82:	f8 01       	movw	r30, r16
     d84:	91 81       	ldd	r25, Z+1	; 0x01
     d86:	95 30       	cpi	r25, 0x05	; 5
     d88:	09 f4       	brne	.+2      	; 0xd8c <tinyLED_update+0x15a>
     d8a:	1f c1       	rjmp	.+574    	; 0xfca <tinyLED_update+0x398>
     d8c:	90 e0       	ldi	r25, 0x00	; 0
     d8e:	fc 01       	movw	r30, r24
     d90:	e3 58       	subi	r30, 0x83	; 131
     d92:	f7 4c       	sbci	r31, 0xC7	; 199
     d94:	20 81       	ld	r18, Z
     d96:	23 11       	cpse	r18, r3
     d98:	0d c0       	rjmp	.+26     	; 0xdb4 <tinyLED_update+0x182>
		{
			// This implementation is easier, but it means that the last flash into the queue is the first out.
			tinyLED_set_color_mode(flash_queue_ids[flashes_in_queue], flash_queue[flashes_in_queue], FLASH_ONCE);
     d9a:	fc 01       	movw	r30, r24
     d9c:	eb 59       	subi	r30, 0x9B	; 155
     d9e:	f7 4c       	sbci	r31, 0xC7	; 199
     da0:	45 e0       	ldi	r20, 0x05	; 5
     da2:	60 81       	ld	r22, Z
     da4:	83 2d       	mov	r24, r3
     da6:	0e 94 af 05 	call	0xb5e	; 0xb5e <tinyLED_set_color_mode>
			flashes_in_queue--;
     daa:	80 91 46 38 	lds	r24, 0x3846	; 0x803846 <flashes_in_queue>
     dae:	81 50       	subi	r24, 0x01	; 1
     db0:	80 93 46 38 	sts	0x3846, r24	; 0x803846 <flashes_in_queue>
		}
		
		// Adjust colors according to mode
		switch(tinyLED_settings[i].mode)
     db4:	f8 01       	movw	r30, r16
     db6:	81 81       	ldd	r24, Z+1	; 0x01
     db8:	83 30       	cpi	r24, 0x03	; 3
     dba:	09 f4       	brne	.+2      	; 0xdbe <tinyLED_update+0x18c>
     dbc:	52 c0       	rjmp	.+164    	; 0xe62 <tinyLED_update+0x230>
     dbe:	28 f4       	brcc	.+10     	; 0xdca <tinyLED_update+0x198>
     dc0:	81 30       	cpi	r24, 0x01	; 1
     dc2:	51 f0       	breq	.+20     	; 0xdd8 <tinyLED_update+0x1a6>
     dc4:	82 30       	cpi	r24, 0x02	; 2
     dc6:	e1 f1       	breq	.+120    	; 0xe40 <tinyLED_update+0x20e>
     dc8:	2d c1       	rjmp	.+602    	; 0x1024 <tinyLED_update+0x3f2>
     dca:	84 30       	cpi	r24, 0x04	; 4
     dcc:	09 f4       	brne	.+2      	; 0xdd0 <tinyLED_update+0x19e>
     dce:	7d c0       	rjmp	.+250    	; 0xeca <tinyLED_update+0x298>
     dd0:	85 30       	cpi	r24, 0x05	; 5
     dd2:	09 f4       	brne	.+2      	; 0xdd6 <tinyLED_update+0x1a4>
     dd4:	fa c0       	rjmp	.+500    	; 0xfca <tinyLED_update+0x398>
     dd6:	26 c1       	rjmp	.+588    	; 0x1024 <tinyLED_update+0x3f2>
		{
			case STABLE:
				break;
			case WEAK:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*WEAK_BRIGHTNESS, rgb_colors[i].green*WEAK_BRIGHTNESS, rgb_colors[i].blue*WEAK_BRIGHTNESS};
     dd8:	f7 01       	movw	r30, r14
     dda:	61 81       	ldd	r22, Z+1	; 0x01
     ddc:	70 e0       	ldi	r23, 0x00	; 0
     dde:	80 e0       	ldi	r24, 0x00	; 0
     de0:	90 e0       	ldi	r25, 0x00	; 0
     de2:	0e 94 c1 0a 	call	0x1582	; 0x1582 <__floatsisf>
     de6:	2d ec       	ldi	r18, 0xCD	; 205
     de8:	3c ec       	ldi	r19, 0xCC	; 204
     dea:	4c ec       	ldi	r20, 0xCC	; 204
     dec:	5d e3       	ldi	r21, 0x3D	; 61
     dee:	0e 94 32 0c 	call	0x1864	; 0x1864 <__mulsf3>
     df2:	0e 94 90 0a 	call	0x1520	; 0x1520 <__fixunssfsi>
     df6:	16 2f       	mov	r17, r22
     df8:	f7 01       	movw	r30, r14
     dfa:	62 81       	ldd	r22, Z+2	; 0x02
     dfc:	70 e0       	ldi	r23, 0x00	; 0
     dfe:	80 e0       	ldi	r24, 0x00	; 0
     e00:	90 e0       	ldi	r25, 0x00	; 0
     e02:	0e 94 c1 0a 	call	0x1582	; 0x1582 <__floatsisf>
     e06:	2d ec       	ldi	r18, 0xCD	; 205
     e08:	3c ec       	ldi	r19, 0xCC	; 204
     e0a:	4c ec       	ldi	r20, 0xCC	; 204
     e0c:	5d e3       	ldi	r21, 0x3D	; 61
     e0e:	0e 94 32 0c 	call	0x1864	; 0x1864 <__mulsf3>
     e12:	0e 94 90 0a 	call	0x1520	; 0x1520 <__fixunssfsi>
     e16:	06 2f       	mov	r16, r22
     e18:	f7 01       	movw	r30, r14
     e1a:	60 81       	ld	r22, Z
     e1c:	70 e0       	ldi	r23, 0x00	; 0
     e1e:	80 e0       	ldi	r24, 0x00	; 0
     e20:	90 e0       	ldi	r25, 0x00	; 0
     e22:	0e 94 c1 0a 	call	0x1582	; 0x1582 <__floatsisf>
     e26:	2d ec       	ldi	r18, 0xCD	; 205
     e28:	3c ec       	ldi	r19, 0xCC	; 204
     e2a:	4c ec       	ldi	r20, 0xCC	; 204
     e2c:	5d e3       	ldi	r21, 0x3D	; 61
     e2e:	0e 94 32 0c 	call	0x1864	; 0x1864 <__mulsf3>
     e32:	0e 94 90 0a 	call	0x1520	; 0x1520 <__fixunssfsi>
     e36:	f7 01       	movw	r30, r14
     e38:	60 83       	st	Z, r22
     e3a:	11 83       	std	Z+1, r17	; 0x01
     e3c:	02 83       	std	Z+2, r16	; 0x02
				break;
     e3e:	f2 c0       	rjmp	.+484    	; 0x1024 <tinyLED_update+0x3f2>
			case FLASH:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*flash_on, rgb_colors[i].green*flash_on, rgb_colors[i].blue*flash_on};
     e40:	f7 01       	movw	r30, r14
     e42:	91 81       	ldd	r25, Z+1	; 0x01
     e44:	29 9e       	mul	r2, r25
     e46:	90 2d       	mov	r25, r0
     e48:	11 24       	eor	r1, r1
     e4a:	82 81       	ldd	r24, Z+2	; 0x02
     e4c:	28 9e       	mul	r2, r24
     e4e:	80 2d       	mov	r24, r0
     e50:	11 24       	eor	r1, r1
     e52:	20 81       	ld	r18, Z
     e54:	22 9d       	mul	r18, r2
     e56:	20 2d       	mov	r18, r0
     e58:	11 24       	eor	r1, r1
     e5a:	20 83       	st	Z, r18
     e5c:	91 83       	std	Z+1, r25	; 0x01
     e5e:	82 83       	std	Z+2, r24	; 0x02
				break;
     e60:	e1 c0       	rjmp	.+450    	; 0x1024 <tinyLED_update+0x3f2>
			case SWING:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*sinValue, rgb_colors[i].green*sinValue, rgb_colors[i].blue*sinValue};
     e62:	f7 01       	movw	r30, r14
     e64:	61 81       	ldd	r22, Z+1	; 0x01
     e66:	70 e0       	ldi	r23, 0x00	; 0
     e68:	80 e0       	ldi	r24, 0x00	; 0
     e6a:	90 e0       	ldi	r25, 0x00	; 0
     e6c:	0e 94 c1 0a 	call	0x1582	; 0x1582 <__floatsisf>
     e70:	2b 85       	ldd	r18, Y+11	; 0x0b
     e72:	3c 85       	ldd	r19, Y+12	; 0x0c
     e74:	4d 85       	ldd	r20, Y+13	; 0x0d
     e76:	5e 85       	ldd	r21, Y+14	; 0x0e
     e78:	0e 94 32 0c 	call	0x1864	; 0x1864 <__mulsf3>
     e7c:	0e 94 90 0a 	call	0x1520	; 0x1520 <__fixunssfsi>
     e80:	16 2f       	mov	r17, r22
     e82:	f7 01       	movw	r30, r14
     e84:	62 81       	ldd	r22, Z+2	; 0x02
     e86:	70 e0       	ldi	r23, 0x00	; 0
     e88:	80 e0       	ldi	r24, 0x00	; 0
     e8a:	90 e0       	ldi	r25, 0x00	; 0
     e8c:	0e 94 c1 0a 	call	0x1582	; 0x1582 <__floatsisf>
     e90:	2b 85       	ldd	r18, Y+11	; 0x0b
     e92:	3c 85       	ldd	r19, Y+12	; 0x0c
     e94:	4d 85       	ldd	r20, Y+13	; 0x0d
     e96:	5e 85       	ldd	r21, Y+14	; 0x0e
     e98:	0e 94 32 0c 	call	0x1864	; 0x1864 <__mulsf3>
     e9c:	0e 94 90 0a 	call	0x1520	; 0x1520 <__fixunssfsi>
     ea0:	06 2f       	mov	r16, r22
     ea2:	f7 01       	movw	r30, r14
     ea4:	60 81       	ld	r22, Z
     ea6:	70 e0       	ldi	r23, 0x00	; 0
     ea8:	80 e0       	ldi	r24, 0x00	; 0
     eaa:	90 e0       	ldi	r25, 0x00	; 0
     eac:	0e 94 c1 0a 	call	0x1582	; 0x1582 <__floatsisf>
     eb0:	2b 85       	ldd	r18, Y+11	; 0x0b
     eb2:	3c 85       	ldd	r19, Y+12	; 0x0c
     eb4:	4d 85       	ldd	r20, Y+13	; 0x0d
     eb6:	5e 85       	ldd	r21, Y+14	; 0x0e
     eb8:	0e 94 32 0c 	call	0x1864	; 0x1864 <__mulsf3>
     ebc:	0e 94 90 0a 	call	0x1520	; 0x1520 <__fixunssfsi>
     ec0:	f7 01       	movw	r30, r14
     ec2:	60 83       	st	Z, r22
     ec4:	11 83       	std	Z+1, r17	; 0x01
     ec6:	02 83       	std	Z+2, r16	; 0x02
				break;
     ec8:	ad c0       	rjmp	.+346    	; 0x1024 <tinyLED_update+0x3f2>
			case PING:
				// in the line below, fmin will either return 1 or 0, so each rgb color is either 0 or 255*PING_BRIGHTNESS
				rgb_colors[i] = (struct RGB_Color){255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].red)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].green)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].blue)*ping_on};
     eca:	f7 01       	movw	r30, r14
     ecc:	60 81       	ld	r22, Z
     ece:	70 e0       	ldi	r23, 0x00	; 0
     ed0:	80 e0       	ldi	r24, 0x00	; 0
     ed2:	90 e0       	ldi	r25, 0x00	; 0
     ed4:	0e 94 bf 0a 	call	0x157e	; 0x157e <__floatunsisf>
     ed8:	9b 01       	movw	r18, r22
     eda:	ac 01       	movw	r20, r24
     edc:	60 e0       	ldi	r22, 0x00	; 0
     ede:	70 e0       	ldi	r23, 0x00	; 0
     ee0:	80 e8       	ldi	r24, 0x80	; 128
     ee2:	9f e3       	ldi	r25, 0x3F	; 63
     ee4:	0e 94 fc 0a 	call	0x15f8	; 0x15f8 <fmin>
     ee8:	6b 8b       	std	Y+19, r22	; 0x13
     eea:	7c 8b       	std	Y+20, r23	; 0x14
     eec:	8d 8b       	std	Y+21, r24	; 0x15
     eee:	9e 8b       	std	Y+22, r25	; 0x16
     ef0:	6f 85       	ldd	r22, Y+15	; 0x0f
     ef2:	78 89       	ldd	r23, Y+16	; 0x10
     ef4:	89 89       	ldd	r24, Y+17	; 0x11
     ef6:	9a 89       	ldd	r25, Y+18	; 0x12
     ef8:	0e 94 c1 0a 	call	0x1582	; 0x1582 <__floatsisf>
     efc:	6f 83       	std	Y+7, r22	; 0x07
     efe:	78 87       	std	Y+8, r23	; 0x08
     f00:	89 87       	std	Y+9, r24	; 0x09
     f02:	9a 87       	std	Y+10, r25	; 0x0a
     f04:	f7 01       	movw	r30, r14
     f06:	61 81       	ldd	r22, Z+1	; 0x01
     f08:	70 e0       	ldi	r23, 0x00	; 0
     f0a:	80 e0       	ldi	r24, 0x00	; 0
     f0c:	90 e0       	ldi	r25, 0x00	; 0
     f0e:	0e 94 bf 0a 	call	0x157e	; 0x157e <__floatunsisf>
     f12:	9b 01       	movw	r18, r22
     f14:	ac 01       	movw	r20, r24
     f16:	60 e0       	ldi	r22, 0x00	; 0
     f18:	70 e0       	ldi	r23, 0x00	; 0
     f1a:	80 e8       	ldi	r24, 0x80	; 128
     f1c:	9f e3       	ldi	r25, 0x3F	; 63
     f1e:	0e 94 fc 0a 	call	0x15f8	; 0x15f8 <fmin>
     f22:	6f 8b       	std	Y+23, r22	; 0x17
     f24:	78 8f       	std	Y+24, r23	; 0x18
     f26:	89 8f       	std	Y+25, r24	; 0x19
     f28:	9a 8f       	std	Y+26, r25	; 0x1a
     f2a:	f7 01       	movw	r30, r14
     f2c:	62 81       	ldd	r22, Z+2	; 0x02
     f2e:	70 e0       	ldi	r23, 0x00	; 0
     f30:	80 e0       	ldi	r24, 0x00	; 0
     f32:	90 e0       	ldi	r25, 0x00	; 0
     f34:	0e 94 bf 0a 	call	0x157e	; 0x157e <__floatunsisf>
     f38:	9b 01       	movw	r18, r22
     f3a:	ac 01       	movw	r20, r24
     f3c:	60 e0       	ldi	r22, 0x00	; 0
     f3e:	70 e0       	ldi	r23, 0x00	; 0
     f40:	80 e8       	ldi	r24, 0x80	; 128
     f42:	9f e3       	ldi	r25, 0x3F	; 63
     f44:	0e 94 fc 0a 	call	0x15f8	; 0x15f8 <fmin>
     f48:	6b 8f       	std	Y+27, r22	; 0x1b
     f4a:	7c 8f       	std	Y+28, r23	; 0x1c
     f4c:	8d 8f       	std	Y+29, r24	; 0x1d
     f4e:	9e 8f       	std	Y+30, r25	; 0x1e
     f50:	23 e3       	ldi	r18, 0x33	; 51
     f52:	33 e3       	ldi	r19, 0x33	; 51
     f54:	43 ea       	ldi	r20, 0xA3	; 163
     f56:	50 e4       	ldi	r21, 0x40	; 64
     f58:	6b 89       	ldd	r22, Y+19	; 0x13
     f5a:	7c 89       	ldd	r23, Y+20	; 0x14
     f5c:	8d 89       	ldd	r24, Y+21	; 0x15
     f5e:	9e 89       	ldd	r25, Y+22	; 0x16
     f60:	0e 94 32 0c 	call	0x1864	; 0x1864 <__mulsf3>
     f64:	2f 81       	ldd	r18, Y+7	; 0x07
     f66:	38 85       	ldd	r19, Y+8	; 0x08
     f68:	49 85       	ldd	r20, Y+9	; 0x09
     f6a:	5a 85       	ldd	r21, Y+10	; 0x0a
     f6c:	0e 94 32 0c 	call	0x1864	; 0x1864 <__mulsf3>
     f70:	0e 94 90 0a 	call	0x1520	; 0x1520 <__fixunssfsi>
     f74:	f7 01       	movw	r30, r14
     f76:	60 83       	st	Z, r22
     f78:	23 e3       	ldi	r18, 0x33	; 51
     f7a:	33 e3       	ldi	r19, 0x33	; 51
     f7c:	43 ea       	ldi	r20, 0xA3	; 163
     f7e:	50 e4       	ldi	r21, 0x40	; 64
     f80:	6f 89       	ldd	r22, Y+23	; 0x17
     f82:	78 8d       	ldd	r23, Y+24	; 0x18
     f84:	89 8d       	ldd	r24, Y+25	; 0x19
     f86:	9a 8d       	ldd	r25, Y+26	; 0x1a
     f88:	0e 94 32 0c 	call	0x1864	; 0x1864 <__mulsf3>
     f8c:	2f 81       	ldd	r18, Y+7	; 0x07
     f8e:	38 85       	ldd	r19, Y+8	; 0x08
     f90:	49 85       	ldd	r20, Y+9	; 0x09
     f92:	5a 85       	ldd	r21, Y+10	; 0x0a
     f94:	0e 94 32 0c 	call	0x1864	; 0x1864 <__mulsf3>
     f98:	0e 94 90 0a 	call	0x1520	; 0x1520 <__fixunssfsi>
     f9c:	f7 01       	movw	r30, r14
     f9e:	61 83       	std	Z+1, r22	; 0x01
     fa0:	23 e3       	ldi	r18, 0x33	; 51
     fa2:	33 e3       	ldi	r19, 0x33	; 51
     fa4:	43 ea       	ldi	r20, 0xA3	; 163
     fa6:	50 e4       	ldi	r21, 0x40	; 64
     fa8:	6b 8d       	ldd	r22, Y+27	; 0x1b
     faa:	7c 8d       	ldd	r23, Y+28	; 0x1c
     fac:	8d 8d       	ldd	r24, Y+29	; 0x1d
     fae:	9e 8d       	ldd	r25, Y+30	; 0x1e
     fb0:	0e 94 32 0c 	call	0x1864	; 0x1864 <__mulsf3>
     fb4:	2f 81       	ldd	r18, Y+7	; 0x07
     fb6:	38 85       	ldd	r19, Y+8	; 0x08
     fb8:	49 85       	ldd	r20, Y+9	; 0x09
     fba:	5a 85       	ldd	r21, Y+10	; 0x0a
     fbc:	0e 94 32 0c 	call	0x1864	; 0x1864 <__mulsf3>
     fc0:	0e 94 90 0a 	call	0x1520	; 0x1520 <__fixunssfsi>
     fc4:	f7 01       	movw	r30, r14
     fc6:	62 83       	std	Z+2, r22	; 0x02
				break;
     fc8:	2d c0       	rjmp	.+90     	; 0x1024 <tinyLED_update+0x3f2>
     fca:	cb 8a       	std	Y+19, r12	; 0x13
     fcc:	dc 8a       	std	Y+20, r13	; 0x14
			case FLASH_ONCE:
				if(tinyLED_flash_once_time[i]>0){
     fce:	f6 01       	movw	r30, r12
     fd0:	01 90       	ld	r0, Z+
     fd2:	f0 81       	ld	r31, Z
     fd4:	e0 2d       	mov	r30, r0
     fd6:	ef 83       	std	Y+7, r30	; 0x07
     fd8:	f8 87       	std	Y+8, r31	; 0x08
     fda:	30 97       	sbiw	r30, 0x00	; 0
     fdc:	d9 f0       	breq	.+54     	; 0x1014 <tinyLED_update+0x3e2>
					
					// Check if flash is inside off period
					if(tinyLED_flash_once_time[i]>1000*(FLASH_TIME - FLASH_OFF_TIME)){
     fde:	bf 01       	movw	r22, r30
     fe0:	80 e0       	ldi	r24, 0x00	; 0
     fe2:	90 e0       	ldi	r25, 0x00	; 0
     fe4:	0e 94 bf 0a 	call	0x157e	; 0x157e <__floatunsisf>
     fe8:	20 e0       	ldi	r18, 0x00	; 0
     fea:	30 e0       	ldi	r19, 0x00	; 0
     fec:	4e e3       	ldi	r20, 0x3E	; 62
     fee:	53 e4       	ldi	r21, 0x43	; 67
     ff0:	0e 94 b7 0b 	call	0x176e	; 0x176e <__gesf2>
     ff4:	18 16       	cp	r1, r24
     ff6:	24 f4       	brge	.+8      	; 0x1000 <tinyLED_update+0x3ce>
						// This is used to seperate flashes
						rgb_colors[i] = (struct RGB_Color){0, 0, 0};
     ff8:	f7 01       	movw	r30, r14
     ffa:	10 82       	st	Z, r1
     ffc:	11 82       	std	Z+1, r1	; 0x01
     ffe:	12 82       	std	Z+2, r1	; 0x02
					} else {
						rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red, rgb_colors[i].green, rgb_colors[i].blue};
					}
					
					tinyLED_flash_once_time[i]--;
    1000:	ef 80       	ldd	r14, Y+7	; 0x07
    1002:	f8 84       	ldd	r15, Y+8	; 0x08
    1004:	f1 e0       	ldi	r31, 0x01	; 1
    1006:	ef 1a       	sub	r14, r31
    1008:	f1 08       	sbc	r15, r1
    100a:	eb 89       	ldd	r30, Y+19	; 0x13
    100c:	fc 89       	ldd	r31, Y+20	; 0x14
    100e:	e0 82       	st	Z, r14
    1010:	f1 82       	std	Z+1, r15	; 0x01
    1012:	08 c0       	rjmp	.+16     	; 0x1024 <tinyLED_update+0x3f2>
				}
				else{
					// Here we return to the previous color and mode
					tinyLED_settings[i].color = tinyLED_old_settings[i].color;
    1014:	f3 01       	movw	r30, r6
    1016:	80 81       	ld	r24, Z
    1018:	f8 01       	movw	r30, r16
    101a:	80 83       	st	Z, r24
					tinyLED_settings[i].mode = tinyLED_old_settings[i].mode;
    101c:	f3 01       	movw	r30, r6
    101e:	81 81       	ldd	r24, Z+1	; 0x01
    1020:	f8 01       	movw	r30, r16
    1022:	81 83       	std	Z+1, r24	; 0x01
	
	// This is where we store all the actual color values we want to send to the LED
	struct RGB_Color rgb_colors[NUMBER_OF_LEDS];
	
	
	for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
    1024:	33 94       	inc	r3
    1026:	f2 e0       	ldi	r31, 0x02	; 2
    1028:	4f 0e       	add	r4, r31
    102a:	51 1c       	adc	r5, r1
    102c:	23 e0       	ldi	r18, 0x03	; 3
    102e:	a2 0e       	add	r10, r18
    1030:	b1 1c       	adc	r11, r1
    1032:	32 e0       	ldi	r19, 0x02	; 2
    1034:	63 0e       	add	r6, r19
    1036:	71 1c       	adc	r7, r1
    1038:	42 e0       	ldi	r20, 0x02	; 2
    103a:	c4 0e       	add	r12, r20
    103c:	d1 1c       	adc	r13, r1
    103e:	52 e0       	ldi	r21, 0x02	; 2
    1040:	35 12       	cpse	r3, r21
    1042:	6f ce       	rjmp	.-802    	; 0xd22 <tinyLED_update+0xf0>
				break;
		}
	}
	
	// We only write to the LEDs if there is something to change. (eg. in SWING mode, we update the LEDs almost every cycle)
	if(!tinyLED_RGB_Color_Compare(&rgb_colors, &tinyLED_old_colors)){
    1044:	6f e5       	ldi	r22, 0x5F	; 95
    1046:	78 e3       	ldi	r23, 0x38	; 56
    1048:	ce 01       	movw	r24, r28
    104a:	01 96       	adiw	r24, 0x01	; 1
    104c:	0e 94 e9 05 	call	0xbd2	; 0xbd2 <tinyLED_RGB_Color_Compare>
    1050:	81 11       	cpse	r24, r1
    1052:	1f c0       	rjmp	.+62     	; 0x1092 <tinyLED_update+0x460>
    1054:	0f e5       	ldi	r16, 0x5F	; 95
    1056:	18 e3       	ldi	r17, 0x38	; 56
    1058:	7e 01       	movw	r14, r28
    105a:	87 e0       	ldi	r24, 0x07	; 7
    105c:	e8 0e       	add	r14, r24
    105e:	f1 1c       	adc	r15, r1
		for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
		{
			// Write to LEDs
			//For some reason, the data-bus to the LEDs is serialized as GRB
			//which means the 24-bit data-bus will look like [Green[0:7], Red[0:7], Blue[0:7]]
			tinyLED_SPIWriteByte(rgb_colors[i].green);
    1060:	f4 01       	movw	r30, r8
    1062:	81 81       	ldd	r24, Z+1	; 0x01
    1064:	0e 94 93 05 	call	0xb26	; 0xb26 <tinyLED_SPIWriteByte>
			tinyLED_SPIWriteByte(rgb_colors[i].red);
    1068:	f4 01       	movw	r30, r8
    106a:	80 81       	ld	r24, Z
    106c:	0e 94 93 05 	call	0xb26	; 0xb26 <tinyLED_SPIWriteByte>
			tinyLED_SPIWriteByte(rgb_colors[i].blue);
    1070:	f4 01       	movw	r30, r8
    1072:	82 81       	ldd	r24, Z+2	; 0x02
    1074:	0e 94 93 05 	call	0xb26	; 0xb26 <tinyLED_SPIWriteByte>
			tinyLED_old_colors[i] = rgb_colors[i];
    1078:	f4 01       	movw	r30, r8
    107a:	81 91       	ld	r24, Z+
    107c:	91 91       	ld	r25, Z+
    107e:	a1 91       	ld	r26, Z+
    1080:	4f 01       	movw	r8, r30
    1082:	f8 01       	movw	r30, r16
    1084:	81 93       	st	Z+, r24
    1086:	91 93       	st	Z+, r25
    1088:	a1 93       	st	Z+, r26
    108a:	8f 01       	movw	r16, r30
		}
	}
	
	// We only write to the LEDs if there is something to change. (eg. in SWING mode, we update the LEDs almost every cycle)
	if(!tinyLED_RGB_Color_Compare(&rgb_colors, &tinyLED_old_colors)){
		for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
    108c:	8e 14       	cp	r8, r14
    108e:	9f 04       	cpc	r9, r15
    1090:	39 f7       	brne	.-50     	; 0x1060 <tinyLED_update+0x42e>
			tinyLED_SPIWriteByte(rgb_colors[i].red);
			tinyLED_SPIWriteByte(rgb_colors[i].blue);
			tinyLED_old_colors[i] = rgb_colors[i];
		}
	}
}
    1092:	6e 96       	adiw	r28, 0x1e	; 30
    1094:	cd bf       	out	0x3d, r28	; 61
    1096:	de bf       	out	0x3e, r29	; 62
    1098:	df 91       	pop	r29
    109a:	cf 91       	pop	r28
    109c:	1f 91       	pop	r17
    109e:	0f 91       	pop	r16
    10a0:	ff 90       	pop	r15
    10a2:	ef 90       	pop	r14
    10a4:	df 90       	pop	r13
    10a6:	cf 90       	pop	r12
    10a8:	bf 90       	pop	r11
    10aa:	af 90       	pop	r10
    10ac:	9f 90       	pop	r9
    10ae:	8f 90       	pop	r8
    10b0:	7f 90       	pop	r7
    10b2:	6f 90       	pop	r6
    10b4:	5f 90       	pop	r5
    10b6:	4f 90       	pop	r4
    10b8:	3f 90       	pop	r3
    10ba:	2f 90       	pop	r2
    10bc:	08 95       	ret

000010be <tinyPotential_update>:

/*
Update the potential
*/
void tinyPotential_update()
{
    10be:	cf 92       	push	r12
    10c0:	df 92       	push	r13
    10c2:	ef 92       	push	r14
    10c4:	ff 92       	push	r15
Function to decay the potential towards 0
*/
static void tinyPotential_decay()
{
		
	uint8_t time_since_last_update = tinyTime_now() - previous_update_time;
    10c6:	0e 94 69 09 	call	0x12d2	; 0x12d2 <tinyTime_now>
	tinyPotential_potential *= (exp(-((float)time_since_last_update/(float)TINYPOTENTIAL_TIME_CONST)));
    10ca:	80 91 47 38 	lds	r24, 0x3847	; 0x803847 <previous_update_time>
    10ce:	68 1b       	sub	r22, r24
    10d0:	70 e0       	ldi	r23, 0x00	; 0
    10d2:	80 e0       	ldi	r24, 0x00	; 0
    10d4:	90 e0       	ldi	r25, 0x00	; 0
    10d6:	0e 94 bf 0a 	call	0x157e	; 0x157e <__floatunsisf>
    10da:	20 e0       	ldi	r18, 0x00	; 0
    10dc:	30 e0       	ldi	r19, 0x00	; 0
    10de:	48 ec       	ldi	r20, 0xC8	; 200
    10e0:	52 e4       	ldi	r21, 0x42	; 66
    10e2:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <__divsf3>
    10e6:	90 58       	subi	r25, 0x80	; 128
    10e8:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <exp>
    10ec:	20 91 4b 38 	lds	r18, 0x384B	; 0x80384b <tinyPotential_potential>
    10f0:	30 91 4c 38 	lds	r19, 0x384C	; 0x80384c <tinyPotential_potential+0x1>
    10f4:	40 91 4d 38 	lds	r20, 0x384D	; 0x80384d <tinyPotential_potential+0x2>
    10f8:	50 91 4e 38 	lds	r21, 0x384E	; 0x80384e <tinyPotential_potential+0x3>
    10fc:	0e 94 32 0c 	call	0x1864	; 0x1864 <__mulsf3>
    1100:	6b 01       	movw	r12, r22
    1102:	7c 01       	movw	r14, r24
	if(fabs(tinyPotential_potential)<POLARIZATION_OFFSET){
    1104:	9f 77       	andi	r25, 0x7F	; 127
    1106:	2d ec       	ldi	r18, 0xCD	; 205
    1108:	3c ec       	ldi	r19, 0xCC	; 204
    110a:	4c ec       	ldi	r20, 0xCC	; 204
    110c:	5d e3       	ldi	r21, 0x3D	; 61
    110e:	0e 94 df 09 	call	0x13be	; 0x13be <__cmpsf2>
    1112:	88 23       	and	r24, r24
    1114:	4c f0       	brlt	.+18     	; 0x1128 <tinyPotential_update+0x6a>
*/
static void tinyPotential_decay()
{
		
	uint8_t time_since_last_update = tinyTime_now() - previous_update_time;
	tinyPotential_potential *= (exp(-((float)time_since_last_update/(float)TINYPOTENTIAL_TIME_CONST)));
    1116:	c0 92 4b 38 	sts	0x384B, r12	; 0x80384b <tinyPotential_potential>
    111a:	d0 92 4c 38 	sts	0x384C, r13	; 0x80384c <tinyPotential_potential+0x1>
    111e:	e0 92 4d 38 	sts	0x384D, r14	; 0x80384d <tinyPotential_potential+0x2>
    1122:	f0 92 4e 38 	sts	0x384E, r15	; 0x80384e <tinyPotential_potential+0x3>
    1126:	08 c0       	rjmp	.+16     	; 0x1138 <tinyPotential_update+0x7a>
	if(fabs(tinyPotential_potential)<POLARIZATION_OFFSET){
		tinyPotential_potential=0;
    1128:	10 92 4b 38 	sts	0x384B, r1	; 0x80384b <tinyPotential_potential>
    112c:	10 92 4c 38 	sts	0x384C, r1	; 0x80384c <tinyPotential_potential+0x1>
    1130:	10 92 4d 38 	sts	0x384D, r1	; 0x80384d <tinyPotential_potential+0x2>
    1134:	10 92 4e 38 	sts	0x384E, r1	; 0x80384e <tinyPotential_potential+0x3>
	}
	previous_update_time = tinyTime_now();
    1138:	0e 94 69 09 	call	0x12d2	; 0x12d2 <tinyTime_now>
    113c:	60 93 47 38 	sts	0x3847, r22	; 0x803847 <previous_update_time>
    1140:	70 93 48 38 	sts	0x3848, r23	; 0x803848 <previous_update_time+0x1>
    1144:	80 93 49 38 	sts	0x3849, r24	; 0x803849 <previous_update_time+0x2>
    1148:	90 93 4a 38 	sts	0x384A, r25	; 0x80384a <previous_update_time+0x3>
void tinyPotential_update()
{
	//Some of the potential in the neuron has decayed away
	tinyPotential_decay();
	// Update potential with values from Dendrites
	tinyPotential_potential = tinyDendrite_update_potential(tinyPotential_potential);
    114c:	60 91 4b 38 	lds	r22, 0x384B	; 0x80384b <tinyPotential_potential>
    1150:	70 91 4c 38 	lds	r23, 0x384C	; 0x80384c <tinyPotential_potential+0x1>
    1154:	80 91 4d 38 	lds	r24, 0x384D	; 0x80384d <tinyPotential_potential+0x2>
    1158:	90 91 4e 38 	lds	r25, 0x384E	; 0x80384e <tinyPotential_potential+0x3>
    115c:	0e 94 4b 05 	call	0xa96	; 0xa96 <tinyDendrite_update_potential>
    1160:	60 93 4b 38 	sts	0x384B, r22	; 0x80384b <tinyPotential_potential>
    1164:	70 93 4c 38 	sts	0x384C, r23	; 0x80384c <tinyPotential_potential+0x1>
    1168:	80 93 4d 38 	sts	0x384D, r24	; 0x80384d <tinyPotential_potential+0x2>
    116c:	90 93 4e 38 	sts	0x384E, r25	; 0x80384e <tinyPotential_potential+0x3>
	
	// Update potential from button press
	tinyPotential_potential = tinyButton_update_potential(tinyPotential_potential);
    1170:	0e 94 af 03 	call	0x75e	; 0x75e <tinyButton_update_potential>
    1174:	60 93 4b 38 	sts	0x384B, r22	; 0x80384b <tinyPotential_potential>
    1178:	70 93 4c 38 	sts	0x384C, r23	; 0x80384c <tinyPotential_potential+0x1>
    117c:	80 93 4d 38 	sts	0x384D, r24	; 0x80384d <tinyPotential_potential+0x2>
    1180:	90 93 4e 38 	sts	0x384E, r25	; 0x80384e <tinyPotential_potential+0x3>
	
	// Update potential with values from spontaneous pulse.
	tinyPotential_potential = tinyPulse_update_potential(tinyPotential_potential);
    1184:	0e 94 0b 09 	call	0x1216	; 0x1216 <tinyPulse_update_potential>
    1188:	ab 01       	movw	r20, r22
    118a:	bc 01       	movw	r22, r24
    118c:	40 93 4b 38 	sts	0x384B, r20	; 0x80384b <tinyPotential_potential>
    1190:	50 93 4c 38 	sts	0x384C, r21	; 0x80384c <tinyPotential_potential+0x1>
    1194:	60 93 4d 38 	sts	0x384D, r22	; 0x80384d <tinyPotential_potential+0x2>
    1198:	70 93 4e 38 	sts	0x384E, r23	; 0x80384e <tinyPotential_potential+0x3>
	
	tinyDebugger_send_double("Potential", tinyPotential_potential);
    119c:	80 e8       	ldi	r24, 0x80	; 128
    119e:	9a e9       	ldi	r25, 0x9A	; 154
    11a0:	0e 94 3c 04 	call	0x878	; 0x878 <tinyDebugger_send_double>
	
	
	// Let the axon affect the potential
	// This is also where we decide whether or not the axon should fire
	tinyPotential_potential = tinyAxon_update_potential(tinyPotential_potential);
    11a4:	60 91 4b 38 	lds	r22, 0x384B	; 0x80384b <tinyPotential_potential>
    11a8:	70 91 4c 38 	lds	r23, 0x384C	; 0x80384c <tinyPotential_potential+0x1>
    11ac:	80 91 4d 38 	lds	r24, 0x384D	; 0x80384d <tinyPotential_potential+0x2>
    11b0:	90 91 4e 38 	lds	r25, 0x384E	; 0x80384e <tinyPotential_potential+0x3>
    11b4:	0e 94 95 02 	call	0x52a	; 0x52a <tinyAxon_update_potential>
    11b8:	60 93 4b 38 	sts	0x384B, r22	; 0x80384b <tinyPotential_potential>
    11bc:	70 93 4c 38 	sts	0x384C, r23	; 0x80384c <tinyPotential_potential+0x1>
    11c0:	80 93 4d 38 	sts	0x384D, r24	; 0x80384d <tinyPotential_potential+0x2>
    11c4:	90 93 4e 38 	sts	0x384E, r25	; 0x80384e <tinyPotential_potential+0x3>
}
    11c8:	ff 90       	pop	r15
    11ca:	ef 90       	pop	r14
    11cc:	df 90       	pop	r13
    11ce:	cf 90       	pop	r12
    11d0:	08 95       	ret

000011d2 <tinyPulse_toggle_pulse_mode>:
_Bool tinyPulse_is_in_pulse_mode(){
	return pulse_mode;
}

void tinyPulse_toggle_pulse_mode(){
	pulse_mode = !pulse_mode;
    11d2:	90 91 55 38 	lds	r25, 0x3855	; 0x803855 <pulse_mode>
    11d6:	81 e0       	ldi	r24, 0x01	; 1
    11d8:	89 27       	eor	r24, r25
    11da:	80 93 55 38 	sts	0x3855, r24	; 0x803855 <pulse_mode>
	
	if(tinyPulse_is_in_pulse_mode()){
    11de:	88 23       	and	r24, r24
    11e0:	59 f0       	breq	.+22     	; 0x11f8 <tinyPulse_toggle_pulse_mode+0x26>
		tinyLED_set_color_mode(OUT_LED, PULSEMODE_COLOR, WEAK);
    11e2:	41 e0       	ldi	r20, 0x01	; 1
    11e4:	62 e0       	ldi	r22, 0x02	; 2
    11e6:	81 e0       	ldi	r24, 0x01	; 1
    11e8:	0e 94 af 05 	call	0xb5e	; 0xb5e <tinyLED_set_color_mode>
		tinyLED_set_color_mode(INN_LED, PULSEMODE_COLOR, WEAK);
    11ec:	41 e0       	ldi	r20, 0x01	; 1
    11ee:	62 e0       	ldi	r22, 0x02	; 2
    11f0:	80 e0       	ldi	r24, 0x00	; 0
    11f2:	0e 94 af 05 	call	0xb5e	; 0xb5e <tinyLED_set_color_mode>
    11f6:	08 95       	ret
	}
	else{
		tinyLED_set_color(OUT_LED, LED_OFF);
    11f8:	60 e0       	ldi	r22, 0x00	; 0
    11fa:	81 e0       	ldi	r24, 0x01	; 1
    11fc:	0e 94 e5 05 	call	0xbca	; 0xbca <tinyLED_set_color>
		tinyLED_set_color(INN_LED, LED_OFF);
    1200:	60 e0       	ldi	r22, 0x00	; 0
    1202:	80 e0       	ldi	r24, 0x00	; 0
    1204:	0e 94 e5 05 	call	0xbca	; 0xbca <tinyLED_set_color>
    1208:	08 95       	ret

0000120a <tinyPulse_set_pulse_mode>:
	}
}

void tinyPulse_set_pulse_mode(_Bool mode){
	if (pulse_mode != mode)
    120a:	90 91 55 38 	lds	r25, 0x3855	; 0x803855 <pulse_mode>
    120e:	98 13       	cpse	r25, r24
	{
		tinyPulse_toggle_pulse_mode();
    1210:	0e 94 e9 08 	call	0x11d2	; 0x11d2 <tinyPulse_toggle_pulse_mode>
    1214:	08 95       	ret

00001216 <tinyPulse_update_potential>:
	}
}

double tinyPulse_update_potential(double potential){
    1216:	cf 92       	push	r12
    1218:	df 92       	push	r13
    121a:	ef 92       	push	r14
    121c:	ff 92       	push	r15
    121e:	6b 01       	movw	r12, r22
    1220:	7c 01       	movw	r14, r24
	if(pulse_mode){
    1222:	80 91 55 38 	lds	r24, 0x3855	; 0x803855 <pulse_mode>
    1226:	88 23       	and	r24, r24
    1228:	39 f1       	breq	.+78     	; 0x1278 <tinyPulse_update_potential+0x62>
		
		time_since_last_pulse = tinyTime_now() - time_of_last_pulse;
    122a:	0e 94 69 09 	call	0x12d2	; 0x12d2 <tinyTime_now>
    122e:	20 91 51 38 	lds	r18, 0x3851	; 0x803851 <time_of_last_pulse>
    1232:	30 91 52 38 	lds	r19, 0x3852	; 0x803852 <time_of_last_pulse+0x1>
    1236:	62 1b       	sub	r22, r18
    1238:	73 0b       	sbc	r23, r19
    123a:	60 93 4f 38 	sts	0x384F, r22	; 0x80384f <time_since_last_pulse>
    123e:	70 93 50 38 	sts	0x3850, r23	; 0x803850 <time_since_last_pulse+0x1>
		
		if(time_since_last_pulse >= ideal_time_between_pulses){
    1242:	80 91 13 38 	lds	r24, 0x3813	; 0x803813 <ideal_time_between_pulses>
    1246:	90 91 14 38 	lds	r25, 0x3814	; 0x803814 <ideal_time_between_pulses+0x1>
    124a:	68 17       	cp	r22, r24
    124c:	79 07       	cpc	r23, r25
    124e:	a0 f0       	brcs	.+40     	; 0x1278 <tinyPulse_update_potential+0x62>
			// This isn't actually a button press. You could have a separate variable for this, but it seems unnecessary.
			potential += BUTTON_PRESS_REACTION;
    1250:	20 e0       	ldi	r18, 0x00	; 0
    1252:	30 e0       	ldi	r19, 0x00	; 0
    1254:	40 ed       	ldi	r20, 0xD0	; 208
    1256:	51 e4       	ldi	r21, 0x41	; 65
    1258:	c7 01       	movw	r24, r14
    125a:	b6 01       	movw	r22, r12
    125c:	0e 94 73 09 	call	0x12e6	; 0x12e6 <__addsf3>
    1260:	6b 01       	movw	r12, r22
    1262:	7c 01       	movw	r14, r24
			time_of_last_pulse = tinyTime_now();			
    1264:	0e 94 69 09 	call	0x12d2	; 0x12d2 <tinyTime_now>
    1268:	60 93 51 38 	sts	0x3851, r22	; 0x803851 <time_of_last_pulse>
    126c:	70 93 52 38 	sts	0x3852, r23	; 0x803852 <time_of_last_pulse+0x1>
    1270:	80 93 53 38 	sts	0x3853, r24	; 0x803853 <time_of_last_pulse+0x2>
    1274:	90 93 54 38 	sts	0x3854, r25	; 0x803854 <time_of_last_pulse+0x3>
		}
	}
	return potential;
}
    1278:	c7 01       	movw	r24, r14
    127a:	b6 01       	movw	r22, r12
    127c:	ff 90       	pop	r15
    127e:	ef 90       	pop	r14
    1280:	df 90       	pop	r13
    1282:	cf 90       	pop	r12
    1284:	08 95       	ret

00001286 <tinySleep_prepare_sleep>:
  PCMSK |= _BV(PCINT3);                   // Use PB3 as interrupt pin
  ADCSRA &= ~_BV(ADEN);                   // ADC off
  */
  
  //set_sleep_mode(SLEEP_MODE_PWR_DOWN);  // Set sleep mode to POWER DOWN mode
  set_sleep_mode(SLEEP_MODE_IDLE);  // Set sleep mode to POWER DOWN mode
    1286:	e0 e5       	ldi	r30, 0x50	; 80
    1288:	f0 e0       	ldi	r31, 0x00	; 0
    128a:	80 81       	ld	r24, Z
    128c:	89 7f       	andi	r24, 0xF9	; 249
    128e:	80 83       	st	Z, r24
  sleep_enable();
    1290:	80 81       	ld	r24, Z
    1292:	81 60       	ori	r24, 0x01	; 1
    1294:	80 83       	st	Z, r24
    1296:	08 95       	ret

00001298 <tinySleep_enter_sleep>:

void tinySleep_enter_sleep(){

	
  //sleep_bod_disable();
  cli();
    1298:	f8 94       	cli
  sei();
    129a:	78 94       	sei
  sleep_cpu();
    129c:	88 95       	sleep
  sleep_disable();
    129e:	e0 e5       	ldi	r30, 0x50	; 80
    12a0:	f0 e0       	ldi	r31, 0x00	; 0
    12a2:	80 81       	ld	r24, Z
    12a4:	8e 7f       	andi	r24, 0xFE	; 254
    12a6:	80 83       	st	Z, r24
    12a8:	08 95       	ret

000012aa <tinyTime_counter_increment>:
If the Interrupt Service Routine is clocked by a crystal oscillator
it gives a very precise timer-counter.
*/
void tinyTime_counter_increment(void)
{
	time_counter++;
    12aa:	80 91 56 38 	lds	r24, 0x3856	; 0x803856 <time_counter>
    12ae:	90 91 57 38 	lds	r25, 0x3857	; 0x803857 <time_counter+0x1>
    12b2:	a0 91 58 38 	lds	r26, 0x3858	; 0x803858 <time_counter+0x2>
    12b6:	b0 91 59 38 	lds	r27, 0x3859	; 0x803859 <time_counter+0x3>
    12ba:	01 96       	adiw	r24, 0x01	; 1
    12bc:	a1 1d       	adc	r26, r1
    12be:	b1 1d       	adc	r27, r1
    12c0:	80 93 56 38 	sts	0x3856, r24	; 0x803856 <time_counter>
    12c4:	90 93 57 38 	sts	0x3857, r25	; 0x803857 <time_counter+0x1>
    12c8:	a0 93 58 38 	sts	0x3858, r26	; 0x803858 <time_counter+0x2>
    12cc:	b0 93 59 38 	sts	0x3859, r27	; 0x803859 <time_counter+0x3>
    12d0:	08 95       	ret

000012d2 <tinyTime_now>:
/*
This function is callable by external libraries to give them the counted time so far.
*/
uint32_t tinyTime_now(void)
{
	return time_counter;
    12d2:	60 91 56 38 	lds	r22, 0x3856	; 0x803856 <time_counter>
    12d6:	70 91 57 38 	lds	r23, 0x3857	; 0x803857 <time_counter+0x1>
    12da:	80 91 58 38 	lds	r24, 0x3858	; 0x803858 <time_counter+0x2>
    12de:	90 91 59 38 	lds	r25, 0x3859	; 0x803859 <time_counter+0x3>
    12e2:	08 95       	ret

000012e4 <__subsf3>:
    12e4:	50 58       	subi	r21, 0x80	; 128

000012e6 <__addsf3>:
    12e6:	bb 27       	eor	r27, r27
    12e8:	aa 27       	eor	r26, r26
    12ea:	0e 94 8a 09 	call	0x1314	; 0x1314 <__addsf3x>
    12ee:	0c 94 7d 0b 	jmp	0x16fa	; 0x16fa <__fp_round>
    12f2:	0e 94 6f 0b 	call	0x16de	; 0x16de <__fp_pscA>
    12f6:	38 f0       	brcs	.+14     	; 0x1306 <__addsf3+0x20>
    12f8:	0e 94 76 0b 	call	0x16ec	; 0x16ec <__fp_pscB>
    12fc:	20 f0       	brcs	.+8      	; 0x1306 <__addsf3+0x20>
    12fe:	39 f4       	brne	.+14     	; 0x130e <__addsf3+0x28>
    1300:	9f 3f       	cpi	r25, 0xFF	; 255
    1302:	19 f4       	brne	.+6      	; 0x130a <__addsf3+0x24>
    1304:	26 f4       	brtc	.+8      	; 0x130e <__addsf3+0x28>
    1306:	0c 94 45 0b 	jmp	0x168a	; 0x168a <__fp_nan>
    130a:	0e f4       	brtc	.+2      	; 0x130e <__addsf3+0x28>
    130c:	e0 95       	com	r30
    130e:	e7 fb       	bst	r30, 7
    1310:	0c 94 3f 0b 	jmp	0x167e	; 0x167e <__fp_inf>

00001314 <__addsf3x>:
    1314:	e9 2f       	mov	r30, r25
    1316:	0e 94 8e 0b 	call	0x171c	; 0x171c <__fp_split3>
    131a:	58 f3       	brcs	.-42     	; 0x12f2 <__addsf3+0xc>
    131c:	ba 17       	cp	r27, r26
    131e:	62 07       	cpc	r22, r18
    1320:	73 07       	cpc	r23, r19
    1322:	84 07       	cpc	r24, r20
    1324:	95 07       	cpc	r25, r21
    1326:	20 f0       	brcs	.+8      	; 0x1330 <__addsf3x+0x1c>
    1328:	79 f4       	brne	.+30     	; 0x1348 <__addsf3x+0x34>
    132a:	a6 f5       	brtc	.+104    	; 0x1394 <__addsf3x+0x80>
    132c:	0c 94 b0 0b 	jmp	0x1760	; 0x1760 <__fp_zero>
    1330:	0e f4       	brtc	.+2      	; 0x1334 <__addsf3x+0x20>
    1332:	e0 95       	com	r30
    1334:	0b 2e       	mov	r0, r27
    1336:	ba 2f       	mov	r27, r26
    1338:	a0 2d       	mov	r26, r0
    133a:	0b 01       	movw	r0, r22
    133c:	b9 01       	movw	r22, r18
    133e:	90 01       	movw	r18, r0
    1340:	0c 01       	movw	r0, r24
    1342:	ca 01       	movw	r24, r20
    1344:	a0 01       	movw	r20, r0
    1346:	11 24       	eor	r1, r1
    1348:	ff 27       	eor	r31, r31
    134a:	59 1b       	sub	r21, r25
    134c:	99 f0       	breq	.+38     	; 0x1374 <__addsf3x+0x60>
    134e:	59 3f       	cpi	r21, 0xF9	; 249
    1350:	50 f4       	brcc	.+20     	; 0x1366 <__addsf3x+0x52>
    1352:	50 3e       	cpi	r21, 0xE0	; 224
    1354:	68 f1       	brcs	.+90     	; 0x13b0 <__addsf3x+0x9c>
    1356:	1a 16       	cp	r1, r26
    1358:	f0 40       	sbci	r31, 0x00	; 0
    135a:	a2 2f       	mov	r26, r18
    135c:	23 2f       	mov	r18, r19
    135e:	34 2f       	mov	r19, r20
    1360:	44 27       	eor	r20, r20
    1362:	58 5f       	subi	r21, 0xF8	; 248
    1364:	f3 cf       	rjmp	.-26     	; 0x134c <__addsf3x+0x38>
    1366:	46 95       	lsr	r20
    1368:	37 95       	ror	r19
    136a:	27 95       	ror	r18
    136c:	a7 95       	ror	r26
    136e:	f0 40       	sbci	r31, 0x00	; 0
    1370:	53 95       	inc	r21
    1372:	c9 f7       	brne	.-14     	; 0x1366 <__addsf3x+0x52>
    1374:	7e f4       	brtc	.+30     	; 0x1394 <__addsf3x+0x80>
    1376:	1f 16       	cp	r1, r31
    1378:	ba 0b       	sbc	r27, r26
    137a:	62 0b       	sbc	r22, r18
    137c:	73 0b       	sbc	r23, r19
    137e:	84 0b       	sbc	r24, r20
    1380:	ba f0       	brmi	.+46     	; 0x13b0 <__addsf3x+0x9c>
    1382:	91 50       	subi	r25, 0x01	; 1
    1384:	a1 f0       	breq	.+40     	; 0x13ae <__addsf3x+0x9a>
    1386:	ff 0f       	add	r31, r31
    1388:	bb 1f       	adc	r27, r27
    138a:	66 1f       	adc	r22, r22
    138c:	77 1f       	adc	r23, r23
    138e:	88 1f       	adc	r24, r24
    1390:	c2 f7       	brpl	.-16     	; 0x1382 <__addsf3x+0x6e>
    1392:	0e c0       	rjmp	.+28     	; 0x13b0 <__addsf3x+0x9c>
    1394:	ba 0f       	add	r27, r26
    1396:	62 1f       	adc	r22, r18
    1398:	73 1f       	adc	r23, r19
    139a:	84 1f       	adc	r24, r20
    139c:	48 f4       	brcc	.+18     	; 0x13b0 <__addsf3x+0x9c>
    139e:	87 95       	ror	r24
    13a0:	77 95       	ror	r23
    13a2:	67 95       	ror	r22
    13a4:	b7 95       	ror	r27
    13a6:	f7 95       	ror	r31
    13a8:	9e 3f       	cpi	r25, 0xFE	; 254
    13aa:	08 f0       	brcs	.+2      	; 0x13ae <__addsf3x+0x9a>
    13ac:	b0 cf       	rjmp	.-160    	; 0x130e <__addsf3+0x28>
    13ae:	93 95       	inc	r25
    13b0:	88 0f       	add	r24, r24
    13b2:	08 f0       	brcs	.+2      	; 0x13b6 <__addsf3x+0xa2>
    13b4:	99 27       	eor	r25, r25
    13b6:	ee 0f       	add	r30, r30
    13b8:	97 95       	ror	r25
    13ba:	87 95       	ror	r24
    13bc:	08 95       	ret

000013be <__cmpsf2>:
    13be:	0e 94 1b 0b 	call	0x1636	; 0x1636 <__fp_cmp>
    13c2:	08 f4       	brcc	.+2      	; 0x13c6 <__cmpsf2+0x8>
    13c4:	81 e0       	ldi	r24, 0x01	; 1
    13c6:	08 95       	ret

000013c8 <__divsf3>:
    13c8:	0e 94 f8 09 	call	0x13f0	; 0x13f0 <__divsf3x>
    13cc:	0c 94 7d 0b 	jmp	0x16fa	; 0x16fa <__fp_round>
    13d0:	0e 94 76 0b 	call	0x16ec	; 0x16ec <__fp_pscB>
    13d4:	58 f0       	brcs	.+22     	; 0x13ec <__divsf3+0x24>
    13d6:	0e 94 6f 0b 	call	0x16de	; 0x16de <__fp_pscA>
    13da:	40 f0       	brcs	.+16     	; 0x13ec <__divsf3+0x24>
    13dc:	29 f4       	brne	.+10     	; 0x13e8 <__divsf3+0x20>
    13de:	5f 3f       	cpi	r21, 0xFF	; 255
    13e0:	29 f0       	breq	.+10     	; 0x13ec <__divsf3+0x24>
    13e2:	0c 94 3f 0b 	jmp	0x167e	; 0x167e <__fp_inf>
    13e6:	51 11       	cpse	r21, r1
    13e8:	0c 94 b1 0b 	jmp	0x1762	; 0x1762 <__fp_szero>
    13ec:	0c 94 45 0b 	jmp	0x168a	; 0x168a <__fp_nan>

000013f0 <__divsf3x>:
    13f0:	0e 94 8e 0b 	call	0x171c	; 0x171c <__fp_split3>
    13f4:	68 f3       	brcs	.-38     	; 0x13d0 <__divsf3+0x8>

000013f6 <__divsf3_pse>:
    13f6:	99 23       	and	r25, r25
    13f8:	b1 f3       	breq	.-20     	; 0x13e6 <__divsf3+0x1e>
    13fa:	55 23       	and	r21, r21
    13fc:	91 f3       	breq	.-28     	; 0x13e2 <__divsf3+0x1a>
    13fe:	95 1b       	sub	r25, r21
    1400:	55 0b       	sbc	r21, r21
    1402:	bb 27       	eor	r27, r27
    1404:	aa 27       	eor	r26, r26
    1406:	62 17       	cp	r22, r18
    1408:	73 07       	cpc	r23, r19
    140a:	84 07       	cpc	r24, r20
    140c:	38 f0       	brcs	.+14     	; 0x141c <__divsf3_pse+0x26>
    140e:	9f 5f       	subi	r25, 0xFF	; 255
    1410:	5f 4f       	sbci	r21, 0xFF	; 255
    1412:	22 0f       	add	r18, r18
    1414:	33 1f       	adc	r19, r19
    1416:	44 1f       	adc	r20, r20
    1418:	aa 1f       	adc	r26, r26
    141a:	a9 f3       	breq	.-22     	; 0x1406 <__divsf3_pse+0x10>
    141c:	35 d0       	rcall	.+106    	; 0x1488 <__divsf3_pse+0x92>
    141e:	0e 2e       	mov	r0, r30
    1420:	3a f0       	brmi	.+14     	; 0x1430 <__divsf3_pse+0x3a>
    1422:	e0 e8       	ldi	r30, 0x80	; 128
    1424:	32 d0       	rcall	.+100    	; 0x148a <__divsf3_pse+0x94>
    1426:	91 50       	subi	r25, 0x01	; 1
    1428:	50 40       	sbci	r21, 0x00	; 0
    142a:	e6 95       	lsr	r30
    142c:	00 1c       	adc	r0, r0
    142e:	ca f7       	brpl	.-14     	; 0x1422 <__divsf3_pse+0x2c>
    1430:	2b d0       	rcall	.+86     	; 0x1488 <__divsf3_pse+0x92>
    1432:	fe 2f       	mov	r31, r30
    1434:	29 d0       	rcall	.+82     	; 0x1488 <__divsf3_pse+0x92>
    1436:	66 0f       	add	r22, r22
    1438:	77 1f       	adc	r23, r23
    143a:	88 1f       	adc	r24, r24
    143c:	bb 1f       	adc	r27, r27
    143e:	26 17       	cp	r18, r22
    1440:	37 07       	cpc	r19, r23
    1442:	48 07       	cpc	r20, r24
    1444:	ab 07       	cpc	r26, r27
    1446:	b0 e8       	ldi	r27, 0x80	; 128
    1448:	09 f0       	breq	.+2      	; 0x144c <__divsf3_pse+0x56>
    144a:	bb 0b       	sbc	r27, r27
    144c:	80 2d       	mov	r24, r0
    144e:	bf 01       	movw	r22, r30
    1450:	ff 27       	eor	r31, r31
    1452:	93 58       	subi	r25, 0x83	; 131
    1454:	5f 4f       	sbci	r21, 0xFF	; 255
    1456:	3a f0       	brmi	.+14     	; 0x1466 <__divsf3_pse+0x70>
    1458:	9e 3f       	cpi	r25, 0xFE	; 254
    145a:	51 05       	cpc	r21, r1
    145c:	78 f0       	brcs	.+30     	; 0x147c <__divsf3_pse+0x86>
    145e:	0c 94 3f 0b 	jmp	0x167e	; 0x167e <__fp_inf>
    1462:	0c 94 b1 0b 	jmp	0x1762	; 0x1762 <__fp_szero>
    1466:	5f 3f       	cpi	r21, 0xFF	; 255
    1468:	e4 f3       	brlt	.-8      	; 0x1462 <__divsf3_pse+0x6c>
    146a:	98 3e       	cpi	r25, 0xE8	; 232
    146c:	d4 f3       	brlt	.-12     	; 0x1462 <__divsf3_pse+0x6c>
    146e:	86 95       	lsr	r24
    1470:	77 95       	ror	r23
    1472:	67 95       	ror	r22
    1474:	b7 95       	ror	r27
    1476:	f7 95       	ror	r31
    1478:	9f 5f       	subi	r25, 0xFF	; 255
    147a:	c9 f7       	brne	.-14     	; 0x146e <__divsf3_pse+0x78>
    147c:	88 0f       	add	r24, r24
    147e:	91 1d       	adc	r25, r1
    1480:	96 95       	lsr	r25
    1482:	87 95       	ror	r24
    1484:	97 f9       	bld	r25, 7
    1486:	08 95       	ret
    1488:	e1 e0       	ldi	r30, 0x01	; 1
    148a:	66 0f       	add	r22, r22
    148c:	77 1f       	adc	r23, r23
    148e:	88 1f       	adc	r24, r24
    1490:	bb 1f       	adc	r27, r27
    1492:	62 17       	cp	r22, r18
    1494:	73 07       	cpc	r23, r19
    1496:	84 07       	cpc	r24, r20
    1498:	ba 07       	cpc	r27, r26
    149a:	20 f0       	brcs	.+8      	; 0x14a4 <__divsf3_pse+0xae>
    149c:	62 1b       	sub	r22, r18
    149e:	73 0b       	sbc	r23, r19
    14a0:	84 0b       	sbc	r24, r20
    14a2:	ba 0b       	sbc	r27, r26
    14a4:	ee 1f       	adc	r30, r30
    14a6:	88 f7       	brcc	.-30     	; 0x148a <__divsf3_pse+0x94>
    14a8:	e0 95       	com	r30
    14aa:	08 95       	ret
    14ac:	29 f4       	brne	.+10     	; 0x14b8 <__divsf3_pse+0xc2>
    14ae:	16 f0       	brts	.+4      	; 0x14b4 <__divsf3_pse+0xbe>
    14b0:	0c 94 3f 0b 	jmp	0x167e	; 0x167e <__fp_inf>
    14b4:	0c 94 b0 0b 	jmp	0x1760	; 0x1760 <__fp_zero>
    14b8:	0c 94 45 0b 	jmp	0x168a	; 0x168a <__fp_nan>

000014bc <exp>:
    14bc:	0e 94 96 0b 	call	0x172c	; 0x172c <__fp_splitA>
    14c0:	a8 f3       	brcs	.-22     	; 0x14ac <__divsf3_pse+0xb6>
    14c2:	96 38       	cpi	r25, 0x86	; 134
    14c4:	a0 f7       	brcc	.-24     	; 0x14ae <__divsf3_pse+0xb8>
    14c6:	07 f8       	bld	r0, 7
    14c8:	0f 92       	push	r0
    14ca:	e8 94       	clt
    14cc:	2b e3       	ldi	r18, 0x3B	; 59
    14ce:	3a ea       	ldi	r19, 0xAA	; 170
    14d0:	48 eb       	ldi	r20, 0xB8	; 184
    14d2:	5f e7       	ldi	r21, 0x7F	; 127
    14d4:	0e 94 48 0c 	call	0x1890	; 0x1890 <__mulsf3_pse>
    14d8:	0f 92       	push	r0
    14da:	0f 92       	push	r0
    14dc:	0f 92       	push	r0
    14de:	4d b7       	in	r20, 0x3d	; 61
    14e0:	5e b7       	in	r21, 0x3e	; 62
    14e2:	0f 92       	push	r0
    14e4:	0e 94 fe 0b 	call	0x17fc	; 0x17fc <modf>
    14e8:	ec e7       	ldi	r30, 0x7C	; 124
    14ea:	f0 e0       	ldi	r31, 0x00	; 0
    14ec:	0e 94 48 0b 	call	0x1690	; 0x1690 <__fp_powser>
    14f0:	4f 91       	pop	r20
    14f2:	5f 91       	pop	r21
    14f4:	ef 91       	pop	r30
    14f6:	ff 91       	pop	r31
    14f8:	e5 95       	asr	r30
    14fa:	ee 1f       	adc	r30, r30
    14fc:	ff 1f       	adc	r31, r31
    14fe:	49 f0       	breq	.+18     	; 0x1512 <exp+0x56>
    1500:	fe 57       	subi	r31, 0x7E	; 126
    1502:	e0 68       	ori	r30, 0x80	; 128
    1504:	44 27       	eor	r20, r20
    1506:	ee 0f       	add	r30, r30
    1508:	44 1f       	adc	r20, r20
    150a:	fa 95       	dec	r31
    150c:	e1 f7       	brne	.-8      	; 0x1506 <exp+0x4a>
    150e:	41 95       	neg	r20
    1510:	55 0b       	sbc	r21, r21
    1512:	0e 94 c8 0b 	call	0x1790	; 0x1790 <ldexp>
    1516:	0f 90       	pop	r0
    1518:	07 fe       	sbrs	r0, 7
    151a:	0c 94 bc 0b 	jmp	0x1778	; 0x1778 <inverse>
    151e:	08 95       	ret

00001520 <__fixunssfsi>:
    1520:	0e 94 96 0b 	call	0x172c	; 0x172c <__fp_splitA>
    1524:	88 f0       	brcs	.+34     	; 0x1548 <__fixunssfsi+0x28>
    1526:	9f 57       	subi	r25, 0x7F	; 127
    1528:	98 f0       	brcs	.+38     	; 0x1550 <__fixunssfsi+0x30>
    152a:	b9 2f       	mov	r27, r25
    152c:	99 27       	eor	r25, r25
    152e:	b7 51       	subi	r27, 0x17	; 23
    1530:	b0 f0       	brcs	.+44     	; 0x155e <__fixunssfsi+0x3e>
    1532:	e1 f0       	breq	.+56     	; 0x156c <__fixunssfsi+0x4c>
    1534:	66 0f       	add	r22, r22
    1536:	77 1f       	adc	r23, r23
    1538:	88 1f       	adc	r24, r24
    153a:	99 1f       	adc	r25, r25
    153c:	1a f0       	brmi	.+6      	; 0x1544 <__fixunssfsi+0x24>
    153e:	ba 95       	dec	r27
    1540:	c9 f7       	brne	.-14     	; 0x1534 <__fixunssfsi+0x14>
    1542:	14 c0       	rjmp	.+40     	; 0x156c <__fixunssfsi+0x4c>
    1544:	b1 30       	cpi	r27, 0x01	; 1
    1546:	91 f0       	breq	.+36     	; 0x156c <__fixunssfsi+0x4c>
    1548:	0e 94 b0 0b 	call	0x1760	; 0x1760 <__fp_zero>
    154c:	b1 e0       	ldi	r27, 0x01	; 1
    154e:	08 95       	ret
    1550:	0c 94 b0 0b 	jmp	0x1760	; 0x1760 <__fp_zero>
    1554:	67 2f       	mov	r22, r23
    1556:	78 2f       	mov	r23, r24
    1558:	88 27       	eor	r24, r24
    155a:	b8 5f       	subi	r27, 0xF8	; 248
    155c:	39 f0       	breq	.+14     	; 0x156c <__fixunssfsi+0x4c>
    155e:	b9 3f       	cpi	r27, 0xF9	; 249
    1560:	cc f3       	brlt	.-14     	; 0x1554 <__fixunssfsi+0x34>
    1562:	86 95       	lsr	r24
    1564:	77 95       	ror	r23
    1566:	67 95       	ror	r22
    1568:	b3 95       	inc	r27
    156a:	d9 f7       	brne	.-10     	; 0x1562 <__fixunssfsi+0x42>
    156c:	3e f4       	brtc	.+14     	; 0x157c <__fixunssfsi+0x5c>
    156e:	90 95       	com	r25
    1570:	80 95       	com	r24
    1572:	70 95       	com	r23
    1574:	61 95       	neg	r22
    1576:	7f 4f       	sbci	r23, 0xFF	; 255
    1578:	8f 4f       	sbci	r24, 0xFF	; 255
    157a:	9f 4f       	sbci	r25, 0xFF	; 255
    157c:	08 95       	ret

0000157e <__floatunsisf>:
    157e:	e8 94       	clt
    1580:	09 c0       	rjmp	.+18     	; 0x1594 <__floatsisf+0x12>

00001582 <__floatsisf>:
    1582:	97 fb       	bst	r25, 7
    1584:	3e f4       	brtc	.+14     	; 0x1594 <__floatsisf+0x12>
    1586:	90 95       	com	r25
    1588:	80 95       	com	r24
    158a:	70 95       	com	r23
    158c:	61 95       	neg	r22
    158e:	7f 4f       	sbci	r23, 0xFF	; 255
    1590:	8f 4f       	sbci	r24, 0xFF	; 255
    1592:	9f 4f       	sbci	r25, 0xFF	; 255
    1594:	99 23       	and	r25, r25
    1596:	a9 f0       	breq	.+42     	; 0x15c2 <__floatsisf+0x40>
    1598:	f9 2f       	mov	r31, r25
    159a:	96 e9       	ldi	r25, 0x96	; 150
    159c:	bb 27       	eor	r27, r27
    159e:	93 95       	inc	r25
    15a0:	f6 95       	lsr	r31
    15a2:	87 95       	ror	r24
    15a4:	77 95       	ror	r23
    15a6:	67 95       	ror	r22
    15a8:	b7 95       	ror	r27
    15aa:	f1 11       	cpse	r31, r1
    15ac:	f8 cf       	rjmp	.-16     	; 0x159e <__floatsisf+0x1c>
    15ae:	fa f4       	brpl	.+62     	; 0x15ee <__floatsisf+0x6c>
    15b0:	bb 0f       	add	r27, r27
    15b2:	11 f4       	brne	.+4      	; 0x15b8 <__floatsisf+0x36>
    15b4:	60 ff       	sbrs	r22, 0
    15b6:	1b c0       	rjmp	.+54     	; 0x15ee <__floatsisf+0x6c>
    15b8:	6f 5f       	subi	r22, 0xFF	; 255
    15ba:	7f 4f       	sbci	r23, 0xFF	; 255
    15bc:	8f 4f       	sbci	r24, 0xFF	; 255
    15be:	9f 4f       	sbci	r25, 0xFF	; 255
    15c0:	16 c0       	rjmp	.+44     	; 0x15ee <__floatsisf+0x6c>
    15c2:	88 23       	and	r24, r24
    15c4:	11 f0       	breq	.+4      	; 0x15ca <__floatsisf+0x48>
    15c6:	96 e9       	ldi	r25, 0x96	; 150
    15c8:	11 c0       	rjmp	.+34     	; 0x15ec <__floatsisf+0x6a>
    15ca:	77 23       	and	r23, r23
    15cc:	21 f0       	breq	.+8      	; 0x15d6 <__floatsisf+0x54>
    15ce:	9e e8       	ldi	r25, 0x8E	; 142
    15d0:	87 2f       	mov	r24, r23
    15d2:	76 2f       	mov	r23, r22
    15d4:	05 c0       	rjmp	.+10     	; 0x15e0 <__floatsisf+0x5e>
    15d6:	66 23       	and	r22, r22
    15d8:	71 f0       	breq	.+28     	; 0x15f6 <__floatsisf+0x74>
    15da:	96 e8       	ldi	r25, 0x86	; 134
    15dc:	86 2f       	mov	r24, r22
    15de:	70 e0       	ldi	r23, 0x00	; 0
    15e0:	60 e0       	ldi	r22, 0x00	; 0
    15e2:	2a f0       	brmi	.+10     	; 0x15ee <__floatsisf+0x6c>
    15e4:	9a 95       	dec	r25
    15e6:	66 0f       	add	r22, r22
    15e8:	77 1f       	adc	r23, r23
    15ea:	88 1f       	adc	r24, r24
    15ec:	da f7       	brpl	.-10     	; 0x15e4 <__floatsisf+0x62>
    15ee:	88 0f       	add	r24, r24
    15f0:	96 95       	lsr	r25
    15f2:	87 95       	ror	r24
    15f4:	97 f9       	bld	r25, 7
    15f6:	08 95       	ret

000015f8 <fmin>:
    15f8:	99 0f       	add	r25, r25
    15fa:	bb 0b       	sbc	r27, r27
    15fc:	55 0f       	add	r21, r21
    15fe:	aa 0b       	sbc	r26, r26
    1600:	e0 e8       	ldi	r30, 0x80	; 128
    1602:	fe ef       	ldi	r31, 0xFE	; 254
    1604:	16 16       	cp	r1, r22
    1606:	17 06       	cpc	r1, r23
    1608:	e8 07       	cpc	r30, r24
    160a:	f9 07       	cpc	r31, r25
    160c:	70 f0       	brcs	.+28     	; 0x162a <fmin+0x32>
    160e:	12 16       	cp	r1, r18
    1610:	13 06       	cpc	r1, r19
    1612:	e4 07       	cpc	r30, r20
    1614:	f5 07       	cpc	r31, r21
    1616:	60 f0       	brcs	.+24     	; 0x1630 <fmin+0x38>
    1618:	ba 17       	cp	r27, r26
    161a:	54 f0       	brlt	.+20     	; 0x1630 <fmin+0x38>
    161c:	31 f4       	brne	.+12     	; 0x162a <fmin+0x32>
    161e:	26 17       	cp	r18, r22
    1620:	37 07       	cpc	r19, r23
    1622:	48 07       	cpc	r20, r24
    1624:	59 07       	cpc	r21, r25
    1626:	a7 95       	ror	r26
    1628:	1b f4       	brvc	.+6      	; 0x1630 <fmin+0x38>
    162a:	b9 01       	movw	r22, r18
    162c:	ca 01       	movw	r24, r20
    162e:	ba 2f       	mov	r27, r26
    1630:	b6 95       	lsr	r27
    1632:	97 95       	ror	r25
    1634:	08 95       	ret

00001636 <__fp_cmp>:
    1636:	99 0f       	add	r25, r25
    1638:	00 08       	sbc	r0, r0
    163a:	55 0f       	add	r21, r21
    163c:	aa 0b       	sbc	r26, r26
    163e:	e0 e8       	ldi	r30, 0x80	; 128
    1640:	fe ef       	ldi	r31, 0xFE	; 254
    1642:	16 16       	cp	r1, r22
    1644:	17 06       	cpc	r1, r23
    1646:	e8 07       	cpc	r30, r24
    1648:	f9 07       	cpc	r31, r25
    164a:	c0 f0       	brcs	.+48     	; 0x167c <__fp_cmp+0x46>
    164c:	12 16       	cp	r1, r18
    164e:	13 06       	cpc	r1, r19
    1650:	e4 07       	cpc	r30, r20
    1652:	f5 07       	cpc	r31, r21
    1654:	98 f0       	brcs	.+38     	; 0x167c <__fp_cmp+0x46>
    1656:	62 1b       	sub	r22, r18
    1658:	73 0b       	sbc	r23, r19
    165a:	84 0b       	sbc	r24, r20
    165c:	95 0b       	sbc	r25, r21
    165e:	39 f4       	brne	.+14     	; 0x166e <__fp_cmp+0x38>
    1660:	0a 26       	eor	r0, r26
    1662:	61 f0       	breq	.+24     	; 0x167c <__fp_cmp+0x46>
    1664:	23 2b       	or	r18, r19
    1666:	24 2b       	or	r18, r20
    1668:	25 2b       	or	r18, r21
    166a:	21 f4       	brne	.+8      	; 0x1674 <__fp_cmp+0x3e>
    166c:	08 95       	ret
    166e:	0a 26       	eor	r0, r26
    1670:	09 f4       	brne	.+2      	; 0x1674 <__fp_cmp+0x3e>
    1672:	a1 40       	sbci	r26, 0x01	; 1
    1674:	a6 95       	lsr	r26
    1676:	8f ef       	ldi	r24, 0xFF	; 255
    1678:	81 1d       	adc	r24, r1
    167a:	81 1d       	adc	r24, r1
    167c:	08 95       	ret

0000167e <__fp_inf>:
    167e:	97 f9       	bld	r25, 7
    1680:	9f 67       	ori	r25, 0x7F	; 127
    1682:	80 e8       	ldi	r24, 0x80	; 128
    1684:	70 e0       	ldi	r23, 0x00	; 0
    1686:	60 e0       	ldi	r22, 0x00	; 0
    1688:	08 95       	ret

0000168a <__fp_nan>:
    168a:	9f ef       	ldi	r25, 0xFF	; 255
    168c:	80 ec       	ldi	r24, 0xC0	; 192
    168e:	08 95       	ret

00001690 <__fp_powser>:
    1690:	df 93       	push	r29
    1692:	cf 93       	push	r28
    1694:	1f 93       	push	r17
    1696:	0f 93       	push	r16
    1698:	ff 92       	push	r15
    169a:	ef 92       	push	r14
    169c:	df 92       	push	r13
    169e:	7b 01       	movw	r14, r22
    16a0:	8c 01       	movw	r16, r24
    16a2:	68 94       	set
    16a4:	06 c0       	rjmp	.+12     	; 0x16b2 <__fp_powser+0x22>
    16a6:	da 2e       	mov	r13, r26
    16a8:	ef 01       	movw	r28, r30
    16aa:	0e 94 45 0c 	call	0x188a	; 0x188a <__mulsf3x>
    16ae:	fe 01       	movw	r30, r28
    16b0:	e8 94       	clt
    16b2:	a5 91       	lpm	r26, Z+
    16b4:	25 91       	lpm	r18, Z+
    16b6:	35 91       	lpm	r19, Z+
    16b8:	45 91       	lpm	r20, Z+
    16ba:	55 91       	lpm	r21, Z+
    16bc:	a6 f3       	brts	.-24     	; 0x16a6 <__fp_powser+0x16>
    16be:	ef 01       	movw	r28, r30
    16c0:	0e 94 8a 09 	call	0x1314	; 0x1314 <__addsf3x>
    16c4:	fe 01       	movw	r30, r28
    16c6:	97 01       	movw	r18, r14
    16c8:	a8 01       	movw	r20, r16
    16ca:	da 94       	dec	r13
    16cc:	69 f7       	brne	.-38     	; 0x16a8 <__fp_powser+0x18>
    16ce:	df 90       	pop	r13
    16d0:	ef 90       	pop	r14
    16d2:	ff 90       	pop	r15
    16d4:	0f 91       	pop	r16
    16d6:	1f 91       	pop	r17
    16d8:	cf 91       	pop	r28
    16da:	df 91       	pop	r29
    16dc:	08 95       	ret

000016de <__fp_pscA>:
    16de:	00 24       	eor	r0, r0
    16e0:	0a 94       	dec	r0
    16e2:	16 16       	cp	r1, r22
    16e4:	17 06       	cpc	r1, r23
    16e6:	18 06       	cpc	r1, r24
    16e8:	09 06       	cpc	r0, r25
    16ea:	08 95       	ret

000016ec <__fp_pscB>:
    16ec:	00 24       	eor	r0, r0
    16ee:	0a 94       	dec	r0
    16f0:	12 16       	cp	r1, r18
    16f2:	13 06       	cpc	r1, r19
    16f4:	14 06       	cpc	r1, r20
    16f6:	05 06       	cpc	r0, r21
    16f8:	08 95       	ret

000016fa <__fp_round>:
    16fa:	09 2e       	mov	r0, r25
    16fc:	03 94       	inc	r0
    16fe:	00 0c       	add	r0, r0
    1700:	11 f4       	brne	.+4      	; 0x1706 <__fp_round+0xc>
    1702:	88 23       	and	r24, r24
    1704:	52 f0       	brmi	.+20     	; 0x171a <__fp_round+0x20>
    1706:	bb 0f       	add	r27, r27
    1708:	40 f4       	brcc	.+16     	; 0x171a <__fp_round+0x20>
    170a:	bf 2b       	or	r27, r31
    170c:	11 f4       	brne	.+4      	; 0x1712 <__fp_round+0x18>
    170e:	60 ff       	sbrs	r22, 0
    1710:	04 c0       	rjmp	.+8      	; 0x171a <__fp_round+0x20>
    1712:	6f 5f       	subi	r22, 0xFF	; 255
    1714:	7f 4f       	sbci	r23, 0xFF	; 255
    1716:	8f 4f       	sbci	r24, 0xFF	; 255
    1718:	9f 4f       	sbci	r25, 0xFF	; 255
    171a:	08 95       	ret

0000171c <__fp_split3>:
    171c:	57 fd       	sbrc	r21, 7
    171e:	90 58       	subi	r25, 0x80	; 128
    1720:	44 0f       	add	r20, r20
    1722:	55 1f       	adc	r21, r21
    1724:	59 f0       	breq	.+22     	; 0x173c <__fp_splitA+0x10>
    1726:	5f 3f       	cpi	r21, 0xFF	; 255
    1728:	71 f0       	breq	.+28     	; 0x1746 <__fp_splitA+0x1a>
    172a:	47 95       	ror	r20

0000172c <__fp_splitA>:
    172c:	88 0f       	add	r24, r24
    172e:	97 fb       	bst	r25, 7
    1730:	99 1f       	adc	r25, r25
    1732:	61 f0       	breq	.+24     	; 0x174c <__fp_splitA+0x20>
    1734:	9f 3f       	cpi	r25, 0xFF	; 255
    1736:	79 f0       	breq	.+30     	; 0x1756 <__fp_splitA+0x2a>
    1738:	87 95       	ror	r24
    173a:	08 95       	ret
    173c:	12 16       	cp	r1, r18
    173e:	13 06       	cpc	r1, r19
    1740:	14 06       	cpc	r1, r20
    1742:	55 1f       	adc	r21, r21
    1744:	f2 cf       	rjmp	.-28     	; 0x172a <__fp_split3+0xe>
    1746:	46 95       	lsr	r20
    1748:	f1 df       	rcall	.-30     	; 0x172c <__fp_splitA>
    174a:	08 c0       	rjmp	.+16     	; 0x175c <__fp_splitA+0x30>
    174c:	16 16       	cp	r1, r22
    174e:	17 06       	cpc	r1, r23
    1750:	18 06       	cpc	r1, r24
    1752:	99 1f       	adc	r25, r25
    1754:	f1 cf       	rjmp	.-30     	; 0x1738 <__fp_splitA+0xc>
    1756:	86 95       	lsr	r24
    1758:	71 05       	cpc	r23, r1
    175a:	61 05       	cpc	r22, r1
    175c:	08 94       	sec
    175e:	08 95       	ret

00001760 <__fp_zero>:
    1760:	e8 94       	clt

00001762 <__fp_szero>:
    1762:	bb 27       	eor	r27, r27
    1764:	66 27       	eor	r22, r22
    1766:	77 27       	eor	r23, r23
    1768:	cb 01       	movw	r24, r22
    176a:	97 f9       	bld	r25, 7
    176c:	08 95       	ret

0000176e <__gesf2>:
    176e:	0e 94 1b 0b 	call	0x1636	; 0x1636 <__fp_cmp>
    1772:	08 f4       	brcc	.+2      	; 0x1776 <__gesf2+0x8>
    1774:	8f ef       	ldi	r24, 0xFF	; 255
    1776:	08 95       	ret

00001778 <inverse>:
    1778:	9b 01       	movw	r18, r22
    177a:	ac 01       	movw	r20, r24
    177c:	60 e0       	ldi	r22, 0x00	; 0
    177e:	70 e0       	ldi	r23, 0x00	; 0
    1780:	80 e8       	ldi	r24, 0x80	; 128
    1782:	9f e3       	ldi	r25, 0x3F	; 63
    1784:	0c 94 e4 09 	jmp	0x13c8	; 0x13c8 <__divsf3>
    1788:	0c 94 3f 0b 	jmp	0x167e	; 0x167e <__fp_inf>
    178c:	0c 94 a7 0c 	jmp	0x194e	; 0x194e <__fp_mpack>

00001790 <ldexp>:
    1790:	0e 94 96 0b 	call	0x172c	; 0x172c <__fp_splitA>
    1794:	d8 f3       	brcs	.-10     	; 0x178c <inverse+0x14>
    1796:	99 23       	and	r25, r25
    1798:	c9 f3       	breq	.-14     	; 0x178c <inverse+0x14>
    179a:	94 0f       	add	r25, r20
    179c:	51 1d       	adc	r21, r1
    179e:	a3 f3       	brvs	.-24     	; 0x1788 <inverse+0x10>
    17a0:	91 50       	subi	r25, 0x01	; 1
    17a2:	50 40       	sbci	r21, 0x00	; 0
    17a4:	94 f0       	brlt	.+36     	; 0x17ca <ldexp+0x3a>
    17a6:	59 f0       	breq	.+22     	; 0x17be <ldexp+0x2e>
    17a8:	88 23       	and	r24, r24
    17aa:	32 f0       	brmi	.+12     	; 0x17b8 <ldexp+0x28>
    17ac:	66 0f       	add	r22, r22
    17ae:	77 1f       	adc	r23, r23
    17b0:	88 1f       	adc	r24, r24
    17b2:	91 50       	subi	r25, 0x01	; 1
    17b4:	50 40       	sbci	r21, 0x00	; 0
    17b6:	c1 f7       	brne	.-16     	; 0x17a8 <ldexp+0x18>
    17b8:	9e 3f       	cpi	r25, 0xFE	; 254
    17ba:	51 05       	cpc	r21, r1
    17bc:	2c f7       	brge	.-54     	; 0x1788 <inverse+0x10>
    17be:	88 0f       	add	r24, r24
    17c0:	91 1d       	adc	r25, r1
    17c2:	96 95       	lsr	r25
    17c4:	87 95       	ror	r24
    17c6:	97 f9       	bld	r25, 7
    17c8:	08 95       	ret
    17ca:	5f 3f       	cpi	r21, 0xFF	; 255
    17cc:	ac f0       	brlt	.+42     	; 0x17f8 <ldexp+0x68>
    17ce:	98 3e       	cpi	r25, 0xE8	; 232
    17d0:	9c f0       	brlt	.+38     	; 0x17f8 <ldexp+0x68>
    17d2:	bb 27       	eor	r27, r27
    17d4:	86 95       	lsr	r24
    17d6:	77 95       	ror	r23
    17d8:	67 95       	ror	r22
    17da:	b7 95       	ror	r27
    17dc:	08 f4       	brcc	.+2      	; 0x17e0 <ldexp+0x50>
    17de:	b1 60       	ori	r27, 0x01	; 1
    17e0:	93 95       	inc	r25
    17e2:	c1 f7       	brne	.-16     	; 0x17d4 <ldexp+0x44>
    17e4:	bb 0f       	add	r27, r27
    17e6:	58 f7       	brcc	.-42     	; 0x17be <ldexp+0x2e>
    17e8:	11 f4       	brne	.+4      	; 0x17ee <ldexp+0x5e>
    17ea:	60 ff       	sbrs	r22, 0
    17ec:	e8 cf       	rjmp	.-48     	; 0x17be <ldexp+0x2e>
    17ee:	6f 5f       	subi	r22, 0xFF	; 255
    17f0:	7f 4f       	sbci	r23, 0xFF	; 255
    17f2:	8f 4f       	sbci	r24, 0xFF	; 255
    17f4:	9f 4f       	sbci	r25, 0xFF	; 255
    17f6:	e3 cf       	rjmp	.-58     	; 0x17be <ldexp+0x2e>
    17f8:	0c 94 b1 0b 	jmp	0x1762	; 0x1762 <__fp_szero>

000017fc <modf>:
    17fc:	fa 01       	movw	r30, r20
    17fe:	dc 01       	movw	r26, r24
    1800:	aa 0f       	add	r26, r26
    1802:	bb 1f       	adc	r27, r27
    1804:	9b 01       	movw	r18, r22
    1806:	ac 01       	movw	r20, r24
    1808:	bf 57       	subi	r27, 0x7F	; 127
    180a:	28 f4       	brcc	.+10     	; 0x1816 <modf+0x1a>
    180c:	22 27       	eor	r18, r18
    180e:	33 27       	eor	r19, r19
    1810:	44 27       	eor	r20, r20
    1812:	50 78       	andi	r21, 0x80	; 128
    1814:	20 c0       	rjmp	.+64     	; 0x1856 <modf+0x5a>
    1816:	b7 51       	subi	r27, 0x17	; 23
    1818:	90 f4       	brcc	.+36     	; 0x183e <modf+0x42>
    181a:	ab 2f       	mov	r26, r27
    181c:	00 24       	eor	r0, r0
    181e:	46 95       	lsr	r20
    1820:	37 95       	ror	r19
    1822:	27 95       	ror	r18
    1824:	01 1c       	adc	r0, r1
    1826:	a3 95       	inc	r26
    1828:	d2 f3       	brmi	.-12     	; 0x181e <modf+0x22>
    182a:	00 20       	and	r0, r0
    182c:	71 f0       	breq	.+28     	; 0x184a <modf+0x4e>
    182e:	22 0f       	add	r18, r18
    1830:	33 1f       	adc	r19, r19
    1832:	44 1f       	adc	r20, r20
    1834:	b3 95       	inc	r27
    1836:	da f3       	brmi	.-10     	; 0x182e <modf+0x32>
    1838:	0e d0       	rcall	.+28     	; 0x1856 <modf+0x5a>
    183a:	0c 94 72 09 	jmp	0x12e4	; 0x12e4 <__subsf3>
    183e:	61 30       	cpi	r22, 0x01	; 1
    1840:	71 05       	cpc	r23, r1
    1842:	a0 e8       	ldi	r26, 0x80	; 128
    1844:	8a 07       	cpc	r24, r26
    1846:	b9 46       	sbci	r27, 0x69	; 105
    1848:	30 f4       	brcc	.+12     	; 0x1856 <modf+0x5a>
    184a:	9b 01       	movw	r18, r22
    184c:	ac 01       	movw	r20, r24
    184e:	66 27       	eor	r22, r22
    1850:	77 27       	eor	r23, r23
    1852:	88 27       	eor	r24, r24
    1854:	90 78       	andi	r25, 0x80	; 128
    1856:	30 96       	adiw	r30, 0x00	; 0
    1858:	21 f0       	breq	.+8      	; 0x1862 <modf+0x66>
    185a:	20 83       	st	Z, r18
    185c:	31 83       	std	Z+1, r19	; 0x01
    185e:	42 83       	std	Z+2, r20	; 0x02
    1860:	53 83       	std	Z+3, r21	; 0x03
    1862:	08 95       	ret

00001864 <__mulsf3>:
    1864:	0e 94 45 0c 	call	0x188a	; 0x188a <__mulsf3x>
    1868:	0c 94 7d 0b 	jmp	0x16fa	; 0x16fa <__fp_round>
    186c:	0e 94 6f 0b 	call	0x16de	; 0x16de <__fp_pscA>
    1870:	38 f0       	brcs	.+14     	; 0x1880 <__mulsf3+0x1c>
    1872:	0e 94 76 0b 	call	0x16ec	; 0x16ec <__fp_pscB>
    1876:	20 f0       	brcs	.+8      	; 0x1880 <__mulsf3+0x1c>
    1878:	95 23       	and	r25, r21
    187a:	11 f0       	breq	.+4      	; 0x1880 <__mulsf3+0x1c>
    187c:	0c 94 3f 0b 	jmp	0x167e	; 0x167e <__fp_inf>
    1880:	0c 94 45 0b 	jmp	0x168a	; 0x168a <__fp_nan>
    1884:	11 24       	eor	r1, r1
    1886:	0c 94 b1 0b 	jmp	0x1762	; 0x1762 <__fp_szero>

0000188a <__mulsf3x>:
    188a:	0e 94 8e 0b 	call	0x171c	; 0x171c <__fp_split3>
    188e:	70 f3       	brcs	.-36     	; 0x186c <__mulsf3+0x8>

00001890 <__mulsf3_pse>:
    1890:	95 9f       	mul	r25, r21
    1892:	c1 f3       	breq	.-16     	; 0x1884 <__mulsf3+0x20>
    1894:	95 0f       	add	r25, r21
    1896:	50 e0       	ldi	r21, 0x00	; 0
    1898:	55 1f       	adc	r21, r21
    189a:	62 9f       	mul	r22, r18
    189c:	f0 01       	movw	r30, r0
    189e:	72 9f       	mul	r23, r18
    18a0:	bb 27       	eor	r27, r27
    18a2:	f0 0d       	add	r31, r0
    18a4:	b1 1d       	adc	r27, r1
    18a6:	63 9f       	mul	r22, r19
    18a8:	aa 27       	eor	r26, r26
    18aa:	f0 0d       	add	r31, r0
    18ac:	b1 1d       	adc	r27, r1
    18ae:	aa 1f       	adc	r26, r26
    18b0:	64 9f       	mul	r22, r20
    18b2:	66 27       	eor	r22, r22
    18b4:	b0 0d       	add	r27, r0
    18b6:	a1 1d       	adc	r26, r1
    18b8:	66 1f       	adc	r22, r22
    18ba:	82 9f       	mul	r24, r18
    18bc:	22 27       	eor	r18, r18
    18be:	b0 0d       	add	r27, r0
    18c0:	a1 1d       	adc	r26, r1
    18c2:	62 1f       	adc	r22, r18
    18c4:	73 9f       	mul	r23, r19
    18c6:	b0 0d       	add	r27, r0
    18c8:	a1 1d       	adc	r26, r1
    18ca:	62 1f       	adc	r22, r18
    18cc:	83 9f       	mul	r24, r19
    18ce:	a0 0d       	add	r26, r0
    18d0:	61 1d       	adc	r22, r1
    18d2:	22 1f       	adc	r18, r18
    18d4:	74 9f       	mul	r23, r20
    18d6:	33 27       	eor	r19, r19
    18d8:	a0 0d       	add	r26, r0
    18da:	61 1d       	adc	r22, r1
    18dc:	23 1f       	adc	r18, r19
    18de:	84 9f       	mul	r24, r20
    18e0:	60 0d       	add	r22, r0
    18e2:	21 1d       	adc	r18, r1
    18e4:	82 2f       	mov	r24, r18
    18e6:	76 2f       	mov	r23, r22
    18e8:	6a 2f       	mov	r22, r26
    18ea:	11 24       	eor	r1, r1
    18ec:	9f 57       	subi	r25, 0x7F	; 127
    18ee:	50 40       	sbci	r21, 0x00	; 0
    18f0:	9a f0       	brmi	.+38     	; 0x1918 <__mulsf3_pse+0x88>
    18f2:	f1 f0       	breq	.+60     	; 0x1930 <__mulsf3_pse+0xa0>
    18f4:	88 23       	and	r24, r24
    18f6:	4a f0       	brmi	.+18     	; 0x190a <__mulsf3_pse+0x7a>
    18f8:	ee 0f       	add	r30, r30
    18fa:	ff 1f       	adc	r31, r31
    18fc:	bb 1f       	adc	r27, r27
    18fe:	66 1f       	adc	r22, r22
    1900:	77 1f       	adc	r23, r23
    1902:	88 1f       	adc	r24, r24
    1904:	91 50       	subi	r25, 0x01	; 1
    1906:	50 40       	sbci	r21, 0x00	; 0
    1908:	a9 f7       	brne	.-22     	; 0x18f4 <__mulsf3_pse+0x64>
    190a:	9e 3f       	cpi	r25, 0xFE	; 254
    190c:	51 05       	cpc	r21, r1
    190e:	80 f0       	brcs	.+32     	; 0x1930 <__mulsf3_pse+0xa0>
    1910:	0c 94 3f 0b 	jmp	0x167e	; 0x167e <__fp_inf>
    1914:	0c 94 b1 0b 	jmp	0x1762	; 0x1762 <__fp_szero>
    1918:	5f 3f       	cpi	r21, 0xFF	; 255
    191a:	e4 f3       	brlt	.-8      	; 0x1914 <__mulsf3_pse+0x84>
    191c:	98 3e       	cpi	r25, 0xE8	; 232
    191e:	d4 f3       	brlt	.-12     	; 0x1914 <__mulsf3_pse+0x84>
    1920:	86 95       	lsr	r24
    1922:	77 95       	ror	r23
    1924:	67 95       	ror	r22
    1926:	b7 95       	ror	r27
    1928:	f7 95       	ror	r31
    192a:	e7 95       	ror	r30
    192c:	9f 5f       	subi	r25, 0xFF	; 255
    192e:	c1 f7       	brne	.-16     	; 0x1920 <__mulsf3_pse+0x90>
    1930:	fe 2b       	or	r31, r30
    1932:	88 0f       	add	r24, r24
    1934:	91 1d       	adc	r25, r1
    1936:	96 95       	lsr	r25
    1938:	87 95       	ror	r24
    193a:	97 f9       	bld	r25, 7
    193c:	08 95       	ret

0000193e <sin>:
    193e:	9f 93       	push	r25
    1940:	0e 94 b7 0c 	call	0x196e	; 0x196e <__fp_rempio2>
    1944:	0f 90       	pop	r0
    1946:	07 fc       	sbrc	r0, 7
    1948:	ee 5f       	subi	r30, 0xFE	; 254
    194a:	0c 94 e0 0c 	jmp	0x19c0	; 0x19c0 <__fp_sinus>

0000194e <__fp_mpack>:
    194e:	9f 3f       	cpi	r25, 0xFF	; 255
    1950:	31 f0       	breq	.+12     	; 0x195e <__fp_mpack_finite+0xc>

00001952 <__fp_mpack_finite>:
    1952:	91 50       	subi	r25, 0x01	; 1
    1954:	20 f4       	brcc	.+8      	; 0x195e <__fp_mpack_finite+0xc>
    1956:	87 95       	ror	r24
    1958:	77 95       	ror	r23
    195a:	67 95       	ror	r22
    195c:	b7 95       	ror	r27
    195e:	88 0f       	add	r24, r24
    1960:	91 1d       	adc	r25, r1
    1962:	96 95       	lsr	r25
    1964:	87 95       	ror	r24
    1966:	97 f9       	bld	r25, 7
    1968:	08 95       	ret
    196a:	0c 94 45 0b 	jmp	0x168a	; 0x168a <__fp_nan>

0000196e <__fp_rempio2>:
    196e:	0e 94 96 0b 	call	0x172c	; 0x172c <__fp_splitA>
    1972:	d8 f3       	brcs	.-10     	; 0x196a <__fp_mpack_finite+0x18>
    1974:	e8 94       	clt
    1976:	e0 e0       	ldi	r30, 0x00	; 0
    1978:	bb 27       	eor	r27, r27
    197a:	9f 57       	subi	r25, 0x7F	; 127
    197c:	f0 f0       	brcs	.+60     	; 0x19ba <__fp_rempio2+0x4c>
    197e:	2a ed       	ldi	r18, 0xDA	; 218
    1980:	3f e0       	ldi	r19, 0x0F	; 15
    1982:	49 ec       	ldi	r20, 0xC9	; 201
    1984:	06 c0       	rjmp	.+12     	; 0x1992 <__fp_rempio2+0x24>
    1986:	ee 0f       	add	r30, r30
    1988:	bb 0f       	add	r27, r27
    198a:	66 1f       	adc	r22, r22
    198c:	77 1f       	adc	r23, r23
    198e:	88 1f       	adc	r24, r24
    1990:	28 f0       	brcs	.+10     	; 0x199c <__fp_rempio2+0x2e>
    1992:	b2 3a       	cpi	r27, 0xA2	; 162
    1994:	62 07       	cpc	r22, r18
    1996:	73 07       	cpc	r23, r19
    1998:	84 07       	cpc	r24, r20
    199a:	28 f0       	brcs	.+10     	; 0x19a6 <__fp_rempio2+0x38>
    199c:	b2 5a       	subi	r27, 0xA2	; 162
    199e:	62 0b       	sbc	r22, r18
    19a0:	73 0b       	sbc	r23, r19
    19a2:	84 0b       	sbc	r24, r20
    19a4:	e3 95       	inc	r30
    19a6:	9a 95       	dec	r25
    19a8:	72 f7       	brpl	.-36     	; 0x1986 <__fp_rempio2+0x18>
    19aa:	80 38       	cpi	r24, 0x80	; 128
    19ac:	30 f4       	brcc	.+12     	; 0x19ba <__fp_rempio2+0x4c>
    19ae:	9a 95       	dec	r25
    19b0:	bb 0f       	add	r27, r27
    19b2:	66 1f       	adc	r22, r22
    19b4:	77 1f       	adc	r23, r23
    19b6:	88 1f       	adc	r24, r24
    19b8:	d2 f7       	brpl	.-12     	; 0x19ae <__fp_rempio2+0x40>
    19ba:	90 48       	sbci	r25, 0x80	; 128
    19bc:	0c 94 a9 0c 	jmp	0x1952	; 0x1952 <__fp_mpack_finite>

000019c0 <__fp_sinus>:
    19c0:	ef 93       	push	r30
    19c2:	e0 ff       	sbrs	r30, 0
    19c4:	07 c0       	rjmp	.+14     	; 0x19d4 <__fp_sinus+0x14>
    19c6:	a2 ea       	ldi	r26, 0xA2	; 162
    19c8:	2a ed       	ldi	r18, 0xDA	; 218
    19ca:	3f e0       	ldi	r19, 0x0F	; 15
    19cc:	49 ec       	ldi	r20, 0xC9	; 201
    19ce:	5f eb       	ldi	r21, 0xBF	; 191
    19d0:	0e 94 8a 09 	call	0x1314	; 0x1314 <__addsf3x>
    19d4:	0e 94 7d 0b 	call	0x16fa	; 0x16fa <__fp_round>
    19d8:	0f 90       	pop	r0
    19da:	03 94       	inc	r0
    19dc:	01 fc       	sbrc	r0, 1
    19de:	90 58       	subi	r25, 0x80	; 128
    19e0:	e4 ea       	ldi	r30, 0xA4	; 164
    19e2:	f0 e0       	ldi	r31, 0x00	; 0
    19e4:	0c 94 f4 0c 	jmp	0x19e8	; 0x19e8 <__fp_powsodd>

000019e8 <__fp_powsodd>:
    19e8:	9f 93       	push	r25
    19ea:	8f 93       	push	r24
    19ec:	7f 93       	push	r23
    19ee:	6f 93       	push	r22
    19f0:	ff 93       	push	r31
    19f2:	ef 93       	push	r30
    19f4:	9b 01       	movw	r18, r22
    19f6:	ac 01       	movw	r20, r24
    19f8:	0e 94 32 0c 	call	0x1864	; 0x1864 <__mulsf3>
    19fc:	ef 91       	pop	r30
    19fe:	ff 91       	pop	r31
    1a00:	0e 94 48 0b 	call	0x1690	; 0x1690 <__fp_powser>
    1a04:	2f 91       	pop	r18
    1a06:	3f 91       	pop	r19
    1a08:	4f 91       	pop	r20
    1a0a:	5f 91       	pop	r21
    1a0c:	0c 94 32 0c 	jmp	0x1864	; 0x1864 <__mulsf3>

00001a10 <__udivmodsi4>:
    1a10:	a1 e2       	ldi	r26, 0x21	; 33
    1a12:	1a 2e       	mov	r1, r26
    1a14:	aa 1b       	sub	r26, r26
    1a16:	bb 1b       	sub	r27, r27
    1a18:	fd 01       	movw	r30, r26
    1a1a:	0d c0       	rjmp	.+26     	; 0x1a36 <__udivmodsi4_ep>

00001a1c <__udivmodsi4_loop>:
    1a1c:	aa 1f       	adc	r26, r26
    1a1e:	bb 1f       	adc	r27, r27
    1a20:	ee 1f       	adc	r30, r30
    1a22:	ff 1f       	adc	r31, r31
    1a24:	a2 17       	cp	r26, r18
    1a26:	b3 07       	cpc	r27, r19
    1a28:	e4 07       	cpc	r30, r20
    1a2a:	f5 07       	cpc	r31, r21
    1a2c:	20 f0       	brcs	.+8      	; 0x1a36 <__udivmodsi4_ep>
    1a2e:	a2 1b       	sub	r26, r18
    1a30:	b3 0b       	sbc	r27, r19
    1a32:	e4 0b       	sbc	r30, r20
    1a34:	f5 0b       	sbc	r31, r21

00001a36 <__udivmodsi4_ep>:
    1a36:	66 1f       	adc	r22, r22
    1a38:	77 1f       	adc	r23, r23
    1a3a:	88 1f       	adc	r24, r24
    1a3c:	99 1f       	adc	r25, r25
    1a3e:	1a 94       	dec	r1
    1a40:	69 f7       	brne	.-38     	; 0x1a1c <__udivmodsi4_loop>
    1a42:	60 95       	com	r22
    1a44:	70 95       	com	r23
    1a46:	80 95       	com	r24
    1a48:	90 95       	com	r25
    1a4a:	9b 01       	movw	r18, r22
    1a4c:	ac 01       	movw	r20, r24
    1a4e:	bd 01       	movw	r22, r26
    1a50:	cf 01       	movw	r24, r30
    1a52:	08 95       	ret

00001a54 <_exit>:
    1a54:	f8 94       	cli

00001a56 <__stop_program>:
    1a56:	ff cf       	rjmp	.-2      	; 0x1a56 <__stop_program>
