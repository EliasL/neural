
Hjernebyggesett_V4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000016  00803800  0000266a  0000271e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002616  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000054  0000a616  00002616  000026ca  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .bss          0000005a  00803816  00803816  00002734  2**0
                  ALLOC
  4 .comment      0000005c  00000000  00000000  00002734  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002790  2**2
                  CONTENTS, READONLY
  6 .debug_aranges 00000528  00000000  00000000  000027d0  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   00008c14  00000000  00000000  00002cf8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000375a  00000000  00000000  0000b90c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00002ad2  00000000  00000000  0000f066  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000009a0  00000000  00000000  00011b38  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000364f  00000000  00000000  000124d8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000019b3  00000000  00000000  00015b27  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 000003a0  00000000  00000000  000174da  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 de 00 	jmp	0x1bc	; 0x1bc <__ctors_end>
       4:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
       8:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
       c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      10:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      14:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      18:	0c 94 3b 06 	jmp	0xc76	; 0xc76 <__vector_6>
      1c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      20:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      24:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      28:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      2c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      30:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      34:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      38:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      3c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      40:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      44:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      48:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      4c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      50:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      54:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      58:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      5c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      60:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      64:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      68:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      6c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      70:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      74:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      78:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      7c:	07 63       	ori	r16, 0x37	; 55
      7e:	42 36       	cpi	r20, 0x62	; 98
      80:	b7 9b       	sbis	0x16, 7	; 22
      82:	d8 a7       	std	Y+40, r29	; 0x28
      84:	1a 39       	cpi	r17, 0x9A	; 154
      86:	68 56       	subi	r22, 0x68	; 104
      88:	18 ae       	std	Y+56, r1	; 0x38
      8a:	ba ab       	std	Y+50, r27	; 0x32
      8c:	55 8c       	ldd	r5, Z+29	; 0x1d
      8e:	1d 3c       	cpi	r17, 0xCD	; 205
      90:	b7 cc       	rjmp	.-1682   	; 0xfffffa00 <__eeprom_end+0xff7efa00>
      92:	57 63       	ori	r21, 0x37	; 55
      94:	bd 6d       	ori	r27, 0xDD	; 221
      96:	ed fd       	.word	0xfded	; ????
      98:	75 3e       	cpi	r23, 0xE5	; 229
      9a:	f6 17       	cp	r31, r22
      9c:	72 31       	cpi	r23, 0x12	; 18
      9e:	bf 00       	.word	0x00bf	; ????
      a0:	00 00       	nop
      a2:	80 3f       	cpi	r24, 0xF0	; 240
      a4:	05 a8       	ldd	r0, Z+53	; 0x35
      a6:	4c cd       	rjmp	.-1384   	; 0xfffffb40 <__eeprom_end+0xff7efb40>
      a8:	b2 d4       	rcall	.+2404   	; 0xa0e <tinyDebugger_send_double+0x48>
      aa:	4e b9       	out	0x0e, r20	; 14
      ac:	38 36       	cpi	r19, 0x68	; 104
      ae:	a9 02       	muls	r26, r25
      b0:	0c 50       	subi	r16, 0x0C	; 12
      b2:	b9 91       	ld	r27, Y+
      b4:	86 88       	ldd	r8, Z+22	; 0x16
      b6:	08 3c       	cpi	r16, 0xC8	; 200
      b8:	a6 aa       	std	Z+54, r10	; 0x36
      ba:	aa 2a       	or	r10, r26
      bc:	be 00       	.word	0x00be	; ????
      be:	00 00       	nop
      c0:	80 3f       	cpi	r24, 0xF0	; 240

000000c2 <__trampolines_end>:
      c2:	00 40       	sbci	r16, 0x00	; 0
      c4:	7a 10       	cpse	r7, r10
      c6:	f3 5a       	subi	r31, 0xA3	; 163
      c8:	00 a0       	ldd	r0, Z+32	; 0x20
      ca:	72 4e       	sbci	r23, 0xE2	; 226
      cc:	18 09       	sbc	r17, r8
      ce:	00 10       	cpse	r0, r0
      d0:	a5 d4       	rcall	.+2378   	; 0xa1c <tinyDebugger_send_double+0x56>
      d2:	e8 00       	.word	0x00e8	; ????
      d4:	00 e8       	ldi	r16, 0x80	; 128
      d6:	76 48       	sbci	r23, 0x86	; 134
      d8:	17 00       	.word	0x0017	; ????
      da:	00 e4       	ldi	r16, 0x40	; 64
      dc:	0b 54       	subi	r16, 0x4B	; 75
      de:	02 00       	.word	0x0002	; ????
      e0:	00 ca       	rjmp	.-3072   	; 0xfffff4e2 <__eeprom_end+0xff7ef4e2>
      e2:	9a 3b       	cpi	r25, 0xBA	; 186
      e4:	00 00       	nop
      e6:	00 e1       	ldi	r16, 0x10	; 16
      e8:	f5 05       	cpc	r31, r5
      ea:	00 00       	nop
      ec:	80 96       	adiw	r24, 0x20	; 32
      ee:	98 00       	.word	0x0098	; ????
      f0:	00 00       	nop
      f2:	40 42       	sbci	r20, 0x20	; 32
      f4:	0f 00       	.word	0x000f	; ????
      f6:	00 00       	nop
      f8:	a0 86       	std	Z+8, r10	; 0x08
      fa:	01 00       	.word	0x0001	; ????
      fc:	00 00       	nop
      fe:	10 27       	eor	r17, r16
     100:	00 00       	nop
     102:	00 00       	nop
     104:	e8 03       	fmulsu	r22, r16
     106:	00 00       	nop
     108:	00 00       	nop
     10a:	64 00       	.word	0x0064	; ????
     10c:	00 00       	nop
     10e:	00 00       	nop
     110:	0a 00       	.word	0x000a	; ????
     112:	00 00       	nop
     114:	00 00       	nop
     116:	01 00       	.word	0x0001	; ????
     118:	00 00       	nop
     11a:	00 00       	nop
     11c:	2c 76       	andi	r18, 0x6C	; 108
     11e:	d8 88       	ldd	r13, Y+16	; 0x10
     120:	dc 67       	ori	r29, 0x7C	; 124
     122:	4f 08       	sbc	r4, r15
     124:	23 df       	rcall	.-442    	; 0xffffff6c <__eeprom_end+0xff7eff6c>
     126:	c1 df       	rcall	.-126    	; 0xaa <__SREG__+0x6b>
     128:	ae 59       	subi	r26, 0x9E	; 158
     12a:	e1 b1       	in	r30, 0x01	; 1
     12c:	b7 96       	adiw	r30, 0x27	; 39
     12e:	e5 e3       	ldi	r30, 0x35	; 53
     130:	e4 53       	subi	r30, 0x34	; 52
     132:	c6 3a       	cpi	r28, 0xA6	; 166
     134:	e6 51       	subi	r30, 0x16	; 22
     136:	99 76       	andi	r25, 0x69	; 105
     138:	96 e8       	ldi	r25, 0x86	; 134
     13a:	e6 c2       	rjmp	.+1484   	; 0x708 <tinyAxon_update_potential+0xe6>
     13c:	84 26       	eor	r8, r20
     13e:	eb 89       	ldd	r30, Y+19	; 0x13
     140:	8c 9b       	sbis	0x11, 4	; 17
     142:	62 ed       	ldi	r22, 0xD2	; 210
     144:	40 7c       	andi	r20, 0xC0	; 192
     146:	6f fc       	.word	0xfc6f	; ????
     148:	ef bc       	out	0x2f, r14	; 47
     14a:	9c 9f       	mul	r25, r28
     14c:	40 f2       	brcs	.-112    	; 0xde <__trampolines_end+0x1c>
     14e:	ba a5       	ldd	r27, Y+42	; 0x2a
     150:	6f a5       	ldd	r22, Y+47	; 0x2f
     152:	f4 90       	lpm	r15, Z
     154:	05 5a       	subi	r16, 0xA5	; 165
     156:	2a f7       	brpl	.-54     	; 0x122 <__trampolines_end+0x60>
     158:	5c 93       	st	X, r21
     15a:	6b 6c       	ori	r22, 0xCB	; 203
     15c:	f9 67       	ori	r31, 0x79	; 121
     15e:	6d c1       	rjmp	.+730    	; 0x43a <DAC_0_initialization+0xe>
     160:	1b fc       	.word	0xfc1b	; ????
     162:	e0 e4       	ldi	r30, 0x40	; 64
     164:	0d 47       	sbci	r16, 0x7D	; 125
     166:	fe f5       	brtc	.+126    	; 0x1e6 <.do_clear_bss_loop>
     168:	20 e6       	ldi	r18, 0x60	; 96
     16a:	b5 00       	.word	0x00b5	; ????
     16c:	d0 ed       	ldi	r29, 0xD0	; 208
     16e:	90 2e       	mov	r9, r16
     170:	03 00       	.word	0x0003	; ????
     172:	94 35       	cpi	r25, 0x54	; 84
     174:	77 05       	cpc	r23, r7
     176:	00 80       	ld	r0, Z
     178:	84 1e       	adc	r8, r20
     17a:	08 00       	.word	0x0008	; ????
     17c:	00 20       	and	r0, r0
     17e:	4e 0a       	sbc	r4, r30
     180:	00 00       	nop
     182:	00 c8       	rjmp	.-4096   	; 0xfffff184 <__eeprom_end+0xff7ef184>
     184:	0c 33       	cpi	r16, 0x3C	; 60
     186:	33 33       	cpi	r19, 0x33	; 51
     188:	33 0f       	add	r19, r19
     18a:	98 6e       	ori	r25, 0xE8	; 232
     18c:	12 83       	std	Z+2, r17	; 0x02
     18e:	11 41       	sbci	r17, 0x11	; 17
     190:	ef 8d       	ldd	r30, Y+31	; 0x1f
     192:	21 14       	cp	r2, r1
     194:	89 3b       	cpi	r24, 0xB9	; 185
     196:	e6 55       	subi	r30, 0x56	; 86
     198:	16 cf       	rjmp	.-468    	; 0xffffffc6 <__eeprom_end+0xff7effc6>
     19a:	fe e6       	ldi	r31, 0x6E	; 110
     19c:	db 18       	sub	r13, r11
     19e:	d1 84       	ldd	r13, Z+9	; 0x09
     1a0:	4b 38       	cpi	r20, 0x8B	; 139
     1a2:	1b f7       	brvc	.-58     	; 0x16a <__trampolines_end+0xa8>
     1a4:	7c 1d       	adc	r23, r12
     1a6:	90 1d       	adc	r25, r0
     1a8:	a4 bb       	out	0x14, r26	; 20
     1aa:	e4 24       	eor	r14, r4
     1ac:	20 32       	cpi	r18, 0x20	; 32
     1ae:	84 72       	andi	r24, 0x24	; 36
     1b0:	5e 22       	and	r5, r30
     1b2:	81 00       	.word	0x0081	; ????
     1b4:	c9 f1       	breq	.+114    	; 0x228 <main+0x28>
     1b6:	24 ec       	ldi	r18, 0xC4	; 196
     1b8:	a1 e5       	ldi	r26, 0x51	; 81
     1ba:	3d 27       	eor	r19, r29

000001bc <__ctors_end>:
     1bc:	11 24       	eor	r1, r1
     1be:	1f be       	out	0x3f, r1	; 63
     1c0:	cf ef       	ldi	r28, 0xFF	; 255
     1c2:	cd bf       	out	0x3d, r28	; 61
     1c4:	df e3       	ldi	r29, 0x3F	; 63
     1c6:	de bf       	out	0x3e, r29	; 62

000001c8 <__do_copy_data>:
     1c8:	18 e3       	ldi	r17, 0x38	; 56
     1ca:	a0 e0       	ldi	r26, 0x00	; 0
     1cc:	b8 e3       	ldi	r27, 0x38	; 56
     1ce:	ea e6       	ldi	r30, 0x6A	; 106
     1d0:	f6 e2       	ldi	r31, 0x26	; 38
     1d2:	02 c0       	rjmp	.+4      	; 0x1d8 <__do_copy_data+0x10>
     1d4:	05 90       	lpm	r0, Z+
     1d6:	0d 92       	st	X+, r0
     1d8:	a6 31       	cpi	r26, 0x16	; 22
     1da:	b1 07       	cpc	r27, r17
     1dc:	d9 f7       	brne	.-10     	; 0x1d4 <__do_copy_data+0xc>

000001de <__do_clear_bss>:
     1de:	28 e3       	ldi	r18, 0x38	; 56
     1e0:	a6 e1       	ldi	r26, 0x16	; 22
     1e2:	b8 e3       	ldi	r27, 0x38	; 56
     1e4:	01 c0       	rjmp	.+2      	; 0x1e8 <.do_clear_bss_start>

000001e6 <.do_clear_bss_loop>:
     1e6:	1d 92       	st	X+, r1

000001e8 <.do_clear_bss_start>:
     1e8:	a0 37       	cpi	r26, 0x70	; 112
     1ea:	b2 07       	cpc	r27, r18
     1ec:	e1 f7       	brne	.-8      	; 0x1e6 <.do_clear_bss_loop>
     1ee:	0e 94 00 01 	call	0x200	; 0x200 <main>
     1f2:	0c 94 09 13 	jmp	0x2612	; 0x2612 <_exit>

000001f6 <__bad_interrupt>:
     1f6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000001fa <atmel_start_init>:
/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
	system_init();
     1fa:	0e 94 22 02 	call	0x444	; 0x444 <system_init>
     1fe:	08 95       	ret

00000200 <main>:

int main(void)
{	
	
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
     200:	0e 94 fd 00 	call	0x1fa	; 0x1fa <atmel_start_init>
	For some reason, instead of the reference voltage being 4.32v, it is 3.3v. 
	A plausible explanation is that the microchip does not up the voltage, so that if the microchip is only ever 
	supplied with 3.3v, it will output 3.3v as the max.
	*/
	
	VREF.CTRLA |= VREF_DAC0REFSEL_4V34_gc;
     204:	e0 ea       	ldi	r30, 0xA0	; 160
     206:	f0 e0       	ldi	r31, 0x00	; 0
     208:	80 81       	ld	r24, Z
     20a:	83 60       	ori	r24, 0x03	; 3
     20c:	80 83       	st	Z, r24
	//tinyTester_test();
	
	while (1)
	{
		// We don't want to update the neuron too often because of various reasons. The tinyISR_getflag is set every ms, and so the loop is only run once every ms.  
		if(tinyISR_getflag())
     20e:	0e 94 69 06 	call	0xcd2	; 0xcd2 <tinyISR_getflag>
     212:	88 23       	and	r24, r24
     214:	e1 f3       	breq	.-8      	; 0x20e <main+0xe>
		{
			tinyCharge_update_charging_mode();
     216:	0e 94 7c 04 	call	0x8f8	; 0x8f8 <tinyCharge_update_charging_mode>
			
			if(tinyCharge_is_connected_to_charger()){
     21a:	0e 94 41 04 	call	0x882	; 0x882 <tinyCharge_is_connected_to_charger>
     21e:	88 23       	and	r24, r24
     220:	b9 f0       	breq	.+46     	; 0x250 <main+0x50>
				// Charge loop
				
				if(tinyCharge_is_fully_charged()){
     222:	0e 94 44 04 	call	0x888	; 0x888 <tinyCharge_is_fully_charged>
     226:	88 23       	and	r24, r24
     228:	49 f0       	breq	.+18     	; 0x23c <main+0x3c>
					// When the neuron is connected to a charger, and fully charged:
					tinyLED_set_color(INN_LED, CHARGING_DONE_COLOR);
     22a:	63 e0       	ldi	r22, 0x03	; 3
     22c:	80 e0       	ldi	r24, 0x00	; 0
     22e:	0e 94 ac 06 	call	0xd58	; 0xd58 <tinyLED_set_color>
					tinyLED_set_color(OUT_LED, LED_OFF);
     232:	60 e0       	ldi	r22, 0x00	; 0
     234:	81 e0       	ldi	r24, 0x01	; 1
     236:	0e 94 ac 06 	call	0xd58	; 0xd58 <tinyLED_set_color>
     23a:	11 c0       	rjmp	.+34     	; 0x25e <main+0x5e>
				}
				else{
					// When the neuron is charging and is not fully charged
					tinyLED_set_color_mode(OUT_LED, CHARGING_COLOR, SWING);
     23c:	43 e0       	ldi	r20, 0x03	; 3
     23e:	61 e0       	ldi	r22, 0x01	; 1
     240:	81 e0       	ldi	r24, 0x01	; 1
     242:	0e 94 88 06 	call	0xd10	; 0xd10 <tinyLED_set_color_mode>
					tinyLED_set_color(INN_LED, LED_OFF);
     246:	60 e0       	ldi	r22, 0x00	; 0
     248:	80 e0       	ldi	r24, 0x00	; 0
     24a:	0e 94 ac 06 	call	0xd58	; 0xd58 <tinyLED_set_color>
     24e:	07 c0       	rjmp	.+14     	; 0x25e <main+0x5e>
				// Main loop			
				
				// Set LED
				// If the out led is turned LED_OFF, and the ping color is not disabled,
				// we turn on ping mode
				if(tinyLED_get_color(OUT_LED) == LED_OFF && PING_COLOR != LED_OFF){
     250:	81 e0       	ldi	r24, 0x01	; 1
     252:	0e 94 80 06 	call	0xd00	; 0xd00 <tinyLED_get_color>
					tinyLED_set_color_mode(OUT_LED, PING_COLOR, PING);
				}				
				
				// Update button	
				tinyButton_update();
     256:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <tinyButton_update>
				
				// Update the potential (This is where most of the important stuff happens)
				tinyPotential_update();
     25a:	0e 94 f6 08 	call	0x11ec	; 0x11ec <tinyPotential_update>
			}
			// Update LED
			tinyLED_update();
     25e:	0e 94 e0 06 	call	0xdc0	; 0xdc0 <tinyLED_update>
				
			// Switch transistors
			tinyCharge_set_transistors();
     262:	0e 94 b6 04 	call	0x96c	; 0x96c <tinyCharge_set_transistors>
			
			// Prepare for next cycle
			tinyISR_setflag(false);
     266:	80 e0       	ldi	r24, 0x00	; 0
     268:	0e 94 66 06 	call	0xccc	; 0xccc <tinyISR_setflag>
			tinyDebugger_send_uint32("time", tinyTime_now());
     26c:	0e 94 ee 09 	call	0x13dc	; 0x13dc <tinyTime_now>
     270:	ab 01       	movw	r20, r22
     272:	bc 01       	movw	r22, r24
     274:	86 e1       	ldi	r24, 0x16	; 22
     276:	96 ea       	ldi	r25, 0xA6	; 166
     278:	0e 94 c0 04 	call	0x980	; 0x980 <tinyDebugger_send_uint32>
			tinyDebugger_end_line();
     27c:	0e 94 19 05 	call	0xa32	; 0xa32 <tinyDebugger_end_line>
     280:	c6 cf       	rjmp	.-116    	; 0x20e <main+0xe>

00000282 <ADC_0_init>:
 * \return Conversion result read from the ADC_0 ADC module
 */
adc_result_t ADC_0_get_conversion_result(void)
{
	return (ADC1.RES);
}
     282:	e0 e4       	ldi	r30, 0x40	; 64
     284:	f6 e0       	ldi	r31, 0x06	; 6
     286:	80 e1       	ldi	r24, 0x10	; 16
     288:	82 83       	std	Z+2, r24	; 0x02
     28a:	85 e0       	ldi	r24, 0x05	; 5
     28c:	80 83       	st	Z, r24
     28e:	80 e0       	ldi	r24, 0x00	; 0
     290:	08 95       	ret

00000292 <ADC_0_is_conversion_done>:
     292:	80 91 4b 06 	lds	r24, 0x064B	; 0x80064b <__TEXT_REGION_LENGTH__+0x70064b>
     296:	81 70       	andi	r24, 0x01	; 1
     298:	08 95       	ret

0000029a <ADC_0_get_conversion>:
 *
 * \return Nothing
 */
void ADC_0_start_conversion(adc_1_channel_t channel)
{
	ADC1.MUXPOS  = channel;
     29a:	e0 e4       	ldi	r30, 0x40	; 64
     29c:	f6 e0       	ldi	r31, 0x06	; 6
     29e:	86 83       	std	Z+6, r24	; 0x06
	ADC1.COMMAND = ADC_STCONV_bm;
     2a0:	81 e0       	ldi	r24, 0x01	; 1
     2a2:	80 87       	std	Z+8, r24	; 0x08
adc_result_t ADC_0_get_conversion(adc_1_channel_t channel)
{
	adc_result_t res;

	ADC_0_start_conversion(channel);
	while (!ADC_0_is_conversion_done())
     2a4:	0e 94 49 01 	call	0x292	; 0x292 <ADC_0_is_conversion_done>
     2a8:	88 23       	and	r24, r24
     2aa:	e1 f3       	breq	.-8      	; 0x2a4 <ADC_0_get_conversion+0xa>
 *
 * \return Conversion result read from the ADC_0 ADC module
 */
adc_result_t ADC_0_get_conversion_result(void)
{
	return (ADC1.RES);
     2ac:	e0 e4       	ldi	r30, 0x40	; 64
     2ae:	f6 e0       	ldi	r31, 0x06	; 6
     2b0:	20 89       	ldd	r18, Z+16	; 0x10
     2b2:	31 89       	ldd	r19, Z+17	; 0x11

	ADC_0_start_conversion(channel);
	while (!ADC_0_is_conversion_done())
		;
	res = ADC_0_get_conversion_result();
	ADC1.INTFLAGS |= ADC_RESRDY_bm;
     2b4:	93 85       	ldd	r25, Z+11	; 0x0b
     2b6:	91 60       	ori	r25, 0x01	; 1
     2b8:	93 87       	std	Z+11, r25	; 0x0b
	return res;
}
     2ba:	c9 01       	movw	r24, r18
     2bc:	08 95       	ret

000002be <BOD_init>:
	//		 | BOD_VLMCFG_BELOW_gc; /* Interrupt when supply goes below VLM level */

	// BOD.VLMCTRLA = BOD_VLMLVL_5ABOVE_gc; /* VLM threshold 5% above BOD level */

	return 0;
}
     2be:	80 e0       	ldi	r24, 0x00	; 0
     2c0:	08 95       	ret

000002c2 <DIGITAL_GLUE_LOGIC_0_init>:

	// Enable Protected register, peripheral must be disabled (ENABLE=0, in TCD.LUT0CTRLA).

	// CCL.SEQCTRL0 = CCL_SEQSEL_DISABLE_gc /* Sequential logic disabled */;

	CCL.TRUTH0 = 168; /* Truth 0: 168 */
     2c2:	e0 ec       	ldi	r30, 0xC0	; 192
     2c4:	f1 e0       	ldi	r31, 0x01	; 1
     2c6:	28 ea       	ldi	r18, 0xA8	; 168
     2c8:	20 87       	std	Z+8, r18	; 0x08

	CCL.LUT0CTRLC = CCL_INSEL2_TCA0_gc /* TCA0 WO2 input source */;
     2ca:	98 e0       	ldi	r25, 0x08	; 8
     2cc:	97 83       	std	Z+7, r25	; 0x07

	CCL.LUT0CTRLB = CCL_INSEL0_SPI0_gc /* SPI0 SCK source */
     2ce:	8b eb       	ldi	r24, 0xBB	; 187
     2d0:	86 83       	std	Z+6, r24	; 0x06
	                | CCL_INSEL1_SPI0_gc /* SPI0 MOSI input source */;

	CCL.LUT0CTRLA = 0 << CCL_CLKSRC_bp       /* Clock Source Selection: disabled */
     2d2:	39 e0       	ldi	r19, 0x09	; 9
     2d4:	35 83       	std	Z+5, r19	; 0x05
	                | CCL_EDGEDET_DIS_gc     /* Edge detector is disabled */
	                | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	                | 1 << CCL_ENABLE_bp     /* LUT Enable: enabled */
	                | 1 << CCL_OUTEN_bp;     /* Output Enable: enabled */

	CCL.TRUTH1 = 168; /* Truth 1: 168 */
     2d6:	24 87       	std	Z+12, r18	; 0x0c

	CCL.LUT1CTRLC = CCL_INSEL2_TCA0_gc /* TCA0 WO2 input source */;
     2d8:	93 87       	std	Z+11, r25	; 0x0b

	CCL.LUT1CTRLB = CCL_INSEL0_SPI0_gc /* SPI0 SCK source */
     2da:	82 87       	std	Z+10, r24	; 0x0a
	//		 | CCL_EDGEDET_DIS_gc /* Edge detector is disabled */
	//		 | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	//		 | 0 << CCL_ENABLE_bp /* LUT Enable: disabled */
	//		 | 0 << CCL_OUTEN_bp; /* Output Enable: disabled */

	CCL.CTRLA = 1 << CCL_ENABLE_bp      /* Enable: enabled */
     2dc:	81 e4       	ldi	r24, 0x41	; 65
     2de:	80 83       	st	Z, r24
	            | 1 << CCL_RUNSTDBY_bp; /* Run in Standby: enabled */

	return 0;
}
     2e0:	80 e0       	ldi	r24, 0x00	; 0
     2e2:	08 95       	ret

000002e4 <CLKCTRL_init>:
 *       on calling convention. The memory model is not visible to the
 *       preprocessor, so it must be defined in the Assembler preprocessor directives.
 */
static inline void ccp_write_io(void *addr, uint8_t value)
{
	protected_write_io(addr, CCP_IOREG_gc, value);
     2e4:	47 e0       	ldi	r20, 0x07	; 7
     2e6:	68 ed       	ldi	r22, 0xD8	; 216
     2e8:	8c e7       	ldi	r24, 0x7C	; 124
     2ea:	90 e0       	ldi	r25, 0x00	; 0
     2ec:	0e 94 51 02 	call	0x4a2	; 0x4a2 <protected_write_io>
     2f0:	41 e0       	ldi	r20, 0x01	; 1
     2f2:	68 ed       	ldi	r22, 0xD8	; 216
     2f4:	81 e6       	ldi	r24, 0x61	; 97
     2f6:	90 e0       	ldi	r25, 0x00	; 0
     2f8:	0e 94 51 02 	call	0x4a2	; 0x4a2 <protected_write_io>
	//		 | 0 << CLKCTRL_CLKOUT_bp /* System clock out: disabled */);

	// ccp_write_io((void*)&(CLKCTRL.MCLKLOCK),0 << CLKCTRL_LOCKEN_bp /* lock enable: disabled */);

	return 0;
}
     2fc:	80 e0       	ldi	r24, 0x00	; 0
     2fe:	08 95       	ret

00000300 <CPUINT_init>:

	// CPUINT.LVL0PRI = 0x0 << CPUINT_LVL0PRI_gp; /* Interrupt Level Priority: 0x0 */

	// CPUINT.LVL1VEC = 0x0 << CPUINT_LVL1VEC_gp; /* Interrupt Vector with High Priority: 0x0 */

	ENABLE_INTERRUPTS();
     300:	78 94       	sei

	return 0;
}
     302:	80 e0       	ldi	r24, 0x00	; 0
     304:	08 95       	ret

00000306 <DAC_0_init>:
int8_t DAC_0_init()
{

	// DAC0.DATA = 0x0; /* DATA Register: 0x0 */

	DAC0.CTRLA = 1 << DAC_ENABLE_bp      /* DAC Enable: enabled */
     306:	81 e4       	ldi	r24, 0x41	; 65
     308:	80 93 a0 06 	sts	0x06A0, r24	; 0x8006a0 <__TEXT_REGION_LENGTH__+0x7006a0>
	             | 1 << DAC_OUTEN_bp     /* Output Buffer Enable: enabled */
	             | 0 << DAC_RUNSTDBY_bp; /* Run in Standby Mode: disabled */

	return 0;
}
     30c:	80 e0       	ldi	r24, 0x00	; 0
     30e:	08 95       	ret

00000310 <DAC_0_uninit>:
int8_t DAC_0_uninit()
{

	// DAC0.DATA = 0x0; /* DATA Register: 0x0 */

	DAC0.CTRLA = 1 << DAC_ENABLE_bp      /* DAC Enable: enabled */
     310:	81 e0       	ldi	r24, 0x01	; 1
     312:	80 93 a0 06 	sts	0x06A0, r24	; 0x8006a0 <__TEXT_REGION_LENGTH__+0x7006a0>
	| 0 << DAC_OUTEN_bp     /* Output Buffer Enable: disabled */
	| 0 << DAC_RUNSTDBY_bp; /* Run in Standby Mode: disabled */

	return 0;
}
     316:	80 e0       	ldi	r24, 0x00	; 0
     318:	08 95       	ret

0000031a <DAC_0_enable>:
 *
 * \return Nothing
 */
void DAC_0_enable()
{
	DAC0.CTRLA |= DAC_ENABLE_bm;
     31a:	e0 ea       	ldi	r30, 0xA0	; 160
     31c:	f6 e0       	ldi	r31, 0x06	; 6
     31e:	80 81       	ld	r24, Z
     320:	81 60       	ori	r24, 0x01	; 1
     322:	80 83       	st	Z, r24
     324:	08 95       	ret

00000326 <DAC_0_disable>:
 *
 * \return Nothing
 */
void DAC_0_disable()
{
	DAC0.CTRLA &= ~DAC_ENABLE_bm;
     326:	e0 ea       	ldi	r30, 0xA0	; 160
     328:	f6 e0       	ldi	r31, 0x06	; 6
     32a:	80 81       	ld	r24, Z
     32c:	8e 7f       	andi	r24, 0xFE	; 254
     32e:	80 83       	st	Z, r24
     330:	08 95       	ret

00000332 <DAC_0_set_output>:
 *
 * \return Nothing
 */
void DAC_0_set_output(dac_resolution_t value)
{
	DAC0.DATA = value;
     332:	80 93 a1 06 	sts	0x06A1, r24	; 0x8006a1 <__TEXT_REGION_LENGTH__+0x7006a1>
     336:	08 95       	ret

00000338 <mcu_init>:
#ifdef __cplusplus
extern "C" {
#endif

void mcu_init(void)
{
     338:	e0 e1       	ldi	r30, 0x10	; 16
     33a:	f4 e0       	ldi	r31, 0x04	; 4
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     33c:	80 81       	ld	r24, Z
     33e:	88 60       	ori	r24, 0x08	; 8
     340:	81 93       	st	Z+, r24
	 * disables all peripherals to save power. Driver shall enable
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
     342:	e8 31       	cpi	r30, 0x18	; 24
     344:	84 e0       	ldi	r24, 0x04	; 4
     346:	f8 07       	cpc	r31, r24
     348:	c9 f7       	brne	.-14     	; 0x33c <mcu_init+0x4>
     34a:	e0 e3       	ldi	r30, 0x30	; 48
     34c:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     34e:	80 81       	ld	r24, Z
     350:	88 60       	ori	r24, 0x08	; 8
     352:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     354:	e8 33       	cpi	r30, 0x38	; 56
     356:	84 e0       	ldi	r24, 0x04	; 4
     358:	f8 07       	cpc	r31, r24
     35a:	c9 f7       	brne	.-14     	; 0x34e <mcu_init+0x16>
     35c:	e0 e5       	ldi	r30, 0x50	; 80
     35e:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     360:	80 81       	ld	r24, Z
     362:	88 60       	ori	r24, 0x08	; 8
     364:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     366:	e8 35       	cpi	r30, 0x58	; 88
     368:	84 e0       	ldi	r24, 0x04	; 4
     36a:	f8 07       	cpc	r31, r24
     36c:	c9 f7       	brne	.-14     	; 0x360 <mcu_init+0x28>
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}
}
     36e:	08 95       	ret

00000370 <ADC_0_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     370:	e5 e1       	ldi	r30, 0x15	; 21
     372:	f4 e0       	ldi	r31, 0x04	; 4
     374:	80 81       	ld	r24, Z
     376:	88 7f       	andi	r24, 0xF8	; 248
     378:	84 60       	ori	r24, 0x04	; 4
     37a:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     37c:	80 81       	ld	r24, Z
     37e:	87 7f       	andi	r24, 0xF7	; 247
     380:	80 83       	st	Z, r24
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     382:	e7 e1       	ldi	r30, 0x17	; 23
     384:	f4 e0       	ldi	r31, 0x04	; 4
     386:	80 81       	ld	r24, Z
     388:	88 7f       	andi	r24, 0xF8	; 248
     38a:	84 60       	ori	r24, 0x04	; 4
     38c:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     38e:	80 81       	ld	r24, Z
     390:	87 7f       	andi	r24, 0xF7	; 247
     392:	80 83       	st	Z, r24
 */
static inline void PORTC_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     394:	e0 e5       	ldi	r30, 0x50	; 80
     396:	f4 e0       	ldi	r31, 0x04	; 4
     398:	80 81       	ld	r24, Z
     39a:	88 7f       	andi	r24, 0xF8	; 248
     39c:	84 60       	ori	r24, 0x04	; 4
     39e:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     3a0:	80 81       	ld	r24, Z
     3a2:	87 7f       	andi	r24, 0xF7	; 247
     3a4:	80 83       	st	Z, r24
 */
static inline void PORTC_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     3a6:	e1 e5       	ldi	r30, 0x51	; 81
     3a8:	f4 e0       	ldi	r31, 0x04	; 4
     3aa:	80 81       	ld	r24, Z
     3ac:	88 7f       	andi	r24, 0xF8	; 248
     3ae:	84 60       	ori	r24, 0x04	; 4
     3b0:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     3b2:	80 81       	ld	r24, Z
     3b4:	87 7f       	andi	r24, 0xF7	; 247
     3b6:	80 83       	st	Z, r24
 */
static inline void PORTC_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     3b8:	e3 e5       	ldi	r30, 0x53	; 83
     3ba:	f4 e0       	ldi	r31, 0x04	; 4
     3bc:	80 81       	ld	r24, Z
     3be:	88 7f       	andi	r24, 0xF8	; 248
     3c0:	84 60       	ori	r24, 0x04	; 4
     3c2:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     3c4:	80 81       	ld	r24, Z
     3c6:	87 7f       	andi	r24, 0xF7	; 247
     3c8:	80 83       	st	Z, r24
	// Disable digital input buffer
	DEN4_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	DEN4_PIN_set_pull_mode(PORT_PULL_OFF);

	ADC_0_init();
     3ca:	0e 94 41 01 	call	0x282	; 0x282 <ADC_0_init>
     3ce:	08 95       	ret

000003d0 <USART_0_initialization>:
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     3d0:	23 98       	cbi	0x04, 3	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     3d2:	e3 e3       	ldi	r30, 0x33	; 51
     3d4:	f4 e0       	ldi	r31, 0x04	; 4
     3d6:	80 81       	ld	r24, Z
     3d8:	87 7f       	andi	r24, 0xF7	; 247
     3da:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     3dc:	22 9a       	sbi	0x04, 2	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     3de:	2a 98       	cbi	0x05, 2	; 5
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	USART_0_init();
     3e0:	0e 94 8b 02 	call	0x516	; 0x516 <USART_0_init>
     3e4:	08 95       	ret

000003e6 <TIMER_0_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     3e6:	25 9a       	sbi	0x04, 5	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     3e8:	2d 98       	cbi	0x05, 5	; 5
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLC |= PORTMUX_TCA02_bm;
     3ea:	e0 e0       	ldi	r30, 0x00	; 0
     3ec:	f2 e0       	ldi	r31, 0x02	; 2
     3ee:	82 81       	ldd	r24, Z+2	; 0x02
     3f0:	84 60       	ori	r24, 0x04	; 4
     3f2:	82 83       	std	Z+2, r24	; 0x02

	TIMER_0_init();
     3f4:	0e 94 7b 02 	call	0x4f6	; 0x4f6 <TIMER_0_init>
     3f8:	08 95       	ret

000003fa <DIGITAL_GLUE_LOGIC_0_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     3fa:	24 9a       	sbi	0x04, 4	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     3fc:	2c 98       	cbi	0x05, 4	; 5
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLA |= PORTMUX_LUT0_bm;
     3fe:	e0 e0       	ldi	r30, 0x00	; 0
     400:	f2 e0       	ldi	r31, 0x02	; 2
     402:	80 81       	ld	r24, Z
     404:	80 61       	ori	r24, 0x10	; 16
     406:	80 83       	st	Z, r24

	DIGITAL_GLUE_LOGIC_0_init();
     408:	0e 94 61 01 	call	0x2c2	; 0x2c2 <DIGITAL_GLUE_LOGIC_0_init>
     40c:	08 95       	ret

0000040e <SPI_0_initialization>:
 */
static inline void PORTA_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
     40e:	02 98       	cbi	0x00, 2	; 0
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     410:	e2 e1       	ldi	r30, 0x12	; 18
     412:	f4 e0       	ldi	r31, 0x04	; 4
     414:	80 81       	ld	r24, Z
     416:	87 7f       	andi	r24, 0xF7	; 247
     418:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     41a:	01 9a       	sbi	0x00, 1	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     41c:	09 98       	cbi	0x01, 1	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     41e:	03 9a       	sbi	0x00, 3	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     420:	0b 98       	cbi	0x01, 3	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     422:	04 9a       	sbi	0x00, 4	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     424:	0c 98       	cbi	0x01, 4	; 1
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	SPI_0_init();
     426:	0e 94 73 02 	call	0x4e6	; 0x4e6 <SPI_0_init>
     42a:	08 95       	ret

0000042c <DAC_0_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     42c:	e6 e1       	ldi	r30, 0x16	; 22
     42e:	f4 e0       	ldi	r31, 0x04	; 4
     430:	80 81       	ld	r24, Z
     432:	88 7f       	andi	r24, 0xF8	; 248
     434:	84 60       	ori	r24, 0x04	; 4
     436:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     438:	80 81       	ld	r24, Z
     43a:	87 7f       	andi	r24, 0xF7	; 247
     43c:	80 83       	st	Z, r24
	// Disable digital input buffer
	AXON_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	AXON_PIN_set_pull_mode(PORT_PULL_OFF);

	DAC_0_init();
     43e:	0e 94 83 01 	call	0x306	; 0x306 <DAC_0_init>
     442:	08 95       	ret

00000444 <system_init>:
/**
 * \brief System initialization
 */
void system_init()
{
	mcu_init();
     444:	0e 94 9c 01 	call	0x338	; 0x338 <mcu_init>
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     448:	21 9a       	sbi	0x04, 1	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     44a:	29 98       	cbi	0x05, 1	; 5
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     44c:	26 98       	cbi	0x04, 6	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     44e:	e6 e3       	ldi	r30, 0x36	; 54
     450:	f4 e0       	ldi	r31, 0x04	; 4
     452:	80 81       	ld	r24, Z
     454:	87 7f       	andi	r24, 0xF7	; 247
     456:	80 83       	st	Z, r24
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     458:	27 98       	cbi	0x04, 7	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     45a:	e7 e3       	ldi	r30, 0x37	; 55
     45c:	f4 e0       	ldi	r31, 0x04	; 4
     45e:	80 81       	ld	r24, Z
     460:	87 7f       	andi	r24, 0xF7	; 247
     462:	80 83       	st	Z, r24
 */
static inline void PORTC_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
     464:	42 98       	cbi	0x08, 2	; 8
static inline void PORTC_set_pin_pull_mode(const uint8_t pin, const enum port_pull_mode pull_mode)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
     466:	e2 e5       	ldi	r30, 0x52	; 82
     468:	f4 e0       	ldi	r31, 0x04	; 4
     46a:	80 81       	ld	r24, Z
     46c:	88 60       	ori	r24, 0x08	; 8
     46e:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTC.DIR |= (1 << pin);
     470:	45 9a       	sbi	0x08, 5	; 8
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     472:	4d 9a       	sbi	0x09, 5	; 9
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    true);

	CLKCTRL_init();
     474:	0e 94 72 01 	call	0x2e4	; 0x2e4 <CLKCTRL_init>

	RTC_0_init();
     478:	0e 94 55 02 	call	0x4aa	; 0x4aa <RTC_0_init>

	ADC_0_initialization();
     47c:	0e 94 b8 01 	call	0x370	; 0x370 <ADC_0_initialization>

	USART_0_initialization();
     480:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <USART_0_initialization>

	TIMER_0_initialization();
     484:	0e 94 f3 01 	call	0x3e6	; 0x3e6 <TIMER_0_initialization>

	DIGITAL_GLUE_LOGIC_0_initialization();
     488:	0e 94 fd 01 	call	0x3fa	; 0x3fa <DIGITAL_GLUE_LOGIC_0_initialization>

	SPI_0_initialization();
     48c:	0e 94 07 02 	call	0x40e	; 0x40e <SPI_0_initialization>

	DAC_0_initialization();
     490:	0e 94 16 02 	call	0x42c	; 0x42c <DAC_0_initialization>

	CPUINT_init();
     494:	0e 94 80 01 	call	0x300	; 0x300 <CPUINT_init>

	SLPCTRL_init();
     498:	0e 94 71 02 	call	0x4e2	; 0x4e2 <SLPCTRL_init>

	BOD_init();
     49c:	0e 94 5f 01 	call	0x2be	; 0x2be <BOD_init>
     4a0:	08 95       	ret

000004a2 <protected_write_io>:
#if defined(__GNUC__)
  
#ifdef RAMPZ
	out     _SFR_IO_ADDR(RAMPZ), r1         // Clear bits 23:16 of Z
#endif
	movw    r30, r24                // Load addr into Z
     4a2:	fc 01       	movw	r30, r24
	out     CCP, r22                // Start CCP handshake
     4a4:	64 bf       	out	0x34, r22	; 52
	st      Z, r20                  // Write value to I/O register
     4a6:	40 83       	st	Z, r20
	ret                             // Return to caller
     4a8:	08 95       	ret

000004aa <RTC_0_init>:
 * \return Initialization status.
 */
int8_t RTC_0_init()
{

	while (RTC.STATUS > 0) { /* Wait for all register to be synchronized */
     4aa:	e0 e4       	ldi	r30, 0x40	; 64
     4ac:	f1 e0       	ldi	r31, 0x01	; 1
     4ae:	81 81       	ldd	r24, Z+1	; 0x01
     4b0:	81 11       	cpse	r24, r1
     4b2:	fd cf       	rjmp	.-6      	; 0x4ae <RTC_0_init+0x4>
	}

	// RTC.CMP = 0x0; /* Compare: 0x0 */

	RTC.CNT = 0x20; /* Counter: 0x20 */
     4b4:	e0 e4       	ldi	r30, 0x40	; 64
     4b6:	f1 e0       	ldi	r31, 0x01	; 1
     4b8:	80 e2       	ldi	r24, 0x20	; 32
     4ba:	90 e0       	ldi	r25, 0x00	; 0
     4bc:	80 87       	std	Z+8, r24	; 0x08
     4be:	91 87       	std	Z+9, r25	; 0x09

	RTC.CTRLA = RTC_PRESCALER_DIV1_gc   /* 1 */
     4c0:	81 e8       	ldi	r24, 0x81	; 129
     4c2:	80 83       	st	Z, r24
	            | 1 << RTC_RTCEN_bp     /* Enable: enabled */
	            | 1 << RTC_RUNSTDBY_bp; /* Run In Standby: enabled */

	RTC.PER = 0x20 / TIMESCALE; /* Period: 0x20 */
     4c4:	80 e8       	ldi	r24, 0x80	; 128
     4c6:	92 e0       	ldi	r25, 0x02	; 2
     4c8:	82 87       	std	Z+10, r24	; 0x0a
     4ca:	93 87       	std	Z+11, r25	; 0x0b

	// RTC.CLKSEL = RTC_CLKSEL_INT32K_gc; /* 32KHz Internal Ultra Low Power Oscillator (OSCULP32K) */

	RTC.DBGCTRL = 1 << RTC_DBGRUN_bp; /* Run in debug: enabled */
     4cc:	81 e0       	ldi	r24, 0x01	; 1
     4ce:	85 83       	std	Z+5, r24	; 0x05

	RTC.INTCTRL = 0 << RTC_CMP_bp    /* Compare Match Interrupt enable: disabled */
     4d0:	82 83       	std	Z+2, r24	; 0x02
	              | 1 << RTC_OVF_bp; /* Overflow Interrupt enable: enabled */

	while (RTC.PITSTATUS > 0) { /* Wait for all register to be synchronized */
     4d2:	81 89       	ldd	r24, Z+17	; 0x11
     4d4:	81 11       	cpse	r24, r1
     4d6:	fd cf       	rjmp	.-6      	; 0x4d2 <RTC_0_init+0x28>
	}

	RTC.PITCTRLA = RTC_PERIOD_OFF_gc    /* Off */
     4d8:	81 e0       	ldi	r24, 0x01	; 1
     4da:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <__TEXT_REGION_LENGTH__+0x700150>
	// RTC.PITDBGCTRL = 0 << RTC_DBGRUN_bp; /* Run in debug: disabled */

	// RTC.PITINTCTRL = 0 << RTC_PI_bp; /* Periodic Interrupt: disabled */

	return 0;
}
     4de:	80 e0       	ldi	r24, 0x00	; 0
     4e0:	08 95       	ret

000004e2 <SLPCTRL_init>:

	// SLPCTRL.CTRLA = 0 << SLPCTRL_SEN_bp /* Sleep enable: disabled */
	//		 | SLPCTRL_SMODE_IDLE_gc; /* Idle mode */

	return 0;
}
     4e2:	80 e0       	ldi	r24, 0x00	; 0
     4e4:	08 95       	ret

000004e6 <SPI_0_init>:
 * \return Initialization status
 */
int8_t SPI_0_init()
{

	SPI0.CTRLA = 0 << SPI_CLK2X_bp     /* Enable Double Speed: disabled */
     4e6:	e0 e2       	ldi	r30, 0x20	; 32
     4e8:	f8 e0       	ldi	r31, 0x08	; 8
     4ea:	83 e2       	ldi	r24, 0x23	; 35
     4ec:	80 83       	st	Z, r24
	             | 0 << SPI_DORD_bp    /* Data Order Setting: disabled */
	             | 1 << SPI_ENABLE_bp  /* Enable Module: enabled */
	             | 1 << SPI_MASTER_bp  /* SPI module in master mode */
	             | SPI_PRESC_DIV16_gc; /* System Clock / 16 */

	SPI0.CTRLB = 0 << SPI_BUFEN_bp   /* Buffer Mode Enable: disabled */
     4ee:	84 e0       	ldi	r24, 0x04	; 4
     4f0:	81 83       	std	Z+1, r24	; 0x01
	//		 | 0 << SPI_RXCIE_bp /* Receive Complete Interrupt Enable: disabled */
	//		 | 0 << SPI_SSIE_bp /* Slave Select Trigger Interrupt Enable: disabled */
	//		 | 0 << SPI_TXCIE_bp; /* Transfer Complete Interrupt Enable: disabled */

	return 0;
}
     4f2:	80 e0       	ldi	r24, 0x00	; 0
     4f4:	08 95       	ret

000004f6 <TIMER_0_init>:

	// TCA0.SINGLE.CMP0 = 0x0; /* Compare Register 0: 0x0 */

	// TCA0.SINGLE.CMP1 = 0x0; /* Compare Register 1: 0x0 */

	TCA0.SINGLE.CMP2 = 0x4; /* Compare Register 2: 0x4 */
     4f6:	e0 e0       	ldi	r30, 0x00	; 0
     4f8:	fa e0       	ldi	r31, 0x0A	; 10
     4fa:	84 e0       	ldi	r24, 0x04	; 4
     4fc:	90 e0       	ldi	r25, 0x00	; 0
     4fe:	84 a7       	std	Z+44, r24	; 0x2c
     500:	95 a7       	std	Z+45, r25	; 0x2d

	// TCA0.SINGLE.CNT = 0x0; /* Count: 0x0 */

	TCA0.SINGLE.CTRLB = 0 << TCA_SINGLE_ALUPD_bp            /* Auto Lock Update: disabled */
     502:	83 e4       	ldi	r24, 0x43	; 67
     504:	81 83       	std	Z+1, r24	; 0x01
	                    | 0 << TCA_SINGLE_CMP0EN_bp         /* Compare 0 Enable: disabled */
	                    | 0 << TCA_SINGLE_CMP1EN_bp         /* Compare 1 Enable: disabled */
	                    | 1 << TCA_SINGLE_CMP2EN_bp         /* Compare 2 Enable: enabled */
	                    | TCA_SINGLE_WGMODE_SINGLESLOPE_gc; /*  */

	TCA0.SINGLE.CTRLC = 0 << TCA_SINGLE_CMP0OV_bp    /* Compare 0 Waveform Output Value: disabled */
     506:	84 e0       	ldi	r24, 0x04	; 4
     508:	82 83       	std	Z+2, r24	; 0x02
	// TCA0.SINGLE.INTCTRL = 0 << TCA_SINGLE_CMP0_bp /* Compare 0 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP1_bp /* Compare 1 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP2_bp /* Compare 2 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_OVF_bp; /* Overflow Interrupt: disabled */

	TCA0.SINGLE.PER = 0x7; /* Period: 0x7 */
     50a:	87 e0       	ldi	r24, 0x07	; 7
     50c:	90 e0       	ldi	r25, 0x00	; 0
     50e:	86 a3       	std	Z+38, r24	; 0x26
     510:	97 a3       	std	Z+39, r25	; 0x27

	// TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV1_gc /* System Clock */
	//		 | 0 << TCA_SINGLE_ENABLE_bp; /* Module Enable: disabled */

	return 0;
}
     512:	80 e0       	ldi	r24, 0x00	; 0
     514:	08 95       	ret

00000516 <USART_0_init>:
uint8_t USART_0_read()
{
	while (!(USART0.STATUS & USART_RXCIF_bm))
		;
	return USART0.RXDATAL;
}
     516:	e0 e0       	ldi	r30, 0x00	; 0
     518:	f8 e0       	ldi	r31, 0x08	; 8
     51a:	8b e5       	ldi	r24, 0x5B	; 91
     51c:	91 e0       	ldi	r25, 0x01	; 1
     51e:	80 87       	std	Z+8, r24	; 0x08
     520:	91 87       	std	Z+9, r25	; 0x09
     522:	80 ec       	ldi	r24, 0xC0	; 192
     524:	86 83       	std	Z+6, r24	; 0x06
     526:	80 e0       	ldi	r24, 0x00	; 0
     528:	98 e3       	ldi	r25, 0x38	; 56
     52a:	80 93 6c 38 	sts	0x386C, r24	; 0x80386c <__iob+0x2>
     52e:	90 93 6d 38 	sts	0x386D, r25	; 0x80386d <__iob+0x3>
     532:	80 e0       	ldi	r24, 0x00	; 0
     534:	08 95       	ret

00000536 <USART_0_write>:
 *
 * \return Nothing
 */
void USART_0_write(const uint8_t data)
{
	while (!(USART0.STATUS & USART_DREIF_bm))
     536:	e0 e0       	ldi	r30, 0x00	; 0
     538:	f8 e0       	ldi	r31, 0x08	; 8
     53a:	94 81       	ldd	r25, Z+4	; 0x04
     53c:	95 ff       	sbrs	r25, 5
     53e:	fd cf       	rjmp	.-6      	; 0x53a <USART_0_write+0x4>
		;
	USART0.TXDATAL = data;
     540:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <__TEXT_REGION_LENGTH__+0x700802>
     544:	08 95       	ret

00000546 <USART_0_printCHAR>:

#if defined(__GNUC__)

int USART_0_printCHAR(char character, FILE *stream)
{
	USART_0_write(character);
     546:	0e 94 9b 02 	call	0x536	; 0x536 <USART_0_write>
	return 0;
}
     54a:	80 e0       	ldi	r24, 0x00	; 0
     54c:	90 e0       	ldi	r25, 0x00	; 0
     54e:	08 95       	ret

00000550 <tinyAxon_add_pulse>:
{
	// We want to check each slot in the pulse_queue, and
	// if we find an empty slot (0), we add a pulse.
	for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
	{
		if(pulse_queue[i] == 0){
     550:	20 91 16 38 	lds	r18, 0x3816	; 0x803816 <__data_end>
     554:	30 91 17 38 	lds	r19, 0x3817	; 0x803817 <__data_end+0x1>
     558:	23 2b       	or	r18, r19
     55a:	51 f0       	breq	.+20     	; 0x570 <tinyAxon_add_pulse+0x20>
     55c:	e8 e1       	ldi	r30, 0x18	; 24
     55e:	f8 e3       	ldi	r31, 0x38	; 56
     560:	21 e0       	ldi	r18, 0x01	; 1
     562:	30 e0       	ldi	r19, 0x00	; 0
     564:	b9 01       	movw	r22, r18
     566:	41 91       	ld	r20, Z+
     568:	51 91       	ld	r21, Z+
     56a:	45 2b       	or	r20, r21
     56c:	81 f4       	brne	.+32     	; 0x58e <tinyAxon_add_pulse+0x3e>
     56e:	02 c0       	rjmp	.+4      	; 0x574 <tinyAxon_add_pulse+0x24>
     570:	60 e0       	ldi	r22, 0x00	; 0
     572:	70 e0       	ldi	r23, 0x00	; 0
			pulse_queue[i] = new_pulse;
     574:	66 0f       	add	r22, r22
     576:	77 1f       	adc	r23, r23
     578:	fb 01       	movw	r30, r22
     57a:	ea 5e       	subi	r30, 0xEA	; 234
     57c:	f7 4c       	sbci	r31, 0xC7	; 199
     57e:	80 83       	st	Z, r24
     580:	91 83       	std	Z+1, r25	; 0x01
			pulses_in_queue++;
     582:	80 91 2a 38 	lds	r24, 0x382A	; 0x80382a <pulses_in_queue>
     586:	8f 5f       	subi	r24, 0xFF	; 255
     588:	80 93 2a 38 	sts	0x382A, r24	; 0x80382a <pulses_in_queue>
			// We return so we only ever add one
			break;
     58c:	08 95       	ret
     58e:	2f 5f       	subi	r18, 0xFF	; 255
     590:	3f 4f       	sbci	r19, 0xFF	; 255
*/
static void tinyAxon_add_pulse(uint16_t new_pulse)
{
	// We want to check each slot in the pulse_queue, and
	// if we find an empty slot (0), we add a pulse.
	for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
     592:	2a 30       	cpi	r18, 0x0A	; 10
     594:	31 05       	cpc	r19, r1
     596:	31 f7       	brne	.-52     	; 0x564 <tinyAxon_add_pulse+0x14>
     598:	08 95       	ret

0000059a <tinyAxon_is_firing>:
// DAC has no DAC_0_get_output, so we keep track of this here.
uint8_t axonOutputValue = 0;


_Bool tinyAxon_is_firing(){
	return axonOutputValue != NO_SIGNAL_OUTPUT;
     59a:	81 e0       	ldi	r24, 0x01	; 1
     59c:	90 91 2b 38 	lds	r25, 0x382B	; 0x80382b <axonOutputValue>
     5a0:	91 11       	cpse	r25, r1
     5a2:	01 c0       	rjmp	.+2      	; 0x5a6 <tinyAxon_is_firing+0xc>
     5a4:	80 e0       	ldi	r24, 0x00	; 0
}
     5a6:	08 95       	ret

000005a8 <find_newest_pulse>:
uint8_t find_newest_pulse() {
	uint16_t max;
	uint8_t current_index = 0;
	uint8_t return_index = 0;
	
	max = pulse_queue[current_index];
     5a8:	40 91 16 38 	lds	r20, 0x3816	; 0x803816 <__data_end>
     5ac:	50 91 17 38 	lds	r21, 0x3817	; 0x803817 <__data_end+0x1>
     5b0:	e8 e1       	ldi	r30, 0x18	; 24
     5b2:	f8 e3       	ldi	r31, 0x38	; 56
	
// This function will be used with pulse_queue to find the newest pulse
uint8_t find_newest_pulse() {
	uint16_t max;
	uint8_t current_index = 0;
	uint8_t return_index = 0;
     5b4:	80 e0       	ldi	r24, 0x00	; 0
	
	max = pulse_queue[current_index];
	
	for (current_index = 1; current_index < MAX_NUMBER_OF_PULSES; current_index++) {
     5b6:	91 e0       	ldi	r25, 0x01	; 1
		if (pulse_queue[current_index] > max) {
     5b8:	21 91       	ld	r18, Z+
     5ba:	31 91       	ld	r19, Z+
     5bc:	42 17       	cp	r20, r18
     5be:	53 07       	cpc	r21, r19
     5c0:	10 f4       	brcc	.+4      	; 0x5c6 <find_newest_pulse+0x1e>
     5c2:	89 2f       	mov	r24, r25
			return_index = current_index;
			max = pulse_queue[current_index];
     5c4:	a9 01       	movw	r20, r18
	uint8_t current_index = 0;
	uint8_t return_index = 0;
	
	max = pulse_queue[current_index];
	
	for (current_index = 1; current_index < MAX_NUMBER_OF_PULSES; current_index++) {
     5c6:	9f 5f       	subi	r25, 0xFF	; 255
     5c8:	9a 30       	cpi	r25, 0x0A	; 10
     5ca:	b1 f7       	brne	.-20     	; 0x5b8 <find_newest_pulse+0x10>
			return_index = current_index;
			max = pulse_queue[current_index];
		}
	}
	return return_index;
}
     5cc:	08 95       	ret

000005ce <tinyAxon_stop_sending_pulse>:
	tinyLED_set_color_mode(OUT_LED, WHITE, FLASH_ONCE);
}

void tinyAxon_stop_sending_pulse()
{
	DAC_0_set_output(NO_SIGNAL_OUTPUT);
     5ce:	80 e0       	ldi	r24, 0x00	; 0
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	0e 94 99 01 	call	0x332	; 0x332 <DAC_0_set_output>
	axonOutputValue=NO_SIGNAL_OUTPUT;
     5d6:	10 92 2b 38 	sts	0x382B, r1	; 0x80382b <axonOutputValue>
     5da:	08 95       	ret

000005dc <tinyAxon_remove_pulse>:

/*
If the potential is very low, we want to try to remove a pulse.
*/
bool tinyAxon_remove_pulse(void)
{
     5dc:	cf 93       	push	r28
	// We want to return a bool indicating whether or not a pulse actually was removed.
	if(pulses_in_queue == 0){
     5de:	c0 91 2a 38 	lds	r28, 0x382A	; 0x80382a <pulses_in_queue>
     5e2:	cc 23       	and	r28, r28
     5e4:	c9 f0       	breq	.+50     	; 0x618 <tinyAxon_remove_pulse+0x3c>
		//There was no pulse to remove.
		return false;
	}
	else{
		// If we are to remove a pulse, we want to remove the one that will fire last.
		uint8_t pulse_index = find_newest_pulse();
     5e6:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <find_newest_pulse>
		uint16_t newest_pulse = pulse_queue[pulse_index];
     5ea:	90 e0       	ldi	r25, 0x00	; 0
     5ec:	fc 01       	movw	r30, r24
     5ee:	ee 0f       	add	r30, r30
     5f0:	ff 1f       	adc	r31, r31
     5f2:	ea 5e       	subi	r30, 0xEA	; 234
     5f4:	f7 4c       	sbci	r31, 0xC7	; 199
	
		// Now we want to check if the pulse is too far away to be affected by the low potential, or close enough that we decide to remove it.
		// (When we say that the pulse is too far away, it refers to the biological process of how the potential spreads from Dendrites to axon).
		if(newest_pulse > PULSE_NO_RETURN_TIME){
     5f6:	20 81       	ld	r18, Z
     5f8:	31 81       	ldd	r19, Z+1	; 0x01
     5fa:	2d 33       	cpi	r18, 0x3D	; 61
     5fc:	31 05       	cpc	r19, r1
     5fe:	70 f0       	brcs	.+28     	; 0x61c <tinyAxon_remove_pulse+0x40>
			// We decided to remove the pulse
			pulse_queue[pulse_index] = 0;
     600:	88 0f       	add	r24, r24
     602:	99 1f       	adc	r25, r25
     604:	fc 01       	movw	r30, r24
     606:	ea 5e       	subi	r30, 0xEA	; 234
     608:	f7 4c       	sbci	r31, 0xC7	; 199
     60a:	10 82       	st	Z, r1
     60c:	11 82       	std	Z+1, r1	; 0x01
			pulses_in_queue--;
     60e:	c1 50       	subi	r28, 0x01	; 1
     610:	c0 93 2a 38 	sts	0x382A, r28	; 0x80382a <pulses_in_queue>
			return true;
     614:	81 e0       	ldi	r24, 0x01	; 1
     616:	03 c0       	rjmp	.+6      	; 0x61e <tinyAxon_remove_pulse+0x42>
bool tinyAxon_remove_pulse(void)
{
	// We want to return a bool indicating whether or not a pulse actually was removed.
	if(pulses_in_queue == 0){
		//There was no pulse to remove.
		return false;
     618:	80 e0       	ldi	r24, 0x00	; 0
     61a:	01 c0       	rjmp	.+2      	; 0x61e <tinyAxon_remove_pulse+0x42>
			pulses_in_queue--;
			return true;
		}
		// Here we have found that there is a pulse queued, but it is old enough to let pass anyway, so now we need to put it back into the queue.
		else{
			return false;
     61c:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     61e:	cf 91       	pop	r28
     620:	08 95       	ret

00000622 <tinyAxon_update_potential>:
/*
Decides whether or not the axon should fire
If the axon does fire, the potential is reduced
*/
double tinyAxon_update_potential(double potential)
{	
     622:	cf 92       	push	r12
     624:	df 92       	push	r13
     626:	ef 92       	push	r14
     628:	ff 92       	push	r15
     62a:	6b 01       	movw	r12, r22
     62c:	7c 01       	movw	r14, r24
	//While the neuron has enough potential to fire, we want to fire more
	while (potential >= THRESHOLD_POTENTIAL)
     62e:	20 e0       	ldi	r18, 0x00	; 0
     630:	30 e0       	ldi	r19, 0x00	; 0
     632:	48 ec       	ldi	r20, 0xC8	; 200
     634:	51 e4       	ldi	r21, 0x41	; 65
     636:	0e 94 3c 0c 	call	0x1878	; 0x1878 <__gesf2>
     63a:	88 23       	and	r24, r24
     63c:	bc f1       	brlt	.+110    	; 0x6ac <tinyAxon_update_potential+0x8a>
	{
		// We have to check if there are already queued pulses, so that the frequency never exceeds FIRE_DELAY
		if(pulses_in_queue>0){
     63e:	80 91 2a 38 	lds	r24, 0x382A	; 0x80382a <pulses_in_queue>
     642:	88 23       	and	r24, r24
     644:	b1 f0       	breq	.+44     	; 0x672 <tinyAxon_update_potential+0x50>
			uint16_t newest_pulse = pulse_queue[find_newest_pulse()];
     646:	0e 94 d4 02 	call	0x5a8	; 0x5a8 <find_newest_pulse>
     64a:	e8 2f       	mov	r30, r24
     64c:	f0 e0       	ldi	r31, 0x00	; 0
     64e:	ee 0f       	add	r30, r30
     650:	ff 1f       	adc	r31, r31
     652:	ea 5e       	subi	r30, 0xEA	; 234
     654:	f7 4c       	sbci	r31, 0xC7	; 199
			
			// There is at least one pulse in the queue, and it is "so close", that we need to offset the new pulse, so that we keep at least
			// one FIRE_DELAY between each pulse
			if(newest_pulse + FIRE_DELAY > TRAVLE_DELAY){
     656:	80 81       	ld	r24, Z
     658:	91 81       	ldd	r25, Z+1	; 0x01
     65a:	0a 96       	adiw	r24, 0x0a	; 10
     65c:	85 36       	cpi	r24, 0x65	; 101
     65e:	91 05       	cpc	r25, r1
     660:	18 f0       	brcs	.+6      	; 0x668 <tinyAxon_update_potential+0x46>
				tinyAxon_add_pulse(newest_pulse + FIRE_DELAY);
     662:	0e 94 a8 02 	call	0x550	; 0x550 <tinyAxon_add_pulse>
     666:	09 c0       	rjmp	.+18     	; 0x67a <tinyAxon_update_potential+0x58>
			}
			// There is at least one pulse in the queue, but it's "far enough away" to ignore
			else{
				tinyAxon_add_pulse(TRAVLE_DELAY);
     668:	84 e6       	ldi	r24, 0x64	; 100
     66a:	90 e0       	ldi	r25, 0x00	; 0
     66c:	0e 94 a8 02 	call	0x550	; 0x550 <tinyAxon_add_pulse>
     670:	04 c0       	rjmp	.+8      	; 0x67a <tinyAxon_update_potential+0x58>
			}
		}
		// There are no pulses in the queue, so we add a pulse as normal
		else{
			tinyAxon_add_pulse(TRAVLE_DELAY);		
     672:	84 e6       	ldi	r24, 0x64	; 100
     674:	90 e0       	ldi	r25, 0x00	; 0
     676:	0e 94 a8 02 	call	0x550	; 0x550 <tinyAxon_add_pulse>
		}
		
		potential += POSTFIRE_POTENTIAL_REACTION; // This is usually defined as a negative value, don't be confused by the +=
     67a:	20 e0       	ldi	r18, 0x00	; 0
     67c:	30 e0       	ldi	r19, 0x00	; 0
     67e:	48 ec       	ldi	r20, 0xC8	; 200
     680:	51 e4       	ldi	r21, 0x41	; 65
     682:	c7 01       	movw	r24, r14
     684:	b6 01       	movw	r22, r12
     686:	0e 94 f7 09 	call	0x13ee	; 0x13ee <__subsf3>
     68a:	6b 01       	movw	r12, r22
     68c:	7c 01       	movw	r14, r24
		
		tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
     68e:	45 e0       	ldi	r20, 0x05	; 5
     690:	63 e0       	ldi	r22, 0x03	; 3
     692:	80 e0       	ldi	r24, 0x00	; 0
     694:	0e 94 88 06 	call	0xd10	; 0xd10 <tinyLED_set_color_mode>
If the axon does fire, the potential is reduced
*/
double tinyAxon_update_potential(double potential)
{	
	//While the neuron has enough potential to fire, we want to fire more
	while (potential >= THRESHOLD_POTENTIAL)
     698:	20 e0       	ldi	r18, 0x00	; 0
     69a:	30 e0       	ldi	r19, 0x00	; 0
     69c:	48 ec       	ldi	r20, 0xC8	; 200
     69e:	51 e4       	ldi	r21, 0x41	; 65
     6a0:	c7 01       	movw	r24, r14
     6a2:	b6 01       	movw	r22, r12
     6a4:	0e 94 3c 0c 	call	0x1878	; 0x1878 <__gesf2>
     6a8:	88 23       	and	r24, r24
     6aa:	4c f6       	brge	.-110    	; 0x63e <tinyAxon_update_potential+0x1c>
		
		tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
	}
	
	// If the neuron has a very low potential, we want to remove a pulse from the queue (if there is one)
	if(potential < -THRESHOLD_POTENTIAL)
     6ac:	20 e0       	ldi	r18, 0x00	; 0
     6ae:	30 e0       	ldi	r19, 0x00	; 0
     6b0:	48 ec       	ldi	r20, 0xC8	; 200
     6b2:	51 ec       	ldi	r21, 0xC1	; 193
     6b4:	c7 01       	movw	r24, r14
     6b6:	b6 01       	movw	r22, r12
     6b8:	0e 94 64 0a 	call	0x14c8	; 0x14c8 <__cmpsf2>
     6bc:	88 23       	and	r24, r24
     6be:	0c f0       	brlt	.+2      	; 0x6c2 <tinyAxon_update_potential+0xa0>
     6c0:	46 c0       	rjmp	.+140    	; 0x74e <tinyAxon_update_potential+0x12c>
	{
		if(pulses_in_queue > 0) // Perhaps this should be a separate variable? For now, we will just simply use -THRESHOLD_POTENTIAL
     6c2:	80 91 2a 38 	lds	r24, 0x382A	; 0x80382a <pulses_in_queue>
     6c6:	88 23       	and	r24, r24
     6c8:	11 f1       	breq	.+68     	; 0x70e <tinyAxon_update_potential+0xec>
		{
			// The neurons potential is low enough to attempt to remove a queued fire (Fire less)
			if(tinyAxon_remove_pulse())
     6ca:	0e 94 ee 02 	call	0x5dc	; 0x5dc <tinyAxon_remove_pulse>
     6ce:	88 23       	and	r24, r24
     6d0:	f1 f1       	breq	.+124    	; 0x74e <tinyAxon_update_potential+0x12c>
			{
				// The potential has evened out a bit
				potential += THRESHOLD_POTENTIAL;
     6d2:	20 e0       	ldi	r18, 0x00	; 0
     6d4:	30 e0       	ldi	r19, 0x00	; 0
     6d6:	48 ec       	ldi	r20, 0xC8	; 200
     6d8:	51 e4       	ldi	r21, 0x41	; 65
     6da:	c7 01       	movw	r24, r14
     6dc:	b6 01       	movw	r22, r12
     6de:	0e 94 f8 09 	call	0x13f0	; 0x13f0 <__addsf3>
     6e2:	6b 01       	movw	r12, r22
     6e4:	7c 01       	movw	r14, r24
     6e6:	33 c0       	rjmp	.+102    	; 0x74e <tinyAxon_update_potential+0x12c>
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
	{
		for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
		{
			if(pulse_queue[i] != 0){
     6e8:	80 81       	ld	r24, Z
     6ea:	91 81       	ldd	r25, Z+1	; 0x01
     6ec:	00 97       	sbiw	r24, 0x00	; 0
     6ee:	39 f0       	breq	.+14     	; 0x6fe <tinyAxon_update_potential+0xdc>
				pulse_queue[i]--;
     6f0:	01 97       	sbiw	r24, 0x01	; 1
     6f2:	80 83       	st	Z, r24
     6f4:	91 83       	std	Z+1, r25	; 0x01
				
				// If the time went from 1 to 0, we fire the axon
				if(pulse_queue[i] == 0){
     6f6:	89 2b       	or	r24, r25
     6f8:	11 f4       	brne	.+4      	; 0x6fe <tinyAxon_update_potential+0xdc>
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
	pulses_in_queue--;
     6fa:	41 50       	subi	r20, 0x01	; 1
Function to set firing.
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
     6fc:	51 e0       	ldi	r21, 0x01	; 1
     6fe:	32 96       	adiw	r30, 0x02	; 2
	}
	
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
	{
		for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
     700:	e2 17       	cp	r30, r18
     702:	f3 07       	cpc	r31, r19
     704:	89 f7       	brne	.-30     	; 0x6e8 <tinyAxon_update_potential+0xc6>
     706:	50 93 2c 38 	sts	0x382C, r21	; 0x80382c <tinyAxon_should_fire>
     70a:	40 93 2a 38 	sts	0x382A, r20	; 0x80382a <pulses_in_queue>
The function should set the DAC to fire for two
update cycles once the pulse flag is set high.
*/
static void tinyAxon_update_pulse_transmitter(void)
{
	if (tinyAxon_should_fire)
     70e:	80 91 2c 38 	lds	r24, 0x382C	; 0x80382c <tinyAxon_should_fire>
     712:	88 23       	and	r24, r24
     714:	91 f0       	breq	.+36     	; 0x73a <tinyAxon_update_potential+0x118>
	{
		tinyAxon_should_fire = false;
     716:	10 92 2c 38 	sts	0x382C, r1	; 0x80382c <tinyAxon_should_fire>
*/
static void tinyAxon_start_sending_pulse()
{
	if (NEURONTYPE == EXCITATORY_NEURON)
	{
		DAC_0_set_output(EXCITATORY_NEURON_OUTPUT);
     71a:	86 ee       	ldi	r24, 0xE6	; 230
     71c:	90 e0       	ldi	r25, 0x00	; 0
     71e:	0e 94 99 01 	call	0x332	; 0x332 <DAC_0_set_output>
		axonOutputValue=EXCITATORY_NEURON_OUTPUT;
     722:	86 ee       	ldi	r24, 0xE6	; 230
     724:	80 93 2b 38 	sts	0x382B, r24	; 0x80382b <axonOutputValue>
	{
		DAC_0_set_output(INHIBITORY_NEURON_OUTPUT);
		axonOutputValue=INHIBITORY_NEURON_OUTPUT;
	}
	
	tinyLED_set_color_mode(OUT_LED, WHITE, FLASH_ONCE);
     728:	45 e0       	ldi	r20, 0x05	; 5
     72a:	65 e0       	ldi	r22, 0x05	; 5
     72c:	81 e0       	ldi	r24, 0x01	; 1
     72e:	0e 94 88 06 	call	0xd10	; 0xd10 <tinyLED_set_color_mode>
{
	if (tinyAxon_should_fire)
	{
		tinyAxon_should_fire = false;
		tinyAxon_start_sending_pulse();
		tinyAxon_has_just_fired = true;
     732:	81 e0       	ldi	r24, 0x01	; 1
     734:	80 93 2d 38 	sts	0x382D, r24	; 0x80382d <tinyAxon_has_just_fired>
     738:	15 c0       	rjmp	.+42     	; 0x764 <tinyAxon_update_potential+0x142>
		
	}
	else if (tinyAxon_has_just_fired)
     73a:	80 91 2d 38 	lds	r24, 0x382D	; 0x80382d <tinyAxon_has_just_fired>
     73e:	88 23       	and	r24, r24
     740:	19 f0       	breq	.+6      	; 0x748 <tinyAxon_update_potential+0x126>
	{
		tinyAxon_has_just_fired = false;
     742:	10 92 2d 38 	sts	0x382D, r1	; 0x80382d <tinyAxon_has_just_fired>
     746:	0e c0       	rjmp	.+28     	; 0x764 <tinyAxon_update_potential+0x142>
	}
	else if (!tinyAxon_has_just_fired && !tinyAxon_should_fire)
	{
		tinyAxon_stop_sending_pulse();
     748:	0e 94 e7 02 	call	0x5ce	; 0x5ce <tinyAxon_stop_sending_pulse>
     74c:	0b c0       	rjmp	.+22     	; 0x764 <tinyAxon_update_potential+0x142>
			}
		}
	}
	
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
     74e:	40 91 2a 38 	lds	r20, 0x382A	; 0x80382a <pulses_in_queue>
     752:	44 23       	and	r20, r20
     754:	e1 f2       	breq	.-72     	; 0x70e <tinyAxon_update_potential+0xec>
     756:	50 91 2c 38 	lds	r21, 0x382C	; 0x80382c <tinyAxon_should_fire>
     75a:	e6 e1       	ldi	r30, 0x16	; 22
     75c:	f8 e3       	ldi	r31, 0x38	; 56
     75e:	2a e2       	ldi	r18, 0x2A	; 42
     760:	38 e3       	ldi	r19, 0x38	; 56
     762:	c2 cf       	rjmp	.-124    	; 0x6e8 <tinyAxon_update_potential+0xc6>
	}
	
	// Here we set the actual output of the DAC (Digital to Analog Converter)
	tinyAxon_update_pulse_transmitter();
	
	tinyDebugger_send_uint8("Axon", axonOutputValue);
     764:	60 91 2b 38 	lds	r22, 0x382B	; 0x80382b <axonOutputValue>
     768:	8b e1       	ldi	r24, 0x1B	; 27
     76a:	96 ea       	ldi	r25, 0xA6	; 166
     76c:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("Pulses", pulses_in_queue);
     770:	60 91 2a 38 	lds	r22, 0x382A	; 0x80382a <pulses_in_queue>
     774:	80 e2       	ldi	r24, 0x20	; 32
     776:	96 ea       	ldi	r25, 0xA6	; 166
     778:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <tinyDebugger_send_uint8>
	
	
	return potential;
}
     77c:	c7 01       	movw	r24, r14
     77e:	b6 01       	movw	r22, r12
     780:	ff 90       	pop	r15
     782:	ef 90       	pop	r14
     784:	df 90       	pop	r13
     786:	cf 90       	pop	r12
     788:	08 95       	ret

0000078a <tinyAxon_check_charge_level>:
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTB_get_pin_level(const uint8_t pin)
{
	return VPORTB.IN & (1 << pin);
     78a:	66 b1       	in	r22, 0x06	; 6

_Bool tinyAxon_check_charge_level(void)
{
	// We check the AXON_CHECK_PIN. If it is hight while the axon is not firing, it must be connected to a charger
	
	tinyDebugger_send_uint8("Pulses", AXON_CHECK_PIN_get_level());
     78c:	66 1f       	adc	r22, r22
     78e:	66 27       	eor	r22, r22
     790:	66 1f       	adc	r22, r22
     792:	80 e2       	ldi	r24, 0x20	; 32
     794:	96 ea       	ldi	r25, 0xA6	; 166
     796:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <tinyDebugger_send_uint8>
	return (AXON_CHECK_PIN_get_level() && !tinyAxon_has_just_fired);
     79a:	37 9b       	sbis	0x06, 7	; 6
     79c:	05 c0       	rjmp	.+10     	; 0x7a8 <tinyAxon_check_charge_level+0x1e>
     79e:	90 91 2d 38 	lds	r25, 0x382D	; 0x80382d <tinyAxon_has_just_fired>
     7a2:	81 e0       	ldi	r24, 0x01	; 1
     7a4:	89 27       	eor	r24, r25
     7a6:	02 c0       	rjmp	.+4      	; 0x7ac <tinyAxon_check_charge_level+0x22>
     7a8:	80 e0       	ldi	r24, 0x00	; 0
     7aa:	90 e0       	ldi	r25, 0x00	; 0
     7ac:	81 70       	andi	r24, 0x01	; 1
     7ae:	08 95       	ret

000007b0 <tinyButton_update>:
/*
If the button has been let go, we change button_press to true. This only lasts one cycle, before it is set to false again.
If the button is held down for longer than PULSEMODE_BUTTON_PRESS_TIME, we toggle the pulse mode state.
*/
void tinyButton_update(void)
{
     7b0:	0f 93       	push	r16
     7b2:	1f 93       	push	r17
     7b4:	cf 93       	push	r28
     7b6:	df 93       	push	r29
	button_press = false;
     7b8:	10 92 33 38 	sts	0x3833, r1	; 0x803833 <button_press>
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTC_get_pin_level(const uint8_t pin)
{
	return VPORTC.IN & (1 << pin);
     7bc:	8a b1       	in	r24, 0x0a	; 10
	_Bool button_is_pushed_down = !BUTTON_PIN_get_level(); // The digital port will be read as low if the button is pushed down.
     7be:	d1 e0       	ldi	r29, 0x01	; 1
     7c0:	c8 2f       	mov	r28, r24
     7c2:	c4 70       	andi	r28, 0x04	; 4
     7c4:	82 fd       	sbrc	r24, 2
     7c6:	d0 e0       	ldi	r29, 0x00	; 0

	if (button_is_pushed_down && !button_was_pushed_down)
     7c8:	c1 11       	cpse	r28, r1
     7ca:	39 c0       	rjmp	.+114    	; 0x83e <tinyButton_update+0x8e>
     7cc:	80 91 34 38 	lds	r24, 0x3834	; 0x803834 <button_was_pushed_down>
     7d0:	81 11       	cpse	r24, r1
     7d2:	0e c0       	rjmp	.+28     	; 0x7f0 <tinyButton_update+0x40>
	{
		tinyButton_start_time = tinyTime_now();
     7d4:	0e 94 ee 09 	call	0x13dc	; 0x13dc <tinyTime_now>
     7d8:	60 93 2e 38 	sts	0x382E, r22	; 0x80382e <tinyButton_start_time>
     7dc:	70 93 2f 38 	sts	0x382F, r23	; 0x80382f <tinyButton_start_time+0x1>
     7e0:	80 93 30 38 	sts	0x3830, r24	; 0x803830 <tinyButton_start_time+0x2>
     7e4:	90 93 31 38 	sts	0x3831, r25	; 0x803831 <tinyButton_start_time+0x3>
	}
	if (button_is_pushed_down && button_was_pushed_down)
     7e8:	80 91 34 38 	lds	r24, 0x3834	; 0x803834 <button_was_pushed_down>
     7ec:	88 23       	and	r24, r24
     7ee:	b9 f1       	breq	.+110    	; 0x85e <tinyButton_update+0xae>
	{
		if ((tinyTime_now() - tinyButton_start_time) > PULSEMODE_BUTTON_PRESS_TIME)
     7f0:	0e 94 ee 09 	call	0x13dc	; 0x13dc <tinyTime_now>
     7f4:	00 91 2e 38 	lds	r16, 0x382E	; 0x80382e <tinyButton_start_time>
     7f8:	10 91 2f 38 	lds	r17, 0x382F	; 0x80382f <tinyButton_start_time+0x1>
     7fc:	20 91 30 38 	lds	r18, 0x3830	; 0x803830 <tinyButton_start_time+0x2>
     800:	30 91 31 38 	lds	r19, 0x3831	; 0x803831 <tinyButton_start_time+0x3>
     804:	60 1b       	sub	r22, r16
     806:	71 0b       	sbc	r23, r17
     808:	82 0b       	sbc	r24, r18
     80a:	93 0b       	sbc	r25, r19
     80c:	0e 94 44 0b 	call	0x1688	; 0x1688 <__floatunsisf>
     810:	20 e0       	ldi	r18, 0x00	; 0
     812:	30 e0       	ldi	r19, 0x00	; 0
     814:	48 ec       	ldi	r20, 0xC8	; 200
     816:	52 e4       	ldi	r21, 0x42	; 66
     818:	0e 94 3c 0c 	call	0x1878	; 0x1878 <__gesf2>
     81c:	18 16       	cp	r1, r24
     81e:	7c f4       	brge	.+30     	; 0x83e <tinyButton_update+0x8e>
		{
			tinyPulse_toggle_pulse_mode();
     820:	0e 94 80 09 	call	0x1300	; 0x1300 <tinyPulse_toggle_pulse_mode>
			tinyButton_start_time = tinyTime_now();
     824:	0e 94 ee 09 	call	0x13dc	; 0x13dc <tinyTime_now>
     828:	60 93 2e 38 	sts	0x382E, r22	; 0x80382e <tinyButton_start_time>
     82c:	70 93 2f 38 	sts	0x382F, r23	; 0x80382f <tinyButton_start_time+0x1>
     830:	80 93 30 38 	sts	0x3830, r24	; 0x803830 <tinyButton_start_time+0x2>
     834:	90 93 31 38 	sts	0x3831, r25	; 0x803831 <tinyButton_start_time+0x3>
			// We don't want switching to pulse mode to count as a button press, so we ignore the next button press
			ignore_next_button_press = true;
     838:	81 e0       	ldi	r24, 0x01	; 1
     83a:	80 93 32 38 	sts	0x3832, r24	; 0x803832 <ignore_next_button_press>
		}
	}
	if (!button_is_pushed_down && button_was_pushed_down)
     83e:	cc 23       	and	r28, r28
     840:	71 f0       	breq	.+28     	; 0x85e <tinyButton_update+0xae>
     842:	80 91 34 38 	lds	r24, 0x3834	; 0x803834 <button_was_pushed_down>
     846:	88 23       	and	r24, r24
     848:	51 f0       	breq	.+20     	; 0x85e <tinyButton_update+0xae>
	{
		if(!ignore_next_button_press){
     84a:	80 91 32 38 	lds	r24, 0x3832	; 0x803832 <ignore_next_button_press>
     84e:	81 11       	cpse	r24, r1
     850:	04 c0       	rjmp	.+8      	; 0x85a <tinyButton_update+0xaa>
			button_press = true;
     852:	81 e0       	ldi	r24, 0x01	; 1
     854:	80 93 33 38 	sts	0x3833, r24	; 0x803833 <button_press>
     858:	02 c0       	rjmp	.+4      	; 0x85e <tinyButton_update+0xae>
		}
		else{
			ignore_next_button_press = false;
     85a:	10 92 32 38 	sts	0x3832, r1	; 0x803832 <ignore_next_button_press>
		}
		
	}
	button_was_pushed_down = button_is_pushed_down;
     85e:	d0 93 34 38 	sts	0x3834, r29	; 0x803834 <button_was_pushed_down>
}
     862:	df 91       	pop	r29
     864:	cf 91       	pop	r28
     866:	1f 91       	pop	r17
     868:	0f 91       	pop	r16
     86a:	08 95       	ret

0000086c <tinyButton_update_potential>:

double tinyButton_update_potential(double potential){
	if(button_press){
     86c:	20 91 33 38 	lds	r18, 0x3833	; 0x803833 <button_press>
     870:	22 23       	and	r18, r18
     872:	31 f0       	breq	.+12     	; 0x880 <tinyButton_update_potential+0x14>
		potential += BUTTON_PRESS_REACTION;
     874:	20 e0       	ldi	r18, 0x00	; 0
     876:	30 e0       	ldi	r19, 0x00	; 0
     878:	40 ed       	ldi	r20, 0xD0	; 208
     87a:	51 e4       	ldi	r21, 0x41	; 65
     87c:	0e 94 f8 09 	call	0x13f0	; 0x13f0 <__addsf3>
	}
	return potential;
}
     880:	08 95       	ret

00000882 <tinyCharge_is_connected_to_charger>:
*/
uint8_t charge_counter = 0; 

_Bool tinyCharge_is_connected_to_charger(){
	return connected_to_charger;
}
     882:	80 91 59 38 	lds	r24, 0x3859	; 0x803859 <connected_to_charger>
     886:	08 95       	ret

00000888 <tinyCharge_is_fully_charged>:
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTB_get_pin_level(const uint8_t pin)
{
	return VPORTB.IN & (1 << pin);
     888:	86 b1       	in	r24, 0x06	; 6

_Bool tinyCharge_is_fully_charged(){
	return CHARGING_STATUS_PIN_get_level();
}
     88a:	86 fb       	bst	r24, 6
     88c:	88 27       	eor	r24, r24
     88e:	80 f9       	bld	r24, 0
     890:	08 95       	ret

00000892 <tinyCharge_DAC_dissable>:
void tinyCharge_DAC_dissable(){
	
	// We need some way to disable the DAC to prevent huge current draw when charging (64mA). When there is no code uploaded to the attiny, there is no problem.
	// We're going to try to enable the pin as a dendrite, since they seem to be doing fine. Completely uninitializing the pin probably caused a microchip to be fried.
	
	DAC_0_uninit();
     892:	0e 94 88 01 	call	0x310	; 0x310 <DAC_0_uninit>
	DAC_0_disable();
     896:	0e 94 93 01 	call	0x326	; 0x326 <DAC_0_disable>
     89a:	08 95       	ret

0000089c <tinyCharge_DAC_enable>:
void tinyCharge_DAC_enable(){
	
	// We need some way to disable the DAC to prevent huge current draw when charging (64mA). When there is no code uploaded to the attiny, there is no problem.
	// We're going to try to enable the pin as a dendrite, since they seem to be doing fine. Completely uninitializing the pin probably caused a microchip to be fried.
	
	DAC_0_init();
     89c:	0e 94 83 01 	call	0x306	; 0x306 <DAC_0_init>
	DAC_0_enable();
     8a0:	0e 94 8d 01 	call	0x31a	; 0x31a <DAC_0_enable>
     8a4:	08 95       	ret

000008a6 <tinyCharge_switch_mode>:
}


void tinyCharge_switch_mode(){
	
	if(connected_to_charger){
     8a6:	80 91 59 38 	lds	r24, 0x3859	; 0x803859 <connected_to_charger>
     8aa:	88 23       	and	r24, r24
     8ac:	89 f0       	breq	.+34     	; 0x8d0 <tinyCharge_switch_mode+0x2a>
		// Switch from main to charging mode
		
		// Set LED
		tinyLED_set_color_mode(OUT_LED, CHARGING_COLOR, SWING);
     8ae:	43 e0       	ldi	r20, 0x03	; 3
     8b0:	61 e0       	ldi	r22, 0x01	; 1
     8b2:	81 e0       	ldi	r24, 0x01	; 1
     8b4:	0e 94 88 06 	call	0xd10	; 0xd10 <tinyLED_set_color_mode>
		tinyLED_set_color(INN_LED, LED_OFF);
     8b8:	60 e0       	ldi	r22, 0x00	; 0
     8ba:	80 e0       	ldi	r24, 0x00	; 0
     8bc:	0e 94 ac 06 	call	0xd58	; 0xd58 <tinyLED_set_color>


		// Stop axon from firing
		// (There is a small chance that the neuron is put into charging mode as it is firing. The axon is then never told to stop firing)
		tinyAxon_stop_sending_pulse();
     8c0:	0e 94 e7 02 	call	0x5ce	; 0x5ce <tinyAxon_stop_sending_pulse>

		// disable DAC
		tinyCharge_DAC_dissable();
     8c4:	0e 94 49 04 	call	0x892	; 0x892 <tinyCharge_DAC_dissable>
		
		// We also turn off pulse mode, because it's confusing if it suddenly comes on
		// after it has been charging
		tinyPulse_set_pulse_mode(false);
     8c8:	80 e0       	ldi	r24, 0x00	; 0
     8ca:	0e 94 9c 09 	call	0x1338	; 0x1338 <tinyPulse_set_pulse_mode>
     8ce:	08 95       	ret
	}
	else{
		// Switch from charge to main mode
		
		// Set LED
		tinyLED_set_color(OUT_LED, LED_OFF);
     8d0:	60 e0       	ldi	r22, 0x00	; 0
     8d2:	81 e0       	ldi	r24, 0x01	; 1
     8d4:	0e 94 ac 06 	call	0xd58	; 0xd58 <tinyLED_set_color>
		tinyLED_set_color(INN_LED, LED_OFF);
     8d8:	60 e0       	ldi	r22, 0x00	; 0
     8da:	80 e0       	ldi	r24, 0x00	; 0
     8dc:	0e 94 ac 06 	call	0xd58	; 0xd58 <tinyLED_set_color>
		
		// enable DAC
		tinyCharge_DAC_enable();
     8e0:	0e 94 4e 04 	call	0x89c	; 0x89c <tinyCharge_DAC_enable>
     8e4:	08 95       	ret

000008e6 <tinyCharge_set_charging_mode>:
	}
}

void tinyCharge_set_charging_mode(_Bool charging_status){
	if(charging_status != connected_to_charger){
     8e6:	90 91 59 38 	lds	r25, 0x3859	; 0x803859 <connected_to_charger>
     8ea:	98 17       	cp	r25, r24
     8ec:	21 f0       	breq	.+8      	; 0x8f6 <tinyCharge_set_charging_mode+0x10>
		connected_to_charger = charging_status;
     8ee:	80 93 59 38 	sts	0x3859, r24	; 0x803859 <connected_to_charger>
		tinyCharge_switch_mode();
     8f2:	0e 94 53 04 	call	0x8a6	; 0x8a6 <tinyCharge_switch_mode>
     8f6:	08 95       	ret

000008f8 <tinyCharge_update_charging_mode>:

/*
Checks if the levels of the dendrites and axon are at charging levels
and updates the mode accordingly
*/
void tinyCharge_update_charging_mode(){
     8f8:	cf 93       	push	r28
	// For complicated reasons, the axon_check_level will be high even when the charger is not connected
	// WHEN the neuron is in charging mode, hence we ignore the axon level when the neuron is in charging mode
	_Bool charging;
	if(connected_to_charger){
     8fa:	80 91 59 38 	lds	r24, 0x3859	; 0x803859 <connected_to_charger>
     8fe:	88 23       	and	r24, r24
     900:	21 f0       	breq	.+8      	; 0x90a <tinyCharge_update_charging_mode+0x12>
		charging = tinyDendrite_check_charge_level();
     902:	0e 94 3e 05 	call	0xa7c	; 0xa7c <tinyDendrite_check_charge_level>
     906:	c8 2f       	mov	r28, r24
     908:	0b c0       	rjmp	.+22     	; 0x920 <tinyCharge_update_charging_mode+0x28>
	} else{
		charging = tinyDendrite_check_charge_level() || tinyAxon_check_charge_level();
     90a:	0e 94 3e 05 	call	0xa7c	; 0xa7c <tinyDendrite_check_charge_level>
     90e:	81 11       	cpse	r24, r1
     910:	03 c0       	rjmp	.+6      	; 0x918 <tinyCharge_update_charging_mode+0x20>
     912:	0e 94 c5 03 	call	0x78a	; 0x78a <tinyAxon_check_charge_level>
     916:	02 c0       	rjmp	.+4      	; 0x91c <tinyCharge_update_charging_mode+0x24>
     918:	81 e0       	ldi	r24, 0x01	; 1
     91a:	90 e0       	ldi	r25, 0x00	; 0
     91c:	c8 2f       	mov	r28, r24
     91e:	c1 70       	andi	r28, 0x01	; 1
	}
	
	// In order to prevent the axon from stimulating itself, we only switch into charging mode when the conditions have been right for several cycles
	if(!connected_to_charger && charging){
     920:	80 91 59 38 	lds	r24, 0x3859	; 0x803859 <connected_to_charger>
     924:	81 11       	cpse	r24, r1
     926:	0d c0       	rjmp	.+26     	; 0x942 <tinyCharge_update_charging_mode+0x4a>
     928:	cc 23       	and	r28, r28
     92a:	d1 f0       	breq	.+52     	; 0x960 <tinyCharge_update_charging_mode+0x68>
		charge_counter++;
     92c:	80 91 35 38 	lds	r24, 0x3835	; 0x803835 <charge_counter>
     930:	8f 5f       	subi	r24, 0xFF	; 255
		if(charge_counter > CYCLES_REQUIRED_FOR_CHARGING_MODE_SWITCH){
     932:	8b 30       	cpi	r24, 0x0B	; 11
     934:	90 f0       	brcs	.+36     	; 0x95a <tinyCharge_update_charging_mode+0x62>
			charge_counter = 0;
     936:	10 92 35 38 	sts	0x3835, r1	; 0x803835 <charge_counter>
			tinyCharge_set_charging_mode(charging);
     93a:	81 e0       	ldi	r24, 0x01	; 1
     93c:	0e 94 73 04 	call	0x8e6	; 0x8e6 <tinyCharge_set_charging_mode>
     940:	13 c0       	rjmp	.+38     	; 0x968 <tinyCharge_update_charging_mode+0x70>
		}
	}
	else{
		tinyCharge_set_charging_mode(charging);
     942:	8c 2f       	mov	r24, r28
     944:	0e 94 73 04 	call	0x8e6	; 0x8e6 <tinyCharge_set_charging_mode>
	}
	
	// We have to prevent charge_counters from accumulating over time
	if(!charging && charge_counter>0){
     948:	c1 11       	cpse	r28, r1
     94a:	0e c0       	rjmp	.+28     	; 0x968 <tinyCharge_update_charging_mode+0x70>
     94c:	80 91 35 38 	lds	r24, 0x3835	; 0x803835 <charge_counter>
     950:	88 23       	and	r24, r24
     952:	51 f0       	breq	.+20     	; 0x968 <tinyCharge_update_charging_mode+0x70>
		charge_counter = 0;
     954:	10 92 35 38 	sts	0x3835, r1	; 0x803835 <charge_counter>
	}
	
}
     958:	07 c0       	rjmp	.+14     	; 0x968 <tinyCharge_update_charging_mode+0x70>
		charging = tinyDendrite_check_charge_level() || tinyAxon_check_charge_level();
	}
	
	// In order to prevent the axon from stimulating itself, we only switch into charging mode when the conditions have been right for several cycles
	if(!connected_to_charger && charging){
		charge_counter++;
     95a:	80 93 35 38 	sts	0x3835, r24	; 0x803835 <charge_counter>
     95e:	04 c0       	rjmp	.+8      	; 0x968 <tinyCharge_update_charging_mode+0x70>
			charge_counter = 0;
			tinyCharge_set_charging_mode(charging);
		}
	}
	else{
		tinyCharge_set_charging_mode(charging);
     960:	8c 2f       	mov	r24, r28
     962:	0e 94 73 04 	call	0x8e6	; 0x8e6 <tinyCharge_set_charging_mode>
     966:	f2 cf       	rjmp	.-28     	; 0x94c <tinyCharge_update_charging_mode+0x54>
	// We have to prevent charge_counters from accumulating over time
	if(!charging && charge_counter>0){
		charge_counter = 0;
	}
	
}
     968:	cf 91       	pop	r28
     96a:	08 95       	ret

0000096c <tinyCharge_set_transistors>:



void tinyCharge_set_transistors(){
	if(connected_to_charger){
     96c:	80 91 59 38 	lds	r24, 0x3859	; 0x803859 <connected_to_charger>
     970:	88 23       	and	r24, r24
     972:	19 f0       	breq	.+6      	; 0x97a <tinyCharge_set_transistors+0xe>
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
	} else {
		VPORTC.OUT &= ~(1 << pin);
     974:	4d 98       	cbi	0x09, 5	; 9
 *                  false = Pin level set to "low" state
 */
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
     976:	29 9a       	sbi	0x05, 1	; 5
     978:	08 95       	ret
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     97a:	4d 9a       	sbi	0x09, 5	; 9
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     97c:	29 98       	cbi	0x05, 1	; 5
     97e:	08 95       	ret

00000980 <tinyDebugger_send_uint32>:
}
void tinyDebugger_send_string(const char* name, char * value){
	if(DEBUGGING){
		printf("%s:%s\t", name, value);
	}
}
     980:	7f 93       	push	r23
     982:	6f 93       	push	r22
     984:	5f 93       	push	r21
     986:	4f 93       	push	r20
     988:	9f 93       	push	r25
     98a:	8f 93       	push	r24
     98c:	8f e2       	ldi	r24, 0x2F	; 47
     98e:	96 ea       	ldi	r25, 0xA6	; 166
     990:	9f 93       	push	r25
     992:	8f 93       	push	r24
     994:	0e 94 cf 0d 	call	0x1b9e	; 0x1b9e <printf>
     998:	8d b7       	in	r24, 0x3d	; 61
     99a:	9e b7       	in	r25, 0x3e	; 62
     99c:	08 96       	adiw	r24, 0x08	; 8
     99e:	8d bf       	out	0x3d, r24	; 61
     9a0:	9e bf       	out	0x3e, r25	; 62
     9a2:	08 95       	ret

000009a4 <tinyDebugger_send_uint8>:
     9a4:	1f 92       	push	r1
     9a6:	6f 93       	push	r22
     9a8:	9f 93       	push	r25
     9aa:	8f 93       	push	r24
     9ac:	88 e3       	ldi	r24, 0x38	; 56
     9ae:	96 ea       	ldi	r25, 0xA6	; 166
     9b0:	9f 93       	push	r25
     9b2:	8f 93       	push	r24
     9b4:	0e 94 cf 0d 	call	0x1b9e	; 0x1b9e <printf>
     9b8:	0f 90       	pop	r0
     9ba:	0f 90       	pop	r0
     9bc:	0f 90       	pop	r0
     9be:	0f 90       	pop	r0
     9c0:	0f 90       	pop	r0
     9c2:	0f 90       	pop	r0
     9c4:	08 95       	ret

000009c6 <tinyDebugger_send_double>:
     9c6:	cf 92       	push	r12
     9c8:	df 92       	push	r13
     9ca:	ef 92       	push	r14
     9cc:	ff 92       	push	r15
     9ce:	0f 93       	push	r16
     9d0:	1f 93       	push	r17
     9d2:	cf 93       	push	r28
     9d4:	df 93       	push	r29
     9d6:	cd b7       	in	r28, 0x3d	; 61
     9d8:	de b7       	in	r29, 0x3e	; 62
     9da:	64 97       	sbiw	r28, 0x14	; 20
     9dc:	cd bf       	out	0x3d, r28	; 61
     9de:	de bf       	out	0x3e, r29	; 62
     9e0:	d8 2e       	mov	r13, r24
     9e2:	c9 2e       	mov	r12, r25
     9e4:	cb 01       	movw	r24, r22
     9e6:	ba 01       	movw	r22, r20
     9e8:	9e 01       	movw	r18, r28
     9ea:	2f 5f       	subi	r18, 0xFF	; 255
     9ec:	3f 4f       	sbci	r19, 0xFF	; 255
     9ee:	79 01       	movw	r14, r18
     9f0:	89 01       	movw	r16, r18
     9f2:	21 e0       	ldi	r18, 0x01	; 1
     9f4:	41 e0       	ldi	r20, 0x01	; 1
     9f6:	0e 94 af 0d 	call	0x1b5e	; 0x1b5e <dtostrf>
     9fa:	ff 92       	push	r15
     9fc:	ef 92       	push	r14
     9fe:	cf 92       	push	r12
     a00:	df 92       	push	r13
     a02:	80 e4       	ldi	r24, 0x40	; 64
     a04:	96 ea       	ldi	r25, 0xA6	; 166
     a06:	9f 93       	push	r25
     a08:	8f 93       	push	r24
     a0a:	0e 94 cf 0d 	call	0x1b9e	; 0x1b9e <printf>
     a0e:	0f 90       	pop	r0
     a10:	0f 90       	pop	r0
     a12:	0f 90       	pop	r0
     a14:	0f 90       	pop	r0
     a16:	0f 90       	pop	r0
     a18:	0f 90       	pop	r0
     a1a:	64 96       	adiw	r28, 0x14	; 20
     a1c:	cd bf       	out	0x3d, r28	; 61
     a1e:	de bf       	out	0x3e, r29	; 62
     a20:	df 91       	pop	r29
     a22:	cf 91       	pop	r28
     a24:	1f 91       	pop	r17
     a26:	0f 91       	pop	r16
     a28:	ff 90       	pop	r15
     a2a:	ef 90       	pop	r14
     a2c:	df 90       	pop	r13
     a2e:	cf 90       	pop	r12
     a30:	08 95       	ret

00000a32 <tinyDebugger_end_line>:
void tinyDebugger_end_line(){
	if(DEBUGGING){
		printf("\r\n");
     a32:	8f e4       	ldi	r24, 0x4F	; 79
     a34:	96 ea       	ldi	r25, 0xA6	; 166
     a36:	0e 94 e5 0d 	call	0x1bca	; 0x1bca <puts>
     a3a:	08 95       	ret

00000a3c <tinyDendrite_read_signals>:
	}
}

uint8_t tinyDendrite_get_value(uint8_t dendrite_number){
	return tinyDendrite_values[dendrite_number];
}
     a3c:	ef 92       	push	r14
     a3e:	ff 92       	push	r15
     a40:	0f 93       	push	r16
     a42:	1f 93       	push	r17
     a44:	cf 93       	push	r28
     a46:	df 93       	push	r29
     a48:	ce e0       	ldi	r28, 0x0E	; 14
     a4a:	d8 e3       	ldi	r29, 0x38	; 56
     a4c:	00 e4       	ldi	r16, 0x40	; 64
     a4e:	18 e3       	ldi	r17, 0x38	; 56
     a50:	0f 2e       	mov	r0, r31
     a52:	f3 e1       	ldi	r31, 0x13	; 19
     a54:	ef 2e       	mov	r14, r31
     a56:	f8 e3       	ldi	r31, 0x38	; 56
     a58:	ff 2e       	mov	r15, r31
     a5a:	f0 2d       	mov	r31, r0
     a5c:	89 91       	ld	r24, Y+
     a5e:	0e 94 4d 01 	call	0x29a	; 0x29a <ADC_0_get_conversion>
     a62:	f8 01       	movw	r30, r16
     a64:	81 93       	st	Z+, r24
     a66:	8f 01       	movw	r16, r30
     a68:	ce 15       	cp	r28, r14
     a6a:	df 05       	cpc	r29, r15
     a6c:	b9 f7       	brne	.-18     	; 0xa5c <tinyDendrite_read_signals+0x20>
     a6e:	df 91       	pop	r29
     a70:	cf 91       	pop	r28
     a72:	1f 91       	pop	r17
     a74:	0f 91       	pop	r16
     a76:	ff 90       	pop	r15
     a78:	ef 90       	pop	r14
     a7a:	08 95       	ret

00000a7c <tinyDendrite_check_charge_level>:

_Bool tinyDendrite_check_charge_level(void)
{
     a7c:	cf 93       	push	r28
     a7e:	df 93       	push	r29
	_Bool charging = false;
	
	tinyDendrite_read_signals();
     a80:	0e 94 1e 05 	call	0xa3c	; 0xa3c <tinyDendrite_read_signals>
     a84:	eb e3       	ldi	r30, 0x3B	; 59
     a86:	f8 e3       	ldi	r31, 0x38	; 56
     a88:	c6 e3       	ldi	r28, 0x36	; 54
     a8a:	d8 e3       	ldi	r29, 0x38	; 56
     a8c:	a0 e4       	ldi	r26, 0x40	; 64
     a8e:	b8 e3       	ldi	r27, 0x38	; 56
     a90:	20 e4       	ldi	r18, 0x40	; 64
     a92:	38 e3       	ldi	r19, 0x38	; 56
	return tinyDendrite_values[dendrite_number];
}

_Bool tinyDendrite_check_charge_level(void)
{
	_Bool charging = false;
     a94:	80 e0       	ldi	r24, 0x00	; 0
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = CHARGING;
     a96:	47 e0       	ldi	r20, 0x07	; 7
	_Bool charging = false;
	
	tinyDendrite_read_signals();
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
     a98:	90 81       	ld	r25, Z
     a9a:	99 93       	st	Y+, r25
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
     a9c:	9d 91       	ld	r25, X+
     a9e:	99 3e       	cpi	r25, 0xE9	; 233
     aa0:	10 f0       	brcs	.+4      	; 0xaa6 <tinyDendrite_check_charge_level+0x2a>
		{
			tinyDendrite_current_signals[i] = CHARGING;
     aa2:	40 83       	st	Z, r20
			charging = true;
     aa4:	81 e0       	ldi	r24, 0x01	; 1
     aa6:	31 96       	adiw	r30, 0x01	; 1
_Bool tinyDendrite_check_charge_level(void)
{
	_Bool charging = false;
	
	tinyDendrite_read_signals();
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
     aa8:	e2 17       	cp	r30, r18
     aaa:	f3 07       	cpc	r31, r19
     aac:	a9 f7       	brne	.-22     	; 0xa98 <tinyDendrite_check_charge_level+0x1c>
			tinyDendrite_current_signals[i] = CHARGING;
			charging = true;
		}
	}
	return charging;
}
     aae:	df 91       	pop	r29
     ab0:	cf 91       	pop	r28
     ab2:	08 95       	ret

00000ab4 <tinyDendrite_update_signals>:

/*
This function converts the 8 bit value from the ADC into one of the signal types defined in DendriteSignal
*/
void tinyDendrite_update_signals(void)
{
     ab4:	af 92       	push	r10
     ab6:	bf 92       	push	r11
     ab8:	df 92       	push	r13
     aba:	ef 92       	push	r14
     abc:	ff 92       	push	r15
     abe:	0f 93       	push	r16
     ac0:	1f 93       	push	r17
     ac2:	cf 93       	push	r28
     ac4:	df 93       	push	r29
	
	// This function does not read the dendrite values! Read_signals must be called somewhere prior to this function!
	// As of writing this, the update_charging_mode function in main runs check_charge_level, so 
	// the tinyDendrite_values are updated when update_signals is called later
	
	tinyDebugger_send_uint8("D1", tinyDendrite_values[0]);
     ac6:	c0 e4       	ldi	r28, 0x40	; 64
     ac8:	d8 e3       	ldi	r29, 0x38	; 56
     aca:	68 81       	ld	r22, Y
     acc:	81 e5       	ldi	r24, 0x51	; 81
     ace:	96 ea       	ldi	r25, 0xA6	; 166
     ad0:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D2", tinyDendrite_values[1]);
     ad4:	69 81       	ldd	r22, Y+1	; 0x01
     ad6:	84 e5       	ldi	r24, 0x54	; 84
     ad8:	96 ea       	ldi	r25, 0xA6	; 166
     ada:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D3", tinyDendrite_values[2]);
     ade:	6a 81       	ldd	r22, Y+2	; 0x02
     ae0:	87 e5       	ldi	r24, 0x57	; 87
     ae2:	96 ea       	ldi	r25, 0xA6	; 166
     ae4:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D4", tinyDendrite_values[3]);
     ae8:	6b 81       	ldd	r22, Y+3	; 0x03
     aea:	8a e5       	ldi	r24, 0x5A	; 90
     aec:	96 ea       	ldi	r25, 0xA6	; 166
     aee:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D5", tinyDendrite_values[4]);
     af2:	6c 81       	ldd	r22, Y+4	; 0x04
     af4:	8d e5       	ldi	r24, 0x5D	; 93
     af6:	96 ea       	ldi	r25, 0xA6	; 166
     af8:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <tinyDebugger_send_uint8>
     afc:	eb e3       	ldi	r30, 0x3B	; 59
     afe:	f8 e3       	ldi	r31, 0x38	; 56
     b00:	26 e3       	ldi	r18, 0x36	; 54
     b02:	38 e3       	ldi	r19, 0x38	; 56
     b04:	40 e4       	ldi	r20, 0x40	; 64
     b06:	58 e3       	ldi	r21, 0x38	; 56
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     b08:	dd 24       	eor	r13, r13
     b0a:	d3 94       	inc	r13
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
		}
		else if (tinyDendrite_values[i] > HIGH_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
     b0c:	0f 2e       	mov	r0, r31
     b0e:	f3 e0       	ldi	r31, 0x03	; 3
     b10:	ef 2e       	mov	r14, r31
     b12:	f0 2d       	mov	r31, r0
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     b14:	68 94       	set
     b16:	ff 24       	eor	r15, r15
     b18:	f1 f8       	bld	r15, 1
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     b1a:	04 e0       	ldi	r16, 0x04	; 4
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     b1c:	16 e0       	ldi	r17, 0x06	; 6
			// been moved to tinyDendrite_check_charging.
			//charging = true;
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     b1e:	75 e0       	ldi	r23, 0x05	; 5
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = CHARGING;
     b20:	67 e0       	ldi	r22, 0x07	; 7
     b22:	5f 01       	movw	r10, r30
	tinyDebugger_send_uint8("D4", tinyDendrite_values[3]);
	tinyDebugger_send_uint8("D5", tinyDendrite_values[4]);
	
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
     b24:	80 81       	ld	r24, Z
     b26:	d9 01       	movw	r26, r18
     b28:	8d 93       	st	X+, r24
     b2a:	9d 01       	movw	r18, r26
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
     b2c:	99 91       	ld	r25, Y+
     b2e:	99 3e       	cpi	r25, 0xE9	; 233
     b30:	10 f0       	brcs	.+4      	; 0xb36 <tinyDendrite_update_signals+0x82>
		{
			tinyDendrite_current_signals[i] = CHARGING;
     b32:	60 83       	st	Z, r22
     b34:	19 c0       	rjmp	.+50     	; 0xb68 <tinyDendrite_update_signals+0xb4>
			// Previously, we used this function to check charging, but this has now
			// been moved to tinyDendrite_check_charging.
			//charging = true;
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
     b36:	98 3c       	cpi	r25, 0xC8	; 200
     b38:	10 f0       	brcs	.+4      	; 0xb3e <tinyDendrite_update_signals+0x8a>
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     b3a:	70 83       	st	Z, r23
     b3c:	15 c0       	rjmp	.+42     	; 0xb68 <tinyDendrite_update_signals+0xb4>
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
     b3e:	97 3a       	cpi	r25, 0xA7	; 167
     b40:	10 f0       	brcs	.+4      	; 0xb46 <tinyDendrite_update_signals+0x92>
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     b42:	10 83       	st	Z, r17
     b44:	11 c0       	rjmp	.+34     	; 0xb68 <tinyDendrite_update_signals+0xb4>
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
     b46:	95 38       	cpi	r25, 0x85	; 133
     b48:	10 f0       	brcs	.+4      	; 0xb4e <tinyDendrite_update_signals+0x9a>
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     b4a:	00 83       	st	Z, r16
     b4c:	0d c0       	rjmp	.+26     	; 0xb68 <tinyDendrite_update_signals+0xb4>
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
     b4e:	94 36       	cpi	r25, 0x64	; 100
     b50:	10 f0       	brcs	.+4      	; 0xb56 <tinyDendrite_update_signals+0xa2>
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     b52:	f0 82       	st	Z, r15
     b54:	09 c0       	rjmp	.+18     	; 0xb68 <tinyDendrite_update_signals+0xb4>
		}
		else if (tinyDendrite_values[i] > HIGH_INHIB_THRESHOLD)
     b56:	93 34       	cpi	r25, 0x43	; 67
     b58:	10 f0       	brcs	.+4      	; 0xb5e <tinyDendrite_update_signals+0xaa>
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
     b5a:	e0 82       	st	Z, r14
     b5c:	05 c0       	rjmp	.+10     	; 0xb68 <tinyDendrite_update_signals+0xb4>
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
     b5e:	92 32       	cpi	r25, 0x22	; 34
     b60:	10 f0       	brcs	.+4      	; 0xb66 <tinyDendrite_update_signals+0xb2>
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     b62:	d0 82       	st	Z, r13
     b64:	01 c0       	rjmp	.+2      	; 0xb68 <tinyDendrite_update_signals+0xb4>
		}
		else
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     b66:	10 82       	st	Z, r1
		}
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
     b68:	d5 01       	movw	r26, r10
     b6a:	9c 91       	ld	r25, X
     b6c:	89 13       	cpse	r24, r25
     b6e:	01 c0       	rjmp	.+2      	; 0xb72 <tinyDendrite_update_signals+0xbe>
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     b70:	1c 92       	st	X, r1
     b72:	31 96       	adiw	r30, 0x01	; 1
	tinyDebugger_send_uint8("D2", tinyDendrite_values[1]);
	tinyDebugger_send_uint8("D3", tinyDendrite_values[2]);
	tinyDebugger_send_uint8("D4", tinyDendrite_values[3]);
	tinyDebugger_send_uint8("D5", tinyDendrite_values[4]);
	
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
     b74:	e4 17       	cp	r30, r20
     b76:	f5 07       	cpc	r31, r21
     b78:	a1 f6       	brne	.-88     	; 0xb22 <tinyDendrite_update_signals+0x6e>
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
		}
	}
}
     b7a:	df 91       	pop	r29
     b7c:	cf 91       	pop	r28
     b7e:	1f 91       	pop	r17
     b80:	0f 91       	pop	r16
     b82:	ff 90       	pop	r15
     b84:	ef 90       	pop	r14
     b86:	df 90       	pop	r13
     b88:	bf 90       	pop	r11
     b8a:	af 90       	pop	r10
     b8c:	08 95       	ret

00000b8e <tinyDendrite_get_potential>:
/*
This is the master function of the module that is callable from
outside. It uses the previously declared functions to return the potential.
*/
int16_t tinyDendrite_get_potential()
{
     b8e:	ef 92       	push	r14
     b90:	ff 92       	push	r15
     b92:	0f 93       	push	r16
     b94:	1f 93       	push	r17
     b96:	cf 93       	push	r28
     b98:	df 93       	push	r29
	if(tinyAxon_is_firing() && IGNORE_INPUT_WHILE_FIRING){
     b9a:	0e 94 cd 02 	call	0x59a	; 0x59a <tinyAxon_is_firing>
		
		return NO_SIGNAL_REACTION;
	}
	
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
     b9e:	0e 94 5a 05 	call	0xab4	; 0xab4 <tinyDendrite_update_signals>
     ba2:	cb e3       	ldi	r28, 0x3B	; 59
     ba4:	d8 e3       	ldi	r29, 0x38	; 56
     ba6:	0f 2e       	mov	r0, r31
     ba8:	f0 e4       	ldi	r31, 0x40	; 64
     baa:	ef 2e       	mov	r14, r31
     bac:	f8 e3       	ldi	r31, 0x38	; 56
     bae:	ff 2e       	mov	r15, r31
     bb0:	f0 2d       	mov	r31, r0
	
	int16_t return_potential_val = 0;
     bb2:	00 e0       	ldi	r16, 0x00	; 0
     bb4:	10 e0       	ldi	r17, 0x00	; 0
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		switch(tinyDendrite_current_signals[i])
     bb6:	89 91       	ld	r24, Y+
     bb8:	83 30       	cpi	r24, 0x03	; 3
     bba:	19 f1       	breq	.+70     	; 0xc02 <tinyDendrite_get_potential+0x74>
     bbc:	28 f4       	brcc	.+10     	; 0xbc8 <tinyDendrite_get_potential+0x3a>
     bbe:	81 30       	cpi	r24, 0x01	; 1
     bc0:	81 f1       	breq	.+96     	; 0xc22 <tinyDendrite_get_potential+0x94>
     bc2:	82 30       	cpi	r24, 0x02	; 2
     bc4:	31 f1       	breq	.+76     	; 0xc12 <tinyDendrite_get_potential+0x84>
     bc6:	34 c0       	rjmp	.+104    	; 0xc30 <tinyDendrite_get_potential+0xa2>
     bc8:	85 30       	cpi	r24, 0x05	; 5
     bca:	59 f0       	breq	.+22     	; 0xbe2 <tinyDendrite_get_potential+0x54>
     bcc:	90 f0       	brcs	.+36     	; 0xbf2 <tinyDendrite_get_potential+0x64>
     bce:	86 30       	cpi	r24, 0x06	; 6
     bd0:	79 f5       	brne	.+94     	; 0xc30 <tinyDendrite_get_potential+0xa2>
		{
			case NO_SIGNAL:
				return_potential_val += NO_SIGNAL_REACTION;
				break;
			case HIGH_EXCITE:
				return_potential_val += HIGH_EXCITE_REACTION;
     bd2:	0c 5c       	subi	r16, 0xCC	; 204
     bd4:	1f 4f       	sbci	r17, 0xFF	; 255
				tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
     bd6:	45 e0       	ldi	r20, 0x05	; 5
     bd8:	63 e0       	ldi	r22, 0x03	; 3
     bda:	80 e0       	ldi	r24, 0x00	; 0
     bdc:	0e 94 88 06 	call	0xd10	; 0xd10 <tinyLED_set_color_mode>
				break;
     be0:	27 c0       	rjmp	.+78     	; 0xc30 <tinyDendrite_get_potential+0xa2>
			case NORMAL_EXCITE:
				return_potential_val += NORMAL_EXCITE_REACTION;
     be2:	07 5e       	subi	r16, 0xE7	; 231
     be4:	1f 4f       	sbci	r17, 0xFF	; 255
				tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
     be6:	45 e0       	ldi	r20, 0x05	; 5
     be8:	63 e0       	ldi	r22, 0x03	; 3
     bea:	80 e0       	ldi	r24, 0x00	; 0
     bec:	0e 94 88 06 	call	0xd10	; 0xd10 <tinyLED_set_color_mode>
				break;
     bf0:	1f c0       	rjmp	.+62     	; 0xc30 <tinyDendrite_get_potential+0xa2>
			case LOW_EXCITE:
				return_potential_val += LOW_EXCITE_REACTION;
     bf2:	0c 5e       	subi	r16, 0xEC	; 236
     bf4:	1f 4f       	sbci	r17, 0xFF	; 255
				tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
     bf6:	45 e0       	ldi	r20, 0x05	; 5
     bf8:	63 e0       	ldi	r22, 0x03	; 3
     bfa:	80 e0       	ldi	r24, 0x00	; 0
     bfc:	0e 94 88 06 	call	0xd10	; 0xd10 <tinyLED_set_color_mode>
				break;
     c00:	17 c0       	rjmp	.+46     	; 0xc30 <tinyDendrite_get_potential+0xa2>
			case HIGH_INHIB:
				return_potential_val += HIGH_INHIB_REACTION;
     c02:	02 53       	subi	r16, 0x32	; 50
     c04:	11 09       	sbc	r17, r1
				tinyLED_set_color_mode(INN_LED, RED, FLASH_ONCE);
     c06:	45 e0       	ldi	r20, 0x05	; 5
     c08:	61 e0       	ldi	r22, 0x01	; 1
     c0a:	80 e0       	ldi	r24, 0x00	; 0
     c0c:	0e 94 88 06 	call	0xd10	; 0xd10 <tinyLED_set_color_mode>
				break;
     c10:	0f c0       	rjmp	.+30     	; 0xc30 <tinyDendrite_get_potential+0xa2>
			case NORMAL_INHIB:
				return_potential_val += NORMAL_INHIB_REACTION;
     c12:	09 51       	subi	r16, 0x19	; 25
     c14:	11 09       	sbc	r17, r1
				tinyLED_set_color_mode(INN_LED, RED, FLASH_ONCE);
     c16:	45 e0       	ldi	r20, 0x05	; 5
     c18:	61 e0       	ldi	r22, 0x01	; 1
     c1a:	80 e0       	ldi	r24, 0x00	; 0
     c1c:	0e 94 88 06 	call	0xd10	; 0xd10 <tinyLED_set_color_mode>
				break;
     c20:	07 c0       	rjmp	.+14     	; 0xc30 <tinyDendrite_get_potential+0xa2>
			case LOW_INHIB:
				return_potential_val += LOW_INHIB_REACTION;
     c22:	04 51       	subi	r16, 0x14	; 20
     c24:	11 09       	sbc	r17, r1
				tinyLED_set_color_mode(INN_LED, RED, FLASH_ONCE);
     c26:	45 e0       	ldi	r20, 0x05	; 5
     c28:	61 e0       	ldi	r22, 0x01	; 1
     c2a:	80 e0       	ldi	r24, 0x00	; 0
     c2c:	0e 94 88 06 	call	0xd10	; 0xd10 <tinyLED_set_color_mode>
	
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
	
	int16_t return_potential_val = 0;
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
     c30:	ce 15       	cp	r28, r14
     c32:	df 05       	cpc	r29, r15
     c34:	09 f0       	breq	.+2      	; 0xc38 <tinyDendrite_get_potential+0xaa>
     c36:	bf cf       	rjmp	.-130    	; 0xbb6 <tinyDendrite_get_potential+0x28>
		}
	}
	
	return return_potential_val;
	
}
     c38:	c8 01       	movw	r24, r16
     c3a:	df 91       	pop	r29
     c3c:	cf 91       	pop	r28
     c3e:	1f 91       	pop	r17
     c40:	0f 91       	pop	r16
     c42:	ff 90       	pop	r15
     c44:	ef 90       	pop	r14
     c46:	08 95       	ret

00000c48 <tinyDendrite_update_potential>:

double tinyDendrite_update_potential(double potential){
     c48:	cf 92       	push	r12
     c4a:	df 92       	push	r13
     c4c:	ef 92       	push	r14
     c4e:	ff 92       	push	r15
     c50:	6b 01       	movw	r12, r22
     c52:	7c 01       	movw	r14, r24
	
	int16_t potential_change = tinyDendrite_get_potential();
     c54:	0e 94 c7 05 	call	0xb8e	; 0xb8e <tinyDendrite_get_potential>
	potential += potential_change;
	return potential;
     c58:	bc 01       	movw	r22, r24
     c5a:	99 0f       	add	r25, r25
     c5c:	88 0b       	sbc	r24, r24
     c5e:	99 0b       	sbc	r25, r25
     c60:	0e 94 46 0b 	call	0x168c	; 0x168c <__floatsisf>
     c64:	a7 01       	movw	r20, r14
     c66:	96 01       	movw	r18, r12
     c68:	0e 94 f8 09 	call	0x13f0	; 0x13f0 <__addsf3>
     c6c:	ff 90       	pop	r15
     c6e:	ef 90       	pop	r14
     c70:	df 90       	pop	r13
     c72:	cf 90       	pop	r12
     c74:	08 95       	ret

00000c76 <__vector_6>:
This function is called every time the RTC (Real Time Clock) counter overflows.
With the current settings, it will be called every ms.
The RTC clock runs at 1kHz, and the number of cycles before overflow is set with RTC.PER = someHexValue (e.g. 0x20) in src/rtc.c
*/
ISR(RTC_CNT_vect)
{
     c76:	1f 92       	push	r1
     c78:	0f 92       	push	r0
     c7a:	0f b6       	in	r0, 0x3f	; 63
     c7c:	0f 92       	push	r0
     c7e:	11 24       	eor	r1, r1
     c80:	2f 93       	push	r18
     c82:	3f 93       	push	r19
     c84:	4f 93       	push	r20
     c86:	5f 93       	push	r21
     c88:	6f 93       	push	r22
     c8a:	7f 93       	push	r23
     c8c:	8f 93       	push	r24
     c8e:	9f 93       	push	r25
     c90:	af 93       	push	r26
     c92:	bf 93       	push	r27
     c94:	cf 93       	push	r28
     c96:	ef 93       	push	r30
     c98:	ff 93       	push	r31
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     c9a:	c1 e0       	ldi	r28, 0x01	; 1
     c9c:	c0 93 45 38 	sts	0x3845, r28	; 0x803845 <tinyISR_interrupt_flag>
{
	// Set flag to let main loop run a new cycle
	tinyISR_setflag(true);
	
	// Timer counter incrementation
	tinyTime_counter_increment();
     ca0:	0e 94 da 09 	call	0x13b4	; 0x13b4 <tinyTime_counter_increment>

	/* Overflow interrupt flag has to be cleared manually */
	RTC.INTFLAGS = RTC_OVF_bm;
     ca4:	c0 93 43 01 	sts	0x0143, r28	; 0x800143 <__TEXT_REGION_LENGTH__+0x700143>
}
     ca8:	ff 91       	pop	r31
     caa:	ef 91       	pop	r30
     cac:	cf 91       	pop	r28
     cae:	bf 91       	pop	r27
     cb0:	af 91       	pop	r26
     cb2:	9f 91       	pop	r25
     cb4:	8f 91       	pop	r24
     cb6:	7f 91       	pop	r23
     cb8:	6f 91       	pop	r22
     cba:	5f 91       	pop	r21
     cbc:	4f 91       	pop	r20
     cbe:	3f 91       	pop	r19
     cc0:	2f 91       	pop	r18
     cc2:	0f 90       	pop	r0
     cc4:	0f be       	out	0x3f, r0	; 63
     cc6:	0f 90       	pop	r0
     cc8:	1f 90       	pop	r1
     cca:	18 95       	reti

00000ccc <tinyISR_setflag>:
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     ccc:	80 93 45 38 	sts	0x3845, r24	; 0x803845 <tinyISR_interrupt_flag>
     cd0:	08 95       	ret

00000cd2 <tinyISR_getflag>:
}

_Bool tinyISR_getflag(void)
{
	return tinyISR_interrupt_flag;
}
     cd2:	80 91 45 38 	lds	r24, 0x3845	; 0x803845 <tinyISR_interrupt_flag>
     cd6:	08 95       	ret

00000cd8 <tinyLED_SPIWriteByte>:
Function used to send a byte over SPI, which in turn gets
translated to the bit-sequence required by the LEDs over the CCL.
*/
static void tinyLED_SPIWriteByte(uint8_t byte)
{
	SPI0.INTFLAGS = SPI0_INTFLAGS; // clear the write collision flag to allow writing
     cd8:	90 91 23 08 	lds	r25, 0x0823	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
     cdc:	90 93 23 08 	sts	0x0823, r25	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
	TCA0.SINGLE.CNT = 0; // reset TCA counter register to ensure the first rising edge of the PWM is predictable
     ce0:	e0 e0       	ldi	r30, 0x00	; 0
     ce2:	fa e0       	ldi	r31, 0x0A	; 10
     ce4:	10 a2       	std	Z+32, r1	; 0x20
     ce6:	11 a2       	std	Z+33, r1	; 0x21
	
	// start TCA
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 1 << TCA_SPLIT_ENABLE_bp;
     ce8:	91 e0       	ldi	r25, 0x01	; 1
     cea:	90 83       	st	Z, r25
	SPI0_DATA = byte;
     cec:	80 93 24 08 	sts	0x0824, r24	; 0x800824 <__TEXT_REGION_LENGTH__+0x700824>

	while((SPI0.INTFLAGS & SPI_RXCIE_bm) == 0){} // wait for transfer to complete
     cf0:	e0 e2       	ldi	r30, 0x20	; 32
     cf2:	f8 e0       	ldi	r31, 0x08	; 8
     cf4:	83 81       	ldd	r24, Z+3	; 0x03
     cf6:	88 23       	and	r24, r24
     cf8:	ec f7       	brge	.-6      	; 0xcf4 <tinyLED_SPIWriteByte+0x1c>
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 0 << TCA_SPLIT_ENABLE_bp; //Stop TCA
     cfa:	10 92 00 0a 	sts	0x0A00, r1	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
     cfe:	08 95       	ret

00000d00 <tinyLED_get_color>:
	tinyLED_set_color_mode(LED_id, color, STABLE);
}

enum Colors tinyLED_get_color(uint8_t LED_id)
{
	return tinyLED_settings[LED_id].color;
     d00:	e8 2f       	mov	r30, r24
     d02:	f0 e0       	ldi	r31, 0x00	; 0
     d04:	ee 0f       	add	r30, r30
     d06:	ff 1f       	adc	r31, r31
     d08:	ee 59       	subi	r30, 0x9E	; 158
     d0a:	f7 4c       	sbci	r31, 0xC7	; 199
}
     d0c:	80 81       	ld	r24, Z
     d0e:	08 95       	ret

00000d10 <tinyLED_set_color_mode>:
{
	// If we are in pulse mode, we want to stay in pulse mode after we have flashed a light.
	// We do this by storing the previous mode in old settings.
	// However, it can happen that two flashes comes very quickly after one another, that leads
	// to an infinite flash loop, therefore, we only store the settings if it is not flash mode.
	if(tinyLED_settings[LED_id].mode != FLASH_ONCE){
     d10:	90 e0       	ldi	r25, 0x00	; 0
     d12:	fc 01       	movw	r30, r24
     d14:	ee 0f       	add	r30, r30
     d16:	ff 1f       	adc	r31, r31
     d18:	ee 59       	subi	r30, 0x9E	; 158
     d1a:	f7 4c       	sbci	r31, 0xC7	; 199
     d1c:	51 81       	ldd	r21, Z+1	; 0x01
     d1e:	55 30       	cpi	r21, 0x05	; 5
     d20:	61 f0       	breq	.+24     	; 0xd3a <tinyLED_set_color_mode+0x2a>
		// We use two lines to avoid pointer trouble. (I'm not good with pointers)
		tinyLED_old_settings[LED_id].color = tinyLED_settings[LED_id].color;
     d22:	9c 01       	movw	r18, r24
     d24:	22 0f       	add	r18, r18
     d26:	33 1f       	adc	r19, r19
     d28:	f9 01       	movw	r30, r18
     d2a:	ea 59       	subi	r30, 0x9A	; 154
     d2c:	f7 4c       	sbci	r31, 0xC7	; 199
     d2e:	d9 01       	movw	r26, r18
     d30:	ae 59       	subi	r26, 0x9E	; 158
     d32:	b7 4c       	sbci	r27, 0xC7	; 199
     d34:	2c 91       	ld	r18, X
     d36:	20 83       	st	Z, r18
		tinyLED_old_settings[LED_id].mode = tinyLED_settings[LED_id].mode;
     d38:	51 83       	std	Z+1, r21	; 0x01
	}
	
	struct ColorSetting setting = {.color=color, .mode=mode};
	tinyLED_settings[LED_id] = setting;
     d3a:	fc 01       	movw	r30, r24
     d3c:	ee 0f       	add	r30, r30
     d3e:	ff 1f       	adc	r31, r31
     d40:	ee 59       	subi	r30, 0x9E	; 158
     d42:	f7 4c       	sbci	r31, 0xC7	; 199
     d44:	60 83       	st	Z, r22
     d46:	41 83       	std	Z+1, r20	; 0x01
	if (mode == FLASH_ONCE)
     d48:	45 30       	cpi	r20, 0x05	; 5
     d4a:	29 f4       	brne	.+10     	; 0xd56 <tinyLED_set_color_mode+0x46>
	{
		tinyLED_flash_once_time[LED_id] = 1000*FLASH_TIME;
     d4c:	fc 01       	movw	r30, r24
     d4e:	e6 5a       	subi	r30, 0xA6	; 166
     d50:	f7 4c       	sbci	r31, 0xC7	; 199
     d52:	2a e0       	ldi	r18, 0x0A	; 10
     d54:	20 83       	st	Z, r18
     d56:	08 95       	ret

00000d58 <tinyLED_set_color>:
/*
changes the values in the variables stored in the LED-array.
*/
void tinyLED_set_color(uint8_t LED_id, enum Colors color)
{
	tinyLED_set_color_mode(LED_id, color, STABLE);
     d58:	40 e0       	ldi	r20, 0x00	; 0
     d5a:	0e 94 88 06 	call	0xd10	; 0xd10 <tinyLED_set_color_mode>
     d5e:	08 95       	ret

00000d60 <tinyLED_RGB_Color_Compare>:
	return rgb_color;
			
};
// This might be cause of strange light behavior?
//Message		expected 'struct RGB_Color *' but argument is of type 'struct RGB_Color (*)[2]'	Hjernebyggesett_V4	C:\Users\Elias Lundheim\Documents\GitHub\neural\Hjernebyggesett_V4\Hjernebyggesett_V4\tinyLED\tinyLED.c	121
_Bool tinyLED_RGB_Color_Compare(struct RGB_Color (*a)[NUMBER_OF_LEDS], struct RGB_Color (*b)[NUMBER_OF_LEDS]){
     d60:	dc 01       	movw	r26, r24
     d62:	fb 01       	movw	r30, r22
	for (int i=0; i<NUMBER_OF_LEDS; i++)
	{
		if(!((*a)[i].red==(*b)[i].red && (*a)[i].green==(*b)[i].green && (*a)[i].blue==(*b)[i].blue)){
     d64:	9c 91       	ld	r25, X
     d66:	80 81       	ld	r24, Z
     d68:	98 13       	cpse	r25, r24
     d6a:	20 c0       	rjmp	.+64     	; 0xdac <tinyLED_RGB_Color_Compare+0x4c>
     d6c:	11 96       	adiw	r26, 0x01	; 1
     d6e:	9c 91       	ld	r25, X
     d70:	11 97       	sbiw	r26, 0x01	; 1
     d72:	81 81       	ldd	r24, Z+1	; 0x01
     d74:	98 13       	cpse	r25, r24
     d76:	1c c0       	rjmp	.+56     	; 0xdb0 <tinyLED_RGB_Color_Compare+0x50>
     d78:	12 96       	adiw	r26, 0x02	; 2
     d7a:	9c 91       	ld	r25, X
     d7c:	12 97       	sbiw	r26, 0x02	; 2
     d7e:	82 81       	ldd	r24, Z+2	; 0x02
     d80:	98 13       	cpse	r25, r24
     d82:	18 c0       	rjmp	.+48     	; 0xdb4 <tinyLED_RGB_Color_Compare+0x54>
     d84:	13 96       	adiw	r26, 0x03	; 3
     d86:	9c 91       	ld	r25, X
     d88:	13 97       	sbiw	r26, 0x03	; 3
     d8a:	83 81       	ldd	r24, Z+3	; 0x03
     d8c:	98 13       	cpse	r25, r24
     d8e:	14 c0       	rjmp	.+40     	; 0xdb8 <tinyLED_RGB_Color_Compare+0x58>
     d90:	14 96       	adiw	r26, 0x04	; 4
     d92:	9c 91       	ld	r25, X
     d94:	14 97       	sbiw	r26, 0x04	; 4
     d96:	84 81       	ldd	r24, Z+4	; 0x04
     d98:	98 13       	cpse	r25, r24
     d9a:	10 c0       	rjmp	.+32     	; 0xdbc <tinyLED_RGB_Color_Compare+0x5c>
     d9c:	81 e0       	ldi	r24, 0x01	; 1
     d9e:	15 96       	adiw	r26, 0x05	; 5
     da0:	2c 91       	ld	r18, X
     da2:	95 81       	ldd	r25, Z+5	; 0x05
     da4:	29 17       	cp	r18, r25
     da6:	59 f0       	breq	.+22     	; 0xdbe <tinyLED_RGB_Color_Compare+0x5e>
     da8:	80 e0       	ldi	r24, 0x00	; 0
     daa:	08 95       	ret
			return false;
     dac:	80 e0       	ldi	r24, 0x00	; 0
     dae:	08 95       	ret
     db0:	80 e0       	ldi	r24, 0x00	; 0
     db2:	08 95       	ret
     db4:	80 e0       	ldi	r24, 0x00	; 0
     db6:	08 95       	ret
     db8:	80 e0       	ldi	r24, 0x00	; 0
     dba:	08 95       	ret
     dbc:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	return true;
}
     dbe:	08 95       	ret

00000dc0 <tinyLED_update>:
/*
function to write the current LED-array on to the LEDs and
effectively update the values stored in the LEDs to the values stored in the MCU.
*/
void tinyLED_update(void)
{
     dc0:	2f 92       	push	r2
     dc2:	3f 92       	push	r3
     dc4:	4f 92       	push	r4
     dc6:	5f 92       	push	r5
     dc8:	6f 92       	push	r6
     dca:	7f 92       	push	r7
     dcc:	8f 92       	push	r8
     dce:	9f 92       	push	r9
     dd0:	af 92       	push	r10
     dd2:	bf 92       	push	r11
     dd4:	cf 92       	push	r12
     dd6:	df 92       	push	r13
     dd8:	ef 92       	push	r14
     dda:	ff 92       	push	r15
     ddc:	0f 93       	push	r16
     dde:	1f 93       	push	r17
     de0:	cf 93       	push	r28
     de2:	df 93       	push	r29
     de4:	cd b7       	in	r28, 0x3d	; 61
     de6:	de b7       	in	r29, 0x3e	; 62
     de8:	6f 97       	sbiw	r28, 0x1f	; 31
     dea:	cd bf       	out	0x3d, r28	; 61
     dec:	de bf       	out	0x3e, r29	; 62
			
	uint32_t now = tinyTime_now();
     dee:	0e 94 ee 09 	call	0x13dc	; 0x13dc <tinyTime_now>
     df2:	6b 01       	movw	r12, r22
     df4:	7c 01       	movw	r14, r24
	
	// This is a sin curve, but between 0 and 1 instead of -1 and 1
	double sinValue = 0.5+sin((double)now/(100*M_PI/SWING_RATE))/2;
     df6:	0e 94 44 0b 	call	0x1688	; 0x1688 <__floatunsisf>
     dfa:	22 ed       	ldi	r18, 0xD2	; 210
     dfc:	33 e5       	ldi	r19, 0x53	; 83
     dfe:	4b ef       	ldi	r20, 0xFB	; 251
     e00:	51 e4       	ldi	r21, 0x41	; 65
     e02:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <__divsf3>
     e06:	0e 94 24 0d 	call	0x1a48	; 0x1a48 <sin>
     e0a:	20 e0       	ldi	r18, 0x00	; 0
     e0c:	30 e0       	ldi	r19, 0x00	; 0
     e0e:	40 e0       	ldi	r20, 0x00	; 0
     e10:	5f e3       	ldi	r21, 0x3F	; 63
     e12:	0e 94 b7 0c 	call	0x196e	; 0x196e <__mulsf3>
     e16:	20 e0       	ldi	r18, 0x00	; 0
     e18:	30 e0       	ldi	r19, 0x00	; 0
     e1a:	40 e0       	ldi	r20, 0x00	; 0
     e1c:	5f e3       	ldi	r21, 0x3F	; 63
     e1e:	0e 94 f8 09 	call	0x13f0	; 0x13f0 <__addsf3>
     e22:	6f 83       	std	Y+7, r22	; 0x07
     e24:	78 87       	std	Y+8, r23	; 0x08
     e26:	89 87       	std	Y+9, r24	; 0x09
     e28:	9a 87       	std	Y+10, r25	; 0x0a
	
	// If FLASH_RATE is one, then that means that the left side of the "<" will just count from 0 to 1000, and flash_on will be true for half of the time
	_Bool flash_on = now%(uint32_t)(1000/FLASH_RATE)  <   500/FLASH_RATE;
     e2a:	c7 01       	movw	r24, r14
     e2c:	b6 01       	movw	r22, r12
     e2e:	22 e3       	ldi	r18, 0x32	; 50
     e30:	30 e0       	ldi	r19, 0x00	; 0
     e32:	40 e0       	ldi	r20, 0x00	; 0
     e34:	50 e0       	ldi	r21, 0x00	; 0
     e36:	0e 94 8d 0d 	call	0x1b1a	; 0x1b1a <__udivmodsi4>
     e3a:	0e 94 44 0b 	call	0x1688	; 0x1688 <__floatunsisf>
     e3e:	20 e0       	ldi	r18, 0x00	; 0
     e40:	30 e0       	ldi	r19, 0x00	; 0
     e42:	48 ec       	ldi	r20, 0xC8	; 200
     e44:	51 e4       	ldi	r21, 0x41	; 65
     e46:	0e 94 64 0a 	call	0x14c8	; 0x14c8 <__cmpsf2>
     e4a:	88 1f       	adc	r24, r24
     e4c:	88 27       	eor	r24, r24
     e4e:	88 1f       	adc	r24, r24
     e50:	8b 87       	std	Y+11, r24	; 0x0b
	
	// PING_RATE is usually small, so the left side counts to some large number. Since flash_time usually is also quite small,
	// the left side will usually be larger than the right
	_Bool ping_on =  now%(uint32_t)(1000/PING_RATE)   <   1000*FLASH_TIME;
     e52:	c7 01       	movw	r24, r14
     e54:	b6 01       	movw	r22, r12
     e56:	24 ef       	ldi	r18, 0xF4	; 244
     e58:	31 e0       	ldi	r19, 0x01	; 1
     e5a:	40 e0       	ldi	r20, 0x00	; 0
     e5c:	50 e0       	ldi	r21, 0x00	; 0
     e5e:	0e 94 8d 0d 	call	0x1b1a	; 0x1b1a <__udivmodsi4>
     e62:	0e 94 44 0b 	call	0x1688	; 0x1688 <__floatunsisf>
     e66:	20 e0       	ldi	r18, 0x00	; 0
     e68:	30 e0       	ldi	r19, 0x00	; 0
     e6a:	40 e2       	ldi	r20, 0x20	; 32
     e6c:	51 e4       	ldi	r21, 0x41	; 65
     e6e:	0e 94 64 0a 	call	0x14c8	; 0x14c8 <__cmpsf2>
     e72:	88 1f       	adc	r24, r24
     e74:	88 27       	eor	r24, r24
     e76:	88 1f       	adc	r24, r24
     e78:	0f 2e       	mov	r0, r31
     e7a:	f2 e6       	ldi	r31, 0x62	; 98
     e7c:	2f 2e       	mov	r2, r31
     e7e:	f8 e3       	ldi	r31, 0x38	; 56
     e80:	3f 2e       	mov	r3, r31
     e82:	f0 2d       	mov	r31, r0
     e84:	9e 01       	movw	r18, r28
     e86:	2f 5f       	subi	r18, 0xFF	; 255
     e88:	3f 4f       	sbci	r19, 0xFF	; 255
     e8a:	69 01       	movw	r12, r18
     e8c:	0f 2e       	mov	r0, r31
     e8e:	f6 e6       	ldi	r31, 0x66	; 102
     e90:	af 2e       	mov	r10, r31
     e92:	f8 e3       	ldi	r31, 0x38	; 56
     e94:	bf 2e       	mov	r11, r31
     e96:	f0 2d       	mov	r31, r0
     e98:	0a e5       	ldi	r16, 0x5A	; 90
     e9a:	18 e3       	ldi	r17, 0x38	; 56
     e9c:	0f 2e       	mov	r0, r31
     e9e:	f6 e6       	ldi	r31, 0x66	; 102
     ea0:	4f 2e       	mov	r4, r31
     ea2:	f8 e3       	ldi	r31, 0x38	; 56
     ea4:	5f 2e       	mov	r5, r31
     ea6:	f0 2d       	mov	r31, r0
     ea8:	39 01       	movw	r6, r18
			case SWING:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*sinValue, rgb_colors[i].green*sinValue, rgb_colors[i].blue*sinValue};
				break;
			case PING:
				// in the line below, fmin will either return 1 or 0, so each rgb color is either 0 or 255*PING_BRIGHTNESS
				rgb_colors[i] = (struct RGB_Color){255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].red)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].green)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].blue)*ping_on};
     eaa:	28 2f       	mov	r18, r24
     eac:	30 e0       	ldi	r19, 0x00	; 0
     eae:	40 e0       	ldi	r20, 0x00	; 0
     eb0:	50 e0       	ldi	r21, 0x00	; 0
     eb2:	28 8b       	std	Y+16, r18	; 0x10
     eb4:	39 8b       	std	Y+17, r19	; 0x11
     eb6:	4a 8b       	std	Y+18, r20	; 0x12
     eb8:	5b 8b       	std	Y+19, r21	; 0x13
     eba:	f1 01       	movw	r30, r2
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 0 << TCA_SPLIT_ENABLE_bp; //Stop TCA
}

static struct RGB_Color tinyLED_enum_to_RGB_Color(enum Colors color){
	struct RGB_Color rgb_color;
	switch(color)
     ebc:	80 81       	ld	r24, Z
     ebe:	83 30       	cpi	r24, 0x03	; 3
     ec0:	79 f0       	breq	.+30     	; 0xee0 <tinyLED_update+0x120>
     ec2:	28 f4       	brcc	.+10     	; 0xece <tinyLED_update+0x10e>
     ec4:	81 30       	cpi	r24, 0x01	; 1
     ec6:	41 f0       	breq	.+16     	; 0xed8 <tinyLED_update+0x118>
     ec8:	82 30       	cpi	r24, 0x02	; 2
     eca:	89 f0       	breq	.+34     	; 0xeee <tinyLED_update+0x12e>
     ecc:	28 c0       	rjmp	.+80     	; 0xf1e <tinyLED_update+0x15e>
     ece:	84 30       	cpi	r24, 0x04	; 4
     ed0:	a9 f0       	breq	.+42     	; 0xefc <tinyLED_update+0x13c>
     ed2:	85 30       	cpi	r24, 0x05	; 5
     ed4:	d1 f0       	breq	.+52     	; 0xf0a <tinyLED_update+0x14a>
     ed6:	23 c0       	rjmp	.+70     	; 0xf1e <tinyLED_update+0x15e>
	{
		case LED_OFF:
			rgb_color = (struct RGB_Color){0, 0, 0};
			break;
		case RED:
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 0, 0};
     ed8:	f1 2c       	mov	r15, r1
     eda:	e1 2c       	mov	r14, r1
     edc:	69 e1       	ldi	r22, 0x19	; 25
     ede:	22 c0       	rjmp	.+68     	; 0xf24 <tinyLED_update+0x164>
			break;
		case GREEN:
			rgb_color = (struct RGB_Color){0, 255*LED_BRIGHTNESS, 0};
     ee0:	f1 2c       	mov	r15, r1
     ee2:	0f 2e       	mov	r0, r31
     ee4:	f9 e1       	ldi	r31, 0x19	; 25
     ee6:	ef 2e       	mov	r14, r31
     ee8:	f0 2d       	mov	r31, r0
     eea:	60 e0       	ldi	r22, 0x00	; 0
     eec:	1b c0       	rjmp	.+54     	; 0xf24 <tinyLED_update+0x164>
			break;
		case BLUE:
			rgb_color = (struct RGB_Color){0, 0, 255*LED_BRIGHTNESS};
     eee:	0f 2e       	mov	r0, r31
     ef0:	f9 e1       	ldi	r31, 0x19	; 25
     ef2:	ff 2e       	mov	r15, r31
     ef4:	f0 2d       	mov	r31, r0
     ef6:	e1 2c       	mov	r14, r1
     ef8:	60 e0       	ldi	r22, 0x00	; 0
     efa:	14 c0       	rjmp	.+40     	; 0xf24 <tinyLED_update+0x164>
			break;
		case YELLOW:
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS, 0};
     efc:	f1 2c       	mov	r15, r1
     efe:	0f 2e       	mov	r0, r31
     f00:	f9 e1       	ldi	r31, 0x19	; 25
     f02:	ef 2e       	mov	r14, r31
     f04:	f0 2d       	mov	r31, r0
     f06:	69 e1       	ldi	r22, 0x19	; 25
     f08:	0d c0       	rjmp	.+26     	; 0xf24 <tinyLED_update+0x164>
			// Should the /3 be there? This requires testing.
			// After testing, findings were that at 0.1 brightness, one would see the three LEDs instead of one white led
			// We try with /2 instead.
			// We find that the best results come from not dividing by anything. At leasts in the lower brightness settings, and that
			// is where we suspect it will be most of the time. When we divide, the LEDs are so weak, that they appear as three lights instead of one.
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS};
     f0a:	0f 2e       	mov	r0, r31
     f0c:	f9 e1       	ldi	r31, 0x19	; 25
     f0e:	ff 2e       	mov	r15, r31
     f10:	f0 2d       	mov	r31, r0
     f12:	0f 2e       	mov	r0, r31
     f14:	f9 e1       	ldi	r31, 0x19	; 25
     f16:	ef 2e       	mov	r14, r31
     f18:	f0 2d       	mov	r31, r0
     f1a:	69 e1       	ldi	r22, 0x19	; 25
     f1c:	03 c0       	rjmp	.+6      	; 0xf24 <tinyLED_update+0x164>
static struct RGB_Color tinyLED_enum_to_RGB_Color(enum Colors color){
	struct RGB_Color rgb_color;
	switch(color)
	{
		case LED_OFF:
			rgb_color = (struct RGB_Color){0, 0, 0};
     f1e:	f1 2c       	mov	r15, r1
     f20:	e1 2c       	mov	r14, r1
     f22:	60 e0       	ldi	r22, 0x00	; 0
	
		
	for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
	{		
		// Convert enum to RGB_Color
		rgb_colors[i] = tinyLED_enum_to_RGB_Color(tinyLED_settings[i].color);
     f24:	d3 01       	movw	r26, r6
     f26:	6c 93       	st	X, r22
     f28:	11 96       	adiw	r26, 0x01	; 1
     f2a:	ec 92       	st	X, r14
     f2c:	11 97       	sbiw	r26, 0x01	; 1
     f2e:	12 96       	adiw	r26, 0x02	; 2
     f30:	fc 92       	st	X, r15
			
		// Adjust colors according to mode
		switch(tinyLED_settings[i].mode)
     f32:	81 81       	ldd	r24, Z+1	; 0x01
     f34:	83 30       	cpi	r24, 0x03	; 3
     f36:	09 f4       	brne	.+2      	; 0xf3a <tinyLED_update+0x17a>
     f38:	50 c0       	rjmp	.+160    	; 0xfda <tinyLED_update+0x21a>
     f3a:	28 f4       	brcc	.+10     	; 0xf46 <tinyLED_update+0x186>
     f3c:	81 30       	cpi	r24, 0x01	; 1
     f3e:	51 f0       	breq	.+20     	; 0xf54 <tinyLED_update+0x194>
     f40:	82 30       	cpi	r24, 0x02	; 2
     f42:	c9 f1       	breq	.+114    	; 0xfb6 <tinyLED_update+0x1f6>
     f44:	05 c1       	rjmp	.+522    	; 0x1150 <tinyLED_update+0x390>
     f46:	84 30       	cpi	r24, 0x04	; 4
     f48:	09 f4       	brne	.+2      	; 0xf4c <tinyLED_update+0x18c>
     f4a:	78 c0       	rjmp	.+240    	; 0x103c <tinyLED_update+0x27c>
     f4c:	85 30       	cpi	r24, 0x05	; 5
     f4e:	09 f4       	brne	.+2      	; 0xf52 <tinyLED_update+0x192>
     f50:	f2 c0       	rjmp	.+484    	; 0x1136 <tinyLED_update+0x376>
     f52:	fe c0       	rjmp	.+508    	; 0x1150 <tinyLED_update+0x390>
		{
			case STABLE:
				break;
			case WEAK:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*WEAK_BRIGHTNESS, rgb_colors[i].green*WEAK_BRIGHTNESS, rgb_colors[i].blue*WEAK_BRIGHTNESS};
     f54:	70 e0       	ldi	r23, 0x00	; 0
     f56:	80 e0       	ldi	r24, 0x00	; 0
     f58:	90 e0       	ldi	r25, 0x00	; 0
     f5a:	0e 94 46 0b 	call	0x168c	; 0x168c <__floatsisf>
     f5e:	2d ec       	ldi	r18, 0xCD	; 205
     f60:	3c ec       	ldi	r19, 0xCC	; 204
     f62:	4c ec       	ldi	r20, 0xCC	; 204
     f64:	5d e3       	ldi	r21, 0x3D	; 61
     f66:	0e 94 b7 0c 	call	0x196e	; 0x196e <__mulsf3>
     f6a:	0e 94 15 0b 	call	0x162a	; 0x162a <__fixunssfsi>
     f6e:	f3 01       	movw	r30, r6
     f70:	60 83       	st	Z, r22
     f72:	6e 2d       	mov	r22, r14
     f74:	70 e0       	ldi	r23, 0x00	; 0
     f76:	80 e0       	ldi	r24, 0x00	; 0
     f78:	90 e0       	ldi	r25, 0x00	; 0
     f7a:	0e 94 46 0b 	call	0x168c	; 0x168c <__floatsisf>
     f7e:	2d ec       	ldi	r18, 0xCD	; 205
     f80:	3c ec       	ldi	r19, 0xCC	; 204
     f82:	4c ec       	ldi	r20, 0xCC	; 204
     f84:	5d e3       	ldi	r21, 0x3D	; 61
     f86:	0e 94 b7 0c 	call	0x196e	; 0x196e <__mulsf3>
     f8a:	0e 94 15 0b 	call	0x162a	; 0x162a <__fixunssfsi>
     f8e:	d3 01       	movw	r26, r6
     f90:	11 96       	adiw	r26, 0x01	; 1
     f92:	6c 93       	st	X, r22
     f94:	6f 2d       	mov	r22, r15
     f96:	70 e0       	ldi	r23, 0x00	; 0
     f98:	80 e0       	ldi	r24, 0x00	; 0
     f9a:	90 e0       	ldi	r25, 0x00	; 0
     f9c:	0e 94 46 0b 	call	0x168c	; 0x168c <__floatsisf>
     fa0:	2d ec       	ldi	r18, 0xCD	; 205
     fa2:	3c ec       	ldi	r19, 0xCC	; 204
     fa4:	4c ec       	ldi	r20, 0xCC	; 204
     fa6:	5d e3       	ldi	r21, 0x3D	; 61
     fa8:	0e 94 b7 0c 	call	0x196e	; 0x196e <__mulsf3>
     fac:	0e 94 15 0b 	call	0x162a	; 0x162a <__fixunssfsi>
     fb0:	f3 01       	movw	r30, r6
     fb2:	62 83       	std	Z+2, r22	; 0x02
				break;
     fb4:	cd c0       	rjmp	.+410    	; 0x1150 <tinyLED_update+0x390>
			case FLASH:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*flash_on, rgb_colors[i].green*flash_on, rgb_colors[i].blue*flash_on};
     fb6:	fb 85       	ldd	r31, Y+11	; 0x0b
     fb8:	f6 9f       	mul	r31, r22
     fba:	60 2d       	mov	r22, r0
     fbc:	11 24       	eor	r1, r1
     fbe:	d3 01       	movw	r26, r6
     fc0:	6c 93       	st	X, r22
     fc2:	fe 9d       	mul	r31, r14
     fc4:	e0 2c       	mov	r14, r0
     fc6:	11 24       	eor	r1, r1
     fc8:	11 96       	adiw	r26, 0x01	; 1
     fca:	ec 92       	st	X, r14
     fcc:	11 97       	sbiw	r26, 0x01	; 1
     fce:	ff 9d       	mul	r31, r15
     fd0:	f0 2c       	mov	r15, r0
     fd2:	11 24       	eor	r1, r1
     fd4:	12 96       	adiw	r26, 0x02	; 2
     fd6:	fc 92       	st	X, r15
				break;
     fd8:	bb c0       	rjmp	.+374    	; 0x1150 <tinyLED_update+0x390>
			case SWING:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*sinValue, rgb_colors[i].green*sinValue, rgb_colors[i].blue*sinValue};
     fda:	70 e0       	ldi	r23, 0x00	; 0
     fdc:	80 e0       	ldi	r24, 0x00	; 0
     fde:	90 e0       	ldi	r25, 0x00	; 0
     fe0:	0e 94 46 0b 	call	0x168c	; 0x168c <__floatsisf>
     fe4:	2f 81       	ldd	r18, Y+7	; 0x07
     fe6:	38 85       	ldd	r19, Y+8	; 0x08
     fe8:	49 85       	ldd	r20, Y+9	; 0x09
     fea:	5a 85       	ldd	r21, Y+10	; 0x0a
     fec:	0e 94 b7 0c 	call	0x196e	; 0x196e <__mulsf3>
     ff0:	0e 94 15 0b 	call	0x162a	; 0x162a <__fixunssfsi>
     ff4:	f3 01       	movw	r30, r6
     ff6:	60 83       	st	Z, r22
     ff8:	6e 2d       	mov	r22, r14
     ffa:	70 e0       	ldi	r23, 0x00	; 0
     ffc:	80 e0       	ldi	r24, 0x00	; 0
     ffe:	90 e0       	ldi	r25, 0x00	; 0
    1000:	0e 94 46 0b 	call	0x168c	; 0x168c <__floatsisf>
    1004:	2f 81       	ldd	r18, Y+7	; 0x07
    1006:	38 85       	ldd	r19, Y+8	; 0x08
    1008:	49 85       	ldd	r20, Y+9	; 0x09
    100a:	5a 85       	ldd	r21, Y+10	; 0x0a
    100c:	0e 94 b7 0c 	call	0x196e	; 0x196e <__mulsf3>
    1010:	0e 94 15 0b 	call	0x162a	; 0x162a <__fixunssfsi>
    1014:	d3 01       	movw	r26, r6
    1016:	11 96       	adiw	r26, 0x01	; 1
    1018:	6c 93       	st	X, r22
    101a:	6f 2d       	mov	r22, r15
    101c:	70 e0       	ldi	r23, 0x00	; 0
    101e:	80 e0       	ldi	r24, 0x00	; 0
    1020:	90 e0       	ldi	r25, 0x00	; 0
    1022:	0e 94 46 0b 	call	0x168c	; 0x168c <__floatsisf>
    1026:	2f 81       	ldd	r18, Y+7	; 0x07
    1028:	38 85       	ldd	r19, Y+8	; 0x08
    102a:	49 85       	ldd	r20, Y+9	; 0x09
    102c:	5a 85       	ldd	r21, Y+10	; 0x0a
    102e:	0e 94 b7 0c 	call	0x196e	; 0x196e <__mulsf3>
    1032:	0e 94 15 0b 	call	0x162a	; 0x162a <__fixunssfsi>
    1036:	f3 01       	movw	r30, r6
    1038:	62 83       	std	Z+2, r22	; 0x02
				break;
    103a:	8a c0       	rjmp	.+276    	; 0x1150 <tinyLED_update+0x390>
			case PING:
				// in the line below, fmin will either return 1 or 0, so each rgb color is either 0 or 255*PING_BRIGHTNESS
				rgb_colors[i] = (struct RGB_Color){255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].red)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].green)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].blue)*ping_on};
    103c:	70 e0       	ldi	r23, 0x00	; 0
    103e:	80 e0       	ldi	r24, 0x00	; 0
    1040:	90 e0       	ldi	r25, 0x00	; 0
    1042:	0e 94 44 0b 	call	0x1688	; 0x1688 <__floatunsisf>
    1046:	9b 01       	movw	r18, r22
    1048:	ac 01       	movw	r20, r24
    104a:	60 e0       	ldi	r22, 0x00	; 0
    104c:	70 e0       	ldi	r23, 0x00	; 0
    104e:	80 e8       	ldi	r24, 0x80	; 128
    1050:	9f e3       	ldi	r25, 0x3F	; 63
    1052:	0e 94 81 0b 	call	0x1702	; 0x1702 <fmin>
    1056:	6c 8b       	std	Y+20, r22	; 0x14
    1058:	7d 8b       	std	Y+21, r23	; 0x15
    105a:	8e 8b       	std	Y+22, r24	; 0x16
    105c:	9f 8b       	std	Y+23, r25	; 0x17
    105e:	68 89       	ldd	r22, Y+16	; 0x10
    1060:	79 89       	ldd	r23, Y+17	; 0x11
    1062:	8a 89       	ldd	r24, Y+18	; 0x12
    1064:	9b 89       	ldd	r25, Y+19	; 0x13
    1066:	0e 94 46 0b 	call	0x168c	; 0x168c <__floatsisf>
    106a:	6c 87       	std	Y+12, r22	; 0x0c
    106c:	7d 87       	std	Y+13, r23	; 0x0d
    106e:	8e 87       	std	Y+14, r24	; 0x0e
    1070:	9f 87       	std	Y+15, r25	; 0x0f
    1072:	6e 2d       	mov	r22, r14
    1074:	70 e0       	ldi	r23, 0x00	; 0
    1076:	80 e0       	ldi	r24, 0x00	; 0
    1078:	90 e0       	ldi	r25, 0x00	; 0
    107a:	0e 94 44 0b 	call	0x1688	; 0x1688 <__floatunsisf>
    107e:	9b 01       	movw	r18, r22
    1080:	ac 01       	movw	r20, r24
    1082:	60 e0       	ldi	r22, 0x00	; 0
    1084:	70 e0       	ldi	r23, 0x00	; 0
    1086:	80 e8       	ldi	r24, 0x80	; 128
    1088:	9f e3       	ldi	r25, 0x3F	; 63
    108a:	0e 94 81 0b 	call	0x1702	; 0x1702 <fmin>
    108e:	68 8f       	std	Y+24, r22	; 0x18
    1090:	79 8f       	std	Y+25, r23	; 0x19
    1092:	8a 8f       	std	Y+26, r24	; 0x1a
    1094:	9b 8f       	std	Y+27, r25	; 0x1b
    1096:	6f 2d       	mov	r22, r15
    1098:	70 e0       	ldi	r23, 0x00	; 0
    109a:	80 e0       	ldi	r24, 0x00	; 0
    109c:	90 e0       	ldi	r25, 0x00	; 0
    109e:	0e 94 44 0b 	call	0x1688	; 0x1688 <__floatunsisf>
    10a2:	9b 01       	movw	r18, r22
    10a4:	ac 01       	movw	r20, r24
    10a6:	60 e0       	ldi	r22, 0x00	; 0
    10a8:	70 e0       	ldi	r23, 0x00	; 0
    10aa:	80 e8       	ldi	r24, 0x80	; 128
    10ac:	9f e3       	ldi	r25, 0x3F	; 63
    10ae:	0e 94 81 0b 	call	0x1702	; 0x1702 <fmin>
    10b2:	6c 8f       	std	Y+28, r22	; 0x1c
    10b4:	7d 8f       	std	Y+29, r23	; 0x1d
    10b6:	8e 8f       	std	Y+30, r24	; 0x1e
    10b8:	9f 8f       	std	Y+31, r25	; 0x1f
    10ba:	23 e3       	ldi	r18, 0x33	; 51
    10bc:	33 e3       	ldi	r19, 0x33	; 51
    10be:	43 ea       	ldi	r20, 0xA3	; 163
    10c0:	50 e4       	ldi	r21, 0x40	; 64
    10c2:	6c 89       	ldd	r22, Y+20	; 0x14
    10c4:	7d 89       	ldd	r23, Y+21	; 0x15
    10c6:	8e 89       	ldd	r24, Y+22	; 0x16
    10c8:	9f 89       	ldd	r25, Y+23	; 0x17
    10ca:	0e 94 b7 0c 	call	0x196e	; 0x196e <__mulsf3>
    10ce:	2c 85       	ldd	r18, Y+12	; 0x0c
    10d0:	3d 85       	ldd	r19, Y+13	; 0x0d
    10d2:	4e 85       	ldd	r20, Y+14	; 0x0e
    10d4:	5f 85       	ldd	r21, Y+15	; 0x0f
    10d6:	0e 94 b7 0c 	call	0x196e	; 0x196e <__mulsf3>
    10da:	0e 94 15 0b 	call	0x162a	; 0x162a <__fixunssfsi>
    10de:	d3 01       	movw	r26, r6
    10e0:	6c 93       	st	X, r22
    10e2:	23 e3       	ldi	r18, 0x33	; 51
    10e4:	33 e3       	ldi	r19, 0x33	; 51
    10e6:	43 ea       	ldi	r20, 0xA3	; 163
    10e8:	50 e4       	ldi	r21, 0x40	; 64
    10ea:	68 8d       	ldd	r22, Y+24	; 0x18
    10ec:	79 8d       	ldd	r23, Y+25	; 0x19
    10ee:	8a 8d       	ldd	r24, Y+26	; 0x1a
    10f0:	9b 8d       	ldd	r25, Y+27	; 0x1b
    10f2:	0e 94 b7 0c 	call	0x196e	; 0x196e <__mulsf3>
    10f6:	2c 85       	ldd	r18, Y+12	; 0x0c
    10f8:	3d 85       	ldd	r19, Y+13	; 0x0d
    10fa:	4e 85       	ldd	r20, Y+14	; 0x0e
    10fc:	5f 85       	ldd	r21, Y+15	; 0x0f
    10fe:	0e 94 b7 0c 	call	0x196e	; 0x196e <__mulsf3>
    1102:	0e 94 15 0b 	call	0x162a	; 0x162a <__fixunssfsi>
    1106:	f3 01       	movw	r30, r6
    1108:	61 83       	std	Z+1, r22	; 0x01
    110a:	23 e3       	ldi	r18, 0x33	; 51
    110c:	33 e3       	ldi	r19, 0x33	; 51
    110e:	43 ea       	ldi	r20, 0xA3	; 163
    1110:	50 e4       	ldi	r21, 0x40	; 64
    1112:	6c 8d       	ldd	r22, Y+28	; 0x1c
    1114:	7d 8d       	ldd	r23, Y+29	; 0x1d
    1116:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1118:	9f 8d       	ldd	r25, Y+31	; 0x1f
    111a:	0e 94 b7 0c 	call	0x196e	; 0x196e <__mulsf3>
    111e:	2c 85       	ldd	r18, Y+12	; 0x0c
    1120:	3d 85       	ldd	r19, Y+13	; 0x0d
    1122:	4e 85       	ldd	r20, Y+14	; 0x0e
    1124:	5f 85       	ldd	r21, Y+15	; 0x0f
    1126:	0e 94 b7 0c 	call	0x196e	; 0x196e <__mulsf3>
    112a:	0e 94 15 0b 	call	0x162a	; 0x162a <__fixunssfsi>
    112e:	d3 01       	movw	r26, r6
    1130:	12 96       	adiw	r26, 0x02	; 2
    1132:	6c 93       	st	X, r22
				break;
    1134:	0d c0       	rjmp	.+26     	; 0x1150 <tinyLED_update+0x390>
			case FLASH_ONCE:
				if(tinyLED_flash_once_time[i]>0){
    1136:	d8 01       	movw	r26, r16
    1138:	8c 91       	ld	r24, X
    113a:	88 23       	and	r24, r24
    113c:	19 f0       	breq	.+6      	; 0x1144 <tinyLED_update+0x384>
					rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red, rgb_colors[i].green, rgb_colors[i].blue};
					tinyLED_flash_once_time[i]--;
    113e:	81 50       	subi	r24, 0x01	; 1
    1140:	8c 93       	st	X, r24
    1142:	06 c0       	rjmp	.+12     	; 0x1150 <tinyLED_update+0x390>
				}
				else{
					// Here we return to the previous color and mode
					tinyLED_settings[i].color = tinyLED_old_settings[i].color;
    1144:	d5 01       	movw	r26, r10
    1146:	8c 91       	ld	r24, X
    1148:	80 83       	st	Z, r24
					tinyLED_settings[i].mode = tinyLED_old_settings[i].mode;
    114a:	11 96       	adiw	r26, 0x01	; 1
    114c:	8c 91       	ld	r24, X
    114e:	81 83       	std	Z+1, r24	; 0x01
    1150:	b2 e0       	ldi	r27, 0x02	; 2
    1152:	2b 0e       	add	r2, r27
    1154:	31 1c       	adc	r3, r1
    1156:	e3 e0       	ldi	r30, 0x03	; 3
    1158:	6e 0e       	add	r6, r30
    115a:	71 1c       	adc	r7, r1
    115c:	f2 e0       	ldi	r31, 0x02	; 2
    115e:	af 0e       	add	r10, r31
    1160:	b1 1c       	adc	r11, r1
    1162:	0f 5f       	subi	r16, 0xFF	; 255
    1164:	1f 4f       	sbci	r17, 0xFF	; 255
	
	// This is where we store all the actual color values we want to send to the LED
	struct RGB_Color rgb_colors[NUMBER_OF_LEDS];
	
		
	for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
    1166:	24 14       	cp	r2, r4
    1168:	35 04       	cpc	r3, r5
    116a:	09 f0       	breq	.+2      	; 0x116e <tinyLED_update+0x3ae>
    116c:	a6 ce       	rjmp	.-692    	; 0xeba <tinyLED_update+0xfa>
				break;
		}
	}
	
	// We only write to the LEDs if there is something to change. (eg. in SWING mode, we update the LEDs almost every cycle)
	if(!tinyLED_RGB_Color_Compare(&rgb_colors, &tinyLED_old_colors)){
    116e:	6c e5       	ldi	r22, 0x5C	; 92
    1170:	78 e3       	ldi	r23, 0x38	; 56
    1172:	ce 01       	movw	r24, r28
    1174:	01 96       	adiw	r24, 0x01	; 1
    1176:	0e 94 b0 06 	call	0xd60	; 0xd60 <tinyLED_RGB_Color_Compare>
    117a:	81 11       	cpse	r24, r1
    117c:	21 c0       	rjmp	.+66     	; 0x11c0 <tinyLED_update+0x400>
    117e:	0c e5       	ldi	r16, 0x5C	; 92
    1180:	18 e3       	ldi	r17, 0x38	; 56
    1182:	7e 01       	movw	r14, r28
    1184:	27 e0       	ldi	r18, 0x07	; 7
    1186:	e2 0e       	add	r14, r18
    1188:	f1 1c       	adc	r15, r1
		for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
		{
			// Write to LEDs
			//For some reason, the data-bus to the LEDs is serialized as GRB
			//which means the 24-bit data-bus will look like [Green[0:7], Red[0:7], Blue[0:7]]
			tinyLED_SPIWriteByte(rgb_colors[i].green);
    118a:	d6 01       	movw	r26, r12
    118c:	11 96       	adiw	r26, 0x01	; 1
    118e:	8c 91       	ld	r24, X
    1190:	0e 94 6c 06 	call	0xcd8	; 0xcd8 <tinyLED_SPIWriteByte>
			tinyLED_SPIWriteByte(rgb_colors[i].red);
    1194:	f6 01       	movw	r30, r12
    1196:	80 81       	ld	r24, Z
    1198:	0e 94 6c 06 	call	0xcd8	; 0xcd8 <tinyLED_SPIWriteByte>
			tinyLED_SPIWriteByte(rgb_colors[i].blue);
    119c:	d6 01       	movw	r26, r12
    119e:	12 96       	adiw	r26, 0x02	; 2
    11a0:	8c 91       	ld	r24, X
    11a2:	0e 94 6c 06 	call	0xcd8	; 0xcd8 <tinyLED_SPIWriteByte>
			tinyLED_old_colors[i] = rgb_colors[i];
    11a6:	f6 01       	movw	r30, r12
    11a8:	81 91       	ld	r24, Z+
    11aa:	91 91       	ld	r25, Z+
    11ac:	a1 91       	ld	r26, Z+
    11ae:	6f 01       	movw	r12, r30
    11b0:	f8 01       	movw	r30, r16
    11b2:	81 93       	st	Z+, r24
    11b4:	91 93       	st	Z+, r25
    11b6:	a1 93       	st	Z+, r26
    11b8:	8f 01       	movw	r16, r30
		}
	}
	
	// We only write to the LEDs if there is something to change. (eg. in SWING mode, we update the LEDs almost every cycle)
	if(!tinyLED_RGB_Color_Compare(&rgb_colors, &tinyLED_old_colors)){
		for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
    11ba:	ce 14       	cp	r12, r14
    11bc:	df 04       	cpc	r13, r15
    11be:	29 f7       	brne	.-54     	; 0x118a <tinyLED_update+0x3ca>
			tinyLED_old_colors[i] = rgb_colors[i];
		}
		//tinyDebugger_send_uint8("LED1 color", tinyLED_settings[0].color);
		//tinyDebugger_send_uint8("LED2 color", tinyLED_settings[1].color);
	}
}
    11c0:	6f 96       	adiw	r28, 0x1f	; 31
    11c2:	cd bf       	out	0x3d, r28	; 61
    11c4:	de bf       	out	0x3e, r29	; 62
    11c6:	df 91       	pop	r29
    11c8:	cf 91       	pop	r28
    11ca:	1f 91       	pop	r17
    11cc:	0f 91       	pop	r16
    11ce:	ff 90       	pop	r15
    11d0:	ef 90       	pop	r14
    11d2:	df 90       	pop	r13
    11d4:	cf 90       	pop	r12
    11d6:	bf 90       	pop	r11
    11d8:	af 90       	pop	r10
    11da:	9f 90       	pop	r9
    11dc:	8f 90       	pop	r8
    11de:	7f 90       	pop	r7
    11e0:	6f 90       	pop	r6
    11e2:	5f 90       	pop	r5
    11e4:	4f 90       	pop	r4
    11e6:	3f 90       	pop	r3
    11e8:	2f 90       	pop	r2
    11ea:	08 95       	ret

000011ec <tinyPotential_update>:

/*
Update the potential
*/
void tinyPotential_update()
{
    11ec:	cf 92       	push	r12
    11ee:	df 92       	push	r13
    11f0:	ef 92       	push	r14
    11f2:	ff 92       	push	r15
Function to decay the potential towards 0
*/
static void tinyPotential_decay()
{
		
	uint8_t time_since_last_update = tinyTime_now() - previous_update_time;
    11f4:	0e 94 ee 09 	call	0x13dc	; 0x13dc <tinyTime_now>
	tinyPotential_potential *= (exp(-((float)time_since_last_update/(float)TINYPOTENTIAL_TIME_CONST)));
    11f8:	80 91 46 38 	lds	r24, 0x3846	; 0x803846 <previous_update_time>
    11fc:	68 1b       	sub	r22, r24
    11fe:	70 e0       	ldi	r23, 0x00	; 0
    1200:	80 e0       	ldi	r24, 0x00	; 0
    1202:	90 e0       	ldi	r25, 0x00	; 0
    1204:	0e 94 44 0b 	call	0x1688	; 0x1688 <__floatunsisf>
    1208:	20 e0       	ldi	r18, 0x00	; 0
    120a:	30 e0       	ldi	r19, 0x00	; 0
    120c:	48 ec       	ldi	r20, 0xC8	; 200
    120e:	52 e4       	ldi	r21, 0x42	; 66
    1210:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <__divsf3>
    1214:	90 58       	subi	r25, 0x80	; 128
    1216:	0e 94 e3 0a 	call	0x15c6	; 0x15c6 <exp>
    121a:	20 91 4a 38 	lds	r18, 0x384A	; 0x80384a <tinyPotential_potential>
    121e:	30 91 4b 38 	lds	r19, 0x384B	; 0x80384b <tinyPotential_potential+0x1>
    1222:	40 91 4c 38 	lds	r20, 0x384C	; 0x80384c <tinyPotential_potential+0x2>
    1226:	50 91 4d 38 	lds	r21, 0x384D	; 0x80384d <tinyPotential_potential+0x3>
    122a:	0e 94 b7 0c 	call	0x196e	; 0x196e <__mulsf3>
    122e:	6b 01       	movw	r12, r22
    1230:	7c 01       	movw	r14, r24
	if(fabs(tinyPotential_potential)<0.1){
    1232:	9f 77       	andi	r25, 0x7F	; 127
    1234:	2d ec       	ldi	r18, 0xCD	; 205
    1236:	3c ec       	ldi	r19, 0xCC	; 204
    1238:	4c ec       	ldi	r20, 0xCC	; 204
    123a:	5d e3       	ldi	r21, 0x3D	; 61
    123c:	0e 94 64 0a 	call	0x14c8	; 0x14c8 <__cmpsf2>
    1240:	88 23       	and	r24, r24
    1242:	4c f0       	brlt	.+18     	; 0x1256 <tinyPotential_update+0x6a>
*/
static void tinyPotential_decay()
{
		
	uint8_t time_since_last_update = tinyTime_now() - previous_update_time;
	tinyPotential_potential *= (exp(-((float)time_since_last_update/(float)TINYPOTENTIAL_TIME_CONST)));
    1244:	c0 92 4a 38 	sts	0x384A, r12	; 0x80384a <tinyPotential_potential>
    1248:	d0 92 4b 38 	sts	0x384B, r13	; 0x80384b <tinyPotential_potential+0x1>
    124c:	e0 92 4c 38 	sts	0x384C, r14	; 0x80384c <tinyPotential_potential+0x2>
    1250:	f0 92 4d 38 	sts	0x384D, r15	; 0x80384d <tinyPotential_potential+0x3>
    1254:	08 c0       	rjmp	.+16     	; 0x1266 <tinyPotential_update+0x7a>
	if(fabs(tinyPotential_potential)<0.1){
		tinyPotential_potential=0;
    1256:	10 92 4a 38 	sts	0x384A, r1	; 0x80384a <tinyPotential_potential>
    125a:	10 92 4b 38 	sts	0x384B, r1	; 0x80384b <tinyPotential_potential+0x1>
    125e:	10 92 4c 38 	sts	0x384C, r1	; 0x80384c <tinyPotential_potential+0x2>
    1262:	10 92 4d 38 	sts	0x384D, r1	; 0x80384d <tinyPotential_potential+0x3>
	}
	previous_update_time = tinyTime_now();
    1266:	0e 94 ee 09 	call	0x13dc	; 0x13dc <tinyTime_now>
    126a:	60 93 46 38 	sts	0x3846, r22	; 0x803846 <previous_update_time>
    126e:	70 93 47 38 	sts	0x3847, r23	; 0x803847 <previous_update_time+0x1>
    1272:	80 93 48 38 	sts	0x3848, r24	; 0x803848 <previous_update_time+0x2>
    1276:	90 93 49 38 	sts	0x3849, r25	; 0x803849 <previous_update_time+0x3>
void tinyPotential_update()
{
	//Some of the potential in the neuron has decayed away
	tinyPotential_decay();
	// Update potential with values from Dendrites
	tinyPotential_potential = tinyDendrite_update_potential(tinyPotential_potential);
    127a:	60 91 4a 38 	lds	r22, 0x384A	; 0x80384a <tinyPotential_potential>
    127e:	70 91 4b 38 	lds	r23, 0x384B	; 0x80384b <tinyPotential_potential+0x1>
    1282:	80 91 4c 38 	lds	r24, 0x384C	; 0x80384c <tinyPotential_potential+0x2>
    1286:	90 91 4d 38 	lds	r25, 0x384D	; 0x80384d <tinyPotential_potential+0x3>
    128a:	0e 94 24 06 	call	0xc48	; 0xc48 <tinyDendrite_update_potential>
    128e:	60 93 4a 38 	sts	0x384A, r22	; 0x80384a <tinyPotential_potential>
    1292:	70 93 4b 38 	sts	0x384B, r23	; 0x80384b <tinyPotential_potential+0x1>
    1296:	80 93 4c 38 	sts	0x384C, r24	; 0x80384c <tinyPotential_potential+0x2>
    129a:	90 93 4d 38 	sts	0x384D, r25	; 0x80384d <tinyPotential_potential+0x3>
	
	// Update potential from button press
	tinyPotential_potential = tinyButton_update_potential(tinyPotential_potential);
    129e:	0e 94 36 04 	call	0x86c	; 0x86c <tinyButton_update_potential>
    12a2:	60 93 4a 38 	sts	0x384A, r22	; 0x80384a <tinyPotential_potential>
    12a6:	70 93 4b 38 	sts	0x384B, r23	; 0x80384b <tinyPotential_potential+0x1>
    12aa:	80 93 4c 38 	sts	0x384C, r24	; 0x80384c <tinyPotential_potential+0x2>
    12ae:	90 93 4d 38 	sts	0x384D, r25	; 0x80384d <tinyPotential_potential+0x3>
	
	// Update potential with values from spontaneous pulse.
	tinyPotential_potential = tinyPulse_update_potential(tinyPotential_potential);
    12b2:	0e 94 a2 09 	call	0x1344	; 0x1344 <tinyPulse_update_potential>
    12b6:	ab 01       	movw	r20, r22
    12b8:	bc 01       	movw	r22, r24
    12ba:	40 93 4a 38 	sts	0x384A, r20	; 0x80384a <tinyPotential_potential>
    12be:	50 93 4b 38 	sts	0x384B, r21	; 0x80384b <tinyPotential_potential+0x1>
    12c2:	60 93 4c 38 	sts	0x384C, r22	; 0x80384c <tinyPotential_potential+0x2>
    12c6:	70 93 4d 38 	sts	0x384D, r23	; 0x80384d <tinyPotential_potential+0x3>
	
	tinyDebugger_send_double("Potential", tinyPotential_potential);
    12ca:	80 e6       	ldi	r24, 0x60	; 96
    12cc:	96 ea       	ldi	r25, 0xA6	; 166
    12ce:	0e 94 e3 04 	call	0x9c6	; 0x9c6 <tinyDebugger_send_double>
	
	
	// Let the axon affect the potential
	// This is also where we decide whether or not the axon should fire
	tinyPotential_potential = tinyAxon_update_potential(tinyPotential_potential);
    12d2:	60 91 4a 38 	lds	r22, 0x384A	; 0x80384a <tinyPotential_potential>
    12d6:	70 91 4b 38 	lds	r23, 0x384B	; 0x80384b <tinyPotential_potential+0x1>
    12da:	80 91 4c 38 	lds	r24, 0x384C	; 0x80384c <tinyPotential_potential+0x2>
    12de:	90 91 4d 38 	lds	r25, 0x384D	; 0x80384d <tinyPotential_potential+0x3>
    12e2:	0e 94 11 03 	call	0x622	; 0x622 <tinyAxon_update_potential>
    12e6:	60 93 4a 38 	sts	0x384A, r22	; 0x80384a <tinyPotential_potential>
    12ea:	70 93 4b 38 	sts	0x384B, r23	; 0x80384b <tinyPotential_potential+0x1>
    12ee:	80 93 4c 38 	sts	0x384C, r24	; 0x80384c <tinyPotential_potential+0x2>
    12f2:	90 93 4d 38 	sts	0x384D, r25	; 0x80384d <tinyPotential_potential+0x3>
}
    12f6:	ff 90       	pop	r15
    12f8:	ef 90       	pop	r14
    12fa:	df 90       	pop	r13
    12fc:	cf 90       	pop	r12
    12fe:	08 95       	ret

00001300 <tinyPulse_toggle_pulse_mode>:
_Bool tinyPulse_is_in_pulse_mode(){
	return pulse_mode;
}

void tinyPulse_toggle_pulse_mode(){
	pulse_mode = !pulse_mode;
    1300:	90 91 54 38 	lds	r25, 0x3854	; 0x803854 <pulse_mode>
    1304:	81 e0       	ldi	r24, 0x01	; 1
    1306:	89 27       	eor	r24, r25
    1308:	80 93 54 38 	sts	0x3854, r24	; 0x803854 <pulse_mode>
	
	if(tinyPulse_is_in_pulse_mode()){
    130c:	88 23       	and	r24, r24
    130e:	59 f0       	breq	.+22     	; 0x1326 <tinyPulse_toggle_pulse_mode+0x26>
		tinyLED_set_color_mode(OUT_LED, PULSEMODE_COLOR, WEAK);
    1310:	41 e0       	ldi	r20, 0x01	; 1
    1312:	62 e0       	ldi	r22, 0x02	; 2
    1314:	81 e0       	ldi	r24, 0x01	; 1
    1316:	0e 94 88 06 	call	0xd10	; 0xd10 <tinyLED_set_color_mode>
		tinyLED_set_color_mode(INN_LED, PULSEMODE_COLOR, WEAK);
    131a:	41 e0       	ldi	r20, 0x01	; 1
    131c:	62 e0       	ldi	r22, 0x02	; 2
    131e:	80 e0       	ldi	r24, 0x00	; 0
    1320:	0e 94 88 06 	call	0xd10	; 0xd10 <tinyLED_set_color_mode>
    1324:	08 95       	ret
	}
	else{
		tinyLED_set_color(OUT_LED, LED_OFF);
    1326:	60 e0       	ldi	r22, 0x00	; 0
    1328:	81 e0       	ldi	r24, 0x01	; 1
    132a:	0e 94 ac 06 	call	0xd58	; 0xd58 <tinyLED_set_color>
		tinyLED_set_color(INN_LED, LED_OFF);
    132e:	60 e0       	ldi	r22, 0x00	; 0
    1330:	80 e0       	ldi	r24, 0x00	; 0
    1332:	0e 94 ac 06 	call	0xd58	; 0xd58 <tinyLED_set_color>
    1336:	08 95       	ret

00001338 <tinyPulse_set_pulse_mode>:
	}
}

void tinyPulse_set_pulse_mode(_Bool mode){
	if (pulse_mode != mode)
    1338:	90 91 54 38 	lds	r25, 0x3854	; 0x803854 <pulse_mode>
    133c:	98 13       	cpse	r25, r24
	{
		tinyPulse_toggle_pulse_mode();
    133e:	0e 94 80 09 	call	0x1300	; 0x1300 <tinyPulse_toggle_pulse_mode>
    1342:	08 95       	ret

00001344 <tinyPulse_update_potential>:
	}
}

double tinyPulse_update_potential(double potential){
    1344:	cf 92       	push	r12
    1346:	df 92       	push	r13
    1348:	ef 92       	push	r14
    134a:	ff 92       	push	r15
    134c:	6b 01       	movw	r12, r22
    134e:	7c 01       	movw	r14, r24
	if(pulse_mode){
    1350:	80 91 54 38 	lds	r24, 0x3854	; 0x803854 <pulse_mode>
    1354:	88 23       	and	r24, r24
    1356:	39 f1       	breq	.+78     	; 0x13a6 <tinyPulse_update_potential+0x62>
		
		time_since_last_pulse = tinyTime_now() - time_of_last_pulse;
    1358:	0e 94 ee 09 	call	0x13dc	; 0x13dc <tinyTime_now>
    135c:	20 91 50 38 	lds	r18, 0x3850	; 0x803850 <time_of_last_pulse>
    1360:	30 91 51 38 	lds	r19, 0x3851	; 0x803851 <time_of_last_pulse+0x1>
    1364:	62 1b       	sub	r22, r18
    1366:	73 0b       	sbc	r23, r19
    1368:	60 93 4e 38 	sts	0x384E, r22	; 0x80384e <time_since_last_pulse>
    136c:	70 93 4f 38 	sts	0x384F, r23	; 0x80384f <time_since_last_pulse+0x1>
		
		if(time_since_last_pulse >= ideal_time_between_pulses){
    1370:	80 91 13 38 	lds	r24, 0x3813	; 0x803813 <ideal_time_between_pulses>
    1374:	90 91 14 38 	lds	r25, 0x3814	; 0x803814 <ideal_time_between_pulses+0x1>
    1378:	68 17       	cp	r22, r24
    137a:	79 07       	cpc	r23, r25
    137c:	a0 f0       	brcs	.+40     	; 0x13a6 <tinyPulse_update_potential+0x62>
			// This isn't actually a button press. You could have a separate variable for this, but it seems unnecessary.
			potential += BUTTON_PRESS_REACTION;
    137e:	20 e0       	ldi	r18, 0x00	; 0
    1380:	30 e0       	ldi	r19, 0x00	; 0
    1382:	40 ed       	ldi	r20, 0xD0	; 208
    1384:	51 e4       	ldi	r21, 0x41	; 65
    1386:	c7 01       	movw	r24, r14
    1388:	b6 01       	movw	r22, r12
    138a:	0e 94 f8 09 	call	0x13f0	; 0x13f0 <__addsf3>
    138e:	6b 01       	movw	r12, r22
    1390:	7c 01       	movw	r14, r24
			time_of_last_pulse = tinyTime_now();			
    1392:	0e 94 ee 09 	call	0x13dc	; 0x13dc <tinyTime_now>
    1396:	60 93 50 38 	sts	0x3850, r22	; 0x803850 <time_of_last_pulse>
    139a:	70 93 51 38 	sts	0x3851, r23	; 0x803851 <time_of_last_pulse+0x1>
    139e:	80 93 52 38 	sts	0x3852, r24	; 0x803852 <time_of_last_pulse+0x2>
    13a2:	90 93 53 38 	sts	0x3853, r25	; 0x803853 <time_of_last_pulse+0x3>
		}
	}
	return potential;
}
    13a6:	c7 01       	movw	r24, r14
    13a8:	b6 01       	movw	r22, r12
    13aa:	ff 90       	pop	r15
    13ac:	ef 90       	pop	r14
    13ae:	df 90       	pop	r13
    13b0:	cf 90       	pop	r12
    13b2:	08 95       	ret

000013b4 <tinyTime_counter_increment>:
If the Interrupt Service Routine is clocked by a crystal oscillator
it gives a very precise timer-counter.
*/
void tinyTime_counter_increment(void)
{
	time_counter++;
    13b4:	80 91 55 38 	lds	r24, 0x3855	; 0x803855 <time_counter>
    13b8:	90 91 56 38 	lds	r25, 0x3856	; 0x803856 <time_counter+0x1>
    13bc:	a0 91 57 38 	lds	r26, 0x3857	; 0x803857 <time_counter+0x2>
    13c0:	b0 91 58 38 	lds	r27, 0x3858	; 0x803858 <time_counter+0x3>
    13c4:	01 96       	adiw	r24, 0x01	; 1
    13c6:	a1 1d       	adc	r26, r1
    13c8:	b1 1d       	adc	r27, r1
    13ca:	80 93 55 38 	sts	0x3855, r24	; 0x803855 <time_counter>
    13ce:	90 93 56 38 	sts	0x3856, r25	; 0x803856 <time_counter+0x1>
    13d2:	a0 93 57 38 	sts	0x3857, r26	; 0x803857 <time_counter+0x2>
    13d6:	b0 93 58 38 	sts	0x3858, r27	; 0x803858 <time_counter+0x3>
    13da:	08 95       	ret

000013dc <tinyTime_now>:
/*
This function is callable by external libraries to give them the counted time so far.
*/
uint32_t tinyTime_now(void)
{
	return time_counter;
    13dc:	60 91 55 38 	lds	r22, 0x3855	; 0x803855 <time_counter>
    13e0:	70 91 56 38 	lds	r23, 0x3856	; 0x803856 <time_counter+0x1>
    13e4:	80 91 57 38 	lds	r24, 0x3857	; 0x803857 <time_counter+0x2>
    13e8:	90 91 58 38 	lds	r25, 0x3858	; 0x803858 <time_counter+0x3>
    13ec:	08 95       	ret

000013ee <__subsf3>:
    13ee:	50 58       	subi	r21, 0x80	; 128

000013f0 <__addsf3>:
    13f0:	bb 27       	eor	r27, r27
    13f2:	aa 27       	eor	r26, r26
    13f4:	0e 94 0f 0a 	call	0x141e	; 0x141e <__addsf3x>
    13f8:	0c 94 02 0c 	jmp	0x1804	; 0x1804 <__fp_round>
    13fc:	0e 94 f4 0b 	call	0x17e8	; 0x17e8 <__fp_pscA>
    1400:	38 f0       	brcs	.+14     	; 0x1410 <__addsf3+0x20>
    1402:	0e 94 fb 0b 	call	0x17f6	; 0x17f6 <__fp_pscB>
    1406:	20 f0       	brcs	.+8      	; 0x1410 <__addsf3+0x20>
    1408:	39 f4       	brne	.+14     	; 0x1418 <__addsf3+0x28>
    140a:	9f 3f       	cpi	r25, 0xFF	; 255
    140c:	19 f4       	brne	.+6      	; 0x1414 <__addsf3+0x24>
    140e:	26 f4       	brtc	.+8      	; 0x1418 <__addsf3+0x28>
    1410:	0c 94 ca 0b 	jmp	0x1794	; 0x1794 <__fp_nan>
    1414:	0e f4       	brtc	.+2      	; 0x1418 <__addsf3+0x28>
    1416:	e0 95       	com	r30
    1418:	e7 fb       	bst	r30, 7
    141a:	0c 94 c4 0b 	jmp	0x1788	; 0x1788 <__fp_inf>

0000141e <__addsf3x>:
    141e:	e9 2f       	mov	r30, r25
    1420:	0e 94 13 0c 	call	0x1826	; 0x1826 <__fp_split3>
    1424:	58 f3       	brcs	.-42     	; 0x13fc <__addsf3+0xc>
    1426:	ba 17       	cp	r27, r26
    1428:	62 07       	cpc	r22, r18
    142a:	73 07       	cpc	r23, r19
    142c:	84 07       	cpc	r24, r20
    142e:	95 07       	cpc	r25, r21
    1430:	20 f0       	brcs	.+8      	; 0x143a <__addsf3x+0x1c>
    1432:	79 f4       	brne	.+30     	; 0x1452 <__addsf3x+0x34>
    1434:	a6 f5       	brtc	.+104    	; 0x149e <__addsf3x+0x80>
    1436:	0c 94 35 0c 	jmp	0x186a	; 0x186a <__fp_zero>
    143a:	0e f4       	brtc	.+2      	; 0x143e <__addsf3x+0x20>
    143c:	e0 95       	com	r30
    143e:	0b 2e       	mov	r0, r27
    1440:	ba 2f       	mov	r27, r26
    1442:	a0 2d       	mov	r26, r0
    1444:	0b 01       	movw	r0, r22
    1446:	b9 01       	movw	r22, r18
    1448:	90 01       	movw	r18, r0
    144a:	0c 01       	movw	r0, r24
    144c:	ca 01       	movw	r24, r20
    144e:	a0 01       	movw	r20, r0
    1450:	11 24       	eor	r1, r1
    1452:	ff 27       	eor	r31, r31
    1454:	59 1b       	sub	r21, r25
    1456:	99 f0       	breq	.+38     	; 0x147e <__addsf3x+0x60>
    1458:	59 3f       	cpi	r21, 0xF9	; 249
    145a:	50 f4       	brcc	.+20     	; 0x1470 <__addsf3x+0x52>
    145c:	50 3e       	cpi	r21, 0xE0	; 224
    145e:	68 f1       	brcs	.+90     	; 0x14ba <__addsf3x+0x9c>
    1460:	1a 16       	cp	r1, r26
    1462:	f0 40       	sbci	r31, 0x00	; 0
    1464:	a2 2f       	mov	r26, r18
    1466:	23 2f       	mov	r18, r19
    1468:	34 2f       	mov	r19, r20
    146a:	44 27       	eor	r20, r20
    146c:	58 5f       	subi	r21, 0xF8	; 248
    146e:	f3 cf       	rjmp	.-26     	; 0x1456 <__addsf3x+0x38>
    1470:	46 95       	lsr	r20
    1472:	37 95       	ror	r19
    1474:	27 95       	ror	r18
    1476:	a7 95       	ror	r26
    1478:	f0 40       	sbci	r31, 0x00	; 0
    147a:	53 95       	inc	r21
    147c:	c9 f7       	brne	.-14     	; 0x1470 <__addsf3x+0x52>
    147e:	7e f4       	brtc	.+30     	; 0x149e <__addsf3x+0x80>
    1480:	1f 16       	cp	r1, r31
    1482:	ba 0b       	sbc	r27, r26
    1484:	62 0b       	sbc	r22, r18
    1486:	73 0b       	sbc	r23, r19
    1488:	84 0b       	sbc	r24, r20
    148a:	ba f0       	brmi	.+46     	; 0x14ba <__addsf3x+0x9c>
    148c:	91 50       	subi	r25, 0x01	; 1
    148e:	a1 f0       	breq	.+40     	; 0x14b8 <__addsf3x+0x9a>
    1490:	ff 0f       	add	r31, r31
    1492:	bb 1f       	adc	r27, r27
    1494:	66 1f       	adc	r22, r22
    1496:	77 1f       	adc	r23, r23
    1498:	88 1f       	adc	r24, r24
    149a:	c2 f7       	brpl	.-16     	; 0x148c <__addsf3x+0x6e>
    149c:	0e c0       	rjmp	.+28     	; 0x14ba <__addsf3x+0x9c>
    149e:	ba 0f       	add	r27, r26
    14a0:	62 1f       	adc	r22, r18
    14a2:	73 1f       	adc	r23, r19
    14a4:	84 1f       	adc	r24, r20
    14a6:	48 f4       	brcc	.+18     	; 0x14ba <__addsf3x+0x9c>
    14a8:	87 95       	ror	r24
    14aa:	77 95       	ror	r23
    14ac:	67 95       	ror	r22
    14ae:	b7 95       	ror	r27
    14b0:	f7 95       	ror	r31
    14b2:	9e 3f       	cpi	r25, 0xFE	; 254
    14b4:	08 f0       	brcs	.+2      	; 0x14b8 <__addsf3x+0x9a>
    14b6:	b0 cf       	rjmp	.-160    	; 0x1418 <__addsf3+0x28>
    14b8:	93 95       	inc	r25
    14ba:	88 0f       	add	r24, r24
    14bc:	08 f0       	brcs	.+2      	; 0x14c0 <__addsf3x+0xa2>
    14be:	99 27       	eor	r25, r25
    14c0:	ee 0f       	add	r30, r30
    14c2:	97 95       	ror	r25
    14c4:	87 95       	ror	r24
    14c6:	08 95       	ret

000014c8 <__cmpsf2>:
    14c8:	0e 94 a0 0b 	call	0x1740	; 0x1740 <__fp_cmp>
    14cc:	08 f4       	brcc	.+2      	; 0x14d0 <__cmpsf2+0x8>
    14ce:	81 e0       	ldi	r24, 0x01	; 1
    14d0:	08 95       	ret

000014d2 <__divsf3>:
    14d2:	0e 94 7d 0a 	call	0x14fa	; 0x14fa <__divsf3x>
    14d6:	0c 94 02 0c 	jmp	0x1804	; 0x1804 <__fp_round>
    14da:	0e 94 fb 0b 	call	0x17f6	; 0x17f6 <__fp_pscB>
    14de:	58 f0       	brcs	.+22     	; 0x14f6 <__divsf3+0x24>
    14e0:	0e 94 f4 0b 	call	0x17e8	; 0x17e8 <__fp_pscA>
    14e4:	40 f0       	brcs	.+16     	; 0x14f6 <__divsf3+0x24>
    14e6:	29 f4       	brne	.+10     	; 0x14f2 <__divsf3+0x20>
    14e8:	5f 3f       	cpi	r21, 0xFF	; 255
    14ea:	29 f0       	breq	.+10     	; 0x14f6 <__divsf3+0x24>
    14ec:	0c 94 c4 0b 	jmp	0x1788	; 0x1788 <__fp_inf>
    14f0:	51 11       	cpse	r21, r1
    14f2:	0c 94 36 0c 	jmp	0x186c	; 0x186c <__fp_szero>
    14f6:	0c 94 ca 0b 	jmp	0x1794	; 0x1794 <__fp_nan>

000014fa <__divsf3x>:
    14fa:	0e 94 13 0c 	call	0x1826	; 0x1826 <__fp_split3>
    14fe:	68 f3       	brcs	.-38     	; 0x14da <__divsf3+0x8>

00001500 <__divsf3_pse>:
    1500:	99 23       	and	r25, r25
    1502:	b1 f3       	breq	.-20     	; 0x14f0 <__divsf3+0x1e>
    1504:	55 23       	and	r21, r21
    1506:	91 f3       	breq	.-28     	; 0x14ec <__divsf3+0x1a>
    1508:	95 1b       	sub	r25, r21
    150a:	55 0b       	sbc	r21, r21
    150c:	bb 27       	eor	r27, r27
    150e:	aa 27       	eor	r26, r26
    1510:	62 17       	cp	r22, r18
    1512:	73 07       	cpc	r23, r19
    1514:	84 07       	cpc	r24, r20
    1516:	38 f0       	brcs	.+14     	; 0x1526 <__divsf3_pse+0x26>
    1518:	9f 5f       	subi	r25, 0xFF	; 255
    151a:	5f 4f       	sbci	r21, 0xFF	; 255
    151c:	22 0f       	add	r18, r18
    151e:	33 1f       	adc	r19, r19
    1520:	44 1f       	adc	r20, r20
    1522:	aa 1f       	adc	r26, r26
    1524:	a9 f3       	breq	.-22     	; 0x1510 <__divsf3_pse+0x10>
    1526:	35 d0       	rcall	.+106    	; 0x1592 <__divsf3_pse+0x92>
    1528:	0e 2e       	mov	r0, r30
    152a:	3a f0       	brmi	.+14     	; 0x153a <__divsf3_pse+0x3a>
    152c:	e0 e8       	ldi	r30, 0x80	; 128
    152e:	32 d0       	rcall	.+100    	; 0x1594 <__divsf3_pse+0x94>
    1530:	91 50       	subi	r25, 0x01	; 1
    1532:	50 40       	sbci	r21, 0x00	; 0
    1534:	e6 95       	lsr	r30
    1536:	00 1c       	adc	r0, r0
    1538:	ca f7       	brpl	.-14     	; 0x152c <__divsf3_pse+0x2c>
    153a:	2b d0       	rcall	.+86     	; 0x1592 <__divsf3_pse+0x92>
    153c:	fe 2f       	mov	r31, r30
    153e:	29 d0       	rcall	.+82     	; 0x1592 <__divsf3_pse+0x92>
    1540:	66 0f       	add	r22, r22
    1542:	77 1f       	adc	r23, r23
    1544:	88 1f       	adc	r24, r24
    1546:	bb 1f       	adc	r27, r27
    1548:	26 17       	cp	r18, r22
    154a:	37 07       	cpc	r19, r23
    154c:	48 07       	cpc	r20, r24
    154e:	ab 07       	cpc	r26, r27
    1550:	b0 e8       	ldi	r27, 0x80	; 128
    1552:	09 f0       	breq	.+2      	; 0x1556 <__divsf3_pse+0x56>
    1554:	bb 0b       	sbc	r27, r27
    1556:	80 2d       	mov	r24, r0
    1558:	bf 01       	movw	r22, r30
    155a:	ff 27       	eor	r31, r31
    155c:	93 58       	subi	r25, 0x83	; 131
    155e:	5f 4f       	sbci	r21, 0xFF	; 255
    1560:	3a f0       	brmi	.+14     	; 0x1570 <__divsf3_pse+0x70>
    1562:	9e 3f       	cpi	r25, 0xFE	; 254
    1564:	51 05       	cpc	r21, r1
    1566:	78 f0       	brcs	.+30     	; 0x1586 <__divsf3_pse+0x86>
    1568:	0c 94 c4 0b 	jmp	0x1788	; 0x1788 <__fp_inf>
    156c:	0c 94 36 0c 	jmp	0x186c	; 0x186c <__fp_szero>
    1570:	5f 3f       	cpi	r21, 0xFF	; 255
    1572:	e4 f3       	brlt	.-8      	; 0x156c <__divsf3_pse+0x6c>
    1574:	98 3e       	cpi	r25, 0xE8	; 232
    1576:	d4 f3       	brlt	.-12     	; 0x156c <__divsf3_pse+0x6c>
    1578:	86 95       	lsr	r24
    157a:	77 95       	ror	r23
    157c:	67 95       	ror	r22
    157e:	b7 95       	ror	r27
    1580:	f7 95       	ror	r31
    1582:	9f 5f       	subi	r25, 0xFF	; 255
    1584:	c9 f7       	brne	.-14     	; 0x1578 <__divsf3_pse+0x78>
    1586:	88 0f       	add	r24, r24
    1588:	91 1d       	adc	r25, r1
    158a:	96 95       	lsr	r25
    158c:	87 95       	ror	r24
    158e:	97 f9       	bld	r25, 7
    1590:	08 95       	ret
    1592:	e1 e0       	ldi	r30, 0x01	; 1
    1594:	66 0f       	add	r22, r22
    1596:	77 1f       	adc	r23, r23
    1598:	88 1f       	adc	r24, r24
    159a:	bb 1f       	adc	r27, r27
    159c:	62 17       	cp	r22, r18
    159e:	73 07       	cpc	r23, r19
    15a0:	84 07       	cpc	r24, r20
    15a2:	ba 07       	cpc	r27, r26
    15a4:	20 f0       	brcs	.+8      	; 0x15ae <__divsf3_pse+0xae>
    15a6:	62 1b       	sub	r22, r18
    15a8:	73 0b       	sbc	r23, r19
    15aa:	84 0b       	sbc	r24, r20
    15ac:	ba 0b       	sbc	r27, r26
    15ae:	ee 1f       	adc	r30, r30
    15b0:	88 f7       	brcc	.-30     	; 0x1594 <__divsf3_pse+0x94>
    15b2:	e0 95       	com	r30
    15b4:	08 95       	ret
    15b6:	29 f4       	brne	.+10     	; 0x15c2 <__divsf3_pse+0xc2>
    15b8:	16 f0       	brts	.+4      	; 0x15be <__divsf3_pse+0xbe>
    15ba:	0c 94 c4 0b 	jmp	0x1788	; 0x1788 <__fp_inf>
    15be:	0c 94 35 0c 	jmp	0x186a	; 0x186a <__fp_zero>
    15c2:	0c 94 ca 0b 	jmp	0x1794	; 0x1794 <__fp_nan>

000015c6 <exp>:
    15c6:	0e 94 1b 0c 	call	0x1836	; 0x1836 <__fp_splitA>
    15ca:	a8 f3       	brcs	.-22     	; 0x15b6 <__divsf3_pse+0xb6>
    15cc:	96 38       	cpi	r25, 0x86	; 134
    15ce:	a0 f7       	brcc	.-24     	; 0x15b8 <__divsf3_pse+0xb8>
    15d0:	07 f8       	bld	r0, 7
    15d2:	0f 92       	push	r0
    15d4:	e8 94       	clt
    15d6:	2b e3       	ldi	r18, 0x3B	; 59
    15d8:	3a ea       	ldi	r19, 0xAA	; 170
    15da:	48 eb       	ldi	r20, 0xB8	; 184
    15dc:	5f e7       	ldi	r21, 0x7F	; 127
    15de:	0e 94 cd 0c 	call	0x199a	; 0x199a <__mulsf3_pse>
    15e2:	0f 92       	push	r0
    15e4:	0f 92       	push	r0
    15e6:	0f 92       	push	r0
    15e8:	4d b7       	in	r20, 0x3d	; 61
    15ea:	5e b7       	in	r21, 0x3e	; 62
    15ec:	0f 92       	push	r0
    15ee:	0e 94 83 0c 	call	0x1906	; 0x1906 <modf>
    15f2:	ec e7       	ldi	r30, 0x7C	; 124
    15f4:	f0 e0       	ldi	r31, 0x00	; 0
    15f6:	0e 94 cd 0b 	call	0x179a	; 0x179a <__fp_powser>
    15fa:	4f 91       	pop	r20
    15fc:	5f 91       	pop	r21
    15fe:	ef 91       	pop	r30
    1600:	ff 91       	pop	r31
    1602:	e5 95       	asr	r30
    1604:	ee 1f       	adc	r30, r30
    1606:	ff 1f       	adc	r31, r31
    1608:	49 f0       	breq	.+18     	; 0x161c <exp+0x56>
    160a:	fe 57       	subi	r31, 0x7E	; 126
    160c:	e0 68       	ori	r30, 0x80	; 128
    160e:	44 27       	eor	r20, r20
    1610:	ee 0f       	add	r30, r30
    1612:	44 1f       	adc	r20, r20
    1614:	fa 95       	dec	r31
    1616:	e1 f7       	brne	.-8      	; 0x1610 <exp+0x4a>
    1618:	41 95       	neg	r20
    161a:	55 0b       	sbc	r21, r21
    161c:	0e 94 4d 0c 	call	0x189a	; 0x189a <ldexp>
    1620:	0f 90       	pop	r0
    1622:	07 fe       	sbrs	r0, 7
    1624:	0c 94 41 0c 	jmp	0x1882	; 0x1882 <inverse>
    1628:	08 95       	ret

0000162a <__fixunssfsi>:
    162a:	0e 94 1b 0c 	call	0x1836	; 0x1836 <__fp_splitA>
    162e:	88 f0       	brcs	.+34     	; 0x1652 <__fixunssfsi+0x28>
    1630:	9f 57       	subi	r25, 0x7F	; 127
    1632:	98 f0       	brcs	.+38     	; 0x165a <__fixunssfsi+0x30>
    1634:	b9 2f       	mov	r27, r25
    1636:	99 27       	eor	r25, r25
    1638:	b7 51       	subi	r27, 0x17	; 23
    163a:	b0 f0       	brcs	.+44     	; 0x1668 <__fixunssfsi+0x3e>
    163c:	e1 f0       	breq	.+56     	; 0x1676 <__fixunssfsi+0x4c>
    163e:	66 0f       	add	r22, r22
    1640:	77 1f       	adc	r23, r23
    1642:	88 1f       	adc	r24, r24
    1644:	99 1f       	adc	r25, r25
    1646:	1a f0       	brmi	.+6      	; 0x164e <__fixunssfsi+0x24>
    1648:	ba 95       	dec	r27
    164a:	c9 f7       	brne	.-14     	; 0x163e <__fixunssfsi+0x14>
    164c:	14 c0       	rjmp	.+40     	; 0x1676 <__fixunssfsi+0x4c>
    164e:	b1 30       	cpi	r27, 0x01	; 1
    1650:	91 f0       	breq	.+36     	; 0x1676 <__fixunssfsi+0x4c>
    1652:	0e 94 35 0c 	call	0x186a	; 0x186a <__fp_zero>
    1656:	b1 e0       	ldi	r27, 0x01	; 1
    1658:	08 95       	ret
    165a:	0c 94 35 0c 	jmp	0x186a	; 0x186a <__fp_zero>
    165e:	67 2f       	mov	r22, r23
    1660:	78 2f       	mov	r23, r24
    1662:	88 27       	eor	r24, r24
    1664:	b8 5f       	subi	r27, 0xF8	; 248
    1666:	39 f0       	breq	.+14     	; 0x1676 <__fixunssfsi+0x4c>
    1668:	b9 3f       	cpi	r27, 0xF9	; 249
    166a:	cc f3       	brlt	.-14     	; 0x165e <__fixunssfsi+0x34>
    166c:	86 95       	lsr	r24
    166e:	77 95       	ror	r23
    1670:	67 95       	ror	r22
    1672:	b3 95       	inc	r27
    1674:	d9 f7       	brne	.-10     	; 0x166c <__fixunssfsi+0x42>
    1676:	3e f4       	brtc	.+14     	; 0x1686 <__fixunssfsi+0x5c>
    1678:	90 95       	com	r25
    167a:	80 95       	com	r24
    167c:	70 95       	com	r23
    167e:	61 95       	neg	r22
    1680:	7f 4f       	sbci	r23, 0xFF	; 255
    1682:	8f 4f       	sbci	r24, 0xFF	; 255
    1684:	9f 4f       	sbci	r25, 0xFF	; 255
    1686:	08 95       	ret

00001688 <__floatunsisf>:
    1688:	e8 94       	clt
    168a:	09 c0       	rjmp	.+18     	; 0x169e <__floatsisf+0x12>

0000168c <__floatsisf>:
    168c:	97 fb       	bst	r25, 7
    168e:	3e f4       	brtc	.+14     	; 0x169e <__floatsisf+0x12>
    1690:	90 95       	com	r25
    1692:	80 95       	com	r24
    1694:	70 95       	com	r23
    1696:	61 95       	neg	r22
    1698:	7f 4f       	sbci	r23, 0xFF	; 255
    169a:	8f 4f       	sbci	r24, 0xFF	; 255
    169c:	9f 4f       	sbci	r25, 0xFF	; 255
    169e:	99 23       	and	r25, r25
    16a0:	a9 f0       	breq	.+42     	; 0x16cc <__floatsisf+0x40>
    16a2:	f9 2f       	mov	r31, r25
    16a4:	96 e9       	ldi	r25, 0x96	; 150
    16a6:	bb 27       	eor	r27, r27
    16a8:	93 95       	inc	r25
    16aa:	f6 95       	lsr	r31
    16ac:	87 95       	ror	r24
    16ae:	77 95       	ror	r23
    16b0:	67 95       	ror	r22
    16b2:	b7 95       	ror	r27
    16b4:	f1 11       	cpse	r31, r1
    16b6:	f8 cf       	rjmp	.-16     	; 0x16a8 <__floatsisf+0x1c>
    16b8:	fa f4       	brpl	.+62     	; 0x16f8 <__floatsisf+0x6c>
    16ba:	bb 0f       	add	r27, r27
    16bc:	11 f4       	brne	.+4      	; 0x16c2 <__floatsisf+0x36>
    16be:	60 ff       	sbrs	r22, 0
    16c0:	1b c0       	rjmp	.+54     	; 0x16f8 <__floatsisf+0x6c>
    16c2:	6f 5f       	subi	r22, 0xFF	; 255
    16c4:	7f 4f       	sbci	r23, 0xFF	; 255
    16c6:	8f 4f       	sbci	r24, 0xFF	; 255
    16c8:	9f 4f       	sbci	r25, 0xFF	; 255
    16ca:	16 c0       	rjmp	.+44     	; 0x16f8 <__floatsisf+0x6c>
    16cc:	88 23       	and	r24, r24
    16ce:	11 f0       	breq	.+4      	; 0x16d4 <__floatsisf+0x48>
    16d0:	96 e9       	ldi	r25, 0x96	; 150
    16d2:	11 c0       	rjmp	.+34     	; 0x16f6 <__floatsisf+0x6a>
    16d4:	77 23       	and	r23, r23
    16d6:	21 f0       	breq	.+8      	; 0x16e0 <__floatsisf+0x54>
    16d8:	9e e8       	ldi	r25, 0x8E	; 142
    16da:	87 2f       	mov	r24, r23
    16dc:	76 2f       	mov	r23, r22
    16de:	05 c0       	rjmp	.+10     	; 0x16ea <__floatsisf+0x5e>
    16e0:	66 23       	and	r22, r22
    16e2:	71 f0       	breq	.+28     	; 0x1700 <__floatsisf+0x74>
    16e4:	96 e8       	ldi	r25, 0x86	; 134
    16e6:	86 2f       	mov	r24, r22
    16e8:	70 e0       	ldi	r23, 0x00	; 0
    16ea:	60 e0       	ldi	r22, 0x00	; 0
    16ec:	2a f0       	brmi	.+10     	; 0x16f8 <__floatsisf+0x6c>
    16ee:	9a 95       	dec	r25
    16f0:	66 0f       	add	r22, r22
    16f2:	77 1f       	adc	r23, r23
    16f4:	88 1f       	adc	r24, r24
    16f6:	da f7       	brpl	.-10     	; 0x16ee <__floatsisf+0x62>
    16f8:	88 0f       	add	r24, r24
    16fa:	96 95       	lsr	r25
    16fc:	87 95       	ror	r24
    16fe:	97 f9       	bld	r25, 7
    1700:	08 95       	ret

00001702 <fmin>:
    1702:	99 0f       	add	r25, r25
    1704:	bb 0b       	sbc	r27, r27
    1706:	55 0f       	add	r21, r21
    1708:	aa 0b       	sbc	r26, r26
    170a:	e0 e8       	ldi	r30, 0x80	; 128
    170c:	fe ef       	ldi	r31, 0xFE	; 254
    170e:	16 16       	cp	r1, r22
    1710:	17 06       	cpc	r1, r23
    1712:	e8 07       	cpc	r30, r24
    1714:	f9 07       	cpc	r31, r25
    1716:	70 f0       	brcs	.+28     	; 0x1734 <fmin+0x32>
    1718:	12 16       	cp	r1, r18
    171a:	13 06       	cpc	r1, r19
    171c:	e4 07       	cpc	r30, r20
    171e:	f5 07       	cpc	r31, r21
    1720:	60 f0       	brcs	.+24     	; 0x173a <fmin+0x38>
    1722:	ba 17       	cp	r27, r26
    1724:	54 f0       	brlt	.+20     	; 0x173a <fmin+0x38>
    1726:	31 f4       	brne	.+12     	; 0x1734 <fmin+0x32>
    1728:	26 17       	cp	r18, r22
    172a:	37 07       	cpc	r19, r23
    172c:	48 07       	cpc	r20, r24
    172e:	59 07       	cpc	r21, r25
    1730:	a7 95       	ror	r26
    1732:	1b f4       	brvc	.+6      	; 0x173a <fmin+0x38>
    1734:	b9 01       	movw	r22, r18
    1736:	ca 01       	movw	r24, r20
    1738:	ba 2f       	mov	r27, r26
    173a:	b6 95       	lsr	r27
    173c:	97 95       	ror	r25
    173e:	08 95       	ret

00001740 <__fp_cmp>:
    1740:	99 0f       	add	r25, r25
    1742:	00 08       	sbc	r0, r0
    1744:	55 0f       	add	r21, r21
    1746:	aa 0b       	sbc	r26, r26
    1748:	e0 e8       	ldi	r30, 0x80	; 128
    174a:	fe ef       	ldi	r31, 0xFE	; 254
    174c:	16 16       	cp	r1, r22
    174e:	17 06       	cpc	r1, r23
    1750:	e8 07       	cpc	r30, r24
    1752:	f9 07       	cpc	r31, r25
    1754:	c0 f0       	brcs	.+48     	; 0x1786 <__fp_cmp+0x46>
    1756:	12 16       	cp	r1, r18
    1758:	13 06       	cpc	r1, r19
    175a:	e4 07       	cpc	r30, r20
    175c:	f5 07       	cpc	r31, r21
    175e:	98 f0       	brcs	.+38     	; 0x1786 <__fp_cmp+0x46>
    1760:	62 1b       	sub	r22, r18
    1762:	73 0b       	sbc	r23, r19
    1764:	84 0b       	sbc	r24, r20
    1766:	95 0b       	sbc	r25, r21
    1768:	39 f4       	brne	.+14     	; 0x1778 <__fp_cmp+0x38>
    176a:	0a 26       	eor	r0, r26
    176c:	61 f0       	breq	.+24     	; 0x1786 <__fp_cmp+0x46>
    176e:	23 2b       	or	r18, r19
    1770:	24 2b       	or	r18, r20
    1772:	25 2b       	or	r18, r21
    1774:	21 f4       	brne	.+8      	; 0x177e <__fp_cmp+0x3e>
    1776:	08 95       	ret
    1778:	0a 26       	eor	r0, r26
    177a:	09 f4       	brne	.+2      	; 0x177e <__fp_cmp+0x3e>
    177c:	a1 40       	sbci	r26, 0x01	; 1
    177e:	a6 95       	lsr	r26
    1780:	8f ef       	ldi	r24, 0xFF	; 255
    1782:	81 1d       	adc	r24, r1
    1784:	81 1d       	adc	r24, r1
    1786:	08 95       	ret

00001788 <__fp_inf>:
    1788:	97 f9       	bld	r25, 7
    178a:	9f 67       	ori	r25, 0x7F	; 127
    178c:	80 e8       	ldi	r24, 0x80	; 128
    178e:	70 e0       	ldi	r23, 0x00	; 0
    1790:	60 e0       	ldi	r22, 0x00	; 0
    1792:	08 95       	ret

00001794 <__fp_nan>:
    1794:	9f ef       	ldi	r25, 0xFF	; 255
    1796:	80 ec       	ldi	r24, 0xC0	; 192
    1798:	08 95       	ret

0000179a <__fp_powser>:
    179a:	df 93       	push	r29
    179c:	cf 93       	push	r28
    179e:	1f 93       	push	r17
    17a0:	0f 93       	push	r16
    17a2:	ff 92       	push	r15
    17a4:	ef 92       	push	r14
    17a6:	df 92       	push	r13
    17a8:	7b 01       	movw	r14, r22
    17aa:	8c 01       	movw	r16, r24
    17ac:	68 94       	set
    17ae:	06 c0       	rjmp	.+12     	; 0x17bc <__fp_powser+0x22>
    17b0:	da 2e       	mov	r13, r26
    17b2:	ef 01       	movw	r28, r30
    17b4:	0e 94 ca 0c 	call	0x1994	; 0x1994 <__mulsf3x>
    17b8:	fe 01       	movw	r30, r28
    17ba:	e8 94       	clt
    17bc:	a5 91       	lpm	r26, Z+
    17be:	25 91       	lpm	r18, Z+
    17c0:	35 91       	lpm	r19, Z+
    17c2:	45 91       	lpm	r20, Z+
    17c4:	55 91       	lpm	r21, Z+
    17c6:	a6 f3       	brts	.-24     	; 0x17b0 <__fp_powser+0x16>
    17c8:	ef 01       	movw	r28, r30
    17ca:	0e 94 0f 0a 	call	0x141e	; 0x141e <__addsf3x>
    17ce:	fe 01       	movw	r30, r28
    17d0:	97 01       	movw	r18, r14
    17d2:	a8 01       	movw	r20, r16
    17d4:	da 94       	dec	r13
    17d6:	69 f7       	brne	.-38     	; 0x17b2 <__fp_powser+0x18>
    17d8:	df 90       	pop	r13
    17da:	ef 90       	pop	r14
    17dc:	ff 90       	pop	r15
    17de:	0f 91       	pop	r16
    17e0:	1f 91       	pop	r17
    17e2:	cf 91       	pop	r28
    17e4:	df 91       	pop	r29
    17e6:	08 95       	ret

000017e8 <__fp_pscA>:
    17e8:	00 24       	eor	r0, r0
    17ea:	0a 94       	dec	r0
    17ec:	16 16       	cp	r1, r22
    17ee:	17 06       	cpc	r1, r23
    17f0:	18 06       	cpc	r1, r24
    17f2:	09 06       	cpc	r0, r25
    17f4:	08 95       	ret

000017f6 <__fp_pscB>:
    17f6:	00 24       	eor	r0, r0
    17f8:	0a 94       	dec	r0
    17fa:	12 16       	cp	r1, r18
    17fc:	13 06       	cpc	r1, r19
    17fe:	14 06       	cpc	r1, r20
    1800:	05 06       	cpc	r0, r21
    1802:	08 95       	ret

00001804 <__fp_round>:
    1804:	09 2e       	mov	r0, r25
    1806:	03 94       	inc	r0
    1808:	00 0c       	add	r0, r0
    180a:	11 f4       	brne	.+4      	; 0x1810 <__fp_round+0xc>
    180c:	88 23       	and	r24, r24
    180e:	52 f0       	brmi	.+20     	; 0x1824 <__fp_round+0x20>
    1810:	bb 0f       	add	r27, r27
    1812:	40 f4       	brcc	.+16     	; 0x1824 <__fp_round+0x20>
    1814:	bf 2b       	or	r27, r31
    1816:	11 f4       	brne	.+4      	; 0x181c <__fp_round+0x18>
    1818:	60 ff       	sbrs	r22, 0
    181a:	04 c0       	rjmp	.+8      	; 0x1824 <__fp_round+0x20>
    181c:	6f 5f       	subi	r22, 0xFF	; 255
    181e:	7f 4f       	sbci	r23, 0xFF	; 255
    1820:	8f 4f       	sbci	r24, 0xFF	; 255
    1822:	9f 4f       	sbci	r25, 0xFF	; 255
    1824:	08 95       	ret

00001826 <__fp_split3>:
    1826:	57 fd       	sbrc	r21, 7
    1828:	90 58       	subi	r25, 0x80	; 128
    182a:	44 0f       	add	r20, r20
    182c:	55 1f       	adc	r21, r21
    182e:	59 f0       	breq	.+22     	; 0x1846 <__fp_splitA+0x10>
    1830:	5f 3f       	cpi	r21, 0xFF	; 255
    1832:	71 f0       	breq	.+28     	; 0x1850 <__fp_splitA+0x1a>
    1834:	47 95       	ror	r20

00001836 <__fp_splitA>:
    1836:	88 0f       	add	r24, r24
    1838:	97 fb       	bst	r25, 7
    183a:	99 1f       	adc	r25, r25
    183c:	61 f0       	breq	.+24     	; 0x1856 <__fp_splitA+0x20>
    183e:	9f 3f       	cpi	r25, 0xFF	; 255
    1840:	79 f0       	breq	.+30     	; 0x1860 <__fp_splitA+0x2a>
    1842:	87 95       	ror	r24
    1844:	08 95       	ret
    1846:	12 16       	cp	r1, r18
    1848:	13 06       	cpc	r1, r19
    184a:	14 06       	cpc	r1, r20
    184c:	55 1f       	adc	r21, r21
    184e:	f2 cf       	rjmp	.-28     	; 0x1834 <__fp_split3+0xe>
    1850:	46 95       	lsr	r20
    1852:	f1 df       	rcall	.-30     	; 0x1836 <__fp_splitA>
    1854:	08 c0       	rjmp	.+16     	; 0x1866 <__fp_splitA+0x30>
    1856:	16 16       	cp	r1, r22
    1858:	17 06       	cpc	r1, r23
    185a:	18 06       	cpc	r1, r24
    185c:	99 1f       	adc	r25, r25
    185e:	f1 cf       	rjmp	.-30     	; 0x1842 <__fp_splitA+0xc>
    1860:	86 95       	lsr	r24
    1862:	71 05       	cpc	r23, r1
    1864:	61 05       	cpc	r22, r1
    1866:	08 94       	sec
    1868:	08 95       	ret

0000186a <__fp_zero>:
    186a:	e8 94       	clt

0000186c <__fp_szero>:
    186c:	bb 27       	eor	r27, r27
    186e:	66 27       	eor	r22, r22
    1870:	77 27       	eor	r23, r23
    1872:	cb 01       	movw	r24, r22
    1874:	97 f9       	bld	r25, 7
    1876:	08 95       	ret

00001878 <__gesf2>:
    1878:	0e 94 a0 0b 	call	0x1740	; 0x1740 <__fp_cmp>
    187c:	08 f4       	brcc	.+2      	; 0x1880 <__gesf2+0x8>
    187e:	8f ef       	ldi	r24, 0xFF	; 255
    1880:	08 95       	ret

00001882 <inverse>:
    1882:	9b 01       	movw	r18, r22
    1884:	ac 01       	movw	r20, r24
    1886:	60 e0       	ldi	r22, 0x00	; 0
    1888:	70 e0       	ldi	r23, 0x00	; 0
    188a:	80 e8       	ldi	r24, 0x80	; 128
    188c:	9f e3       	ldi	r25, 0x3F	; 63
    188e:	0c 94 69 0a 	jmp	0x14d2	; 0x14d2 <__divsf3>
    1892:	0c 94 c4 0b 	jmp	0x1788	; 0x1788 <__fp_inf>
    1896:	0c 94 2c 0d 	jmp	0x1a58	; 0x1a58 <__fp_mpack>

0000189a <ldexp>:
    189a:	0e 94 1b 0c 	call	0x1836	; 0x1836 <__fp_splitA>
    189e:	d8 f3       	brcs	.-10     	; 0x1896 <inverse+0x14>
    18a0:	99 23       	and	r25, r25
    18a2:	c9 f3       	breq	.-14     	; 0x1896 <inverse+0x14>
    18a4:	94 0f       	add	r25, r20
    18a6:	51 1d       	adc	r21, r1
    18a8:	a3 f3       	brvs	.-24     	; 0x1892 <inverse+0x10>
    18aa:	91 50       	subi	r25, 0x01	; 1
    18ac:	50 40       	sbci	r21, 0x00	; 0
    18ae:	94 f0       	brlt	.+36     	; 0x18d4 <ldexp+0x3a>
    18b0:	59 f0       	breq	.+22     	; 0x18c8 <ldexp+0x2e>
    18b2:	88 23       	and	r24, r24
    18b4:	32 f0       	brmi	.+12     	; 0x18c2 <ldexp+0x28>
    18b6:	66 0f       	add	r22, r22
    18b8:	77 1f       	adc	r23, r23
    18ba:	88 1f       	adc	r24, r24
    18bc:	91 50       	subi	r25, 0x01	; 1
    18be:	50 40       	sbci	r21, 0x00	; 0
    18c0:	c1 f7       	brne	.-16     	; 0x18b2 <ldexp+0x18>
    18c2:	9e 3f       	cpi	r25, 0xFE	; 254
    18c4:	51 05       	cpc	r21, r1
    18c6:	2c f7       	brge	.-54     	; 0x1892 <inverse+0x10>
    18c8:	88 0f       	add	r24, r24
    18ca:	91 1d       	adc	r25, r1
    18cc:	96 95       	lsr	r25
    18ce:	87 95       	ror	r24
    18d0:	97 f9       	bld	r25, 7
    18d2:	08 95       	ret
    18d4:	5f 3f       	cpi	r21, 0xFF	; 255
    18d6:	ac f0       	brlt	.+42     	; 0x1902 <ldexp+0x68>
    18d8:	98 3e       	cpi	r25, 0xE8	; 232
    18da:	9c f0       	brlt	.+38     	; 0x1902 <ldexp+0x68>
    18dc:	bb 27       	eor	r27, r27
    18de:	86 95       	lsr	r24
    18e0:	77 95       	ror	r23
    18e2:	67 95       	ror	r22
    18e4:	b7 95       	ror	r27
    18e6:	08 f4       	brcc	.+2      	; 0x18ea <ldexp+0x50>
    18e8:	b1 60       	ori	r27, 0x01	; 1
    18ea:	93 95       	inc	r25
    18ec:	c1 f7       	brne	.-16     	; 0x18de <ldexp+0x44>
    18ee:	bb 0f       	add	r27, r27
    18f0:	58 f7       	brcc	.-42     	; 0x18c8 <ldexp+0x2e>
    18f2:	11 f4       	brne	.+4      	; 0x18f8 <ldexp+0x5e>
    18f4:	60 ff       	sbrs	r22, 0
    18f6:	e8 cf       	rjmp	.-48     	; 0x18c8 <ldexp+0x2e>
    18f8:	6f 5f       	subi	r22, 0xFF	; 255
    18fa:	7f 4f       	sbci	r23, 0xFF	; 255
    18fc:	8f 4f       	sbci	r24, 0xFF	; 255
    18fe:	9f 4f       	sbci	r25, 0xFF	; 255
    1900:	e3 cf       	rjmp	.-58     	; 0x18c8 <ldexp+0x2e>
    1902:	0c 94 36 0c 	jmp	0x186c	; 0x186c <__fp_szero>

00001906 <modf>:
    1906:	fa 01       	movw	r30, r20
    1908:	dc 01       	movw	r26, r24
    190a:	aa 0f       	add	r26, r26
    190c:	bb 1f       	adc	r27, r27
    190e:	9b 01       	movw	r18, r22
    1910:	ac 01       	movw	r20, r24
    1912:	bf 57       	subi	r27, 0x7F	; 127
    1914:	28 f4       	brcc	.+10     	; 0x1920 <modf+0x1a>
    1916:	22 27       	eor	r18, r18
    1918:	33 27       	eor	r19, r19
    191a:	44 27       	eor	r20, r20
    191c:	50 78       	andi	r21, 0x80	; 128
    191e:	20 c0       	rjmp	.+64     	; 0x1960 <modf+0x5a>
    1920:	b7 51       	subi	r27, 0x17	; 23
    1922:	90 f4       	brcc	.+36     	; 0x1948 <modf+0x42>
    1924:	ab 2f       	mov	r26, r27
    1926:	00 24       	eor	r0, r0
    1928:	46 95       	lsr	r20
    192a:	37 95       	ror	r19
    192c:	27 95       	ror	r18
    192e:	01 1c       	adc	r0, r1
    1930:	a3 95       	inc	r26
    1932:	d2 f3       	brmi	.-12     	; 0x1928 <modf+0x22>
    1934:	00 20       	and	r0, r0
    1936:	71 f0       	breq	.+28     	; 0x1954 <modf+0x4e>
    1938:	22 0f       	add	r18, r18
    193a:	33 1f       	adc	r19, r19
    193c:	44 1f       	adc	r20, r20
    193e:	b3 95       	inc	r27
    1940:	da f3       	brmi	.-10     	; 0x1938 <modf+0x32>
    1942:	0e d0       	rcall	.+28     	; 0x1960 <modf+0x5a>
    1944:	0c 94 f7 09 	jmp	0x13ee	; 0x13ee <__subsf3>
    1948:	61 30       	cpi	r22, 0x01	; 1
    194a:	71 05       	cpc	r23, r1
    194c:	a0 e8       	ldi	r26, 0x80	; 128
    194e:	8a 07       	cpc	r24, r26
    1950:	b9 46       	sbci	r27, 0x69	; 105
    1952:	30 f4       	brcc	.+12     	; 0x1960 <modf+0x5a>
    1954:	9b 01       	movw	r18, r22
    1956:	ac 01       	movw	r20, r24
    1958:	66 27       	eor	r22, r22
    195a:	77 27       	eor	r23, r23
    195c:	88 27       	eor	r24, r24
    195e:	90 78       	andi	r25, 0x80	; 128
    1960:	30 96       	adiw	r30, 0x00	; 0
    1962:	21 f0       	breq	.+8      	; 0x196c <modf+0x66>
    1964:	20 83       	st	Z, r18
    1966:	31 83       	std	Z+1, r19	; 0x01
    1968:	42 83       	std	Z+2, r20	; 0x02
    196a:	53 83       	std	Z+3, r21	; 0x03
    196c:	08 95       	ret

0000196e <__mulsf3>:
    196e:	0e 94 ca 0c 	call	0x1994	; 0x1994 <__mulsf3x>
    1972:	0c 94 02 0c 	jmp	0x1804	; 0x1804 <__fp_round>
    1976:	0e 94 f4 0b 	call	0x17e8	; 0x17e8 <__fp_pscA>
    197a:	38 f0       	brcs	.+14     	; 0x198a <__mulsf3+0x1c>
    197c:	0e 94 fb 0b 	call	0x17f6	; 0x17f6 <__fp_pscB>
    1980:	20 f0       	brcs	.+8      	; 0x198a <__mulsf3+0x1c>
    1982:	95 23       	and	r25, r21
    1984:	11 f0       	breq	.+4      	; 0x198a <__mulsf3+0x1c>
    1986:	0c 94 c4 0b 	jmp	0x1788	; 0x1788 <__fp_inf>
    198a:	0c 94 ca 0b 	jmp	0x1794	; 0x1794 <__fp_nan>
    198e:	11 24       	eor	r1, r1
    1990:	0c 94 36 0c 	jmp	0x186c	; 0x186c <__fp_szero>

00001994 <__mulsf3x>:
    1994:	0e 94 13 0c 	call	0x1826	; 0x1826 <__fp_split3>
    1998:	70 f3       	brcs	.-36     	; 0x1976 <__mulsf3+0x8>

0000199a <__mulsf3_pse>:
    199a:	95 9f       	mul	r25, r21
    199c:	c1 f3       	breq	.-16     	; 0x198e <__mulsf3+0x20>
    199e:	95 0f       	add	r25, r21
    19a0:	50 e0       	ldi	r21, 0x00	; 0
    19a2:	55 1f       	adc	r21, r21
    19a4:	62 9f       	mul	r22, r18
    19a6:	f0 01       	movw	r30, r0
    19a8:	72 9f       	mul	r23, r18
    19aa:	bb 27       	eor	r27, r27
    19ac:	f0 0d       	add	r31, r0
    19ae:	b1 1d       	adc	r27, r1
    19b0:	63 9f       	mul	r22, r19
    19b2:	aa 27       	eor	r26, r26
    19b4:	f0 0d       	add	r31, r0
    19b6:	b1 1d       	adc	r27, r1
    19b8:	aa 1f       	adc	r26, r26
    19ba:	64 9f       	mul	r22, r20
    19bc:	66 27       	eor	r22, r22
    19be:	b0 0d       	add	r27, r0
    19c0:	a1 1d       	adc	r26, r1
    19c2:	66 1f       	adc	r22, r22
    19c4:	82 9f       	mul	r24, r18
    19c6:	22 27       	eor	r18, r18
    19c8:	b0 0d       	add	r27, r0
    19ca:	a1 1d       	adc	r26, r1
    19cc:	62 1f       	adc	r22, r18
    19ce:	73 9f       	mul	r23, r19
    19d0:	b0 0d       	add	r27, r0
    19d2:	a1 1d       	adc	r26, r1
    19d4:	62 1f       	adc	r22, r18
    19d6:	83 9f       	mul	r24, r19
    19d8:	a0 0d       	add	r26, r0
    19da:	61 1d       	adc	r22, r1
    19dc:	22 1f       	adc	r18, r18
    19de:	74 9f       	mul	r23, r20
    19e0:	33 27       	eor	r19, r19
    19e2:	a0 0d       	add	r26, r0
    19e4:	61 1d       	adc	r22, r1
    19e6:	23 1f       	adc	r18, r19
    19e8:	84 9f       	mul	r24, r20
    19ea:	60 0d       	add	r22, r0
    19ec:	21 1d       	adc	r18, r1
    19ee:	82 2f       	mov	r24, r18
    19f0:	76 2f       	mov	r23, r22
    19f2:	6a 2f       	mov	r22, r26
    19f4:	11 24       	eor	r1, r1
    19f6:	9f 57       	subi	r25, 0x7F	; 127
    19f8:	50 40       	sbci	r21, 0x00	; 0
    19fa:	9a f0       	brmi	.+38     	; 0x1a22 <__mulsf3_pse+0x88>
    19fc:	f1 f0       	breq	.+60     	; 0x1a3a <__mulsf3_pse+0xa0>
    19fe:	88 23       	and	r24, r24
    1a00:	4a f0       	brmi	.+18     	; 0x1a14 <__mulsf3_pse+0x7a>
    1a02:	ee 0f       	add	r30, r30
    1a04:	ff 1f       	adc	r31, r31
    1a06:	bb 1f       	adc	r27, r27
    1a08:	66 1f       	adc	r22, r22
    1a0a:	77 1f       	adc	r23, r23
    1a0c:	88 1f       	adc	r24, r24
    1a0e:	91 50       	subi	r25, 0x01	; 1
    1a10:	50 40       	sbci	r21, 0x00	; 0
    1a12:	a9 f7       	brne	.-22     	; 0x19fe <__mulsf3_pse+0x64>
    1a14:	9e 3f       	cpi	r25, 0xFE	; 254
    1a16:	51 05       	cpc	r21, r1
    1a18:	80 f0       	brcs	.+32     	; 0x1a3a <__mulsf3_pse+0xa0>
    1a1a:	0c 94 c4 0b 	jmp	0x1788	; 0x1788 <__fp_inf>
    1a1e:	0c 94 36 0c 	jmp	0x186c	; 0x186c <__fp_szero>
    1a22:	5f 3f       	cpi	r21, 0xFF	; 255
    1a24:	e4 f3       	brlt	.-8      	; 0x1a1e <__mulsf3_pse+0x84>
    1a26:	98 3e       	cpi	r25, 0xE8	; 232
    1a28:	d4 f3       	brlt	.-12     	; 0x1a1e <__mulsf3_pse+0x84>
    1a2a:	86 95       	lsr	r24
    1a2c:	77 95       	ror	r23
    1a2e:	67 95       	ror	r22
    1a30:	b7 95       	ror	r27
    1a32:	f7 95       	ror	r31
    1a34:	e7 95       	ror	r30
    1a36:	9f 5f       	subi	r25, 0xFF	; 255
    1a38:	c1 f7       	brne	.-16     	; 0x1a2a <__mulsf3_pse+0x90>
    1a3a:	fe 2b       	or	r31, r30
    1a3c:	88 0f       	add	r24, r24
    1a3e:	91 1d       	adc	r25, r1
    1a40:	96 95       	lsr	r25
    1a42:	87 95       	ror	r24
    1a44:	97 f9       	bld	r25, 7
    1a46:	08 95       	ret

00001a48 <sin>:
    1a48:	9f 93       	push	r25
    1a4a:	0e 94 3c 0d 	call	0x1a78	; 0x1a78 <__fp_rempio2>
    1a4e:	0f 90       	pop	r0
    1a50:	07 fc       	sbrc	r0, 7
    1a52:	ee 5f       	subi	r30, 0xFE	; 254
    1a54:	0c 94 65 0d 	jmp	0x1aca	; 0x1aca <__fp_sinus>

00001a58 <__fp_mpack>:
    1a58:	9f 3f       	cpi	r25, 0xFF	; 255
    1a5a:	31 f0       	breq	.+12     	; 0x1a68 <__fp_mpack_finite+0xc>

00001a5c <__fp_mpack_finite>:
    1a5c:	91 50       	subi	r25, 0x01	; 1
    1a5e:	20 f4       	brcc	.+8      	; 0x1a68 <__fp_mpack_finite+0xc>
    1a60:	87 95       	ror	r24
    1a62:	77 95       	ror	r23
    1a64:	67 95       	ror	r22
    1a66:	b7 95       	ror	r27
    1a68:	88 0f       	add	r24, r24
    1a6a:	91 1d       	adc	r25, r1
    1a6c:	96 95       	lsr	r25
    1a6e:	87 95       	ror	r24
    1a70:	97 f9       	bld	r25, 7
    1a72:	08 95       	ret
    1a74:	0c 94 ca 0b 	jmp	0x1794	; 0x1794 <__fp_nan>

00001a78 <__fp_rempio2>:
    1a78:	0e 94 1b 0c 	call	0x1836	; 0x1836 <__fp_splitA>
    1a7c:	d8 f3       	brcs	.-10     	; 0x1a74 <__fp_mpack_finite+0x18>
    1a7e:	e8 94       	clt
    1a80:	e0 e0       	ldi	r30, 0x00	; 0
    1a82:	bb 27       	eor	r27, r27
    1a84:	9f 57       	subi	r25, 0x7F	; 127
    1a86:	f0 f0       	brcs	.+60     	; 0x1ac4 <__fp_rempio2+0x4c>
    1a88:	2a ed       	ldi	r18, 0xDA	; 218
    1a8a:	3f e0       	ldi	r19, 0x0F	; 15
    1a8c:	49 ec       	ldi	r20, 0xC9	; 201
    1a8e:	06 c0       	rjmp	.+12     	; 0x1a9c <__fp_rempio2+0x24>
    1a90:	ee 0f       	add	r30, r30
    1a92:	bb 0f       	add	r27, r27
    1a94:	66 1f       	adc	r22, r22
    1a96:	77 1f       	adc	r23, r23
    1a98:	88 1f       	adc	r24, r24
    1a9a:	28 f0       	brcs	.+10     	; 0x1aa6 <__fp_rempio2+0x2e>
    1a9c:	b2 3a       	cpi	r27, 0xA2	; 162
    1a9e:	62 07       	cpc	r22, r18
    1aa0:	73 07       	cpc	r23, r19
    1aa2:	84 07       	cpc	r24, r20
    1aa4:	28 f0       	brcs	.+10     	; 0x1ab0 <__fp_rempio2+0x38>
    1aa6:	b2 5a       	subi	r27, 0xA2	; 162
    1aa8:	62 0b       	sbc	r22, r18
    1aaa:	73 0b       	sbc	r23, r19
    1aac:	84 0b       	sbc	r24, r20
    1aae:	e3 95       	inc	r30
    1ab0:	9a 95       	dec	r25
    1ab2:	72 f7       	brpl	.-36     	; 0x1a90 <__fp_rempio2+0x18>
    1ab4:	80 38       	cpi	r24, 0x80	; 128
    1ab6:	30 f4       	brcc	.+12     	; 0x1ac4 <__fp_rempio2+0x4c>
    1ab8:	9a 95       	dec	r25
    1aba:	bb 0f       	add	r27, r27
    1abc:	66 1f       	adc	r22, r22
    1abe:	77 1f       	adc	r23, r23
    1ac0:	88 1f       	adc	r24, r24
    1ac2:	d2 f7       	brpl	.-12     	; 0x1ab8 <__fp_rempio2+0x40>
    1ac4:	90 48       	sbci	r25, 0x80	; 128
    1ac6:	0c 94 2e 0d 	jmp	0x1a5c	; 0x1a5c <__fp_mpack_finite>

00001aca <__fp_sinus>:
    1aca:	ef 93       	push	r30
    1acc:	e0 ff       	sbrs	r30, 0
    1ace:	07 c0       	rjmp	.+14     	; 0x1ade <__fp_sinus+0x14>
    1ad0:	a2 ea       	ldi	r26, 0xA2	; 162
    1ad2:	2a ed       	ldi	r18, 0xDA	; 218
    1ad4:	3f e0       	ldi	r19, 0x0F	; 15
    1ad6:	49 ec       	ldi	r20, 0xC9	; 201
    1ad8:	5f eb       	ldi	r21, 0xBF	; 191
    1ada:	0e 94 0f 0a 	call	0x141e	; 0x141e <__addsf3x>
    1ade:	0e 94 02 0c 	call	0x1804	; 0x1804 <__fp_round>
    1ae2:	0f 90       	pop	r0
    1ae4:	03 94       	inc	r0
    1ae6:	01 fc       	sbrc	r0, 1
    1ae8:	90 58       	subi	r25, 0x80	; 128
    1aea:	e4 ea       	ldi	r30, 0xA4	; 164
    1aec:	f0 e0       	ldi	r31, 0x00	; 0
    1aee:	0c 94 79 0d 	jmp	0x1af2	; 0x1af2 <__fp_powsodd>

00001af2 <__fp_powsodd>:
    1af2:	9f 93       	push	r25
    1af4:	8f 93       	push	r24
    1af6:	7f 93       	push	r23
    1af8:	6f 93       	push	r22
    1afa:	ff 93       	push	r31
    1afc:	ef 93       	push	r30
    1afe:	9b 01       	movw	r18, r22
    1b00:	ac 01       	movw	r20, r24
    1b02:	0e 94 b7 0c 	call	0x196e	; 0x196e <__mulsf3>
    1b06:	ef 91       	pop	r30
    1b08:	ff 91       	pop	r31
    1b0a:	0e 94 cd 0b 	call	0x179a	; 0x179a <__fp_powser>
    1b0e:	2f 91       	pop	r18
    1b10:	3f 91       	pop	r19
    1b12:	4f 91       	pop	r20
    1b14:	5f 91       	pop	r21
    1b16:	0c 94 b7 0c 	jmp	0x196e	; 0x196e <__mulsf3>

00001b1a <__udivmodsi4>:
    1b1a:	a1 e2       	ldi	r26, 0x21	; 33
    1b1c:	1a 2e       	mov	r1, r26
    1b1e:	aa 1b       	sub	r26, r26
    1b20:	bb 1b       	sub	r27, r27
    1b22:	fd 01       	movw	r30, r26
    1b24:	0d c0       	rjmp	.+26     	; 0x1b40 <__udivmodsi4_ep>

00001b26 <__udivmodsi4_loop>:
    1b26:	aa 1f       	adc	r26, r26
    1b28:	bb 1f       	adc	r27, r27
    1b2a:	ee 1f       	adc	r30, r30
    1b2c:	ff 1f       	adc	r31, r31
    1b2e:	a2 17       	cp	r26, r18
    1b30:	b3 07       	cpc	r27, r19
    1b32:	e4 07       	cpc	r30, r20
    1b34:	f5 07       	cpc	r31, r21
    1b36:	20 f0       	brcs	.+8      	; 0x1b40 <__udivmodsi4_ep>
    1b38:	a2 1b       	sub	r26, r18
    1b3a:	b3 0b       	sbc	r27, r19
    1b3c:	e4 0b       	sbc	r30, r20
    1b3e:	f5 0b       	sbc	r31, r21

00001b40 <__udivmodsi4_ep>:
    1b40:	66 1f       	adc	r22, r22
    1b42:	77 1f       	adc	r23, r23
    1b44:	88 1f       	adc	r24, r24
    1b46:	99 1f       	adc	r25, r25
    1b48:	1a 94       	dec	r1
    1b4a:	69 f7       	brne	.-38     	; 0x1b26 <__udivmodsi4_loop>
    1b4c:	60 95       	com	r22
    1b4e:	70 95       	com	r23
    1b50:	80 95       	com	r24
    1b52:	90 95       	com	r25
    1b54:	9b 01       	movw	r18, r22
    1b56:	ac 01       	movw	r20, r24
    1b58:	bd 01       	movw	r22, r26
    1b5a:	cf 01       	movw	r24, r30
    1b5c:	08 95       	ret

00001b5e <dtostrf>:
    1b5e:	ef 92       	push	r14
    1b60:	0f 93       	push	r16
    1b62:	1f 93       	push	r17
    1b64:	cf 93       	push	r28
    1b66:	df 93       	push	r29
    1b68:	e8 01       	movw	r28, r16
    1b6a:	47 fd       	sbrc	r20, 7
    1b6c:	02 c0       	rjmp	.+4      	; 0x1b72 <dtostrf+0x14>
    1b6e:	34 e0       	ldi	r19, 0x04	; 4
    1b70:	01 c0       	rjmp	.+2      	; 0x1b74 <dtostrf+0x16>
    1b72:	34 e1       	ldi	r19, 0x14	; 20
    1b74:	04 2e       	mov	r0, r20
    1b76:	00 0c       	add	r0, r0
    1b78:	55 0b       	sbc	r21, r21
    1b7a:	57 ff       	sbrs	r21, 7
    1b7c:	03 c0       	rjmp	.+6      	; 0x1b84 <dtostrf+0x26>
    1b7e:	51 95       	neg	r21
    1b80:	41 95       	neg	r20
    1b82:	51 09       	sbc	r21, r1
    1b84:	e3 2e       	mov	r14, r19
    1b86:	02 2f       	mov	r16, r18
    1b88:	24 2f       	mov	r18, r20
    1b8a:	ae 01       	movw	r20, r28
    1b8c:	0e 94 f6 0f 	call	0x1fec	; 0x1fec <dtoa_prf>
    1b90:	ce 01       	movw	r24, r28
    1b92:	df 91       	pop	r29
    1b94:	cf 91       	pop	r28
    1b96:	1f 91       	pop	r17
    1b98:	0f 91       	pop	r16
    1b9a:	ef 90       	pop	r14
    1b9c:	08 95       	ret

00001b9e <printf>:
    1b9e:	a0 e0       	ldi	r26, 0x00	; 0
    1ba0:	b0 e0       	ldi	r27, 0x00	; 0
    1ba2:	e5 ed       	ldi	r30, 0xD5	; 213
    1ba4:	fd e0       	ldi	r31, 0x0D	; 13
    1ba6:	0c 94 e8 12 	jmp	0x25d0	; 0x25d0 <__prologue_saves__+0x20>
    1baa:	ae 01       	movw	r20, r28
    1bac:	4b 5f       	subi	r20, 0xFB	; 251
    1bae:	5f 4f       	sbci	r21, 0xFF	; 255
    1bb0:	fa 01       	movw	r30, r20
    1bb2:	61 91       	ld	r22, Z+
    1bb4:	71 91       	ld	r23, Z+
    1bb6:	af 01       	movw	r20, r30
    1bb8:	80 91 6c 38 	lds	r24, 0x386C	; 0x80386c <__iob+0x2>
    1bbc:	90 91 6d 38 	lds	r25, 0x386D	; 0x80386d <__iob+0x3>
    1bc0:	0e 94 15 0e 	call	0x1c2a	; 0x1c2a <vfprintf>
    1bc4:	e2 e0       	ldi	r30, 0x02	; 2
    1bc6:	0c 94 01 13 	jmp	0x2602	; 0x2602 <__epilogue_restores__+0x20>

00001bca <puts>:
    1bca:	0f 93       	push	r16
    1bcc:	1f 93       	push	r17
    1bce:	cf 93       	push	r28
    1bd0:	df 93       	push	r29
    1bd2:	e0 91 6c 38 	lds	r30, 0x386C	; 0x80386c <__iob+0x2>
    1bd6:	f0 91 6d 38 	lds	r31, 0x386D	; 0x80386d <__iob+0x3>
    1bda:	23 81       	ldd	r18, Z+3	; 0x03
    1bdc:	21 ff       	sbrs	r18, 1
    1bde:	1b c0       	rjmp	.+54     	; 0x1c16 <puts+0x4c>
    1be0:	8c 01       	movw	r16, r24
    1be2:	d0 e0       	ldi	r29, 0x00	; 0
    1be4:	c0 e0       	ldi	r28, 0x00	; 0
    1be6:	f8 01       	movw	r30, r16
    1be8:	81 91       	ld	r24, Z+
    1bea:	8f 01       	movw	r16, r30
    1bec:	60 91 6c 38 	lds	r22, 0x386C	; 0x80386c <__iob+0x2>
    1bf0:	70 91 6d 38 	lds	r23, 0x386D	; 0x80386d <__iob+0x3>
    1bf4:	db 01       	movw	r26, r22
    1bf6:	18 96       	adiw	r26, 0x08	; 8
    1bf8:	ed 91       	ld	r30, X+
    1bfa:	fc 91       	ld	r31, X
    1bfc:	19 97       	sbiw	r26, 0x09	; 9
    1bfe:	88 23       	and	r24, r24
    1c00:	31 f0       	breq	.+12     	; 0x1c0e <puts+0x44>
    1c02:	09 95       	icall
    1c04:	89 2b       	or	r24, r25
    1c06:	79 f3       	breq	.-34     	; 0x1be6 <puts+0x1c>
    1c08:	df ef       	ldi	r29, 0xFF	; 255
    1c0a:	cf ef       	ldi	r28, 0xFF	; 255
    1c0c:	ec cf       	rjmp	.-40     	; 0x1be6 <puts+0x1c>
    1c0e:	8a e0       	ldi	r24, 0x0A	; 10
    1c10:	09 95       	icall
    1c12:	89 2b       	or	r24, r25
    1c14:	19 f0       	breq	.+6      	; 0x1c1c <puts+0x52>
    1c16:	8f ef       	ldi	r24, 0xFF	; 255
    1c18:	9f ef       	ldi	r25, 0xFF	; 255
    1c1a:	02 c0       	rjmp	.+4      	; 0x1c20 <puts+0x56>
    1c1c:	8d 2f       	mov	r24, r29
    1c1e:	9c 2f       	mov	r25, r28
    1c20:	df 91       	pop	r29
    1c22:	cf 91       	pop	r28
    1c24:	1f 91       	pop	r17
    1c26:	0f 91       	pop	r16
    1c28:	08 95       	ret

00001c2a <vfprintf>:
    1c2a:	ab e0       	ldi	r26, 0x0B	; 11
    1c2c:	b0 e0       	ldi	r27, 0x00	; 0
    1c2e:	eb e1       	ldi	r30, 0x1B	; 27
    1c30:	fe e0       	ldi	r31, 0x0E	; 14
    1c32:	0c 94 d8 12 	jmp	0x25b0	; 0x25b0 <__prologue_saves__>
    1c36:	6c 01       	movw	r12, r24
    1c38:	7b 01       	movw	r14, r22
    1c3a:	8a 01       	movw	r16, r20
    1c3c:	fc 01       	movw	r30, r24
    1c3e:	16 82       	std	Z+6, r1	; 0x06
    1c40:	17 82       	std	Z+7, r1	; 0x07
    1c42:	83 81       	ldd	r24, Z+3	; 0x03
    1c44:	81 ff       	sbrs	r24, 1
    1c46:	cc c1       	rjmp	.+920    	; 0x1fe0 <vfprintf+0x3b6>
    1c48:	ce 01       	movw	r24, r28
    1c4a:	01 96       	adiw	r24, 0x01	; 1
    1c4c:	3c 01       	movw	r6, r24
    1c4e:	f6 01       	movw	r30, r12
    1c50:	93 81       	ldd	r25, Z+3	; 0x03
    1c52:	f7 01       	movw	r30, r14
    1c54:	93 fd       	sbrc	r25, 3
    1c56:	85 91       	lpm	r24, Z+
    1c58:	93 ff       	sbrs	r25, 3
    1c5a:	81 91       	ld	r24, Z+
    1c5c:	7f 01       	movw	r14, r30
    1c5e:	88 23       	and	r24, r24
    1c60:	09 f4       	brne	.+2      	; 0x1c64 <vfprintf+0x3a>
    1c62:	ba c1       	rjmp	.+884    	; 0x1fd8 <vfprintf+0x3ae>
    1c64:	85 32       	cpi	r24, 0x25	; 37
    1c66:	39 f4       	brne	.+14     	; 0x1c76 <vfprintf+0x4c>
    1c68:	93 fd       	sbrc	r25, 3
    1c6a:	85 91       	lpm	r24, Z+
    1c6c:	93 ff       	sbrs	r25, 3
    1c6e:	81 91       	ld	r24, Z+
    1c70:	7f 01       	movw	r14, r30
    1c72:	85 32       	cpi	r24, 0x25	; 37
    1c74:	29 f4       	brne	.+10     	; 0x1c80 <vfprintf+0x56>
    1c76:	b6 01       	movw	r22, r12
    1c78:	90 e0       	ldi	r25, 0x00	; 0
    1c7a:	0e 94 3e 12 	call	0x247c	; 0x247c <fputc>
    1c7e:	e7 cf       	rjmp	.-50     	; 0x1c4e <vfprintf+0x24>
    1c80:	91 2c       	mov	r9, r1
    1c82:	21 2c       	mov	r2, r1
    1c84:	31 2c       	mov	r3, r1
    1c86:	ff e1       	ldi	r31, 0x1F	; 31
    1c88:	f3 15       	cp	r31, r3
    1c8a:	d8 f0       	brcs	.+54     	; 0x1cc2 <vfprintf+0x98>
    1c8c:	8b 32       	cpi	r24, 0x2B	; 43
    1c8e:	79 f0       	breq	.+30     	; 0x1cae <vfprintf+0x84>
    1c90:	38 f4       	brcc	.+14     	; 0x1ca0 <vfprintf+0x76>
    1c92:	80 32       	cpi	r24, 0x20	; 32
    1c94:	79 f0       	breq	.+30     	; 0x1cb4 <vfprintf+0x8a>
    1c96:	83 32       	cpi	r24, 0x23	; 35
    1c98:	a1 f4       	brne	.+40     	; 0x1cc2 <vfprintf+0x98>
    1c9a:	23 2d       	mov	r18, r3
    1c9c:	20 61       	ori	r18, 0x10	; 16
    1c9e:	1d c0       	rjmp	.+58     	; 0x1cda <vfprintf+0xb0>
    1ca0:	8d 32       	cpi	r24, 0x2D	; 45
    1ca2:	61 f0       	breq	.+24     	; 0x1cbc <vfprintf+0x92>
    1ca4:	80 33       	cpi	r24, 0x30	; 48
    1ca6:	69 f4       	brne	.+26     	; 0x1cc2 <vfprintf+0x98>
    1ca8:	23 2d       	mov	r18, r3
    1caa:	21 60       	ori	r18, 0x01	; 1
    1cac:	16 c0       	rjmp	.+44     	; 0x1cda <vfprintf+0xb0>
    1cae:	83 2d       	mov	r24, r3
    1cb0:	82 60       	ori	r24, 0x02	; 2
    1cb2:	38 2e       	mov	r3, r24
    1cb4:	e3 2d       	mov	r30, r3
    1cb6:	e4 60       	ori	r30, 0x04	; 4
    1cb8:	3e 2e       	mov	r3, r30
    1cba:	2a c0       	rjmp	.+84     	; 0x1d10 <vfprintf+0xe6>
    1cbc:	f3 2d       	mov	r31, r3
    1cbe:	f8 60       	ori	r31, 0x08	; 8
    1cc0:	1d c0       	rjmp	.+58     	; 0x1cfc <vfprintf+0xd2>
    1cc2:	37 fc       	sbrc	r3, 7
    1cc4:	2d c0       	rjmp	.+90     	; 0x1d20 <vfprintf+0xf6>
    1cc6:	20 ed       	ldi	r18, 0xD0	; 208
    1cc8:	28 0f       	add	r18, r24
    1cca:	2a 30       	cpi	r18, 0x0A	; 10
    1ccc:	40 f0       	brcs	.+16     	; 0x1cde <vfprintf+0xb4>
    1cce:	8e 32       	cpi	r24, 0x2E	; 46
    1cd0:	b9 f4       	brne	.+46     	; 0x1d00 <vfprintf+0xd6>
    1cd2:	36 fc       	sbrc	r3, 6
    1cd4:	81 c1       	rjmp	.+770    	; 0x1fd8 <vfprintf+0x3ae>
    1cd6:	23 2d       	mov	r18, r3
    1cd8:	20 64       	ori	r18, 0x40	; 64
    1cda:	32 2e       	mov	r3, r18
    1cdc:	19 c0       	rjmp	.+50     	; 0x1d10 <vfprintf+0xe6>
    1cde:	36 fe       	sbrs	r3, 6
    1ce0:	06 c0       	rjmp	.+12     	; 0x1cee <vfprintf+0xc4>
    1ce2:	8a e0       	ldi	r24, 0x0A	; 10
    1ce4:	98 9e       	mul	r9, r24
    1ce6:	20 0d       	add	r18, r0
    1ce8:	11 24       	eor	r1, r1
    1cea:	92 2e       	mov	r9, r18
    1cec:	11 c0       	rjmp	.+34     	; 0x1d10 <vfprintf+0xe6>
    1cee:	ea e0       	ldi	r30, 0x0A	; 10
    1cf0:	2e 9e       	mul	r2, r30
    1cf2:	20 0d       	add	r18, r0
    1cf4:	11 24       	eor	r1, r1
    1cf6:	22 2e       	mov	r2, r18
    1cf8:	f3 2d       	mov	r31, r3
    1cfa:	f0 62       	ori	r31, 0x20	; 32
    1cfc:	3f 2e       	mov	r3, r31
    1cfe:	08 c0       	rjmp	.+16     	; 0x1d10 <vfprintf+0xe6>
    1d00:	8c 36       	cpi	r24, 0x6C	; 108
    1d02:	21 f4       	brne	.+8      	; 0x1d0c <vfprintf+0xe2>
    1d04:	83 2d       	mov	r24, r3
    1d06:	80 68       	ori	r24, 0x80	; 128
    1d08:	38 2e       	mov	r3, r24
    1d0a:	02 c0       	rjmp	.+4      	; 0x1d10 <vfprintf+0xe6>
    1d0c:	88 36       	cpi	r24, 0x68	; 104
    1d0e:	41 f4       	brne	.+16     	; 0x1d20 <vfprintf+0xf6>
    1d10:	f7 01       	movw	r30, r14
    1d12:	93 fd       	sbrc	r25, 3
    1d14:	85 91       	lpm	r24, Z+
    1d16:	93 ff       	sbrs	r25, 3
    1d18:	81 91       	ld	r24, Z+
    1d1a:	7f 01       	movw	r14, r30
    1d1c:	81 11       	cpse	r24, r1
    1d1e:	b3 cf       	rjmp	.-154    	; 0x1c86 <vfprintf+0x5c>
    1d20:	98 2f       	mov	r25, r24
    1d22:	9f 7d       	andi	r25, 0xDF	; 223
    1d24:	95 54       	subi	r25, 0x45	; 69
    1d26:	93 30       	cpi	r25, 0x03	; 3
    1d28:	28 f4       	brcc	.+10     	; 0x1d34 <vfprintf+0x10a>
    1d2a:	0c 5f       	subi	r16, 0xFC	; 252
    1d2c:	1f 4f       	sbci	r17, 0xFF	; 255
    1d2e:	9f e3       	ldi	r25, 0x3F	; 63
    1d30:	99 83       	std	Y+1, r25	; 0x01
    1d32:	0d c0       	rjmp	.+26     	; 0x1d4e <vfprintf+0x124>
    1d34:	83 36       	cpi	r24, 0x63	; 99
    1d36:	31 f0       	breq	.+12     	; 0x1d44 <vfprintf+0x11a>
    1d38:	83 37       	cpi	r24, 0x73	; 115
    1d3a:	71 f0       	breq	.+28     	; 0x1d58 <vfprintf+0x12e>
    1d3c:	83 35       	cpi	r24, 0x53	; 83
    1d3e:	09 f0       	breq	.+2      	; 0x1d42 <vfprintf+0x118>
    1d40:	59 c0       	rjmp	.+178    	; 0x1df4 <vfprintf+0x1ca>
    1d42:	21 c0       	rjmp	.+66     	; 0x1d86 <vfprintf+0x15c>
    1d44:	f8 01       	movw	r30, r16
    1d46:	80 81       	ld	r24, Z
    1d48:	89 83       	std	Y+1, r24	; 0x01
    1d4a:	0e 5f       	subi	r16, 0xFE	; 254
    1d4c:	1f 4f       	sbci	r17, 0xFF	; 255
    1d4e:	88 24       	eor	r8, r8
    1d50:	83 94       	inc	r8
    1d52:	91 2c       	mov	r9, r1
    1d54:	53 01       	movw	r10, r6
    1d56:	13 c0       	rjmp	.+38     	; 0x1d7e <vfprintf+0x154>
    1d58:	28 01       	movw	r4, r16
    1d5a:	f2 e0       	ldi	r31, 0x02	; 2
    1d5c:	4f 0e       	add	r4, r31
    1d5e:	51 1c       	adc	r5, r1
    1d60:	f8 01       	movw	r30, r16
    1d62:	a0 80       	ld	r10, Z
    1d64:	b1 80       	ldd	r11, Z+1	; 0x01
    1d66:	36 fe       	sbrs	r3, 6
    1d68:	03 c0       	rjmp	.+6      	; 0x1d70 <vfprintf+0x146>
    1d6a:	69 2d       	mov	r22, r9
    1d6c:	70 e0       	ldi	r23, 0x00	; 0
    1d6e:	02 c0       	rjmp	.+4      	; 0x1d74 <vfprintf+0x14a>
    1d70:	6f ef       	ldi	r22, 0xFF	; 255
    1d72:	7f ef       	ldi	r23, 0xFF	; 255
    1d74:	c5 01       	movw	r24, r10
    1d76:	0e 94 33 12 	call	0x2466	; 0x2466 <strnlen>
    1d7a:	4c 01       	movw	r8, r24
    1d7c:	82 01       	movw	r16, r4
    1d7e:	f3 2d       	mov	r31, r3
    1d80:	ff 77       	andi	r31, 0x7F	; 127
    1d82:	3f 2e       	mov	r3, r31
    1d84:	16 c0       	rjmp	.+44     	; 0x1db2 <vfprintf+0x188>
    1d86:	28 01       	movw	r4, r16
    1d88:	22 e0       	ldi	r18, 0x02	; 2
    1d8a:	42 0e       	add	r4, r18
    1d8c:	51 1c       	adc	r5, r1
    1d8e:	f8 01       	movw	r30, r16
    1d90:	a0 80       	ld	r10, Z
    1d92:	b1 80       	ldd	r11, Z+1	; 0x01
    1d94:	36 fe       	sbrs	r3, 6
    1d96:	03 c0       	rjmp	.+6      	; 0x1d9e <vfprintf+0x174>
    1d98:	69 2d       	mov	r22, r9
    1d9a:	70 e0       	ldi	r23, 0x00	; 0
    1d9c:	02 c0       	rjmp	.+4      	; 0x1da2 <vfprintf+0x178>
    1d9e:	6f ef       	ldi	r22, 0xFF	; 255
    1da0:	7f ef       	ldi	r23, 0xFF	; 255
    1da2:	c5 01       	movw	r24, r10
    1da4:	0e 94 28 12 	call	0x2450	; 0x2450 <strnlen_P>
    1da8:	4c 01       	movw	r8, r24
    1daa:	f3 2d       	mov	r31, r3
    1dac:	f0 68       	ori	r31, 0x80	; 128
    1dae:	3f 2e       	mov	r3, r31
    1db0:	82 01       	movw	r16, r4
    1db2:	33 fc       	sbrc	r3, 3
    1db4:	1b c0       	rjmp	.+54     	; 0x1dec <vfprintf+0x1c2>
    1db6:	82 2d       	mov	r24, r2
    1db8:	90 e0       	ldi	r25, 0x00	; 0
    1dba:	88 16       	cp	r8, r24
    1dbc:	99 06       	cpc	r9, r25
    1dbe:	b0 f4       	brcc	.+44     	; 0x1dec <vfprintf+0x1c2>
    1dc0:	b6 01       	movw	r22, r12
    1dc2:	80 e2       	ldi	r24, 0x20	; 32
    1dc4:	90 e0       	ldi	r25, 0x00	; 0
    1dc6:	0e 94 3e 12 	call	0x247c	; 0x247c <fputc>
    1dca:	2a 94       	dec	r2
    1dcc:	f4 cf       	rjmp	.-24     	; 0x1db6 <vfprintf+0x18c>
    1dce:	f5 01       	movw	r30, r10
    1dd0:	37 fc       	sbrc	r3, 7
    1dd2:	85 91       	lpm	r24, Z+
    1dd4:	37 fe       	sbrs	r3, 7
    1dd6:	81 91       	ld	r24, Z+
    1dd8:	5f 01       	movw	r10, r30
    1dda:	b6 01       	movw	r22, r12
    1ddc:	90 e0       	ldi	r25, 0x00	; 0
    1dde:	0e 94 3e 12 	call	0x247c	; 0x247c <fputc>
    1de2:	21 10       	cpse	r2, r1
    1de4:	2a 94       	dec	r2
    1de6:	21 e0       	ldi	r18, 0x01	; 1
    1de8:	82 1a       	sub	r8, r18
    1dea:	91 08       	sbc	r9, r1
    1dec:	81 14       	cp	r8, r1
    1dee:	91 04       	cpc	r9, r1
    1df0:	71 f7       	brne	.-36     	; 0x1dce <vfprintf+0x1a4>
    1df2:	e8 c0       	rjmp	.+464    	; 0x1fc4 <vfprintf+0x39a>
    1df4:	84 36       	cpi	r24, 0x64	; 100
    1df6:	11 f0       	breq	.+4      	; 0x1dfc <vfprintf+0x1d2>
    1df8:	89 36       	cpi	r24, 0x69	; 105
    1dfa:	41 f5       	brne	.+80     	; 0x1e4c <vfprintf+0x222>
    1dfc:	f8 01       	movw	r30, r16
    1dfe:	37 fe       	sbrs	r3, 7
    1e00:	07 c0       	rjmp	.+14     	; 0x1e10 <vfprintf+0x1e6>
    1e02:	60 81       	ld	r22, Z
    1e04:	71 81       	ldd	r23, Z+1	; 0x01
    1e06:	82 81       	ldd	r24, Z+2	; 0x02
    1e08:	93 81       	ldd	r25, Z+3	; 0x03
    1e0a:	0c 5f       	subi	r16, 0xFC	; 252
    1e0c:	1f 4f       	sbci	r17, 0xFF	; 255
    1e0e:	08 c0       	rjmp	.+16     	; 0x1e20 <vfprintf+0x1f6>
    1e10:	60 81       	ld	r22, Z
    1e12:	71 81       	ldd	r23, Z+1	; 0x01
    1e14:	07 2e       	mov	r0, r23
    1e16:	00 0c       	add	r0, r0
    1e18:	88 0b       	sbc	r24, r24
    1e1a:	99 0b       	sbc	r25, r25
    1e1c:	0e 5f       	subi	r16, 0xFE	; 254
    1e1e:	1f 4f       	sbci	r17, 0xFF	; 255
    1e20:	f3 2d       	mov	r31, r3
    1e22:	ff 76       	andi	r31, 0x6F	; 111
    1e24:	3f 2e       	mov	r3, r31
    1e26:	97 ff       	sbrs	r25, 7
    1e28:	09 c0       	rjmp	.+18     	; 0x1e3c <vfprintf+0x212>
    1e2a:	90 95       	com	r25
    1e2c:	80 95       	com	r24
    1e2e:	70 95       	com	r23
    1e30:	61 95       	neg	r22
    1e32:	7f 4f       	sbci	r23, 0xFF	; 255
    1e34:	8f 4f       	sbci	r24, 0xFF	; 255
    1e36:	9f 4f       	sbci	r25, 0xFF	; 255
    1e38:	f0 68       	ori	r31, 0x80	; 128
    1e3a:	3f 2e       	mov	r3, r31
    1e3c:	2a e0       	ldi	r18, 0x0A	; 10
    1e3e:	30 e0       	ldi	r19, 0x00	; 0
    1e40:	a3 01       	movw	r20, r6
    1e42:	0e 94 7a 12 	call	0x24f4	; 0x24f4 <__ultoa_invert>
    1e46:	88 2e       	mov	r8, r24
    1e48:	86 18       	sub	r8, r6
    1e4a:	45 c0       	rjmp	.+138    	; 0x1ed6 <vfprintf+0x2ac>
    1e4c:	85 37       	cpi	r24, 0x75	; 117
    1e4e:	31 f4       	brne	.+12     	; 0x1e5c <vfprintf+0x232>
    1e50:	23 2d       	mov	r18, r3
    1e52:	2f 7e       	andi	r18, 0xEF	; 239
    1e54:	b2 2e       	mov	r11, r18
    1e56:	2a e0       	ldi	r18, 0x0A	; 10
    1e58:	30 e0       	ldi	r19, 0x00	; 0
    1e5a:	25 c0       	rjmp	.+74     	; 0x1ea6 <vfprintf+0x27c>
    1e5c:	93 2d       	mov	r25, r3
    1e5e:	99 7f       	andi	r25, 0xF9	; 249
    1e60:	b9 2e       	mov	r11, r25
    1e62:	8f 36       	cpi	r24, 0x6F	; 111
    1e64:	c1 f0       	breq	.+48     	; 0x1e96 <vfprintf+0x26c>
    1e66:	18 f4       	brcc	.+6      	; 0x1e6e <vfprintf+0x244>
    1e68:	88 35       	cpi	r24, 0x58	; 88
    1e6a:	79 f0       	breq	.+30     	; 0x1e8a <vfprintf+0x260>
    1e6c:	b5 c0       	rjmp	.+362    	; 0x1fd8 <vfprintf+0x3ae>
    1e6e:	80 37       	cpi	r24, 0x70	; 112
    1e70:	19 f0       	breq	.+6      	; 0x1e78 <vfprintf+0x24e>
    1e72:	88 37       	cpi	r24, 0x78	; 120
    1e74:	21 f0       	breq	.+8      	; 0x1e7e <vfprintf+0x254>
    1e76:	b0 c0       	rjmp	.+352    	; 0x1fd8 <vfprintf+0x3ae>
    1e78:	e9 2f       	mov	r30, r25
    1e7a:	e0 61       	ori	r30, 0x10	; 16
    1e7c:	be 2e       	mov	r11, r30
    1e7e:	b4 fe       	sbrs	r11, 4
    1e80:	0d c0       	rjmp	.+26     	; 0x1e9c <vfprintf+0x272>
    1e82:	fb 2d       	mov	r31, r11
    1e84:	f4 60       	ori	r31, 0x04	; 4
    1e86:	bf 2e       	mov	r11, r31
    1e88:	09 c0       	rjmp	.+18     	; 0x1e9c <vfprintf+0x272>
    1e8a:	34 fe       	sbrs	r3, 4
    1e8c:	0a c0       	rjmp	.+20     	; 0x1ea2 <vfprintf+0x278>
    1e8e:	29 2f       	mov	r18, r25
    1e90:	26 60       	ori	r18, 0x06	; 6
    1e92:	b2 2e       	mov	r11, r18
    1e94:	06 c0       	rjmp	.+12     	; 0x1ea2 <vfprintf+0x278>
    1e96:	28 e0       	ldi	r18, 0x08	; 8
    1e98:	30 e0       	ldi	r19, 0x00	; 0
    1e9a:	05 c0       	rjmp	.+10     	; 0x1ea6 <vfprintf+0x27c>
    1e9c:	20 e1       	ldi	r18, 0x10	; 16
    1e9e:	30 e0       	ldi	r19, 0x00	; 0
    1ea0:	02 c0       	rjmp	.+4      	; 0x1ea6 <vfprintf+0x27c>
    1ea2:	20 e1       	ldi	r18, 0x10	; 16
    1ea4:	32 e0       	ldi	r19, 0x02	; 2
    1ea6:	f8 01       	movw	r30, r16
    1ea8:	b7 fe       	sbrs	r11, 7
    1eaa:	07 c0       	rjmp	.+14     	; 0x1eba <vfprintf+0x290>
    1eac:	60 81       	ld	r22, Z
    1eae:	71 81       	ldd	r23, Z+1	; 0x01
    1eb0:	82 81       	ldd	r24, Z+2	; 0x02
    1eb2:	93 81       	ldd	r25, Z+3	; 0x03
    1eb4:	0c 5f       	subi	r16, 0xFC	; 252
    1eb6:	1f 4f       	sbci	r17, 0xFF	; 255
    1eb8:	06 c0       	rjmp	.+12     	; 0x1ec6 <vfprintf+0x29c>
    1eba:	60 81       	ld	r22, Z
    1ebc:	71 81       	ldd	r23, Z+1	; 0x01
    1ebe:	80 e0       	ldi	r24, 0x00	; 0
    1ec0:	90 e0       	ldi	r25, 0x00	; 0
    1ec2:	0e 5f       	subi	r16, 0xFE	; 254
    1ec4:	1f 4f       	sbci	r17, 0xFF	; 255
    1ec6:	a3 01       	movw	r20, r6
    1ec8:	0e 94 7a 12 	call	0x24f4	; 0x24f4 <__ultoa_invert>
    1ecc:	88 2e       	mov	r8, r24
    1ece:	86 18       	sub	r8, r6
    1ed0:	fb 2d       	mov	r31, r11
    1ed2:	ff 77       	andi	r31, 0x7F	; 127
    1ed4:	3f 2e       	mov	r3, r31
    1ed6:	36 fe       	sbrs	r3, 6
    1ed8:	0d c0       	rjmp	.+26     	; 0x1ef4 <vfprintf+0x2ca>
    1eda:	23 2d       	mov	r18, r3
    1edc:	2e 7f       	andi	r18, 0xFE	; 254
    1ede:	a2 2e       	mov	r10, r18
    1ee0:	89 14       	cp	r8, r9
    1ee2:	58 f4       	brcc	.+22     	; 0x1efa <vfprintf+0x2d0>
    1ee4:	34 fe       	sbrs	r3, 4
    1ee6:	0b c0       	rjmp	.+22     	; 0x1efe <vfprintf+0x2d4>
    1ee8:	32 fc       	sbrc	r3, 2
    1eea:	09 c0       	rjmp	.+18     	; 0x1efe <vfprintf+0x2d4>
    1eec:	83 2d       	mov	r24, r3
    1eee:	8e 7e       	andi	r24, 0xEE	; 238
    1ef0:	a8 2e       	mov	r10, r24
    1ef2:	05 c0       	rjmp	.+10     	; 0x1efe <vfprintf+0x2d4>
    1ef4:	b8 2c       	mov	r11, r8
    1ef6:	a3 2c       	mov	r10, r3
    1ef8:	03 c0       	rjmp	.+6      	; 0x1f00 <vfprintf+0x2d6>
    1efa:	b8 2c       	mov	r11, r8
    1efc:	01 c0       	rjmp	.+2      	; 0x1f00 <vfprintf+0x2d6>
    1efe:	b9 2c       	mov	r11, r9
    1f00:	a4 fe       	sbrs	r10, 4
    1f02:	0f c0       	rjmp	.+30     	; 0x1f22 <vfprintf+0x2f8>
    1f04:	fe 01       	movw	r30, r28
    1f06:	e8 0d       	add	r30, r8
    1f08:	f1 1d       	adc	r31, r1
    1f0a:	80 81       	ld	r24, Z
    1f0c:	80 33       	cpi	r24, 0x30	; 48
    1f0e:	21 f4       	brne	.+8      	; 0x1f18 <vfprintf+0x2ee>
    1f10:	9a 2d       	mov	r25, r10
    1f12:	99 7e       	andi	r25, 0xE9	; 233
    1f14:	a9 2e       	mov	r10, r25
    1f16:	09 c0       	rjmp	.+18     	; 0x1f2a <vfprintf+0x300>
    1f18:	a2 fe       	sbrs	r10, 2
    1f1a:	06 c0       	rjmp	.+12     	; 0x1f28 <vfprintf+0x2fe>
    1f1c:	b3 94       	inc	r11
    1f1e:	b3 94       	inc	r11
    1f20:	04 c0       	rjmp	.+8      	; 0x1f2a <vfprintf+0x300>
    1f22:	8a 2d       	mov	r24, r10
    1f24:	86 78       	andi	r24, 0x86	; 134
    1f26:	09 f0       	breq	.+2      	; 0x1f2a <vfprintf+0x300>
    1f28:	b3 94       	inc	r11
    1f2a:	a3 fc       	sbrc	r10, 3
    1f2c:	11 c0       	rjmp	.+34     	; 0x1f50 <vfprintf+0x326>
    1f2e:	a0 fe       	sbrs	r10, 0
    1f30:	06 c0       	rjmp	.+12     	; 0x1f3e <vfprintf+0x314>
    1f32:	b2 14       	cp	r11, r2
    1f34:	88 f4       	brcc	.+34     	; 0x1f58 <vfprintf+0x32e>
    1f36:	28 0c       	add	r2, r8
    1f38:	92 2c       	mov	r9, r2
    1f3a:	9b 18       	sub	r9, r11
    1f3c:	0e c0       	rjmp	.+28     	; 0x1f5a <vfprintf+0x330>
    1f3e:	b2 14       	cp	r11, r2
    1f40:	60 f4       	brcc	.+24     	; 0x1f5a <vfprintf+0x330>
    1f42:	b6 01       	movw	r22, r12
    1f44:	80 e2       	ldi	r24, 0x20	; 32
    1f46:	90 e0       	ldi	r25, 0x00	; 0
    1f48:	0e 94 3e 12 	call	0x247c	; 0x247c <fputc>
    1f4c:	b3 94       	inc	r11
    1f4e:	f7 cf       	rjmp	.-18     	; 0x1f3e <vfprintf+0x314>
    1f50:	b2 14       	cp	r11, r2
    1f52:	18 f4       	brcc	.+6      	; 0x1f5a <vfprintf+0x330>
    1f54:	2b 18       	sub	r2, r11
    1f56:	02 c0       	rjmp	.+4      	; 0x1f5c <vfprintf+0x332>
    1f58:	98 2c       	mov	r9, r8
    1f5a:	21 2c       	mov	r2, r1
    1f5c:	a4 fe       	sbrs	r10, 4
    1f5e:	10 c0       	rjmp	.+32     	; 0x1f80 <vfprintf+0x356>
    1f60:	b6 01       	movw	r22, r12
    1f62:	80 e3       	ldi	r24, 0x30	; 48
    1f64:	90 e0       	ldi	r25, 0x00	; 0
    1f66:	0e 94 3e 12 	call	0x247c	; 0x247c <fputc>
    1f6a:	a2 fe       	sbrs	r10, 2
    1f6c:	17 c0       	rjmp	.+46     	; 0x1f9c <vfprintf+0x372>
    1f6e:	a1 fc       	sbrc	r10, 1
    1f70:	03 c0       	rjmp	.+6      	; 0x1f78 <vfprintf+0x34e>
    1f72:	88 e7       	ldi	r24, 0x78	; 120
    1f74:	90 e0       	ldi	r25, 0x00	; 0
    1f76:	02 c0       	rjmp	.+4      	; 0x1f7c <vfprintf+0x352>
    1f78:	88 e5       	ldi	r24, 0x58	; 88
    1f7a:	90 e0       	ldi	r25, 0x00	; 0
    1f7c:	b6 01       	movw	r22, r12
    1f7e:	0c c0       	rjmp	.+24     	; 0x1f98 <vfprintf+0x36e>
    1f80:	8a 2d       	mov	r24, r10
    1f82:	86 78       	andi	r24, 0x86	; 134
    1f84:	59 f0       	breq	.+22     	; 0x1f9c <vfprintf+0x372>
    1f86:	a1 fe       	sbrs	r10, 1
    1f88:	02 c0       	rjmp	.+4      	; 0x1f8e <vfprintf+0x364>
    1f8a:	8b e2       	ldi	r24, 0x2B	; 43
    1f8c:	01 c0       	rjmp	.+2      	; 0x1f90 <vfprintf+0x366>
    1f8e:	80 e2       	ldi	r24, 0x20	; 32
    1f90:	a7 fc       	sbrc	r10, 7
    1f92:	8d e2       	ldi	r24, 0x2D	; 45
    1f94:	b6 01       	movw	r22, r12
    1f96:	90 e0       	ldi	r25, 0x00	; 0
    1f98:	0e 94 3e 12 	call	0x247c	; 0x247c <fputc>
    1f9c:	89 14       	cp	r8, r9
    1f9e:	38 f4       	brcc	.+14     	; 0x1fae <vfprintf+0x384>
    1fa0:	b6 01       	movw	r22, r12
    1fa2:	80 e3       	ldi	r24, 0x30	; 48
    1fa4:	90 e0       	ldi	r25, 0x00	; 0
    1fa6:	0e 94 3e 12 	call	0x247c	; 0x247c <fputc>
    1faa:	9a 94       	dec	r9
    1fac:	f7 cf       	rjmp	.-18     	; 0x1f9c <vfprintf+0x372>
    1fae:	8a 94       	dec	r8
    1fb0:	f3 01       	movw	r30, r6
    1fb2:	e8 0d       	add	r30, r8
    1fb4:	f1 1d       	adc	r31, r1
    1fb6:	80 81       	ld	r24, Z
    1fb8:	b6 01       	movw	r22, r12
    1fba:	90 e0       	ldi	r25, 0x00	; 0
    1fbc:	0e 94 3e 12 	call	0x247c	; 0x247c <fputc>
    1fc0:	81 10       	cpse	r8, r1
    1fc2:	f5 cf       	rjmp	.-22     	; 0x1fae <vfprintf+0x384>
    1fc4:	22 20       	and	r2, r2
    1fc6:	09 f4       	brne	.+2      	; 0x1fca <vfprintf+0x3a0>
    1fc8:	42 ce       	rjmp	.-892    	; 0x1c4e <vfprintf+0x24>
    1fca:	b6 01       	movw	r22, r12
    1fcc:	80 e2       	ldi	r24, 0x20	; 32
    1fce:	90 e0       	ldi	r25, 0x00	; 0
    1fd0:	0e 94 3e 12 	call	0x247c	; 0x247c <fputc>
    1fd4:	2a 94       	dec	r2
    1fd6:	f6 cf       	rjmp	.-20     	; 0x1fc4 <vfprintf+0x39a>
    1fd8:	f6 01       	movw	r30, r12
    1fda:	86 81       	ldd	r24, Z+6	; 0x06
    1fdc:	97 81       	ldd	r25, Z+7	; 0x07
    1fde:	02 c0       	rjmp	.+4      	; 0x1fe4 <vfprintf+0x3ba>
    1fe0:	8f ef       	ldi	r24, 0xFF	; 255
    1fe2:	9f ef       	ldi	r25, 0xFF	; 255
    1fe4:	2b 96       	adiw	r28, 0x0b	; 11
    1fe6:	e2 e1       	ldi	r30, 0x12	; 18
    1fe8:	0c 94 f1 12 	jmp	0x25e2	; 0x25e2 <__epilogue_restores__>

00001fec <dtoa_prf>:
    1fec:	a9 e0       	ldi	r26, 0x09	; 9
    1fee:	b0 e0       	ldi	r27, 0x00	; 0
    1ff0:	ec ef       	ldi	r30, 0xFC	; 252
    1ff2:	ff e0       	ldi	r31, 0x0F	; 15
    1ff4:	0c 94 de 12 	jmp	0x25bc	; 0x25bc <__prologue_saves__+0xc>
    1ff8:	6a 01       	movw	r12, r20
    1ffa:	12 2f       	mov	r17, r18
    1ffc:	b0 2e       	mov	r11, r16
    1ffe:	2b e3       	ldi	r18, 0x3B	; 59
    2000:	20 17       	cp	r18, r16
    2002:	20 f0       	brcs	.+8      	; 0x200c <dtoa_prf+0x20>
    2004:	ff 24       	eor	r15, r15
    2006:	f3 94       	inc	r15
    2008:	f0 0e       	add	r15, r16
    200a:	02 c0       	rjmp	.+4      	; 0x2010 <dtoa_prf+0x24>
    200c:	2c e3       	ldi	r18, 0x3C	; 60
    200e:	f2 2e       	mov	r15, r18
    2010:	0f 2d       	mov	r16, r15
    2012:	27 e0       	ldi	r18, 0x07	; 7
    2014:	ae 01       	movw	r20, r28
    2016:	4f 5f       	subi	r20, 0xFF	; 255
    2018:	5f 4f       	sbci	r21, 0xFF	; 255
    201a:	0e 94 50 11 	call	0x22a0	; 0x22a0 <__ftoa_engine>
    201e:	bc 01       	movw	r22, r24
    2020:	49 81       	ldd	r20, Y+1	; 0x01
    2022:	84 2f       	mov	r24, r20
    2024:	89 70       	andi	r24, 0x09	; 9
    2026:	81 30       	cpi	r24, 0x01	; 1
    2028:	31 f0       	breq	.+12     	; 0x2036 <dtoa_prf+0x4a>
    202a:	e1 fc       	sbrc	r14, 1
    202c:	06 c0       	rjmp	.+12     	; 0x203a <dtoa_prf+0x4e>
    202e:	e0 fe       	sbrs	r14, 0
    2030:	06 c0       	rjmp	.+12     	; 0x203e <dtoa_prf+0x52>
    2032:	90 e2       	ldi	r25, 0x20	; 32
    2034:	05 c0       	rjmp	.+10     	; 0x2040 <dtoa_prf+0x54>
    2036:	9d e2       	ldi	r25, 0x2D	; 45
    2038:	03 c0       	rjmp	.+6      	; 0x2040 <dtoa_prf+0x54>
    203a:	9b e2       	ldi	r25, 0x2B	; 43
    203c:	01 c0       	rjmp	.+2      	; 0x2040 <dtoa_prf+0x54>
    203e:	90 e0       	ldi	r25, 0x00	; 0
    2040:	5e 2d       	mov	r21, r14
    2042:	50 71       	andi	r21, 0x10	; 16
    2044:	43 ff       	sbrs	r20, 3
    2046:	3c c0       	rjmp	.+120    	; 0x20c0 <dtoa_prf+0xd4>
    2048:	91 11       	cpse	r25, r1
    204a:	02 c0       	rjmp	.+4      	; 0x2050 <dtoa_prf+0x64>
    204c:	83 e0       	ldi	r24, 0x03	; 3
    204e:	01 c0       	rjmp	.+2      	; 0x2052 <dtoa_prf+0x66>
    2050:	84 e0       	ldi	r24, 0x04	; 4
    2052:	81 17       	cp	r24, r17
    2054:	18 f4       	brcc	.+6      	; 0x205c <dtoa_prf+0x70>
    2056:	21 2f       	mov	r18, r17
    2058:	28 1b       	sub	r18, r24
    205a:	01 c0       	rjmp	.+2      	; 0x205e <dtoa_prf+0x72>
    205c:	20 e0       	ldi	r18, 0x00	; 0
    205e:	51 11       	cpse	r21, r1
    2060:	0b c0       	rjmp	.+22     	; 0x2078 <dtoa_prf+0x8c>
    2062:	f6 01       	movw	r30, r12
    2064:	82 2f       	mov	r24, r18
    2066:	30 e2       	ldi	r19, 0x20	; 32
    2068:	88 23       	and	r24, r24
    206a:	19 f0       	breq	.+6      	; 0x2072 <dtoa_prf+0x86>
    206c:	31 93       	st	Z+, r19
    206e:	81 50       	subi	r24, 0x01	; 1
    2070:	fb cf       	rjmp	.-10     	; 0x2068 <dtoa_prf+0x7c>
    2072:	c2 0e       	add	r12, r18
    2074:	d1 1c       	adc	r13, r1
    2076:	20 e0       	ldi	r18, 0x00	; 0
    2078:	99 23       	and	r25, r25
    207a:	29 f0       	breq	.+10     	; 0x2086 <dtoa_prf+0x9a>
    207c:	d6 01       	movw	r26, r12
    207e:	9c 93       	st	X, r25
    2080:	f6 01       	movw	r30, r12
    2082:	31 96       	adiw	r30, 0x01	; 1
    2084:	6f 01       	movw	r12, r30
    2086:	c6 01       	movw	r24, r12
    2088:	03 96       	adiw	r24, 0x03	; 3
    208a:	e2 fe       	sbrs	r14, 2
    208c:	0a c0       	rjmp	.+20     	; 0x20a2 <dtoa_prf+0xb6>
    208e:	3e e4       	ldi	r19, 0x4E	; 78
    2090:	d6 01       	movw	r26, r12
    2092:	3c 93       	st	X, r19
    2094:	41 e4       	ldi	r20, 0x41	; 65
    2096:	11 96       	adiw	r26, 0x01	; 1
    2098:	4c 93       	st	X, r20
    209a:	11 97       	sbiw	r26, 0x01	; 1
    209c:	12 96       	adiw	r26, 0x02	; 2
    209e:	3c 93       	st	X, r19
    20a0:	06 c0       	rjmp	.+12     	; 0x20ae <dtoa_prf+0xc2>
    20a2:	3e e6       	ldi	r19, 0x6E	; 110
    20a4:	f6 01       	movw	r30, r12
    20a6:	30 83       	st	Z, r19
    20a8:	41 e6       	ldi	r20, 0x61	; 97
    20aa:	41 83       	std	Z+1, r20	; 0x01
    20ac:	32 83       	std	Z+2, r19	; 0x02
    20ae:	fc 01       	movw	r30, r24
    20b0:	32 2f       	mov	r19, r18
    20b2:	40 e2       	ldi	r20, 0x20	; 32
    20b4:	33 23       	and	r19, r19
    20b6:	09 f4       	brne	.+2      	; 0x20ba <dtoa_prf+0xce>
    20b8:	42 c0       	rjmp	.+132    	; 0x213e <dtoa_prf+0x152>
    20ba:	41 93       	st	Z+, r20
    20bc:	31 50       	subi	r19, 0x01	; 1
    20be:	fa cf       	rjmp	.-12     	; 0x20b4 <dtoa_prf+0xc8>
    20c0:	42 ff       	sbrs	r20, 2
    20c2:	44 c0       	rjmp	.+136    	; 0x214c <dtoa_prf+0x160>
    20c4:	91 11       	cpse	r25, r1
    20c6:	02 c0       	rjmp	.+4      	; 0x20cc <dtoa_prf+0xe0>
    20c8:	83 e0       	ldi	r24, 0x03	; 3
    20ca:	01 c0       	rjmp	.+2      	; 0x20ce <dtoa_prf+0xe2>
    20cc:	84 e0       	ldi	r24, 0x04	; 4
    20ce:	81 17       	cp	r24, r17
    20d0:	18 f4       	brcc	.+6      	; 0x20d8 <dtoa_prf+0xec>
    20d2:	21 2f       	mov	r18, r17
    20d4:	28 1b       	sub	r18, r24
    20d6:	01 c0       	rjmp	.+2      	; 0x20da <dtoa_prf+0xee>
    20d8:	20 e0       	ldi	r18, 0x00	; 0
    20da:	51 11       	cpse	r21, r1
    20dc:	0b c0       	rjmp	.+22     	; 0x20f4 <dtoa_prf+0x108>
    20de:	f6 01       	movw	r30, r12
    20e0:	82 2f       	mov	r24, r18
    20e2:	30 e2       	ldi	r19, 0x20	; 32
    20e4:	88 23       	and	r24, r24
    20e6:	19 f0       	breq	.+6      	; 0x20ee <dtoa_prf+0x102>
    20e8:	31 93       	st	Z+, r19
    20ea:	81 50       	subi	r24, 0x01	; 1
    20ec:	fb cf       	rjmp	.-10     	; 0x20e4 <dtoa_prf+0xf8>
    20ee:	c2 0e       	add	r12, r18
    20f0:	d1 1c       	adc	r13, r1
    20f2:	20 e0       	ldi	r18, 0x00	; 0
    20f4:	99 23       	and	r25, r25
    20f6:	29 f0       	breq	.+10     	; 0x2102 <dtoa_prf+0x116>
    20f8:	d6 01       	movw	r26, r12
    20fa:	9c 93       	st	X, r25
    20fc:	f6 01       	movw	r30, r12
    20fe:	31 96       	adiw	r30, 0x01	; 1
    2100:	6f 01       	movw	r12, r30
    2102:	c6 01       	movw	r24, r12
    2104:	03 96       	adiw	r24, 0x03	; 3
    2106:	e2 fe       	sbrs	r14, 2
    2108:	0b c0       	rjmp	.+22     	; 0x2120 <dtoa_prf+0x134>
    210a:	39 e4       	ldi	r19, 0x49	; 73
    210c:	d6 01       	movw	r26, r12
    210e:	3c 93       	st	X, r19
    2110:	3e e4       	ldi	r19, 0x4E	; 78
    2112:	11 96       	adiw	r26, 0x01	; 1
    2114:	3c 93       	st	X, r19
    2116:	11 97       	sbiw	r26, 0x01	; 1
    2118:	36 e4       	ldi	r19, 0x46	; 70
    211a:	12 96       	adiw	r26, 0x02	; 2
    211c:	3c 93       	st	X, r19
    211e:	07 c0       	rjmp	.+14     	; 0x212e <dtoa_prf+0x142>
    2120:	39 e6       	ldi	r19, 0x69	; 105
    2122:	f6 01       	movw	r30, r12
    2124:	30 83       	st	Z, r19
    2126:	3e e6       	ldi	r19, 0x6E	; 110
    2128:	31 83       	std	Z+1, r19	; 0x01
    212a:	36 e6       	ldi	r19, 0x66	; 102
    212c:	32 83       	std	Z+2, r19	; 0x02
    212e:	fc 01       	movw	r30, r24
    2130:	32 2f       	mov	r19, r18
    2132:	40 e2       	ldi	r20, 0x20	; 32
    2134:	33 23       	and	r19, r19
    2136:	19 f0       	breq	.+6      	; 0x213e <dtoa_prf+0x152>
    2138:	41 93       	st	Z+, r20
    213a:	31 50       	subi	r19, 0x01	; 1
    213c:	fb cf       	rjmp	.-10     	; 0x2134 <dtoa_prf+0x148>
    213e:	fc 01       	movw	r30, r24
    2140:	e2 0f       	add	r30, r18
    2142:	f1 1d       	adc	r31, r1
    2144:	10 82       	st	Z, r1
    2146:	8e ef       	ldi	r24, 0xFE	; 254
    2148:	9f ef       	ldi	r25, 0xFF	; 255
    214a:	a6 c0       	rjmp	.+332    	; 0x2298 <dtoa_prf+0x2ac>
    214c:	21 e0       	ldi	r18, 0x01	; 1
    214e:	30 e0       	ldi	r19, 0x00	; 0
    2150:	91 11       	cpse	r25, r1
    2152:	02 c0       	rjmp	.+4      	; 0x2158 <dtoa_prf+0x16c>
    2154:	20 e0       	ldi	r18, 0x00	; 0
    2156:	30 e0       	ldi	r19, 0x00	; 0
    2158:	16 16       	cp	r1, r22
    215a:	17 06       	cpc	r1, r23
    215c:	1c f4       	brge	.+6      	; 0x2164 <dtoa_prf+0x178>
    215e:	fb 01       	movw	r30, r22
    2160:	31 96       	adiw	r30, 0x01	; 1
    2162:	02 c0       	rjmp	.+4      	; 0x2168 <dtoa_prf+0x17c>
    2164:	e1 e0       	ldi	r30, 0x01	; 1
    2166:	f0 e0       	ldi	r31, 0x00	; 0
    2168:	2e 0f       	add	r18, r30
    216a:	3f 1f       	adc	r19, r31
    216c:	bb 20       	and	r11, r11
    216e:	21 f0       	breq	.+8      	; 0x2178 <dtoa_prf+0x18c>
    2170:	eb 2d       	mov	r30, r11
    2172:	f0 e0       	ldi	r31, 0x00	; 0
    2174:	31 96       	adiw	r30, 0x01	; 1
    2176:	02 c0       	rjmp	.+4      	; 0x217c <dtoa_prf+0x190>
    2178:	e0 e0       	ldi	r30, 0x00	; 0
    217a:	f0 e0       	ldi	r31, 0x00	; 0
    217c:	2e 0f       	add	r18, r30
    217e:	3f 1f       	adc	r19, r31
    2180:	e1 2f       	mov	r30, r17
    2182:	f0 e0       	ldi	r31, 0x00	; 0
    2184:	2e 17       	cp	r18, r30
    2186:	3f 07       	cpc	r19, r31
    2188:	1c f4       	brge	.+6      	; 0x2190 <dtoa_prf+0x1a4>
    218a:	12 1b       	sub	r17, r18
    218c:	21 2f       	mov	r18, r17
    218e:	01 c0       	rjmp	.+2      	; 0x2192 <dtoa_prf+0x1a6>
    2190:	20 e0       	ldi	r18, 0x00	; 0
    2192:	8e 2d       	mov	r24, r14
    2194:	88 71       	andi	r24, 0x18	; 24
    2196:	59 f4       	brne	.+22     	; 0x21ae <dtoa_prf+0x1c2>
    2198:	f6 01       	movw	r30, r12
    219a:	82 2f       	mov	r24, r18
    219c:	30 e2       	ldi	r19, 0x20	; 32
    219e:	88 23       	and	r24, r24
    21a0:	19 f0       	breq	.+6      	; 0x21a8 <dtoa_prf+0x1bc>
    21a2:	31 93       	st	Z+, r19
    21a4:	81 50       	subi	r24, 0x01	; 1
    21a6:	fb cf       	rjmp	.-10     	; 0x219e <dtoa_prf+0x1b2>
    21a8:	c2 0e       	add	r12, r18
    21aa:	d1 1c       	adc	r13, r1
    21ac:	20 e0       	ldi	r18, 0x00	; 0
    21ae:	99 23       	and	r25, r25
    21b0:	29 f0       	breq	.+10     	; 0x21bc <dtoa_prf+0x1d0>
    21b2:	d6 01       	movw	r26, r12
    21b4:	9c 93       	st	X, r25
    21b6:	f6 01       	movw	r30, r12
    21b8:	31 96       	adiw	r30, 0x01	; 1
    21ba:	6f 01       	movw	r12, r30
    21bc:	51 11       	cpse	r21, r1
    21be:	0b c0       	rjmp	.+22     	; 0x21d6 <dtoa_prf+0x1ea>
    21c0:	f6 01       	movw	r30, r12
    21c2:	82 2f       	mov	r24, r18
    21c4:	90 e3       	ldi	r25, 0x30	; 48
    21c6:	88 23       	and	r24, r24
    21c8:	19 f0       	breq	.+6      	; 0x21d0 <dtoa_prf+0x1e4>
    21ca:	91 93       	st	Z+, r25
    21cc:	81 50       	subi	r24, 0x01	; 1
    21ce:	fb cf       	rjmp	.-10     	; 0x21c6 <dtoa_prf+0x1da>
    21d0:	c2 0e       	add	r12, r18
    21d2:	d1 1c       	adc	r13, r1
    21d4:	20 e0       	ldi	r18, 0x00	; 0
    21d6:	0f 2d       	mov	r16, r15
    21d8:	06 0f       	add	r16, r22
    21da:	9a 81       	ldd	r25, Y+2	; 0x02
    21dc:	34 2f       	mov	r19, r20
    21de:	30 71       	andi	r19, 0x10	; 16
    21e0:	44 ff       	sbrs	r20, 4
    21e2:	03 c0       	rjmp	.+6      	; 0x21ea <dtoa_prf+0x1fe>
    21e4:	91 33       	cpi	r25, 0x31	; 49
    21e6:	09 f4       	brne	.+2      	; 0x21ea <dtoa_prf+0x1fe>
    21e8:	01 50       	subi	r16, 0x01	; 1
    21ea:	10 16       	cp	r1, r16
    21ec:	24 f4       	brge	.+8      	; 0x21f6 <dtoa_prf+0x20a>
    21ee:	09 30       	cpi	r16, 0x09	; 9
    21f0:	18 f0       	brcs	.+6      	; 0x21f8 <dtoa_prf+0x20c>
    21f2:	08 e0       	ldi	r16, 0x08	; 8
    21f4:	01 c0       	rjmp	.+2      	; 0x21f8 <dtoa_prf+0x20c>
    21f6:	01 e0       	ldi	r16, 0x01	; 1
    21f8:	ab 01       	movw	r20, r22
    21fa:	77 ff       	sbrs	r23, 7
    21fc:	02 c0       	rjmp	.+4      	; 0x2202 <dtoa_prf+0x216>
    21fe:	40 e0       	ldi	r20, 0x00	; 0
    2200:	50 e0       	ldi	r21, 0x00	; 0
    2202:	fb 01       	movw	r30, r22
    2204:	e4 1b       	sub	r30, r20
    2206:	f5 0b       	sbc	r31, r21
    2208:	a1 e0       	ldi	r26, 0x01	; 1
    220a:	b0 e0       	ldi	r27, 0x00	; 0
    220c:	ac 0f       	add	r26, r28
    220e:	bd 1f       	adc	r27, r29
    2210:	ea 0f       	add	r30, r26
    2212:	fb 1f       	adc	r31, r27
    2214:	8e e2       	ldi	r24, 0x2E	; 46
    2216:	a8 2e       	mov	r10, r24
    2218:	4b 01       	movw	r8, r22
    221a:	80 1a       	sub	r8, r16
    221c:	91 08       	sbc	r9, r1
    221e:	0b 2d       	mov	r16, r11
    2220:	10 e0       	ldi	r17, 0x00	; 0
    2222:	11 95       	neg	r17
    2224:	01 95       	neg	r16
    2226:	11 09       	sbc	r17, r1
    2228:	4f 3f       	cpi	r20, 0xFF	; 255
    222a:	bf ef       	ldi	r27, 0xFF	; 255
    222c:	5b 07       	cpc	r21, r27
    222e:	21 f4       	brne	.+8      	; 0x2238 <dtoa_prf+0x24c>
    2230:	d6 01       	movw	r26, r12
    2232:	ac 92       	st	X, r10
    2234:	11 96       	adiw	r26, 0x01	; 1
    2236:	6d 01       	movw	r12, r26
    2238:	64 17       	cp	r22, r20
    223a:	75 07       	cpc	r23, r21
    223c:	2c f0       	brlt	.+10     	; 0x2248 <dtoa_prf+0x25c>
    223e:	84 16       	cp	r8, r20
    2240:	95 06       	cpc	r9, r21
    2242:	14 f4       	brge	.+4      	; 0x2248 <dtoa_prf+0x25c>
    2244:	81 81       	ldd	r24, Z+1	; 0x01
    2246:	01 c0       	rjmp	.+2      	; 0x224a <dtoa_prf+0x25e>
    2248:	80 e3       	ldi	r24, 0x30	; 48
    224a:	41 50       	subi	r20, 0x01	; 1
    224c:	51 09       	sbc	r21, r1
    224e:	31 96       	adiw	r30, 0x01	; 1
    2250:	d6 01       	movw	r26, r12
    2252:	11 96       	adiw	r26, 0x01	; 1
    2254:	7d 01       	movw	r14, r26
    2256:	40 17       	cp	r20, r16
    2258:	51 07       	cpc	r21, r17
    225a:	24 f0       	brlt	.+8      	; 0x2264 <dtoa_prf+0x278>
    225c:	d6 01       	movw	r26, r12
    225e:	8c 93       	st	X, r24
    2260:	67 01       	movw	r12, r14
    2262:	e2 cf       	rjmp	.-60     	; 0x2228 <dtoa_prf+0x23c>
    2264:	64 17       	cp	r22, r20
    2266:	75 07       	cpc	r23, r21
    2268:	39 f4       	brne	.+14     	; 0x2278 <dtoa_prf+0x28c>
    226a:	96 33       	cpi	r25, 0x36	; 54
    226c:	20 f4       	brcc	.+8      	; 0x2276 <dtoa_prf+0x28a>
    226e:	95 33       	cpi	r25, 0x35	; 53
    2270:	19 f4       	brne	.+6      	; 0x2278 <dtoa_prf+0x28c>
    2272:	31 11       	cpse	r19, r1
    2274:	01 c0       	rjmp	.+2      	; 0x2278 <dtoa_prf+0x28c>
    2276:	81 e3       	ldi	r24, 0x31	; 49
    2278:	f6 01       	movw	r30, r12
    227a:	80 83       	st	Z, r24
    227c:	f7 01       	movw	r30, r14
    227e:	82 2f       	mov	r24, r18
    2280:	90 e2       	ldi	r25, 0x20	; 32
    2282:	88 23       	and	r24, r24
    2284:	19 f0       	breq	.+6      	; 0x228c <dtoa_prf+0x2a0>
    2286:	91 93       	st	Z+, r25
    2288:	81 50       	subi	r24, 0x01	; 1
    228a:	fb cf       	rjmp	.-10     	; 0x2282 <dtoa_prf+0x296>
    228c:	f7 01       	movw	r30, r14
    228e:	e2 0f       	add	r30, r18
    2290:	f1 1d       	adc	r31, r1
    2292:	10 82       	st	Z, r1
    2294:	80 e0       	ldi	r24, 0x00	; 0
    2296:	90 e0       	ldi	r25, 0x00	; 0
    2298:	29 96       	adiw	r28, 0x09	; 9
    229a:	ec e0       	ldi	r30, 0x0C	; 12
    229c:	0c 94 f7 12 	jmp	0x25ee	; 0x25ee <__epilogue_restores__+0xc>

000022a0 <__ftoa_engine>:
    22a0:	28 30       	cpi	r18, 0x08	; 8
    22a2:	08 f0       	brcs	.+2      	; 0x22a6 <__ftoa_engine+0x6>
    22a4:	27 e0       	ldi	r18, 0x07	; 7
    22a6:	33 27       	eor	r19, r19
    22a8:	da 01       	movw	r26, r20
    22aa:	99 0f       	add	r25, r25
    22ac:	31 1d       	adc	r19, r1
    22ae:	87 fd       	sbrc	r24, 7
    22b0:	91 60       	ori	r25, 0x01	; 1
    22b2:	00 96       	adiw	r24, 0x00	; 0
    22b4:	61 05       	cpc	r22, r1
    22b6:	71 05       	cpc	r23, r1
    22b8:	39 f4       	brne	.+14     	; 0x22c8 <__ftoa_engine+0x28>
    22ba:	32 60       	ori	r19, 0x02	; 2
    22bc:	2e 5f       	subi	r18, 0xFE	; 254
    22be:	3d 93       	st	X+, r19
    22c0:	30 e3       	ldi	r19, 0x30	; 48
    22c2:	2a 95       	dec	r18
    22c4:	e1 f7       	brne	.-8      	; 0x22be <__ftoa_engine+0x1e>
    22c6:	08 95       	ret
    22c8:	9f 3f       	cpi	r25, 0xFF	; 255
    22ca:	30 f0       	brcs	.+12     	; 0x22d8 <__ftoa_engine+0x38>
    22cc:	80 38       	cpi	r24, 0x80	; 128
    22ce:	71 05       	cpc	r23, r1
    22d0:	61 05       	cpc	r22, r1
    22d2:	09 f0       	breq	.+2      	; 0x22d6 <__ftoa_engine+0x36>
    22d4:	3c 5f       	subi	r19, 0xFC	; 252
    22d6:	3c 5f       	subi	r19, 0xFC	; 252
    22d8:	3d 93       	st	X+, r19
    22da:	91 30       	cpi	r25, 0x01	; 1
    22dc:	08 f0       	brcs	.+2      	; 0x22e0 <__ftoa_engine+0x40>
    22de:	80 68       	ori	r24, 0x80	; 128
    22e0:	91 1d       	adc	r25, r1
    22e2:	df 93       	push	r29
    22e4:	cf 93       	push	r28
    22e6:	1f 93       	push	r17
    22e8:	0f 93       	push	r16
    22ea:	ff 92       	push	r15
    22ec:	ef 92       	push	r14
    22ee:	19 2f       	mov	r17, r25
    22f0:	98 7f       	andi	r25, 0xF8	; 248
    22f2:	96 95       	lsr	r25
    22f4:	e9 2f       	mov	r30, r25
    22f6:	96 95       	lsr	r25
    22f8:	96 95       	lsr	r25
    22fa:	e9 0f       	add	r30, r25
    22fc:	ff 27       	eor	r31, r31
    22fe:	e4 5e       	subi	r30, 0xE4	; 228
    2300:	fe 4f       	sbci	r31, 0xFE	; 254
    2302:	99 27       	eor	r25, r25
    2304:	33 27       	eor	r19, r19
    2306:	ee 24       	eor	r14, r14
    2308:	ff 24       	eor	r15, r15
    230a:	a7 01       	movw	r20, r14
    230c:	e7 01       	movw	r28, r14
    230e:	05 90       	lpm	r0, Z+
    2310:	08 94       	sec
    2312:	07 94       	ror	r0
    2314:	28 f4       	brcc	.+10     	; 0x2320 <__ftoa_engine+0x80>
    2316:	36 0f       	add	r19, r22
    2318:	e7 1e       	adc	r14, r23
    231a:	f8 1e       	adc	r15, r24
    231c:	49 1f       	adc	r20, r25
    231e:	51 1d       	adc	r21, r1
    2320:	66 0f       	add	r22, r22
    2322:	77 1f       	adc	r23, r23
    2324:	88 1f       	adc	r24, r24
    2326:	99 1f       	adc	r25, r25
    2328:	06 94       	lsr	r0
    232a:	a1 f7       	brne	.-24     	; 0x2314 <__ftoa_engine+0x74>
    232c:	05 90       	lpm	r0, Z+
    232e:	07 94       	ror	r0
    2330:	28 f4       	brcc	.+10     	; 0x233c <__ftoa_engine+0x9c>
    2332:	e7 0e       	add	r14, r23
    2334:	f8 1e       	adc	r15, r24
    2336:	49 1f       	adc	r20, r25
    2338:	56 1f       	adc	r21, r22
    233a:	c1 1d       	adc	r28, r1
    233c:	77 0f       	add	r23, r23
    233e:	88 1f       	adc	r24, r24
    2340:	99 1f       	adc	r25, r25
    2342:	66 1f       	adc	r22, r22
    2344:	06 94       	lsr	r0
    2346:	a1 f7       	brne	.-24     	; 0x2330 <__ftoa_engine+0x90>
    2348:	05 90       	lpm	r0, Z+
    234a:	07 94       	ror	r0
    234c:	28 f4       	brcc	.+10     	; 0x2358 <__ftoa_engine+0xb8>
    234e:	f8 0e       	add	r15, r24
    2350:	49 1f       	adc	r20, r25
    2352:	56 1f       	adc	r21, r22
    2354:	c7 1f       	adc	r28, r23
    2356:	d1 1d       	adc	r29, r1
    2358:	88 0f       	add	r24, r24
    235a:	99 1f       	adc	r25, r25
    235c:	66 1f       	adc	r22, r22
    235e:	77 1f       	adc	r23, r23
    2360:	06 94       	lsr	r0
    2362:	a1 f7       	brne	.-24     	; 0x234c <__ftoa_engine+0xac>
    2364:	05 90       	lpm	r0, Z+
    2366:	07 94       	ror	r0
    2368:	20 f4       	brcc	.+8      	; 0x2372 <__ftoa_engine+0xd2>
    236a:	49 0f       	add	r20, r25
    236c:	56 1f       	adc	r21, r22
    236e:	c7 1f       	adc	r28, r23
    2370:	d8 1f       	adc	r29, r24
    2372:	99 0f       	add	r25, r25
    2374:	66 1f       	adc	r22, r22
    2376:	77 1f       	adc	r23, r23
    2378:	88 1f       	adc	r24, r24
    237a:	06 94       	lsr	r0
    237c:	a9 f7       	brne	.-22     	; 0x2368 <__ftoa_engine+0xc8>
    237e:	84 91       	lpm	r24, Z
    2380:	10 95       	com	r17
    2382:	17 70       	andi	r17, 0x07	; 7
    2384:	41 f0       	breq	.+16     	; 0x2396 <__ftoa_engine+0xf6>
    2386:	d6 95       	lsr	r29
    2388:	c7 95       	ror	r28
    238a:	57 95       	ror	r21
    238c:	47 95       	ror	r20
    238e:	f7 94       	ror	r15
    2390:	e7 94       	ror	r14
    2392:	1a 95       	dec	r17
    2394:	c1 f7       	brne	.-16     	; 0x2386 <__ftoa_engine+0xe6>
    2396:	e2 ec       	ldi	r30, 0xC2	; 194
    2398:	f0 e0       	ldi	r31, 0x00	; 0
    239a:	68 94       	set
    239c:	15 90       	lpm	r1, Z+
    239e:	15 91       	lpm	r17, Z+
    23a0:	35 91       	lpm	r19, Z+
    23a2:	65 91       	lpm	r22, Z+
    23a4:	95 91       	lpm	r25, Z+
    23a6:	05 90       	lpm	r0, Z+
    23a8:	7f e2       	ldi	r23, 0x2F	; 47
    23aa:	73 95       	inc	r23
    23ac:	e1 18       	sub	r14, r1
    23ae:	f1 0a       	sbc	r15, r17
    23b0:	43 0b       	sbc	r20, r19
    23b2:	56 0b       	sbc	r21, r22
    23b4:	c9 0b       	sbc	r28, r25
    23b6:	d0 09       	sbc	r29, r0
    23b8:	c0 f7       	brcc	.-16     	; 0x23aa <__ftoa_engine+0x10a>
    23ba:	e1 0c       	add	r14, r1
    23bc:	f1 1e       	adc	r15, r17
    23be:	43 1f       	adc	r20, r19
    23c0:	56 1f       	adc	r21, r22
    23c2:	c9 1f       	adc	r28, r25
    23c4:	d0 1d       	adc	r29, r0
    23c6:	7e f4       	brtc	.+30     	; 0x23e6 <__ftoa_engine+0x146>
    23c8:	70 33       	cpi	r23, 0x30	; 48
    23ca:	11 f4       	brne	.+4      	; 0x23d0 <__ftoa_engine+0x130>
    23cc:	8a 95       	dec	r24
    23ce:	e6 cf       	rjmp	.-52     	; 0x239c <__ftoa_engine+0xfc>
    23d0:	e8 94       	clt
    23d2:	01 50       	subi	r16, 0x01	; 1
    23d4:	30 f0       	brcs	.+12     	; 0x23e2 <__ftoa_engine+0x142>
    23d6:	08 0f       	add	r16, r24
    23d8:	0a f4       	brpl	.+2      	; 0x23dc <__ftoa_engine+0x13c>
    23da:	00 27       	eor	r16, r16
    23dc:	02 17       	cp	r16, r18
    23de:	08 f4       	brcc	.+2      	; 0x23e2 <__ftoa_engine+0x142>
    23e0:	20 2f       	mov	r18, r16
    23e2:	23 95       	inc	r18
    23e4:	02 2f       	mov	r16, r18
    23e6:	7a 33       	cpi	r23, 0x3A	; 58
    23e8:	28 f0       	brcs	.+10     	; 0x23f4 <__ftoa_engine+0x154>
    23ea:	79 e3       	ldi	r23, 0x39	; 57
    23ec:	7d 93       	st	X+, r23
    23ee:	2a 95       	dec	r18
    23f0:	e9 f7       	brne	.-6      	; 0x23ec <__ftoa_engine+0x14c>
    23f2:	10 c0       	rjmp	.+32     	; 0x2414 <__ftoa_engine+0x174>
    23f4:	7d 93       	st	X+, r23
    23f6:	2a 95       	dec	r18
    23f8:	89 f6       	brne	.-94     	; 0x239c <__ftoa_engine+0xfc>
    23fa:	06 94       	lsr	r0
    23fc:	97 95       	ror	r25
    23fe:	67 95       	ror	r22
    2400:	37 95       	ror	r19
    2402:	17 95       	ror	r17
    2404:	17 94       	ror	r1
    2406:	e1 18       	sub	r14, r1
    2408:	f1 0a       	sbc	r15, r17
    240a:	43 0b       	sbc	r20, r19
    240c:	56 0b       	sbc	r21, r22
    240e:	c9 0b       	sbc	r28, r25
    2410:	d0 09       	sbc	r29, r0
    2412:	98 f0       	brcs	.+38     	; 0x243a <__ftoa_engine+0x19a>
    2414:	23 95       	inc	r18
    2416:	7e 91       	ld	r23, -X
    2418:	73 95       	inc	r23
    241a:	7a 33       	cpi	r23, 0x3A	; 58
    241c:	08 f0       	brcs	.+2      	; 0x2420 <__ftoa_engine+0x180>
    241e:	70 e3       	ldi	r23, 0x30	; 48
    2420:	7c 93       	st	X, r23
    2422:	20 13       	cpse	r18, r16
    2424:	b8 f7       	brcc	.-18     	; 0x2414 <__ftoa_engine+0x174>
    2426:	7e 91       	ld	r23, -X
    2428:	70 61       	ori	r23, 0x10	; 16
    242a:	7d 93       	st	X+, r23
    242c:	30 f0       	brcs	.+12     	; 0x243a <__ftoa_engine+0x19a>
    242e:	83 95       	inc	r24
    2430:	71 e3       	ldi	r23, 0x31	; 49
    2432:	7d 93       	st	X+, r23
    2434:	70 e3       	ldi	r23, 0x30	; 48
    2436:	2a 95       	dec	r18
    2438:	e1 f7       	brne	.-8      	; 0x2432 <__ftoa_engine+0x192>
    243a:	11 24       	eor	r1, r1
    243c:	ef 90       	pop	r14
    243e:	ff 90       	pop	r15
    2440:	0f 91       	pop	r16
    2442:	1f 91       	pop	r17
    2444:	cf 91       	pop	r28
    2446:	df 91       	pop	r29
    2448:	99 27       	eor	r25, r25
    244a:	87 fd       	sbrc	r24, 7
    244c:	90 95       	com	r25
    244e:	08 95       	ret

00002450 <strnlen_P>:
    2450:	fc 01       	movw	r30, r24
    2452:	05 90       	lpm	r0, Z+
    2454:	61 50       	subi	r22, 0x01	; 1
    2456:	70 40       	sbci	r23, 0x00	; 0
    2458:	01 10       	cpse	r0, r1
    245a:	d8 f7       	brcc	.-10     	; 0x2452 <strnlen_P+0x2>
    245c:	80 95       	com	r24
    245e:	90 95       	com	r25
    2460:	8e 0f       	add	r24, r30
    2462:	9f 1f       	adc	r25, r31
    2464:	08 95       	ret

00002466 <strnlen>:
    2466:	fc 01       	movw	r30, r24
    2468:	61 50       	subi	r22, 0x01	; 1
    246a:	70 40       	sbci	r23, 0x00	; 0
    246c:	01 90       	ld	r0, Z+
    246e:	01 10       	cpse	r0, r1
    2470:	d8 f7       	brcc	.-10     	; 0x2468 <strnlen+0x2>
    2472:	80 95       	com	r24
    2474:	90 95       	com	r25
    2476:	8e 0f       	add	r24, r30
    2478:	9f 1f       	adc	r25, r31
    247a:	08 95       	ret

0000247c <fputc>:
    247c:	0f 93       	push	r16
    247e:	1f 93       	push	r17
    2480:	cf 93       	push	r28
    2482:	df 93       	push	r29
    2484:	fb 01       	movw	r30, r22
    2486:	23 81       	ldd	r18, Z+3	; 0x03
    2488:	21 fd       	sbrc	r18, 1
    248a:	03 c0       	rjmp	.+6      	; 0x2492 <fputc+0x16>
    248c:	8f ef       	ldi	r24, 0xFF	; 255
    248e:	9f ef       	ldi	r25, 0xFF	; 255
    2490:	2c c0       	rjmp	.+88     	; 0x24ea <fputc+0x6e>
    2492:	22 ff       	sbrs	r18, 2
    2494:	16 c0       	rjmp	.+44     	; 0x24c2 <fputc+0x46>
    2496:	46 81       	ldd	r20, Z+6	; 0x06
    2498:	57 81       	ldd	r21, Z+7	; 0x07
    249a:	24 81       	ldd	r18, Z+4	; 0x04
    249c:	35 81       	ldd	r19, Z+5	; 0x05
    249e:	42 17       	cp	r20, r18
    24a0:	53 07       	cpc	r21, r19
    24a2:	44 f4       	brge	.+16     	; 0x24b4 <fputc+0x38>
    24a4:	a0 81       	ld	r26, Z
    24a6:	b1 81       	ldd	r27, Z+1	; 0x01
    24a8:	9d 01       	movw	r18, r26
    24aa:	2f 5f       	subi	r18, 0xFF	; 255
    24ac:	3f 4f       	sbci	r19, 0xFF	; 255
    24ae:	20 83       	st	Z, r18
    24b0:	31 83       	std	Z+1, r19	; 0x01
    24b2:	8c 93       	st	X, r24
    24b4:	26 81       	ldd	r18, Z+6	; 0x06
    24b6:	37 81       	ldd	r19, Z+7	; 0x07
    24b8:	2f 5f       	subi	r18, 0xFF	; 255
    24ba:	3f 4f       	sbci	r19, 0xFF	; 255
    24bc:	26 83       	std	Z+6, r18	; 0x06
    24be:	37 83       	std	Z+7, r19	; 0x07
    24c0:	14 c0       	rjmp	.+40     	; 0x24ea <fputc+0x6e>
    24c2:	8b 01       	movw	r16, r22
    24c4:	ec 01       	movw	r28, r24
    24c6:	fb 01       	movw	r30, r22
    24c8:	00 84       	ldd	r0, Z+8	; 0x08
    24ca:	f1 85       	ldd	r31, Z+9	; 0x09
    24cc:	e0 2d       	mov	r30, r0
    24ce:	09 95       	icall
    24d0:	89 2b       	or	r24, r25
    24d2:	e1 f6       	brne	.-72     	; 0x248c <fputc+0x10>
    24d4:	d8 01       	movw	r26, r16
    24d6:	16 96       	adiw	r26, 0x06	; 6
    24d8:	8d 91       	ld	r24, X+
    24da:	9c 91       	ld	r25, X
    24dc:	17 97       	sbiw	r26, 0x07	; 7
    24de:	01 96       	adiw	r24, 0x01	; 1
    24e0:	16 96       	adiw	r26, 0x06	; 6
    24e2:	8d 93       	st	X+, r24
    24e4:	9c 93       	st	X, r25
    24e6:	17 97       	sbiw	r26, 0x07	; 7
    24e8:	ce 01       	movw	r24, r28
    24ea:	df 91       	pop	r29
    24ec:	cf 91       	pop	r28
    24ee:	1f 91       	pop	r17
    24f0:	0f 91       	pop	r16
    24f2:	08 95       	ret

000024f4 <__ultoa_invert>:
    24f4:	fa 01       	movw	r30, r20
    24f6:	aa 27       	eor	r26, r26
    24f8:	28 30       	cpi	r18, 0x08	; 8
    24fa:	51 f1       	breq	.+84     	; 0x2550 <__ultoa_invert+0x5c>
    24fc:	20 31       	cpi	r18, 0x10	; 16
    24fe:	81 f1       	breq	.+96     	; 0x2560 <__ultoa_invert+0x6c>
    2500:	e8 94       	clt
    2502:	6f 93       	push	r22
    2504:	6e 7f       	andi	r22, 0xFE	; 254
    2506:	6e 5f       	subi	r22, 0xFE	; 254
    2508:	7f 4f       	sbci	r23, 0xFF	; 255
    250a:	8f 4f       	sbci	r24, 0xFF	; 255
    250c:	9f 4f       	sbci	r25, 0xFF	; 255
    250e:	af 4f       	sbci	r26, 0xFF	; 255
    2510:	b1 e0       	ldi	r27, 0x01	; 1
    2512:	3e d0       	rcall	.+124    	; 0x2590 <__ultoa_invert+0x9c>
    2514:	b4 e0       	ldi	r27, 0x04	; 4
    2516:	3c d0       	rcall	.+120    	; 0x2590 <__ultoa_invert+0x9c>
    2518:	67 0f       	add	r22, r23
    251a:	78 1f       	adc	r23, r24
    251c:	89 1f       	adc	r24, r25
    251e:	9a 1f       	adc	r25, r26
    2520:	a1 1d       	adc	r26, r1
    2522:	68 0f       	add	r22, r24
    2524:	79 1f       	adc	r23, r25
    2526:	8a 1f       	adc	r24, r26
    2528:	91 1d       	adc	r25, r1
    252a:	a1 1d       	adc	r26, r1
    252c:	6a 0f       	add	r22, r26
    252e:	71 1d       	adc	r23, r1
    2530:	81 1d       	adc	r24, r1
    2532:	91 1d       	adc	r25, r1
    2534:	a1 1d       	adc	r26, r1
    2536:	20 d0       	rcall	.+64     	; 0x2578 <__ultoa_invert+0x84>
    2538:	09 f4       	brne	.+2      	; 0x253c <__ultoa_invert+0x48>
    253a:	68 94       	set
    253c:	3f 91       	pop	r19
    253e:	2a e0       	ldi	r18, 0x0A	; 10
    2540:	26 9f       	mul	r18, r22
    2542:	11 24       	eor	r1, r1
    2544:	30 19       	sub	r19, r0
    2546:	30 5d       	subi	r19, 0xD0	; 208
    2548:	31 93       	st	Z+, r19
    254a:	de f6       	brtc	.-74     	; 0x2502 <__ultoa_invert+0xe>
    254c:	cf 01       	movw	r24, r30
    254e:	08 95       	ret
    2550:	46 2f       	mov	r20, r22
    2552:	47 70       	andi	r20, 0x07	; 7
    2554:	40 5d       	subi	r20, 0xD0	; 208
    2556:	41 93       	st	Z+, r20
    2558:	b3 e0       	ldi	r27, 0x03	; 3
    255a:	0f d0       	rcall	.+30     	; 0x257a <__ultoa_invert+0x86>
    255c:	c9 f7       	brne	.-14     	; 0x2550 <__ultoa_invert+0x5c>
    255e:	f6 cf       	rjmp	.-20     	; 0x254c <__ultoa_invert+0x58>
    2560:	46 2f       	mov	r20, r22
    2562:	4f 70       	andi	r20, 0x0F	; 15
    2564:	40 5d       	subi	r20, 0xD0	; 208
    2566:	4a 33       	cpi	r20, 0x3A	; 58
    2568:	18 f0       	brcs	.+6      	; 0x2570 <__ultoa_invert+0x7c>
    256a:	49 5d       	subi	r20, 0xD9	; 217
    256c:	31 fd       	sbrc	r19, 1
    256e:	40 52       	subi	r20, 0x20	; 32
    2570:	41 93       	st	Z+, r20
    2572:	02 d0       	rcall	.+4      	; 0x2578 <__ultoa_invert+0x84>
    2574:	a9 f7       	brne	.-22     	; 0x2560 <__ultoa_invert+0x6c>
    2576:	ea cf       	rjmp	.-44     	; 0x254c <__ultoa_invert+0x58>
    2578:	b4 e0       	ldi	r27, 0x04	; 4
    257a:	a6 95       	lsr	r26
    257c:	97 95       	ror	r25
    257e:	87 95       	ror	r24
    2580:	77 95       	ror	r23
    2582:	67 95       	ror	r22
    2584:	ba 95       	dec	r27
    2586:	c9 f7       	brne	.-14     	; 0x257a <__ultoa_invert+0x86>
    2588:	00 97       	sbiw	r24, 0x00	; 0
    258a:	61 05       	cpc	r22, r1
    258c:	71 05       	cpc	r23, r1
    258e:	08 95       	ret
    2590:	9b 01       	movw	r18, r22
    2592:	ac 01       	movw	r20, r24
    2594:	0a 2e       	mov	r0, r26
    2596:	06 94       	lsr	r0
    2598:	57 95       	ror	r21
    259a:	47 95       	ror	r20
    259c:	37 95       	ror	r19
    259e:	27 95       	ror	r18
    25a0:	ba 95       	dec	r27
    25a2:	c9 f7       	brne	.-14     	; 0x2596 <__ultoa_invert+0xa2>
    25a4:	62 0f       	add	r22, r18
    25a6:	73 1f       	adc	r23, r19
    25a8:	84 1f       	adc	r24, r20
    25aa:	95 1f       	adc	r25, r21
    25ac:	a0 1d       	adc	r26, r0
    25ae:	08 95       	ret

000025b0 <__prologue_saves__>:
    25b0:	2f 92       	push	r2
    25b2:	3f 92       	push	r3
    25b4:	4f 92       	push	r4
    25b6:	5f 92       	push	r5
    25b8:	6f 92       	push	r6
    25ba:	7f 92       	push	r7
    25bc:	8f 92       	push	r8
    25be:	9f 92       	push	r9
    25c0:	af 92       	push	r10
    25c2:	bf 92       	push	r11
    25c4:	cf 92       	push	r12
    25c6:	df 92       	push	r13
    25c8:	ef 92       	push	r14
    25ca:	ff 92       	push	r15
    25cc:	0f 93       	push	r16
    25ce:	1f 93       	push	r17
    25d0:	cf 93       	push	r28
    25d2:	df 93       	push	r29
    25d4:	cd b7       	in	r28, 0x3d	; 61
    25d6:	de b7       	in	r29, 0x3e	; 62
    25d8:	ca 1b       	sub	r28, r26
    25da:	db 0b       	sbc	r29, r27
    25dc:	cd bf       	out	0x3d, r28	; 61
    25de:	de bf       	out	0x3e, r29	; 62
    25e0:	09 94       	ijmp

000025e2 <__epilogue_restores__>:
    25e2:	2a 88       	ldd	r2, Y+18	; 0x12
    25e4:	39 88       	ldd	r3, Y+17	; 0x11
    25e6:	48 88       	ldd	r4, Y+16	; 0x10
    25e8:	5f 84       	ldd	r5, Y+15	; 0x0f
    25ea:	6e 84       	ldd	r6, Y+14	; 0x0e
    25ec:	7d 84       	ldd	r7, Y+13	; 0x0d
    25ee:	8c 84       	ldd	r8, Y+12	; 0x0c
    25f0:	9b 84       	ldd	r9, Y+11	; 0x0b
    25f2:	aa 84       	ldd	r10, Y+10	; 0x0a
    25f4:	b9 84       	ldd	r11, Y+9	; 0x09
    25f6:	c8 84       	ldd	r12, Y+8	; 0x08
    25f8:	df 80       	ldd	r13, Y+7	; 0x07
    25fa:	ee 80       	ldd	r14, Y+6	; 0x06
    25fc:	fd 80       	ldd	r15, Y+5	; 0x05
    25fe:	0c 81       	ldd	r16, Y+4	; 0x04
    2600:	1b 81       	ldd	r17, Y+3	; 0x03
    2602:	aa 81       	ldd	r26, Y+2	; 0x02
    2604:	b9 81       	ldd	r27, Y+1	; 0x01
    2606:	ce 0f       	add	r28, r30
    2608:	d1 1d       	adc	r29, r1
    260a:	cd bf       	out	0x3d, r28	; 61
    260c:	de bf       	out	0x3e, r29	; 62
    260e:	ed 01       	movw	r28, r26
    2610:	08 95       	ret

00002612 <_exit>:
    2612:	f8 94       	cli

00002614 <__stop_program>:
    2614:	ff cf       	rjmp	.-2      	; 0x2614 <__stop_program>
