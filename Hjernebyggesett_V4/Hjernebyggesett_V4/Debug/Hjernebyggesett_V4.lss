
Hjernebyggesett_V4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000016  00803800  000017c4  00001878  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001784  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000040  00009784  00001784  00001838  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .bss          00000054  00803816  00803816  0000188e  2**0
                  ALLOC
  4 .comment      00000030  00000000  00000000  0000188e  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000018c0  2**2
                  CONTENTS, READONLY
  6 .debug_aranges 000004e8  00000000  00000000  00001900  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   000085f7  00000000  00000000  00001de8  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00003615  00000000  00000000  0000a3df  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00002815  00000000  00000000  0000d9f4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  0000083c  00000000  00000000  0001020c  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000034bf  00000000  00000000  00010a48  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000139d  00000000  00000000  00013f07  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000360  00000000  00000000  000152a4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 61 00 	jmp	0xc2	; 0xc2 <__ctors_end>
       4:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
       8:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
       c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      10:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      14:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      18:	0c 94 aa 04 	jmp	0x954	; 0x954 <__vector_6>
      1c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      20:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      24:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      28:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      2c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      30:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      34:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      38:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      3c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      40:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      44:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      48:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      4c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      50:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      54:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      58:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      5c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      60:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      64:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      68:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      6c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      70:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      74:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      78:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      7c:	07 63       	ori	r16, 0x37	; 55
      7e:	42 36       	cpi	r20, 0x62	; 98
      80:	b7 9b       	sbis	0x16, 7	; 22
      82:	d8 a7       	std	Y+40, r29	; 0x28
      84:	1a 39       	cpi	r17, 0x9A	; 154
      86:	68 56       	subi	r22, 0x68	; 104
      88:	18 ae       	std	Y+56, r1	; 0x38
      8a:	ba ab       	std	Y+50, r27	; 0x32
      8c:	55 8c       	ldd	r5, Z+29	; 0x1d
      8e:	1d 3c       	cpi	r17, 0xCD	; 205
      90:	b7 cc       	rjmp	.-1682   	; 0xfffffa00 <__eeprom_end+0xff7efa00>
      92:	57 63       	ori	r21, 0x37	; 55
      94:	bd 6d       	ori	r27, 0xDD	; 221
      96:	ed fd       	.word	0xfded	; ????
      98:	75 3e       	cpi	r23, 0xE5	; 229
      9a:	f6 17       	cp	r31, r22
      9c:	72 31       	cpi	r23, 0x12	; 18
      9e:	bf 00       	.word	0x00bf	; ????
      a0:	00 00       	nop
      a2:	80 3f       	cpi	r24, 0xF0	; 240
      a4:	05 a8       	ldd	r0, Z+53	; 0x35
      a6:	4c cd       	rjmp	.-1384   	; 0xfffffb40 <__eeprom_end+0xff7efb40>
      a8:	b2 d4       	rcall	.+2404   	; 0xa0e <tinyLED_set_color_mode+0xe>
      aa:	4e b9       	out	0x0e, r20	; 14
      ac:	38 36       	cpi	r19, 0x68	; 104
      ae:	a9 02       	muls	r26, r25
      b0:	0c 50       	subi	r16, 0x0C	; 12
      b2:	b9 91       	ld	r27, Y+
      b4:	86 88       	ldd	r8, Z+22	; 0x16
      b6:	08 3c       	cpi	r16, 0xC8	; 200
      b8:	a6 aa       	std	Z+54, r10	; 0x36
      ba:	aa 2a       	or	r10, r26
      bc:	be 00       	.word	0x00be	; ????
      be:	00 00       	nop
      c0:	80 3f       	cpi	r24, 0xF0	; 240

000000c2 <__ctors_end>:
      c2:	11 24       	eor	r1, r1
      c4:	1f be       	out	0x3f, r1	; 63
      c6:	cf ef       	ldi	r28, 0xFF	; 255
      c8:	cd bf       	out	0x3d, r28	; 61
      ca:	df e3       	ldi	r29, 0x3F	; 63
      cc:	de bf       	out	0x3e, r29	; 62

000000ce <__do_copy_data>:
      ce:	18 e3       	ldi	r17, 0x38	; 56
      d0:	a0 e0       	ldi	r26, 0x00	; 0
      d2:	b8 e3       	ldi	r27, 0x38	; 56
      d4:	e4 ec       	ldi	r30, 0xC4	; 196
      d6:	f7 e1       	ldi	r31, 0x17	; 23
      d8:	02 c0       	rjmp	.+4      	; 0xde <__do_copy_data+0x10>
      da:	05 90       	lpm	r0, Z+
      dc:	0d 92       	st	X+, r0
      de:	a6 31       	cpi	r26, 0x16	; 22
      e0:	b1 07       	cpc	r27, r17
      e2:	d9 f7       	brne	.-10     	; 0xda <__do_copy_data+0xc>

000000e4 <__do_clear_bss>:
      e4:	28 e3       	ldi	r18, 0x38	; 56
      e6:	a6 e1       	ldi	r26, 0x16	; 22
      e8:	b8 e3       	ldi	r27, 0x38	; 56
      ea:	01 c0       	rjmp	.+2      	; 0xee <.do_clear_bss_start>

000000ec <.do_clear_bss_loop>:
      ec:	1d 92       	st	X+, r1

000000ee <.do_clear_bss_start>:
      ee:	aa 36       	cpi	r26, 0x6A	; 106
      f0:	b2 07       	cpc	r27, r18
      f2:	e1 f7       	brne	.-8      	; 0xec <.do_clear_bss_loop>
      f4:	0e 94 83 00 	call	0x106	; 0x106 <main>
      f8:	0c 94 c0 0b 	jmp	0x1780	; 0x1780 <_exit>

000000fc <__bad_interrupt>:
      fc:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000100 <atmel_start_init>:
/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
	system_init();
     100:	0e 94 9e 01 	call	0x33c	; 0x33c <system_init>
     104:	08 95       	ret

00000106 <main>:

int main(void)
{	
	
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
     106:	0e 94 80 00 	call	0x100	; 0x100 <atmel_start_init>
	For some reason, instead of the reference voltage being 4.32v, it is 3.3v. 
	A plausible explanation is that the microchip does not up the voltage, so that if the microchip is only ever 
	supplied with 3.3v, it will output 3.3v as the max.
	*/
	
	VREF.CTRLA |= VREF_DAC0REFSEL_4V34_gc;
     10a:	e0 ea       	ldi	r30, 0xA0	; 160
     10c:	f0 e0       	ldi	r31, 0x00	; 0
     10e:	80 81       	ld	r24, Z
     110:	83 60       	ori	r24, 0x03	; 3
     112:	80 83       	st	Z, r24
	while (1)
	{
		// We don't want to update the neuron too often because of various reasons. The tinyISR_getflag is set every ms, and so the loop is only run once every ms.  
		if(tinyISR_getflag())
     114:	0e 94 d8 04 	call	0x9b0	; 0x9b0 <tinyISR_getflag>
     118:	88 23       	and	r24, r24
     11a:	e1 f3       	breq	.-8      	; 0x114 <main+0xe>
		{
			
			if(tinyCharge_is_connected_to_charger()){
     11c:	0e 94 98 03 	call	0x730	; 0x730 <tinyCharge_is_connected_to_charger>
     120:	88 23       	and	r24, r24
     122:	59 f0       	breq	.+22     	; 0x13a <main+0x34>
				// Charge loop
				
				if(tinyCharge_is_fully_charged()){
     124:	0e 94 9b 03 	call	0x736	; 0x736 <tinyCharge_is_fully_charged>
     128:	88 23       	and	r24, r24
     12a:	21 f0       	breq	.+8      	; 0x134 <main+0x2e>
					tinyLED_set_color(OUT_LED, CHARGING_DONE_COLOR);
     12c:	63 e0       	ldi	r22, 0x03	; 3
     12e:	81 e0       	ldi	r24, 0x01	; 1
     130:	0e 94 ef 04 	call	0x9de	; 0x9de <tinyLED_set_color>
				}				
				// We check the Dendrites in order to detect if we have stopped charging
				tinyDendrite_update_signals();
     134:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <tinyDendrite_update_signals>
     138:	0e c0       	rjmp	.+28     	; 0x156 <main+0x50>
			}
			else{
				// Main loop			
				
				// Set LED
				if(tinyLED_get_color(OUT_LED) == OFF){
     13a:	81 e0       	ldi	r24, 0x01	; 1
     13c:	0e 94 f8 04 	call	0x9f0	; 0x9f0 <tinyLED_get_color>
     140:	81 11       	cpse	r24, r1
     142:	05 c0       	rjmp	.+10     	; 0x14e <main+0x48>
					tinyLED_set_color_mode(OUT_LED, PING_COLOR, PING);
     144:	43 e0       	ldi	r20, 0x03	; 3
     146:	62 e0       	ldi	r22, 0x02	; 2
     148:	81 e0       	ldi	r24, 0x01	; 1
     14a:	0e 94 00 05 	call	0xa00	; 0xa00 <tinyLED_set_color_mode>
				}
				
				// Update button	
				tinyButton_update();
     14e:	0e 94 39 03 	call	0x672	; 0x672 <tinyButton_update>
				
				// Update the potential (This is where most of the important stuff happens)
				tinyPotential_update();
     152:	0e 94 22 07 	call	0xe44	; 0xe44 <tinyPotential_update>
			}
			// Update LED
			tinyLED_update();
     156:	0e 94 40 05 	call	0xa80	; 0xa80 <tinyLED_update>
				
			// Switch transistors
			tinyCharge_set_transistors();
     15a:	0e 94 d0 03 	call	0x7a0	; 0x7a0 <tinyCharge_set_transistors>
			
			// Prepare for next cycle
			tinyISR_setflag(false);
     15e:	80 e0       	ldi	r24, 0x00	; 0
     160:	0e 94 d5 04 	call	0x9aa	; 0x9aa <tinyISR_setflag>
			tinyDebugger_send_uint32("time", tinyTime_now());
     164:	0e 94 ff 07 	call	0xffe	; 0xffe <tinyTime_now>
     168:	ab 01       	movw	r20, r22
     16a:	bc 01       	movw	r22, r24
     16c:	84 e8       	ldi	r24, 0x84	; 132
     16e:	97 e9       	ldi	r25, 0x97	; 151
     170:	0e 94 d8 03 	call	0x7b0	; 0x7b0 <tinyDebugger_send_uint32>
			tinyDebugger_end_line();
     174:	0e 94 db 03 	call	0x7b6	; 0x7b6 <tinyDebugger_end_line>
     178:	cd cf       	rjmp	.-102    	; 0x114 <main+0xe>

0000017a <ADC_0_init>:
 * \return Conversion result read from the ADC_0 ADC module
 */
adc_result_t ADC_0_get_conversion_result(void)
{
	return (ADC1.RES);
}
     17a:	e0 e4       	ldi	r30, 0x40	; 64
     17c:	f6 e0       	ldi	r31, 0x06	; 6
     17e:	80 e1       	ldi	r24, 0x10	; 16
     180:	82 83       	std	Z+2, r24	; 0x02
     182:	85 e0       	ldi	r24, 0x05	; 5
     184:	80 83       	st	Z, r24
     186:	80 e0       	ldi	r24, 0x00	; 0
     188:	08 95       	ret

0000018a <ADC_0_is_conversion_done>:
     18a:	80 91 4b 06 	lds	r24, 0x064B	; 0x80064b <__TEXT_REGION_LENGTH__+0x70064b>
     18e:	81 70       	andi	r24, 0x01	; 1
     190:	08 95       	ret

00000192 <ADC_0_get_conversion>:
 *
 * \return Nothing
 */
void ADC_0_start_conversion(adc_1_channel_t channel)
{
	ADC1.MUXPOS  = channel;
     192:	e0 e4       	ldi	r30, 0x40	; 64
     194:	f6 e0       	ldi	r31, 0x06	; 6
     196:	86 83       	std	Z+6, r24	; 0x06
	ADC1.COMMAND = ADC_STCONV_bm;
     198:	81 e0       	ldi	r24, 0x01	; 1
     19a:	80 87       	std	Z+8, r24	; 0x08
adc_result_t ADC_0_get_conversion(adc_1_channel_t channel)
{
	adc_result_t res;

	ADC_0_start_conversion(channel);
	while (!ADC_0_is_conversion_done())
     19c:	0e 94 c5 00 	call	0x18a	; 0x18a <ADC_0_is_conversion_done>
     1a0:	88 23       	and	r24, r24
     1a2:	e1 f3       	breq	.-8      	; 0x19c <ADC_0_get_conversion+0xa>
 *
 * \return Conversion result read from the ADC_0 ADC module
 */
adc_result_t ADC_0_get_conversion_result(void)
{
	return (ADC1.RES);
     1a4:	e0 e4       	ldi	r30, 0x40	; 64
     1a6:	f6 e0       	ldi	r31, 0x06	; 6
     1a8:	20 89       	ldd	r18, Z+16	; 0x10
     1aa:	31 89       	ldd	r19, Z+17	; 0x11

	ADC_0_start_conversion(channel);
	while (!ADC_0_is_conversion_done())
		;
	res = ADC_0_get_conversion_result();
	ADC1.INTFLAGS |= ADC_RESRDY_bm;
     1ac:	93 85       	ldd	r25, Z+11	; 0x0b
     1ae:	91 60       	ori	r25, 0x01	; 1
     1b0:	93 87       	std	Z+11, r25	; 0x0b
	return res;
}
     1b2:	c9 01       	movw	r24, r18
     1b4:	08 95       	ret

000001b6 <BOD_init>:
	//		 | BOD_VLMCFG_BELOW_gc; /* Interrupt when supply goes below VLM level */

	// BOD.VLMCTRLA = BOD_VLMLVL_5ABOVE_gc; /* VLM threshold 5% above BOD level */

	return 0;
}
     1b6:	80 e0       	ldi	r24, 0x00	; 0
     1b8:	08 95       	ret

000001ba <DIGITAL_GLUE_LOGIC_0_init>:

	// Enable Protected register, peripheral must be disabled (ENABLE=0, in TCD.LUT0CTRLA).

	// CCL.SEQCTRL0 = CCL_SEQSEL_DISABLE_gc /* Sequential logic disabled */;

	CCL.TRUTH0 = 168; /* Truth 0: 168 */
     1ba:	e0 ec       	ldi	r30, 0xC0	; 192
     1bc:	f1 e0       	ldi	r31, 0x01	; 1
     1be:	28 ea       	ldi	r18, 0xA8	; 168
     1c0:	20 87       	std	Z+8, r18	; 0x08

	CCL.LUT0CTRLC = CCL_INSEL2_TCA0_gc /* TCA0 WO2 input source */;
     1c2:	98 e0       	ldi	r25, 0x08	; 8
     1c4:	97 83       	std	Z+7, r25	; 0x07

	CCL.LUT0CTRLB = CCL_INSEL0_SPI0_gc /* SPI0 SCK source */
     1c6:	8b eb       	ldi	r24, 0xBB	; 187
     1c8:	86 83       	std	Z+6, r24	; 0x06
	                | CCL_INSEL1_SPI0_gc /* SPI0 MOSI input source */;

	CCL.LUT0CTRLA = 0 << CCL_CLKSRC_bp       /* Clock Source Selection: disabled */
     1ca:	39 e0       	ldi	r19, 0x09	; 9
     1cc:	35 83       	std	Z+5, r19	; 0x05
	                | CCL_EDGEDET_DIS_gc     /* Edge detector is disabled */
	                | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	                | 1 << CCL_ENABLE_bp     /* LUT Enable: enabled */
	                | 1 << CCL_OUTEN_bp;     /* Output Enable: enabled */

	CCL.TRUTH1 = 168; /* Truth 1: 168 */
     1ce:	24 87       	std	Z+12, r18	; 0x0c

	CCL.LUT1CTRLC = CCL_INSEL2_TCA0_gc /* TCA0 WO2 input source */;
     1d0:	93 87       	std	Z+11, r25	; 0x0b

	CCL.LUT1CTRLB = CCL_INSEL0_SPI0_gc /* SPI0 SCK source */
     1d2:	82 87       	std	Z+10, r24	; 0x0a
	//		 | CCL_EDGEDET_DIS_gc /* Edge detector is disabled */
	//		 | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	//		 | 0 << CCL_ENABLE_bp /* LUT Enable: disabled */
	//		 | 0 << CCL_OUTEN_bp; /* Output Enable: disabled */

	CCL.CTRLA = 1 << CCL_ENABLE_bp      /* Enable: enabled */
     1d4:	81 e4       	ldi	r24, 0x41	; 65
     1d6:	80 83       	st	Z, r24
	            | 1 << CCL_RUNSTDBY_bp; /* Run in Standby: enabled */

	return 0;
}
     1d8:	80 e0       	ldi	r24, 0x00	; 0
     1da:	08 95       	ret

000001dc <CLKCTRL_init>:
 *       on calling convention. The memory model is not visible to the
 *       preprocessor, so it must be defined in the Assembler preprocessor directives.
 */
static inline void ccp_write_io(void *addr, uint8_t value)
{
	protected_write_io(addr, CCP_IOREG_gc, value);
     1dc:	47 e0       	ldi	r20, 0x07	; 7
     1de:	68 ed       	ldi	r22, 0xD8	; 216
     1e0:	8c e7       	ldi	r24, 0x7C	; 124
     1e2:	90 e0       	ldi	r25, 0x00	; 0
     1e4:	0e 94 cb 01 	call	0x396	; 0x396 <protected_write_io>
     1e8:	41 e0       	ldi	r20, 0x01	; 1
     1ea:	68 ed       	ldi	r22, 0xD8	; 216
     1ec:	81 e6       	ldi	r24, 0x61	; 97
     1ee:	90 e0       	ldi	r25, 0x00	; 0
     1f0:	0e 94 cb 01 	call	0x396	; 0x396 <protected_write_io>
	//		 | 0 << CLKCTRL_CLKOUT_bp /* System clock out: disabled */);

	// ccp_write_io((void*)&(CLKCTRL.MCLKLOCK),0 << CLKCTRL_LOCKEN_bp /* lock enable: disabled */);

	return 0;
}
     1f4:	80 e0       	ldi	r24, 0x00	; 0
     1f6:	08 95       	ret

000001f8 <CPUINT_init>:

	// CPUINT.LVL0PRI = 0x0 << CPUINT_LVL0PRI_gp; /* Interrupt Level Priority: 0x0 */

	// CPUINT.LVL1VEC = 0x0 << CPUINT_LVL1VEC_gp; /* Interrupt Vector with High Priority: 0x0 */

	ENABLE_INTERRUPTS();
     1f8:	78 94       	sei

	return 0;
}
     1fa:	80 e0       	ldi	r24, 0x00	; 0
     1fc:	08 95       	ret

000001fe <DAC_0_init>:
int8_t DAC_0_init()
{

	// DAC0.DATA = 0x0; /* DATA Register: 0x0 */

	DAC0.CTRLA = 1 << DAC_ENABLE_bp      /* DAC Enable: enabled */
     1fe:	81 e4       	ldi	r24, 0x41	; 65
     200:	80 93 a0 06 	sts	0x06A0, r24	; 0x8006a0 <__TEXT_REGION_LENGTH__+0x7006a0>
	             | 1 << DAC_OUTEN_bp     /* Output Buffer Enable: enabled */
	             | 0 << DAC_RUNSTDBY_bp; /* Run in Standby Mode: disabled */

	return 0;
}
     204:	80 e0       	ldi	r24, 0x00	; 0
     206:	08 95       	ret

00000208 <DAC_0_uninit>:
int8_t DAC_0_uninit()
{

	// DAC0.DATA = 0x0; /* DATA Register: 0x0 */

	DAC0.CTRLA = 1 << DAC_ENABLE_bp      /* DAC Enable: enabled */
     208:	81 e0       	ldi	r24, 0x01	; 1
     20a:	80 93 a0 06 	sts	0x06A0, r24	; 0x8006a0 <__TEXT_REGION_LENGTH__+0x7006a0>
	| 0 << DAC_OUTEN_bp     /* Output Buffer Enable: disabled */
	| 0 << DAC_RUNSTDBY_bp; /* Run in Standby Mode: disabled */

	return 0;
}
     20e:	80 e0       	ldi	r24, 0x00	; 0
     210:	08 95       	ret

00000212 <DAC_0_enable>:
 *
 * \return Nothing
 */
void DAC_0_enable()
{
	DAC0.CTRLA |= DAC_ENABLE_bm;
     212:	e0 ea       	ldi	r30, 0xA0	; 160
     214:	f6 e0       	ldi	r31, 0x06	; 6
     216:	80 81       	ld	r24, Z
     218:	81 60       	ori	r24, 0x01	; 1
     21a:	80 83       	st	Z, r24
     21c:	08 95       	ret

0000021e <DAC_0_disable>:
 *
 * \return Nothing
 */
void DAC_0_disable()
{
	DAC0.CTRLA &= ~DAC_ENABLE_bm;
     21e:	e0 ea       	ldi	r30, 0xA0	; 160
     220:	f6 e0       	ldi	r31, 0x06	; 6
     222:	80 81       	ld	r24, Z
     224:	8e 7f       	andi	r24, 0xFE	; 254
     226:	80 83       	st	Z, r24
     228:	08 95       	ret

0000022a <DAC_0_set_output>:
 *
 * \return Nothing
 */
void DAC_0_set_output(dac_resolution_t value)
{
	DAC0.DATA = value;
     22a:	80 93 a1 06 	sts	0x06A1, r24	; 0x8006a1 <__TEXT_REGION_LENGTH__+0x7006a1>
     22e:	08 95       	ret

00000230 <mcu_init>:
#ifdef __cplusplus
extern "C" {
#endif

void mcu_init(void)
{
     230:	e0 e1       	ldi	r30, 0x10	; 16
     232:	f4 e0       	ldi	r31, 0x04	; 4
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     234:	80 81       	ld	r24, Z
     236:	88 60       	ori	r24, 0x08	; 8
     238:	81 93       	st	Z+, r24
	 * disables all peripherals to save power. Driver shall enable
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
     23a:	e8 31       	cpi	r30, 0x18	; 24
     23c:	84 e0       	ldi	r24, 0x04	; 4
     23e:	f8 07       	cpc	r31, r24
     240:	c9 f7       	brne	.-14     	; 0x234 <mcu_init+0x4>
     242:	e0 e3       	ldi	r30, 0x30	; 48
     244:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     246:	80 81       	ld	r24, Z
     248:	88 60       	ori	r24, 0x08	; 8
     24a:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     24c:	e8 33       	cpi	r30, 0x38	; 56
     24e:	84 e0       	ldi	r24, 0x04	; 4
     250:	f8 07       	cpc	r31, r24
     252:	c9 f7       	brne	.-14     	; 0x246 <mcu_init+0x16>
     254:	e0 e5       	ldi	r30, 0x50	; 80
     256:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     258:	80 81       	ld	r24, Z
     25a:	88 60       	ori	r24, 0x08	; 8
     25c:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     25e:	e8 35       	cpi	r30, 0x58	; 88
     260:	84 e0       	ldi	r24, 0x04	; 4
     262:	f8 07       	cpc	r31, r24
     264:	c9 f7       	brne	.-14     	; 0x258 <mcu_init+0x28>
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}
}
     266:	08 95       	ret

00000268 <ADC_0_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     268:	e5 e1       	ldi	r30, 0x15	; 21
     26a:	f4 e0       	ldi	r31, 0x04	; 4
     26c:	80 81       	ld	r24, Z
     26e:	88 7f       	andi	r24, 0xF8	; 248
     270:	84 60       	ori	r24, 0x04	; 4
     272:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     274:	80 81       	ld	r24, Z
     276:	87 7f       	andi	r24, 0xF7	; 247
     278:	80 83       	st	Z, r24
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     27a:	e7 e1       	ldi	r30, 0x17	; 23
     27c:	f4 e0       	ldi	r31, 0x04	; 4
     27e:	80 81       	ld	r24, Z
     280:	88 7f       	andi	r24, 0xF8	; 248
     282:	84 60       	ori	r24, 0x04	; 4
     284:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     286:	80 81       	ld	r24, Z
     288:	87 7f       	andi	r24, 0xF7	; 247
     28a:	80 83       	st	Z, r24
 */
static inline void PORTC_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     28c:	e0 e5       	ldi	r30, 0x50	; 80
     28e:	f4 e0       	ldi	r31, 0x04	; 4
     290:	80 81       	ld	r24, Z
     292:	88 7f       	andi	r24, 0xF8	; 248
     294:	84 60       	ori	r24, 0x04	; 4
     296:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     298:	80 81       	ld	r24, Z
     29a:	87 7f       	andi	r24, 0xF7	; 247
     29c:	80 83       	st	Z, r24
 */
static inline void PORTC_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     29e:	e1 e5       	ldi	r30, 0x51	; 81
     2a0:	f4 e0       	ldi	r31, 0x04	; 4
     2a2:	80 81       	ld	r24, Z
     2a4:	88 7f       	andi	r24, 0xF8	; 248
     2a6:	84 60       	ori	r24, 0x04	; 4
     2a8:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2aa:	80 81       	ld	r24, Z
     2ac:	87 7f       	andi	r24, 0xF7	; 247
     2ae:	80 83       	st	Z, r24
 */
static inline void PORTC_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     2b0:	e3 e5       	ldi	r30, 0x53	; 83
     2b2:	f4 e0       	ldi	r31, 0x04	; 4
     2b4:	80 81       	ld	r24, Z
     2b6:	88 7f       	andi	r24, 0xF8	; 248
     2b8:	84 60       	ori	r24, 0x04	; 4
     2ba:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2bc:	80 81       	ld	r24, Z
     2be:	87 7f       	andi	r24, 0xF7	; 247
     2c0:	80 83       	st	Z, r24
	// Disable digital input buffer
	DEN4_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	DEN4_PIN_set_pull_mode(PORT_PULL_OFF);

	ADC_0_init();
     2c2:	0e 94 bd 00 	call	0x17a	; 0x17a <ADC_0_init>
     2c6:	08 95       	ret

000002c8 <USART_0_initialization>:
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     2c8:	23 98       	cbi	0x04, 3	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2ca:	e3 e3       	ldi	r30, 0x33	; 51
     2cc:	f4 e0       	ldi	r31, 0x04	; 4
     2ce:	80 81       	ld	r24, Z
     2d0:	87 7f       	andi	r24, 0xF7	; 247
     2d2:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     2d4:	22 9a       	sbi	0x04, 2	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     2d6:	2a 98       	cbi	0x05, 2	; 5
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	USART_0_init();
     2d8:	0e 94 05 02 	call	0x40a	; 0x40a <USART_0_init>
     2dc:	08 95       	ret

000002de <TIMER_0_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     2de:	25 9a       	sbi	0x04, 5	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     2e0:	2d 98       	cbi	0x05, 5	; 5
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLC |= PORTMUX_TCA02_bm;
     2e2:	e0 e0       	ldi	r30, 0x00	; 0
     2e4:	f2 e0       	ldi	r31, 0x02	; 2
     2e6:	82 81       	ldd	r24, Z+2	; 0x02
     2e8:	84 60       	ori	r24, 0x04	; 4
     2ea:	82 83       	std	Z+2, r24	; 0x02

	TIMER_0_init();
     2ec:	0e 94 f5 01 	call	0x3ea	; 0x3ea <TIMER_0_init>
     2f0:	08 95       	ret

000002f2 <DIGITAL_GLUE_LOGIC_0_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     2f2:	24 9a       	sbi	0x04, 4	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     2f4:	2c 98       	cbi	0x05, 4	; 5
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLA |= PORTMUX_LUT0_bm;
     2f6:	e0 e0       	ldi	r30, 0x00	; 0
     2f8:	f2 e0       	ldi	r31, 0x02	; 2
     2fa:	80 81       	ld	r24, Z
     2fc:	80 61       	ori	r24, 0x10	; 16
     2fe:	80 83       	st	Z, r24

	DIGITAL_GLUE_LOGIC_0_init();
     300:	0e 94 dd 00 	call	0x1ba	; 0x1ba <DIGITAL_GLUE_LOGIC_0_init>
     304:	08 95       	ret

00000306 <SPI_0_initialization>:
 */
static inline void PORTA_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
     306:	02 98       	cbi	0x00, 2	; 0
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     308:	e2 e1       	ldi	r30, 0x12	; 18
     30a:	f4 e0       	ldi	r31, 0x04	; 4
     30c:	80 81       	ld	r24, Z
     30e:	87 7f       	andi	r24, 0xF7	; 247
     310:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     312:	01 9a       	sbi	0x00, 1	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     314:	09 98       	cbi	0x01, 1	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     316:	03 9a       	sbi	0x00, 3	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     318:	0b 98       	cbi	0x01, 3	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     31a:	04 9a       	sbi	0x00, 4	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     31c:	0c 98       	cbi	0x01, 4	; 1
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	SPI_0_init();
     31e:	0e 94 ed 01 	call	0x3da	; 0x3da <SPI_0_init>
     322:	08 95       	ret

00000324 <DAC_0_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     324:	e6 e1       	ldi	r30, 0x16	; 22
     326:	f4 e0       	ldi	r31, 0x04	; 4
     328:	80 81       	ld	r24, Z
     32a:	88 7f       	andi	r24, 0xF8	; 248
     32c:	84 60       	ori	r24, 0x04	; 4
     32e:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     330:	80 81       	ld	r24, Z
     332:	87 7f       	andi	r24, 0xF7	; 247
     334:	80 83       	st	Z, r24
	// Disable digital input buffer
	AXON_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	AXON_PIN_set_pull_mode(PORT_PULL_OFF);

	DAC_0_init();
     336:	0e 94 ff 00 	call	0x1fe	; 0x1fe <DAC_0_init>
     33a:	08 95       	ret

0000033c <system_init>:
/**
 * \brief System initialization
 */
void system_init()
{
	mcu_init();
     33c:	0e 94 18 01 	call	0x230	; 0x230 <mcu_init>
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     340:	26 98       	cbi	0x04, 6	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     342:	e6 e3       	ldi	r30, 0x36	; 54
     344:	f4 e0       	ldi	r31, 0x04	; 4
     346:	80 81       	ld	r24, Z
     348:	87 7f       	andi	r24, 0xF7	; 247
     34a:	80 83       	st	Z, r24
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     34c:	27 98       	cbi	0x04, 7	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     34e:	e7 e3       	ldi	r30, 0x37	; 55
     350:	f4 e0       	ldi	r31, 0x04	; 4
     352:	80 81       	ld	r24, Z
     354:	87 7f       	andi	r24, 0xF7	; 247
     356:	80 83       	st	Z, r24
 */
static inline void PORTC_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
     358:	42 98       	cbi	0x08, 2	; 8
static inline void PORTC_set_pin_pull_mode(const uint8_t pin, const enum port_pull_mode pull_mode)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
     35a:	e2 e5       	ldi	r30, 0x52	; 82
     35c:	f4 e0       	ldi	r31, 0x04	; 4
     35e:	80 81       	ld	r24, Z
     360:	88 60       	ori	r24, 0x08	; 8
     362:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTC.DIR |= (1 << pin);
     364:	45 9a       	sbi	0x08, 5	; 8
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     366:	4d 9a       	sbi	0x09, 5	; 9
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    true);

	CLKCTRL_init();
     368:	0e 94 ee 00 	call	0x1dc	; 0x1dc <CLKCTRL_init>

	RTC_0_init();
     36c:	0e 94 cf 01 	call	0x39e	; 0x39e <RTC_0_init>

	ADC_0_initialization();
     370:	0e 94 34 01 	call	0x268	; 0x268 <ADC_0_initialization>

	USART_0_initialization();
     374:	0e 94 64 01 	call	0x2c8	; 0x2c8 <USART_0_initialization>

	TIMER_0_initialization();
     378:	0e 94 6f 01 	call	0x2de	; 0x2de <TIMER_0_initialization>

	DIGITAL_GLUE_LOGIC_0_initialization();
     37c:	0e 94 79 01 	call	0x2f2	; 0x2f2 <DIGITAL_GLUE_LOGIC_0_initialization>

	SPI_0_initialization();
     380:	0e 94 83 01 	call	0x306	; 0x306 <SPI_0_initialization>

	DAC_0_initialization();
     384:	0e 94 92 01 	call	0x324	; 0x324 <DAC_0_initialization>

	CPUINT_init();
     388:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <CPUINT_init>

	SLPCTRL_init();
     38c:	0e 94 eb 01 	call	0x3d6	; 0x3d6 <SLPCTRL_init>

	BOD_init();
     390:	0e 94 db 00 	call	0x1b6	; 0x1b6 <BOD_init>
     394:	08 95       	ret

00000396 <protected_write_io>:
#if defined(__GNUC__)
  
#ifdef RAMPZ
	out     _SFR_IO_ADDR(RAMPZ), r1         // Clear bits 23:16 of Z
#endif
	movw    r30, r24                // Load addr into Z
     396:	fc 01       	movw	r30, r24
	out     CCP, r22                // Start CCP handshake
     398:	64 bf       	out	0x34, r22	; 52
	st      Z, r20                  // Write value to I/O register
     39a:	40 83       	st	Z, r20
	ret                             // Return to caller
     39c:	08 95       	ret

0000039e <RTC_0_init>:
 * \return Initialization status.
 */
int8_t RTC_0_init()
{

	while (RTC.STATUS > 0) { /* Wait for all register to be synchronized */
     39e:	e0 e4       	ldi	r30, 0x40	; 64
     3a0:	f1 e0       	ldi	r31, 0x01	; 1
     3a2:	81 81       	ldd	r24, Z+1	; 0x01
     3a4:	81 11       	cpse	r24, r1
     3a6:	fd cf       	rjmp	.-6      	; 0x3a2 <RTC_0_init+0x4>
	}

	// RTC.CMP = 0x0; /* Compare: 0x0 */

	RTC.CNT = 0x20; /* Counter: 0x20 */
     3a8:	e0 e4       	ldi	r30, 0x40	; 64
     3aa:	f1 e0       	ldi	r31, 0x01	; 1
     3ac:	80 e2       	ldi	r24, 0x20	; 32
     3ae:	90 e0       	ldi	r25, 0x00	; 0
     3b0:	80 87       	std	Z+8, r24	; 0x08
     3b2:	91 87       	std	Z+9, r25	; 0x09

	RTC.CTRLA = RTC_PRESCALER_DIV1_gc   /* 1 */
     3b4:	81 e8       	ldi	r24, 0x81	; 129
     3b6:	80 83       	st	Z, r24
	            | 1 << RTC_RTCEN_bp     /* Enable: enabled */
	            | 1 << RTC_RUNSTDBY_bp; /* Run In Standby: enabled */

	RTC.PER = 0x20 / TIMESCALE; /* Period: 0x20 */
     3b8:	80 e4       	ldi	r24, 0x40	; 64
     3ba:	90 e0       	ldi	r25, 0x00	; 0
     3bc:	82 87       	std	Z+10, r24	; 0x0a
     3be:	93 87       	std	Z+11, r25	; 0x0b

	// RTC.CLKSEL = RTC_CLKSEL_INT32K_gc; /* 32KHz Internal Ultra Low Power Oscillator (OSCULP32K) */

	RTC.DBGCTRL = 1 << RTC_DBGRUN_bp; /* Run in debug: enabled */
     3c0:	81 e0       	ldi	r24, 0x01	; 1
     3c2:	85 83       	std	Z+5, r24	; 0x05

	RTC.INTCTRL = 0 << RTC_CMP_bp    /* Compare Match Interrupt enable: disabled */
     3c4:	82 83       	std	Z+2, r24	; 0x02
	              | 1 << RTC_OVF_bp; /* Overflow Interrupt enable: enabled */

	while (RTC.PITSTATUS > 0) { /* Wait for all register to be synchronized */
     3c6:	81 89       	ldd	r24, Z+17	; 0x11
     3c8:	81 11       	cpse	r24, r1
     3ca:	fd cf       	rjmp	.-6      	; 0x3c6 <RTC_0_init+0x28>
	}

	RTC.PITCTRLA = RTC_PERIOD_OFF_gc    /* Off */
     3cc:	81 e0       	ldi	r24, 0x01	; 1
     3ce:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <__TEXT_REGION_LENGTH__+0x700150>
	// RTC.PITDBGCTRL = 0 << RTC_DBGRUN_bp; /* Run in debug: disabled */

	// RTC.PITINTCTRL = 0 << RTC_PI_bp; /* Periodic Interrupt: disabled */

	return 0;
}
     3d2:	80 e0       	ldi	r24, 0x00	; 0
     3d4:	08 95       	ret

000003d6 <SLPCTRL_init>:

	// SLPCTRL.CTRLA = 0 << SLPCTRL_SEN_bp /* Sleep enable: disabled */
	//		 | SLPCTRL_SMODE_IDLE_gc; /* Idle mode */

	return 0;
}
     3d6:	80 e0       	ldi	r24, 0x00	; 0
     3d8:	08 95       	ret

000003da <SPI_0_init>:
 * \return Initialization status
 */
int8_t SPI_0_init()
{

	SPI0.CTRLA = 0 << SPI_CLK2X_bp     /* Enable Double Speed: disabled */
     3da:	e0 e2       	ldi	r30, 0x20	; 32
     3dc:	f8 e0       	ldi	r31, 0x08	; 8
     3de:	83 e2       	ldi	r24, 0x23	; 35
     3e0:	80 83       	st	Z, r24
	             | 0 << SPI_DORD_bp    /* Data Order Setting: disabled */
	             | 1 << SPI_ENABLE_bp  /* Enable Module: enabled */
	             | 1 << SPI_MASTER_bp  /* SPI module in master mode */
	             | SPI_PRESC_DIV16_gc; /* System Clock / 16 */

	SPI0.CTRLB = 0 << SPI_BUFEN_bp   /* Buffer Mode Enable: disabled */
     3e2:	84 e0       	ldi	r24, 0x04	; 4
     3e4:	81 83       	std	Z+1, r24	; 0x01
	//		 | 0 << SPI_RXCIE_bp /* Receive Complete Interrupt Enable: disabled */
	//		 | 0 << SPI_SSIE_bp /* Slave Select Trigger Interrupt Enable: disabled */
	//		 | 0 << SPI_TXCIE_bp; /* Transfer Complete Interrupt Enable: disabled */

	return 0;
}
     3e6:	80 e0       	ldi	r24, 0x00	; 0
     3e8:	08 95       	ret

000003ea <TIMER_0_init>:

	// TCA0.SINGLE.CMP0 = 0x0; /* Compare Register 0: 0x0 */

	// TCA0.SINGLE.CMP1 = 0x0; /* Compare Register 1: 0x0 */

	TCA0.SINGLE.CMP2 = 0x4; /* Compare Register 2: 0x4 */
     3ea:	e0 e0       	ldi	r30, 0x00	; 0
     3ec:	fa e0       	ldi	r31, 0x0A	; 10
     3ee:	84 e0       	ldi	r24, 0x04	; 4
     3f0:	90 e0       	ldi	r25, 0x00	; 0
     3f2:	84 a7       	std	Z+44, r24	; 0x2c
     3f4:	95 a7       	std	Z+45, r25	; 0x2d

	// TCA0.SINGLE.CNT = 0x0; /* Count: 0x0 */

	TCA0.SINGLE.CTRLB = 0 << TCA_SINGLE_ALUPD_bp            /* Auto Lock Update: disabled */
     3f6:	83 e4       	ldi	r24, 0x43	; 67
     3f8:	81 83       	std	Z+1, r24	; 0x01
	                    | 0 << TCA_SINGLE_CMP0EN_bp         /* Compare 0 Enable: disabled */
	                    | 0 << TCA_SINGLE_CMP1EN_bp         /* Compare 1 Enable: disabled */
	                    | 1 << TCA_SINGLE_CMP2EN_bp         /* Compare 2 Enable: enabled */
	                    | TCA_SINGLE_WGMODE_SINGLESLOPE_gc; /*  */

	TCA0.SINGLE.CTRLC = 0 << TCA_SINGLE_CMP0OV_bp    /* Compare 0 Waveform Output Value: disabled */
     3fa:	84 e0       	ldi	r24, 0x04	; 4
     3fc:	82 83       	std	Z+2, r24	; 0x02
	// TCA0.SINGLE.INTCTRL = 0 << TCA_SINGLE_CMP0_bp /* Compare 0 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP1_bp /* Compare 1 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP2_bp /* Compare 2 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_OVF_bp; /* Overflow Interrupt: disabled */

	TCA0.SINGLE.PER = 0x7; /* Period: 0x7 */
     3fe:	87 e0       	ldi	r24, 0x07	; 7
     400:	90 e0       	ldi	r25, 0x00	; 0
     402:	86 a3       	std	Z+38, r24	; 0x26
     404:	97 a3       	std	Z+39, r25	; 0x27

	// TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV1_gc /* System Clock */
	//		 | 0 << TCA_SINGLE_ENABLE_bp; /* Module Enable: disabled */

	return 0;
}
     406:	80 e0       	ldi	r24, 0x00	; 0
     408:	08 95       	ret

0000040a <USART_0_init>:
uint8_t USART_0_read()
{
	while (!(USART0.STATUS & USART_RXCIF_bm))
		;
	return USART0.RXDATAL;
}
     40a:	e0 e0       	ldi	r30, 0x00	; 0
     40c:	f8 e0       	ldi	r31, 0x08	; 8
     40e:	8b e5       	ldi	r24, 0x5B	; 91
     410:	91 e0       	ldi	r25, 0x01	; 1
     412:	80 87       	std	Z+8, r24	; 0x08
     414:	91 87       	std	Z+9, r25	; 0x09
     416:	80 ec       	ldi	r24, 0xC0	; 192
     418:	86 83       	std	Z+6, r24	; 0x06
     41a:	80 e0       	ldi	r24, 0x00	; 0
     41c:	98 e3       	ldi	r25, 0x38	; 56
     41e:	80 93 66 38 	sts	0x3866, r24	; 0x803866 <__iob+0x2>
     422:	90 93 67 38 	sts	0x3867, r25	; 0x803867 <__iob+0x3>
     426:	80 e0       	ldi	r24, 0x00	; 0
     428:	08 95       	ret

0000042a <USART_0_write>:
 *
 * \return Nothing
 */
void USART_0_write(const uint8_t data)
{
	while (!(USART0.STATUS & USART_DREIF_bm))
     42a:	e0 e0       	ldi	r30, 0x00	; 0
     42c:	f8 e0       	ldi	r31, 0x08	; 8
     42e:	94 81       	ldd	r25, Z+4	; 0x04
     430:	95 ff       	sbrs	r25, 5
     432:	fd cf       	rjmp	.-6      	; 0x42e <USART_0_write+0x4>
		;
	USART0.TXDATAL = data;
     434:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <__TEXT_REGION_LENGTH__+0x700802>
     438:	08 95       	ret

0000043a <USART_0_printCHAR>:

#if defined(__GNUC__)

int USART_0_printCHAR(char character, FILE *stream)
{
	USART_0_write(character);
     43a:	0e 94 15 02 	call	0x42a	; 0x42a <USART_0_write>
	return 0;
}
     43e:	80 e0       	ldi	r24, 0x00	; 0
     440:	90 e0       	ldi	r25, 0x00	; 0
     442:	08 95       	ret

00000444 <tinyAxon_add_pulse>:
{
	// We want to check each slot in the pulse_queue, and
	// if we find an empty slot (0), we add a pulse.
	for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
	{
		if(pulse_queue[i] == 0){
     444:	20 91 17 38 	lds	r18, 0x3817	; 0x803817 <pulse_queue>
     448:	30 91 18 38 	lds	r19, 0x3818	; 0x803818 <pulse_queue+0x1>
     44c:	23 2b       	or	r18, r19
     44e:	51 f0       	breq	.+20     	; 0x464 <tinyAxon_add_pulse+0x20>
     450:	e9 e1       	ldi	r30, 0x19	; 25
     452:	f8 e3       	ldi	r31, 0x38	; 56
     454:	21 e0       	ldi	r18, 0x01	; 1
     456:	30 e0       	ldi	r19, 0x00	; 0
     458:	b9 01       	movw	r22, r18
     45a:	41 91       	ld	r20, Z+
     45c:	51 91       	ld	r21, Z+
     45e:	45 2b       	or	r20, r21
     460:	81 f4       	brne	.+32     	; 0x482 <tinyAxon_add_pulse+0x3e>
     462:	02 c0       	rjmp	.+4      	; 0x468 <tinyAxon_add_pulse+0x24>
     464:	60 e0       	ldi	r22, 0x00	; 0
     466:	70 e0       	ldi	r23, 0x00	; 0
			pulse_queue[i] = new_pulse;
     468:	66 0f       	add	r22, r22
     46a:	77 1f       	adc	r23, r23
     46c:	fb 01       	movw	r30, r22
     46e:	e9 5e       	subi	r30, 0xE9	; 233
     470:	f7 4c       	sbci	r31, 0xC7	; 199
     472:	80 83       	st	Z, r24
     474:	91 83       	std	Z+1, r25	; 0x01
			pulses_in_queue++;
     476:	80 91 2b 38 	lds	r24, 0x382B	; 0x80382b <pulses_in_queue>
     47a:	8f 5f       	subi	r24, 0xFF	; 255
     47c:	80 93 2b 38 	sts	0x382B, r24	; 0x80382b <pulses_in_queue>
			// We return so we only ever add one
			break;
     480:	08 95       	ret
     482:	2f 5f       	subi	r18, 0xFF	; 255
     484:	3f 4f       	sbci	r19, 0xFF	; 255
*/
static void tinyAxon_add_pulse(uint16_t new_pulse)
{
	// We want to check each slot in the pulse_queue, and
	// if we find an empty slot (0), we add a pulse.
	for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
     486:	2a 30       	cpi	r18, 0x0A	; 10
     488:	31 05       	cpc	r19, r1
     48a:	31 f7       	brne	.-52     	; 0x458 <tinyAxon_add_pulse+0x14>
     48c:	08 95       	ret

0000048e <find_newest_pulse>:
uint8_t find_newest_pulse() {
	uint16_t max;
	uint8_t current_index = 0;
	uint8_t return_index = 0;
	
	max = pulse_queue[current_index];
     48e:	40 91 17 38 	lds	r20, 0x3817	; 0x803817 <pulse_queue>
     492:	50 91 18 38 	lds	r21, 0x3818	; 0x803818 <pulse_queue+0x1>
     496:	e9 e1       	ldi	r30, 0x19	; 25
     498:	f8 e3       	ldi	r31, 0x38	; 56
	
// This function will be used with pulse_queue to find the newest pulse
uint8_t find_newest_pulse() {
	uint16_t max;
	uint8_t current_index = 0;
	uint8_t return_index = 0;
     49a:	80 e0       	ldi	r24, 0x00	; 0
	
	max = pulse_queue[current_index];
	
	for (current_index = 1; current_index < MAX_NUMBER_OF_PULSES; current_index++) {
     49c:	91 e0       	ldi	r25, 0x01	; 1
		if (pulse_queue[current_index] > max) {
     49e:	21 91       	ld	r18, Z+
     4a0:	31 91       	ld	r19, Z+
     4a2:	42 17       	cp	r20, r18
     4a4:	53 07       	cpc	r21, r19
     4a6:	10 f4       	brcc	.+4      	; 0x4ac <find_newest_pulse+0x1e>
     4a8:	89 2f       	mov	r24, r25
			return_index = current_index;
			max = pulse_queue[current_index];
     4aa:	a9 01       	movw	r20, r18
	uint8_t current_index = 0;
	uint8_t return_index = 0;
	
	max = pulse_queue[current_index];
	
	for (current_index = 1; current_index < MAX_NUMBER_OF_PULSES; current_index++) {
     4ac:	9f 5f       	subi	r25, 0xFF	; 255
     4ae:	9a 30       	cpi	r25, 0x0A	; 10
     4b0:	b1 f7       	brne	.-20     	; 0x49e <find_newest_pulse+0x10>
			return_index = current_index;
			max = pulse_queue[current_index];
		}
	}
	return return_index;
}
     4b2:	08 95       	ret

000004b4 <tinyAxon_stop_sending_pulse>:
	tinyLED_set_color_mode(OUT_LED, WHITE, FLASH_ONCE);
}

void tinyAxon_stop_sending_pulse()
{
	DAC_0_set_output(NO_SIGNAL_OUTPUT);
     4b4:	80 e0       	ldi	r24, 0x00	; 0
     4b6:	90 e0       	ldi	r25, 0x00	; 0
     4b8:	0e 94 15 01 	call	0x22a	; 0x22a <DAC_0_set_output>
	axonOutputValue=NO_SIGNAL_OUTPUT;
     4bc:	10 92 16 38 	sts	0x3816, r1	; 0x803816 <__data_end>
     4c0:	08 95       	ret

000004c2 <tinyAxon_remove_pulse>:

/*
If the potential is very low, we want to try to remove a pulse.
*/
bool tinyAxon_remove_pulse(void)
{
     4c2:	cf 93       	push	r28
	// We want to return a bool indicating whether or not a pulse actually was removed.
	if(pulses_in_queue == 0){
     4c4:	c0 91 2b 38 	lds	r28, 0x382B	; 0x80382b <pulses_in_queue>
     4c8:	cc 23       	and	r28, r28
     4ca:	c9 f0       	breq	.+50     	; 0x4fe <tinyAxon_remove_pulse+0x3c>
		//There was no pulse to remove.
		return false;
	}
	else{
		// If we are to remove a pulse, we want to remove the one that will fire last.
		uint8_t pulse_index = find_newest_pulse();
     4cc:	0e 94 47 02 	call	0x48e	; 0x48e <find_newest_pulse>
		uint16_t newest_pulse = pulse_queue[pulse_index];
     4d0:	90 e0       	ldi	r25, 0x00	; 0
     4d2:	fc 01       	movw	r30, r24
     4d4:	ee 0f       	add	r30, r30
     4d6:	ff 1f       	adc	r31, r31
     4d8:	e9 5e       	subi	r30, 0xE9	; 233
     4da:	f7 4c       	sbci	r31, 0xC7	; 199
	
		// Now we want to check if the pulse is too far away to be affected by the low potential, or close enough that we decide to remove it.
		// (When we say that the pulse is too far away, it refers to the biological process of how the potential spreads from Dendrites to axon).
		if(newest_pulse > PULSE_NO_RETURN_TIME){
     4dc:	20 81       	ld	r18, Z
     4de:	31 81       	ldd	r19, Z+1	; 0x01
     4e0:	2d 33       	cpi	r18, 0x3D	; 61
     4e2:	31 05       	cpc	r19, r1
     4e4:	70 f0       	brcs	.+28     	; 0x502 <tinyAxon_remove_pulse+0x40>
			// We decided to remove the pulse
			pulse_queue[pulse_index] = 0;
     4e6:	88 0f       	add	r24, r24
     4e8:	99 1f       	adc	r25, r25
     4ea:	fc 01       	movw	r30, r24
     4ec:	e9 5e       	subi	r30, 0xE9	; 233
     4ee:	f7 4c       	sbci	r31, 0xC7	; 199
     4f0:	10 82       	st	Z, r1
     4f2:	11 82       	std	Z+1, r1	; 0x01
			pulses_in_queue--;
     4f4:	c1 50       	subi	r28, 0x01	; 1
     4f6:	c0 93 2b 38 	sts	0x382B, r28	; 0x80382b <pulses_in_queue>
			return true;
     4fa:	81 e0       	ldi	r24, 0x01	; 1
     4fc:	03 c0       	rjmp	.+6      	; 0x504 <tinyAxon_remove_pulse+0x42>
bool tinyAxon_remove_pulse(void)
{
	// We want to return a bool indicating whether or not a pulse actually was removed.
	if(pulses_in_queue == 0){
		//There was no pulse to remove.
		return false;
     4fe:	80 e0       	ldi	r24, 0x00	; 0
     500:	01 c0       	rjmp	.+2      	; 0x504 <tinyAxon_remove_pulse+0x42>
			pulses_in_queue--;
			return true;
		}
		// Here we have found that there is a pulse queued, but it is old enough to let pass anyway, so now we need to put it back into the queue.
		else{
			return false;
     502:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     504:	cf 91       	pop	r28
     506:	08 95       	ret

00000508 <tinyAxon_update_potential>:
/*
Decides whether or not the axon should fire
If the axon does fire, the potential is reduced
*/
double tinyAxon_update_potential(double potential)
{	
     508:	cf 92       	push	r12
     50a:	df 92       	push	r13
     50c:	ef 92       	push	r14
     50e:	ff 92       	push	r15
     510:	6b 01       	movw	r12, r22
     512:	7c 01       	movw	r14, r24
	//While the neuron has enough potential to fire, we want to fire more
	while (potential >= THRESHOLD_POTENTIAL)
     514:	20 e0       	ldi	r18, 0x00	; 0
     516:	30 e0       	ldi	r19, 0x00	; 0
     518:	48 ec       	ldi	r20, 0xC8	; 200
     51a:	51 e4       	ldi	r21, 0x41	; 65
     51c:	0e 94 4d 0a 	call	0x149a	; 0x149a <__gesf2>
     520:	88 23       	and	r24, r24
     522:	bc f1       	brlt	.+110    	; 0x592 <tinyAxon_update_potential+0x8a>
	{
		// We have to check if there are already queued pulses, so that the frequency never exceeds FIRE_DELAY
		if(pulses_in_queue>0){
     524:	80 91 2b 38 	lds	r24, 0x382B	; 0x80382b <pulses_in_queue>
     528:	88 23       	and	r24, r24
     52a:	b1 f0       	breq	.+44     	; 0x558 <tinyAxon_update_potential+0x50>
			uint16_t newest_pulse = pulse_queue[find_newest_pulse()];
     52c:	0e 94 47 02 	call	0x48e	; 0x48e <find_newest_pulse>
     530:	e8 2f       	mov	r30, r24
     532:	f0 e0       	ldi	r31, 0x00	; 0
     534:	ee 0f       	add	r30, r30
     536:	ff 1f       	adc	r31, r31
     538:	e9 5e       	subi	r30, 0xE9	; 233
     53a:	f7 4c       	sbci	r31, 0xC7	; 199
			
			// There is at least one pulse in the queue, and it is so close, that we need to offset the new pulse, so that we keep at least
			// one FIRE_DELAY between each pulse
			if(newest_pulse + FIRE_DELAY > TRAVLE_DELAY){
     53c:	80 81       	ld	r24, Z
     53e:	91 81       	ldd	r25, Z+1	; 0x01
     540:	0a 96       	adiw	r24, 0x0a	; 10
     542:	85 36       	cpi	r24, 0x65	; 101
     544:	91 05       	cpc	r25, r1
     546:	18 f0       	brcs	.+6      	; 0x54e <tinyAxon_update_potential+0x46>
				tinyAxon_add_pulse(newest_pulse + FIRE_DELAY);
     548:	0e 94 22 02 	call	0x444	; 0x444 <tinyAxon_add_pulse>
     54c:	09 c0       	rjmp	.+18     	; 0x560 <tinyAxon_update_potential+0x58>
			}
			// There is at least one pulse in the queue, but it's far enough away to ignore
			else{
				tinyAxon_add_pulse(TRAVLE_DELAY);
     54e:	84 e6       	ldi	r24, 0x64	; 100
     550:	90 e0       	ldi	r25, 0x00	; 0
     552:	0e 94 22 02 	call	0x444	; 0x444 <tinyAxon_add_pulse>
     556:	04 c0       	rjmp	.+8      	; 0x560 <tinyAxon_update_potential+0x58>
			}
		}
		// There are no pulses in the queue, so we add a pulse as normal
		else{
			tinyAxon_add_pulse(TRAVLE_DELAY);		
     558:	84 e6       	ldi	r24, 0x64	; 100
     55a:	90 e0       	ldi	r25, 0x00	; 0
     55c:	0e 94 22 02 	call	0x444	; 0x444 <tinyAxon_add_pulse>
		}
		
		potential += POSTFIRE_POTENTIAL_REACTION; // This is usually defined as a negative value, don't be confused by the +=
     560:	20 e0       	ldi	r18, 0x00	; 0
     562:	30 e0       	ldi	r19, 0x00	; 0
     564:	48 ec       	ldi	r20, 0xC8	; 200
     566:	51 e4       	ldi	r21, 0x41	; 65
     568:	c7 01       	movw	r24, r14
     56a:	b6 01       	movw	r22, r12
     56c:	0e 94 08 08 	call	0x1010	; 0x1010 <__subsf3>
     570:	6b 01       	movw	r12, r22
     572:	7c 01       	movw	r14, r24
		
		tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
     574:	44 e0       	ldi	r20, 0x04	; 4
     576:	63 e0       	ldi	r22, 0x03	; 3
     578:	80 e0       	ldi	r24, 0x00	; 0
     57a:	0e 94 00 05 	call	0xa00	; 0xa00 <tinyLED_set_color_mode>
If the axon does fire, the potential is reduced
*/
double tinyAxon_update_potential(double potential)
{	
	//While the neuron has enough potential to fire, we want to fire more
	while (potential >= THRESHOLD_POTENTIAL)
     57e:	20 e0       	ldi	r18, 0x00	; 0
     580:	30 e0       	ldi	r19, 0x00	; 0
     582:	48 ec       	ldi	r20, 0xC8	; 200
     584:	51 e4       	ldi	r21, 0x41	; 65
     586:	c7 01       	movw	r24, r14
     588:	b6 01       	movw	r22, r12
     58a:	0e 94 4d 0a 	call	0x149a	; 0x149a <__gesf2>
     58e:	88 23       	and	r24, r24
     590:	4c f6       	brge	.-110    	; 0x524 <tinyAxon_update_potential+0x1c>
		
		tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
	}
	
	// If the neuron has a very low potential, we want to remove a pulse from the queue (if there is one)
	if(potential < -THRESHOLD_POTENTIAL && pulses_in_queue > 0) // Perhaps this should be a separate variable? For now, we will just simply use -THRESHOLD_POTENTIAL
     592:	20 e0       	ldi	r18, 0x00	; 0
     594:	30 e0       	ldi	r19, 0x00	; 0
     596:	48 ec       	ldi	r20, 0xC8	; 200
     598:	51 ec       	ldi	r21, 0xC1	; 193
     59a:	c7 01       	movw	r24, r14
     59c:	b6 01       	movw	r22, r12
     59e:	0e 94 75 08 	call	0x10ea	; 0x10ea <__cmpsf2>
     5a2:	88 23       	and	r24, r24
     5a4:	0c f0       	brlt	.+2      	; 0x5a8 <tinyAxon_update_potential+0xa0>
     5a6:	46 c0       	rjmp	.+140    	; 0x634 <tinyAxon_update_potential+0x12c>
     5a8:	80 91 2b 38 	lds	r24, 0x382B	; 0x80382b <pulses_in_queue>
     5ac:	88 23       	and	r24, r24
     5ae:	11 f1       	breq	.+68     	; 0x5f4 <tinyAxon_update_potential+0xec>
	{
		// The neurons potential is low enough to attempt to remove a queued fire (Fire less)
		if(tinyAxon_remove_pulse())
     5b0:	0e 94 61 02 	call	0x4c2	; 0x4c2 <tinyAxon_remove_pulse>
     5b4:	88 23       	and	r24, r24
     5b6:	f1 f1       	breq	.+124    	; 0x634 <tinyAxon_update_potential+0x12c>
		{
			// The potential has evened out a bit
			potential += THRESHOLD_POTENTIAL;
     5b8:	20 e0       	ldi	r18, 0x00	; 0
     5ba:	30 e0       	ldi	r19, 0x00	; 0
     5bc:	48 ec       	ldi	r20, 0xC8	; 200
     5be:	51 e4       	ldi	r21, 0x41	; 65
     5c0:	c7 01       	movw	r24, r14
     5c2:	b6 01       	movw	r22, r12
     5c4:	0e 94 09 08 	call	0x1012	; 0x1012 <__addsf3>
     5c8:	6b 01       	movw	r12, r22
     5ca:	7c 01       	movw	r14, r24
     5cc:	33 c0       	rjmp	.+102    	; 0x634 <tinyAxon_update_potential+0x12c>
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
	{
		for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
		{
			if(pulse_queue[i] != 0){
     5ce:	80 81       	ld	r24, Z
     5d0:	91 81       	ldd	r25, Z+1	; 0x01
     5d2:	00 97       	sbiw	r24, 0x00	; 0
     5d4:	39 f0       	breq	.+14     	; 0x5e4 <tinyAxon_update_potential+0xdc>
				pulse_queue[i]--;
     5d6:	01 97       	sbiw	r24, 0x01	; 1
     5d8:	80 83       	st	Z, r24
     5da:	91 83       	std	Z+1, r25	; 0x01
				
				// If the time went from 1 to 0, we fire the axon
				if(pulse_queue[i] == 0){
     5dc:	89 2b       	or	r24, r25
     5de:	11 f4       	brne	.+4      	; 0x5e4 <tinyAxon_update_potential+0xdc>
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
	pulses_in_queue--;
     5e0:	41 50       	subi	r20, 0x01	; 1
Function to set firing.
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
     5e2:	51 e0       	ldi	r21, 0x01	; 1
     5e4:	32 96       	adiw	r30, 0x02	; 2
	}
	
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
	{
		for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
     5e6:	e2 17       	cp	r30, r18
     5e8:	f3 07       	cpc	r31, r19
     5ea:	89 f7       	brne	.-30     	; 0x5ce <tinyAxon_update_potential+0xc6>
     5ec:	50 93 2c 38 	sts	0x382C, r21	; 0x80382c <tinyAxon_should_fire>
     5f0:	40 93 2b 38 	sts	0x382B, r20	; 0x80382b <pulses_in_queue>
The function should set the DAC to fire for two
update cycles once the pulse flag is set high.
*/
static void tinyAxon_update_pulse_transmitter(void)
{
	if (tinyAxon_should_fire)
     5f4:	80 91 2c 38 	lds	r24, 0x382C	; 0x80382c <tinyAxon_should_fire>
     5f8:	88 23       	and	r24, r24
     5fa:	91 f0       	breq	.+36     	; 0x620 <tinyAxon_update_potential+0x118>
	{
		tinyAxon_should_fire = false;
     5fc:	10 92 2c 38 	sts	0x382C, r1	; 0x80382c <tinyAxon_should_fire>
		tinyAxon_has_fired = true;
     600:	81 e0       	ldi	r24, 0x01	; 1
     602:	80 93 2d 38 	sts	0x382D, r24	; 0x80382d <tinyAxon_has_fired>
*/
static void tinyAxon_start_sending_pulse()
{
	if (NEURONTYPE == EXCITATORY_NEURON)
	{
		DAC_0_set_output(EXCITATORY_NEURON_OUTPUT);
     606:	82 ed       	ldi	r24, 0xD2	; 210
     608:	90 e0       	ldi	r25, 0x00	; 0
     60a:	0e 94 15 01 	call	0x22a	; 0x22a <DAC_0_set_output>
		axonOutputValue=EXCITATORY_NEURON_OUTPUT;
     60e:	82 ed       	ldi	r24, 0xD2	; 210
     610:	80 93 16 38 	sts	0x3816, r24	; 0x803816 <__data_end>
	{
		DAC_0_set_output(INHIBITORY_NEURON_OUTPUT);
		axonOutputValue=INHIBITORY_NEURON_OUTPUT;
	}
	
	tinyLED_set_color_mode(OUT_LED, WHITE, FLASH_ONCE);
     614:	44 e0       	ldi	r20, 0x04	; 4
     616:	65 e0       	ldi	r22, 0x05	; 5
     618:	81 e0       	ldi	r24, 0x01	; 1
     61a:	0e 94 00 05 	call	0xa00	; 0xa00 <tinyLED_set_color_mode>
     61e:	15 c0       	rjmp	.+42     	; 0x64a <tinyAxon_update_potential+0x142>
		tinyAxon_should_fire = false;
		tinyAxon_has_fired = true;
		
		tinyAxon_start_sending_pulse();
	}
	else if (tinyAxon_has_fired)
     620:	80 91 2d 38 	lds	r24, 0x382D	; 0x80382d <tinyAxon_has_fired>
     624:	88 23       	and	r24, r24
     626:	19 f0       	breq	.+6      	; 0x62e <tinyAxon_update_potential+0x126>
	{
		tinyAxon_has_fired = false;
     628:	10 92 2d 38 	sts	0x382D, r1	; 0x80382d <tinyAxon_has_fired>
     62c:	0e c0       	rjmp	.+28     	; 0x64a <tinyAxon_update_potential+0x142>
	}
	else if (!tinyAxon_has_fired && !tinyAxon_should_fire)
	{
		tinyAxon_stop_sending_pulse();
     62e:	0e 94 5a 02 	call	0x4b4	; 0x4b4 <tinyAxon_stop_sending_pulse>
     632:	0b c0       	rjmp	.+22     	; 0x64a <tinyAxon_update_potential+0x142>
			potential += THRESHOLD_POTENTIAL;
		}
	}
	
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
     634:	40 91 2b 38 	lds	r20, 0x382B	; 0x80382b <pulses_in_queue>
     638:	44 23       	and	r20, r20
     63a:	e1 f2       	breq	.-72     	; 0x5f4 <tinyAxon_update_potential+0xec>
     63c:	50 91 2c 38 	lds	r21, 0x382C	; 0x80382c <tinyAxon_should_fire>
     640:	e7 e1       	ldi	r30, 0x17	; 23
     642:	f8 e3       	ldi	r31, 0x38	; 56
     644:	2b e2       	ldi	r18, 0x2B	; 43
     646:	38 e3       	ldi	r19, 0x38	; 56
     648:	c2 cf       	rjmp	.-124    	; 0x5ce <tinyAxon_update_potential+0xc6>
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTB_get_pin_level(const uint8_t pin)
{
	return VPORTB.IN & (1 << pin);
     64a:	86 b1       	in	r24, 0x06	; 6
	// We need to check if the axon is connected to a charger. We do this by checking the AXON_CHECK_PIN. If it is hight while the axon is not firing, it must be connected to a charger
	if(AXON_CHECK_PIN_get_level() && !tinyAxon_should_fire){
		//tinyCharge_set_charging_mode(true);
	}
	
	tinyDebugger_send_uint8("Axon", axonOutputValue);
     64c:	60 91 16 38 	lds	r22, 0x3816	; 0x803816 <__data_end>
     650:	89 e8       	ldi	r24, 0x89	; 137
     652:	97 e9       	ldi	r25, 0x97	; 151
     654:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("Pulses", pulses_in_queue);
     658:	60 91 2b 38 	lds	r22, 0x382B	; 0x80382b <pulses_in_queue>
     65c:	8e e8       	ldi	r24, 0x8E	; 142
     65e:	97 e9       	ldi	r25, 0x97	; 151
     660:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <tinyDebugger_send_uint8>
	
	return potential;
}
     664:	c7 01       	movw	r24, r14
     666:	b6 01       	movw	r22, r12
     668:	ff 90       	pop	r15
     66a:	ef 90       	pop	r14
     66c:	df 90       	pop	r13
     66e:	cf 90       	pop	r12
     670:	08 95       	ret

00000672 <tinyButton_update>:
/*
If the button has been let go, we change button_press to true. This only lasts one cycle, before it is set to false again.
If the button is held down for longer than PULSEMODE_BUTTON_PRESS_TIME, we toggle the pulse mode state.
*/
void tinyButton_update(void)
{
     672:	0f 93       	push	r16
     674:	1f 93       	push	r17
     676:	cf 93       	push	r28
     678:	df 93       	push	r29
	button_press = false;
     67a:	10 92 32 38 	sts	0x3832, r1	; 0x803832 <button_press>
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTC_get_pin_level(const uint8_t pin)
{
	return VPORTC.IN & (1 << pin);
     67e:	8a b1       	in	r24, 0x0a	; 10
	_Bool button_is_pushed_down = !BUTTON_PIN_get_level(); // The digital port will be read as low if the button is pushed down.
     680:	d1 e0       	ldi	r29, 0x01	; 1
     682:	c8 2f       	mov	r28, r24
     684:	c4 70       	andi	r28, 0x04	; 4
     686:	82 fd       	sbrc	r24, 2
     688:	d0 e0       	ldi	r29, 0x00	; 0

	if (button_is_pushed_down && !button_was_pushed_down)
     68a:	c1 11       	cpse	r28, r1
     68c:	36 c0       	rjmp	.+108    	; 0x6fa <tinyButton_update+0x88>
     68e:	80 91 33 38 	lds	r24, 0x3833	; 0x803833 <button_was_pushed_down>
     692:	81 11       	cpse	r24, r1
     694:	0e c0       	rjmp	.+28     	; 0x6b2 <tinyButton_update+0x40>
	{
		tinyButton_start_time = tinyTime_now();
     696:	0e 94 ff 07 	call	0xffe	; 0xffe <tinyTime_now>
     69a:	60 93 2e 38 	sts	0x382E, r22	; 0x80382e <tinyButton_start_time>
     69e:	70 93 2f 38 	sts	0x382F, r23	; 0x80382f <tinyButton_start_time+0x1>
     6a2:	80 93 30 38 	sts	0x3830, r24	; 0x803830 <tinyButton_start_time+0x2>
     6a6:	90 93 31 38 	sts	0x3831, r25	; 0x803831 <tinyButton_start_time+0x3>
	}
	if (button_is_pushed_down && button_was_pushed_down)
     6aa:	80 91 33 38 	lds	r24, 0x3833	; 0x803833 <button_was_pushed_down>
     6ae:	88 23       	and	r24, r24
     6b0:	69 f1       	breq	.+90     	; 0x70c <tinyButton_update+0x9a>
	{
		if ((tinyTime_now() - tinyButton_start_time) > PULSEMODE_BUTTON_PRESS_TIME)
     6b2:	0e 94 ff 07 	call	0xffe	; 0xffe <tinyTime_now>
     6b6:	00 91 2e 38 	lds	r16, 0x382E	; 0x80382e <tinyButton_start_time>
     6ba:	10 91 2f 38 	lds	r17, 0x382F	; 0x80382f <tinyButton_start_time+0x1>
     6be:	20 91 30 38 	lds	r18, 0x3830	; 0x803830 <tinyButton_start_time+0x2>
     6c2:	30 91 31 38 	lds	r19, 0x3831	; 0x803831 <tinyButton_start_time+0x3>
     6c6:	60 1b       	sub	r22, r16
     6c8:	71 0b       	sbc	r23, r17
     6ca:	82 0b       	sbc	r24, r18
     6cc:	93 0b       	sbc	r25, r19
     6ce:	0e 94 55 09 	call	0x12aa	; 0x12aa <__floatunsisf>
     6d2:	20 e0       	ldi	r18, 0x00	; 0
     6d4:	30 e0       	ldi	r19, 0x00	; 0
     6d6:	4a e7       	ldi	r20, 0x7A	; 122
     6d8:	54 e4       	ldi	r21, 0x44	; 68
     6da:	0e 94 4d 0a 	call	0x149a	; 0x149a <__gesf2>
     6de:	18 16       	cp	r1, r24
     6e0:	64 f4       	brge	.+24     	; 0x6fa <tinyButton_update+0x88>
		{
			tinyPulse_toggle_pulse_mode();
     6e2:	0e 94 ac 07 	call	0xf58	; 0xf58 <tinyPulse_toggle_pulse_mode>
			tinyButton_start_time = tinyTime_now();
     6e6:	0e 94 ff 07 	call	0xffe	; 0xffe <tinyTime_now>
     6ea:	60 93 2e 38 	sts	0x382E, r22	; 0x80382e <tinyButton_start_time>
     6ee:	70 93 2f 38 	sts	0x382F, r23	; 0x80382f <tinyButton_start_time+0x1>
     6f2:	80 93 30 38 	sts	0x3830, r24	; 0x803830 <tinyButton_start_time+0x2>
     6f6:	90 93 31 38 	sts	0x3831, r25	; 0x803831 <tinyButton_start_time+0x3>
		}
	}
	if (!button_is_pushed_down && button_was_pushed_down)
     6fa:	cc 23       	and	r28, r28
     6fc:	39 f0       	breq	.+14     	; 0x70c <tinyButton_update+0x9a>
     6fe:	80 91 33 38 	lds	r24, 0x3833	; 0x803833 <button_was_pushed_down>
     702:	88 23       	and	r24, r24
     704:	19 f0       	breq	.+6      	; 0x70c <tinyButton_update+0x9a>
	{
		button_press = true;
     706:	81 e0       	ldi	r24, 0x01	; 1
     708:	80 93 32 38 	sts	0x3832, r24	; 0x803832 <button_press>
	}
	button_was_pushed_down = button_is_pushed_down;
     70c:	d0 93 33 38 	sts	0x3833, r29	; 0x803833 <button_was_pushed_down>
}
     710:	df 91       	pop	r29
     712:	cf 91       	pop	r28
     714:	1f 91       	pop	r17
     716:	0f 91       	pop	r16
     718:	08 95       	ret

0000071a <tinyButton_update_potential>:

double tinyButton_update_potential(double potential){
	if(button_press){
     71a:	20 91 32 38 	lds	r18, 0x3832	; 0x803832 <button_press>
     71e:	22 23       	and	r18, r18
     720:	31 f0       	breq	.+12     	; 0x72e <tinyButton_update_potential+0x14>
		potential += BUTTON_PRESS_REACTION;
     722:	20 e0       	ldi	r18, 0x00	; 0
     724:	30 e0       	ldi	r19, 0x00	; 0
     726:	40 ed       	ldi	r20, 0xD0	; 208
     728:	51 e4       	ldi	r21, 0x41	; 65
     72a:	0e 94 09 08 	call	0x1012	; 0x1012 <__addsf3>
	}
	return potential;
}
     72e:	08 95       	ret

00000730 <tinyCharge_is_connected_to_charger>:

_Bool connected_to_charger;

_Bool tinyCharge_is_connected_to_charger(){
	return connected_to_charger;
}
     730:	80 91 57 38 	lds	r24, 0x3857	; 0x803857 <connected_to_charger>
     734:	08 95       	ret

00000736 <tinyCharge_is_fully_charged>:
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTB_get_pin_level(const uint8_t pin)
{
	return VPORTB.IN & (1 << pin);
     736:	86 b1       	in	r24, 0x06	; 6

_Bool tinyCharge_is_fully_charged(){
	return CHARGING_STATUS_PIN_get_level();
}
     738:	86 fb       	bst	r24, 6
     73a:	88 27       	eor	r24, r24
     73c:	80 f9       	bld	r24, 0
     73e:	08 95       	ret

00000740 <tinyCharge_DAC_dissable>:
void tinyCharge_DAC_dissable(){
	
	// We need some way to disable the DAC to prevent huge current draw when charging (64mA). When there is no code uploaded to the attiny, there is no problem.
	// We're going to try to enable the pin as a dendrite, since they seem to be doing fine. Completely uninitializing the pin probably caused a microchip to be fried.
	
	DAC_0_uninit();
     740:	0e 94 04 01 	call	0x208	; 0x208 <DAC_0_uninit>
	DAC_0_disable();
     744:	0e 94 0f 01 	call	0x21e	; 0x21e <DAC_0_disable>
     748:	08 95       	ret

0000074a <tinyCharge_DAC_enable>:
void tinyCharge_DAC_enable(){
	
	// We need some way to disable the DAC to prevent huge current draw when charging (64mA). When there is no code uploaded to the attiny, there is no problem.
	// We're going to try to enable the pin as a dendrite, since they seem to be doing fine. Completely uninitializing the pin probably caused a microchip to be fried.
	
	DAC_0_init();
     74a:	0e 94 ff 00 	call	0x1fe	; 0x1fe <DAC_0_init>
	DAC_0_enable();
     74e:	0e 94 09 01 	call	0x212	; 0x212 <DAC_0_enable>
     752:	08 95       	ret

00000754 <tinyCharge_switch_mode>:
}


void tinyCharge_switch_mode(){
	
	if(connected_to_charger){
     754:	80 91 57 38 	lds	r24, 0x3857	; 0x803857 <connected_to_charger>
     758:	88 23       	and	r24, r24
     75a:	71 f0       	breq	.+28     	; 0x778 <tinyCharge_switch_mode+0x24>
		// Switch from main to charging mode
		
		// Set LED
		tinyLED_set_color_mode(INN_LED, CHARGING_COLOR, SWING);
     75c:	42 e0       	ldi	r20, 0x02	; 2
     75e:	61 e0       	ldi	r22, 0x01	; 1
     760:	80 e0       	ldi	r24, 0x00	; 0
     762:	0e 94 00 05 	call	0xa00	; 0xa00 <tinyLED_set_color_mode>
		tinyLED_set_color(OUT_LED, OFF);
     766:	60 e0       	ldi	r22, 0x00	; 0
     768:	81 e0       	ldi	r24, 0x01	; 1
     76a:	0e 94 ef 04 	call	0x9de	; 0x9de <tinyLED_set_color>


		// Stop axon from firing
		// (There is a small chance that the neuron is put into charging mode as it is firing. The axon is then never told to stop firing)
		tinyAxon_stop_sending_pulse();
     76e:	0e 94 5a 02 	call	0x4b4	; 0x4b4 <tinyAxon_stop_sending_pulse>

		// disable DAC
		tinyCharge_DAC_dissable();
     772:	0e 94 a0 03 	call	0x740	; 0x740 <tinyCharge_DAC_dissable>
     776:	08 95       	ret
	}
	else{
		// Switch from charge to main mode
		
		// Set LED
		tinyLED_set_color(OUT_LED, OFF);
     778:	60 e0       	ldi	r22, 0x00	; 0
     77a:	81 e0       	ldi	r24, 0x01	; 1
     77c:	0e 94 ef 04 	call	0x9de	; 0x9de <tinyLED_set_color>
		tinyLED_set_color(INN_LED, OFF);
     780:	60 e0       	ldi	r22, 0x00	; 0
     782:	80 e0       	ldi	r24, 0x00	; 0
     784:	0e 94 ef 04 	call	0x9de	; 0x9de <tinyLED_set_color>
		
		// enable DAC
		tinyCharge_DAC_enable();
     788:	0e 94 a5 03 	call	0x74a	; 0x74a <tinyCharge_DAC_enable>
     78c:	08 95       	ret

0000078e <tinyCharge_set_charging_mode>:
	}
}

void tinyCharge_set_charging_mode(_Bool charging_status){
	if(charging_status != connected_to_charger){
     78e:	90 91 57 38 	lds	r25, 0x3857	; 0x803857 <connected_to_charger>
     792:	98 17       	cp	r25, r24
     794:	21 f0       	breq	.+8      	; 0x79e <tinyCharge_set_charging_mode+0x10>
		connected_to_charger = charging_status;
     796:	80 93 57 38 	sts	0x3857, r24	; 0x803857 <connected_to_charger>
		tinyCharge_switch_mode();
     79a:	0e 94 aa 03 	call	0x754	; 0x754 <tinyCharge_switch_mode>
     79e:	08 95       	ret

000007a0 <tinyCharge_set_transistors>:
	}
}


void tinyCharge_set_transistors(){
	if(connected_to_charger){
     7a0:	80 91 57 38 	lds	r24, 0x3857	; 0x803857 <connected_to_charger>
     7a4:	88 23       	and	r24, r24
     7a6:	11 f0       	breq	.+4      	; 0x7ac <tinyCharge_set_transistors+0xc>
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
	} else {
		VPORTC.OUT &= ~(1 << pin);
     7a8:	4d 98       	cbi	0x09, 5	; 9
     7aa:	08 95       	ret
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     7ac:	4d 9a       	sbi	0x09, 5	; 9
     7ae:	08 95       	ret

000007b0 <tinyDebugger_send_uint32>:
		char number[20]; // Arbitrary max
		dtostrf(value,1,NUMBER_OF_DECIMALS, number);
		printf("%s:%5s\t", name, number);
	}
}
void tinyDebugger_send_string(const char* name, char * value){
     7b0:	08 95       	ret

000007b2 <tinyDebugger_send_uint8>:
     7b2:	08 95       	ret

000007b4 <tinyDebugger_send_double>:
     7b4:	08 95       	ret

000007b6 <tinyDebugger_end_line>:
	if(DEBUGGING){
		printf("%s:%s\t", name, value);
	}
}
void tinyDebugger_end_line(){
     7b6:	08 95       	ret

000007b8 <tinyDendrite_update_signals>:
/*
This function converts the 8 bit value from the ADC into one of the signal types defined in DendriteSignal
We also update the charging state
*/
void tinyDendrite_update_signals(void)
{
     7b8:	af 92       	push	r10
     7ba:	bf 92       	push	r11
     7bc:	cf 92       	push	r12
     7be:	df 92       	push	r13
     7c0:	ef 92       	push	r14
     7c2:	ff 92       	push	r15
     7c4:	0f 93       	push	r16
     7c6:	1f 93       	push	r17
     7c8:	cf 93       	push	r28
     7ca:	df 93       	push	r29
     7cc:	ce e0       	ldi	r28, 0x0E	; 14
     7ce:	d8 e3       	ldi	r29, 0x38	; 56
     7d0:	0e e3       	ldi	r16, 0x3E	; 62
     7d2:	18 e3       	ldi	r17, 0x38	; 56
     7d4:	0f 2e       	mov	r0, r31
     7d6:	f3 e1       	ldi	r31, 0x13	; 19
     7d8:	cf 2e       	mov	r12, r31
     7da:	f8 e3       	ldi	r31, 0x38	; 56
     7dc:	df 2e       	mov	r13, r31
     7de:	f0 2d       	mov	r31, r0
     7e0:	78 01       	movw	r14, r16
*/
static void tinyDendrite_read_signals(void)
{
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_values[i] = ADC_0_get_conversion(Dendrite_ports[i]);
     7e2:	89 91       	ld	r24, Y+
     7e4:	0e 94 c9 00 	call	0x192	; 0x192 <ADC_0_get_conversion>
     7e8:	d7 01       	movw	r26, r14
     7ea:	8d 93       	st	X+, r24
     7ec:	7d 01       	movw	r14, r26
/*
This function reads the voltage at the Dendrite inputs with the ADC
*/
static void tinyDendrite_read_signals(void)
{
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
     7ee:	cc 15       	cp	r28, r12
     7f0:	dd 05       	cpc	r29, r13
     7f2:	b9 f7       	brne	.-18     	; 0x7e2 <tinyDendrite_update_signals+0x2a>
	{
		tinyDendrite_values[i] = ADC_0_get_conversion(Dendrite_ports[i]);
	}
	tinyDebugger_send_uint8("D1", tinyDendrite_values[0]);
     7f4:	ce e3       	ldi	r28, 0x3E	; 62
     7f6:	d8 e3       	ldi	r29, 0x38	; 56
     7f8:	68 81       	ld	r22, Y
     7fa:	85 e9       	ldi	r24, 0x95	; 149
     7fc:	97 e9       	ldi	r25, 0x97	; 151
     7fe:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D2", tinyDendrite_values[1]);
     802:	69 81       	ldd	r22, Y+1	; 0x01
     804:	88 e9       	ldi	r24, 0x98	; 152
     806:	97 e9       	ldi	r25, 0x97	; 151
     808:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D3", tinyDendrite_values[2]);
     80c:	6a 81       	ldd	r22, Y+2	; 0x02
     80e:	8b e9       	ldi	r24, 0x9B	; 155
     810:	97 e9       	ldi	r25, 0x97	; 151
     812:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D4", tinyDendrite_values[3]);
     816:	6b 81       	ldd	r22, Y+3	; 0x03
     818:	8e e9       	ldi	r24, 0x9E	; 158
     81a:	97 e9       	ldi	r25, 0x97	; 151
     81c:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D5", tinyDendrite_values[4]);
     820:	6c 81       	ldd	r22, Y+4	; 0x04
     822:	81 ea       	ldi	r24, 0xA1	; 161
     824:	97 e9       	ldi	r25, 0x97	; 151
     826:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <tinyDebugger_send_uint8>
     82a:	e9 e3       	ldi	r30, 0x39	; 57
     82c:	f8 e3       	ldi	r31, 0x38	; 56
     82e:	c4 e3       	ldi	r28, 0x34	; 52
     830:	d8 e3       	ldi	r29, 0x38	; 56
     832:	4e e3       	ldi	r20, 0x3E	; 62
     834:	58 e3       	ldi	r21, 0x38	; 56
{
	
	//Read the analog voltage values on each of the Dendrites
	tinyDendrite_read_signals();
	
	_Bool charging = false;
     836:	80 e0       	ldi	r24, 0x00	; 0
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     838:	31 e0       	ldi	r19, 0x01	; 1
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
		}
		else if (tinyDendrite_values[i] > HIGH_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
     83a:	0f 2e       	mov	r0, r31
     83c:	f3 e0       	ldi	r31, 0x03	; 3
     83e:	cf 2e       	mov	r12, r31
     840:	f0 2d       	mov	r31, r0
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     842:	68 94       	set
     844:	dd 24       	eor	r13, r13
     846:	d1 f8       	bld	r13, 1
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     848:	68 94       	set
     84a:	ee 24       	eor	r14, r14
     84c:	e2 f8       	bld	r14, 2
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     84e:	0f 2e       	mov	r0, r31
     850:	f6 e0       	ldi	r31, 0x06	; 6
     852:	ff 2e       	mov	r15, r31
     854:	f0 2d       	mov	r31, r0
			tinyDendrite_current_signals[i] = CHARGING;
			charging = true;
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     856:	75 e0       	ldi	r23, 0x05	; 5
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = CHARGING;
     858:	67 e0       	ldi	r22, 0x07	; 7
     85a:	5f 01       	movw	r10, r30
	
	_Bool charging = false;
	
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
     85c:	90 81       	ld	r25, Z
     85e:	99 93       	st	Y+, r25
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
     860:	d8 01       	movw	r26, r16
     862:	2d 91       	ld	r18, X+
     864:	8d 01       	movw	r16, r26
     866:	29 3e       	cpi	r18, 0xE9	; 233
     868:	18 f0       	brcs	.+6      	; 0x870 <tinyDendrite_update_signals+0xb8>
		{
			tinyDendrite_current_signals[i] = CHARGING;
     86a:	60 83       	st	Z, r22
			charging = true;
     86c:	83 2f       	mov	r24, r19
     86e:	19 c0       	rjmp	.+50     	; 0x8a2 <tinyDendrite_update_signals+0xea>
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
     870:	28 3c       	cpi	r18, 0xC8	; 200
     872:	10 f0       	brcs	.+4      	; 0x878 <tinyDendrite_update_signals+0xc0>
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     874:	70 83       	st	Z, r23
     876:	15 c0       	rjmp	.+42     	; 0x8a2 <tinyDendrite_update_signals+0xea>
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
     878:	27 3a       	cpi	r18, 0xA7	; 167
     87a:	10 f0       	brcs	.+4      	; 0x880 <tinyDendrite_update_signals+0xc8>
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     87c:	f0 82       	st	Z, r15
     87e:	11 c0       	rjmp	.+34     	; 0x8a2 <tinyDendrite_update_signals+0xea>
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
     880:	25 38       	cpi	r18, 0x85	; 133
     882:	10 f0       	brcs	.+4      	; 0x888 <tinyDendrite_update_signals+0xd0>
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     884:	e0 82       	st	Z, r14
     886:	0d c0       	rjmp	.+26     	; 0x8a2 <tinyDendrite_update_signals+0xea>
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
     888:	24 36       	cpi	r18, 0x64	; 100
     88a:	10 f0       	brcs	.+4      	; 0x890 <tinyDendrite_update_signals+0xd8>
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     88c:	d0 82       	st	Z, r13
     88e:	09 c0       	rjmp	.+18     	; 0x8a2 <tinyDendrite_update_signals+0xea>
		}
		else if (tinyDendrite_values[i] > HIGH_INHIB_THRESHOLD)
     890:	23 34       	cpi	r18, 0x43	; 67
     892:	10 f0       	brcs	.+4      	; 0x898 <tinyDendrite_update_signals+0xe0>
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
     894:	c0 82       	st	Z, r12
     896:	05 c0       	rjmp	.+10     	; 0x8a2 <tinyDendrite_update_signals+0xea>
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
     898:	22 32       	cpi	r18, 0x22	; 34
     89a:	10 f0       	brcs	.+4      	; 0x8a0 <tinyDendrite_update_signals+0xe8>
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     89c:	30 83       	st	Z, r19
     89e:	01 c0       	rjmp	.+2      	; 0x8a2 <tinyDendrite_update_signals+0xea>
		}
		else
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     8a0:	10 82       	st	Z, r1
		}
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
     8a2:	d5 01       	movw	r26, r10
     8a4:	2c 91       	ld	r18, X
     8a6:	92 13       	cpse	r25, r18
     8a8:	01 c0       	rjmp	.+2      	; 0x8ac <tinyDendrite_update_signals+0xf4>
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     8aa:	1c 92       	st	X, r1
     8ac:	31 96       	adiw	r30, 0x01	; 1
	//Read the analog voltage values on each of the Dendrites
	tinyDendrite_read_signals();
	
	_Bool charging = false;
	
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
     8ae:	e4 17       	cp	r30, r20
     8b0:	f5 07       	cpc	r31, r21
     8b2:	99 f6       	brne	.-90     	; 0x85a <tinyDendrite_update_signals+0xa2>
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
		}
	}
	tinyCharge_set_charging_mode(charging);
     8b4:	0e 94 c7 03 	call	0x78e	; 0x78e <tinyCharge_set_charging_mode>
}
     8b8:	df 91       	pop	r29
     8ba:	cf 91       	pop	r28
     8bc:	1f 91       	pop	r17
     8be:	0f 91       	pop	r16
     8c0:	ff 90       	pop	r15
     8c2:	ef 90       	pop	r14
     8c4:	df 90       	pop	r13
     8c6:	cf 90       	pop	r12
     8c8:	bf 90       	pop	r11
     8ca:	af 90       	pop	r10
     8cc:	08 95       	ret

000008ce <tinyDendrite_get_potential>:
outside. It uses the previously declared functions to return the potential.
*/
int16_t tinyDendrite_get_potential()
{
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
     8ce:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <tinyDendrite_update_signals>
     8d2:	e9 e3       	ldi	r30, 0x39	; 57
     8d4:	f8 e3       	ldi	r31, 0x38	; 56
     8d6:	4e e3       	ldi	r20, 0x3E	; 62
     8d8:	58 e3       	ldi	r21, 0x38	; 56
	
	int16_t return_potential_val = 0;
     8da:	20 e0       	ldi	r18, 0x00	; 0
     8dc:	30 e0       	ldi	r19, 0x00	; 0
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		switch(tinyDendrite_current_signals[i])
     8de:	91 91       	ld	r25, Z+
     8e0:	93 30       	cpi	r25, 0x03	; 3
     8e2:	a1 f0       	breq	.+40     	; 0x90c <tinyDendrite_get_potential+0x3e>
     8e4:	28 f4       	brcc	.+10     	; 0x8f0 <tinyDendrite_get_potential+0x22>
     8e6:	91 30       	cpi	r25, 0x01	; 1
     8e8:	b9 f0       	breq	.+46     	; 0x918 <tinyDendrite_get_potential+0x4a>
     8ea:	92 30       	cpi	r25, 0x02	; 2
     8ec:	91 f0       	breq	.+36     	; 0x912 <tinyDendrite_get_potential+0x44>
     8ee:	16 c0       	rjmp	.+44     	; 0x91c <tinyDendrite_get_potential+0x4e>
     8f0:	95 30       	cpi	r25, 0x05	; 5
     8f2:	31 f0       	breq	.+12     	; 0x900 <tinyDendrite_get_potential+0x32>
     8f4:	40 f0       	brcs	.+16     	; 0x906 <tinyDendrite_get_potential+0x38>
     8f6:	96 30       	cpi	r25, 0x06	; 6
     8f8:	89 f4       	brne	.+34     	; 0x91c <tinyDendrite_get_potential+0x4e>
		{
			case NO_SIGNAL:
				return_potential_val += NO_SIGNAL_REACTION;
				break;
			case HIGH_EXCITE:
				return_potential_val += HIGH_EXCITE_REACTION;
     8fa:	2c 5c       	subi	r18, 0xCC	; 204
     8fc:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     8fe:	0e c0       	rjmp	.+28     	; 0x91c <tinyDendrite_get_potential+0x4e>
			case NORMAL_EXCITE:
				return_potential_val += NORMAL_EXCITE_REACTION;
     900:	27 5e       	subi	r18, 0xE7	; 231
     902:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     904:	0b c0       	rjmp	.+22     	; 0x91c <tinyDendrite_get_potential+0x4e>
			case LOW_EXCITE:
				return_potential_val += LOW_EXCITE_REACTION;
     906:	2c 5e       	subi	r18, 0xEC	; 236
     908:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     90a:	08 c0       	rjmp	.+16     	; 0x91c <tinyDendrite_get_potential+0x4e>
			case HIGH_INHIB:
				return_potential_val += HIGH_INHIB_REACTION;
     90c:	22 53       	subi	r18, 0x32	; 50
     90e:	31 09       	sbc	r19, r1
				break;
     910:	05 c0       	rjmp	.+10     	; 0x91c <tinyDendrite_get_potential+0x4e>
			case NORMAL_INHIB:
				return_potential_val += NORMAL_INHIB_REACTION;
     912:	29 51       	subi	r18, 0x19	; 25
     914:	31 09       	sbc	r19, r1
				break;
     916:	02 c0       	rjmp	.+4      	; 0x91c <tinyDendrite_get_potential+0x4e>
			case LOW_INHIB:
				return_potential_val += LOW_INHIB_REACTION;
     918:	24 51       	subi	r18, 0x14	; 20
     91a:	31 09       	sbc	r19, r1
{
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
	
	int16_t return_potential_val = 0;
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
     91c:	e4 17       	cp	r30, r20
     91e:	f5 07       	cpc	r31, r21
     920:	f1 f6       	brne	.-68     	; 0x8de <tinyDendrite_get_potential+0x10>
			default:
				break;
		}
	}
	return return_potential_val;
}
     922:	c9 01       	movw	r24, r18
     924:	08 95       	ret

00000926 <tinyDendrite_update_potential>:

double tinyDendrite_update_potential(double potential){
     926:	cf 92       	push	r12
     928:	df 92       	push	r13
     92a:	ef 92       	push	r14
     92c:	ff 92       	push	r15
     92e:	6b 01       	movw	r12, r22
     930:	7c 01       	movw	r14, r24
	
	int16_t potential_change = tinyDendrite_get_potential();
     932:	0e 94 67 04 	call	0x8ce	; 0x8ce <tinyDendrite_get_potential>
	potential += potential_change;
	return potential;
     936:	bc 01       	movw	r22, r24
     938:	99 0f       	add	r25, r25
     93a:	88 0b       	sbc	r24, r24
     93c:	99 0b       	sbc	r25, r25
     93e:	0e 94 57 09 	call	0x12ae	; 0x12ae <__floatsisf>
     942:	a7 01       	movw	r20, r14
     944:	96 01       	movw	r18, r12
     946:	0e 94 09 08 	call	0x1012	; 0x1012 <__addsf3>
     94a:	ff 90       	pop	r15
     94c:	ef 90       	pop	r14
     94e:	df 90       	pop	r13
     950:	cf 90       	pop	r12
     952:	08 95       	ret

00000954 <__vector_6>:
This function is called every time the RTC (Real Time Clock) counter overflows.
With the current settings, it will be called every ms.
The RTC clock runs at 1kHz, and the number of cycles before overflow is set with RTC.PER = someHexValue (e.g. 0x20) in src/rtc.c
*/
ISR(RTC_CNT_vect)
{
     954:	1f 92       	push	r1
     956:	0f 92       	push	r0
     958:	0f b6       	in	r0, 0x3f	; 63
     95a:	0f 92       	push	r0
     95c:	11 24       	eor	r1, r1
     95e:	2f 93       	push	r18
     960:	3f 93       	push	r19
     962:	4f 93       	push	r20
     964:	5f 93       	push	r21
     966:	6f 93       	push	r22
     968:	7f 93       	push	r23
     96a:	8f 93       	push	r24
     96c:	9f 93       	push	r25
     96e:	af 93       	push	r26
     970:	bf 93       	push	r27
     972:	cf 93       	push	r28
     974:	ef 93       	push	r30
     976:	ff 93       	push	r31
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     978:	c1 e0       	ldi	r28, 0x01	; 1
     97a:	c0 93 43 38 	sts	0x3843, r28	; 0x803843 <tinyISR_interrupt_flag>
{
	// Set flag to let main loop run a new cycle
	tinyISR_setflag(true);
	
	// Timer counter incrementation
	tinyTime_counter_increment();
     97e:	0e 94 eb 07 	call	0xfd6	; 0xfd6 <tinyTime_counter_increment>

	/* Overflow interrupt flag has to be cleared manually */
	RTC.INTFLAGS = RTC_OVF_bm;
     982:	c0 93 43 01 	sts	0x0143, r28	; 0x800143 <__TEXT_REGION_LENGTH__+0x700143>
}
     986:	ff 91       	pop	r31
     988:	ef 91       	pop	r30
     98a:	cf 91       	pop	r28
     98c:	bf 91       	pop	r27
     98e:	af 91       	pop	r26
     990:	9f 91       	pop	r25
     992:	8f 91       	pop	r24
     994:	7f 91       	pop	r23
     996:	6f 91       	pop	r22
     998:	5f 91       	pop	r21
     99a:	4f 91       	pop	r20
     99c:	3f 91       	pop	r19
     99e:	2f 91       	pop	r18
     9a0:	0f 90       	pop	r0
     9a2:	0f be       	out	0x3f, r0	; 63
     9a4:	0f 90       	pop	r0
     9a6:	1f 90       	pop	r1
     9a8:	18 95       	reti

000009aa <tinyISR_setflag>:
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     9aa:	80 93 43 38 	sts	0x3843, r24	; 0x803843 <tinyISR_interrupt_flag>
     9ae:	08 95       	ret

000009b0 <tinyISR_getflag>:
}

_Bool tinyISR_getflag(void)
{
	return tinyISR_interrupt_flag;
}
     9b0:	80 91 43 38 	lds	r24, 0x3843	; 0x803843 <tinyISR_interrupt_flag>
     9b4:	08 95       	ret

000009b6 <tinyLED_SPIWriteByte>:
Function used to send a byte over SPI, which in turn gets
translated to the bit-sequence required by the LEDs over the CCL.
*/
static void tinyLED_SPIWriteByte(uint8_t byte)
{
	SPI0.INTFLAGS = SPI0_INTFLAGS; // clear the write collision flag to allow writing
     9b6:	90 91 23 08 	lds	r25, 0x0823	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
     9ba:	90 93 23 08 	sts	0x0823, r25	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
	TCA0.SINGLE.CNT = 0; // reset TCA counter register to ensure the first rising edge of the PWM is predictable
     9be:	e0 e0       	ldi	r30, 0x00	; 0
     9c0:	fa e0       	ldi	r31, 0x0A	; 10
     9c2:	10 a2       	std	Z+32, r1	; 0x20
     9c4:	11 a2       	std	Z+33, r1	; 0x21
	
	// start TCA
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 1 << TCA_SPLIT_ENABLE_bp;
     9c6:	91 e0       	ldi	r25, 0x01	; 1
     9c8:	90 83       	st	Z, r25
	SPI0_DATA = byte;
     9ca:	80 93 24 08 	sts	0x0824, r24	; 0x800824 <__TEXT_REGION_LENGTH__+0x700824>

	while((SPI0.INTFLAGS & SPI_RXCIE_bm) == 0){} // wait for transfer to complete
     9ce:	e0 e2       	ldi	r30, 0x20	; 32
     9d0:	f8 e0       	ldi	r31, 0x08	; 8
     9d2:	83 81       	ldd	r24, Z+3	; 0x03
     9d4:	88 23       	and	r24, r24
     9d6:	ec f7       	brge	.-6      	; 0x9d2 <tinyLED_SPIWriteByte+0x1c>
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 0 << TCA_SPLIT_ENABLE_bp; //Stop TCA
     9d8:	10 92 00 0a 	sts	0x0A00, r1	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
     9dc:	08 95       	ret

000009de <tinyLED_set_color>:
changes the values in the variables stored in the LED-array.
*/
void tinyLED_set_color_mode(uint8_t LED_id, enum Colors color, enum ColorModes mode)
{
	struct ColorSetting setting = {.color=color, .mode=mode};
	tinyLED_colors[LED_id] = setting;
     9de:	e8 2f       	mov	r30, r24
     9e0:	f0 e0       	ldi	r31, 0x00	; 0
     9e2:	ee 0f       	add	r30, r30
     9e4:	ff 1f       	adc	r31, r31
     9e6:	e0 5a       	subi	r30, 0xA0	; 160
     9e8:	f7 4c       	sbci	r31, 0xC7	; 199
     9ea:	60 83       	st	Z, r22
     9ec:	11 82       	std	Z+1, r1	; 0x01
     9ee:	08 95       	ret

000009f0 <tinyLED_get_color>:
	tinyLED_set_color_mode(LED_id, color, STABLE);
}

enum Colors tinyLED_get_color(uint8_t LED_id)
{
	return tinyLED_colors[LED_id].color;
     9f0:	e8 2f       	mov	r30, r24
     9f2:	f0 e0       	ldi	r31, 0x00	; 0
     9f4:	ee 0f       	add	r30, r30
     9f6:	ff 1f       	adc	r31, r31
     9f8:	e0 5a       	subi	r30, 0xA0	; 160
     9fa:	f7 4c       	sbci	r31, 0xC7	; 199
}
     9fc:	80 81       	ld	r24, Z
     9fe:	08 95       	ret

00000a00 <tinyLED_set_color_mode>:
changes the values in the variables stored in the LED-array.
*/
void tinyLED_set_color_mode(uint8_t LED_id, enum Colors color, enum ColorModes mode)
{
	struct ColorSetting setting = {.color=color, .mode=mode};
	tinyLED_colors[LED_id] = setting;
     a00:	90 e0       	ldi	r25, 0x00	; 0
     a02:	fc 01       	movw	r30, r24
     a04:	ee 0f       	add	r30, r30
     a06:	ff 1f       	adc	r31, r31
     a08:	e0 5a       	subi	r30, 0xA0	; 160
     a0a:	f7 4c       	sbci	r31, 0xC7	; 199
     a0c:	60 83       	st	Z, r22
     a0e:	41 83       	std	Z+1, r20	; 0x01
	if (mode == FLASH_ONCE)
     a10:	44 30       	cpi	r20, 0x04	; 4
     a12:	29 f4       	brne	.+10     	; 0xa1e <tinyLED_set_color_mode+0x1e>
	{
		tinyLED_flash_once_time[LED_id] = 1000*FLASH_TIME;
     a14:	fc 01       	movw	r30, r24
     a16:	e8 5a       	subi	r30, 0xA8	; 168
     a18:	f7 4c       	sbci	r31, 0xC7	; 199
     a1a:	24 e6       	ldi	r18, 0x64	; 100
     a1c:	20 83       	st	Z, r18
     a1e:	08 95       	ret

00000a20 <tinyLED_RGB_Color_Compare>:
	return rgb_color;
			
};
// This might be cause of strange light behavior?
//Message		expected 'struct RGB_Color *' but argument is of type 'struct RGB_Color (*)[2]'	Hjernebyggesett_V4	C:\Users\Elias Lundheim\Documents\GitHub\neural\Hjernebyggesett_V4\Hjernebyggesett_V4\tinyLED\tinyLED.c	121
_Bool tinyLED_RGB_Color_Compare(struct RGB_Color (*a)[NUMBER_OF_LEDS], struct RGB_Color (*b)[NUMBER_OF_LEDS]){
     a20:	dc 01       	movw	r26, r24
     a22:	fb 01       	movw	r30, r22
	for (int i=0; i<NUMBER_OF_LEDS; i++)
	{
		if(!((*a)[i].red==(*b)[i].red && (*a)[i].green==(*b)[i].green && (*a)[i].blue==(*b)[i].blue)){
     a24:	9c 91       	ld	r25, X
     a26:	80 81       	ld	r24, Z
     a28:	98 13       	cpse	r25, r24
     a2a:	20 c0       	rjmp	.+64     	; 0xa6c <tinyLED_RGB_Color_Compare+0x4c>
     a2c:	11 96       	adiw	r26, 0x01	; 1
     a2e:	9c 91       	ld	r25, X
     a30:	11 97       	sbiw	r26, 0x01	; 1
     a32:	81 81       	ldd	r24, Z+1	; 0x01
     a34:	98 13       	cpse	r25, r24
     a36:	1c c0       	rjmp	.+56     	; 0xa70 <tinyLED_RGB_Color_Compare+0x50>
     a38:	12 96       	adiw	r26, 0x02	; 2
     a3a:	9c 91       	ld	r25, X
     a3c:	12 97       	sbiw	r26, 0x02	; 2
     a3e:	82 81       	ldd	r24, Z+2	; 0x02
     a40:	98 13       	cpse	r25, r24
     a42:	18 c0       	rjmp	.+48     	; 0xa74 <tinyLED_RGB_Color_Compare+0x54>
     a44:	13 96       	adiw	r26, 0x03	; 3
     a46:	9c 91       	ld	r25, X
     a48:	13 97       	sbiw	r26, 0x03	; 3
     a4a:	83 81       	ldd	r24, Z+3	; 0x03
     a4c:	98 13       	cpse	r25, r24
     a4e:	14 c0       	rjmp	.+40     	; 0xa78 <tinyLED_RGB_Color_Compare+0x58>
     a50:	14 96       	adiw	r26, 0x04	; 4
     a52:	9c 91       	ld	r25, X
     a54:	14 97       	sbiw	r26, 0x04	; 4
     a56:	84 81       	ldd	r24, Z+4	; 0x04
     a58:	98 13       	cpse	r25, r24
     a5a:	10 c0       	rjmp	.+32     	; 0xa7c <tinyLED_RGB_Color_Compare+0x5c>
     a5c:	81 e0       	ldi	r24, 0x01	; 1
     a5e:	15 96       	adiw	r26, 0x05	; 5
     a60:	2c 91       	ld	r18, X
     a62:	95 81       	ldd	r25, Z+5	; 0x05
     a64:	29 17       	cp	r18, r25
     a66:	59 f0       	breq	.+22     	; 0xa7e <tinyLED_RGB_Color_Compare+0x5e>
     a68:	80 e0       	ldi	r24, 0x00	; 0
     a6a:	08 95       	ret
			return false;
     a6c:	80 e0       	ldi	r24, 0x00	; 0
     a6e:	08 95       	ret
     a70:	80 e0       	ldi	r24, 0x00	; 0
     a72:	08 95       	ret
     a74:	80 e0       	ldi	r24, 0x00	; 0
     a76:	08 95       	ret
     a78:	80 e0       	ldi	r24, 0x00	; 0
     a7a:	08 95       	ret
     a7c:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	return true;
}
     a7e:	08 95       	ret

00000a80 <tinyLED_update>:
/*
function to write the current LED-array on to the LEDs and
effectively update the values stored in the LEDs to the values stored in the MCU.
*/
void tinyLED_update(void)
{
     a80:	2f 92       	push	r2
     a82:	3f 92       	push	r3
     a84:	4f 92       	push	r4
     a86:	5f 92       	push	r5
     a88:	6f 92       	push	r6
     a8a:	7f 92       	push	r7
     a8c:	8f 92       	push	r8
     a8e:	9f 92       	push	r9
     a90:	af 92       	push	r10
     a92:	bf 92       	push	r11
     a94:	cf 92       	push	r12
     a96:	df 92       	push	r13
     a98:	ef 92       	push	r14
     a9a:	ff 92       	push	r15
     a9c:	0f 93       	push	r16
     a9e:	1f 93       	push	r17
     aa0:	cf 93       	push	r28
     aa2:	df 93       	push	r29
     aa4:	cd b7       	in	r28, 0x3d	; 61
     aa6:	de b7       	in	r29, 0x3e	; 62
     aa8:	6e 97       	sbiw	r28, 0x1e	; 30
     aaa:	cd bf       	out	0x3d, r28	; 61
     aac:	de bf       	out	0x3e, r29	; 62
			
	uint32_t now = tinyTime_now();
     aae:	0e 94 ff 07 	call	0xffe	; 0xffe <tinyTime_now>
     ab2:	6b 01       	movw	r12, r22
     ab4:	7c 01       	movw	r14, r24
	
	// This is a sin curve, but between 0 and 1 instead of -1 and 1
	double sinValue = 0.5+sin((double)now/(100*M_PI/SWING_RATE))/2;
     ab6:	0e 94 55 09 	call	0x12aa	; 0x12aa <__floatunsisf>
     aba:	23 e6       	ldi	r18, 0x63	; 99
     abc:	34 e1       	ldi	r19, 0x14	; 20
     abe:	4d e9       	ldi	r20, 0x9D	; 157
     ac0:	53 e4       	ldi	r21, 0x43	; 67
     ac2:	0e 94 7a 08 	call	0x10f4	; 0x10f4 <__divsf3>
     ac6:	0e 94 35 0b 	call	0x166a	; 0x166a <sin>
     aca:	20 e0       	ldi	r18, 0x00	; 0
     acc:	30 e0       	ldi	r19, 0x00	; 0
     ace:	40 e0       	ldi	r20, 0x00	; 0
     ad0:	5f e3       	ldi	r21, 0x3F	; 63
     ad2:	0e 94 c8 0a 	call	0x1590	; 0x1590 <__mulsf3>
     ad6:	20 e0       	ldi	r18, 0x00	; 0
     ad8:	30 e0       	ldi	r19, 0x00	; 0
     ada:	40 e0       	ldi	r20, 0x00	; 0
     adc:	5f e3       	ldi	r21, 0x3F	; 63
     ade:	0e 94 09 08 	call	0x1012	; 0x1012 <__addsf3>
     ae2:	69 87       	std	Y+9, r22	; 0x09
     ae4:	7a 87       	std	Y+10, r23	; 0x0a
     ae6:	8b 87       	std	Y+11, r24	; 0x0b
     ae8:	9c 87       	std	Y+12, r25	; 0x0c
	
	// If FLASH_RATE is one, then that means that the left side of the "<" will just count from 0 to 1000, and flash_on will be true for half of the time
	_Bool flash_on = now%(uint32_t)(1000/FLASH_RATE)  <   500/FLASH_RATE;
     aea:	c7 01       	movw	r24, r14
     aec:	b6 01       	movw	r22, r12
     aee:	24 ef       	ldi	r18, 0xF4	; 244
     af0:	31 e0       	ldi	r19, 0x01	; 1
     af2:	40 e0       	ldi	r20, 0x00	; 0
     af4:	50 e0       	ldi	r21, 0x00	; 0
     af6:	0e 94 9e 0b 	call	0x173c	; 0x173c <__udivmodsi4>
     afa:	0e 94 55 09 	call	0x12aa	; 0x12aa <__floatunsisf>
     afe:	20 e0       	ldi	r18, 0x00	; 0
     b00:	30 e0       	ldi	r19, 0x00	; 0
     b02:	4a e7       	ldi	r20, 0x7A	; 122
     b04:	53 e4       	ldi	r21, 0x43	; 67
     b06:	0e 94 75 08 	call	0x10ea	; 0x10ea <__cmpsf2>
     b0a:	88 1f       	adc	r24, r24
     b0c:	88 27       	eor	r24, r24
     b0e:	88 1f       	adc	r24, r24
     b10:	8f 83       	std	Y+7, r24	; 0x07
	
	// PING_RATE is usually small, so the left side counts to some large number. Since flash_time usually is also quite small,
	// the left side will usually be larger than the right
	_Bool ping_on =  now%(uint32_t)(1000/PING_RATE)   <   1000*FLASH_TIME;
     b12:	c7 01       	movw	r24, r14
     b14:	b6 01       	movw	r22, r12
     b16:	28 e8       	ldi	r18, 0x88	; 136
     b18:	33 e1       	ldi	r19, 0x13	; 19
     b1a:	40 e0       	ldi	r20, 0x00	; 0
     b1c:	50 e0       	ldi	r21, 0x00	; 0
     b1e:	0e 94 9e 0b 	call	0x173c	; 0x173c <__udivmodsi4>
     b22:	0e 94 55 09 	call	0x12aa	; 0x12aa <__floatunsisf>
     b26:	20 e0       	ldi	r18, 0x00	; 0
     b28:	30 e0       	ldi	r19, 0x00	; 0
     b2a:	48 ec       	ldi	r20, 0xC8	; 200
     b2c:	52 e4       	ldi	r21, 0x42	; 66
     b2e:	0e 94 75 08 	call	0x10ea	; 0x10ea <__cmpsf2>
     b32:	88 1f       	adc	r24, r24
     b34:	88 27       	eor	r24, r24
     b36:	88 1f       	adc	r24, r24
     b38:	00 e6       	ldi	r16, 0x60	; 96
     b3a:	18 e3       	ldi	r17, 0x38	; 56
     b3c:	9e 01       	movw	r18, r28
     b3e:	2f 5f       	subi	r18, 0xFF	; 255
     b40:	3f 4f       	sbci	r19, 0xFF	; 255
     b42:	0f 2e       	mov	r0, r31
     b44:	f8 e5       	ldi	r31, 0x58	; 88
     b46:	4f 2e       	mov	r4, r31
     b48:	f8 e3       	ldi	r31, 0x38	; 56
     b4a:	5f 2e       	mov	r5, r31
     b4c:	f0 2d       	mov	r31, r0
     b4e:	0f 2e       	mov	r0, r31
     b50:	f4 e6       	ldi	r31, 0x64	; 100
     b52:	6f 2e       	mov	r6, r31
     b54:	f8 e3       	ldi	r31, 0x38	; 56
     b56:	7f 2e       	mov	r7, r31
     b58:	f0 2d       	mov	r31, r0
     b5a:	19 01       	movw	r2, r18
			case SWING:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*sinValue, rgb_colors[i].green*sinValue, rgb_colors[i].blue*sinValue};
				break;
			case PING:
				// in the line below, fmin will either return 1 or 0, so each rgb color is either 0 or 255*PING_BRIGHTNESS
				rgb_colors[i] = (struct RGB_Color){255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].red)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].green)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].blue)*ping_on};
     b5c:	88 2e       	mov	r8, r24
     b5e:	91 2c       	mov	r9, r1
     b60:	a1 2c       	mov	r10, r1
     b62:	b1 2c       	mov	r11, r1
     b64:	2d 87       	std	Y+13, r18	; 0x0d
     b66:	3e 87       	std	Y+14, r19	; 0x0e
     b68:	df 80       	ldd	r13, Y+7	; 0x07
     b6a:	f8 01       	movw	r30, r16
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 0 << TCA_SPLIT_ENABLE_bp; //Stop TCA
}

static struct RGB_Color tinyLED_enum_to_RGB_Color(enum Colors color){
	struct RGB_Color rgb_color;
	switch(color)
     b6c:	80 81       	ld	r24, Z
     b6e:	83 30       	cpi	r24, 0x03	; 3
     b70:	79 f0       	breq	.+30     	; 0xb90 <tinyLED_update+0x110>
     b72:	28 f4       	brcc	.+10     	; 0xb7e <tinyLED_update+0xfe>
     b74:	81 30       	cpi	r24, 0x01	; 1
     b76:	41 f0       	breq	.+16     	; 0xb88 <tinyLED_update+0x108>
     b78:	82 30       	cpi	r24, 0x02	; 2
     b7a:	89 f0       	breq	.+34     	; 0xb9e <tinyLED_update+0x11e>
     b7c:	28 c0       	rjmp	.+80     	; 0xbce <tinyLED_update+0x14e>
     b7e:	84 30       	cpi	r24, 0x04	; 4
     b80:	a9 f0       	breq	.+42     	; 0xbac <tinyLED_update+0x12c>
     b82:	85 30       	cpi	r24, 0x05	; 5
     b84:	d1 f0       	breq	.+52     	; 0xbba <tinyLED_update+0x13a>
     b86:	23 c0       	rjmp	.+70     	; 0xbce <tinyLED_update+0x14e>
	{
		case OFF:
			rgb_color = (struct RGB_Color){0, 0, 0};
			break;
		case RED:
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 0, 0};
     b88:	f1 2c       	mov	r15, r1
     b8a:	e1 2c       	mov	r14, r1
     b8c:	69 e1       	ldi	r22, 0x19	; 25
     b8e:	22 c0       	rjmp	.+68     	; 0xbd4 <tinyLED_update+0x154>
			break;
		case GREEN:
			rgb_color = (struct RGB_Color){0, 255*LED_BRIGHTNESS, 0};
     b90:	f1 2c       	mov	r15, r1
     b92:	0f 2e       	mov	r0, r31
     b94:	f9 e1       	ldi	r31, 0x19	; 25
     b96:	ef 2e       	mov	r14, r31
     b98:	f0 2d       	mov	r31, r0
     b9a:	60 e0       	ldi	r22, 0x00	; 0
     b9c:	1b c0       	rjmp	.+54     	; 0xbd4 <tinyLED_update+0x154>
			break;
		case BLUE:
			rgb_color = (struct RGB_Color){0, 0, 255*LED_BRIGHTNESS};
     b9e:	0f 2e       	mov	r0, r31
     ba0:	f9 e1       	ldi	r31, 0x19	; 25
     ba2:	ff 2e       	mov	r15, r31
     ba4:	f0 2d       	mov	r31, r0
     ba6:	e1 2c       	mov	r14, r1
     ba8:	60 e0       	ldi	r22, 0x00	; 0
     baa:	14 c0       	rjmp	.+40     	; 0xbd4 <tinyLED_update+0x154>
			break;
		case YELLOW:
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS, 0};
     bac:	f1 2c       	mov	r15, r1
     bae:	0f 2e       	mov	r0, r31
     bb0:	f9 e1       	ldi	r31, 0x19	; 25
     bb2:	ef 2e       	mov	r14, r31
     bb4:	f0 2d       	mov	r31, r0
     bb6:	69 e1       	ldi	r22, 0x19	; 25
     bb8:	0d c0       	rjmp	.+26     	; 0xbd4 <tinyLED_update+0x154>
			// Should the /3 be there? This requires testing.
			// After testing, findings were that at 0.1 brightness, one would see the three LEDs instead of one white led
			// We try with /2 instead.
			// We find that the best results come from not dividing by anything. At leasts in the lower brightness settings, and that
			// is where we suspect it will be most of the time. When we divide, the LEDs are so weak, that they appear as three lights instead of one.
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS};
     bba:	0f 2e       	mov	r0, r31
     bbc:	f9 e1       	ldi	r31, 0x19	; 25
     bbe:	ff 2e       	mov	r15, r31
     bc0:	f0 2d       	mov	r31, r0
     bc2:	0f 2e       	mov	r0, r31
     bc4:	f9 e1       	ldi	r31, 0x19	; 25
     bc6:	ef 2e       	mov	r14, r31
     bc8:	f0 2d       	mov	r31, r0
     bca:	69 e1       	ldi	r22, 0x19	; 25
     bcc:	03 c0       	rjmp	.+6      	; 0xbd4 <tinyLED_update+0x154>
static struct RGB_Color tinyLED_enum_to_RGB_Color(enum Colors color){
	struct RGB_Color rgb_color;
	switch(color)
	{
		case OFF:
			rgb_color = (struct RGB_Color){0, 0, 0};
     bce:	f1 2c       	mov	r15, r1
     bd0:	e1 2c       	mov	r14, r1
     bd2:	60 e0       	ldi	r22, 0x00	; 0
     bd4:	2f 82       	std	Y+7, r2	; 0x07
     bd6:	38 86       	std	Y+8, r3	; 0x08
	
		
	for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
	{		
		// Convert enum to RGB_Color
		rgb_colors[i] = tinyLED_enum_to_RGB_Color(tinyLED_colors[i].color);
     bd8:	d1 01       	movw	r26, r2
     bda:	6c 93       	st	X, r22
     bdc:	11 96       	adiw	r26, 0x01	; 1
     bde:	ec 92       	st	X, r14
     be0:	11 97       	sbiw	r26, 0x01	; 1
     be2:	12 96       	adiw	r26, 0x02	; 2
     be4:	fc 92       	st	X, r15
			
		// Adjust colors according to mode
		switch(tinyLED_colors[i].mode)
     be6:	81 81       	ldd	r24, Z+1	; 0x01
     be8:	82 30       	cpi	r24, 0x02	; 2
     bea:	d1 f0       	breq	.+52     	; 0xc20 <tinyLED_update+0x1a0>
     bec:	18 f4       	brcc	.+6      	; 0xbf4 <tinyLED_update+0x174>
     bee:	81 30       	cpi	r24, 0x01	; 1
     bf0:	41 f0       	breq	.+16     	; 0xc02 <tinyLED_update+0x182>
     bf2:	cd c0       	rjmp	.+410    	; 0xd8e <tinyLED_update+0x30e>
     bf4:	83 30       	cpi	r24, 0x03	; 3
     bf6:	09 f4       	brne	.+2      	; 0xbfa <tinyLED_update+0x17a>
     bf8:	44 c0       	rjmp	.+136    	; 0xc82 <tinyLED_update+0x202>
     bfa:	84 30       	cpi	r24, 0x04	; 4
     bfc:	09 f4       	brne	.+2      	; 0xc00 <tinyLED_update+0x180>
     bfe:	bf c0       	rjmp	.+382    	; 0xd7e <tinyLED_update+0x2fe>
     c00:	c6 c0       	rjmp	.+396    	; 0xd8e <tinyLED_update+0x30e>
		{
			case STABLE:
				break;
			case FLASH:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*flash_on, rgb_colors[i].green*flash_on, rgb_colors[i].blue*flash_on};
     c02:	d6 9e       	mul	r13, r22
     c04:	60 2d       	mov	r22, r0
     c06:	11 24       	eor	r1, r1
     c08:	ef 81       	ldd	r30, Y+7	; 0x07
     c0a:	f8 85       	ldd	r31, Y+8	; 0x08
     c0c:	60 83       	st	Z, r22
     c0e:	de 9c       	mul	r13, r14
     c10:	e0 2c       	mov	r14, r0
     c12:	11 24       	eor	r1, r1
     c14:	e1 82       	std	Z+1, r14	; 0x01
     c16:	df 9c       	mul	r13, r15
     c18:	f0 2c       	mov	r15, r0
     c1a:	11 24       	eor	r1, r1
     c1c:	f2 82       	std	Z+2, r15	; 0x02
				break;
     c1e:	b7 c0       	rjmp	.+366    	; 0xd8e <tinyLED_update+0x30e>
			case SWING:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*sinValue, rgb_colors[i].green*sinValue, rgb_colors[i].blue*sinValue};
     c20:	70 e0       	ldi	r23, 0x00	; 0
     c22:	80 e0       	ldi	r24, 0x00	; 0
     c24:	90 e0       	ldi	r25, 0x00	; 0
     c26:	0e 94 57 09 	call	0x12ae	; 0x12ae <__floatsisf>
     c2a:	29 85       	ldd	r18, Y+9	; 0x09
     c2c:	3a 85       	ldd	r19, Y+10	; 0x0a
     c2e:	4b 85       	ldd	r20, Y+11	; 0x0b
     c30:	5c 85       	ldd	r21, Y+12	; 0x0c
     c32:	0e 94 c8 0a 	call	0x1590	; 0x1590 <__mulsf3>
     c36:	0e 94 26 09 	call	0x124c	; 0x124c <__fixunssfsi>
     c3a:	d1 01       	movw	r26, r2
     c3c:	6c 93       	st	X, r22
     c3e:	6e 2d       	mov	r22, r14
     c40:	70 e0       	ldi	r23, 0x00	; 0
     c42:	80 e0       	ldi	r24, 0x00	; 0
     c44:	90 e0       	ldi	r25, 0x00	; 0
     c46:	0e 94 57 09 	call	0x12ae	; 0x12ae <__floatsisf>
     c4a:	29 85       	ldd	r18, Y+9	; 0x09
     c4c:	3a 85       	ldd	r19, Y+10	; 0x0a
     c4e:	4b 85       	ldd	r20, Y+11	; 0x0b
     c50:	5c 85       	ldd	r21, Y+12	; 0x0c
     c52:	0e 94 c8 0a 	call	0x1590	; 0x1590 <__mulsf3>
     c56:	0e 94 26 09 	call	0x124c	; 0x124c <__fixunssfsi>
     c5a:	f1 01       	movw	r30, r2
     c5c:	61 83       	std	Z+1, r22	; 0x01
     c5e:	6f 2d       	mov	r22, r15
     c60:	70 e0       	ldi	r23, 0x00	; 0
     c62:	80 e0       	ldi	r24, 0x00	; 0
     c64:	90 e0       	ldi	r25, 0x00	; 0
     c66:	0e 94 57 09 	call	0x12ae	; 0x12ae <__floatsisf>
     c6a:	29 85       	ldd	r18, Y+9	; 0x09
     c6c:	3a 85       	ldd	r19, Y+10	; 0x0a
     c6e:	4b 85       	ldd	r20, Y+11	; 0x0b
     c70:	5c 85       	ldd	r21, Y+12	; 0x0c
     c72:	0e 94 c8 0a 	call	0x1590	; 0x1590 <__mulsf3>
     c76:	0e 94 26 09 	call	0x124c	; 0x124c <__fixunssfsi>
     c7a:	d1 01       	movw	r26, r2
     c7c:	12 96       	adiw	r26, 0x02	; 2
     c7e:	6c 93       	st	X, r22
				break;
     c80:	86 c0       	rjmp	.+268    	; 0xd8e <tinyLED_update+0x30e>
			case PING:
				// in the line below, fmin will either return 1 or 0, so each rgb color is either 0 or 255*PING_BRIGHTNESS
				rgb_colors[i] = (struct RGB_Color){255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].red)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].green)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].blue)*ping_on};
     c82:	70 e0       	ldi	r23, 0x00	; 0
     c84:	80 e0       	ldi	r24, 0x00	; 0
     c86:	90 e0       	ldi	r25, 0x00	; 0
     c88:	0e 94 55 09 	call	0x12aa	; 0x12aa <__floatunsisf>
     c8c:	9b 01       	movw	r18, r22
     c8e:	ac 01       	movw	r20, r24
     c90:	60 e0       	ldi	r22, 0x00	; 0
     c92:	70 e0       	ldi	r23, 0x00	; 0
     c94:	80 e8       	ldi	r24, 0x80	; 128
     c96:	9f e3       	ldi	r25, 0x3F	; 63
     c98:	0e 94 92 09 	call	0x1324	; 0x1324 <fmin>
     c9c:	6b 8b       	std	Y+19, r22	; 0x13
     c9e:	7c 8b       	std	Y+20, r23	; 0x14
     ca0:	8d 8b       	std	Y+21, r24	; 0x15
     ca2:	9e 8b       	std	Y+22, r25	; 0x16
     ca4:	c5 01       	movw	r24, r10
     ca6:	b4 01       	movw	r22, r8
     ca8:	0e 94 57 09 	call	0x12ae	; 0x12ae <__floatsisf>
     cac:	6f 87       	std	Y+15, r22	; 0x0f
     cae:	78 8b       	std	Y+16, r23	; 0x10
     cb0:	89 8b       	std	Y+17, r24	; 0x11
     cb2:	9a 8b       	std	Y+18, r25	; 0x12
     cb4:	6e 2d       	mov	r22, r14
     cb6:	70 e0       	ldi	r23, 0x00	; 0
     cb8:	80 e0       	ldi	r24, 0x00	; 0
     cba:	90 e0       	ldi	r25, 0x00	; 0
     cbc:	0e 94 55 09 	call	0x12aa	; 0x12aa <__floatunsisf>
     cc0:	9b 01       	movw	r18, r22
     cc2:	ac 01       	movw	r20, r24
     cc4:	60 e0       	ldi	r22, 0x00	; 0
     cc6:	70 e0       	ldi	r23, 0x00	; 0
     cc8:	80 e8       	ldi	r24, 0x80	; 128
     cca:	9f e3       	ldi	r25, 0x3F	; 63
     ccc:	0e 94 92 09 	call	0x1324	; 0x1324 <fmin>
     cd0:	6f 8b       	std	Y+23, r22	; 0x17
     cd2:	78 8f       	std	Y+24, r23	; 0x18
     cd4:	89 8f       	std	Y+25, r24	; 0x19
     cd6:	9a 8f       	std	Y+26, r25	; 0x1a
     cd8:	6f 2d       	mov	r22, r15
     cda:	70 e0       	ldi	r23, 0x00	; 0
     cdc:	80 e0       	ldi	r24, 0x00	; 0
     cde:	90 e0       	ldi	r25, 0x00	; 0
     ce0:	0e 94 55 09 	call	0x12aa	; 0x12aa <__floatunsisf>
     ce4:	9b 01       	movw	r18, r22
     ce6:	ac 01       	movw	r20, r24
     ce8:	60 e0       	ldi	r22, 0x00	; 0
     cea:	70 e0       	ldi	r23, 0x00	; 0
     cec:	80 e8       	ldi	r24, 0x80	; 128
     cee:	9f e3       	ldi	r25, 0x3F	; 63
     cf0:	0e 94 92 09 	call	0x1324	; 0x1324 <fmin>
     cf4:	6b 8f       	std	Y+27, r22	; 0x1b
     cf6:	7c 8f       	std	Y+28, r23	; 0x1c
     cf8:	8d 8f       	std	Y+29, r24	; 0x1d
     cfa:	9e 8f       	std	Y+30, r25	; 0x1e
     cfc:	23 e3       	ldi	r18, 0x33	; 51
     cfe:	33 e3       	ldi	r19, 0x33	; 51
     d00:	43 ea       	ldi	r20, 0xA3	; 163
     d02:	50 e4       	ldi	r21, 0x40	; 64
     d04:	6b 89       	ldd	r22, Y+19	; 0x13
     d06:	7c 89       	ldd	r23, Y+20	; 0x14
     d08:	8d 89       	ldd	r24, Y+21	; 0x15
     d0a:	9e 89       	ldd	r25, Y+22	; 0x16
     d0c:	0e 94 c8 0a 	call	0x1590	; 0x1590 <__mulsf3>
     d10:	2f 85       	ldd	r18, Y+15	; 0x0f
     d12:	38 89       	ldd	r19, Y+16	; 0x10
     d14:	49 89       	ldd	r20, Y+17	; 0x11
     d16:	5a 89       	ldd	r21, Y+18	; 0x12
     d18:	0e 94 c8 0a 	call	0x1590	; 0x1590 <__mulsf3>
     d1c:	0e 94 26 09 	call	0x124c	; 0x124c <__fixunssfsi>
     d20:	ef 81       	ldd	r30, Y+7	; 0x07
     d22:	f8 85       	ldd	r31, Y+8	; 0x08
     d24:	60 83       	st	Z, r22
     d26:	23 e3       	ldi	r18, 0x33	; 51
     d28:	33 e3       	ldi	r19, 0x33	; 51
     d2a:	43 ea       	ldi	r20, 0xA3	; 163
     d2c:	50 e4       	ldi	r21, 0x40	; 64
     d2e:	6f 89       	ldd	r22, Y+23	; 0x17
     d30:	78 8d       	ldd	r23, Y+24	; 0x18
     d32:	89 8d       	ldd	r24, Y+25	; 0x19
     d34:	9a 8d       	ldd	r25, Y+26	; 0x1a
     d36:	0e 94 c8 0a 	call	0x1590	; 0x1590 <__mulsf3>
     d3a:	2f 85       	ldd	r18, Y+15	; 0x0f
     d3c:	38 89       	ldd	r19, Y+16	; 0x10
     d3e:	49 89       	ldd	r20, Y+17	; 0x11
     d40:	5a 89       	ldd	r21, Y+18	; 0x12
     d42:	0e 94 c8 0a 	call	0x1590	; 0x1590 <__mulsf3>
     d46:	0e 94 26 09 	call	0x124c	; 0x124c <__fixunssfsi>
     d4a:	af 81       	ldd	r26, Y+7	; 0x07
     d4c:	b8 85       	ldd	r27, Y+8	; 0x08
     d4e:	11 96       	adiw	r26, 0x01	; 1
     d50:	6c 93       	st	X, r22
     d52:	23 e3       	ldi	r18, 0x33	; 51
     d54:	33 e3       	ldi	r19, 0x33	; 51
     d56:	43 ea       	ldi	r20, 0xA3	; 163
     d58:	50 e4       	ldi	r21, 0x40	; 64
     d5a:	6b 8d       	ldd	r22, Y+27	; 0x1b
     d5c:	7c 8d       	ldd	r23, Y+28	; 0x1c
     d5e:	8d 8d       	ldd	r24, Y+29	; 0x1d
     d60:	9e 8d       	ldd	r25, Y+30	; 0x1e
     d62:	0e 94 c8 0a 	call	0x1590	; 0x1590 <__mulsf3>
     d66:	2f 85       	ldd	r18, Y+15	; 0x0f
     d68:	38 89       	ldd	r19, Y+16	; 0x10
     d6a:	49 89       	ldd	r20, Y+17	; 0x11
     d6c:	5a 89       	ldd	r21, Y+18	; 0x12
     d6e:	0e 94 c8 0a 	call	0x1590	; 0x1590 <__mulsf3>
     d72:	0e 94 26 09 	call	0x124c	; 0x124c <__fixunssfsi>
     d76:	ef 81       	ldd	r30, Y+7	; 0x07
     d78:	f8 85       	ldd	r31, Y+8	; 0x08
     d7a:	62 83       	std	Z+2, r22	; 0x02
				break;
     d7c:	08 c0       	rjmp	.+16     	; 0xd8e <tinyLED_update+0x30e>
			case FLASH_ONCE:
				if(tinyLED_flash_once_time[i]>0){
     d7e:	d2 01       	movw	r26, r4
     d80:	8c 91       	ld	r24, X
     d82:	88 23       	and	r24, r24
     d84:	19 f0       	breq	.+6      	; 0xd8c <tinyLED_update+0x30c>
					rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red, rgb_colors[i].green, rgb_colors[i].blue};
					tinyLED_flash_once_time[i]--;
     d86:	81 50       	subi	r24, 0x01	; 1
     d88:	8c 93       	st	X, r24
     d8a:	01 c0       	rjmp	.+2      	; 0xd8e <tinyLED_update+0x30e>
				}
				else{
					tinyLED_colors[i].color = OFF;
     d8c:	10 82       	st	Z, r1
     d8e:	0e 5f       	subi	r16, 0xFE	; 254
     d90:	1f 4f       	sbci	r17, 0xFF	; 255
     d92:	b3 e0       	ldi	r27, 0x03	; 3
     d94:	2b 0e       	add	r2, r27
     d96:	31 1c       	adc	r3, r1
     d98:	ef ef       	ldi	r30, 0xFF	; 255
     d9a:	4e 1a       	sub	r4, r30
     d9c:	5e 0a       	sbc	r5, r30
	
	// This is where we store all the actual color values we want to send to the LED
	struct RGB_Color rgb_colors[NUMBER_OF_LEDS];
	
		
	for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
     d9e:	06 15       	cp	r16, r6
     da0:	17 05       	cpc	r17, r7
     da2:	09 f0       	breq	.+2      	; 0xda6 <tinyLED_update+0x326>
     da4:	e2 ce       	rjmp	.-572    	; 0xb6a <tinyLED_update+0xea>
     da6:	cd 84       	ldd	r12, Y+13	; 0x0d
     da8:	de 84       	ldd	r13, Y+14	; 0x0e
				break;
		}
	}
	
	// We only write to the LEDs if there is something to change. (eg. in SWING mode, we update the LEDs almost every cycle)
	if(!tinyLED_RGB_Color_Compare(&rgb_colors, &tinyLED_old_colors)){
     daa:	6a e5       	ldi	r22, 0x5A	; 90
     dac:	78 e3       	ldi	r23, 0x38	; 56
     dae:	ce 01       	movw	r24, r28
     db0:	01 96       	adiw	r24, 0x01	; 1
     db2:	0e 94 10 05 	call	0xa20	; 0xa20 <tinyLED_RGB_Color_Compare>
     db6:	81 11       	cpse	r24, r1
     db8:	2f c0       	rjmp	.+94     	; 0xe18 <tinyLED_update+0x398>
     dba:	0a e5       	ldi	r16, 0x5A	; 90
     dbc:	18 e3       	ldi	r17, 0x38	; 56
     dbe:	7e 01       	movw	r14, r28
     dc0:	f7 e0       	ldi	r31, 0x07	; 7
     dc2:	ef 0e       	add	r14, r31
     dc4:	f1 1c       	adc	r15, r1
		for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
		{
			// Write to LEDs
			//For some reason, the data-bus to the LEDs is serialized as GRB
			//which means the 24-bit data-bus will look like [Green[0:7], Red[0:7], Blue[0:7]]
			tinyLED_SPIWriteByte(rgb_colors[i].green);
     dc6:	d6 01       	movw	r26, r12
     dc8:	11 96       	adiw	r26, 0x01	; 1
     dca:	8c 91       	ld	r24, X
     dcc:	0e 94 db 04 	call	0x9b6	; 0x9b6 <tinyLED_SPIWriteByte>
			tinyLED_SPIWriteByte(rgb_colors[i].red);
     dd0:	f6 01       	movw	r30, r12
     dd2:	80 81       	ld	r24, Z
     dd4:	0e 94 db 04 	call	0x9b6	; 0x9b6 <tinyLED_SPIWriteByte>
			tinyLED_SPIWriteByte(rgb_colors[i].blue);
     dd8:	d6 01       	movw	r26, r12
     dda:	12 96       	adiw	r26, 0x02	; 2
     ddc:	8c 91       	ld	r24, X
     dde:	0e 94 db 04 	call	0x9b6	; 0x9b6 <tinyLED_SPIWriteByte>
			tinyLED_old_colors[i] = rgb_colors[i];
     de2:	f6 01       	movw	r30, r12
     de4:	81 91       	ld	r24, Z+
     de6:	91 91       	ld	r25, Z+
     de8:	a1 91       	ld	r26, Z+
     dea:	6f 01       	movw	r12, r30
     dec:	f8 01       	movw	r30, r16
     dee:	81 93       	st	Z+, r24
     df0:	91 93       	st	Z+, r25
     df2:	a1 93       	st	Z+, r26
     df4:	8f 01       	movw	r16, r30
		}
	}
	
	// We only write to the LEDs if there is something to change. (eg. in SWING mode, we update the LEDs almost every cycle)
	if(!tinyLED_RGB_Color_Compare(&rgb_colors, &tinyLED_old_colors)){
		for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
     df6:	ce 14       	cp	r12, r14
     df8:	df 04       	cpc	r13, r15
     dfa:	29 f7       	brne	.-54     	; 0xdc6 <tinyLED_update+0x346>
			tinyLED_SPIWriteByte(rgb_colors[i].green);
			tinyLED_SPIWriteByte(rgb_colors[i].red);
			tinyLED_SPIWriteByte(rgb_colors[i].blue);
			tinyLED_old_colors[i] = rgb_colors[i];
		}
		tinyDebugger_send_uint8("LED1 color", tinyLED_colors[0].color);
     dfc:	00 e6       	ldi	r16, 0x60	; 96
     dfe:	18 e3       	ldi	r17, 0x38	; 56
     e00:	d8 01       	movw	r26, r16
     e02:	6c 91       	ld	r22, X
     e04:	84 ea       	ldi	r24, 0xA4	; 164
     e06:	97 e9       	ldi	r25, 0x97	; 151
     e08:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <tinyDebugger_send_uint8>
		tinyDebugger_send_uint8("LED2 color", tinyLED_colors[1].color);
     e0c:	f8 01       	movw	r30, r16
     e0e:	62 81       	ldd	r22, Z+2	; 0x02
     e10:	8f ea       	ldi	r24, 0xAF	; 175
     e12:	97 e9       	ldi	r25, 0x97	; 151
     e14:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <tinyDebugger_send_uint8>
	}
}
     e18:	6e 96       	adiw	r28, 0x1e	; 30
     e1a:	cd bf       	out	0x3d, r28	; 61
     e1c:	de bf       	out	0x3e, r29	; 62
     e1e:	df 91       	pop	r29
     e20:	cf 91       	pop	r28
     e22:	1f 91       	pop	r17
     e24:	0f 91       	pop	r16
     e26:	ff 90       	pop	r15
     e28:	ef 90       	pop	r14
     e2a:	df 90       	pop	r13
     e2c:	cf 90       	pop	r12
     e2e:	bf 90       	pop	r11
     e30:	af 90       	pop	r10
     e32:	9f 90       	pop	r9
     e34:	8f 90       	pop	r8
     e36:	7f 90       	pop	r7
     e38:	6f 90       	pop	r6
     e3a:	5f 90       	pop	r5
     e3c:	4f 90       	pop	r4
     e3e:	3f 90       	pop	r3
     e40:	2f 90       	pop	r2
     e42:	08 95       	ret

00000e44 <tinyPotential_update>:

/*
Update the potential
*/
void tinyPotential_update()
{
     e44:	cf 92       	push	r12
     e46:	df 92       	push	r13
     e48:	ef 92       	push	r14
     e4a:	ff 92       	push	r15
Function to decay the potential towards 0
*/
static void tinyPotential_decay()
{
		
	uint8_t time_since_last_update = tinyTime_now() - previous_update_time;
     e4c:	0e 94 ff 07 	call	0xffe	; 0xffe <tinyTime_now>
	tinyPotential_potential *= (exp(-((float)time_since_last_update/(float)TINYPOTENTIAL_TIME_CONST)));
     e50:	80 91 44 38 	lds	r24, 0x3844	; 0x803844 <previous_update_time>
     e54:	68 1b       	sub	r22, r24
     e56:	70 e0       	ldi	r23, 0x00	; 0
     e58:	80 e0       	ldi	r24, 0x00	; 0
     e5a:	90 e0       	ldi	r25, 0x00	; 0
     e5c:	0e 94 55 09 	call	0x12aa	; 0x12aa <__floatunsisf>
     e60:	20 e0       	ldi	r18, 0x00	; 0
     e62:	30 e0       	ldi	r19, 0x00	; 0
     e64:	48 ec       	ldi	r20, 0xC8	; 200
     e66:	52 e4       	ldi	r21, 0x42	; 66
     e68:	0e 94 7a 08 	call	0x10f4	; 0x10f4 <__divsf3>
     e6c:	90 58       	subi	r25, 0x80	; 128
     e6e:	0e 94 f4 08 	call	0x11e8	; 0x11e8 <exp>
     e72:	20 91 48 38 	lds	r18, 0x3848	; 0x803848 <tinyPotential_potential>
     e76:	30 91 49 38 	lds	r19, 0x3849	; 0x803849 <tinyPotential_potential+0x1>
     e7a:	40 91 4a 38 	lds	r20, 0x384A	; 0x80384a <tinyPotential_potential+0x2>
     e7e:	50 91 4b 38 	lds	r21, 0x384B	; 0x80384b <tinyPotential_potential+0x3>
     e82:	0e 94 c8 0a 	call	0x1590	; 0x1590 <__mulsf3>
     e86:	6b 01       	movw	r12, r22
     e88:	7c 01       	movw	r14, r24
	if(fabs(tinyPotential_potential)<0.1){
     e8a:	9f 77       	andi	r25, 0x7F	; 127
     e8c:	2d ec       	ldi	r18, 0xCD	; 205
     e8e:	3c ec       	ldi	r19, 0xCC	; 204
     e90:	4c ec       	ldi	r20, 0xCC	; 204
     e92:	5d e3       	ldi	r21, 0x3D	; 61
     e94:	0e 94 75 08 	call	0x10ea	; 0x10ea <__cmpsf2>
     e98:	88 23       	and	r24, r24
     e9a:	4c f0       	brlt	.+18     	; 0xeae <tinyPotential_update+0x6a>
*/
static void tinyPotential_decay()
{
		
	uint8_t time_since_last_update = tinyTime_now() - previous_update_time;
	tinyPotential_potential *= (exp(-((float)time_since_last_update/(float)TINYPOTENTIAL_TIME_CONST)));
     e9c:	c0 92 48 38 	sts	0x3848, r12	; 0x803848 <tinyPotential_potential>
     ea0:	d0 92 49 38 	sts	0x3849, r13	; 0x803849 <tinyPotential_potential+0x1>
     ea4:	e0 92 4a 38 	sts	0x384A, r14	; 0x80384a <tinyPotential_potential+0x2>
     ea8:	f0 92 4b 38 	sts	0x384B, r15	; 0x80384b <tinyPotential_potential+0x3>
     eac:	08 c0       	rjmp	.+16     	; 0xebe <tinyPotential_update+0x7a>
	if(fabs(tinyPotential_potential)<0.1){
		tinyPotential_potential=0;
     eae:	10 92 48 38 	sts	0x3848, r1	; 0x803848 <tinyPotential_potential>
     eb2:	10 92 49 38 	sts	0x3849, r1	; 0x803849 <tinyPotential_potential+0x1>
     eb6:	10 92 4a 38 	sts	0x384A, r1	; 0x80384a <tinyPotential_potential+0x2>
     eba:	10 92 4b 38 	sts	0x384B, r1	; 0x80384b <tinyPotential_potential+0x3>
	}
	previous_update_time = tinyTime_now();
     ebe:	0e 94 ff 07 	call	0xffe	; 0xffe <tinyTime_now>
     ec2:	60 93 44 38 	sts	0x3844, r22	; 0x803844 <previous_update_time>
     ec6:	70 93 45 38 	sts	0x3845, r23	; 0x803845 <previous_update_time+0x1>
     eca:	80 93 46 38 	sts	0x3846, r24	; 0x803846 <previous_update_time+0x2>
     ece:	90 93 47 38 	sts	0x3847, r25	; 0x803847 <previous_update_time+0x3>
void tinyPotential_update()
{
	//Some of the potential in the neuron has decayed away
	tinyPotential_decay();
	// Update potential with values from Dendrites
	tinyPotential_potential = tinyDendrite_update_potential(tinyPotential_potential);
     ed2:	60 91 48 38 	lds	r22, 0x3848	; 0x803848 <tinyPotential_potential>
     ed6:	70 91 49 38 	lds	r23, 0x3849	; 0x803849 <tinyPotential_potential+0x1>
     eda:	80 91 4a 38 	lds	r24, 0x384A	; 0x80384a <tinyPotential_potential+0x2>
     ede:	90 91 4b 38 	lds	r25, 0x384B	; 0x80384b <tinyPotential_potential+0x3>
     ee2:	0e 94 93 04 	call	0x926	; 0x926 <tinyDendrite_update_potential>
     ee6:	60 93 48 38 	sts	0x3848, r22	; 0x803848 <tinyPotential_potential>
     eea:	70 93 49 38 	sts	0x3849, r23	; 0x803849 <tinyPotential_potential+0x1>
     eee:	80 93 4a 38 	sts	0x384A, r24	; 0x80384a <tinyPotential_potential+0x2>
     ef2:	90 93 4b 38 	sts	0x384B, r25	; 0x80384b <tinyPotential_potential+0x3>
	
	// Update potential from button press
	tinyPotential_potential = tinyButton_update_potential(tinyPotential_potential);
     ef6:	0e 94 8d 03 	call	0x71a	; 0x71a <tinyButton_update_potential>
     efa:	60 93 48 38 	sts	0x3848, r22	; 0x803848 <tinyPotential_potential>
     efe:	70 93 49 38 	sts	0x3849, r23	; 0x803849 <tinyPotential_potential+0x1>
     f02:	80 93 4a 38 	sts	0x384A, r24	; 0x80384a <tinyPotential_potential+0x2>
     f06:	90 93 4b 38 	sts	0x384B, r25	; 0x80384b <tinyPotential_potential+0x3>
	
	// Update potential with values from spontaneous pulse.
	tinyPotential_potential = tinyPulse_update_potential(tinyPotential_potential);
     f0a:	0e 94 b3 07 	call	0xf66	; 0xf66 <tinyPulse_update_potential>
     f0e:	ab 01       	movw	r20, r22
     f10:	bc 01       	movw	r22, r24
     f12:	40 93 48 38 	sts	0x3848, r20	; 0x803848 <tinyPotential_potential>
     f16:	50 93 49 38 	sts	0x3849, r21	; 0x803849 <tinyPotential_potential+0x1>
     f1a:	60 93 4a 38 	sts	0x384A, r22	; 0x80384a <tinyPotential_potential+0x2>
     f1e:	70 93 4b 38 	sts	0x384B, r23	; 0x80384b <tinyPotential_potential+0x3>
	
	tinyDebugger_send_double("Potential", tinyPotential_potential);
     f22:	8a eb       	ldi	r24, 0xBA	; 186
     f24:	97 e9       	ldi	r25, 0x97	; 151
     f26:	0e 94 da 03 	call	0x7b4	; 0x7b4 <tinyDebugger_send_double>
	
	
	// Let the axon affect the potential
	// This is also where we decide whether or not the axon should fire
	tinyPotential_potential = tinyAxon_update_potential(tinyPotential_potential);
     f2a:	60 91 48 38 	lds	r22, 0x3848	; 0x803848 <tinyPotential_potential>
     f2e:	70 91 49 38 	lds	r23, 0x3849	; 0x803849 <tinyPotential_potential+0x1>
     f32:	80 91 4a 38 	lds	r24, 0x384A	; 0x80384a <tinyPotential_potential+0x2>
     f36:	90 91 4b 38 	lds	r25, 0x384B	; 0x80384b <tinyPotential_potential+0x3>
     f3a:	0e 94 84 02 	call	0x508	; 0x508 <tinyAxon_update_potential>
     f3e:	60 93 48 38 	sts	0x3848, r22	; 0x803848 <tinyPotential_potential>
     f42:	70 93 49 38 	sts	0x3849, r23	; 0x803849 <tinyPotential_potential+0x1>
     f46:	80 93 4a 38 	sts	0x384A, r24	; 0x80384a <tinyPotential_potential+0x2>
     f4a:	90 93 4b 38 	sts	0x384B, r25	; 0x80384b <tinyPotential_potential+0x3>
}
     f4e:	ff 90       	pop	r15
     f50:	ef 90       	pop	r14
     f52:	df 90       	pop	r13
     f54:	cf 90       	pop	r12
     f56:	08 95       	ret

00000f58 <tinyPulse_toggle_pulse_mode>:
uint32_t time_of_last_pulse = 0;
uint16_t time_since_last_pulse = 0;
uint16_t ideal_time_between_pulses = 1000/PULSEMODE_FREQUENCY;

void tinyPulse_toggle_pulse_mode(){
	pulse_mode = !pulse_mode;
     f58:	90 91 52 38 	lds	r25, 0x3852	; 0x803852 <pulse_mode>
     f5c:	81 e0       	ldi	r24, 0x01	; 1
     f5e:	89 27       	eor	r24, r25
     f60:	80 93 52 38 	sts	0x3852, r24	; 0x803852 <pulse_mode>
     f64:	08 95       	ret

00000f66 <tinyPulse_update_potential>:
}

double tinyPulse_update_potential(double potential){
     f66:	cf 92       	push	r12
     f68:	df 92       	push	r13
     f6a:	ef 92       	push	r14
     f6c:	ff 92       	push	r15
     f6e:	6b 01       	movw	r12, r22
     f70:	7c 01       	movw	r14, r24
	if(pulse_mode){
     f72:	80 91 52 38 	lds	r24, 0x3852	; 0x803852 <pulse_mode>
     f76:	88 23       	and	r24, r24
     f78:	39 f1       	breq	.+78     	; 0xfc8 <tinyPulse_update_potential+0x62>
		
		time_since_last_pulse = tinyTime_now() - time_of_last_pulse;
     f7a:	0e 94 ff 07 	call	0xffe	; 0xffe <tinyTime_now>
     f7e:	20 91 4e 38 	lds	r18, 0x384E	; 0x80384e <time_of_last_pulse>
     f82:	30 91 4f 38 	lds	r19, 0x384F	; 0x80384f <time_of_last_pulse+0x1>
     f86:	62 1b       	sub	r22, r18
     f88:	73 0b       	sbc	r23, r19
     f8a:	60 93 4c 38 	sts	0x384C, r22	; 0x80384c <time_since_last_pulse>
     f8e:	70 93 4d 38 	sts	0x384D, r23	; 0x80384d <time_since_last_pulse+0x1>
		
		if(time_since_last_pulse >= ideal_time_between_pulses){
     f92:	80 91 13 38 	lds	r24, 0x3813	; 0x803813 <ideal_time_between_pulses>
     f96:	90 91 14 38 	lds	r25, 0x3814	; 0x803814 <ideal_time_between_pulses+0x1>
     f9a:	68 17       	cp	r22, r24
     f9c:	79 07       	cpc	r23, r25
     f9e:	a0 f0       	brcs	.+40     	; 0xfc8 <tinyPulse_update_potential+0x62>
			// This isn't actually a button press. You could have a separate variable for this, but it seems unnecessary.
			potential += BUTTON_PRESS_REACTION;
     fa0:	20 e0       	ldi	r18, 0x00	; 0
     fa2:	30 e0       	ldi	r19, 0x00	; 0
     fa4:	40 ed       	ldi	r20, 0xD0	; 208
     fa6:	51 e4       	ldi	r21, 0x41	; 65
     fa8:	c7 01       	movw	r24, r14
     faa:	b6 01       	movw	r22, r12
     fac:	0e 94 09 08 	call	0x1012	; 0x1012 <__addsf3>
     fb0:	6b 01       	movw	r12, r22
     fb2:	7c 01       	movw	r14, r24
			time_of_last_pulse = tinyTime_now();			
     fb4:	0e 94 ff 07 	call	0xffe	; 0xffe <tinyTime_now>
     fb8:	60 93 4e 38 	sts	0x384E, r22	; 0x80384e <time_of_last_pulse>
     fbc:	70 93 4f 38 	sts	0x384F, r23	; 0x80384f <time_of_last_pulse+0x1>
     fc0:	80 93 50 38 	sts	0x3850, r24	; 0x803850 <time_of_last_pulse+0x2>
     fc4:	90 93 51 38 	sts	0x3851, r25	; 0x803851 <time_of_last_pulse+0x3>
		}
	}
	return potential;
}
     fc8:	c7 01       	movw	r24, r14
     fca:	b6 01       	movw	r22, r12
     fcc:	ff 90       	pop	r15
     fce:	ef 90       	pop	r14
     fd0:	df 90       	pop	r13
     fd2:	cf 90       	pop	r12
     fd4:	08 95       	ret

00000fd6 <tinyTime_counter_increment>:
If the Interrupt Service Routine is clocked by a crystal oscillator
it gives a very precise timer-counter.
*/
void tinyTime_counter_increment(void)
{
	time_counter++;
     fd6:	80 91 53 38 	lds	r24, 0x3853	; 0x803853 <time_counter>
     fda:	90 91 54 38 	lds	r25, 0x3854	; 0x803854 <time_counter+0x1>
     fde:	a0 91 55 38 	lds	r26, 0x3855	; 0x803855 <time_counter+0x2>
     fe2:	b0 91 56 38 	lds	r27, 0x3856	; 0x803856 <time_counter+0x3>
     fe6:	01 96       	adiw	r24, 0x01	; 1
     fe8:	a1 1d       	adc	r26, r1
     fea:	b1 1d       	adc	r27, r1
     fec:	80 93 53 38 	sts	0x3853, r24	; 0x803853 <time_counter>
     ff0:	90 93 54 38 	sts	0x3854, r25	; 0x803854 <time_counter+0x1>
     ff4:	a0 93 55 38 	sts	0x3855, r26	; 0x803855 <time_counter+0x2>
     ff8:	b0 93 56 38 	sts	0x3856, r27	; 0x803856 <time_counter+0x3>
     ffc:	08 95       	ret

00000ffe <tinyTime_now>:
/*
This function is callable by external libraries to give them the counted time so far.
*/
uint32_t tinyTime_now(void)
{
	return time_counter;
     ffe:	60 91 53 38 	lds	r22, 0x3853	; 0x803853 <time_counter>
    1002:	70 91 54 38 	lds	r23, 0x3854	; 0x803854 <time_counter+0x1>
    1006:	80 91 55 38 	lds	r24, 0x3855	; 0x803855 <time_counter+0x2>
    100a:	90 91 56 38 	lds	r25, 0x3856	; 0x803856 <time_counter+0x3>
    100e:	08 95       	ret

00001010 <__subsf3>:
    1010:	50 58       	subi	r21, 0x80	; 128

00001012 <__addsf3>:
    1012:	bb 27       	eor	r27, r27
    1014:	aa 27       	eor	r26, r26
    1016:	0e 94 20 08 	call	0x1040	; 0x1040 <__addsf3x>
    101a:	0c 94 13 0a 	jmp	0x1426	; 0x1426 <__fp_round>
    101e:	0e 94 05 0a 	call	0x140a	; 0x140a <__fp_pscA>
    1022:	38 f0       	brcs	.+14     	; 0x1032 <__addsf3+0x20>
    1024:	0e 94 0c 0a 	call	0x1418	; 0x1418 <__fp_pscB>
    1028:	20 f0       	brcs	.+8      	; 0x1032 <__addsf3+0x20>
    102a:	39 f4       	brne	.+14     	; 0x103a <__addsf3+0x28>
    102c:	9f 3f       	cpi	r25, 0xFF	; 255
    102e:	19 f4       	brne	.+6      	; 0x1036 <__addsf3+0x24>
    1030:	26 f4       	brtc	.+8      	; 0x103a <__addsf3+0x28>
    1032:	0c 94 db 09 	jmp	0x13b6	; 0x13b6 <__fp_nan>
    1036:	0e f4       	brtc	.+2      	; 0x103a <__addsf3+0x28>
    1038:	e0 95       	com	r30
    103a:	e7 fb       	bst	r30, 7
    103c:	0c 94 d5 09 	jmp	0x13aa	; 0x13aa <__fp_inf>

00001040 <__addsf3x>:
    1040:	e9 2f       	mov	r30, r25
    1042:	0e 94 24 0a 	call	0x1448	; 0x1448 <__fp_split3>
    1046:	58 f3       	brcs	.-42     	; 0x101e <__addsf3+0xc>
    1048:	ba 17       	cp	r27, r26
    104a:	62 07       	cpc	r22, r18
    104c:	73 07       	cpc	r23, r19
    104e:	84 07       	cpc	r24, r20
    1050:	95 07       	cpc	r25, r21
    1052:	20 f0       	brcs	.+8      	; 0x105c <__addsf3x+0x1c>
    1054:	79 f4       	brne	.+30     	; 0x1074 <__addsf3x+0x34>
    1056:	a6 f5       	brtc	.+104    	; 0x10c0 <__addsf3x+0x80>
    1058:	0c 94 46 0a 	jmp	0x148c	; 0x148c <__fp_zero>
    105c:	0e f4       	brtc	.+2      	; 0x1060 <__addsf3x+0x20>
    105e:	e0 95       	com	r30
    1060:	0b 2e       	mov	r0, r27
    1062:	ba 2f       	mov	r27, r26
    1064:	a0 2d       	mov	r26, r0
    1066:	0b 01       	movw	r0, r22
    1068:	b9 01       	movw	r22, r18
    106a:	90 01       	movw	r18, r0
    106c:	0c 01       	movw	r0, r24
    106e:	ca 01       	movw	r24, r20
    1070:	a0 01       	movw	r20, r0
    1072:	11 24       	eor	r1, r1
    1074:	ff 27       	eor	r31, r31
    1076:	59 1b       	sub	r21, r25
    1078:	99 f0       	breq	.+38     	; 0x10a0 <__addsf3x+0x60>
    107a:	59 3f       	cpi	r21, 0xF9	; 249
    107c:	50 f4       	brcc	.+20     	; 0x1092 <__addsf3x+0x52>
    107e:	50 3e       	cpi	r21, 0xE0	; 224
    1080:	68 f1       	brcs	.+90     	; 0x10dc <__addsf3x+0x9c>
    1082:	1a 16       	cp	r1, r26
    1084:	f0 40       	sbci	r31, 0x00	; 0
    1086:	a2 2f       	mov	r26, r18
    1088:	23 2f       	mov	r18, r19
    108a:	34 2f       	mov	r19, r20
    108c:	44 27       	eor	r20, r20
    108e:	58 5f       	subi	r21, 0xF8	; 248
    1090:	f3 cf       	rjmp	.-26     	; 0x1078 <__addsf3x+0x38>
    1092:	46 95       	lsr	r20
    1094:	37 95       	ror	r19
    1096:	27 95       	ror	r18
    1098:	a7 95       	ror	r26
    109a:	f0 40       	sbci	r31, 0x00	; 0
    109c:	53 95       	inc	r21
    109e:	c9 f7       	brne	.-14     	; 0x1092 <__addsf3x+0x52>
    10a0:	7e f4       	brtc	.+30     	; 0x10c0 <__addsf3x+0x80>
    10a2:	1f 16       	cp	r1, r31
    10a4:	ba 0b       	sbc	r27, r26
    10a6:	62 0b       	sbc	r22, r18
    10a8:	73 0b       	sbc	r23, r19
    10aa:	84 0b       	sbc	r24, r20
    10ac:	ba f0       	brmi	.+46     	; 0x10dc <__addsf3x+0x9c>
    10ae:	91 50       	subi	r25, 0x01	; 1
    10b0:	a1 f0       	breq	.+40     	; 0x10da <__addsf3x+0x9a>
    10b2:	ff 0f       	add	r31, r31
    10b4:	bb 1f       	adc	r27, r27
    10b6:	66 1f       	adc	r22, r22
    10b8:	77 1f       	adc	r23, r23
    10ba:	88 1f       	adc	r24, r24
    10bc:	c2 f7       	brpl	.-16     	; 0x10ae <__addsf3x+0x6e>
    10be:	0e c0       	rjmp	.+28     	; 0x10dc <__addsf3x+0x9c>
    10c0:	ba 0f       	add	r27, r26
    10c2:	62 1f       	adc	r22, r18
    10c4:	73 1f       	adc	r23, r19
    10c6:	84 1f       	adc	r24, r20
    10c8:	48 f4       	brcc	.+18     	; 0x10dc <__addsf3x+0x9c>
    10ca:	87 95       	ror	r24
    10cc:	77 95       	ror	r23
    10ce:	67 95       	ror	r22
    10d0:	b7 95       	ror	r27
    10d2:	f7 95       	ror	r31
    10d4:	9e 3f       	cpi	r25, 0xFE	; 254
    10d6:	08 f0       	brcs	.+2      	; 0x10da <__addsf3x+0x9a>
    10d8:	b0 cf       	rjmp	.-160    	; 0x103a <__addsf3+0x28>
    10da:	93 95       	inc	r25
    10dc:	88 0f       	add	r24, r24
    10de:	08 f0       	brcs	.+2      	; 0x10e2 <__addsf3x+0xa2>
    10e0:	99 27       	eor	r25, r25
    10e2:	ee 0f       	add	r30, r30
    10e4:	97 95       	ror	r25
    10e6:	87 95       	ror	r24
    10e8:	08 95       	ret

000010ea <__cmpsf2>:
    10ea:	0e 94 b1 09 	call	0x1362	; 0x1362 <__fp_cmp>
    10ee:	08 f4       	brcc	.+2      	; 0x10f2 <__cmpsf2+0x8>
    10f0:	81 e0       	ldi	r24, 0x01	; 1
    10f2:	08 95       	ret

000010f4 <__divsf3>:
    10f4:	0e 94 8e 08 	call	0x111c	; 0x111c <__divsf3x>
    10f8:	0c 94 13 0a 	jmp	0x1426	; 0x1426 <__fp_round>
    10fc:	0e 94 0c 0a 	call	0x1418	; 0x1418 <__fp_pscB>
    1100:	58 f0       	brcs	.+22     	; 0x1118 <__divsf3+0x24>
    1102:	0e 94 05 0a 	call	0x140a	; 0x140a <__fp_pscA>
    1106:	40 f0       	brcs	.+16     	; 0x1118 <__divsf3+0x24>
    1108:	29 f4       	brne	.+10     	; 0x1114 <__divsf3+0x20>
    110a:	5f 3f       	cpi	r21, 0xFF	; 255
    110c:	29 f0       	breq	.+10     	; 0x1118 <__divsf3+0x24>
    110e:	0c 94 d5 09 	jmp	0x13aa	; 0x13aa <__fp_inf>
    1112:	51 11       	cpse	r21, r1
    1114:	0c 94 47 0a 	jmp	0x148e	; 0x148e <__fp_szero>
    1118:	0c 94 db 09 	jmp	0x13b6	; 0x13b6 <__fp_nan>

0000111c <__divsf3x>:
    111c:	0e 94 24 0a 	call	0x1448	; 0x1448 <__fp_split3>
    1120:	68 f3       	brcs	.-38     	; 0x10fc <__divsf3+0x8>

00001122 <__divsf3_pse>:
    1122:	99 23       	and	r25, r25
    1124:	b1 f3       	breq	.-20     	; 0x1112 <__divsf3+0x1e>
    1126:	55 23       	and	r21, r21
    1128:	91 f3       	breq	.-28     	; 0x110e <__divsf3+0x1a>
    112a:	95 1b       	sub	r25, r21
    112c:	55 0b       	sbc	r21, r21
    112e:	bb 27       	eor	r27, r27
    1130:	aa 27       	eor	r26, r26
    1132:	62 17       	cp	r22, r18
    1134:	73 07       	cpc	r23, r19
    1136:	84 07       	cpc	r24, r20
    1138:	38 f0       	brcs	.+14     	; 0x1148 <__divsf3_pse+0x26>
    113a:	9f 5f       	subi	r25, 0xFF	; 255
    113c:	5f 4f       	sbci	r21, 0xFF	; 255
    113e:	22 0f       	add	r18, r18
    1140:	33 1f       	adc	r19, r19
    1142:	44 1f       	adc	r20, r20
    1144:	aa 1f       	adc	r26, r26
    1146:	a9 f3       	breq	.-22     	; 0x1132 <__divsf3_pse+0x10>
    1148:	35 d0       	rcall	.+106    	; 0x11b4 <__divsf3_pse+0x92>
    114a:	0e 2e       	mov	r0, r30
    114c:	3a f0       	brmi	.+14     	; 0x115c <__divsf3_pse+0x3a>
    114e:	e0 e8       	ldi	r30, 0x80	; 128
    1150:	32 d0       	rcall	.+100    	; 0x11b6 <__divsf3_pse+0x94>
    1152:	91 50       	subi	r25, 0x01	; 1
    1154:	50 40       	sbci	r21, 0x00	; 0
    1156:	e6 95       	lsr	r30
    1158:	00 1c       	adc	r0, r0
    115a:	ca f7       	brpl	.-14     	; 0x114e <__divsf3_pse+0x2c>
    115c:	2b d0       	rcall	.+86     	; 0x11b4 <__divsf3_pse+0x92>
    115e:	fe 2f       	mov	r31, r30
    1160:	29 d0       	rcall	.+82     	; 0x11b4 <__divsf3_pse+0x92>
    1162:	66 0f       	add	r22, r22
    1164:	77 1f       	adc	r23, r23
    1166:	88 1f       	adc	r24, r24
    1168:	bb 1f       	adc	r27, r27
    116a:	26 17       	cp	r18, r22
    116c:	37 07       	cpc	r19, r23
    116e:	48 07       	cpc	r20, r24
    1170:	ab 07       	cpc	r26, r27
    1172:	b0 e8       	ldi	r27, 0x80	; 128
    1174:	09 f0       	breq	.+2      	; 0x1178 <__divsf3_pse+0x56>
    1176:	bb 0b       	sbc	r27, r27
    1178:	80 2d       	mov	r24, r0
    117a:	bf 01       	movw	r22, r30
    117c:	ff 27       	eor	r31, r31
    117e:	93 58       	subi	r25, 0x83	; 131
    1180:	5f 4f       	sbci	r21, 0xFF	; 255
    1182:	3a f0       	brmi	.+14     	; 0x1192 <__divsf3_pse+0x70>
    1184:	9e 3f       	cpi	r25, 0xFE	; 254
    1186:	51 05       	cpc	r21, r1
    1188:	78 f0       	brcs	.+30     	; 0x11a8 <__divsf3_pse+0x86>
    118a:	0c 94 d5 09 	jmp	0x13aa	; 0x13aa <__fp_inf>
    118e:	0c 94 47 0a 	jmp	0x148e	; 0x148e <__fp_szero>
    1192:	5f 3f       	cpi	r21, 0xFF	; 255
    1194:	e4 f3       	brlt	.-8      	; 0x118e <__divsf3_pse+0x6c>
    1196:	98 3e       	cpi	r25, 0xE8	; 232
    1198:	d4 f3       	brlt	.-12     	; 0x118e <__divsf3_pse+0x6c>
    119a:	86 95       	lsr	r24
    119c:	77 95       	ror	r23
    119e:	67 95       	ror	r22
    11a0:	b7 95       	ror	r27
    11a2:	f7 95       	ror	r31
    11a4:	9f 5f       	subi	r25, 0xFF	; 255
    11a6:	c9 f7       	brne	.-14     	; 0x119a <__divsf3_pse+0x78>
    11a8:	88 0f       	add	r24, r24
    11aa:	91 1d       	adc	r25, r1
    11ac:	96 95       	lsr	r25
    11ae:	87 95       	ror	r24
    11b0:	97 f9       	bld	r25, 7
    11b2:	08 95       	ret
    11b4:	e1 e0       	ldi	r30, 0x01	; 1
    11b6:	66 0f       	add	r22, r22
    11b8:	77 1f       	adc	r23, r23
    11ba:	88 1f       	adc	r24, r24
    11bc:	bb 1f       	adc	r27, r27
    11be:	62 17       	cp	r22, r18
    11c0:	73 07       	cpc	r23, r19
    11c2:	84 07       	cpc	r24, r20
    11c4:	ba 07       	cpc	r27, r26
    11c6:	20 f0       	brcs	.+8      	; 0x11d0 <__divsf3_pse+0xae>
    11c8:	62 1b       	sub	r22, r18
    11ca:	73 0b       	sbc	r23, r19
    11cc:	84 0b       	sbc	r24, r20
    11ce:	ba 0b       	sbc	r27, r26
    11d0:	ee 1f       	adc	r30, r30
    11d2:	88 f7       	brcc	.-30     	; 0x11b6 <__divsf3_pse+0x94>
    11d4:	e0 95       	com	r30
    11d6:	08 95       	ret
    11d8:	29 f4       	brne	.+10     	; 0x11e4 <__divsf3_pse+0xc2>
    11da:	16 f0       	brts	.+4      	; 0x11e0 <__divsf3_pse+0xbe>
    11dc:	0c 94 d5 09 	jmp	0x13aa	; 0x13aa <__fp_inf>
    11e0:	0c 94 46 0a 	jmp	0x148c	; 0x148c <__fp_zero>
    11e4:	0c 94 db 09 	jmp	0x13b6	; 0x13b6 <__fp_nan>

000011e8 <exp>:
    11e8:	0e 94 2c 0a 	call	0x1458	; 0x1458 <__fp_splitA>
    11ec:	a8 f3       	brcs	.-22     	; 0x11d8 <__divsf3_pse+0xb6>
    11ee:	96 38       	cpi	r25, 0x86	; 134
    11f0:	a0 f7       	brcc	.-24     	; 0x11da <__divsf3_pse+0xb8>
    11f2:	07 f8       	bld	r0, 7
    11f4:	0f 92       	push	r0
    11f6:	e8 94       	clt
    11f8:	2b e3       	ldi	r18, 0x3B	; 59
    11fa:	3a ea       	ldi	r19, 0xAA	; 170
    11fc:	48 eb       	ldi	r20, 0xB8	; 184
    11fe:	5f e7       	ldi	r21, 0x7F	; 127
    1200:	0e 94 de 0a 	call	0x15bc	; 0x15bc <__mulsf3_pse>
    1204:	0f 92       	push	r0
    1206:	0f 92       	push	r0
    1208:	0f 92       	push	r0
    120a:	4d b7       	in	r20, 0x3d	; 61
    120c:	5e b7       	in	r21, 0x3e	; 62
    120e:	0f 92       	push	r0
    1210:	0e 94 94 0a 	call	0x1528	; 0x1528 <modf>
    1214:	ec e7       	ldi	r30, 0x7C	; 124
    1216:	f0 e0       	ldi	r31, 0x00	; 0
    1218:	0e 94 de 09 	call	0x13bc	; 0x13bc <__fp_powser>
    121c:	4f 91       	pop	r20
    121e:	5f 91       	pop	r21
    1220:	ef 91       	pop	r30
    1222:	ff 91       	pop	r31
    1224:	e5 95       	asr	r30
    1226:	ee 1f       	adc	r30, r30
    1228:	ff 1f       	adc	r31, r31
    122a:	49 f0       	breq	.+18     	; 0x123e <exp+0x56>
    122c:	fe 57       	subi	r31, 0x7E	; 126
    122e:	e0 68       	ori	r30, 0x80	; 128
    1230:	44 27       	eor	r20, r20
    1232:	ee 0f       	add	r30, r30
    1234:	44 1f       	adc	r20, r20
    1236:	fa 95       	dec	r31
    1238:	e1 f7       	brne	.-8      	; 0x1232 <exp+0x4a>
    123a:	41 95       	neg	r20
    123c:	55 0b       	sbc	r21, r21
    123e:	0e 94 5e 0a 	call	0x14bc	; 0x14bc <ldexp>
    1242:	0f 90       	pop	r0
    1244:	07 fe       	sbrs	r0, 7
    1246:	0c 94 52 0a 	jmp	0x14a4	; 0x14a4 <inverse>
    124a:	08 95       	ret

0000124c <__fixunssfsi>:
    124c:	0e 94 2c 0a 	call	0x1458	; 0x1458 <__fp_splitA>
    1250:	88 f0       	brcs	.+34     	; 0x1274 <__fixunssfsi+0x28>
    1252:	9f 57       	subi	r25, 0x7F	; 127
    1254:	98 f0       	brcs	.+38     	; 0x127c <__fixunssfsi+0x30>
    1256:	b9 2f       	mov	r27, r25
    1258:	99 27       	eor	r25, r25
    125a:	b7 51       	subi	r27, 0x17	; 23
    125c:	b0 f0       	brcs	.+44     	; 0x128a <__fixunssfsi+0x3e>
    125e:	e1 f0       	breq	.+56     	; 0x1298 <__fixunssfsi+0x4c>
    1260:	66 0f       	add	r22, r22
    1262:	77 1f       	adc	r23, r23
    1264:	88 1f       	adc	r24, r24
    1266:	99 1f       	adc	r25, r25
    1268:	1a f0       	brmi	.+6      	; 0x1270 <__fixunssfsi+0x24>
    126a:	ba 95       	dec	r27
    126c:	c9 f7       	brne	.-14     	; 0x1260 <__fixunssfsi+0x14>
    126e:	14 c0       	rjmp	.+40     	; 0x1298 <__fixunssfsi+0x4c>
    1270:	b1 30       	cpi	r27, 0x01	; 1
    1272:	91 f0       	breq	.+36     	; 0x1298 <__fixunssfsi+0x4c>
    1274:	0e 94 46 0a 	call	0x148c	; 0x148c <__fp_zero>
    1278:	b1 e0       	ldi	r27, 0x01	; 1
    127a:	08 95       	ret
    127c:	0c 94 46 0a 	jmp	0x148c	; 0x148c <__fp_zero>
    1280:	67 2f       	mov	r22, r23
    1282:	78 2f       	mov	r23, r24
    1284:	88 27       	eor	r24, r24
    1286:	b8 5f       	subi	r27, 0xF8	; 248
    1288:	39 f0       	breq	.+14     	; 0x1298 <__fixunssfsi+0x4c>
    128a:	b9 3f       	cpi	r27, 0xF9	; 249
    128c:	cc f3       	brlt	.-14     	; 0x1280 <__fixunssfsi+0x34>
    128e:	86 95       	lsr	r24
    1290:	77 95       	ror	r23
    1292:	67 95       	ror	r22
    1294:	b3 95       	inc	r27
    1296:	d9 f7       	brne	.-10     	; 0x128e <__fixunssfsi+0x42>
    1298:	3e f4       	brtc	.+14     	; 0x12a8 <__fixunssfsi+0x5c>
    129a:	90 95       	com	r25
    129c:	80 95       	com	r24
    129e:	70 95       	com	r23
    12a0:	61 95       	neg	r22
    12a2:	7f 4f       	sbci	r23, 0xFF	; 255
    12a4:	8f 4f       	sbci	r24, 0xFF	; 255
    12a6:	9f 4f       	sbci	r25, 0xFF	; 255
    12a8:	08 95       	ret

000012aa <__floatunsisf>:
    12aa:	e8 94       	clt
    12ac:	09 c0       	rjmp	.+18     	; 0x12c0 <__floatsisf+0x12>

000012ae <__floatsisf>:
    12ae:	97 fb       	bst	r25, 7
    12b0:	3e f4       	brtc	.+14     	; 0x12c0 <__floatsisf+0x12>
    12b2:	90 95       	com	r25
    12b4:	80 95       	com	r24
    12b6:	70 95       	com	r23
    12b8:	61 95       	neg	r22
    12ba:	7f 4f       	sbci	r23, 0xFF	; 255
    12bc:	8f 4f       	sbci	r24, 0xFF	; 255
    12be:	9f 4f       	sbci	r25, 0xFF	; 255
    12c0:	99 23       	and	r25, r25
    12c2:	a9 f0       	breq	.+42     	; 0x12ee <__floatsisf+0x40>
    12c4:	f9 2f       	mov	r31, r25
    12c6:	96 e9       	ldi	r25, 0x96	; 150
    12c8:	bb 27       	eor	r27, r27
    12ca:	93 95       	inc	r25
    12cc:	f6 95       	lsr	r31
    12ce:	87 95       	ror	r24
    12d0:	77 95       	ror	r23
    12d2:	67 95       	ror	r22
    12d4:	b7 95       	ror	r27
    12d6:	f1 11       	cpse	r31, r1
    12d8:	f8 cf       	rjmp	.-16     	; 0x12ca <__floatsisf+0x1c>
    12da:	fa f4       	brpl	.+62     	; 0x131a <__floatsisf+0x6c>
    12dc:	bb 0f       	add	r27, r27
    12de:	11 f4       	brne	.+4      	; 0x12e4 <__floatsisf+0x36>
    12e0:	60 ff       	sbrs	r22, 0
    12e2:	1b c0       	rjmp	.+54     	; 0x131a <__floatsisf+0x6c>
    12e4:	6f 5f       	subi	r22, 0xFF	; 255
    12e6:	7f 4f       	sbci	r23, 0xFF	; 255
    12e8:	8f 4f       	sbci	r24, 0xFF	; 255
    12ea:	9f 4f       	sbci	r25, 0xFF	; 255
    12ec:	16 c0       	rjmp	.+44     	; 0x131a <__floatsisf+0x6c>
    12ee:	88 23       	and	r24, r24
    12f0:	11 f0       	breq	.+4      	; 0x12f6 <__floatsisf+0x48>
    12f2:	96 e9       	ldi	r25, 0x96	; 150
    12f4:	11 c0       	rjmp	.+34     	; 0x1318 <__floatsisf+0x6a>
    12f6:	77 23       	and	r23, r23
    12f8:	21 f0       	breq	.+8      	; 0x1302 <__floatsisf+0x54>
    12fa:	9e e8       	ldi	r25, 0x8E	; 142
    12fc:	87 2f       	mov	r24, r23
    12fe:	76 2f       	mov	r23, r22
    1300:	05 c0       	rjmp	.+10     	; 0x130c <__floatsisf+0x5e>
    1302:	66 23       	and	r22, r22
    1304:	71 f0       	breq	.+28     	; 0x1322 <__floatsisf+0x74>
    1306:	96 e8       	ldi	r25, 0x86	; 134
    1308:	86 2f       	mov	r24, r22
    130a:	70 e0       	ldi	r23, 0x00	; 0
    130c:	60 e0       	ldi	r22, 0x00	; 0
    130e:	2a f0       	brmi	.+10     	; 0x131a <__floatsisf+0x6c>
    1310:	9a 95       	dec	r25
    1312:	66 0f       	add	r22, r22
    1314:	77 1f       	adc	r23, r23
    1316:	88 1f       	adc	r24, r24
    1318:	da f7       	brpl	.-10     	; 0x1310 <__floatsisf+0x62>
    131a:	88 0f       	add	r24, r24
    131c:	96 95       	lsr	r25
    131e:	87 95       	ror	r24
    1320:	97 f9       	bld	r25, 7
    1322:	08 95       	ret

00001324 <fmin>:
    1324:	99 0f       	add	r25, r25
    1326:	bb 0b       	sbc	r27, r27
    1328:	55 0f       	add	r21, r21
    132a:	aa 0b       	sbc	r26, r26
    132c:	e0 e8       	ldi	r30, 0x80	; 128
    132e:	fe ef       	ldi	r31, 0xFE	; 254
    1330:	16 16       	cp	r1, r22
    1332:	17 06       	cpc	r1, r23
    1334:	e8 07       	cpc	r30, r24
    1336:	f9 07       	cpc	r31, r25
    1338:	70 f0       	brcs	.+28     	; 0x1356 <fmin+0x32>
    133a:	12 16       	cp	r1, r18
    133c:	13 06       	cpc	r1, r19
    133e:	e4 07       	cpc	r30, r20
    1340:	f5 07       	cpc	r31, r21
    1342:	60 f0       	brcs	.+24     	; 0x135c <fmin+0x38>
    1344:	ba 17       	cp	r27, r26
    1346:	54 f0       	brlt	.+20     	; 0x135c <fmin+0x38>
    1348:	31 f4       	brne	.+12     	; 0x1356 <fmin+0x32>
    134a:	26 17       	cp	r18, r22
    134c:	37 07       	cpc	r19, r23
    134e:	48 07       	cpc	r20, r24
    1350:	59 07       	cpc	r21, r25
    1352:	a7 95       	ror	r26
    1354:	1b f4       	brvc	.+6      	; 0x135c <fmin+0x38>
    1356:	b9 01       	movw	r22, r18
    1358:	ca 01       	movw	r24, r20
    135a:	ba 2f       	mov	r27, r26
    135c:	b6 95       	lsr	r27
    135e:	97 95       	ror	r25
    1360:	08 95       	ret

00001362 <__fp_cmp>:
    1362:	99 0f       	add	r25, r25
    1364:	00 08       	sbc	r0, r0
    1366:	55 0f       	add	r21, r21
    1368:	aa 0b       	sbc	r26, r26
    136a:	e0 e8       	ldi	r30, 0x80	; 128
    136c:	fe ef       	ldi	r31, 0xFE	; 254
    136e:	16 16       	cp	r1, r22
    1370:	17 06       	cpc	r1, r23
    1372:	e8 07       	cpc	r30, r24
    1374:	f9 07       	cpc	r31, r25
    1376:	c0 f0       	brcs	.+48     	; 0x13a8 <__fp_cmp+0x46>
    1378:	12 16       	cp	r1, r18
    137a:	13 06       	cpc	r1, r19
    137c:	e4 07       	cpc	r30, r20
    137e:	f5 07       	cpc	r31, r21
    1380:	98 f0       	brcs	.+38     	; 0x13a8 <__fp_cmp+0x46>
    1382:	62 1b       	sub	r22, r18
    1384:	73 0b       	sbc	r23, r19
    1386:	84 0b       	sbc	r24, r20
    1388:	95 0b       	sbc	r25, r21
    138a:	39 f4       	brne	.+14     	; 0x139a <__fp_cmp+0x38>
    138c:	0a 26       	eor	r0, r26
    138e:	61 f0       	breq	.+24     	; 0x13a8 <__fp_cmp+0x46>
    1390:	23 2b       	or	r18, r19
    1392:	24 2b       	or	r18, r20
    1394:	25 2b       	or	r18, r21
    1396:	21 f4       	brne	.+8      	; 0x13a0 <__fp_cmp+0x3e>
    1398:	08 95       	ret
    139a:	0a 26       	eor	r0, r26
    139c:	09 f4       	brne	.+2      	; 0x13a0 <__fp_cmp+0x3e>
    139e:	a1 40       	sbci	r26, 0x01	; 1
    13a0:	a6 95       	lsr	r26
    13a2:	8f ef       	ldi	r24, 0xFF	; 255
    13a4:	81 1d       	adc	r24, r1
    13a6:	81 1d       	adc	r24, r1
    13a8:	08 95       	ret

000013aa <__fp_inf>:
    13aa:	97 f9       	bld	r25, 7
    13ac:	9f 67       	ori	r25, 0x7F	; 127
    13ae:	80 e8       	ldi	r24, 0x80	; 128
    13b0:	70 e0       	ldi	r23, 0x00	; 0
    13b2:	60 e0       	ldi	r22, 0x00	; 0
    13b4:	08 95       	ret

000013b6 <__fp_nan>:
    13b6:	9f ef       	ldi	r25, 0xFF	; 255
    13b8:	80 ec       	ldi	r24, 0xC0	; 192
    13ba:	08 95       	ret

000013bc <__fp_powser>:
    13bc:	df 93       	push	r29
    13be:	cf 93       	push	r28
    13c0:	1f 93       	push	r17
    13c2:	0f 93       	push	r16
    13c4:	ff 92       	push	r15
    13c6:	ef 92       	push	r14
    13c8:	df 92       	push	r13
    13ca:	7b 01       	movw	r14, r22
    13cc:	8c 01       	movw	r16, r24
    13ce:	68 94       	set
    13d0:	06 c0       	rjmp	.+12     	; 0x13de <__fp_powser+0x22>
    13d2:	da 2e       	mov	r13, r26
    13d4:	ef 01       	movw	r28, r30
    13d6:	0e 94 db 0a 	call	0x15b6	; 0x15b6 <__mulsf3x>
    13da:	fe 01       	movw	r30, r28
    13dc:	e8 94       	clt
    13de:	a5 91       	lpm	r26, Z+
    13e0:	25 91       	lpm	r18, Z+
    13e2:	35 91       	lpm	r19, Z+
    13e4:	45 91       	lpm	r20, Z+
    13e6:	55 91       	lpm	r21, Z+
    13e8:	a6 f3       	brts	.-24     	; 0x13d2 <__fp_powser+0x16>
    13ea:	ef 01       	movw	r28, r30
    13ec:	0e 94 20 08 	call	0x1040	; 0x1040 <__addsf3x>
    13f0:	fe 01       	movw	r30, r28
    13f2:	97 01       	movw	r18, r14
    13f4:	a8 01       	movw	r20, r16
    13f6:	da 94       	dec	r13
    13f8:	69 f7       	brne	.-38     	; 0x13d4 <__fp_powser+0x18>
    13fa:	df 90       	pop	r13
    13fc:	ef 90       	pop	r14
    13fe:	ff 90       	pop	r15
    1400:	0f 91       	pop	r16
    1402:	1f 91       	pop	r17
    1404:	cf 91       	pop	r28
    1406:	df 91       	pop	r29
    1408:	08 95       	ret

0000140a <__fp_pscA>:
    140a:	00 24       	eor	r0, r0
    140c:	0a 94       	dec	r0
    140e:	16 16       	cp	r1, r22
    1410:	17 06       	cpc	r1, r23
    1412:	18 06       	cpc	r1, r24
    1414:	09 06       	cpc	r0, r25
    1416:	08 95       	ret

00001418 <__fp_pscB>:
    1418:	00 24       	eor	r0, r0
    141a:	0a 94       	dec	r0
    141c:	12 16       	cp	r1, r18
    141e:	13 06       	cpc	r1, r19
    1420:	14 06       	cpc	r1, r20
    1422:	05 06       	cpc	r0, r21
    1424:	08 95       	ret

00001426 <__fp_round>:
    1426:	09 2e       	mov	r0, r25
    1428:	03 94       	inc	r0
    142a:	00 0c       	add	r0, r0
    142c:	11 f4       	brne	.+4      	; 0x1432 <__fp_round+0xc>
    142e:	88 23       	and	r24, r24
    1430:	52 f0       	brmi	.+20     	; 0x1446 <__fp_round+0x20>
    1432:	bb 0f       	add	r27, r27
    1434:	40 f4       	brcc	.+16     	; 0x1446 <__fp_round+0x20>
    1436:	bf 2b       	or	r27, r31
    1438:	11 f4       	brne	.+4      	; 0x143e <__fp_round+0x18>
    143a:	60 ff       	sbrs	r22, 0
    143c:	04 c0       	rjmp	.+8      	; 0x1446 <__fp_round+0x20>
    143e:	6f 5f       	subi	r22, 0xFF	; 255
    1440:	7f 4f       	sbci	r23, 0xFF	; 255
    1442:	8f 4f       	sbci	r24, 0xFF	; 255
    1444:	9f 4f       	sbci	r25, 0xFF	; 255
    1446:	08 95       	ret

00001448 <__fp_split3>:
    1448:	57 fd       	sbrc	r21, 7
    144a:	90 58       	subi	r25, 0x80	; 128
    144c:	44 0f       	add	r20, r20
    144e:	55 1f       	adc	r21, r21
    1450:	59 f0       	breq	.+22     	; 0x1468 <__fp_splitA+0x10>
    1452:	5f 3f       	cpi	r21, 0xFF	; 255
    1454:	71 f0       	breq	.+28     	; 0x1472 <__fp_splitA+0x1a>
    1456:	47 95       	ror	r20

00001458 <__fp_splitA>:
    1458:	88 0f       	add	r24, r24
    145a:	97 fb       	bst	r25, 7
    145c:	99 1f       	adc	r25, r25
    145e:	61 f0       	breq	.+24     	; 0x1478 <__fp_splitA+0x20>
    1460:	9f 3f       	cpi	r25, 0xFF	; 255
    1462:	79 f0       	breq	.+30     	; 0x1482 <__fp_splitA+0x2a>
    1464:	87 95       	ror	r24
    1466:	08 95       	ret
    1468:	12 16       	cp	r1, r18
    146a:	13 06       	cpc	r1, r19
    146c:	14 06       	cpc	r1, r20
    146e:	55 1f       	adc	r21, r21
    1470:	f2 cf       	rjmp	.-28     	; 0x1456 <__fp_split3+0xe>
    1472:	46 95       	lsr	r20
    1474:	f1 df       	rcall	.-30     	; 0x1458 <__fp_splitA>
    1476:	08 c0       	rjmp	.+16     	; 0x1488 <__fp_splitA+0x30>
    1478:	16 16       	cp	r1, r22
    147a:	17 06       	cpc	r1, r23
    147c:	18 06       	cpc	r1, r24
    147e:	99 1f       	adc	r25, r25
    1480:	f1 cf       	rjmp	.-30     	; 0x1464 <__fp_splitA+0xc>
    1482:	86 95       	lsr	r24
    1484:	71 05       	cpc	r23, r1
    1486:	61 05       	cpc	r22, r1
    1488:	08 94       	sec
    148a:	08 95       	ret

0000148c <__fp_zero>:
    148c:	e8 94       	clt

0000148e <__fp_szero>:
    148e:	bb 27       	eor	r27, r27
    1490:	66 27       	eor	r22, r22
    1492:	77 27       	eor	r23, r23
    1494:	cb 01       	movw	r24, r22
    1496:	97 f9       	bld	r25, 7
    1498:	08 95       	ret

0000149a <__gesf2>:
    149a:	0e 94 b1 09 	call	0x1362	; 0x1362 <__fp_cmp>
    149e:	08 f4       	brcc	.+2      	; 0x14a2 <__gesf2+0x8>
    14a0:	8f ef       	ldi	r24, 0xFF	; 255
    14a2:	08 95       	ret

000014a4 <inverse>:
    14a4:	9b 01       	movw	r18, r22
    14a6:	ac 01       	movw	r20, r24
    14a8:	60 e0       	ldi	r22, 0x00	; 0
    14aa:	70 e0       	ldi	r23, 0x00	; 0
    14ac:	80 e8       	ldi	r24, 0x80	; 128
    14ae:	9f e3       	ldi	r25, 0x3F	; 63
    14b0:	0c 94 7a 08 	jmp	0x10f4	; 0x10f4 <__divsf3>
    14b4:	0c 94 d5 09 	jmp	0x13aa	; 0x13aa <__fp_inf>
    14b8:	0c 94 3d 0b 	jmp	0x167a	; 0x167a <__fp_mpack>

000014bc <ldexp>:
    14bc:	0e 94 2c 0a 	call	0x1458	; 0x1458 <__fp_splitA>
    14c0:	d8 f3       	brcs	.-10     	; 0x14b8 <inverse+0x14>
    14c2:	99 23       	and	r25, r25
    14c4:	c9 f3       	breq	.-14     	; 0x14b8 <inverse+0x14>
    14c6:	94 0f       	add	r25, r20
    14c8:	51 1d       	adc	r21, r1
    14ca:	a3 f3       	brvs	.-24     	; 0x14b4 <inverse+0x10>
    14cc:	91 50       	subi	r25, 0x01	; 1
    14ce:	50 40       	sbci	r21, 0x00	; 0
    14d0:	94 f0       	brlt	.+36     	; 0x14f6 <ldexp+0x3a>
    14d2:	59 f0       	breq	.+22     	; 0x14ea <ldexp+0x2e>
    14d4:	88 23       	and	r24, r24
    14d6:	32 f0       	brmi	.+12     	; 0x14e4 <ldexp+0x28>
    14d8:	66 0f       	add	r22, r22
    14da:	77 1f       	adc	r23, r23
    14dc:	88 1f       	adc	r24, r24
    14de:	91 50       	subi	r25, 0x01	; 1
    14e0:	50 40       	sbci	r21, 0x00	; 0
    14e2:	c1 f7       	brne	.-16     	; 0x14d4 <ldexp+0x18>
    14e4:	9e 3f       	cpi	r25, 0xFE	; 254
    14e6:	51 05       	cpc	r21, r1
    14e8:	2c f7       	brge	.-54     	; 0x14b4 <inverse+0x10>
    14ea:	88 0f       	add	r24, r24
    14ec:	91 1d       	adc	r25, r1
    14ee:	96 95       	lsr	r25
    14f0:	87 95       	ror	r24
    14f2:	97 f9       	bld	r25, 7
    14f4:	08 95       	ret
    14f6:	5f 3f       	cpi	r21, 0xFF	; 255
    14f8:	ac f0       	brlt	.+42     	; 0x1524 <ldexp+0x68>
    14fa:	98 3e       	cpi	r25, 0xE8	; 232
    14fc:	9c f0       	brlt	.+38     	; 0x1524 <ldexp+0x68>
    14fe:	bb 27       	eor	r27, r27
    1500:	86 95       	lsr	r24
    1502:	77 95       	ror	r23
    1504:	67 95       	ror	r22
    1506:	b7 95       	ror	r27
    1508:	08 f4       	brcc	.+2      	; 0x150c <ldexp+0x50>
    150a:	b1 60       	ori	r27, 0x01	; 1
    150c:	93 95       	inc	r25
    150e:	c1 f7       	brne	.-16     	; 0x1500 <ldexp+0x44>
    1510:	bb 0f       	add	r27, r27
    1512:	58 f7       	brcc	.-42     	; 0x14ea <ldexp+0x2e>
    1514:	11 f4       	brne	.+4      	; 0x151a <ldexp+0x5e>
    1516:	60 ff       	sbrs	r22, 0
    1518:	e8 cf       	rjmp	.-48     	; 0x14ea <ldexp+0x2e>
    151a:	6f 5f       	subi	r22, 0xFF	; 255
    151c:	7f 4f       	sbci	r23, 0xFF	; 255
    151e:	8f 4f       	sbci	r24, 0xFF	; 255
    1520:	9f 4f       	sbci	r25, 0xFF	; 255
    1522:	e3 cf       	rjmp	.-58     	; 0x14ea <ldexp+0x2e>
    1524:	0c 94 47 0a 	jmp	0x148e	; 0x148e <__fp_szero>

00001528 <modf>:
    1528:	fa 01       	movw	r30, r20
    152a:	dc 01       	movw	r26, r24
    152c:	aa 0f       	add	r26, r26
    152e:	bb 1f       	adc	r27, r27
    1530:	9b 01       	movw	r18, r22
    1532:	ac 01       	movw	r20, r24
    1534:	bf 57       	subi	r27, 0x7F	; 127
    1536:	28 f4       	brcc	.+10     	; 0x1542 <modf+0x1a>
    1538:	22 27       	eor	r18, r18
    153a:	33 27       	eor	r19, r19
    153c:	44 27       	eor	r20, r20
    153e:	50 78       	andi	r21, 0x80	; 128
    1540:	20 c0       	rjmp	.+64     	; 0x1582 <modf+0x5a>
    1542:	b7 51       	subi	r27, 0x17	; 23
    1544:	90 f4       	brcc	.+36     	; 0x156a <modf+0x42>
    1546:	ab 2f       	mov	r26, r27
    1548:	00 24       	eor	r0, r0
    154a:	46 95       	lsr	r20
    154c:	37 95       	ror	r19
    154e:	27 95       	ror	r18
    1550:	01 1c       	adc	r0, r1
    1552:	a3 95       	inc	r26
    1554:	d2 f3       	brmi	.-12     	; 0x154a <modf+0x22>
    1556:	00 20       	and	r0, r0
    1558:	71 f0       	breq	.+28     	; 0x1576 <modf+0x4e>
    155a:	22 0f       	add	r18, r18
    155c:	33 1f       	adc	r19, r19
    155e:	44 1f       	adc	r20, r20
    1560:	b3 95       	inc	r27
    1562:	da f3       	brmi	.-10     	; 0x155a <modf+0x32>
    1564:	0e d0       	rcall	.+28     	; 0x1582 <modf+0x5a>
    1566:	0c 94 08 08 	jmp	0x1010	; 0x1010 <__subsf3>
    156a:	61 30       	cpi	r22, 0x01	; 1
    156c:	71 05       	cpc	r23, r1
    156e:	a0 e8       	ldi	r26, 0x80	; 128
    1570:	8a 07       	cpc	r24, r26
    1572:	b9 46       	sbci	r27, 0x69	; 105
    1574:	30 f4       	brcc	.+12     	; 0x1582 <modf+0x5a>
    1576:	9b 01       	movw	r18, r22
    1578:	ac 01       	movw	r20, r24
    157a:	66 27       	eor	r22, r22
    157c:	77 27       	eor	r23, r23
    157e:	88 27       	eor	r24, r24
    1580:	90 78       	andi	r25, 0x80	; 128
    1582:	30 96       	adiw	r30, 0x00	; 0
    1584:	21 f0       	breq	.+8      	; 0x158e <modf+0x66>
    1586:	20 83       	st	Z, r18
    1588:	31 83       	std	Z+1, r19	; 0x01
    158a:	42 83       	std	Z+2, r20	; 0x02
    158c:	53 83       	std	Z+3, r21	; 0x03
    158e:	08 95       	ret

00001590 <__mulsf3>:
    1590:	0e 94 db 0a 	call	0x15b6	; 0x15b6 <__mulsf3x>
    1594:	0c 94 13 0a 	jmp	0x1426	; 0x1426 <__fp_round>
    1598:	0e 94 05 0a 	call	0x140a	; 0x140a <__fp_pscA>
    159c:	38 f0       	brcs	.+14     	; 0x15ac <__mulsf3+0x1c>
    159e:	0e 94 0c 0a 	call	0x1418	; 0x1418 <__fp_pscB>
    15a2:	20 f0       	brcs	.+8      	; 0x15ac <__mulsf3+0x1c>
    15a4:	95 23       	and	r25, r21
    15a6:	11 f0       	breq	.+4      	; 0x15ac <__mulsf3+0x1c>
    15a8:	0c 94 d5 09 	jmp	0x13aa	; 0x13aa <__fp_inf>
    15ac:	0c 94 db 09 	jmp	0x13b6	; 0x13b6 <__fp_nan>
    15b0:	11 24       	eor	r1, r1
    15b2:	0c 94 47 0a 	jmp	0x148e	; 0x148e <__fp_szero>

000015b6 <__mulsf3x>:
    15b6:	0e 94 24 0a 	call	0x1448	; 0x1448 <__fp_split3>
    15ba:	70 f3       	brcs	.-36     	; 0x1598 <__mulsf3+0x8>

000015bc <__mulsf3_pse>:
    15bc:	95 9f       	mul	r25, r21
    15be:	c1 f3       	breq	.-16     	; 0x15b0 <__mulsf3+0x20>
    15c0:	95 0f       	add	r25, r21
    15c2:	50 e0       	ldi	r21, 0x00	; 0
    15c4:	55 1f       	adc	r21, r21
    15c6:	62 9f       	mul	r22, r18
    15c8:	f0 01       	movw	r30, r0
    15ca:	72 9f       	mul	r23, r18
    15cc:	bb 27       	eor	r27, r27
    15ce:	f0 0d       	add	r31, r0
    15d0:	b1 1d       	adc	r27, r1
    15d2:	63 9f       	mul	r22, r19
    15d4:	aa 27       	eor	r26, r26
    15d6:	f0 0d       	add	r31, r0
    15d8:	b1 1d       	adc	r27, r1
    15da:	aa 1f       	adc	r26, r26
    15dc:	64 9f       	mul	r22, r20
    15de:	66 27       	eor	r22, r22
    15e0:	b0 0d       	add	r27, r0
    15e2:	a1 1d       	adc	r26, r1
    15e4:	66 1f       	adc	r22, r22
    15e6:	82 9f       	mul	r24, r18
    15e8:	22 27       	eor	r18, r18
    15ea:	b0 0d       	add	r27, r0
    15ec:	a1 1d       	adc	r26, r1
    15ee:	62 1f       	adc	r22, r18
    15f0:	73 9f       	mul	r23, r19
    15f2:	b0 0d       	add	r27, r0
    15f4:	a1 1d       	adc	r26, r1
    15f6:	62 1f       	adc	r22, r18
    15f8:	83 9f       	mul	r24, r19
    15fa:	a0 0d       	add	r26, r0
    15fc:	61 1d       	adc	r22, r1
    15fe:	22 1f       	adc	r18, r18
    1600:	74 9f       	mul	r23, r20
    1602:	33 27       	eor	r19, r19
    1604:	a0 0d       	add	r26, r0
    1606:	61 1d       	adc	r22, r1
    1608:	23 1f       	adc	r18, r19
    160a:	84 9f       	mul	r24, r20
    160c:	60 0d       	add	r22, r0
    160e:	21 1d       	adc	r18, r1
    1610:	82 2f       	mov	r24, r18
    1612:	76 2f       	mov	r23, r22
    1614:	6a 2f       	mov	r22, r26
    1616:	11 24       	eor	r1, r1
    1618:	9f 57       	subi	r25, 0x7F	; 127
    161a:	50 40       	sbci	r21, 0x00	; 0
    161c:	9a f0       	brmi	.+38     	; 0x1644 <__mulsf3_pse+0x88>
    161e:	f1 f0       	breq	.+60     	; 0x165c <__mulsf3_pse+0xa0>
    1620:	88 23       	and	r24, r24
    1622:	4a f0       	brmi	.+18     	; 0x1636 <__mulsf3_pse+0x7a>
    1624:	ee 0f       	add	r30, r30
    1626:	ff 1f       	adc	r31, r31
    1628:	bb 1f       	adc	r27, r27
    162a:	66 1f       	adc	r22, r22
    162c:	77 1f       	adc	r23, r23
    162e:	88 1f       	adc	r24, r24
    1630:	91 50       	subi	r25, 0x01	; 1
    1632:	50 40       	sbci	r21, 0x00	; 0
    1634:	a9 f7       	brne	.-22     	; 0x1620 <__mulsf3_pse+0x64>
    1636:	9e 3f       	cpi	r25, 0xFE	; 254
    1638:	51 05       	cpc	r21, r1
    163a:	80 f0       	brcs	.+32     	; 0x165c <__mulsf3_pse+0xa0>
    163c:	0c 94 d5 09 	jmp	0x13aa	; 0x13aa <__fp_inf>
    1640:	0c 94 47 0a 	jmp	0x148e	; 0x148e <__fp_szero>
    1644:	5f 3f       	cpi	r21, 0xFF	; 255
    1646:	e4 f3       	brlt	.-8      	; 0x1640 <__mulsf3_pse+0x84>
    1648:	98 3e       	cpi	r25, 0xE8	; 232
    164a:	d4 f3       	brlt	.-12     	; 0x1640 <__mulsf3_pse+0x84>
    164c:	86 95       	lsr	r24
    164e:	77 95       	ror	r23
    1650:	67 95       	ror	r22
    1652:	b7 95       	ror	r27
    1654:	f7 95       	ror	r31
    1656:	e7 95       	ror	r30
    1658:	9f 5f       	subi	r25, 0xFF	; 255
    165a:	c1 f7       	brne	.-16     	; 0x164c <__mulsf3_pse+0x90>
    165c:	fe 2b       	or	r31, r30
    165e:	88 0f       	add	r24, r24
    1660:	91 1d       	adc	r25, r1
    1662:	96 95       	lsr	r25
    1664:	87 95       	ror	r24
    1666:	97 f9       	bld	r25, 7
    1668:	08 95       	ret

0000166a <sin>:
    166a:	9f 93       	push	r25
    166c:	0e 94 4d 0b 	call	0x169a	; 0x169a <__fp_rempio2>
    1670:	0f 90       	pop	r0
    1672:	07 fc       	sbrc	r0, 7
    1674:	ee 5f       	subi	r30, 0xFE	; 254
    1676:	0c 94 76 0b 	jmp	0x16ec	; 0x16ec <__fp_sinus>

0000167a <__fp_mpack>:
    167a:	9f 3f       	cpi	r25, 0xFF	; 255
    167c:	31 f0       	breq	.+12     	; 0x168a <__fp_mpack_finite+0xc>

0000167e <__fp_mpack_finite>:
    167e:	91 50       	subi	r25, 0x01	; 1
    1680:	20 f4       	brcc	.+8      	; 0x168a <__fp_mpack_finite+0xc>
    1682:	87 95       	ror	r24
    1684:	77 95       	ror	r23
    1686:	67 95       	ror	r22
    1688:	b7 95       	ror	r27
    168a:	88 0f       	add	r24, r24
    168c:	91 1d       	adc	r25, r1
    168e:	96 95       	lsr	r25
    1690:	87 95       	ror	r24
    1692:	97 f9       	bld	r25, 7
    1694:	08 95       	ret
    1696:	0c 94 db 09 	jmp	0x13b6	; 0x13b6 <__fp_nan>

0000169a <__fp_rempio2>:
    169a:	0e 94 2c 0a 	call	0x1458	; 0x1458 <__fp_splitA>
    169e:	d8 f3       	brcs	.-10     	; 0x1696 <__fp_mpack_finite+0x18>
    16a0:	e8 94       	clt
    16a2:	e0 e0       	ldi	r30, 0x00	; 0
    16a4:	bb 27       	eor	r27, r27
    16a6:	9f 57       	subi	r25, 0x7F	; 127
    16a8:	f0 f0       	brcs	.+60     	; 0x16e6 <__fp_rempio2+0x4c>
    16aa:	2a ed       	ldi	r18, 0xDA	; 218
    16ac:	3f e0       	ldi	r19, 0x0F	; 15
    16ae:	49 ec       	ldi	r20, 0xC9	; 201
    16b0:	06 c0       	rjmp	.+12     	; 0x16be <__fp_rempio2+0x24>
    16b2:	ee 0f       	add	r30, r30
    16b4:	bb 0f       	add	r27, r27
    16b6:	66 1f       	adc	r22, r22
    16b8:	77 1f       	adc	r23, r23
    16ba:	88 1f       	adc	r24, r24
    16bc:	28 f0       	brcs	.+10     	; 0x16c8 <__fp_rempio2+0x2e>
    16be:	b2 3a       	cpi	r27, 0xA2	; 162
    16c0:	62 07       	cpc	r22, r18
    16c2:	73 07       	cpc	r23, r19
    16c4:	84 07       	cpc	r24, r20
    16c6:	28 f0       	brcs	.+10     	; 0x16d2 <__fp_rempio2+0x38>
    16c8:	b2 5a       	subi	r27, 0xA2	; 162
    16ca:	62 0b       	sbc	r22, r18
    16cc:	73 0b       	sbc	r23, r19
    16ce:	84 0b       	sbc	r24, r20
    16d0:	e3 95       	inc	r30
    16d2:	9a 95       	dec	r25
    16d4:	72 f7       	brpl	.-36     	; 0x16b2 <__fp_rempio2+0x18>
    16d6:	80 38       	cpi	r24, 0x80	; 128
    16d8:	30 f4       	brcc	.+12     	; 0x16e6 <__fp_rempio2+0x4c>
    16da:	9a 95       	dec	r25
    16dc:	bb 0f       	add	r27, r27
    16de:	66 1f       	adc	r22, r22
    16e0:	77 1f       	adc	r23, r23
    16e2:	88 1f       	adc	r24, r24
    16e4:	d2 f7       	brpl	.-12     	; 0x16da <__fp_rempio2+0x40>
    16e6:	90 48       	sbci	r25, 0x80	; 128
    16e8:	0c 94 3f 0b 	jmp	0x167e	; 0x167e <__fp_mpack_finite>

000016ec <__fp_sinus>:
    16ec:	ef 93       	push	r30
    16ee:	e0 ff       	sbrs	r30, 0
    16f0:	07 c0       	rjmp	.+14     	; 0x1700 <__fp_sinus+0x14>
    16f2:	a2 ea       	ldi	r26, 0xA2	; 162
    16f4:	2a ed       	ldi	r18, 0xDA	; 218
    16f6:	3f e0       	ldi	r19, 0x0F	; 15
    16f8:	49 ec       	ldi	r20, 0xC9	; 201
    16fa:	5f eb       	ldi	r21, 0xBF	; 191
    16fc:	0e 94 20 08 	call	0x1040	; 0x1040 <__addsf3x>
    1700:	0e 94 13 0a 	call	0x1426	; 0x1426 <__fp_round>
    1704:	0f 90       	pop	r0
    1706:	03 94       	inc	r0
    1708:	01 fc       	sbrc	r0, 1
    170a:	90 58       	subi	r25, 0x80	; 128
    170c:	e4 ea       	ldi	r30, 0xA4	; 164
    170e:	f0 e0       	ldi	r31, 0x00	; 0
    1710:	0c 94 8a 0b 	jmp	0x1714	; 0x1714 <__fp_powsodd>

00001714 <__fp_powsodd>:
    1714:	9f 93       	push	r25
    1716:	8f 93       	push	r24
    1718:	7f 93       	push	r23
    171a:	6f 93       	push	r22
    171c:	ff 93       	push	r31
    171e:	ef 93       	push	r30
    1720:	9b 01       	movw	r18, r22
    1722:	ac 01       	movw	r20, r24
    1724:	0e 94 c8 0a 	call	0x1590	; 0x1590 <__mulsf3>
    1728:	ef 91       	pop	r30
    172a:	ff 91       	pop	r31
    172c:	0e 94 de 09 	call	0x13bc	; 0x13bc <__fp_powser>
    1730:	2f 91       	pop	r18
    1732:	3f 91       	pop	r19
    1734:	4f 91       	pop	r20
    1736:	5f 91       	pop	r21
    1738:	0c 94 c8 0a 	jmp	0x1590	; 0x1590 <__mulsf3>

0000173c <__udivmodsi4>:
    173c:	a1 e2       	ldi	r26, 0x21	; 33
    173e:	1a 2e       	mov	r1, r26
    1740:	aa 1b       	sub	r26, r26
    1742:	bb 1b       	sub	r27, r27
    1744:	fd 01       	movw	r30, r26
    1746:	0d c0       	rjmp	.+26     	; 0x1762 <__udivmodsi4_ep>

00001748 <__udivmodsi4_loop>:
    1748:	aa 1f       	adc	r26, r26
    174a:	bb 1f       	adc	r27, r27
    174c:	ee 1f       	adc	r30, r30
    174e:	ff 1f       	adc	r31, r31
    1750:	a2 17       	cp	r26, r18
    1752:	b3 07       	cpc	r27, r19
    1754:	e4 07       	cpc	r30, r20
    1756:	f5 07       	cpc	r31, r21
    1758:	20 f0       	brcs	.+8      	; 0x1762 <__udivmodsi4_ep>
    175a:	a2 1b       	sub	r26, r18
    175c:	b3 0b       	sbc	r27, r19
    175e:	e4 0b       	sbc	r30, r20
    1760:	f5 0b       	sbc	r31, r21

00001762 <__udivmodsi4_ep>:
    1762:	66 1f       	adc	r22, r22
    1764:	77 1f       	adc	r23, r23
    1766:	88 1f       	adc	r24, r24
    1768:	99 1f       	adc	r25, r25
    176a:	1a 94       	dec	r1
    176c:	69 f7       	brne	.-38     	; 0x1748 <__udivmodsi4_loop>
    176e:	60 95       	com	r22
    1770:	70 95       	com	r23
    1772:	80 95       	com	r24
    1774:	90 95       	com	r25
    1776:	9b 01       	movw	r18, r22
    1778:	ac 01       	movw	r20, r24
    177a:	bd 01       	movw	r22, r26
    177c:	cf 01       	movw	r24, r30
    177e:	08 95       	ret

00001780 <_exit>:
    1780:	f8 94       	cli

00001782 <__stop_program>:
    1782:	ff cf       	rjmp	.-2      	; 0x1782 <__stop_program>
