
Hjernebyggesett_V4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000016  00803800  0000183a  000018ee  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000017fa  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000040  000097fa  000017fa  000018ae  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .bss          00000054  00803816  00803816  00001904  2**0
                  ALLOC
  4 .comment      00000030  00000000  00000000  00001904  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001934  2**2
                  CONTENTS, READONLY
  6 .debug_aranges 000004f0  00000000  00000000  00001978  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000872f  00000000  00000000  00001e68  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00003636  00000000  00000000  0000a597  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   0000288d  00000000  00000000  0000dbcd  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  0000086c  00000000  00000000  0001045c  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000034d7  00000000  00000000  00010cc8  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    00001400  00000000  00000000  0001419f  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000368  00000000  00000000  0001559f  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 61 00 	jmp	0xc2	; 0xc2 <__ctors_end>
       4:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
       8:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
       c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      10:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      14:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      18:	0c 94 e5 04 	jmp	0x9ca	; 0x9ca <__vector_6>
      1c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      20:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      24:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      28:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      2c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      30:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      34:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      38:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      3c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      40:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      44:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      48:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      4c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      50:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      54:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      58:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      5c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      60:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      64:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      68:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      6c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      70:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      74:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      78:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      7c:	07 63       	ori	r16, 0x37	; 55
      7e:	42 36       	cpi	r20, 0x62	; 98
      80:	b7 9b       	sbis	0x16, 7	; 22
      82:	d8 a7       	std	Y+40, r29	; 0x28
      84:	1a 39       	cpi	r17, 0x9A	; 154
      86:	68 56       	subi	r22, 0x68	; 104
      88:	18 ae       	std	Y+56, r1	; 0x38
      8a:	ba ab       	std	Y+50, r27	; 0x32
      8c:	55 8c       	ldd	r5, Z+29	; 0x1d
      8e:	1d 3c       	cpi	r17, 0xCD	; 205
      90:	b7 cc       	rjmp	.-1682   	; 0xfffffa00 <__eeprom_end+0xff7efa00>
      92:	57 63       	ori	r21, 0x37	; 55
      94:	bd 6d       	ori	r27, 0xDD	; 221
      96:	ed fd       	.word	0xfded	; ????
      98:	75 3e       	cpi	r23, 0xE5	; 229
      9a:	f6 17       	cp	r31, r22
      9c:	72 31       	cpi	r23, 0x12	; 18
      9e:	bf 00       	.word	0x00bf	; ????
      a0:	00 00       	nop
      a2:	80 3f       	cpi	r24, 0xF0	; 240
      a4:	05 a8       	ldd	r0, Z+53	; 0x35
      a6:	4c cd       	rjmp	.-1384   	; 0xfffffb40 <__eeprom_end+0xff7efb40>
      a8:	b2 d4       	rcall	.+2404   	; 0xa0e <__vector_6+0x44>
      aa:	4e b9       	out	0x0e, r20	; 14
      ac:	38 36       	cpi	r19, 0x68	; 104
      ae:	a9 02       	muls	r26, r25
      b0:	0c 50       	subi	r16, 0x0C	; 12
      b2:	b9 91       	ld	r27, Y+
      b4:	86 88       	ldd	r8, Z+22	; 0x16
      b6:	08 3c       	cpi	r16, 0xC8	; 200
      b8:	a6 aa       	std	Z+54, r10	; 0x36
      ba:	aa 2a       	or	r10, r26
      bc:	be 00       	.word	0x00be	; ????
      be:	00 00       	nop
      c0:	80 3f       	cpi	r24, 0xF0	; 240

000000c2 <__ctors_end>:
      c2:	11 24       	eor	r1, r1
      c4:	1f be       	out	0x3f, r1	; 63
      c6:	cf ef       	ldi	r28, 0xFF	; 255
      c8:	cd bf       	out	0x3d, r28	; 61
      ca:	df e3       	ldi	r29, 0x3F	; 63
      cc:	de bf       	out	0x3e, r29	; 62

000000ce <__do_copy_data>:
      ce:	18 e3       	ldi	r17, 0x38	; 56
      d0:	a0 e0       	ldi	r26, 0x00	; 0
      d2:	b8 e3       	ldi	r27, 0x38	; 56
      d4:	ea e3       	ldi	r30, 0x3A	; 58
      d6:	f8 e1       	ldi	r31, 0x18	; 24
      d8:	02 c0       	rjmp	.+4      	; 0xde <__do_copy_data+0x10>
      da:	05 90       	lpm	r0, Z+
      dc:	0d 92       	st	X+, r0
      de:	a6 31       	cpi	r26, 0x16	; 22
      e0:	b1 07       	cpc	r27, r17
      e2:	d9 f7       	brne	.-10     	; 0xda <__do_copy_data+0xc>

000000e4 <__do_clear_bss>:
      e4:	28 e3       	ldi	r18, 0x38	; 56
      e6:	a6 e1       	ldi	r26, 0x16	; 22
      e8:	b8 e3       	ldi	r27, 0x38	; 56
      ea:	01 c0       	rjmp	.+2      	; 0xee <.do_clear_bss_start>

000000ec <.do_clear_bss_loop>:
      ec:	1d 92       	st	X+, r1

000000ee <.do_clear_bss_start>:
      ee:	aa 36       	cpi	r26, 0x6A	; 106
      f0:	b2 07       	cpc	r27, r18
      f2:	e1 f7       	brne	.-8      	; 0xec <.do_clear_bss_loop>
      f4:	0e 94 83 00 	call	0x106	; 0x106 <main>
      f8:	0c 94 fb 0b 	jmp	0x17f6	; 0x17f6 <_exit>

000000fc <__bad_interrupt>:
      fc:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000100 <atmel_start_init>:
/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
	system_init();
     100:	0e 94 9b 01 	call	0x336	; 0x336 <system_init>
     104:	08 95       	ret

00000106 <main>:

int main(void)
{	
	
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
     106:	0e 94 80 00 	call	0x100	; 0x100 <atmel_start_init>
	For some reason, instead of the reference voltage being 4.32v, it is 3.3v. 
	A plausible explanation is that the microchip does not up the voltage, so that if the microchip is only ever 
	supplied with 3.3v, it will output 3.3v as the max.
	*/
	
	VREF.CTRLA |= VREF_DAC0REFSEL_4V34_gc;
     10a:	e0 ea       	ldi	r30, 0xA0	; 160
     10c:	f0 e0       	ldi	r31, 0x00	; 0
     10e:	80 81       	ld	r24, Z
     110:	83 60       	ori	r24, 0x03	; 3
     112:	80 83       	st	Z, r24
	while (1)
	{
		// We don't want to update the neuron too often because of various reasons. The tinyISR_getflag is set every ms, and so the loop is only run once every ms.  
		if(tinyISR_getflag())
     114:	0e 94 13 05 	call	0xa26	; 0xa26 <tinyISR_getflag>
     118:	88 23       	and	r24, r24
     11a:	e1 f3       	breq	.-8      	; 0x114 <main+0xe>
		{
			
			if(tinyCharge_is_connected_to_charger()){
     11c:	0e 94 9c 03 	call	0x738	; 0x738 <tinyCharge_is_connected_to_charger>
     120:	88 23       	and	r24, r24
     122:	79 f0       	breq	.+30     	; 0x142 <main+0x3c>
				// Charge loop
				
				if(tinyCharge_is_fully_charged()){
     124:	0e 94 9f 03 	call	0x73e	; 0x73e <tinyCharge_is_fully_charged>
     128:	88 23       	and	r24, r24
     12a:	41 f0       	breq	.+16     	; 0x13c <main+0x36>
					tinyLED_set_color(INN_LED, CHARGING_DONE_COLOR);
     12c:	63 e0       	ldi	r22, 0x03	; 3
     12e:	80 e0       	ldi	r24, 0x00	; 0
     130:	0e 94 2a 05 	call	0xa54	; 0xa54 <tinyLED_set_color>
					tinyLED_set_color(OUT_LED, OFF);
     134:	60 e0       	ldi	r22, 0x00	; 0
     136:	81 e0       	ldi	r24, 0x01	; 1
     138:	0e 94 2a 05 	call	0xa54	; 0xa54 <tinyLED_set_color>
				}				
				// We check the Dendrites in order to detect if we have stopped charging
				tinyDendrite_update_signals();
     13c:	0e 94 e0 03 	call	0x7c0	; 0x7c0 <tinyDendrite_update_signals>
     140:	07 c0       	rjmp	.+14     	; 0x150 <main+0x4a>
			}
			else{
				// Main loop			
				
				// Set LED
				if(tinyLED_get_color(OUT_LED) == OFF && PING_COLOR != OFF){
     142:	81 e0       	ldi	r24, 0x01	; 1
     144:	0e 94 33 05 	call	0xa66	; 0xa66 <tinyLED_get_color>
					tinyLED_set_color_mode(OUT_LED, PING_COLOR, PING);
				}
				
				// Update button	
				tinyButton_update();
     148:	0e 94 3d 03 	call	0x67a	; 0x67a <tinyButton_update>
				
				// Update the potential (This is where most of the important stuff happens)
				tinyPotential_update();
     14c:	0e 94 5d 07 	call	0xeba	; 0xeba <tinyPotential_update>
			}
			// Update LED
			tinyLED_update();
     150:	0e 94 7b 05 	call	0xaf6	; 0xaf6 <tinyLED_update>
				
			// Switch transistors
			tinyCharge_set_transistors();
     154:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <tinyCharge_set_transistors>
			
			// Prepare for next cycle
			tinyISR_setflag(false);
     158:	80 e0       	ldi	r24, 0x00	; 0
     15a:	0e 94 10 05 	call	0xa20	; 0xa20 <tinyISR_setflag>
			tinyDebugger_send_uint32("time", tinyTime_now());
     15e:	0e 94 3a 08 	call	0x1074	; 0x1074 <tinyTime_now>
     162:	ab 01       	movw	r20, r22
     164:	bc 01       	movw	r22, r24
     166:	8a ef       	ldi	r24, 0xFA	; 250
     168:	97 e9       	ldi	r25, 0x97	; 151
     16a:	0e 94 dc 03 	call	0x7b8	; 0x7b8 <tinyDebugger_send_uint32>
			tinyDebugger_end_line();
     16e:	0e 94 df 03 	call	0x7be	; 0x7be <tinyDebugger_end_line>
     172:	d0 cf       	rjmp	.-96     	; 0x114 <main+0xe>

00000174 <ADC_0_init>:
 * \return Conversion result read from the ADC_0 ADC module
 */
adc_result_t ADC_0_get_conversion_result(void)
{
	return (ADC1.RES);
}
     174:	e0 e4       	ldi	r30, 0x40	; 64
     176:	f6 e0       	ldi	r31, 0x06	; 6
     178:	80 e1       	ldi	r24, 0x10	; 16
     17a:	82 83       	std	Z+2, r24	; 0x02
     17c:	85 e0       	ldi	r24, 0x05	; 5
     17e:	80 83       	st	Z, r24
     180:	80 e0       	ldi	r24, 0x00	; 0
     182:	08 95       	ret

00000184 <ADC_0_is_conversion_done>:
     184:	80 91 4b 06 	lds	r24, 0x064B	; 0x80064b <__TEXT_REGION_LENGTH__+0x70064b>
     188:	81 70       	andi	r24, 0x01	; 1
     18a:	08 95       	ret

0000018c <ADC_0_get_conversion>:
 *
 * \return Nothing
 */
void ADC_0_start_conversion(adc_1_channel_t channel)
{
	ADC1.MUXPOS  = channel;
     18c:	e0 e4       	ldi	r30, 0x40	; 64
     18e:	f6 e0       	ldi	r31, 0x06	; 6
     190:	86 83       	std	Z+6, r24	; 0x06
	ADC1.COMMAND = ADC_STCONV_bm;
     192:	81 e0       	ldi	r24, 0x01	; 1
     194:	80 87       	std	Z+8, r24	; 0x08
adc_result_t ADC_0_get_conversion(adc_1_channel_t channel)
{
	adc_result_t res;

	ADC_0_start_conversion(channel);
	while (!ADC_0_is_conversion_done())
     196:	0e 94 c2 00 	call	0x184	; 0x184 <ADC_0_is_conversion_done>
     19a:	88 23       	and	r24, r24
     19c:	e1 f3       	breq	.-8      	; 0x196 <ADC_0_get_conversion+0xa>
 *
 * \return Conversion result read from the ADC_0 ADC module
 */
adc_result_t ADC_0_get_conversion_result(void)
{
	return (ADC1.RES);
     19e:	e0 e4       	ldi	r30, 0x40	; 64
     1a0:	f6 e0       	ldi	r31, 0x06	; 6
     1a2:	20 89       	ldd	r18, Z+16	; 0x10
     1a4:	31 89       	ldd	r19, Z+17	; 0x11

	ADC_0_start_conversion(channel);
	while (!ADC_0_is_conversion_done())
		;
	res = ADC_0_get_conversion_result();
	ADC1.INTFLAGS |= ADC_RESRDY_bm;
     1a6:	93 85       	ldd	r25, Z+11	; 0x0b
     1a8:	91 60       	ori	r25, 0x01	; 1
     1aa:	93 87       	std	Z+11, r25	; 0x0b
	return res;
}
     1ac:	c9 01       	movw	r24, r18
     1ae:	08 95       	ret

000001b0 <BOD_init>:
	//		 | BOD_VLMCFG_BELOW_gc; /* Interrupt when supply goes below VLM level */

	// BOD.VLMCTRLA = BOD_VLMLVL_5ABOVE_gc; /* VLM threshold 5% above BOD level */

	return 0;
}
     1b0:	80 e0       	ldi	r24, 0x00	; 0
     1b2:	08 95       	ret

000001b4 <DIGITAL_GLUE_LOGIC_0_init>:

	// Enable Protected register, peripheral must be disabled (ENABLE=0, in TCD.LUT0CTRLA).

	// CCL.SEQCTRL0 = CCL_SEQSEL_DISABLE_gc /* Sequential logic disabled */;

	CCL.TRUTH0 = 168; /* Truth 0: 168 */
     1b4:	e0 ec       	ldi	r30, 0xC0	; 192
     1b6:	f1 e0       	ldi	r31, 0x01	; 1
     1b8:	28 ea       	ldi	r18, 0xA8	; 168
     1ba:	20 87       	std	Z+8, r18	; 0x08

	CCL.LUT0CTRLC = CCL_INSEL2_TCA0_gc /* TCA0 WO2 input source */;
     1bc:	98 e0       	ldi	r25, 0x08	; 8
     1be:	97 83       	std	Z+7, r25	; 0x07

	CCL.LUT0CTRLB = CCL_INSEL0_SPI0_gc /* SPI0 SCK source */
     1c0:	8b eb       	ldi	r24, 0xBB	; 187
     1c2:	86 83       	std	Z+6, r24	; 0x06
	                | CCL_INSEL1_SPI0_gc /* SPI0 MOSI input source */;

	CCL.LUT0CTRLA = 0 << CCL_CLKSRC_bp       /* Clock Source Selection: disabled */
     1c4:	39 e0       	ldi	r19, 0x09	; 9
     1c6:	35 83       	std	Z+5, r19	; 0x05
	                | CCL_EDGEDET_DIS_gc     /* Edge detector is disabled */
	                | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	                | 1 << CCL_ENABLE_bp     /* LUT Enable: enabled */
	                | 1 << CCL_OUTEN_bp;     /* Output Enable: enabled */

	CCL.TRUTH1 = 168; /* Truth 1: 168 */
     1c8:	24 87       	std	Z+12, r18	; 0x0c

	CCL.LUT1CTRLC = CCL_INSEL2_TCA0_gc /* TCA0 WO2 input source */;
     1ca:	93 87       	std	Z+11, r25	; 0x0b

	CCL.LUT1CTRLB = CCL_INSEL0_SPI0_gc /* SPI0 SCK source */
     1cc:	82 87       	std	Z+10, r24	; 0x0a
	//		 | CCL_EDGEDET_DIS_gc /* Edge detector is disabled */
	//		 | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	//		 | 0 << CCL_ENABLE_bp /* LUT Enable: disabled */
	//		 | 0 << CCL_OUTEN_bp; /* Output Enable: disabled */

	CCL.CTRLA = 1 << CCL_ENABLE_bp      /* Enable: enabled */
     1ce:	81 e4       	ldi	r24, 0x41	; 65
     1d0:	80 83       	st	Z, r24
	            | 1 << CCL_RUNSTDBY_bp; /* Run in Standby: enabled */

	return 0;
}
     1d2:	80 e0       	ldi	r24, 0x00	; 0
     1d4:	08 95       	ret

000001d6 <CLKCTRL_init>:
 *       on calling convention. The memory model is not visible to the
 *       preprocessor, so it must be defined in the Assembler preprocessor directives.
 */
static inline void ccp_write_io(void *addr, uint8_t value)
{
	protected_write_io(addr, CCP_IOREG_gc, value);
     1d6:	47 e0       	ldi	r20, 0x07	; 7
     1d8:	68 ed       	ldi	r22, 0xD8	; 216
     1da:	8c e7       	ldi	r24, 0x7C	; 124
     1dc:	90 e0       	ldi	r25, 0x00	; 0
     1de:	0e 94 c8 01 	call	0x390	; 0x390 <protected_write_io>
     1e2:	41 e0       	ldi	r20, 0x01	; 1
     1e4:	68 ed       	ldi	r22, 0xD8	; 216
     1e6:	81 e6       	ldi	r24, 0x61	; 97
     1e8:	90 e0       	ldi	r25, 0x00	; 0
     1ea:	0e 94 c8 01 	call	0x390	; 0x390 <protected_write_io>
	//		 | 0 << CLKCTRL_CLKOUT_bp /* System clock out: disabled */);

	// ccp_write_io((void*)&(CLKCTRL.MCLKLOCK),0 << CLKCTRL_LOCKEN_bp /* lock enable: disabled */);

	return 0;
}
     1ee:	80 e0       	ldi	r24, 0x00	; 0
     1f0:	08 95       	ret

000001f2 <CPUINT_init>:

	// CPUINT.LVL0PRI = 0x0 << CPUINT_LVL0PRI_gp; /* Interrupt Level Priority: 0x0 */

	// CPUINT.LVL1VEC = 0x0 << CPUINT_LVL1VEC_gp; /* Interrupt Vector with High Priority: 0x0 */

	ENABLE_INTERRUPTS();
     1f2:	78 94       	sei

	return 0;
}
     1f4:	80 e0       	ldi	r24, 0x00	; 0
     1f6:	08 95       	ret

000001f8 <DAC_0_init>:
int8_t DAC_0_init()
{

	// DAC0.DATA = 0x0; /* DATA Register: 0x0 */

	DAC0.CTRLA = 1 << DAC_ENABLE_bp      /* DAC Enable: enabled */
     1f8:	81 e4       	ldi	r24, 0x41	; 65
     1fa:	80 93 a0 06 	sts	0x06A0, r24	; 0x8006a0 <__TEXT_REGION_LENGTH__+0x7006a0>
	             | 1 << DAC_OUTEN_bp     /* Output Buffer Enable: enabled */
	             | 0 << DAC_RUNSTDBY_bp; /* Run in Standby Mode: disabled */

	return 0;
}
     1fe:	80 e0       	ldi	r24, 0x00	; 0
     200:	08 95       	ret

00000202 <DAC_0_uninit>:
int8_t DAC_0_uninit()
{

	// DAC0.DATA = 0x0; /* DATA Register: 0x0 */

	DAC0.CTRLA = 1 << DAC_ENABLE_bp      /* DAC Enable: enabled */
     202:	81 e0       	ldi	r24, 0x01	; 1
     204:	80 93 a0 06 	sts	0x06A0, r24	; 0x8006a0 <__TEXT_REGION_LENGTH__+0x7006a0>
	| 0 << DAC_OUTEN_bp     /* Output Buffer Enable: disabled */
	| 0 << DAC_RUNSTDBY_bp; /* Run in Standby Mode: disabled */

	return 0;
}
     208:	80 e0       	ldi	r24, 0x00	; 0
     20a:	08 95       	ret

0000020c <DAC_0_enable>:
 *
 * \return Nothing
 */
void DAC_0_enable()
{
	DAC0.CTRLA |= DAC_ENABLE_bm;
     20c:	e0 ea       	ldi	r30, 0xA0	; 160
     20e:	f6 e0       	ldi	r31, 0x06	; 6
     210:	80 81       	ld	r24, Z
     212:	81 60       	ori	r24, 0x01	; 1
     214:	80 83       	st	Z, r24
     216:	08 95       	ret

00000218 <DAC_0_disable>:
 *
 * \return Nothing
 */
void DAC_0_disable()
{
	DAC0.CTRLA &= ~DAC_ENABLE_bm;
     218:	e0 ea       	ldi	r30, 0xA0	; 160
     21a:	f6 e0       	ldi	r31, 0x06	; 6
     21c:	80 81       	ld	r24, Z
     21e:	8e 7f       	andi	r24, 0xFE	; 254
     220:	80 83       	st	Z, r24
     222:	08 95       	ret

00000224 <DAC_0_set_output>:
 *
 * \return Nothing
 */
void DAC_0_set_output(dac_resolution_t value)
{
	DAC0.DATA = value;
     224:	80 93 a1 06 	sts	0x06A1, r24	; 0x8006a1 <__TEXT_REGION_LENGTH__+0x7006a1>
     228:	08 95       	ret

0000022a <mcu_init>:
#ifdef __cplusplus
extern "C" {
#endif

void mcu_init(void)
{
     22a:	e0 e1       	ldi	r30, 0x10	; 16
     22c:	f4 e0       	ldi	r31, 0x04	; 4
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     22e:	80 81       	ld	r24, Z
     230:	88 60       	ori	r24, 0x08	; 8
     232:	81 93       	st	Z+, r24
	 * disables all peripherals to save power. Driver shall enable
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
     234:	e8 31       	cpi	r30, 0x18	; 24
     236:	84 e0       	ldi	r24, 0x04	; 4
     238:	f8 07       	cpc	r31, r24
     23a:	c9 f7       	brne	.-14     	; 0x22e <mcu_init+0x4>
     23c:	e0 e3       	ldi	r30, 0x30	; 48
     23e:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     240:	80 81       	ld	r24, Z
     242:	88 60       	ori	r24, 0x08	; 8
     244:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     246:	e8 33       	cpi	r30, 0x38	; 56
     248:	84 e0       	ldi	r24, 0x04	; 4
     24a:	f8 07       	cpc	r31, r24
     24c:	c9 f7       	brne	.-14     	; 0x240 <mcu_init+0x16>
     24e:	e0 e5       	ldi	r30, 0x50	; 80
     250:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     252:	80 81       	ld	r24, Z
     254:	88 60       	ori	r24, 0x08	; 8
     256:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     258:	e8 35       	cpi	r30, 0x58	; 88
     25a:	84 e0       	ldi	r24, 0x04	; 4
     25c:	f8 07       	cpc	r31, r24
     25e:	c9 f7       	brne	.-14     	; 0x252 <mcu_init+0x28>
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}
}
     260:	08 95       	ret

00000262 <ADC_0_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     262:	e5 e1       	ldi	r30, 0x15	; 21
     264:	f4 e0       	ldi	r31, 0x04	; 4
     266:	80 81       	ld	r24, Z
     268:	88 7f       	andi	r24, 0xF8	; 248
     26a:	84 60       	ori	r24, 0x04	; 4
     26c:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     26e:	80 81       	ld	r24, Z
     270:	87 7f       	andi	r24, 0xF7	; 247
     272:	80 83       	st	Z, r24
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     274:	e7 e1       	ldi	r30, 0x17	; 23
     276:	f4 e0       	ldi	r31, 0x04	; 4
     278:	80 81       	ld	r24, Z
     27a:	88 7f       	andi	r24, 0xF8	; 248
     27c:	84 60       	ori	r24, 0x04	; 4
     27e:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     280:	80 81       	ld	r24, Z
     282:	87 7f       	andi	r24, 0xF7	; 247
     284:	80 83       	st	Z, r24
 */
static inline void PORTC_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     286:	e0 e5       	ldi	r30, 0x50	; 80
     288:	f4 e0       	ldi	r31, 0x04	; 4
     28a:	80 81       	ld	r24, Z
     28c:	88 7f       	andi	r24, 0xF8	; 248
     28e:	84 60       	ori	r24, 0x04	; 4
     290:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     292:	80 81       	ld	r24, Z
     294:	87 7f       	andi	r24, 0xF7	; 247
     296:	80 83       	st	Z, r24
 */
static inline void PORTC_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     298:	e1 e5       	ldi	r30, 0x51	; 81
     29a:	f4 e0       	ldi	r31, 0x04	; 4
     29c:	80 81       	ld	r24, Z
     29e:	88 7f       	andi	r24, 0xF8	; 248
     2a0:	84 60       	ori	r24, 0x04	; 4
     2a2:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2a4:	80 81       	ld	r24, Z
     2a6:	87 7f       	andi	r24, 0xF7	; 247
     2a8:	80 83       	st	Z, r24
 */
static inline void PORTC_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     2aa:	e3 e5       	ldi	r30, 0x53	; 83
     2ac:	f4 e0       	ldi	r31, 0x04	; 4
     2ae:	80 81       	ld	r24, Z
     2b0:	88 7f       	andi	r24, 0xF8	; 248
     2b2:	84 60       	ori	r24, 0x04	; 4
     2b4:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2b6:	80 81       	ld	r24, Z
     2b8:	87 7f       	andi	r24, 0xF7	; 247
     2ba:	80 83       	st	Z, r24
	// Disable digital input buffer
	DEN4_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	DEN4_PIN_set_pull_mode(PORT_PULL_OFF);

	ADC_0_init();
     2bc:	0e 94 ba 00 	call	0x174	; 0x174 <ADC_0_init>
     2c0:	08 95       	ret

000002c2 <USART_0_initialization>:
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     2c2:	23 98       	cbi	0x04, 3	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2c4:	e3 e3       	ldi	r30, 0x33	; 51
     2c6:	f4 e0       	ldi	r31, 0x04	; 4
     2c8:	80 81       	ld	r24, Z
     2ca:	87 7f       	andi	r24, 0xF7	; 247
     2cc:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     2ce:	22 9a       	sbi	0x04, 2	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     2d0:	2a 98       	cbi	0x05, 2	; 5
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	USART_0_init();
     2d2:	0e 94 02 02 	call	0x404	; 0x404 <USART_0_init>
     2d6:	08 95       	ret

000002d8 <TIMER_0_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     2d8:	25 9a       	sbi	0x04, 5	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     2da:	2d 98       	cbi	0x05, 5	; 5
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLC |= PORTMUX_TCA02_bm;
     2dc:	e0 e0       	ldi	r30, 0x00	; 0
     2de:	f2 e0       	ldi	r31, 0x02	; 2
     2e0:	82 81       	ldd	r24, Z+2	; 0x02
     2e2:	84 60       	ori	r24, 0x04	; 4
     2e4:	82 83       	std	Z+2, r24	; 0x02

	TIMER_0_init();
     2e6:	0e 94 f2 01 	call	0x3e4	; 0x3e4 <TIMER_0_init>
     2ea:	08 95       	ret

000002ec <DIGITAL_GLUE_LOGIC_0_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     2ec:	24 9a       	sbi	0x04, 4	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     2ee:	2c 98       	cbi	0x05, 4	; 5
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLA |= PORTMUX_LUT0_bm;
     2f0:	e0 e0       	ldi	r30, 0x00	; 0
     2f2:	f2 e0       	ldi	r31, 0x02	; 2
     2f4:	80 81       	ld	r24, Z
     2f6:	80 61       	ori	r24, 0x10	; 16
     2f8:	80 83       	st	Z, r24

	DIGITAL_GLUE_LOGIC_0_init();
     2fa:	0e 94 da 00 	call	0x1b4	; 0x1b4 <DIGITAL_GLUE_LOGIC_0_init>
     2fe:	08 95       	ret

00000300 <SPI_0_initialization>:
 */
static inline void PORTA_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
     300:	02 98       	cbi	0x00, 2	; 0
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     302:	e2 e1       	ldi	r30, 0x12	; 18
     304:	f4 e0       	ldi	r31, 0x04	; 4
     306:	80 81       	ld	r24, Z
     308:	87 7f       	andi	r24, 0xF7	; 247
     30a:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     30c:	01 9a       	sbi	0x00, 1	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     30e:	09 98       	cbi	0x01, 1	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     310:	03 9a       	sbi	0x00, 3	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     312:	0b 98       	cbi	0x01, 3	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     314:	04 9a       	sbi	0x00, 4	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     316:	0c 98       	cbi	0x01, 4	; 1
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	SPI_0_init();
     318:	0e 94 ea 01 	call	0x3d4	; 0x3d4 <SPI_0_init>
     31c:	08 95       	ret

0000031e <DAC_0_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     31e:	e6 e1       	ldi	r30, 0x16	; 22
     320:	f4 e0       	ldi	r31, 0x04	; 4
     322:	80 81       	ld	r24, Z
     324:	88 7f       	andi	r24, 0xF8	; 248
     326:	84 60       	ori	r24, 0x04	; 4
     328:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     32a:	80 81       	ld	r24, Z
     32c:	87 7f       	andi	r24, 0xF7	; 247
     32e:	80 83       	st	Z, r24
	// Disable digital input buffer
	AXON_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	AXON_PIN_set_pull_mode(PORT_PULL_OFF);

	DAC_0_init();
     330:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <DAC_0_init>
     334:	08 95       	ret

00000336 <system_init>:
/**
 * \brief System initialization
 */
void system_init()
{
	mcu_init();
     336:	0e 94 15 01 	call	0x22a	; 0x22a <mcu_init>
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     33a:	26 98       	cbi	0x04, 6	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     33c:	e6 e3       	ldi	r30, 0x36	; 54
     33e:	f4 e0       	ldi	r31, 0x04	; 4
     340:	80 81       	ld	r24, Z
     342:	87 7f       	andi	r24, 0xF7	; 247
     344:	80 83       	st	Z, r24
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     346:	27 98       	cbi	0x04, 7	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     348:	e7 e3       	ldi	r30, 0x37	; 55
     34a:	f4 e0       	ldi	r31, 0x04	; 4
     34c:	80 81       	ld	r24, Z
     34e:	87 7f       	andi	r24, 0xF7	; 247
     350:	80 83       	st	Z, r24
 */
static inline void PORTC_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
     352:	42 98       	cbi	0x08, 2	; 8
static inline void PORTC_set_pin_pull_mode(const uint8_t pin, const enum port_pull_mode pull_mode)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
     354:	e2 e5       	ldi	r30, 0x52	; 82
     356:	f4 e0       	ldi	r31, 0x04	; 4
     358:	80 81       	ld	r24, Z
     35a:	88 60       	ori	r24, 0x08	; 8
     35c:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTC.DIR |= (1 << pin);
     35e:	45 9a       	sbi	0x08, 5	; 8
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     360:	4d 9a       	sbi	0x09, 5	; 9
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    true);

	CLKCTRL_init();
     362:	0e 94 eb 00 	call	0x1d6	; 0x1d6 <CLKCTRL_init>

	RTC_0_init();
     366:	0e 94 cc 01 	call	0x398	; 0x398 <RTC_0_init>

	ADC_0_initialization();
     36a:	0e 94 31 01 	call	0x262	; 0x262 <ADC_0_initialization>

	USART_0_initialization();
     36e:	0e 94 61 01 	call	0x2c2	; 0x2c2 <USART_0_initialization>

	TIMER_0_initialization();
     372:	0e 94 6c 01 	call	0x2d8	; 0x2d8 <TIMER_0_initialization>

	DIGITAL_GLUE_LOGIC_0_initialization();
     376:	0e 94 76 01 	call	0x2ec	; 0x2ec <DIGITAL_GLUE_LOGIC_0_initialization>

	SPI_0_initialization();
     37a:	0e 94 80 01 	call	0x300	; 0x300 <SPI_0_initialization>

	DAC_0_initialization();
     37e:	0e 94 8f 01 	call	0x31e	; 0x31e <DAC_0_initialization>

	CPUINT_init();
     382:	0e 94 f9 00 	call	0x1f2	; 0x1f2 <CPUINT_init>

	SLPCTRL_init();
     386:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <SLPCTRL_init>

	BOD_init();
     38a:	0e 94 d8 00 	call	0x1b0	; 0x1b0 <BOD_init>
     38e:	08 95       	ret

00000390 <protected_write_io>:
#if defined(__GNUC__)
  
#ifdef RAMPZ
	out     _SFR_IO_ADDR(RAMPZ), r1         // Clear bits 23:16 of Z
#endif
	movw    r30, r24                // Load addr into Z
     390:	fc 01       	movw	r30, r24
	out     CCP, r22                // Start CCP handshake
     392:	64 bf       	out	0x34, r22	; 52
	st      Z, r20                  // Write value to I/O register
     394:	40 83       	st	Z, r20
	ret                             // Return to caller
     396:	08 95       	ret

00000398 <RTC_0_init>:
 * \return Initialization status.
 */
int8_t RTC_0_init()
{

	while (RTC.STATUS > 0) { /* Wait for all register to be synchronized */
     398:	e0 e4       	ldi	r30, 0x40	; 64
     39a:	f1 e0       	ldi	r31, 0x01	; 1
     39c:	81 81       	ldd	r24, Z+1	; 0x01
     39e:	81 11       	cpse	r24, r1
     3a0:	fd cf       	rjmp	.-6      	; 0x39c <RTC_0_init+0x4>
	}

	// RTC.CMP = 0x0; /* Compare: 0x0 */

	RTC.CNT = 0x20; /* Counter: 0x20 */
     3a2:	e0 e4       	ldi	r30, 0x40	; 64
     3a4:	f1 e0       	ldi	r31, 0x01	; 1
     3a6:	80 e2       	ldi	r24, 0x20	; 32
     3a8:	90 e0       	ldi	r25, 0x00	; 0
     3aa:	80 87       	std	Z+8, r24	; 0x08
     3ac:	91 87       	std	Z+9, r25	; 0x09

	RTC.CTRLA = RTC_PRESCALER_DIV1_gc   /* 1 */
     3ae:	81 e8       	ldi	r24, 0x81	; 129
     3b0:	80 83       	st	Z, r24
	            | 1 << RTC_RTCEN_bp     /* Enable: enabled */
	            | 1 << RTC_RUNSTDBY_bp; /* Run In Standby: enabled */

	RTC.PER = 0x20 / TIMESCALE; /* Period: 0x20 */
     3b2:	80 e4       	ldi	r24, 0x40	; 64
     3b4:	90 e0       	ldi	r25, 0x00	; 0
     3b6:	82 87       	std	Z+10, r24	; 0x0a
     3b8:	93 87       	std	Z+11, r25	; 0x0b

	// RTC.CLKSEL = RTC_CLKSEL_INT32K_gc; /* 32KHz Internal Ultra Low Power Oscillator (OSCULP32K) */

	RTC.DBGCTRL = 1 << RTC_DBGRUN_bp; /* Run in debug: enabled */
     3ba:	81 e0       	ldi	r24, 0x01	; 1
     3bc:	85 83       	std	Z+5, r24	; 0x05

	RTC.INTCTRL = 0 << RTC_CMP_bp    /* Compare Match Interrupt enable: disabled */
     3be:	82 83       	std	Z+2, r24	; 0x02
	              | 1 << RTC_OVF_bp; /* Overflow Interrupt enable: enabled */

	while (RTC.PITSTATUS > 0) { /* Wait for all register to be synchronized */
     3c0:	81 89       	ldd	r24, Z+17	; 0x11
     3c2:	81 11       	cpse	r24, r1
     3c4:	fd cf       	rjmp	.-6      	; 0x3c0 <RTC_0_init+0x28>
	}

	RTC.PITCTRLA = RTC_PERIOD_OFF_gc    /* Off */
     3c6:	81 e0       	ldi	r24, 0x01	; 1
     3c8:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <__TEXT_REGION_LENGTH__+0x700150>
	// RTC.PITDBGCTRL = 0 << RTC_DBGRUN_bp; /* Run in debug: disabled */

	// RTC.PITINTCTRL = 0 << RTC_PI_bp; /* Periodic Interrupt: disabled */

	return 0;
}
     3cc:	80 e0       	ldi	r24, 0x00	; 0
     3ce:	08 95       	ret

000003d0 <SLPCTRL_init>:

	// SLPCTRL.CTRLA = 0 << SLPCTRL_SEN_bp /* Sleep enable: disabled */
	//		 | SLPCTRL_SMODE_IDLE_gc; /* Idle mode */

	return 0;
}
     3d0:	80 e0       	ldi	r24, 0x00	; 0
     3d2:	08 95       	ret

000003d4 <SPI_0_init>:
 * \return Initialization status
 */
int8_t SPI_0_init()
{

	SPI0.CTRLA = 0 << SPI_CLK2X_bp     /* Enable Double Speed: disabled */
     3d4:	e0 e2       	ldi	r30, 0x20	; 32
     3d6:	f8 e0       	ldi	r31, 0x08	; 8
     3d8:	83 e2       	ldi	r24, 0x23	; 35
     3da:	80 83       	st	Z, r24
	             | 0 << SPI_DORD_bp    /* Data Order Setting: disabled */
	             | 1 << SPI_ENABLE_bp  /* Enable Module: enabled */
	             | 1 << SPI_MASTER_bp  /* SPI module in master mode */
	             | SPI_PRESC_DIV16_gc; /* System Clock / 16 */

	SPI0.CTRLB = 0 << SPI_BUFEN_bp   /* Buffer Mode Enable: disabled */
     3dc:	84 e0       	ldi	r24, 0x04	; 4
     3de:	81 83       	std	Z+1, r24	; 0x01
	//		 | 0 << SPI_RXCIE_bp /* Receive Complete Interrupt Enable: disabled */
	//		 | 0 << SPI_SSIE_bp /* Slave Select Trigger Interrupt Enable: disabled */
	//		 | 0 << SPI_TXCIE_bp; /* Transfer Complete Interrupt Enable: disabled */

	return 0;
}
     3e0:	80 e0       	ldi	r24, 0x00	; 0
     3e2:	08 95       	ret

000003e4 <TIMER_0_init>:

	// TCA0.SINGLE.CMP0 = 0x0; /* Compare Register 0: 0x0 */

	// TCA0.SINGLE.CMP1 = 0x0; /* Compare Register 1: 0x0 */

	TCA0.SINGLE.CMP2 = 0x4; /* Compare Register 2: 0x4 */
     3e4:	e0 e0       	ldi	r30, 0x00	; 0
     3e6:	fa e0       	ldi	r31, 0x0A	; 10
     3e8:	84 e0       	ldi	r24, 0x04	; 4
     3ea:	90 e0       	ldi	r25, 0x00	; 0
     3ec:	84 a7       	std	Z+44, r24	; 0x2c
     3ee:	95 a7       	std	Z+45, r25	; 0x2d

	// TCA0.SINGLE.CNT = 0x0; /* Count: 0x0 */

	TCA0.SINGLE.CTRLB = 0 << TCA_SINGLE_ALUPD_bp            /* Auto Lock Update: disabled */
     3f0:	83 e4       	ldi	r24, 0x43	; 67
     3f2:	81 83       	std	Z+1, r24	; 0x01
	                    | 0 << TCA_SINGLE_CMP0EN_bp         /* Compare 0 Enable: disabled */
	                    | 0 << TCA_SINGLE_CMP1EN_bp         /* Compare 1 Enable: disabled */
	                    | 1 << TCA_SINGLE_CMP2EN_bp         /* Compare 2 Enable: enabled */
	                    | TCA_SINGLE_WGMODE_SINGLESLOPE_gc; /*  */

	TCA0.SINGLE.CTRLC = 0 << TCA_SINGLE_CMP0OV_bp    /* Compare 0 Waveform Output Value: disabled */
     3f4:	84 e0       	ldi	r24, 0x04	; 4
     3f6:	82 83       	std	Z+2, r24	; 0x02
	// TCA0.SINGLE.INTCTRL = 0 << TCA_SINGLE_CMP0_bp /* Compare 0 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP1_bp /* Compare 1 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP2_bp /* Compare 2 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_OVF_bp; /* Overflow Interrupt: disabled */

	TCA0.SINGLE.PER = 0x7; /* Period: 0x7 */
     3f8:	87 e0       	ldi	r24, 0x07	; 7
     3fa:	90 e0       	ldi	r25, 0x00	; 0
     3fc:	86 a3       	std	Z+38, r24	; 0x26
     3fe:	97 a3       	std	Z+39, r25	; 0x27

	// TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV1_gc /* System Clock */
	//		 | 0 << TCA_SINGLE_ENABLE_bp; /* Module Enable: disabled */

	return 0;
}
     400:	80 e0       	ldi	r24, 0x00	; 0
     402:	08 95       	ret

00000404 <USART_0_init>:
uint8_t USART_0_read()
{
	while (!(USART0.STATUS & USART_RXCIF_bm))
		;
	return USART0.RXDATAL;
}
     404:	e0 e0       	ldi	r30, 0x00	; 0
     406:	f8 e0       	ldi	r31, 0x08	; 8
     408:	8b e5       	ldi	r24, 0x5B	; 91
     40a:	91 e0       	ldi	r25, 0x01	; 1
     40c:	80 87       	std	Z+8, r24	; 0x08
     40e:	91 87       	std	Z+9, r25	; 0x09
     410:	80 ec       	ldi	r24, 0xC0	; 192
     412:	86 83       	std	Z+6, r24	; 0x06
     414:	80 e0       	ldi	r24, 0x00	; 0
     416:	98 e3       	ldi	r25, 0x38	; 56
     418:	80 93 66 38 	sts	0x3866, r24	; 0x803866 <__iob+0x2>
     41c:	90 93 67 38 	sts	0x3867, r25	; 0x803867 <__iob+0x3>
     420:	80 e0       	ldi	r24, 0x00	; 0
     422:	08 95       	ret

00000424 <USART_0_write>:
 *
 * \return Nothing
 */
void USART_0_write(const uint8_t data)
{
	while (!(USART0.STATUS & USART_DREIF_bm))
     424:	e0 e0       	ldi	r30, 0x00	; 0
     426:	f8 e0       	ldi	r31, 0x08	; 8
     428:	94 81       	ldd	r25, Z+4	; 0x04
     42a:	95 ff       	sbrs	r25, 5
     42c:	fd cf       	rjmp	.-6      	; 0x428 <USART_0_write+0x4>
		;
	USART0.TXDATAL = data;
     42e:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <__TEXT_REGION_LENGTH__+0x700802>
     432:	08 95       	ret

00000434 <USART_0_printCHAR>:

#if defined(__GNUC__)

int USART_0_printCHAR(char character, FILE *stream)
{
	USART_0_write(character);
     434:	0e 94 12 02 	call	0x424	; 0x424 <USART_0_write>
	return 0;
}
     438:	80 e0       	ldi	r24, 0x00	; 0
     43a:	90 e0       	ldi	r25, 0x00	; 0
     43c:	08 95       	ret

0000043e <tinyAxon_add_pulse>:
{
	// We want to check each slot in the pulse_queue, and
	// if we find an empty slot (0), we add a pulse.
	for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
	{
		if(pulse_queue[i] == 0){
     43e:	20 91 16 38 	lds	r18, 0x3816	; 0x803816 <__data_end>
     442:	30 91 17 38 	lds	r19, 0x3817	; 0x803817 <__data_end+0x1>
     446:	23 2b       	or	r18, r19
     448:	51 f0       	breq	.+20     	; 0x45e <tinyAxon_add_pulse+0x20>
     44a:	e8 e1       	ldi	r30, 0x18	; 24
     44c:	f8 e3       	ldi	r31, 0x38	; 56
     44e:	21 e0       	ldi	r18, 0x01	; 1
     450:	30 e0       	ldi	r19, 0x00	; 0
     452:	b9 01       	movw	r22, r18
     454:	41 91       	ld	r20, Z+
     456:	51 91       	ld	r21, Z+
     458:	45 2b       	or	r20, r21
     45a:	81 f4       	brne	.+32     	; 0x47c <tinyAxon_add_pulse+0x3e>
     45c:	02 c0       	rjmp	.+4      	; 0x462 <tinyAxon_add_pulse+0x24>
     45e:	60 e0       	ldi	r22, 0x00	; 0
     460:	70 e0       	ldi	r23, 0x00	; 0
			pulse_queue[i] = new_pulse;
     462:	66 0f       	add	r22, r22
     464:	77 1f       	adc	r23, r23
     466:	fb 01       	movw	r30, r22
     468:	ea 5e       	subi	r30, 0xEA	; 234
     46a:	f7 4c       	sbci	r31, 0xC7	; 199
     46c:	80 83       	st	Z, r24
     46e:	91 83       	std	Z+1, r25	; 0x01
			pulses_in_queue++;
     470:	80 91 2a 38 	lds	r24, 0x382A	; 0x80382a <pulses_in_queue>
     474:	8f 5f       	subi	r24, 0xFF	; 255
     476:	80 93 2a 38 	sts	0x382A, r24	; 0x80382a <pulses_in_queue>
			// We return so we only ever add one
			break;
     47a:	08 95       	ret
     47c:	2f 5f       	subi	r18, 0xFF	; 255
     47e:	3f 4f       	sbci	r19, 0xFF	; 255
*/
static void tinyAxon_add_pulse(uint16_t new_pulse)
{
	// We want to check each slot in the pulse_queue, and
	// if we find an empty slot (0), we add a pulse.
	for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
     480:	2a 30       	cpi	r18, 0x0A	; 10
     482:	31 05       	cpc	r19, r1
     484:	31 f7       	brne	.-52     	; 0x452 <tinyAxon_add_pulse+0x14>
     486:	08 95       	ret

00000488 <tinyAxon_is_firing>:
// DAC has no DAC_0_get_output, so we keep track of this here.
uint8_t axonOutputValue = 0;


_Bool tinyAxon_is_firing(){
	return axonOutputValue != NO_SIGNAL_OUTPUT;
     488:	81 e0       	ldi	r24, 0x01	; 1
     48a:	90 91 2b 38 	lds	r25, 0x382B	; 0x80382b <axonOutputValue>
     48e:	91 11       	cpse	r25, r1
     490:	01 c0       	rjmp	.+2      	; 0x494 <tinyAxon_is_firing+0xc>
     492:	80 e0       	ldi	r24, 0x00	; 0
}
     494:	08 95       	ret

00000496 <find_newest_pulse>:
uint8_t find_newest_pulse() {
	uint16_t max;
	uint8_t current_index = 0;
	uint8_t return_index = 0;
	
	max = pulse_queue[current_index];
     496:	40 91 16 38 	lds	r20, 0x3816	; 0x803816 <__data_end>
     49a:	50 91 17 38 	lds	r21, 0x3817	; 0x803817 <__data_end+0x1>
     49e:	e8 e1       	ldi	r30, 0x18	; 24
     4a0:	f8 e3       	ldi	r31, 0x38	; 56
	
// This function will be used with pulse_queue to find the newest pulse
uint8_t find_newest_pulse() {
	uint16_t max;
	uint8_t current_index = 0;
	uint8_t return_index = 0;
     4a2:	80 e0       	ldi	r24, 0x00	; 0
	
	max = pulse_queue[current_index];
	
	for (current_index = 1; current_index < MAX_NUMBER_OF_PULSES; current_index++) {
     4a4:	91 e0       	ldi	r25, 0x01	; 1
		if (pulse_queue[current_index] > max) {
     4a6:	21 91       	ld	r18, Z+
     4a8:	31 91       	ld	r19, Z+
     4aa:	42 17       	cp	r20, r18
     4ac:	53 07       	cpc	r21, r19
     4ae:	10 f4       	brcc	.+4      	; 0x4b4 <find_newest_pulse+0x1e>
     4b0:	89 2f       	mov	r24, r25
			return_index = current_index;
			max = pulse_queue[current_index];
     4b2:	a9 01       	movw	r20, r18
	uint8_t current_index = 0;
	uint8_t return_index = 0;
	
	max = pulse_queue[current_index];
	
	for (current_index = 1; current_index < MAX_NUMBER_OF_PULSES; current_index++) {
     4b4:	9f 5f       	subi	r25, 0xFF	; 255
     4b6:	9a 30       	cpi	r25, 0x0A	; 10
     4b8:	b1 f7       	brne	.-20     	; 0x4a6 <find_newest_pulse+0x10>
			return_index = current_index;
			max = pulse_queue[current_index];
		}
	}
	return return_index;
}
     4ba:	08 95       	ret

000004bc <tinyAxon_stop_sending_pulse>:
	tinyLED_set_color_mode(OUT_LED, WHITE, FLASH_ONCE);
}

void tinyAxon_stop_sending_pulse()
{
	DAC_0_set_output(NO_SIGNAL_OUTPUT);
     4bc:	80 e0       	ldi	r24, 0x00	; 0
     4be:	90 e0       	ldi	r25, 0x00	; 0
     4c0:	0e 94 12 01 	call	0x224	; 0x224 <DAC_0_set_output>
	axonOutputValue=NO_SIGNAL_OUTPUT;
     4c4:	10 92 2b 38 	sts	0x382B, r1	; 0x80382b <axonOutputValue>
     4c8:	08 95       	ret

000004ca <tinyAxon_remove_pulse>:

/*
If the potential is very low, we want to try to remove a pulse.
*/
bool tinyAxon_remove_pulse(void)
{
     4ca:	cf 93       	push	r28
	// We want to return a bool indicating whether or not a pulse actually was removed.
	if(pulses_in_queue == 0){
     4cc:	c0 91 2a 38 	lds	r28, 0x382A	; 0x80382a <pulses_in_queue>
     4d0:	cc 23       	and	r28, r28
     4d2:	c9 f0       	breq	.+50     	; 0x506 <tinyAxon_remove_pulse+0x3c>
		//There was no pulse to remove.
		return false;
	}
	else{
		// If we are to remove a pulse, we want to remove the one that will fire last.
		uint8_t pulse_index = find_newest_pulse();
     4d4:	0e 94 4b 02 	call	0x496	; 0x496 <find_newest_pulse>
		uint16_t newest_pulse = pulse_queue[pulse_index];
     4d8:	90 e0       	ldi	r25, 0x00	; 0
     4da:	fc 01       	movw	r30, r24
     4dc:	ee 0f       	add	r30, r30
     4de:	ff 1f       	adc	r31, r31
     4e0:	ea 5e       	subi	r30, 0xEA	; 234
     4e2:	f7 4c       	sbci	r31, 0xC7	; 199
	
		// Now we want to check if the pulse is too far away to be affected by the low potential, or close enough that we decide to remove it.
		// (When we say that the pulse is too far away, it refers to the biological process of how the potential spreads from Dendrites to axon).
		if(newest_pulse > PULSE_NO_RETURN_TIME){
     4e4:	20 81       	ld	r18, Z
     4e6:	31 81       	ldd	r19, Z+1	; 0x01
     4e8:	2d 33       	cpi	r18, 0x3D	; 61
     4ea:	31 05       	cpc	r19, r1
     4ec:	70 f0       	brcs	.+28     	; 0x50a <tinyAxon_remove_pulse+0x40>
			// We decided to remove the pulse
			pulse_queue[pulse_index] = 0;
     4ee:	88 0f       	add	r24, r24
     4f0:	99 1f       	adc	r25, r25
     4f2:	fc 01       	movw	r30, r24
     4f4:	ea 5e       	subi	r30, 0xEA	; 234
     4f6:	f7 4c       	sbci	r31, 0xC7	; 199
     4f8:	10 82       	st	Z, r1
     4fa:	11 82       	std	Z+1, r1	; 0x01
			pulses_in_queue--;
     4fc:	c1 50       	subi	r28, 0x01	; 1
     4fe:	c0 93 2a 38 	sts	0x382A, r28	; 0x80382a <pulses_in_queue>
			return true;
     502:	81 e0       	ldi	r24, 0x01	; 1
     504:	03 c0       	rjmp	.+6      	; 0x50c <tinyAxon_remove_pulse+0x42>
bool tinyAxon_remove_pulse(void)
{
	// We want to return a bool indicating whether or not a pulse actually was removed.
	if(pulses_in_queue == 0){
		//There was no pulse to remove.
		return false;
     506:	80 e0       	ldi	r24, 0x00	; 0
     508:	01 c0       	rjmp	.+2      	; 0x50c <tinyAxon_remove_pulse+0x42>
			pulses_in_queue--;
			return true;
		}
		// Here we have found that there is a pulse queued, but it is old enough to let pass anyway, so now we need to put it back into the queue.
		else{
			return false;
     50a:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     50c:	cf 91       	pop	r28
     50e:	08 95       	ret

00000510 <tinyAxon_update_potential>:
/*
Decides whether or not the axon should fire
If the axon does fire, the potential is reduced
*/
double tinyAxon_update_potential(double potential)
{	
     510:	cf 92       	push	r12
     512:	df 92       	push	r13
     514:	ef 92       	push	r14
     516:	ff 92       	push	r15
     518:	6b 01       	movw	r12, r22
     51a:	7c 01       	movw	r14, r24
	//While the neuron has enough potential to fire, we want to fire more
	while (potential >= THRESHOLD_POTENTIAL)
     51c:	20 e0       	ldi	r18, 0x00	; 0
     51e:	30 e0       	ldi	r19, 0x00	; 0
     520:	48 ec       	ldi	r20, 0xC8	; 200
     522:	51 e4       	ldi	r21, 0x41	; 65
     524:	0e 94 88 0a 	call	0x1510	; 0x1510 <__gesf2>
     528:	88 23       	and	r24, r24
     52a:	bc f1       	brlt	.+110    	; 0x59a <tinyAxon_update_potential+0x8a>
	{
		// We have to check if there are already queued pulses, so that the frequency never exceeds FIRE_DELAY
		if(pulses_in_queue>0){
     52c:	80 91 2a 38 	lds	r24, 0x382A	; 0x80382a <pulses_in_queue>
     530:	88 23       	and	r24, r24
     532:	b1 f0       	breq	.+44     	; 0x560 <tinyAxon_update_potential+0x50>
			uint16_t newest_pulse = pulse_queue[find_newest_pulse()];
     534:	0e 94 4b 02 	call	0x496	; 0x496 <find_newest_pulse>
     538:	e8 2f       	mov	r30, r24
     53a:	f0 e0       	ldi	r31, 0x00	; 0
     53c:	ee 0f       	add	r30, r30
     53e:	ff 1f       	adc	r31, r31
     540:	ea 5e       	subi	r30, 0xEA	; 234
     542:	f7 4c       	sbci	r31, 0xC7	; 199
			
			// There is at least one pulse in the queue, and it is "so close", that we need to offset the new pulse, so that we keep at least
			// one FIRE_DELAY between each pulse
			if(newest_pulse + FIRE_DELAY > TRAVLE_DELAY){
     544:	80 81       	ld	r24, Z
     546:	91 81       	ldd	r25, Z+1	; 0x01
     548:	0a 96       	adiw	r24, 0x0a	; 10
     54a:	85 36       	cpi	r24, 0x65	; 101
     54c:	91 05       	cpc	r25, r1
     54e:	18 f0       	brcs	.+6      	; 0x556 <tinyAxon_update_potential+0x46>
				tinyAxon_add_pulse(newest_pulse + FIRE_DELAY);
     550:	0e 94 1f 02 	call	0x43e	; 0x43e <tinyAxon_add_pulse>
     554:	09 c0       	rjmp	.+18     	; 0x568 <tinyAxon_update_potential+0x58>
			}
			// There is at least one pulse in the queue, but it's "far enough away" to ignore
			else{
				tinyAxon_add_pulse(TRAVLE_DELAY);
     556:	84 e6       	ldi	r24, 0x64	; 100
     558:	90 e0       	ldi	r25, 0x00	; 0
     55a:	0e 94 1f 02 	call	0x43e	; 0x43e <tinyAxon_add_pulse>
     55e:	04 c0       	rjmp	.+8      	; 0x568 <tinyAxon_update_potential+0x58>
			}
		}
		// There are no pulses in the queue, so we add a pulse as normal
		else{
			tinyAxon_add_pulse(TRAVLE_DELAY);		
     560:	84 e6       	ldi	r24, 0x64	; 100
     562:	90 e0       	ldi	r25, 0x00	; 0
     564:	0e 94 1f 02 	call	0x43e	; 0x43e <tinyAxon_add_pulse>
		}
		
		potential += POSTFIRE_POTENTIAL_REACTION; // This is usually defined as a negative value, don't be confused by the +=
     568:	20 e0       	ldi	r18, 0x00	; 0
     56a:	30 e0       	ldi	r19, 0x00	; 0
     56c:	48 ec       	ldi	r20, 0xC8	; 200
     56e:	51 e4       	ldi	r21, 0x41	; 65
     570:	c7 01       	movw	r24, r14
     572:	b6 01       	movw	r22, r12
     574:	0e 94 43 08 	call	0x1086	; 0x1086 <__subsf3>
     578:	6b 01       	movw	r12, r22
     57a:	7c 01       	movw	r14, r24
		
		tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
     57c:	44 e0       	ldi	r20, 0x04	; 4
     57e:	63 e0       	ldi	r22, 0x03	; 3
     580:	80 e0       	ldi	r24, 0x00	; 0
     582:	0e 94 3b 05 	call	0xa76	; 0xa76 <tinyLED_set_color_mode>
If the axon does fire, the potential is reduced
*/
double tinyAxon_update_potential(double potential)
{	
	//While the neuron has enough potential to fire, we want to fire more
	while (potential >= THRESHOLD_POTENTIAL)
     586:	20 e0       	ldi	r18, 0x00	; 0
     588:	30 e0       	ldi	r19, 0x00	; 0
     58a:	48 ec       	ldi	r20, 0xC8	; 200
     58c:	51 e4       	ldi	r21, 0x41	; 65
     58e:	c7 01       	movw	r24, r14
     590:	b6 01       	movw	r22, r12
     592:	0e 94 88 0a 	call	0x1510	; 0x1510 <__gesf2>
     596:	88 23       	and	r24, r24
     598:	4c f6       	brge	.-110    	; 0x52c <tinyAxon_update_potential+0x1c>
		
		tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
	}
	
	// If the neuron has a very low potential, we want to remove a pulse from the queue (if there is one)
	if(potential < -THRESHOLD_POTENTIAL)
     59a:	20 e0       	ldi	r18, 0x00	; 0
     59c:	30 e0       	ldi	r19, 0x00	; 0
     59e:	48 ec       	ldi	r20, 0xC8	; 200
     5a0:	51 ec       	ldi	r21, 0xC1	; 193
     5a2:	c7 01       	movw	r24, r14
     5a4:	b6 01       	movw	r22, r12
     5a6:	0e 94 b0 08 	call	0x1160	; 0x1160 <__cmpsf2>
     5aa:	88 23       	and	r24, r24
     5ac:	0c f0       	brlt	.+2      	; 0x5b0 <tinyAxon_update_potential+0xa0>
     5ae:	46 c0       	rjmp	.+140    	; 0x63c <tinyAxon_update_potential+0x12c>
	{
		if(pulses_in_queue > 0) // Perhaps this should be a separate variable? For now, we will just simply use -THRESHOLD_POTENTIAL
     5b0:	80 91 2a 38 	lds	r24, 0x382A	; 0x80382a <pulses_in_queue>
     5b4:	88 23       	and	r24, r24
     5b6:	11 f1       	breq	.+68     	; 0x5fc <tinyAxon_update_potential+0xec>
		{
			// The neurons potential is low enough to attempt to remove a queued fire (Fire less)
			if(tinyAxon_remove_pulse())
     5b8:	0e 94 65 02 	call	0x4ca	; 0x4ca <tinyAxon_remove_pulse>
     5bc:	88 23       	and	r24, r24
     5be:	f1 f1       	breq	.+124    	; 0x63c <tinyAxon_update_potential+0x12c>
			{
				// The potential has evened out a bit
				potential += THRESHOLD_POTENTIAL;
     5c0:	20 e0       	ldi	r18, 0x00	; 0
     5c2:	30 e0       	ldi	r19, 0x00	; 0
     5c4:	48 ec       	ldi	r20, 0xC8	; 200
     5c6:	51 e4       	ldi	r21, 0x41	; 65
     5c8:	c7 01       	movw	r24, r14
     5ca:	b6 01       	movw	r22, r12
     5cc:	0e 94 44 08 	call	0x1088	; 0x1088 <__addsf3>
     5d0:	6b 01       	movw	r12, r22
     5d2:	7c 01       	movw	r14, r24
     5d4:	33 c0       	rjmp	.+102    	; 0x63c <tinyAxon_update_potential+0x12c>
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
	{
		for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
		{
			if(pulse_queue[i] != 0){
     5d6:	80 81       	ld	r24, Z
     5d8:	91 81       	ldd	r25, Z+1	; 0x01
     5da:	00 97       	sbiw	r24, 0x00	; 0
     5dc:	39 f0       	breq	.+14     	; 0x5ec <tinyAxon_update_potential+0xdc>
				pulse_queue[i]--;
     5de:	01 97       	sbiw	r24, 0x01	; 1
     5e0:	80 83       	st	Z, r24
     5e2:	91 83       	std	Z+1, r25	; 0x01
				
				// If the time went from 1 to 0, we fire the axon
				if(pulse_queue[i] == 0){
     5e4:	89 2b       	or	r24, r25
     5e6:	11 f4       	brne	.+4      	; 0x5ec <tinyAxon_update_potential+0xdc>
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
	pulses_in_queue--;
     5e8:	41 50       	subi	r20, 0x01	; 1
Function to set firing.
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
     5ea:	51 e0       	ldi	r21, 0x01	; 1
     5ec:	32 96       	adiw	r30, 0x02	; 2
	}
	
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
	{
		for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
     5ee:	e2 17       	cp	r30, r18
     5f0:	f3 07       	cpc	r31, r19
     5f2:	89 f7       	brne	.-30     	; 0x5d6 <tinyAxon_update_potential+0xc6>
     5f4:	50 93 2c 38 	sts	0x382C, r21	; 0x80382c <tinyAxon_should_fire>
     5f8:	40 93 2a 38 	sts	0x382A, r20	; 0x80382a <pulses_in_queue>
The function should set the DAC to fire for two
update cycles once the pulse flag is set high.
*/
static void tinyAxon_update_pulse_transmitter(void)
{
	if (tinyAxon_should_fire)
     5fc:	80 91 2c 38 	lds	r24, 0x382C	; 0x80382c <tinyAxon_should_fire>
     600:	88 23       	and	r24, r24
     602:	91 f0       	breq	.+36     	; 0x628 <tinyAxon_update_potential+0x118>
	{
		tinyAxon_should_fire = false;
     604:	10 92 2c 38 	sts	0x382C, r1	; 0x80382c <tinyAxon_should_fire>
*/
static void tinyAxon_start_sending_pulse()
{
	if (NEURONTYPE == EXCITATORY_NEURON)
	{
		DAC_0_set_output(EXCITATORY_NEURON_OUTPUT);
     608:	86 ee       	ldi	r24, 0xE6	; 230
     60a:	90 e0       	ldi	r25, 0x00	; 0
     60c:	0e 94 12 01 	call	0x224	; 0x224 <DAC_0_set_output>
		axonOutputValue=EXCITATORY_NEURON_OUTPUT;
     610:	86 ee       	ldi	r24, 0xE6	; 230
     612:	80 93 2b 38 	sts	0x382B, r24	; 0x80382b <axonOutputValue>
	{
		DAC_0_set_output(INHIBITORY_NEURON_OUTPUT);
		axonOutputValue=INHIBITORY_NEURON_OUTPUT;
	}
	
	tinyLED_set_color_mode(OUT_LED, WHITE, FLASH_ONCE);
     616:	44 e0       	ldi	r20, 0x04	; 4
     618:	65 e0       	ldi	r22, 0x05	; 5
     61a:	81 e0       	ldi	r24, 0x01	; 1
     61c:	0e 94 3b 05 	call	0xa76	; 0xa76 <tinyLED_set_color_mode>
{
	if (tinyAxon_should_fire)
	{
		tinyAxon_should_fire = false;
		tinyAxon_start_sending_pulse();
		tinyAxon_has_just_fired = true;
     620:	81 e0       	ldi	r24, 0x01	; 1
     622:	80 93 2d 38 	sts	0x382D, r24	; 0x80382d <tinyAxon_has_just_fired>
     626:	15 c0       	rjmp	.+42     	; 0x652 <tinyAxon_update_potential+0x142>
		
	}
	else if (tinyAxon_has_just_fired)
     628:	80 91 2d 38 	lds	r24, 0x382D	; 0x80382d <tinyAxon_has_just_fired>
     62c:	88 23       	and	r24, r24
     62e:	19 f0       	breq	.+6      	; 0x636 <tinyAxon_update_potential+0x126>
	{
		tinyAxon_has_just_fired = false;
     630:	10 92 2d 38 	sts	0x382D, r1	; 0x80382d <tinyAxon_has_just_fired>
     634:	0e c0       	rjmp	.+28     	; 0x652 <tinyAxon_update_potential+0x142>
	}
	else if (!tinyAxon_has_just_fired && !tinyAxon_should_fire)
	{
		tinyAxon_stop_sending_pulse();
     636:	0e 94 5e 02 	call	0x4bc	; 0x4bc <tinyAxon_stop_sending_pulse>
     63a:	0b c0       	rjmp	.+22     	; 0x652 <tinyAxon_update_potential+0x142>
			}
		}
	}
	
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
     63c:	40 91 2a 38 	lds	r20, 0x382A	; 0x80382a <pulses_in_queue>
     640:	44 23       	and	r20, r20
     642:	e1 f2       	breq	.-72     	; 0x5fc <tinyAxon_update_potential+0xec>
     644:	50 91 2c 38 	lds	r21, 0x382C	; 0x80382c <tinyAxon_should_fire>
     648:	e6 e1       	ldi	r30, 0x16	; 22
     64a:	f8 e3       	ldi	r31, 0x38	; 56
     64c:	2a e2       	ldi	r18, 0x2A	; 42
     64e:	38 e3       	ldi	r19, 0x38	; 56
     650:	c2 cf       	rjmp	.-124    	; 0x5d6 <tinyAxon_update_potential+0xc6>
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTB_get_pin_level(const uint8_t pin)
{
	return VPORTB.IN & (1 << pin);
     652:	86 b1       	in	r24, 0x06	; 6
	// We need to check if the axon is connected to a charger. We do this by checking the AXON_CHECK_PIN. If it is hight while the axon is not firing, it must be connected to a charger
	if(AXON_CHECK_PIN_get_level() && !tinyAxon_should_fire){
		//tinyCharge_set_charging_mode(true);
	}
	
	tinyDebugger_send_uint8("Axon", axonOutputValue);
     654:	60 91 2b 38 	lds	r22, 0x382B	; 0x80382b <axonOutputValue>
     658:	8f ef       	ldi	r24, 0xFF	; 255
     65a:	97 e9       	ldi	r25, 0x97	; 151
     65c:	0e 94 dd 03 	call	0x7ba	; 0x7ba <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("Pulses", pulses_in_queue);
     660:	60 91 2a 38 	lds	r22, 0x382A	; 0x80382a <pulses_in_queue>
     664:	84 e0       	ldi	r24, 0x04	; 4
     666:	98 e9       	ldi	r25, 0x98	; 152
     668:	0e 94 dd 03 	call	0x7ba	; 0x7ba <tinyDebugger_send_uint8>
	
	return potential;
}
     66c:	c7 01       	movw	r24, r14
     66e:	b6 01       	movw	r22, r12
     670:	ff 90       	pop	r15
     672:	ef 90       	pop	r14
     674:	df 90       	pop	r13
     676:	cf 90       	pop	r12
     678:	08 95       	ret

0000067a <tinyButton_update>:
/*
If the button has been let go, we change button_press to true. This only lasts one cycle, before it is set to false again.
If the button is held down for longer than PULSEMODE_BUTTON_PRESS_TIME, we toggle the pulse mode state.
*/
void tinyButton_update(void)
{
     67a:	0f 93       	push	r16
     67c:	1f 93       	push	r17
     67e:	cf 93       	push	r28
     680:	df 93       	push	r29
	button_press = false;
     682:	10 92 32 38 	sts	0x3832, r1	; 0x803832 <button_press>
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTC_get_pin_level(const uint8_t pin)
{
	return VPORTC.IN & (1 << pin);
     686:	8a b1       	in	r24, 0x0a	; 10
	_Bool button_is_pushed_down = !BUTTON_PIN_get_level(); // The digital port will be read as low if the button is pushed down.
     688:	d1 e0       	ldi	r29, 0x01	; 1
     68a:	c8 2f       	mov	r28, r24
     68c:	c4 70       	andi	r28, 0x04	; 4
     68e:	82 fd       	sbrc	r24, 2
     690:	d0 e0       	ldi	r29, 0x00	; 0

	if (button_is_pushed_down && !button_was_pushed_down)
     692:	c1 11       	cpse	r28, r1
     694:	36 c0       	rjmp	.+108    	; 0x702 <tinyButton_update+0x88>
     696:	80 91 33 38 	lds	r24, 0x3833	; 0x803833 <button_was_pushed_down>
     69a:	81 11       	cpse	r24, r1
     69c:	0e c0       	rjmp	.+28     	; 0x6ba <tinyButton_update+0x40>
	{
		tinyButton_start_time = tinyTime_now();
     69e:	0e 94 3a 08 	call	0x1074	; 0x1074 <tinyTime_now>
     6a2:	60 93 2e 38 	sts	0x382E, r22	; 0x80382e <tinyButton_start_time>
     6a6:	70 93 2f 38 	sts	0x382F, r23	; 0x80382f <tinyButton_start_time+0x1>
     6aa:	80 93 30 38 	sts	0x3830, r24	; 0x803830 <tinyButton_start_time+0x2>
     6ae:	90 93 31 38 	sts	0x3831, r25	; 0x803831 <tinyButton_start_time+0x3>
	}
	if (button_is_pushed_down && button_was_pushed_down)
     6b2:	80 91 33 38 	lds	r24, 0x3833	; 0x803833 <button_was_pushed_down>
     6b6:	88 23       	and	r24, r24
     6b8:	69 f1       	breq	.+90     	; 0x714 <tinyButton_update+0x9a>
	{
		if ((tinyTime_now() - tinyButton_start_time) > PULSEMODE_BUTTON_PRESS_TIME)
     6ba:	0e 94 3a 08 	call	0x1074	; 0x1074 <tinyTime_now>
     6be:	00 91 2e 38 	lds	r16, 0x382E	; 0x80382e <tinyButton_start_time>
     6c2:	10 91 2f 38 	lds	r17, 0x382F	; 0x80382f <tinyButton_start_time+0x1>
     6c6:	20 91 30 38 	lds	r18, 0x3830	; 0x803830 <tinyButton_start_time+0x2>
     6ca:	30 91 31 38 	lds	r19, 0x3831	; 0x803831 <tinyButton_start_time+0x3>
     6ce:	60 1b       	sub	r22, r16
     6d0:	71 0b       	sbc	r23, r17
     6d2:	82 0b       	sbc	r24, r18
     6d4:	93 0b       	sbc	r25, r19
     6d6:	0e 94 90 09 	call	0x1320	; 0x1320 <__floatunsisf>
     6da:	20 e0       	ldi	r18, 0x00	; 0
     6dc:	30 e0       	ldi	r19, 0x00	; 0
     6de:	4a e7       	ldi	r20, 0x7A	; 122
     6e0:	54 e4       	ldi	r21, 0x44	; 68
     6e2:	0e 94 88 0a 	call	0x1510	; 0x1510 <__gesf2>
     6e6:	18 16       	cp	r1, r24
     6e8:	64 f4       	brge	.+24     	; 0x702 <tinyButton_update+0x88>
		{
			tinyPulse_toggle_pulse_mode();
     6ea:	0e 94 e7 07 	call	0xfce	; 0xfce <tinyPulse_toggle_pulse_mode>
			tinyButton_start_time = tinyTime_now();
     6ee:	0e 94 3a 08 	call	0x1074	; 0x1074 <tinyTime_now>
     6f2:	60 93 2e 38 	sts	0x382E, r22	; 0x80382e <tinyButton_start_time>
     6f6:	70 93 2f 38 	sts	0x382F, r23	; 0x80382f <tinyButton_start_time+0x1>
     6fa:	80 93 30 38 	sts	0x3830, r24	; 0x803830 <tinyButton_start_time+0x2>
     6fe:	90 93 31 38 	sts	0x3831, r25	; 0x803831 <tinyButton_start_time+0x3>
		}
	}
	if (!button_is_pushed_down && button_was_pushed_down)
     702:	cc 23       	and	r28, r28
     704:	39 f0       	breq	.+14     	; 0x714 <tinyButton_update+0x9a>
     706:	80 91 33 38 	lds	r24, 0x3833	; 0x803833 <button_was_pushed_down>
     70a:	88 23       	and	r24, r24
     70c:	19 f0       	breq	.+6      	; 0x714 <tinyButton_update+0x9a>
	{
		button_press = true;
     70e:	81 e0       	ldi	r24, 0x01	; 1
     710:	80 93 32 38 	sts	0x3832, r24	; 0x803832 <button_press>
	}
	button_was_pushed_down = button_is_pushed_down;
     714:	d0 93 33 38 	sts	0x3833, r29	; 0x803833 <button_was_pushed_down>
}
     718:	df 91       	pop	r29
     71a:	cf 91       	pop	r28
     71c:	1f 91       	pop	r17
     71e:	0f 91       	pop	r16
     720:	08 95       	ret

00000722 <tinyButton_update_potential>:

double tinyButton_update_potential(double potential){
	if(button_press){
     722:	20 91 32 38 	lds	r18, 0x3832	; 0x803832 <button_press>
     726:	22 23       	and	r18, r18
     728:	31 f0       	breq	.+12     	; 0x736 <tinyButton_update_potential+0x14>
		potential += BUTTON_PRESS_REACTION;
     72a:	20 e0       	ldi	r18, 0x00	; 0
     72c:	30 e0       	ldi	r19, 0x00	; 0
     72e:	40 ed       	ldi	r20, 0xD0	; 208
     730:	51 e4       	ldi	r21, 0x41	; 65
     732:	0e 94 44 08 	call	0x1088	; 0x1088 <__addsf3>
	}
	return potential;
}
     736:	08 95       	ret

00000738 <tinyCharge_is_connected_to_charger>:

_Bool connected_to_charger;

_Bool tinyCharge_is_connected_to_charger(){
	return connected_to_charger;
}
     738:	80 91 57 38 	lds	r24, 0x3857	; 0x803857 <connected_to_charger>
     73c:	08 95       	ret

0000073e <tinyCharge_is_fully_charged>:
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTB_get_pin_level(const uint8_t pin)
{
	return VPORTB.IN & (1 << pin);
     73e:	86 b1       	in	r24, 0x06	; 6

_Bool tinyCharge_is_fully_charged(){
	return CHARGING_STATUS_PIN_get_level();
}
     740:	86 fb       	bst	r24, 6
     742:	88 27       	eor	r24, r24
     744:	80 f9       	bld	r24, 0
     746:	08 95       	ret

00000748 <tinyCharge_DAC_dissable>:
void tinyCharge_DAC_dissable(){
	
	// We need some way to disable the DAC to prevent huge current draw when charging (64mA). When there is no code uploaded to the attiny, there is no problem.
	// We're going to try to enable the pin as a dendrite, since they seem to be doing fine. Completely uninitializing the pin probably caused a microchip to be fried.
	
	DAC_0_uninit();
     748:	0e 94 01 01 	call	0x202	; 0x202 <DAC_0_uninit>
	DAC_0_disable();
     74c:	0e 94 0c 01 	call	0x218	; 0x218 <DAC_0_disable>
     750:	08 95       	ret

00000752 <tinyCharge_DAC_enable>:
void tinyCharge_DAC_enable(){
	
	// We need some way to disable the DAC to prevent huge current draw when charging (64mA). When there is no code uploaded to the attiny, there is no problem.
	// We're going to try to enable the pin as a dendrite, since they seem to be doing fine. Completely uninitializing the pin probably caused a microchip to be fried.
	
	DAC_0_init();
     752:	0e 94 fc 00 	call	0x1f8	; 0x1f8 <DAC_0_init>
	DAC_0_enable();
     756:	0e 94 06 01 	call	0x20c	; 0x20c <DAC_0_enable>
     75a:	08 95       	ret

0000075c <tinyCharge_switch_mode>:
}


void tinyCharge_switch_mode(){
	
	if(connected_to_charger){
     75c:	80 91 57 38 	lds	r24, 0x3857	; 0x803857 <connected_to_charger>
     760:	88 23       	and	r24, r24
     762:	71 f0       	breq	.+28     	; 0x780 <tinyCharge_switch_mode+0x24>
		// Switch from main to charging mode
		
		// Set LED
		tinyLED_set_color_mode(OUT_LED, CHARGING_COLOR, SWING);
     764:	42 e0       	ldi	r20, 0x02	; 2
     766:	61 e0       	ldi	r22, 0x01	; 1
     768:	81 e0       	ldi	r24, 0x01	; 1
     76a:	0e 94 3b 05 	call	0xa76	; 0xa76 <tinyLED_set_color_mode>
		tinyLED_set_color(INN_LED, OFF);
     76e:	60 e0       	ldi	r22, 0x00	; 0
     770:	80 e0       	ldi	r24, 0x00	; 0
     772:	0e 94 2a 05 	call	0xa54	; 0xa54 <tinyLED_set_color>


		// Stop axon from firing
		// (There is a small chance that the neuron is put into charging mode as it is firing. The axon is then never told to stop firing)
		tinyAxon_stop_sending_pulse();
     776:	0e 94 5e 02 	call	0x4bc	; 0x4bc <tinyAxon_stop_sending_pulse>

		// disable DAC
		tinyCharge_DAC_dissable();
     77a:	0e 94 a4 03 	call	0x748	; 0x748 <tinyCharge_DAC_dissable>
     77e:	08 95       	ret
	}
	else{
		// Switch from charge to main mode
		
		// Set LED
		tinyLED_set_color(OUT_LED, OFF);
     780:	60 e0       	ldi	r22, 0x00	; 0
     782:	81 e0       	ldi	r24, 0x01	; 1
     784:	0e 94 2a 05 	call	0xa54	; 0xa54 <tinyLED_set_color>
		tinyLED_set_color(INN_LED, OFF);
     788:	60 e0       	ldi	r22, 0x00	; 0
     78a:	80 e0       	ldi	r24, 0x00	; 0
     78c:	0e 94 2a 05 	call	0xa54	; 0xa54 <tinyLED_set_color>
		
		// enable DAC
		tinyCharge_DAC_enable();
     790:	0e 94 a9 03 	call	0x752	; 0x752 <tinyCharge_DAC_enable>
     794:	08 95       	ret

00000796 <tinyCharge_set_charging_mode>:
	}
}

void tinyCharge_set_charging_mode(_Bool charging_status){
	if(charging_status != connected_to_charger){
     796:	90 91 57 38 	lds	r25, 0x3857	; 0x803857 <connected_to_charger>
     79a:	98 17       	cp	r25, r24
     79c:	21 f0       	breq	.+8      	; 0x7a6 <tinyCharge_set_charging_mode+0x10>
		connected_to_charger = charging_status;
     79e:	80 93 57 38 	sts	0x3857, r24	; 0x803857 <connected_to_charger>
		tinyCharge_switch_mode();
     7a2:	0e 94 ae 03 	call	0x75c	; 0x75c <tinyCharge_switch_mode>
     7a6:	08 95       	ret

000007a8 <tinyCharge_set_transistors>:
	}
}


void tinyCharge_set_transistors(){
	if(connected_to_charger){
     7a8:	80 91 57 38 	lds	r24, 0x3857	; 0x803857 <connected_to_charger>
     7ac:	88 23       	and	r24, r24
     7ae:	11 f0       	breq	.+4      	; 0x7b4 <tinyCharge_set_transistors+0xc>
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
	} else {
		VPORTC.OUT &= ~(1 << pin);
     7b0:	4d 98       	cbi	0x09, 5	; 9
     7b2:	08 95       	ret
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     7b4:	4d 9a       	sbi	0x09, 5	; 9
     7b6:	08 95       	ret

000007b8 <tinyDebugger_send_uint32>:
		char number[20]; // Arbitrary max
		dtostrf(value,1,NUMBER_OF_DECIMALS, number);
		printf("%s:%5s\t", name, number);
	}
}
void tinyDebugger_send_string(const char* name, char * value){
     7b8:	08 95       	ret

000007ba <tinyDebugger_send_uint8>:
     7ba:	08 95       	ret

000007bc <tinyDebugger_send_double>:
     7bc:	08 95       	ret

000007be <tinyDebugger_end_line>:
	if(DEBUGGING){
		printf("%s:%s\t", name, value);
	}
}
void tinyDebugger_end_line(){
     7be:	08 95       	ret

000007c0 <tinyDendrite_update_signals>:
/*
This function converts the 8 bit value from the ADC into one of the signal types defined in DendriteSignal
We also update the charging state
*/
void tinyDendrite_update_signals(void)
{
     7c0:	af 92       	push	r10
     7c2:	bf 92       	push	r11
     7c4:	cf 92       	push	r12
     7c6:	df 92       	push	r13
     7c8:	ef 92       	push	r14
     7ca:	ff 92       	push	r15
     7cc:	0f 93       	push	r16
     7ce:	1f 93       	push	r17
     7d0:	cf 93       	push	r28
     7d2:	df 93       	push	r29
     7d4:	ce e0       	ldi	r28, 0x0E	; 14
     7d6:	d8 e3       	ldi	r29, 0x38	; 56
     7d8:	0e e3       	ldi	r16, 0x3E	; 62
     7da:	18 e3       	ldi	r17, 0x38	; 56
     7dc:	0f 2e       	mov	r0, r31
     7de:	f3 e1       	ldi	r31, 0x13	; 19
     7e0:	cf 2e       	mov	r12, r31
     7e2:	f8 e3       	ldi	r31, 0x38	; 56
     7e4:	df 2e       	mov	r13, r31
     7e6:	f0 2d       	mov	r31, r0
     7e8:	78 01       	movw	r14, r16
*/
static void tinyDendrite_read_signals(void)
{
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_values[i] = ADC_0_get_conversion(Dendrite_ports[i]);
     7ea:	89 91       	ld	r24, Y+
     7ec:	0e 94 c6 00 	call	0x18c	; 0x18c <ADC_0_get_conversion>
     7f0:	d7 01       	movw	r26, r14
     7f2:	8d 93       	st	X+, r24
     7f4:	7d 01       	movw	r14, r26
/*
This function reads the voltage at the Dendrite inputs with the ADC
*/
static void tinyDendrite_read_signals(void)
{
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
     7f6:	cc 15       	cp	r28, r12
     7f8:	dd 05       	cpc	r29, r13
     7fa:	b9 f7       	brne	.-18     	; 0x7ea <tinyDendrite_update_signals+0x2a>
	{
		tinyDendrite_values[i] = ADC_0_get_conversion(Dendrite_ports[i]);
	}
	tinyDebugger_send_uint8("D1", tinyDendrite_values[0]);
     7fc:	ce e3       	ldi	r28, 0x3E	; 62
     7fe:	d8 e3       	ldi	r29, 0x38	; 56
     800:	68 81       	ld	r22, Y
     802:	8b e0       	ldi	r24, 0x0B	; 11
     804:	98 e9       	ldi	r25, 0x98	; 152
     806:	0e 94 dd 03 	call	0x7ba	; 0x7ba <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D2", tinyDendrite_values[1]);
     80a:	69 81       	ldd	r22, Y+1	; 0x01
     80c:	8e e0       	ldi	r24, 0x0E	; 14
     80e:	98 e9       	ldi	r25, 0x98	; 152
     810:	0e 94 dd 03 	call	0x7ba	; 0x7ba <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D3", tinyDendrite_values[2]);
     814:	6a 81       	ldd	r22, Y+2	; 0x02
     816:	81 e1       	ldi	r24, 0x11	; 17
     818:	98 e9       	ldi	r25, 0x98	; 152
     81a:	0e 94 dd 03 	call	0x7ba	; 0x7ba <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D4", tinyDendrite_values[3]);
     81e:	6b 81       	ldd	r22, Y+3	; 0x03
     820:	84 e1       	ldi	r24, 0x14	; 20
     822:	98 e9       	ldi	r25, 0x98	; 152
     824:	0e 94 dd 03 	call	0x7ba	; 0x7ba <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D5", tinyDendrite_values[4]);
     828:	6c 81       	ldd	r22, Y+4	; 0x04
     82a:	87 e1       	ldi	r24, 0x17	; 23
     82c:	98 e9       	ldi	r25, 0x98	; 152
     82e:	0e 94 dd 03 	call	0x7ba	; 0x7ba <tinyDebugger_send_uint8>
     832:	e9 e3       	ldi	r30, 0x39	; 57
     834:	f8 e3       	ldi	r31, 0x38	; 56
     836:	c4 e3       	ldi	r28, 0x34	; 52
     838:	d8 e3       	ldi	r29, 0x38	; 56
     83a:	4e e3       	ldi	r20, 0x3E	; 62
     83c:	58 e3       	ldi	r21, 0x38	; 56
{
	
	//Read the analog voltage values on each of the Dendrites
	tinyDendrite_read_signals();
	
	_Bool charging = false;
     83e:	80 e0       	ldi	r24, 0x00	; 0
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     840:	31 e0       	ldi	r19, 0x01	; 1
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
		}
		else if (tinyDendrite_values[i] > HIGH_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
     842:	0f 2e       	mov	r0, r31
     844:	f3 e0       	ldi	r31, 0x03	; 3
     846:	cf 2e       	mov	r12, r31
     848:	f0 2d       	mov	r31, r0
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     84a:	68 94       	set
     84c:	dd 24       	eor	r13, r13
     84e:	d1 f8       	bld	r13, 1
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     850:	68 94       	set
     852:	ee 24       	eor	r14, r14
     854:	e2 f8       	bld	r14, 2
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     856:	0f 2e       	mov	r0, r31
     858:	f6 e0       	ldi	r31, 0x06	; 6
     85a:	ff 2e       	mov	r15, r31
     85c:	f0 2d       	mov	r31, r0
			tinyDendrite_current_signals[i] = CHARGING;
			charging = true;
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     85e:	75 e0       	ldi	r23, 0x05	; 5
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = CHARGING;
     860:	67 e0       	ldi	r22, 0x07	; 7
     862:	5f 01       	movw	r10, r30
	
	_Bool charging = false;
	
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
     864:	90 81       	ld	r25, Z
     866:	99 93       	st	Y+, r25
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
     868:	d8 01       	movw	r26, r16
     86a:	2d 91       	ld	r18, X+
     86c:	8d 01       	movw	r16, r26
     86e:	29 3e       	cpi	r18, 0xE9	; 233
     870:	18 f0       	brcs	.+6      	; 0x878 <tinyDendrite_update_signals+0xb8>
		{
			tinyDendrite_current_signals[i] = CHARGING;
     872:	60 83       	st	Z, r22
			charging = true;
     874:	83 2f       	mov	r24, r19
     876:	19 c0       	rjmp	.+50     	; 0x8aa <tinyDendrite_update_signals+0xea>
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
     878:	28 3c       	cpi	r18, 0xC8	; 200
     87a:	10 f0       	brcs	.+4      	; 0x880 <tinyDendrite_update_signals+0xc0>
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     87c:	70 83       	st	Z, r23
     87e:	15 c0       	rjmp	.+42     	; 0x8aa <tinyDendrite_update_signals+0xea>
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
     880:	27 3a       	cpi	r18, 0xA7	; 167
     882:	10 f0       	brcs	.+4      	; 0x888 <tinyDendrite_update_signals+0xc8>
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     884:	f0 82       	st	Z, r15
     886:	11 c0       	rjmp	.+34     	; 0x8aa <tinyDendrite_update_signals+0xea>
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
     888:	25 38       	cpi	r18, 0x85	; 133
     88a:	10 f0       	brcs	.+4      	; 0x890 <tinyDendrite_update_signals+0xd0>
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     88c:	e0 82       	st	Z, r14
     88e:	0d c0       	rjmp	.+26     	; 0x8aa <tinyDendrite_update_signals+0xea>
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
     890:	24 36       	cpi	r18, 0x64	; 100
     892:	10 f0       	brcs	.+4      	; 0x898 <tinyDendrite_update_signals+0xd8>
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     894:	d0 82       	st	Z, r13
     896:	09 c0       	rjmp	.+18     	; 0x8aa <tinyDendrite_update_signals+0xea>
		}
		else if (tinyDendrite_values[i] > HIGH_INHIB_THRESHOLD)
     898:	23 34       	cpi	r18, 0x43	; 67
     89a:	10 f0       	brcs	.+4      	; 0x8a0 <tinyDendrite_update_signals+0xe0>
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
     89c:	c0 82       	st	Z, r12
     89e:	05 c0       	rjmp	.+10     	; 0x8aa <tinyDendrite_update_signals+0xea>
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
     8a0:	22 32       	cpi	r18, 0x22	; 34
     8a2:	10 f0       	brcs	.+4      	; 0x8a8 <tinyDendrite_update_signals+0xe8>
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     8a4:	30 83       	st	Z, r19
     8a6:	01 c0       	rjmp	.+2      	; 0x8aa <tinyDendrite_update_signals+0xea>
		}
		else
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     8a8:	10 82       	st	Z, r1
		}
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
     8aa:	d5 01       	movw	r26, r10
     8ac:	2c 91       	ld	r18, X
     8ae:	92 13       	cpse	r25, r18
     8b0:	01 c0       	rjmp	.+2      	; 0x8b4 <tinyDendrite_update_signals+0xf4>
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     8b2:	1c 92       	st	X, r1
     8b4:	31 96       	adiw	r30, 0x01	; 1
	//Read the analog voltage values on each of the Dendrites
	tinyDendrite_read_signals();
	
	_Bool charging = false;
	
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
     8b6:	e4 17       	cp	r30, r20
     8b8:	f5 07       	cpc	r31, r21
     8ba:	99 f6       	brne	.-90     	; 0x862 <tinyDendrite_update_signals+0xa2>
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
		}
	}
	tinyCharge_set_charging_mode(charging);
     8bc:	0e 94 cb 03 	call	0x796	; 0x796 <tinyCharge_set_charging_mode>
}
     8c0:	df 91       	pop	r29
     8c2:	cf 91       	pop	r28
     8c4:	1f 91       	pop	r17
     8c6:	0f 91       	pop	r16
     8c8:	ff 90       	pop	r15
     8ca:	ef 90       	pop	r14
     8cc:	df 90       	pop	r13
     8ce:	cf 90       	pop	r12
     8d0:	bf 90       	pop	r11
     8d2:	af 90       	pop	r10
     8d4:	08 95       	ret

000008d6 <tinyDendrite_get_potential>:
/*
This is the master function of the module that is callable from
outside. It uses the previously declared functions to return the potential.
*/
int16_t tinyDendrite_get_potential()
{
     8d6:	ef 92       	push	r14
     8d8:	ff 92       	push	r15
     8da:	0f 93       	push	r16
     8dc:	1f 93       	push	r17
     8de:	cf 93       	push	r28
     8e0:	df 93       	push	r29
	if(tinyAxon_is_firing() && IGNORE_INPUT_WHILE_FIRING){
     8e2:	0e 94 44 02 	call	0x488	; 0x488 <tinyAxon_is_firing>
     8e6:	81 11       	cpse	r24, r1
     8e8:	50 c0       	rjmp	.+160    	; 0x98a <tinyDendrite_get_potential+0xb4>
		
		return NO_SIGNAL_REACTION;
	}
	
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
     8ea:	0e 94 e0 03 	call	0x7c0	; 0x7c0 <tinyDendrite_update_signals>
     8ee:	c9 e3       	ldi	r28, 0x39	; 57
     8f0:	d8 e3       	ldi	r29, 0x38	; 56
     8f2:	0f 2e       	mov	r0, r31
     8f4:	fe e3       	ldi	r31, 0x3E	; 62
     8f6:	ef 2e       	mov	r14, r31
     8f8:	f8 e3       	ldi	r31, 0x38	; 56
     8fa:	ff 2e       	mov	r15, r31
     8fc:	f0 2d       	mov	r31, r0
	
	int16_t return_potential_val = 0;
     8fe:	00 e0       	ldi	r16, 0x00	; 0
     900:	10 e0       	ldi	r17, 0x00	; 0
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		switch(tinyDendrite_current_signals[i])
     902:	89 91       	ld	r24, Y+
     904:	83 30       	cpi	r24, 0x03	; 3
     906:	19 f1       	breq	.+70     	; 0x94e <tinyDendrite_get_potential+0x78>
     908:	28 f4       	brcc	.+10     	; 0x914 <tinyDendrite_get_potential+0x3e>
     90a:	81 30       	cpi	r24, 0x01	; 1
     90c:	81 f1       	breq	.+96     	; 0x96e <tinyDendrite_get_potential+0x98>
     90e:	82 30       	cpi	r24, 0x02	; 2
     910:	31 f1       	breq	.+76     	; 0x95e <tinyDendrite_get_potential+0x88>
     912:	34 c0       	rjmp	.+104    	; 0x97c <tinyDendrite_get_potential+0xa6>
     914:	85 30       	cpi	r24, 0x05	; 5
     916:	59 f0       	breq	.+22     	; 0x92e <tinyDendrite_get_potential+0x58>
     918:	90 f0       	brcs	.+36     	; 0x93e <tinyDendrite_get_potential+0x68>
     91a:	86 30       	cpi	r24, 0x06	; 6
     91c:	79 f5       	brne	.+94     	; 0x97c <tinyDendrite_get_potential+0xa6>
		{
			case NO_SIGNAL:
				return_potential_val += NO_SIGNAL_REACTION;
				break;
			case HIGH_EXCITE:
				return_potential_val += HIGH_EXCITE_REACTION;
     91e:	0c 5c       	subi	r16, 0xCC	; 204
     920:	1f 4f       	sbci	r17, 0xFF	; 255
				tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
     922:	44 e0       	ldi	r20, 0x04	; 4
     924:	63 e0       	ldi	r22, 0x03	; 3
     926:	80 e0       	ldi	r24, 0x00	; 0
     928:	0e 94 3b 05 	call	0xa76	; 0xa76 <tinyLED_set_color_mode>
				break;
     92c:	27 c0       	rjmp	.+78     	; 0x97c <tinyDendrite_get_potential+0xa6>
			case NORMAL_EXCITE:
				return_potential_val += NORMAL_EXCITE_REACTION;
     92e:	07 5e       	subi	r16, 0xE7	; 231
     930:	1f 4f       	sbci	r17, 0xFF	; 255
				tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
     932:	44 e0       	ldi	r20, 0x04	; 4
     934:	63 e0       	ldi	r22, 0x03	; 3
     936:	80 e0       	ldi	r24, 0x00	; 0
     938:	0e 94 3b 05 	call	0xa76	; 0xa76 <tinyLED_set_color_mode>
				break;
     93c:	1f c0       	rjmp	.+62     	; 0x97c <tinyDendrite_get_potential+0xa6>
			case LOW_EXCITE:
				return_potential_val += LOW_EXCITE_REACTION;
     93e:	0c 5e       	subi	r16, 0xEC	; 236
     940:	1f 4f       	sbci	r17, 0xFF	; 255
				tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
     942:	44 e0       	ldi	r20, 0x04	; 4
     944:	63 e0       	ldi	r22, 0x03	; 3
     946:	80 e0       	ldi	r24, 0x00	; 0
     948:	0e 94 3b 05 	call	0xa76	; 0xa76 <tinyLED_set_color_mode>
				break;
     94c:	17 c0       	rjmp	.+46     	; 0x97c <tinyDendrite_get_potential+0xa6>
			case HIGH_INHIB:
				return_potential_val += HIGH_INHIB_REACTION;
     94e:	02 53       	subi	r16, 0x32	; 50
     950:	11 09       	sbc	r17, r1
				tinyLED_set_color_mode(INN_LED, RED, FLASH_ONCE);
     952:	44 e0       	ldi	r20, 0x04	; 4
     954:	61 e0       	ldi	r22, 0x01	; 1
     956:	80 e0       	ldi	r24, 0x00	; 0
     958:	0e 94 3b 05 	call	0xa76	; 0xa76 <tinyLED_set_color_mode>
				break;
     95c:	0f c0       	rjmp	.+30     	; 0x97c <tinyDendrite_get_potential+0xa6>
			case NORMAL_INHIB:
				return_potential_val += NORMAL_INHIB_REACTION;
     95e:	09 51       	subi	r16, 0x19	; 25
     960:	11 09       	sbc	r17, r1
				tinyLED_set_color_mode(INN_LED, RED, FLASH_ONCE);
     962:	44 e0       	ldi	r20, 0x04	; 4
     964:	61 e0       	ldi	r22, 0x01	; 1
     966:	80 e0       	ldi	r24, 0x00	; 0
     968:	0e 94 3b 05 	call	0xa76	; 0xa76 <tinyLED_set_color_mode>
				break;
     96c:	07 c0       	rjmp	.+14     	; 0x97c <tinyDendrite_get_potential+0xa6>
			case LOW_INHIB:
				return_potential_val += LOW_INHIB_REACTION;
     96e:	04 51       	subi	r16, 0x14	; 20
     970:	11 09       	sbc	r17, r1
				tinyLED_set_color_mode(INN_LED, RED, FLASH_ONCE);
     972:	44 e0       	ldi	r20, 0x04	; 4
     974:	61 e0       	ldi	r22, 0x01	; 1
     976:	80 e0       	ldi	r24, 0x00	; 0
     978:	0e 94 3b 05 	call	0xa76	; 0xa76 <tinyLED_set_color_mode>
	
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
	
	int16_t return_potential_val = 0;
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
     97c:	ce 15       	cp	r28, r14
     97e:	df 05       	cpc	r29, r15
     980:	09 f0       	breq	.+2      	; 0x984 <tinyDendrite_get_potential+0xae>
     982:	bf cf       	rjmp	.-130    	; 0x902 <tinyDendrite_get_potential+0x2c>
     984:	80 2f       	mov	r24, r16
     986:	91 2f       	mov	r25, r17
     988:	02 c0       	rjmp	.+4      	; 0x98e <tinyDendrite_get_potential+0xb8>
*/
int16_t tinyDendrite_get_potential()
{
	if(tinyAxon_is_firing() && IGNORE_INPUT_WHILE_FIRING){
		
		return NO_SIGNAL_REACTION;
     98a:	80 e0       	ldi	r24, 0x00	; 0
     98c:	90 e0       	ldi	r25, 0x00	; 0
		}
	}
	
	return return_potential_val;
	
}
     98e:	df 91       	pop	r29
     990:	cf 91       	pop	r28
     992:	1f 91       	pop	r17
     994:	0f 91       	pop	r16
     996:	ff 90       	pop	r15
     998:	ef 90       	pop	r14
     99a:	08 95       	ret

0000099c <tinyDendrite_update_potential>:

double tinyDendrite_update_potential(double potential){
     99c:	cf 92       	push	r12
     99e:	df 92       	push	r13
     9a0:	ef 92       	push	r14
     9a2:	ff 92       	push	r15
     9a4:	6b 01       	movw	r12, r22
     9a6:	7c 01       	movw	r14, r24
	
	int16_t potential_change = tinyDendrite_get_potential();
     9a8:	0e 94 6b 04 	call	0x8d6	; 0x8d6 <tinyDendrite_get_potential>
	potential += potential_change;
	return potential;
     9ac:	bc 01       	movw	r22, r24
     9ae:	99 0f       	add	r25, r25
     9b0:	88 0b       	sbc	r24, r24
     9b2:	99 0b       	sbc	r25, r25
     9b4:	0e 94 92 09 	call	0x1324	; 0x1324 <__floatsisf>
     9b8:	a7 01       	movw	r20, r14
     9ba:	96 01       	movw	r18, r12
     9bc:	0e 94 44 08 	call	0x1088	; 0x1088 <__addsf3>
     9c0:	ff 90       	pop	r15
     9c2:	ef 90       	pop	r14
     9c4:	df 90       	pop	r13
     9c6:	cf 90       	pop	r12
     9c8:	08 95       	ret

000009ca <__vector_6>:
This function is called every time the RTC (Real Time Clock) counter overflows.
With the current settings, it will be called every ms.
The RTC clock runs at 1kHz, and the number of cycles before overflow is set with RTC.PER = someHexValue (e.g. 0x20) in src/rtc.c
*/
ISR(RTC_CNT_vect)
{
     9ca:	1f 92       	push	r1
     9cc:	0f 92       	push	r0
     9ce:	0f b6       	in	r0, 0x3f	; 63
     9d0:	0f 92       	push	r0
     9d2:	11 24       	eor	r1, r1
     9d4:	2f 93       	push	r18
     9d6:	3f 93       	push	r19
     9d8:	4f 93       	push	r20
     9da:	5f 93       	push	r21
     9dc:	6f 93       	push	r22
     9de:	7f 93       	push	r23
     9e0:	8f 93       	push	r24
     9e2:	9f 93       	push	r25
     9e4:	af 93       	push	r26
     9e6:	bf 93       	push	r27
     9e8:	cf 93       	push	r28
     9ea:	ef 93       	push	r30
     9ec:	ff 93       	push	r31
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     9ee:	c1 e0       	ldi	r28, 0x01	; 1
     9f0:	c0 93 43 38 	sts	0x3843, r28	; 0x803843 <tinyISR_interrupt_flag>
{
	// Set flag to let main loop run a new cycle
	tinyISR_setflag(true);
	
	// Timer counter incrementation
	tinyTime_counter_increment();
     9f4:	0e 94 26 08 	call	0x104c	; 0x104c <tinyTime_counter_increment>

	/* Overflow interrupt flag has to be cleared manually */
	RTC.INTFLAGS = RTC_OVF_bm;
     9f8:	c0 93 43 01 	sts	0x0143, r28	; 0x800143 <__TEXT_REGION_LENGTH__+0x700143>
}
     9fc:	ff 91       	pop	r31
     9fe:	ef 91       	pop	r30
     a00:	cf 91       	pop	r28
     a02:	bf 91       	pop	r27
     a04:	af 91       	pop	r26
     a06:	9f 91       	pop	r25
     a08:	8f 91       	pop	r24
     a0a:	7f 91       	pop	r23
     a0c:	6f 91       	pop	r22
     a0e:	5f 91       	pop	r21
     a10:	4f 91       	pop	r20
     a12:	3f 91       	pop	r19
     a14:	2f 91       	pop	r18
     a16:	0f 90       	pop	r0
     a18:	0f be       	out	0x3f, r0	; 63
     a1a:	0f 90       	pop	r0
     a1c:	1f 90       	pop	r1
     a1e:	18 95       	reti

00000a20 <tinyISR_setflag>:
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     a20:	80 93 43 38 	sts	0x3843, r24	; 0x803843 <tinyISR_interrupt_flag>
     a24:	08 95       	ret

00000a26 <tinyISR_getflag>:
}

_Bool tinyISR_getflag(void)
{
	return tinyISR_interrupt_flag;
}
     a26:	80 91 43 38 	lds	r24, 0x3843	; 0x803843 <tinyISR_interrupt_flag>
     a2a:	08 95       	ret

00000a2c <tinyLED_SPIWriteByte>:
Function used to send a byte over SPI, which in turn gets
translated to the bit-sequence required by the LEDs over the CCL.
*/
static void tinyLED_SPIWriteByte(uint8_t byte)
{
	SPI0.INTFLAGS = SPI0_INTFLAGS; // clear the write collision flag to allow writing
     a2c:	90 91 23 08 	lds	r25, 0x0823	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
     a30:	90 93 23 08 	sts	0x0823, r25	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
	TCA0.SINGLE.CNT = 0; // reset TCA counter register to ensure the first rising edge of the PWM is predictable
     a34:	e0 e0       	ldi	r30, 0x00	; 0
     a36:	fa e0       	ldi	r31, 0x0A	; 10
     a38:	10 a2       	std	Z+32, r1	; 0x20
     a3a:	11 a2       	std	Z+33, r1	; 0x21
	
	// start TCA
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 1 << TCA_SPLIT_ENABLE_bp;
     a3c:	91 e0       	ldi	r25, 0x01	; 1
     a3e:	90 83       	st	Z, r25
	SPI0_DATA = byte;
     a40:	80 93 24 08 	sts	0x0824, r24	; 0x800824 <__TEXT_REGION_LENGTH__+0x700824>

	while((SPI0.INTFLAGS & SPI_RXCIE_bm) == 0){} // wait for transfer to complete
     a44:	e0 e2       	ldi	r30, 0x20	; 32
     a46:	f8 e0       	ldi	r31, 0x08	; 8
     a48:	83 81       	ldd	r24, Z+3	; 0x03
     a4a:	88 23       	and	r24, r24
     a4c:	ec f7       	brge	.-6      	; 0xa48 <tinyLED_SPIWriteByte+0x1c>
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 0 << TCA_SPLIT_ENABLE_bp; //Stop TCA
     a4e:	10 92 00 0a 	sts	0x0A00, r1	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
     a52:	08 95       	ret

00000a54 <tinyLED_set_color>:
changes the values in the variables stored in the LED-array.
*/
void tinyLED_set_color_mode(uint8_t LED_id, enum Colors color, enum ColorModes mode)
{
	struct ColorSetting setting = {.color=color, .mode=mode};
	tinyLED_colors[LED_id] = setting;
     a54:	e8 2f       	mov	r30, r24
     a56:	f0 e0       	ldi	r31, 0x00	; 0
     a58:	ee 0f       	add	r30, r30
     a5a:	ff 1f       	adc	r31, r31
     a5c:	e0 5a       	subi	r30, 0xA0	; 160
     a5e:	f7 4c       	sbci	r31, 0xC7	; 199
     a60:	60 83       	st	Z, r22
     a62:	11 82       	std	Z+1, r1	; 0x01
     a64:	08 95       	ret

00000a66 <tinyLED_get_color>:
	tinyLED_set_color_mode(LED_id, color, STABLE);
}

enum Colors tinyLED_get_color(uint8_t LED_id)
{
	return tinyLED_colors[LED_id].color;
     a66:	e8 2f       	mov	r30, r24
     a68:	f0 e0       	ldi	r31, 0x00	; 0
     a6a:	ee 0f       	add	r30, r30
     a6c:	ff 1f       	adc	r31, r31
     a6e:	e0 5a       	subi	r30, 0xA0	; 160
     a70:	f7 4c       	sbci	r31, 0xC7	; 199
}
     a72:	80 81       	ld	r24, Z
     a74:	08 95       	ret

00000a76 <tinyLED_set_color_mode>:
changes the values in the variables stored in the LED-array.
*/
void tinyLED_set_color_mode(uint8_t LED_id, enum Colors color, enum ColorModes mode)
{
	struct ColorSetting setting = {.color=color, .mode=mode};
	tinyLED_colors[LED_id] = setting;
     a76:	90 e0       	ldi	r25, 0x00	; 0
     a78:	fc 01       	movw	r30, r24
     a7a:	ee 0f       	add	r30, r30
     a7c:	ff 1f       	adc	r31, r31
     a7e:	e0 5a       	subi	r30, 0xA0	; 160
     a80:	f7 4c       	sbci	r31, 0xC7	; 199
     a82:	60 83       	st	Z, r22
     a84:	41 83       	std	Z+1, r20	; 0x01
	if (mode == FLASH_ONCE)
     a86:	44 30       	cpi	r20, 0x04	; 4
     a88:	29 f4       	brne	.+10     	; 0xa94 <tinyLED_set_color_mode+0x1e>
	{
		tinyLED_flash_once_time[LED_id] = 1000*FLASH_TIME;
     a8a:	fc 01       	movw	r30, r24
     a8c:	e8 5a       	subi	r30, 0xA8	; 168
     a8e:	f7 4c       	sbci	r31, 0xC7	; 199
     a90:	24 e6       	ldi	r18, 0x64	; 100
     a92:	20 83       	st	Z, r18
     a94:	08 95       	ret

00000a96 <tinyLED_RGB_Color_Compare>:
	return rgb_color;
			
};
// This might be cause of strange light behavior?
//Message		expected 'struct RGB_Color *' but argument is of type 'struct RGB_Color (*)[2]'	Hjernebyggesett_V4	C:\Users\Elias Lundheim\Documents\GitHub\neural\Hjernebyggesett_V4\Hjernebyggesett_V4\tinyLED\tinyLED.c	121
_Bool tinyLED_RGB_Color_Compare(struct RGB_Color (*a)[NUMBER_OF_LEDS], struct RGB_Color (*b)[NUMBER_OF_LEDS]){
     a96:	dc 01       	movw	r26, r24
     a98:	fb 01       	movw	r30, r22
	for (int i=0; i<NUMBER_OF_LEDS; i++)
	{
		if(!((*a)[i].red==(*b)[i].red && (*a)[i].green==(*b)[i].green && (*a)[i].blue==(*b)[i].blue)){
     a9a:	9c 91       	ld	r25, X
     a9c:	80 81       	ld	r24, Z
     a9e:	98 13       	cpse	r25, r24
     aa0:	20 c0       	rjmp	.+64     	; 0xae2 <tinyLED_RGB_Color_Compare+0x4c>
     aa2:	11 96       	adiw	r26, 0x01	; 1
     aa4:	9c 91       	ld	r25, X
     aa6:	11 97       	sbiw	r26, 0x01	; 1
     aa8:	81 81       	ldd	r24, Z+1	; 0x01
     aaa:	98 13       	cpse	r25, r24
     aac:	1c c0       	rjmp	.+56     	; 0xae6 <tinyLED_RGB_Color_Compare+0x50>
     aae:	12 96       	adiw	r26, 0x02	; 2
     ab0:	9c 91       	ld	r25, X
     ab2:	12 97       	sbiw	r26, 0x02	; 2
     ab4:	82 81       	ldd	r24, Z+2	; 0x02
     ab6:	98 13       	cpse	r25, r24
     ab8:	18 c0       	rjmp	.+48     	; 0xaea <tinyLED_RGB_Color_Compare+0x54>
     aba:	13 96       	adiw	r26, 0x03	; 3
     abc:	9c 91       	ld	r25, X
     abe:	13 97       	sbiw	r26, 0x03	; 3
     ac0:	83 81       	ldd	r24, Z+3	; 0x03
     ac2:	98 13       	cpse	r25, r24
     ac4:	14 c0       	rjmp	.+40     	; 0xaee <tinyLED_RGB_Color_Compare+0x58>
     ac6:	14 96       	adiw	r26, 0x04	; 4
     ac8:	9c 91       	ld	r25, X
     aca:	14 97       	sbiw	r26, 0x04	; 4
     acc:	84 81       	ldd	r24, Z+4	; 0x04
     ace:	98 13       	cpse	r25, r24
     ad0:	10 c0       	rjmp	.+32     	; 0xaf2 <tinyLED_RGB_Color_Compare+0x5c>
     ad2:	81 e0       	ldi	r24, 0x01	; 1
     ad4:	15 96       	adiw	r26, 0x05	; 5
     ad6:	2c 91       	ld	r18, X
     ad8:	95 81       	ldd	r25, Z+5	; 0x05
     ada:	29 17       	cp	r18, r25
     adc:	59 f0       	breq	.+22     	; 0xaf4 <tinyLED_RGB_Color_Compare+0x5e>
     ade:	80 e0       	ldi	r24, 0x00	; 0
     ae0:	08 95       	ret
			return false;
     ae2:	80 e0       	ldi	r24, 0x00	; 0
     ae4:	08 95       	ret
     ae6:	80 e0       	ldi	r24, 0x00	; 0
     ae8:	08 95       	ret
     aea:	80 e0       	ldi	r24, 0x00	; 0
     aec:	08 95       	ret
     aee:	80 e0       	ldi	r24, 0x00	; 0
     af0:	08 95       	ret
     af2:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	return true;
}
     af4:	08 95       	ret

00000af6 <tinyLED_update>:
/*
function to write the current LED-array on to the LEDs and
effectively update the values stored in the LEDs to the values stored in the MCU.
*/
void tinyLED_update(void)
{
     af6:	2f 92       	push	r2
     af8:	3f 92       	push	r3
     afa:	4f 92       	push	r4
     afc:	5f 92       	push	r5
     afe:	6f 92       	push	r6
     b00:	7f 92       	push	r7
     b02:	8f 92       	push	r8
     b04:	9f 92       	push	r9
     b06:	af 92       	push	r10
     b08:	bf 92       	push	r11
     b0a:	cf 92       	push	r12
     b0c:	df 92       	push	r13
     b0e:	ef 92       	push	r14
     b10:	ff 92       	push	r15
     b12:	0f 93       	push	r16
     b14:	1f 93       	push	r17
     b16:	cf 93       	push	r28
     b18:	df 93       	push	r29
     b1a:	cd b7       	in	r28, 0x3d	; 61
     b1c:	de b7       	in	r29, 0x3e	; 62
     b1e:	6e 97       	sbiw	r28, 0x1e	; 30
     b20:	cd bf       	out	0x3d, r28	; 61
     b22:	de bf       	out	0x3e, r29	; 62
			
	uint32_t now = tinyTime_now();
     b24:	0e 94 3a 08 	call	0x1074	; 0x1074 <tinyTime_now>
     b28:	6b 01       	movw	r12, r22
     b2a:	7c 01       	movw	r14, r24
	
	// This is a sin curve, but between 0 and 1 instead of -1 and 1
	double sinValue = 0.5+sin((double)now/(100*M_PI/SWING_RATE))/2;
     b2c:	0e 94 90 09 	call	0x1320	; 0x1320 <__floatunsisf>
     b30:	23 e6       	ldi	r18, 0x63	; 99
     b32:	34 e1       	ldi	r19, 0x14	; 20
     b34:	4d e9       	ldi	r20, 0x9D	; 157
     b36:	53 e4       	ldi	r21, 0x43	; 67
     b38:	0e 94 b5 08 	call	0x116a	; 0x116a <__divsf3>
     b3c:	0e 94 70 0b 	call	0x16e0	; 0x16e0 <sin>
     b40:	20 e0       	ldi	r18, 0x00	; 0
     b42:	30 e0       	ldi	r19, 0x00	; 0
     b44:	40 e0       	ldi	r20, 0x00	; 0
     b46:	5f e3       	ldi	r21, 0x3F	; 63
     b48:	0e 94 03 0b 	call	0x1606	; 0x1606 <__mulsf3>
     b4c:	20 e0       	ldi	r18, 0x00	; 0
     b4e:	30 e0       	ldi	r19, 0x00	; 0
     b50:	40 e0       	ldi	r20, 0x00	; 0
     b52:	5f e3       	ldi	r21, 0x3F	; 63
     b54:	0e 94 44 08 	call	0x1088	; 0x1088 <__addsf3>
     b58:	69 87       	std	Y+9, r22	; 0x09
     b5a:	7a 87       	std	Y+10, r23	; 0x0a
     b5c:	8b 87       	std	Y+11, r24	; 0x0b
     b5e:	9c 87       	std	Y+12, r25	; 0x0c
	
	// If FLASH_RATE is one, then that means that the left side of the "<" will just count from 0 to 1000, and flash_on will be true for half of the time
	_Bool flash_on = now%(uint32_t)(1000/FLASH_RATE)  <   500/FLASH_RATE;
     b60:	c7 01       	movw	r24, r14
     b62:	b6 01       	movw	r22, r12
     b64:	24 ef       	ldi	r18, 0xF4	; 244
     b66:	31 e0       	ldi	r19, 0x01	; 1
     b68:	40 e0       	ldi	r20, 0x00	; 0
     b6a:	50 e0       	ldi	r21, 0x00	; 0
     b6c:	0e 94 d9 0b 	call	0x17b2	; 0x17b2 <__udivmodsi4>
     b70:	0e 94 90 09 	call	0x1320	; 0x1320 <__floatunsisf>
     b74:	20 e0       	ldi	r18, 0x00	; 0
     b76:	30 e0       	ldi	r19, 0x00	; 0
     b78:	4a e7       	ldi	r20, 0x7A	; 122
     b7a:	53 e4       	ldi	r21, 0x43	; 67
     b7c:	0e 94 b0 08 	call	0x1160	; 0x1160 <__cmpsf2>
     b80:	88 1f       	adc	r24, r24
     b82:	88 27       	eor	r24, r24
     b84:	88 1f       	adc	r24, r24
     b86:	8f 83       	std	Y+7, r24	; 0x07
	
	// PING_RATE is usually small, so the left side counts to some large number. Since flash_time usually is also quite small,
	// the left side will usually be larger than the right
	_Bool ping_on =  now%(uint32_t)(1000/PING_RATE)   <   1000*FLASH_TIME;
     b88:	c7 01       	movw	r24, r14
     b8a:	b6 01       	movw	r22, r12
     b8c:	28 e8       	ldi	r18, 0x88	; 136
     b8e:	33 e1       	ldi	r19, 0x13	; 19
     b90:	40 e0       	ldi	r20, 0x00	; 0
     b92:	50 e0       	ldi	r21, 0x00	; 0
     b94:	0e 94 d9 0b 	call	0x17b2	; 0x17b2 <__udivmodsi4>
     b98:	0e 94 90 09 	call	0x1320	; 0x1320 <__floatunsisf>
     b9c:	20 e0       	ldi	r18, 0x00	; 0
     b9e:	30 e0       	ldi	r19, 0x00	; 0
     ba0:	48 ec       	ldi	r20, 0xC8	; 200
     ba2:	52 e4       	ldi	r21, 0x42	; 66
     ba4:	0e 94 b0 08 	call	0x1160	; 0x1160 <__cmpsf2>
     ba8:	88 1f       	adc	r24, r24
     baa:	88 27       	eor	r24, r24
     bac:	88 1f       	adc	r24, r24
     bae:	00 e6       	ldi	r16, 0x60	; 96
     bb0:	18 e3       	ldi	r17, 0x38	; 56
     bb2:	9e 01       	movw	r18, r28
     bb4:	2f 5f       	subi	r18, 0xFF	; 255
     bb6:	3f 4f       	sbci	r19, 0xFF	; 255
     bb8:	0f 2e       	mov	r0, r31
     bba:	f8 e5       	ldi	r31, 0x58	; 88
     bbc:	4f 2e       	mov	r4, r31
     bbe:	f8 e3       	ldi	r31, 0x38	; 56
     bc0:	5f 2e       	mov	r5, r31
     bc2:	f0 2d       	mov	r31, r0
     bc4:	0f 2e       	mov	r0, r31
     bc6:	f4 e6       	ldi	r31, 0x64	; 100
     bc8:	6f 2e       	mov	r6, r31
     bca:	f8 e3       	ldi	r31, 0x38	; 56
     bcc:	7f 2e       	mov	r7, r31
     bce:	f0 2d       	mov	r31, r0
     bd0:	19 01       	movw	r2, r18
			case SWING:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*sinValue, rgb_colors[i].green*sinValue, rgb_colors[i].blue*sinValue};
				break;
			case PING:
				// in the line below, fmin will either return 1 or 0, so each rgb color is either 0 or 255*PING_BRIGHTNESS
				rgb_colors[i] = (struct RGB_Color){255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].red)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].green)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].blue)*ping_on};
     bd2:	88 2e       	mov	r8, r24
     bd4:	91 2c       	mov	r9, r1
     bd6:	a1 2c       	mov	r10, r1
     bd8:	b1 2c       	mov	r11, r1
     bda:	2d 87       	std	Y+13, r18	; 0x0d
     bdc:	3e 87       	std	Y+14, r19	; 0x0e
     bde:	df 80       	ldd	r13, Y+7	; 0x07
     be0:	f8 01       	movw	r30, r16
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 0 << TCA_SPLIT_ENABLE_bp; //Stop TCA
}

static struct RGB_Color tinyLED_enum_to_RGB_Color(enum Colors color){
	struct RGB_Color rgb_color;
	switch(color)
     be2:	80 81       	ld	r24, Z
     be4:	83 30       	cpi	r24, 0x03	; 3
     be6:	79 f0       	breq	.+30     	; 0xc06 <tinyLED_update+0x110>
     be8:	28 f4       	brcc	.+10     	; 0xbf4 <tinyLED_update+0xfe>
     bea:	81 30       	cpi	r24, 0x01	; 1
     bec:	41 f0       	breq	.+16     	; 0xbfe <tinyLED_update+0x108>
     bee:	82 30       	cpi	r24, 0x02	; 2
     bf0:	89 f0       	breq	.+34     	; 0xc14 <tinyLED_update+0x11e>
     bf2:	28 c0       	rjmp	.+80     	; 0xc44 <tinyLED_update+0x14e>
     bf4:	84 30       	cpi	r24, 0x04	; 4
     bf6:	a9 f0       	breq	.+42     	; 0xc22 <tinyLED_update+0x12c>
     bf8:	85 30       	cpi	r24, 0x05	; 5
     bfa:	d1 f0       	breq	.+52     	; 0xc30 <tinyLED_update+0x13a>
     bfc:	23 c0       	rjmp	.+70     	; 0xc44 <tinyLED_update+0x14e>
	{
		case OFF:
			rgb_color = (struct RGB_Color){0, 0, 0};
			break;
		case RED:
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 0, 0};
     bfe:	f1 2c       	mov	r15, r1
     c00:	e1 2c       	mov	r14, r1
     c02:	69 e1       	ldi	r22, 0x19	; 25
     c04:	22 c0       	rjmp	.+68     	; 0xc4a <tinyLED_update+0x154>
			break;
		case GREEN:
			rgb_color = (struct RGB_Color){0, 255*LED_BRIGHTNESS, 0};
     c06:	f1 2c       	mov	r15, r1
     c08:	0f 2e       	mov	r0, r31
     c0a:	f9 e1       	ldi	r31, 0x19	; 25
     c0c:	ef 2e       	mov	r14, r31
     c0e:	f0 2d       	mov	r31, r0
     c10:	60 e0       	ldi	r22, 0x00	; 0
     c12:	1b c0       	rjmp	.+54     	; 0xc4a <tinyLED_update+0x154>
			break;
		case BLUE:
			rgb_color = (struct RGB_Color){0, 0, 255*LED_BRIGHTNESS};
     c14:	0f 2e       	mov	r0, r31
     c16:	f9 e1       	ldi	r31, 0x19	; 25
     c18:	ff 2e       	mov	r15, r31
     c1a:	f0 2d       	mov	r31, r0
     c1c:	e1 2c       	mov	r14, r1
     c1e:	60 e0       	ldi	r22, 0x00	; 0
     c20:	14 c0       	rjmp	.+40     	; 0xc4a <tinyLED_update+0x154>
			break;
		case YELLOW:
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS, 0};
     c22:	f1 2c       	mov	r15, r1
     c24:	0f 2e       	mov	r0, r31
     c26:	f9 e1       	ldi	r31, 0x19	; 25
     c28:	ef 2e       	mov	r14, r31
     c2a:	f0 2d       	mov	r31, r0
     c2c:	69 e1       	ldi	r22, 0x19	; 25
     c2e:	0d c0       	rjmp	.+26     	; 0xc4a <tinyLED_update+0x154>
			// Should the /3 be there? This requires testing.
			// After testing, findings were that at 0.1 brightness, one would see the three LEDs instead of one white led
			// We try with /2 instead.
			// We find that the best results come from not dividing by anything. At leasts in the lower brightness settings, and that
			// is where we suspect it will be most of the time. When we divide, the LEDs are so weak, that they appear as three lights instead of one.
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS};
     c30:	0f 2e       	mov	r0, r31
     c32:	f9 e1       	ldi	r31, 0x19	; 25
     c34:	ff 2e       	mov	r15, r31
     c36:	f0 2d       	mov	r31, r0
     c38:	0f 2e       	mov	r0, r31
     c3a:	f9 e1       	ldi	r31, 0x19	; 25
     c3c:	ef 2e       	mov	r14, r31
     c3e:	f0 2d       	mov	r31, r0
     c40:	69 e1       	ldi	r22, 0x19	; 25
     c42:	03 c0       	rjmp	.+6      	; 0xc4a <tinyLED_update+0x154>
static struct RGB_Color tinyLED_enum_to_RGB_Color(enum Colors color){
	struct RGB_Color rgb_color;
	switch(color)
	{
		case OFF:
			rgb_color = (struct RGB_Color){0, 0, 0};
     c44:	f1 2c       	mov	r15, r1
     c46:	e1 2c       	mov	r14, r1
     c48:	60 e0       	ldi	r22, 0x00	; 0
     c4a:	2f 82       	std	Y+7, r2	; 0x07
     c4c:	38 86       	std	Y+8, r3	; 0x08
	
		
	for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
	{		
		// Convert enum to RGB_Color
		rgb_colors[i] = tinyLED_enum_to_RGB_Color(tinyLED_colors[i].color);
     c4e:	d1 01       	movw	r26, r2
     c50:	6c 93       	st	X, r22
     c52:	11 96       	adiw	r26, 0x01	; 1
     c54:	ec 92       	st	X, r14
     c56:	11 97       	sbiw	r26, 0x01	; 1
     c58:	12 96       	adiw	r26, 0x02	; 2
     c5a:	fc 92       	st	X, r15
			
		// Adjust colors according to mode
		switch(tinyLED_colors[i].mode)
     c5c:	81 81       	ldd	r24, Z+1	; 0x01
     c5e:	82 30       	cpi	r24, 0x02	; 2
     c60:	d1 f0       	breq	.+52     	; 0xc96 <tinyLED_update+0x1a0>
     c62:	18 f4       	brcc	.+6      	; 0xc6a <tinyLED_update+0x174>
     c64:	81 30       	cpi	r24, 0x01	; 1
     c66:	41 f0       	breq	.+16     	; 0xc78 <tinyLED_update+0x182>
     c68:	cd c0       	rjmp	.+410    	; 0xe04 <tinyLED_update+0x30e>
     c6a:	83 30       	cpi	r24, 0x03	; 3
     c6c:	09 f4       	brne	.+2      	; 0xc70 <tinyLED_update+0x17a>
     c6e:	44 c0       	rjmp	.+136    	; 0xcf8 <tinyLED_update+0x202>
     c70:	84 30       	cpi	r24, 0x04	; 4
     c72:	09 f4       	brne	.+2      	; 0xc76 <tinyLED_update+0x180>
     c74:	bf c0       	rjmp	.+382    	; 0xdf4 <tinyLED_update+0x2fe>
     c76:	c6 c0       	rjmp	.+396    	; 0xe04 <tinyLED_update+0x30e>
		{
			case STABLE:
				break;
			case FLASH:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*flash_on, rgb_colors[i].green*flash_on, rgb_colors[i].blue*flash_on};
     c78:	d6 9e       	mul	r13, r22
     c7a:	60 2d       	mov	r22, r0
     c7c:	11 24       	eor	r1, r1
     c7e:	ef 81       	ldd	r30, Y+7	; 0x07
     c80:	f8 85       	ldd	r31, Y+8	; 0x08
     c82:	60 83       	st	Z, r22
     c84:	de 9c       	mul	r13, r14
     c86:	e0 2c       	mov	r14, r0
     c88:	11 24       	eor	r1, r1
     c8a:	e1 82       	std	Z+1, r14	; 0x01
     c8c:	df 9c       	mul	r13, r15
     c8e:	f0 2c       	mov	r15, r0
     c90:	11 24       	eor	r1, r1
     c92:	f2 82       	std	Z+2, r15	; 0x02
				break;
     c94:	b7 c0       	rjmp	.+366    	; 0xe04 <tinyLED_update+0x30e>
			case SWING:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*sinValue, rgb_colors[i].green*sinValue, rgb_colors[i].blue*sinValue};
     c96:	70 e0       	ldi	r23, 0x00	; 0
     c98:	80 e0       	ldi	r24, 0x00	; 0
     c9a:	90 e0       	ldi	r25, 0x00	; 0
     c9c:	0e 94 92 09 	call	0x1324	; 0x1324 <__floatsisf>
     ca0:	29 85       	ldd	r18, Y+9	; 0x09
     ca2:	3a 85       	ldd	r19, Y+10	; 0x0a
     ca4:	4b 85       	ldd	r20, Y+11	; 0x0b
     ca6:	5c 85       	ldd	r21, Y+12	; 0x0c
     ca8:	0e 94 03 0b 	call	0x1606	; 0x1606 <__mulsf3>
     cac:	0e 94 61 09 	call	0x12c2	; 0x12c2 <__fixunssfsi>
     cb0:	d1 01       	movw	r26, r2
     cb2:	6c 93       	st	X, r22
     cb4:	6e 2d       	mov	r22, r14
     cb6:	70 e0       	ldi	r23, 0x00	; 0
     cb8:	80 e0       	ldi	r24, 0x00	; 0
     cba:	90 e0       	ldi	r25, 0x00	; 0
     cbc:	0e 94 92 09 	call	0x1324	; 0x1324 <__floatsisf>
     cc0:	29 85       	ldd	r18, Y+9	; 0x09
     cc2:	3a 85       	ldd	r19, Y+10	; 0x0a
     cc4:	4b 85       	ldd	r20, Y+11	; 0x0b
     cc6:	5c 85       	ldd	r21, Y+12	; 0x0c
     cc8:	0e 94 03 0b 	call	0x1606	; 0x1606 <__mulsf3>
     ccc:	0e 94 61 09 	call	0x12c2	; 0x12c2 <__fixunssfsi>
     cd0:	f1 01       	movw	r30, r2
     cd2:	61 83       	std	Z+1, r22	; 0x01
     cd4:	6f 2d       	mov	r22, r15
     cd6:	70 e0       	ldi	r23, 0x00	; 0
     cd8:	80 e0       	ldi	r24, 0x00	; 0
     cda:	90 e0       	ldi	r25, 0x00	; 0
     cdc:	0e 94 92 09 	call	0x1324	; 0x1324 <__floatsisf>
     ce0:	29 85       	ldd	r18, Y+9	; 0x09
     ce2:	3a 85       	ldd	r19, Y+10	; 0x0a
     ce4:	4b 85       	ldd	r20, Y+11	; 0x0b
     ce6:	5c 85       	ldd	r21, Y+12	; 0x0c
     ce8:	0e 94 03 0b 	call	0x1606	; 0x1606 <__mulsf3>
     cec:	0e 94 61 09 	call	0x12c2	; 0x12c2 <__fixunssfsi>
     cf0:	d1 01       	movw	r26, r2
     cf2:	12 96       	adiw	r26, 0x02	; 2
     cf4:	6c 93       	st	X, r22
				break;
     cf6:	86 c0       	rjmp	.+268    	; 0xe04 <tinyLED_update+0x30e>
			case PING:
				// in the line below, fmin will either return 1 or 0, so each rgb color is either 0 or 255*PING_BRIGHTNESS
				rgb_colors[i] = (struct RGB_Color){255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].red)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].green)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].blue)*ping_on};
     cf8:	70 e0       	ldi	r23, 0x00	; 0
     cfa:	80 e0       	ldi	r24, 0x00	; 0
     cfc:	90 e0       	ldi	r25, 0x00	; 0
     cfe:	0e 94 90 09 	call	0x1320	; 0x1320 <__floatunsisf>
     d02:	9b 01       	movw	r18, r22
     d04:	ac 01       	movw	r20, r24
     d06:	60 e0       	ldi	r22, 0x00	; 0
     d08:	70 e0       	ldi	r23, 0x00	; 0
     d0a:	80 e8       	ldi	r24, 0x80	; 128
     d0c:	9f e3       	ldi	r25, 0x3F	; 63
     d0e:	0e 94 cd 09 	call	0x139a	; 0x139a <fmin>
     d12:	6b 8b       	std	Y+19, r22	; 0x13
     d14:	7c 8b       	std	Y+20, r23	; 0x14
     d16:	8d 8b       	std	Y+21, r24	; 0x15
     d18:	9e 8b       	std	Y+22, r25	; 0x16
     d1a:	c5 01       	movw	r24, r10
     d1c:	b4 01       	movw	r22, r8
     d1e:	0e 94 92 09 	call	0x1324	; 0x1324 <__floatsisf>
     d22:	6f 87       	std	Y+15, r22	; 0x0f
     d24:	78 8b       	std	Y+16, r23	; 0x10
     d26:	89 8b       	std	Y+17, r24	; 0x11
     d28:	9a 8b       	std	Y+18, r25	; 0x12
     d2a:	6e 2d       	mov	r22, r14
     d2c:	70 e0       	ldi	r23, 0x00	; 0
     d2e:	80 e0       	ldi	r24, 0x00	; 0
     d30:	90 e0       	ldi	r25, 0x00	; 0
     d32:	0e 94 90 09 	call	0x1320	; 0x1320 <__floatunsisf>
     d36:	9b 01       	movw	r18, r22
     d38:	ac 01       	movw	r20, r24
     d3a:	60 e0       	ldi	r22, 0x00	; 0
     d3c:	70 e0       	ldi	r23, 0x00	; 0
     d3e:	80 e8       	ldi	r24, 0x80	; 128
     d40:	9f e3       	ldi	r25, 0x3F	; 63
     d42:	0e 94 cd 09 	call	0x139a	; 0x139a <fmin>
     d46:	6f 8b       	std	Y+23, r22	; 0x17
     d48:	78 8f       	std	Y+24, r23	; 0x18
     d4a:	89 8f       	std	Y+25, r24	; 0x19
     d4c:	9a 8f       	std	Y+26, r25	; 0x1a
     d4e:	6f 2d       	mov	r22, r15
     d50:	70 e0       	ldi	r23, 0x00	; 0
     d52:	80 e0       	ldi	r24, 0x00	; 0
     d54:	90 e0       	ldi	r25, 0x00	; 0
     d56:	0e 94 90 09 	call	0x1320	; 0x1320 <__floatunsisf>
     d5a:	9b 01       	movw	r18, r22
     d5c:	ac 01       	movw	r20, r24
     d5e:	60 e0       	ldi	r22, 0x00	; 0
     d60:	70 e0       	ldi	r23, 0x00	; 0
     d62:	80 e8       	ldi	r24, 0x80	; 128
     d64:	9f e3       	ldi	r25, 0x3F	; 63
     d66:	0e 94 cd 09 	call	0x139a	; 0x139a <fmin>
     d6a:	6b 8f       	std	Y+27, r22	; 0x1b
     d6c:	7c 8f       	std	Y+28, r23	; 0x1c
     d6e:	8d 8f       	std	Y+29, r24	; 0x1d
     d70:	9e 8f       	std	Y+30, r25	; 0x1e
     d72:	23 e3       	ldi	r18, 0x33	; 51
     d74:	33 e3       	ldi	r19, 0x33	; 51
     d76:	43 ea       	ldi	r20, 0xA3	; 163
     d78:	50 e4       	ldi	r21, 0x40	; 64
     d7a:	6b 89       	ldd	r22, Y+19	; 0x13
     d7c:	7c 89       	ldd	r23, Y+20	; 0x14
     d7e:	8d 89       	ldd	r24, Y+21	; 0x15
     d80:	9e 89       	ldd	r25, Y+22	; 0x16
     d82:	0e 94 03 0b 	call	0x1606	; 0x1606 <__mulsf3>
     d86:	2f 85       	ldd	r18, Y+15	; 0x0f
     d88:	38 89       	ldd	r19, Y+16	; 0x10
     d8a:	49 89       	ldd	r20, Y+17	; 0x11
     d8c:	5a 89       	ldd	r21, Y+18	; 0x12
     d8e:	0e 94 03 0b 	call	0x1606	; 0x1606 <__mulsf3>
     d92:	0e 94 61 09 	call	0x12c2	; 0x12c2 <__fixunssfsi>
     d96:	ef 81       	ldd	r30, Y+7	; 0x07
     d98:	f8 85       	ldd	r31, Y+8	; 0x08
     d9a:	60 83       	st	Z, r22
     d9c:	23 e3       	ldi	r18, 0x33	; 51
     d9e:	33 e3       	ldi	r19, 0x33	; 51
     da0:	43 ea       	ldi	r20, 0xA3	; 163
     da2:	50 e4       	ldi	r21, 0x40	; 64
     da4:	6f 89       	ldd	r22, Y+23	; 0x17
     da6:	78 8d       	ldd	r23, Y+24	; 0x18
     da8:	89 8d       	ldd	r24, Y+25	; 0x19
     daa:	9a 8d       	ldd	r25, Y+26	; 0x1a
     dac:	0e 94 03 0b 	call	0x1606	; 0x1606 <__mulsf3>
     db0:	2f 85       	ldd	r18, Y+15	; 0x0f
     db2:	38 89       	ldd	r19, Y+16	; 0x10
     db4:	49 89       	ldd	r20, Y+17	; 0x11
     db6:	5a 89       	ldd	r21, Y+18	; 0x12
     db8:	0e 94 03 0b 	call	0x1606	; 0x1606 <__mulsf3>
     dbc:	0e 94 61 09 	call	0x12c2	; 0x12c2 <__fixunssfsi>
     dc0:	af 81       	ldd	r26, Y+7	; 0x07
     dc2:	b8 85       	ldd	r27, Y+8	; 0x08
     dc4:	11 96       	adiw	r26, 0x01	; 1
     dc6:	6c 93       	st	X, r22
     dc8:	23 e3       	ldi	r18, 0x33	; 51
     dca:	33 e3       	ldi	r19, 0x33	; 51
     dcc:	43 ea       	ldi	r20, 0xA3	; 163
     dce:	50 e4       	ldi	r21, 0x40	; 64
     dd0:	6b 8d       	ldd	r22, Y+27	; 0x1b
     dd2:	7c 8d       	ldd	r23, Y+28	; 0x1c
     dd4:	8d 8d       	ldd	r24, Y+29	; 0x1d
     dd6:	9e 8d       	ldd	r25, Y+30	; 0x1e
     dd8:	0e 94 03 0b 	call	0x1606	; 0x1606 <__mulsf3>
     ddc:	2f 85       	ldd	r18, Y+15	; 0x0f
     dde:	38 89       	ldd	r19, Y+16	; 0x10
     de0:	49 89       	ldd	r20, Y+17	; 0x11
     de2:	5a 89       	ldd	r21, Y+18	; 0x12
     de4:	0e 94 03 0b 	call	0x1606	; 0x1606 <__mulsf3>
     de8:	0e 94 61 09 	call	0x12c2	; 0x12c2 <__fixunssfsi>
     dec:	ef 81       	ldd	r30, Y+7	; 0x07
     dee:	f8 85       	ldd	r31, Y+8	; 0x08
     df0:	62 83       	std	Z+2, r22	; 0x02
				break;
     df2:	08 c0       	rjmp	.+16     	; 0xe04 <tinyLED_update+0x30e>
			case FLASH_ONCE:
				if(tinyLED_flash_once_time[i]>0){
     df4:	d2 01       	movw	r26, r4
     df6:	8c 91       	ld	r24, X
     df8:	88 23       	and	r24, r24
     dfa:	19 f0       	breq	.+6      	; 0xe02 <tinyLED_update+0x30c>
					rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red, rgb_colors[i].green, rgb_colors[i].blue};
					tinyLED_flash_once_time[i]--;
     dfc:	81 50       	subi	r24, 0x01	; 1
     dfe:	8c 93       	st	X, r24
     e00:	01 c0       	rjmp	.+2      	; 0xe04 <tinyLED_update+0x30e>
				}
				else{
					tinyLED_colors[i].color = OFF;
     e02:	10 82       	st	Z, r1
     e04:	0e 5f       	subi	r16, 0xFE	; 254
     e06:	1f 4f       	sbci	r17, 0xFF	; 255
     e08:	b3 e0       	ldi	r27, 0x03	; 3
     e0a:	2b 0e       	add	r2, r27
     e0c:	31 1c       	adc	r3, r1
     e0e:	ef ef       	ldi	r30, 0xFF	; 255
     e10:	4e 1a       	sub	r4, r30
     e12:	5e 0a       	sbc	r5, r30
	
	// This is where we store all the actual color values we want to send to the LED
	struct RGB_Color rgb_colors[NUMBER_OF_LEDS];
	
		
	for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
     e14:	06 15       	cp	r16, r6
     e16:	17 05       	cpc	r17, r7
     e18:	09 f0       	breq	.+2      	; 0xe1c <tinyLED_update+0x326>
     e1a:	e2 ce       	rjmp	.-572    	; 0xbe0 <tinyLED_update+0xea>
     e1c:	cd 84       	ldd	r12, Y+13	; 0x0d
     e1e:	de 84       	ldd	r13, Y+14	; 0x0e
				break;
		}
	}
	
	// We only write to the LEDs if there is something to change. (eg. in SWING mode, we update the LEDs almost every cycle)
	if(!tinyLED_RGB_Color_Compare(&rgb_colors, &tinyLED_old_colors)){
     e20:	6a e5       	ldi	r22, 0x5A	; 90
     e22:	78 e3       	ldi	r23, 0x38	; 56
     e24:	ce 01       	movw	r24, r28
     e26:	01 96       	adiw	r24, 0x01	; 1
     e28:	0e 94 4b 05 	call	0xa96	; 0xa96 <tinyLED_RGB_Color_Compare>
     e2c:	81 11       	cpse	r24, r1
     e2e:	2f c0       	rjmp	.+94     	; 0xe8e <tinyLED_update+0x398>
     e30:	0a e5       	ldi	r16, 0x5A	; 90
     e32:	18 e3       	ldi	r17, 0x38	; 56
     e34:	7e 01       	movw	r14, r28
     e36:	f7 e0       	ldi	r31, 0x07	; 7
     e38:	ef 0e       	add	r14, r31
     e3a:	f1 1c       	adc	r15, r1
		for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
		{
			// Write to LEDs
			//For some reason, the data-bus to the LEDs is serialized as GRB
			//which means the 24-bit data-bus will look like [Green[0:7], Red[0:7], Blue[0:7]]
			tinyLED_SPIWriteByte(rgb_colors[i].green);
     e3c:	d6 01       	movw	r26, r12
     e3e:	11 96       	adiw	r26, 0x01	; 1
     e40:	8c 91       	ld	r24, X
     e42:	0e 94 16 05 	call	0xa2c	; 0xa2c <tinyLED_SPIWriteByte>
			tinyLED_SPIWriteByte(rgb_colors[i].red);
     e46:	f6 01       	movw	r30, r12
     e48:	80 81       	ld	r24, Z
     e4a:	0e 94 16 05 	call	0xa2c	; 0xa2c <tinyLED_SPIWriteByte>
			tinyLED_SPIWriteByte(rgb_colors[i].blue);
     e4e:	d6 01       	movw	r26, r12
     e50:	12 96       	adiw	r26, 0x02	; 2
     e52:	8c 91       	ld	r24, X
     e54:	0e 94 16 05 	call	0xa2c	; 0xa2c <tinyLED_SPIWriteByte>
			tinyLED_old_colors[i] = rgb_colors[i];
     e58:	f6 01       	movw	r30, r12
     e5a:	81 91       	ld	r24, Z+
     e5c:	91 91       	ld	r25, Z+
     e5e:	a1 91       	ld	r26, Z+
     e60:	6f 01       	movw	r12, r30
     e62:	f8 01       	movw	r30, r16
     e64:	81 93       	st	Z+, r24
     e66:	91 93       	st	Z+, r25
     e68:	a1 93       	st	Z+, r26
     e6a:	8f 01       	movw	r16, r30
		}
	}
	
	// We only write to the LEDs if there is something to change. (eg. in SWING mode, we update the LEDs almost every cycle)
	if(!tinyLED_RGB_Color_Compare(&rgb_colors, &tinyLED_old_colors)){
		for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
     e6c:	ce 14       	cp	r12, r14
     e6e:	df 04       	cpc	r13, r15
     e70:	29 f7       	brne	.-54     	; 0xe3c <tinyLED_update+0x346>
			tinyLED_SPIWriteByte(rgb_colors[i].green);
			tinyLED_SPIWriteByte(rgb_colors[i].red);
			tinyLED_SPIWriteByte(rgb_colors[i].blue);
			tinyLED_old_colors[i] = rgb_colors[i];
		}
		tinyDebugger_send_uint8("LED1 color", tinyLED_colors[0].color);
     e72:	00 e6       	ldi	r16, 0x60	; 96
     e74:	18 e3       	ldi	r17, 0x38	; 56
     e76:	d8 01       	movw	r26, r16
     e78:	6c 91       	ld	r22, X
     e7a:	8a e1       	ldi	r24, 0x1A	; 26
     e7c:	98 e9       	ldi	r25, 0x98	; 152
     e7e:	0e 94 dd 03 	call	0x7ba	; 0x7ba <tinyDebugger_send_uint8>
		tinyDebugger_send_uint8("LED2 color", tinyLED_colors[1].color);
     e82:	f8 01       	movw	r30, r16
     e84:	62 81       	ldd	r22, Z+2	; 0x02
     e86:	85 e2       	ldi	r24, 0x25	; 37
     e88:	98 e9       	ldi	r25, 0x98	; 152
     e8a:	0e 94 dd 03 	call	0x7ba	; 0x7ba <tinyDebugger_send_uint8>
	}
}
     e8e:	6e 96       	adiw	r28, 0x1e	; 30
     e90:	cd bf       	out	0x3d, r28	; 61
     e92:	de bf       	out	0x3e, r29	; 62
     e94:	df 91       	pop	r29
     e96:	cf 91       	pop	r28
     e98:	1f 91       	pop	r17
     e9a:	0f 91       	pop	r16
     e9c:	ff 90       	pop	r15
     e9e:	ef 90       	pop	r14
     ea0:	df 90       	pop	r13
     ea2:	cf 90       	pop	r12
     ea4:	bf 90       	pop	r11
     ea6:	af 90       	pop	r10
     ea8:	9f 90       	pop	r9
     eaa:	8f 90       	pop	r8
     eac:	7f 90       	pop	r7
     eae:	6f 90       	pop	r6
     eb0:	5f 90       	pop	r5
     eb2:	4f 90       	pop	r4
     eb4:	3f 90       	pop	r3
     eb6:	2f 90       	pop	r2
     eb8:	08 95       	ret

00000eba <tinyPotential_update>:

/*
Update the potential
*/
void tinyPotential_update()
{
     eba:	cf 92       	push	r12
     ebc:	df 92       	push	r13
     ebe:	ef 92       	push	r14
     ec0:	ff 92       	push	r15
Function to decay the potential towards 0
*/
static void tinyPotential_decay()
{
		
	uint8_t time_since_last_update = tinyTime_now() - previous_update_time;
     ec2:	0e 94 3a 08 	call	0x1074	; 0x1074 <tinyTime_now>
	tinyPotential_potential *= (exp(-((float)time_since_last_update/(float)TINYPOTENTIAL_TIME_CONST)));
     ec6:	80 91 44 38 	lds	r24, 0x3844	; 0x803844 <previous_update_time>
     eca:	68 1b       	sub	r22, r24
     ecc:	70 e0       	ldi	r23, 0x00	; 0
     ece:	80 e0       	ldi	r24, 0x00	; 0
     ed0:	90 e0       	ldi	r25, 0x00	; 0
     ed2:	0e 94 90 09 	call	0x1320	; 0x1320 <__floatunsisf>
     ed6:	20 e0       	ldi	r18, 0x00	; 0
     ed8:	30 e0       	ldi	r19, 0x00	; 0
     eda:	48 ec       	ldi	r20, 0xC8	; 200
     edc:	52 e4       	ldi	r21, 0x42	; 66
     ede:	0e 94 b5 08 	call	0x116a	; 0x116a <__divsf3>
     ee2:	90 58       	subi	r25, 0x80	; 128
     ee4:	0e 94 2f 09 	call	0x125e	; 0x125e <exp>
     ee8:	20 91 48 38 	lds	r18, 0x3848	; 0x803848 <tinyPotential_potential>
     eec:	30 91 49 38 	lds	r19, 0x3849	; 0x803849 <tinyPotential_potential+0x1>
     ef0:	40 91 4a 38 	lds	r20, 0x384A	; 0x80384a <tinyPotential_potential+0x2>
     ef4:	50 91 4b 38 	lds	r21, 0x384B	; 0x80384b <tinyPotential_potential+0x3>
     ef8:	0e 94 03 0b 	call	0x1606	; 0x1606 <__mulsf3>
     efc:	6b 01       	movw	r12, r22
     efe:	7c 01       	movw	r14, r24
	if(fabs(tinyPotential_potential)<0.1){
     f00:	9f 77       	andi	r25, 0x7F	; 127
     f02:	2d ec       	ldi	r18, 0xCD	; 205
     f04:	3c ec       	ldi	r19, 0xCC	; 204
     f06:	4c ec       	ldi	r20, 0xCC	; 204
     f08:	5d e3       	ldi	r21, 0x3D	; 61
     f0a:	0e 94 b0 08 	call	0x1160	; 0x1160 <__cmpsf2>
     f0e:	88 23       	and	r24, r24
     f10:	4c f0       	brlt	.+18     	; 0xf24 <tinyPotential_update+0x6a>
*/
static void tinyPotential_decay()
{
		
	uint8_t time_since_last_update = tinyTime_now() - previous_update_time;
	tinyPotential_potential *= (exp(-((float)time_since_last_update/(float)TINYPOTENTIAL_TIME_CONST)));
     f12:	c0 92 48 38 	sts	0x3848, r12	; 0x803848 <tinyPotential_potential>
     f16:	d0 92 49 38 	sts	0x3849, r13	; 0x803849 <tinyPotential_potential+0x1>
     f1a:	e0 92 4a 38 	sts	0x384A, r14	; 0x80384a <tinyPotential_potential+0x2>
     f1e:	f0 92 4b 38 	sts	0x384B, r15	; 0x80384b <tinyPotential_potential+0x3>
     f22:	08 c0       	rjmp	.+16     	; 0xf34 <tinyPotential_update+0x7a>
	if(fabs(tinyPotential_potential)<0.1){
		tinyPotential_potential=0;
     f24:	10 92 48 38 	sts	0x3848, r1	; 0x803848 <tinyPotential_potential>
     f28:	10 92 49 38 	sts	0x3849, r1	; 0x803849 <tinyPotential_potential+0x1>
     f2c:	10 92 4a 38 	sts	0x384A, r1	; 0x80384a <tinyPotential_potential+0x2>
     f30:	10 92 4b 38 	sts	0x384B, r1	; 0x80384b <tinyPotential_potential+0x3>
	}
	previous_update_time = tinyTime_now();
     f34:	0e 94 3a 08 	call	0x1074	; 0x1074 <tinyTime_now>
     f38:	60 93 44 38 	sts	0x3844, r22	; 0x803844 <previous_update_time>
     f3c:	70 93 45 38 	sts	0x3845, r23	; 0x803845 <previous_update_time+0x1>
     f40:	80 93 46 38 	sts	0x3846, r24	; 0x803846 <previous_update_time+0x2>
     f44:	90 93 47 38 	sts	0x3847, r25	; 0x803847 <previous_update_time+0x3>
void tinyPotential_update()
{
	//Some of the potential in the neuron has decayed away
	tinyPotential_decay();
	// Update potential with values from Dendrites
	tinyPotential_potential = tinyDendrite_update_potential(tinyPotential_potential);
     f48:	60 91 48 38 	lds	r22, 0x3848	; 0x803848 <tinyPotential_potential>
     f4c:	70 91 49 38 	lds	r23, 0x3849	; 0x803849 <tinyPotential_potential+0x1>
     f50:	80 91 4a 38 	lds	r24, 0x384A	; 0x80384a <tinyPotential_potential+0x2>
     f54:	90 91 4b 38 	lds	r25, 0x384B	; 0x80384b <tinyPotential_potential+0x3>
     f58:	0e 94 ce 04 	call	0x99c	; 0x99c <tinyDendrite_update_potential>
     f5c:	60 93 48 38 	sts	0x3848, r22	; 0x803848 <tinyPotential_potential>
     f60:	70 93 49 38 	sts	0x3849, r23	; 0x803849 <tinyPotential_potential+0x1>
     f64:	80 93 4a 38 	sts	0x384A, r24	; 0x80384a <tinyPotential_potential+0x2>
     f68:	90 93 4b 38 	sts	0x384B, r25	; 0x80384b <tinyPotential_potential+0x3>
	
	// Update potential from button press
	tinyPotential_potential = tinyButton_update_potential(tinyPotential_potential);
     f6c:	0e 94 91 03 	call	0x722	; 0x722 <tinyButton_update_potential>
     f70:	60 93 48 38 	sts	0x3848, r22	; 0x803848 <tinyPotential_potential>
     f74:	70 93 49 38 	sts	0x3849, r23	; 0x803849 <tinyPotential_potential+0x1>
     f78:	80 93 4a 38 	sts	0x384A, r24	; 0x80384a <tinyPotential_potential+0x2>
     f7c:	90 93 4b 38 	sts	0x384B, r25	; 0x80384b <tinyPotential_potential+0x3>
	
	// Update potential with values from spontaneous pulse.
	tinyPotential_potential = tinyPulse_update_potential(tinyPotential_potential);
     f80:	0e 94 ee 07 	call	0xfdc	; 0xfdc <tinyPulse_update_potential>
     f84:	ab 01       	movw	r20, r22
     f86:	bc 01       	movw	r22, r24
     f88:	40 93 48 38 	sts	0x3848, r20	; 0x803848 <tinyPotential_potential>
     f8c:	50 93 49 38 	sts	0x3849, r21	; 0x803849 <tinyPotential_potential+0x1>
     f90:	60 93 4a 38 	sts	0x384A, r22	; 0x80384a <tinyPotential_potential+0x2>
     f94:	70 93 4b 38 	sts	0x384B, r23	; 0x80384b <tinyPotential_potential+0x3>
	
	tinyDebugger_send_double("Potential", tinyPotential_potential);
     f98:	80 e3       	ldi	r24, 0x30	; 48
     f9a:	98 e9       	ldi	r25, 0x98	; 152
     f9c:	0e 94 de 03 	call	0x7bc	; 0x7bc <tinyDebugger_send_double>
	
	
	// Let the axon affect the potential
	// This is also where we decide whether or not the axon should fire
	tinyPotential_potential = tinyAxon_update_potential(tinyPotential_potential);
     fa0:	60 91 48 38 	lds	r22, 0x3848	; 0x803848 <tinyPotential_potential>
     fa4:	70 91 49 38 	lds	r23, 0x3849	; 0x803849 <tinyPotential_potential+0x1>
     fa8:	80 91 4a 38 	lds	r24, 0x384A	; 0x80384a <tinyPotential_potential+0x2>
     fac:	90 91 4b 38 	lds	r25, 0x384B	; 0x80384b <tinyPotential_potential+0x3>
     fb0:	0e 94 88 02 	call	0x510	; 0x510 <tinyAxon_update_potential>
     fb4:	60 93 48 38 	sts	0x3848, r22	; 0x803848 <tinyPotential_potential>
     fb8:	70 93 49 38 	sts	0x3849, r23	; 0x803849 <tinyPotential_potential+0x1>
     fbc:	80 93 4a 38 	sts	0x384A, r24	; 0x80384a <tinyPotential_potential+0x2>
     fc0:	90 93 4b 38 	sts	0x384B, r25	; 0x80384b <tinyPotential_potential+0x3>
}
     fc4:	ff 90       	pop	r15
     fc6:	ef 90       	pop	r14
     fc8:	df 90       	pop	r13
     fca:	cf 90       	pop	r12
     fcc:	08 95       	ret

00000fce <tinyPulse_toggle_pulse_mode>:
uint32_t time_of_last_pulse = 0;
uint16_t time_since_last_pulse = 0;
uint16_t ideal_time_between_pulses = 1000/PULSEMODE_FREQUENCY;

void tinyPulse_toggle_pulse_mode(){
	pulse_mode = !pulse_mode;
     fce:	90 91 52 38 	lds	r25, 0x3852	; 0x803852 <pulse_mode>
     fd2:	81 e0       	ldi	r24, 0x01	; 1
     fd4:	89 27       	eor	r24, r25
     fd6:	80 93 52 38 	sts	0x3852, r24	; 0x803852 <pulse_mode>
     fda:	08 95       	ret

00000fdc <tinyPulse_update_potential>:
}

double tinyPulse_update_potential(double potential){
     fdc:	cf 92       	push	r12
     fde:	df 92       	push	r13
     fe0:	ef 92       	push	r14
     fe2:	ff 92       	push	r15
     fe4:	6b 01       	movw	r12, r22
     fe6:	7c 01       	movw	r14, r24
	if(pulse_mode){
     fe8:	80 91 52 38 	lds	r24, 0x3852	; 0x803852 <pulse_mode>
     fec:	88 23       	and	r24, r24
     fee:	39 f1       	breq	.+78     	; 0x103e <tinyPulse_update_potential+0x62>
		
		time_since_last_pulse = tinyTime_now() - time_of_last_pulse;
     ff0:	0e 94 3a 08 	call	0x1074	; 0x1074 <tinyTime_now>
     ff4:	20 91 4e 38 	lds	r18, 0x384E	; 0x80384e <time_of_last_pulse>
     ff8:	30 91 4f 38 	lds	r19, 0x384F	; 0x80384f <time_of_last_pulse+0x1>
     ffc:	62 1b       	sub	r22, r18
     ffe:	73 0b       	sbc	r23, r19
    1000:	60 93 4c 38 	sts	0x384C, r22	; 0x80384c <time_since_last_pulse>
    1004:	70 93 4d 38 	sts	0x384D, r23	; 0x80384d <time_since_last_pulse+0x1>
		
		if(time_since_last_pulse >= ideal_time_between_pulses){
    1008:	80 91 13 38 	lds	r24, 0x3813	; 0x803813 <ideal_time_between_pulses>
    100c:	90 91 14 38 	lds	r25, 0x3814	; 0x803814 <ideal_time_between_pulses+0x1>
    1010:	68 17       	cp	r22, r24
    1012:	79 07       	cpc	r23, r25
    1014:	a0 f0       	brcs	.+40     	; 0x103e <tinyPulse_update_potential+0x62>
			// This isn't actually a button press. You could have a separate variable for this, but it seems unnecessary.
			potential += BUTTON_PRESS_REACTION;
    1016:	20 e0       	ldi	r18, 0x00	; 0
    1018:	30 e0       	ldi	r19, 0x00	; 0
    101a:	40 ed       	ldi	r20, 0xD0	; 208
    101c:	51 e4       	ldi	r21, 0x41	; 65
    101e:	c7 01       	movw	r24, r14
    1020:	b6 01       	movw	r22, r12
    1022:	0e 94 44 08 	call	0x1088	; 0x1088 <__addsf3>
    1026:	6b 01       	movw	r12, r22
    1028:	7c 01       	movw	r14, r24
			time_of_last_pulse = tinyTime_now();			
    102a:	0e 94 3a 08 	call	0x1074	; 0x1074 <tinyTime_now>
    102e:	60 93 4e 38 	sts	0x384E, r22	; 0x80384e <time_of_last_pulse>
    1032:	70 93 4f 38 	sts	0x384F, r23	; 0x80384f <time_of_last_pulse+0x1>
    1036:	80 93 50 38 	sts	0x3850, r24	; 0x803850 <time_of_last_pulse+0x2>
    103a:	90 93 51 38 	sts	0x3851, r25	; 0x803851 <time_of_last_pulse+0x3>
		}
	}
	return potential;
}
    103e:	c7 01       	movw	r24, r14
    1040:	b6 01       	movw	r22, r12
    1042:	ff 90       	pop	r15
    1044:	ef 90       	pop	r14
    1046:	df 90       	pop	r13
    1048:	cf 90       	pop	r12
    104a:	08 95       	ret

0000104c <tinyTime_counter_increment>:
If the Interrupt Service Routine is clocked by a crystal oscillator
it gives a very precise timer-counter.
*/
void tinyTime_counter_increment(void)
{
	time_counter++;
    104c:	80 91 53 38 	lds	r24, 0x3853	; 0x803853 <time_counter>
    1050:	90 91 54 38 	lds	r25, 0x3854	; 0x803854 <time_counter+0x1>
    1054:	a0 91 55 38 	lds	r26, 0x3855	; 0x803855 <time_counter+0x2>
    1058:	b0 91 56 38 	lds	r27, 0x3856	; 0x803856 <time_counter+0x3>
    105c:	01 96       	adiw	r24, 0x01	; 1
    105e:	a1 1d       	adc	r26, r1
    1060:	b1 1d       	adc	r27, r1
    1062:	80 93 53 38 	sts	0x3853, r24	; 0x803853 <time_counter>
    1066:	90 93 54 38 	sts	0x3854, r25	; 0x803854 <time_counter+0x1>
    106a:	a0 93 55 38 	sts	0x3855, r26	; 0x803855 <time_counter+0x2>
    106e:	b0 93 56 38 	sts	0x3856, r27	; 0x803856 <time_counter+0x3>
    1072:	08 95       	ret

00001074 <tinyTime_now>:
/*
This function is callable by external libraries to give them the counted time so far.
*/
uint32_t tinyTime_now(void)
{
	return time_counter;
    1074:	60 91 53 38 	lds	r22, 0x3853	; 0x803853 <time_counter>
    1078:	70 91 54 38 	lds	r23, 0x3854	; 0x803854 <time_counter+0x1>
    107c:	80 91 55 38 	lds	r24, 0x3855	; 0x803855 <time_counter+0x2>
    1080:	90 91 56 38 	lds	r25, 0x3856	; 0x803856 <time_counter+0x3>
    1084:	08 95       	ret

00001086 <__subsf3>:
    1086:	50 58       	subi	r21, 0x80	; 128

00001088 <__addsf3>:
    1088:	bb 27       	eor	r27, r27
    108a:	aa 27       	eor	r26, r26
    108c:	0e 94 5b 08 	call	0x10b6	; 0x10b6 <__addsf3x>
    1090:	0c 94 4e 0a 	jmp	0x149c	; 0x149c <__fp_round>
    1094:	0e 94 40 0a 	call	0x1480	; 0x1480 <__fp_pscA>
    1098:	38 f0       	brcs	.+14     	; 0x10a8 <__addsf3+0x20>
    109a:	0e 94 47 0a 	call	0x148e	; 0x148e <__fp_pscB>
    109e:	20 f0       	brcs	.+8      	; 0x10a8 <__addsf3+0x20>
    10a0:	39 f4       	brne	.+14     	; 0x10b0 <__addsf3+0x28>
    10a2:	9f 3f       	cpi	r25, 0xFF	; 255
    10a4:	19 f4       	brne	.+6      	; 0x10ac <__addsf3+0x24>
    10a6:	26 f4       	brtc	.+8      	; 0x10b0 <__addsf3+0x28>
    10a8:	0c 94 16 0a 	jmp	0x142c	; 0x142c <__fp_nan>
    10ac:	0e f4       	brtc	.+2      	; 0x10b0 <__addsf3+0x28>
    10ae:	e0 95       	com	r30
    10b0:	e7 fb       	bst	r30, 7
    10b2:	0c 94 10 0a 	jmp	0x1420	; 0x1420 <__fp_inf>

000010b6 <__addsf3x>:
    10b6:	e9 2f       	mov	r30, r25
    10b8:	0e 94 5f 0a 	call	0x14be	; 0x14be <__fp_split3>
    10bc:	58 f3       	brcs	.-42     	; 0x1094 <__addsf3+0xc>
    10be:	ba 17       	cp	r27, r26
    10c0:	62 07       	cpc	r22, r18
    10c2:	73 07       	cpc	r23, r19
    10c4:	84 07       	cpc	r24, r20
    10c6:	95 07       	cpc	r25, r21
    10c8:	20 f0       	brcs	.+8      	; 0x10d2 <__addsf3x+0x1c>
    10ca:	79 f4       	brne	.+30     	; 0x10ea <__addsf3x+0x34>
    10cc:	a6 f5       	brtc	.+104    	; 0x1136 <__addsf3x+0x80>
    10ce:	0c 94 81 0a 	jmp	0x1502	; 0x1502 <__fp_zero>
    10d2:	0e f4       	brtc	.+2      	; 0x10d6 <__addsf3x+0x20>
    10d4:	e0 95       	com	r30
    10d6:	0b 2e       	mov	r0, r27
    10d8:	ba 2f       	mov	r27, r26
    10da:	a0 2d       	mov	r26, r0
    10dc:	0b 01       	movw	r0, r22
    10de:	b9 01       	movw	r22, r18
    10e0:	90 01       	movw	r18, r0
    10e2:	0c 01       	movw	r0, r24
    10e4:	ca 01       	movw	r24, r20
    10e6:	a0 01       	movw	r20, r0
    10e8:	11 24       	eor	r1, r1
    10ea:	ff 27       	eor	r31, r31
    10ec:	59 1b       	sub	r21, r25
    10ee:	99 f0       	breq	.+38     	; 0x1116 <__addsf3x+0x60>
    10f0:	59 3f       	cpi	r21, 0xF9	; 249
    10f2:	50 f4       	brcc	.+20     	; 0x1108 <__addsf3x+0x52>
    10f4:	50 3e       	cpi	r21, 0xE0	; 224
    10f6:	68 f1       	brcs	.+90     	; 0x1152 <__addsf3x+0x9c>
    10f8:	1a 16       	cp	r1, r26
    10fa:	f0 40       	sbci	r31, 0x00	; 0
    10fc:	a2 2f       	mov	r26, r18
    10fe:	23 2f       	mov	r18, r19
    1100:	34 2f       	mov	r19, r20
    1102:	44 27       	eor	r20, r20
    1104:	58 5f       	subi	r21, 0xF8	; 248
    1106:	f3 cf       	rjmp	.-26     	; 0x10ee <__addsf3x+0x38>
    1108:	46 95       	lsr	r20
    110a:	37 95       	ror	r19
    110c:	27 95       	ror	r18
    110e:	a7 95       	ror	r26
    1110:	f0 40       	sbci	r31, 0x00	; 0
    1112:	53 95       	inc	r21
    1114:	c9 f7       	brne	.-14     	; 0x1108 <__addsf3x+0x52>
    1116:	7e f4       	brtc	.+30     	; 0x1136 <__addsf3x+0x80>
    1118:	1f 16       	cp	r1, r31
    111a:	ba 0b       	sbc	r27, r26
    111c:	62 0b       	sbc	r22, r18
    111e:	73 0b       	sbc	r23, r19
    1120:	84 0b       	sbc	r24, r20
    1122:	ba f0       	brmi	.+46     	; 0x1152 <__addsf3x+0x9c>
    1124:	91 50       	subi	r25, 0x01	; 1
    1126:	a1 f0       	breq	.+40     	; 0x1150 <__addsf3x+0x9a>
    1128:	ff 0f       	add	r31, r31
    112a:	bb 1f       	adc	r27, r27
    112c:	66 1f       	adc	r22, r22
    112e:	77 1f       	adc	r23, r23
    1130:	88 1f       	adc	r24, r24
    1132:	c2 f7       	brpl	.-16     	; 0x1124 <__addsf3x+0x6e>
    1134:	0e c0       	rjmp	.+28     	; 0x1152 <__addsf3x+0x9c>
    1136:	ba 0f       	add	r27, r26
    1138:	62 1f       	adc	r22, r18
    113a:	73 1f       	adc	r23, r19
    113c:	84 1f       	adc	r24, r20
    113e:	48 f4       	brcc	.+18     	; 0x1152 <__addsf3x+0x9c>
    1140:	87 95       	ror	r24
    1142:	77 95       	ror	r23
    1144:	67 95       	ror	r22
    1146:	b7 95       	ror	r27
    1148:	f7 95       	ror	r31
    114a:	9e 3f       	cpi	r25, 0xFE	; 254
    114c:	08 f0       	brcs	.+2      	; 0x1150 <__addsf3x+0x9a>
    114e:	b0 cf       	rjmp	.-160    	; 0x10b0 <__addsf3+0x28>
    1150:	93 95       	inc	r25
    1152:	88 0f       	add	r24, r24
    1154:	08 f0       	brcs	.+2      	; 0x1158 <__addsf3x+0xa2>
    1156:	99 27       	eor	r25, r25
    1158:	ee 0f       	add	r30, r30
    115a:	97 95       	ror	r25
    115c:	87 95       	ror	r24
    115e:	08 95       	ret

00001160 <__cmpsf2>:
    1160:	0e 94 ec 09 	call	0x13d8	; 0x13d8 <__fp_cmp>
    1164:	08 f4       	brcc	.+2      	; 0x1168 <__cmpsf2+0x8>
    1166:	81 e0       	ldi	r24, 0x01	; 1
    1168:	08 95       	ret

0000116a <__divsf3>:
    116a:	0e 94 c9 08 	call	0x1192	; 0x1192 <__divsf3x>
    116e:	0c 94 4e 0a 	jmp	0x149c	; 0x149c <__fp_round>
    1172:	0e 94 47 0a 	call	0x148e	; 0x148e <__fp_pscB>
    1176:	58 f0       	brcs	.+22     	; 0x118e <__divsf3+0x24>
    1178:	0e 94 40 0a 	call	0x1480	; 0x1480 <__fp_pscA>
    117c:	40 f0       	brcs	.+16     	; 0x118e <__divsf3+0x24>
    117e:	29 f4       	brne	.+10     	; 0x118a <__divsf3+0x20>
    1180:	5f 3f       	cpi	r21, 0xFF	; 255
    1182:	29 f0       	breq	.+10     	; 0x118e <__divsf3+0x24>
    1184:	0c 94 10 0a 	jmp	0x1420	; 0x1420 <__fp_inf>
    1188:	51 11       	cpse	r21, r1
    118a:	0c 94 82 0a 	jmp	0x1504	; 0x1504 <__fp_szero>
    118e:	0c 94 16 0a 	jmp	0x142c	; 0x142c <__fp_nan>

00001192 <__divsf3x>:
    1192:	0e 94 5f 0a 	call	0x14be	; 0x14be <__fp_split3>
    1196:	68 f3       	brcs	.-38     	; 0x1172 <__divsf3+0x8>

00001198 <__divsf3_pse>:
    1198:	99 23       	and	r25, r25
    119a:	b1 f3       	breq	.-20     	; 0x1188 <__divsf3+0x1e>
    119c:	55 23       	and	r21, r21
    119e:	91 f3       	breq	.-28     	; 0x1184 <__divsf3+0x1a>
    11a0:	95 1b       	sub	r25, r21
    11a2:	55 0b       	sbc	r21, r21
    11a4:	bb 27       	eor	r27, r27
    11a6:	aa 27       	eor	r26, r26
    11a8:	62 17       	cp	r22, r18
    11aa:	73 07       	cpc	r23, r19
    11ac:	84 07       	cpc	r24, r20
    11ae:	38 f0       	brcs	.+14     	; 0x11be <__divsf3_pse+0x26>
    11b0:	9f 5f       	subi	r25, 0xFF	; 255
    11b2:	5f 4f       	sbci	r21, 0xFF	; 255
    11b4:	22 0f       	add	r18, r18
    11b6:	33 1f       	adc	r19, r19
    11b8:	44 1f       	adc	r20, r20
    11ba:	aa 1f       	adc	r26, r26
    11bc:	a9 f3       	breq	.-22     	; 0x11a8 <__divsf3_pse+0x10>
    11be:	35 d0       	rcall	.+106    	; 0x122a <__divsf3_pse+0x92>
    11c0:	0e 2e       	mov	r0, r30
    11c2:	3a f0       	brmi	.+14     	; 0x11d2 <__divsf3_pse+0x3a>
    11c4:	e0 e8       	ldi	r30, 0x80	; 128
    11c6:	32 d0       	rcall	.+100    	; 0x122c <__divsf3_pse+0x94>
    11c8:	91 50       	subi	r25, 0x01	; 1
    11ca:	50 40       	sbci	r21, 0x00	; 0
    11cc:	e6 95       	lsr	r30
    11ce:	00 1c       	adc	r0, r0
    11d0:	ca f7       	brpl	.-14     	; 0x11c4 <__divsf3_pse+0x2c>
    11d2:	2b d0       	rcall	.+86     	; 0x122a <__divsf3_pse+0x92>
    11d4:	fe 2f       	mov	r31, r30
    11d6:	29 d0       	rcall	.+82     	; 0x122a <__divsf3_pse+0x92>
    11d8:	66 0f       	add	r22, r22
    11da:	77 1f       	adc	r23, r23
    11dc:	88 1f       	adc	r24, r24
    11de:	bb 1f       	adc	r27, r27
    11e0:	26 17       	cp	r18, r22
    11e2:	37 07       	cpc	r19, r23
    11e4:	48 07       	cpc	r20, r24
    11e6:	ab 07       	cpc	r26, r27
    11e8:	b0 e8       	ldi	r27, 0x80	; 128
    11ea:	09 f0       	breq	.+2      	; 0x11ee <__divsf3_pse+0x56>
    11ec:	bb 0b       	sbc	r27, r27
    11ee:	80 2d       	mov	r24, r0
    11f0:	bf 01       	movw	r22, r30
    11f2:	ff 27       	eor	r31, r31
    11f4:	93 58       	subi	r25, 0x83	; 131
    11f6:	5f 4f       	sbci	r21, 0xFF	; 255
    11f8:	3a f0       	brmi	.+14     	; 0x1208 <__divsf3_pse+0x70>
    11fa:	9e 3f       	cpi	r25, 0xFE	; 254
    11fc:	51 05       	cpc	r21, r1
    11fe:	78 f0       	brcs	.+30     	; 0x121e <__divsf3_pse+0x86>
    1200:	0c 94 10 0a 	jmp	0x1420	; 0x1420 <__fp_inf>
    1204:	0c 94 82 0a 	jmp	0x1504	; 0x1504 <__fp_szero>
    1208:	5f 3f       	cpi	r21, 0xFF	; 255
    120a:	e4 f3       	brlt	.-8      	; 0x1204 <__divsf3_pse+0x6c>
    120c:	98 3e       	cpi	r25, 0xE8	; 232
    120e:	d4 f3       	brlt	.-12     	; 0x1204 <__divsf3_pse+0x6c>
    1210:	86 95       	lsr	r24
    1212:	77 95       	ror	r23
    1214:	67 95       	ror	r22
    1216:	b7 95       	ror	r27
    1218:	f7 95       	ror	r31
    121a:	9f 5f       	subi	r25, 0xFF	; 255
    121c:	c9 f7       	brne	.-14     	; 0x1210 <__divsf3_pse+0x78>
    121e:	88 0f       	add	r24, r24
    1220:	91 1d       	adc	r25, r1
    1222:	96 95       	lsr	r25
    1224:	87 95       	ror	r24
    1226:	97 f9       	bld	r25, 7
    1228:	08 95       	ret
    122a:	e1 e0       	ldi	r30, 0x01	; 1
    122c:	66 0f       	add	r22, r22
    122e:	77 1f       	adc	r23, r23
    1230:	88 1f       	adc	r24, r24
    1232:	bb 1f       	adc	r27, r27
    1234:	62 17       	cp	r22, r18
    1236:	73 07       	cpc	r23, r19
    1238:	84 07       	cpc	r24, r20
    123a:	ba 07       	cpc	r27, r26
    123c:	20 f0       	brcs	.+8      	; 0x1246 <__divsf3_pse+0xae>
    123e:	62 1b       	sub	r22, r18
    1240:	73 0b       	sbc	r23, r19
    1242:	84 0b       	sbc	r24, r20
    1244:	ba 0b       	sbc	r27, r26
    1246:	ee 1f       	adc	r30, r30
    1248:	88 f7       	brcc	.-30     	; 0x122c <__divsf3_pse+0x94>
    124a:	e0 95       	com	r30
    124c:	08 95       	ret
    124e:	29 f4       	brne	.+10     	; 0x125a <__divsf3_pse+0xc2>
    1250:	16 f0       	brts	.+4      	; 0x1256 <__divsf3_pse+0xbe>
    1252:	0c 94 10 0a 	jmp	0x1420	; 0x1420 <__fp_inf>
    1256:	0c 94 81 0a 	jmp	0x1502	; 0x1502 <__fp_zero>
    125a:	0c 94 16 0a 	jmp	0x142c	; 0x142c <__fp_nan>

0000125e <exp>:
    125e:	0e 94 67 0a 	call	0x14ce	; 0x14ce <__fp_splitA>
    1262:	a8 f3       	brcs	.-22     	; 0x124e <__divsf3_pse+0xb6>
    1264:	96 38       	cpi	r25, 0x86	; 134
    1266:	a0 f7       	brcc	.-24     	; 0x1250 <__divsf3_pse+0xb8>
    1268:	07 f8       	bld	r0, 7
    126a:	0f 92       	push	r0
    126c:	e8 94       	clt
    126e:	2b e3       	ldi	r18, 0x3B	; 59
    1270:	3a ea       	ldi	r19, 0xAA	; 170
    1272:	48 eb       	ldi	r20, 0xB8	; 184
    1274:	5f e7       	ldi	r21, 0x7F	; 127
    1276:	0e 94 19 0b 	call	0x1632	; 0x1632 <__mulsf3_pse>
    127a:	0f 92       	push	r0
    127c:	0f 92       	push	r0
    127e:	0f 92       	push	r0
    1280:	4d b7       	in	r20, 0x3d	; 61
    1282:	5e b7       	in	r21, 0x3e	; 62
    1284:	0f 92       	push	r0
    1286:	0e 94 cf 0a 	call	0x159e	; 0x159e <modf>
    128a:	ec e7       	ldi	r30, 0x7C	; 124
    128c:	f0 e0       	ldi	r31, 0x00	; 0
    128e:	0e 94 19 0a 	call	0x1432	; 0x1432 <__fp_powser>
    1292:	4f 91       	pop	r20
    1294:	5f 91       	pop	r21
    1296:	ef 91       	pop	r30
    1298:	ff 91       	pop	r31
    129a:	e5 95       	asr	r30
    129c:	ee 1f       	adc	r30, r30
    129e:	ff 1f       	adc	r31, r31
    12a0:	49 f0       	breq	.+18     	; 0x12b4 <exp+0x56>
    12a2:	fe 57       	subi	r31, 0x7E	; 126
    12a4:	e0 68       	ori	r30, 0x80	; 128
    12a6:	44 27       	eor	r20, r20
    12a8:	ee 0f       	add	r30, r30
    12aa:	44 1f       	adc	r20, r20
    12ac:	fa 95       	dec	r31
    12ae:	e1 f7       	brne	.-8      	; 0x12a8 <exp+0x4a>
    12b0:	41 95       	neg	r20
    12b2:	55 0b       	sbc	r21, r21
    12b4:	0e 94 99 0a 	call	0x1532	; 0x1532 <ldexp>
    12b8:	0f 90       	pop	r0
    12ba:	07 fe       	sbrs	r0, 7
    12bc:	0c 94 8d 0a 	jmp	0x151a	; 0x151a <inverse>
    12c0:	08 95       	ret

000012c2 <__fixunssfsi>:
    12c2:	0e 94 67 0a 	call	0x14ce	; 0x14ce <__fp_splitA>
    12c6:	88 f0       	brcs	.+34     	; 0x12ea <__fixunssfsi+0x28>
    12c8:	9f 57       	subi	r25, 0x7F	; 127
    12ca:	98 f0       	brcs	.+38     	; 0x12f2 <__fixunssfsi+0x30>
    12cc:	b9 2f       	mov	r27, r25
    12ce:	99 27       	eor	r25, r25
    12d0:	b7 51       	subi	r27, 0x17	; 23
    12d2:	b0 f0       	brcs	.+44     	; 0x1300 <__fixunssfsi+0x3e>
    12d4:	e1 f0       	breq	.+56     	; 0x130e <__fixunssfsi+0x4c>
    12d6:	66 0f       	add	r22, r22
    12d8:	77 1f       	adc	r23, r23
    12da:	88 1f       	adc	r24, r24
    12dc:	99 1f       	adc	r25, r25
    12de:	1a f0       	brmi	.+6      	; 0x12e6 <__fixunssfsi+0x24>
    12e0:	ba 95       	dec	r27
    12e2:	c9 f7       	brne	.-14     	; 0x12d6 <__fixunssfsi+0x14>
    12e4:	14 c0       	rjmp	.+40     	; 0x130e <__fixunssfsi+0x4c>
    12e6:	b1 30       	cpi	r27, 0x01	; 1
    12e8:	91 f0       	breq	.+36     	; 0x130e <__fixunssfsi+0x4c>
    12ea:	0e 94 81 0a 	call	0x1502	; 0x1502 <__fp_zero>
    12ee:	b1 e0       	ldi	r27, 0x01	; 1
    12f0:	08 95       	ret
    12f2:	0c 94 81 0a 	jmp	0x1502	; 0x1502 <__fp_zero>
    12f6:	67 2f       	mov	r22, r23
    12f8:	78 2f       	mov	r23, r24
    12fa:	88 27       	eor	r24, r24
    12fc:	b8 5f       	subi	r27, 0xF8	; 248
    12fe:	39 f0       	breq	.+14     	; 0x130e <__fixunssfsi+0x4c>
    1300:	b9 3f       	cpi	r27, 0xF9	; 249
    1302:	cc f3       	brlt	.-14     	; 0x12f6 <__fixunssfsi+0x34>
    1304:	86 95       	lsr	r24
    1306:	77 95       	ror	r23
    1308:	67 95       	ror	r22
    130a:	b3 95       	inc	r27
    130c:	d9 f7       	brne	.-10     	; 0x1304 <__fixunssfsi+0x42>
    130e:	3e f4       	brtc	.+14     	; 0x131e <__fixunssfsi+0x5c>
    1310:	90 95       	com	r25
    1312:	80 95       	com	r24
    1314:	70 95       	com	r23
    1316:	61 95       	neg	r22
    1318:	7f 4f       	sbci	r23, 0xFF	; 255
    131a:	8f 4f       	sbci	r24, 0xFF	; 255
    131c:	9f 4f       	sbci	r25, 0xFF	; 255
    131e:	08 95       	ret

00001320 <__floatunsisf>:
    1320:	e8 94       	clt
    1322:	09 c0       	rjmp	.+18     	; 0x1336 <__floatsisf+0x12>

00001324 <__floatsisf>:
    1324:	97 fb       	bst	r25, 7
    1326:	3e f4       	brtc	.+14     	; 0x1336 <__floatsisf+0x12>
    1328:	90 95       	com	r25
    132a:	80 95       	com	r24
    132c:	70 95       	com	r23
    132e:	61 95       	neg	r22
    1330:	7f 4f       	sbci	r23, 0xFF	; 255
    1332:	8f 4f       	sbci	r24, 0xFF	; 255
    1334:	9f 4f       	sbci	r25, 0xFF	; 255
    1336:	99 23       	and	r25, r25
    1338:	a9 f0       	breq	.+42     	; 0x1364 <__floatsisf+0x40>
    133a:	f9 2f       	mov	r31, r25
    133c:	96 e9       	ldi	r25, 0x96	; 150
    133e:	bb 27       	eor	r27, r27
    1340:	93 95       	inc	r25
    1342:	f6 95       	lsr	r31
    1344:	87 95       	ror	r24
    1346:	77 95       	ror	r23
    1348:	67 95       	ror	r22
    134a:	b7 95       	ror	r27
    134c:	f1 11       	cpse	r31, r1
    134e:	f8 cf       	rjmp	.-16     	; 0x1340 <__floatsisf+0x1c>
    1350:	fa f4       	brpl	.+62     	; 0x1390 <__floatsisf+0x6c>
    1352:	bb 0f       	add	r27, r27
    1354:	11 f4       	brne	.+4      	; 0x135a <__floatsisf+0x36>
    1356:	60 ff       	sbrs	r22, 0
    1358:	1b c0       	rjmp	.+54     	; 0x1390 <__floatsisf+0x6c>
    135a:	6f 5f       	subi	r22, 0xFF	; 255
    135c:	7f 4f       	sbci	r23, 0xFF	; 255
    135e:	8f 4f       	sbci	r24, 0xFF	; 255
    1360:	9f 4f       	sbci	r25, 0xFF	; 255
    1362:	16 c0       	rjmp	.+44     	; 0x1390 <__floatsisf+0x6c>
    1364:	88 23       	and	r24, r24
    1366:	11 f0       	breq	.+4      	; 0x136c <__floatsisf+0x48>
    1368:	96 e9       	ldi	r25, 0x96	; 150
    136a:	11 c0       	rjmp	.+34     	; 0x138e <__floatsisf+0x6a>
    136c:	77 23       	and	r23, r23
    136e:	21 f0       	breq	.+8      	; 0x1378 <__floatsisf+0x54>
    1370:	9e e8       	ldi	r25, 0x8E	; 142
    1372:	87 2f       	mov	r24, r23
    1374:	76 2f       	mov	r23, r22
    1376:	05 c0       	rjmp	.+10     	; 0x1382 <__floatsisf+0x5e>
    1378:	66 23       	and	r22, r22
    137a:	71 f0       	breq	.+28     	; 0x1398 <__floatsisf+0x74>
    137c:	96 e8       	ldi	r25, 0x86	; 134
    137e:	86 2f       	mov	r24, r22
    1380:	70 e0       	ldi	r23, 0x00	; 0
    1382:	60 e0       	ldi	r22, 0x00	; 0
    1384:	2a f0       	brmi	.+10     	; 0x1390 <__floatsisf+0x6c>
    1386:	9a 95       	dec	r25
    1388:	66 0f       	add	r22, r22
    138a:	77 1f       	adc	r23, r23
    138c:	88 1f       	adc	r24, r24
    138e:	da f7       	brpl	.-10     	; 0x1386 <__floatsisf+0x62>
    1390:	88 0f       	add	r24, r24
    1392:	96 95       	lsr	r25
    1394:	87 95       	ror	r24
    1396:	97 f9       	bld	r25, 7
    1398:	08 95       	ret

0000139a <fmin>:
    139a:	99 0f       	add	r25, r25
    139c:	bb 0b       	sbc	r27, r27
    139e:	55 0f       	add	r21, r21
    13a0:	aa 0b       	sbc	r26, r26
    13a2:	e0 e8       	ldi	r30, 0x80	; 128
    13a4:	fe ef       	ldi	r31, 0xFE	; 254
    13a6:	16 16       	cp	r1, r22
    13a8:	17 06       	cpc	r1, r23
    13aa:	e8 07       	cpc	r30, r24
    13ac:	f9 07       	cpc	r31, r25
    13ae:	70 f0       	brcs	.+28     	; 0x13cc <fmin+0x32>
    13b0:	12 16       	cp	r1, r18
    13b2:	13 06       	cpc	r1, r19
    13b4:	e4 07       	cpc	r30, r20
    13b6:	f5 07       	cpc	r31, r21
    13b8:	60 f0       	brcs	.+24     	; 0x13d2 <fmin+0x38>
    13ba:	ba 17       	cp	r27, r26
    13bc:	54 f0       	brlt	.+20     	; 0x13d2 <fmin+0x38>
    13be:	31 f4       	brne	.+12     	; 0x13cc <fmin+0x32>
    13c0:	26 17       	cp	r18, r22
    13c2:	37 07       	cpc	r19, r23
    13c4:	48 07       	cpc	r20, r24
    13c6:	59 07       	cpc	r21, r25
    13c8:	a7 95       	ror	r26
    13ca:	1b f4       	brvc	.+6      	; 0x13d2 <fmin+0x38>
    13cc:	b9 01       	movw	r22, r18
    13ce:	ca 01       	movw	r24, r20
    13d0:	ba 2f       	mov	r27, r26
    13d2:	b6 95       	lsr	r27
    13d4:	97 95       	ror	r25
    13d6:	08 95       	ret

000013d8 <__fp_cmp>:
    13d8:	99 0f       	add	r25, r25
    13da:	00 08       	sbc	r0, r0
    13dc:	55 0f       	add	r21, r21
    13de:	aa 0b       	sbc	r26, r26
    13e0:	e0 e8       	ldi	r30, 0x80	; 128
    13e2:	fe ef       	ldi	r31, 0xFE	; 254
    13e4:	16 16       	cp	r1, r22
    13e6:	17 06       	cpc	r1, r23
    13e8:	e8 07       	cpc	r30, r24
    13ea:	f9 07       	cpc	r31, r25
    13ec:	c0 f0       	brcs	.+48     	; 0x141e <__fp_cmp+0x46>
    13ee:	12 16       	cp	r1, r18
    13f0:	13 06       	cpc	r1, r19
    13f2:	e4 07       	cpc	r30, r20
    13f4:	f5 07       	cpc	r31, r21
    13f6:	98 f0       	brcs	.+38     	; 0x141e <__fp_cmp+0x46>
    13f8:	62 1b       	sub	r22, r18
    13fa:	73 0b       	sbc	r23, r19
    13fc:	84 0b       	sbc	r24, r20
    13fe:	95 0b       	sbc	r25, r21
    1400:	39 f4       	brne	.+14     	; 0x1410 <__fp_cmp+0x38>
    1402:	0a 26       	eor	r0, r26
    1404:	61 f0       	breq	.+24     	; 0x141e <__fp_cmp+0x46>
    1406:	23 2b       	or	r18, r19
    1408:	24 2b       	or	r18, r20
    140a:	25 2b       	or	r18, r21
    140c:	21 f4       	brne	.+8      	; 0x1416 <__fp_cmp+0x3e>
    140e:	08 95       	ret
    1410:	0a 26       	eor	r0, r26
    1412:	09 f4       	brne	.+2      	; 0x1416 <__fp_cmp+0x3e>
    1414:	a1 40       	sbci	r26, 0x01	; 1
    1416:	a6 95       	lsr	r26
    1418:	8f ef       	ldi	r24, 0xFF	; 255
    141a:	81 1d       	adc	r24, r1
    141c:	81 1d       	adc	r24, r1
    141e:	08 95       	ret

00001420 <__fp_inf>:
    1420:	97 f9       	bld	r25, 7
    1422:	9f 67       	ori	r25, 0x7F	; 127
    1424:	80 e8       	ldi	r24, 0x80	; 128
    1426:	70 e0       	ldi	r23, 0x00	; 0
    1428:	60 e0       	ldi	r22, 0x00	; 0
    142a:	08 95       	ret

0000142c <__fp_nan>:
    142c:	9f ef       	ldi	r25, 0xFF	; 255
    142e:	80 ec       	ldi	r24, 0xC0	; 192
    1430:	08 95       	ret

00001432 <__fp_powser>:
    1432:	df 93       	push	r29
    1434:	cf 93       	push	r28
    1436:	1f 93       	push	r17
    1438:	0f 93       	push	r16
    143a:	ff 92       	push	r15
    143c:	ef 92       	push	r14
    143e:	df 92       	push	r13
    1440:	7b 01       	movw	r14, r22
    1442:	8c 01       	movw	r16, r24
    1444:	68 94       	set
    1446:	06 c0       	rjmp	.+12     	; 0x1454 <__fp_powser+0x22>
    1448:	da 2e       	mov	r13, r26
    144a:	ef 01       	movw	r28, r30
    144c:	0e 94 16 0b 	call	0x162c	; 0x162c <__mulsf3x>
    1450:	fe 01       	movw	r30, r28
    1452:	e8 94       	clt
    1454:	a5 91       	lpm	r26, Z+
    1456:	25 91       	lpm	r18, Z+
    1458:	35 91       	lpm	r19, Z+
    145a:	45 91       	lpm	r20, Z+
    145c:	55 91       	lpm	r21, Z+
    145e:	a6 f3       	brts	.-24     	; 0x1448 <__fp_powser+0x16>
    1460:	ef 01       	movw	r28, r30
    1462:	0e 94 5b 08 	call	0x10b6	; 0x10b6 <__addsf3x>
    1466:	fe 01       	movw	r30, r28
    1468:	97 01       	movw	r18, r14
    146a:	a8 01       	movw	r20, r16
    146c:	da 94       	dec	r13
    146e:	69 f7       	brne	.-38     	; 0x144a <__fp_powser+0x18>
    1470:	df 90       	pop	r13
    1472:	ef 90       	pop	r14
    1474:	ff 90       	pop	r15
    1476:	0f 91       	pop	r16
    1478:	1f 91       	pop	r17
    147a:	cf 91       	pop	r28
    147c:	df 91       	pop	r29
    147e:	08 95       	ret

00001480 <__fp_pscA>:
    1480:	00 24       	eor	r0, r0
    1482:	0a 94       	dec	r0
    1484:	16 16       	cp	r1, r22
    1486:	17 06       	cpc	r1, r23
    1488:	18 06       	cpc	r1, r24
    148a:	09 06       	cpc	r0, r25
    148c:	08 95       	ret

0000148e <__fp_pscB>:
    148e:	00 24       	eor	r0, r0
    1490:	0a 94       	dec	r0
    1492:	12 16       	cp	r1, r18
    1494:	13 06       	cpc	r1, r19
    1496:	14 06       	cpc	r1, r20
    1498:	05 06       	cpc	r0, r21
    149a:	08 95       	ret

0000149c <__fp_round>:
    149c:	09 2e       	mov	r0, r25
    149e:	03 94       	inc	r0
    14a0:	00 0c       	add	r0, r0
    14a2:	11 f4       	brne	.+4      	; 0x14a8 <__fp_round+0xc>
    14a4:	88 23       	and	r24, r24
    14a6:	52 f0       	brmi	.+20     	; 0x14bc <__fp_round+0x20>
    14a8:	bb 0f       	add	r27, r27
    14aa:	40 f4       	brcc	.+16     	; 0x14bc <__fp_round+0x20>
    14ac:	bf 2b       	or	r27, r31
    14ae:	11 f4       	brne	.+4      	; 0x14b4 <__fp_round+0x18>
    14b0:	60 ff       	sbrs	r22, 0
    14b2:	04 c0       	rjmp	.+8      	; 0x14bc <__fp_round+0x20>
    14b4:	6f 5f       	subi	r22, 0xFF	; 255
    14b6:	7f 4f       	sbci	r23, 0xFF	; 255
    14b8:	8f 4f       	sbci	r24, 0xFF	; 255
    14ba:	9f 4f       	sbci	r25, 0xFF	; 255
    14bc:	08 95       	ret

000014be <__fp_split3>:
    14be:	57 fd       	sbrc	r21, 7
    14c0:	90 58       	subi	r25, 0x80	; 128
    14c2:	44 0f       	add	r20, r20
    14c4:	55 1f       	adc	r21, r21
    14c6:	59 f0       	breq	.+22     	; 0x14de <__fp_splitA+0x10>
    14c8:	5f 3f       	cpi	r21, 0xFF	; 255
    14ca:	71 f0       	breq	.+28     	; 0x14e8 <__fp_splitA+0x1a>
    14cc:	47 95       	ror	r20

000014ce <__fp_splitA>:
    14ce:	88 0f       	add	r24, r24
    14d0:	97 fb       	bst	r25, 7
    14d2:	99 1f       	adc	r25, r25
    14d4:	61 f0       	breq	.+24     	; 0x14ee <__fp_splitA+0x20>
    14d6:	9f 3f       	cpi	r25, 0xFF	; 255
    14d8:	79 f0       	breq	.+30     	; 0x14f8 <__fp_splitA+0x2a>
    14da:	87 95       	ror	r24
    14dc:	08 95       	ret
    14de:	12 16       	cp	r1, r18
    14e0:	13 06       	cpc	r1, r19
    14e2:	14 06       	cpc	r1, r20
    14e4:	55 1f       	adc	r21, r21
    14e6:	f2 cf       	rjmp	.-28     	; 0x14cc <__fp_split3+0xe>
    14e8:	46 95       	lsr	r20
    14ea:	f1 df       	rcall	.-30     	; 0x14ce <__fp_splitA>
    14ec:	08 c0       	rjmp	.+16     	; 0x14fe <__fp_splitA+0x30>
    14ee:	16 16       	cp	r1, r22
    14f0:	17 06       	cpc	r1, r23
    14f2:	18 06       	cpc	r1, r24
    14f4:	99 1f       	adc	r25, r25
    14f6:	f1 cf       	rjmp	.-30     	; 0x14da <__fp_splitA+0xc>
    14f8:	86 95       	lsr	r24
    14fa:	71 05       	cpc	r23, r1
    14fc:	61 05       	cpc	r22, r1
    14fe:	08 94       	sec
    1500:	08 95       	ret

00001502 <__fp_zero>:
    1502:	e8 94       	clt

00001504 <__fp_szero>:
    1504:	bb 27       	eor	r27, r27
    1506:	66 27       	eor	r22, r22
    1508:	77 27       	eor	r23, r23
    150a:	cb 01       	movw	r24, r22
    150c:	97 f9       	bld	r25, 7
    150e:	08 95       	ret

00001510 <__gesf2>:
    1510:	0e 94 ec 09 	call	0x13d8	; 0x13d8 <__fp_cmp>
    1514:	08 f4       	brcc	.+2      	; 0x1518 <__gesf2+0x8>
    1516:	8f ef       	ldi	r24, 0xFF	; 255
    1518:	08 95       	ret

0000151a <inverse>:
    151a:	9b 01       	movw	r18, r22
    151c:	ac 01       	movw	r20, r24
    151e:	60 e0       	ldi	r22, 0x00	; 0
    1520:	70 e0       	ldi	r23, 0x00	; 0
    1522:	80 e8       	ldi	r24, 0x80	; 128
    1524:	9f e3       	ldi	r25, 0x3F	; 63
    1526:	0c 94 b5 08 	jmp	0x116a	; 0x116a <__divsf3>
    152a:	0c 94 10 0a 	jmp	0x1420	; 0x1420 <__fp_inf>
    152e:	0c 94 78 0b 	jmp	0x16f0	; 0x16f0 <__fp_mpack>

00001532 <ldexp>:
    1532:	0e 94 67 0a 	call	0x14ce	; 0x14ce <__fp_splitA>
    1536:	d8 f3       	brcs	.-10     	; 0x152e <inverse+0x14>
    1538:	99 23       	and	r25, r25
    153a:	c9 f3       	breq	.-14     	; 0x152e <inverse+0x14>
    153c:	94 0f       	add	r25, r20
    153e:	51 1d       	adc	r21, r1
    1540:	a3 f3       	brvs	.-24     	; 0x152a <inverse+0x10>
    1542:	91 50       	subi	r25, 0x01	; 1
    1544:	50 40       	sbci	r21, 0x00	; 0
    1546:	94 f0       	brlt	.+36     	; 0x156c <ldexp+0x3a>
    1548:	59 f0       	breq	.+22     	; 0x1560 <ldexp+0x2e>
    154a:	88 23       	and	r24, r24
    154c:	32 f0       	brmi	.+12     	; 0x155a <ldexp+0x28>
    154e:	66 0f       	add	r22, r22
    1550:	77 1f       	adc	r23, r23
    1552:	88 1f       	adc	r24, r24
    1554:	91 50       	subi	r25, 0x01	; 1
    1556:	50 40       	sbci	r21, 0x00	; 0
    1558:	c1 f7       	brne	.-16     	; 0x154a <ldexp+0x18>
    155a:	9e 3f       	cpi	r25, 0xFE	; 254
    155c:	51 05       	cpc	r21, r1
    155e:	2c f7       	brge	.-54     	; 0x152a <inverse+0x10>
    1560:	88 0f       	add	r24, r24
    1562:	91 1d       	adc	r25, r1
    1564:	96 95       	lsr	r25
    1566:	87 95       	ror	r24
    1568:	97 f9       	bld	r25, 7
    156a:	08 95       	ret
    156c:	5f 3f       	cpi	r21, 0xFF	; 255
    156e:	ac f0       	brlt	.+42     	; 0x159a <ldexp+0x68>
    1570:	98 3e       	cpi	r25, 0xE8	; 232
    1572:	9c f0       	brlt	.+38     	; 0x159a <ldexp+0x68>
    1574:	bb 27       	eor	r27, r27
    1576:	86 95       	lsr	r24
    1578:	77 95       	ror	r23
    157a:	67 95       	ror	r22
    157c:	b7 95       	ror	r27
    157e:	08 f4       	brcc	.+2      	; 0x1582 <ldexp+0x50>
    1580:	b1 60       	ori	r27, 0x01	; 1
    1582:	93 95       	inc	r25
    1584:	c1 f7       	brne	.-16     	; 0x1576 <ldexp+0x44>
    1586:	bb 0f       	add	r27, r27
    1588:	58 f7       	brcc	.-42     	; 0x1560 <ldexp+0x2e>
    158a:	11 f4       	brne	.+4      	; 0x1590 <ldexp+0x5e>
    158c:	60 ff       	sbrs	r22, 0
    158e:	e8 cf       	rjmp	.-48     	; 0x1560 <ldexp+0x2e>
    1590:	6f 5f       	subi	r22, 0xFF	; 255
    1592:	7f 4f       	sbci	r23, 0xFF	; 255
    1594:	8f 4f       	sbci	r24, 0xFF	; 255
    1596:	9f 4f       	sbci	r25, 0xFF	; 255
    1598:	e3 cf       	rjmp	.-58     	; 0x1560 <ldexp+0x2e>
    159a:	0c 94 82 0a 	jmp	0x1504	; 0x1504 <__fp_szero>

0000159e <modf>:
    159e:	fa 01       	movw	r30, r20
    15a0:	dc 01       	movw	r26, r24
    15a2:	aa 0f       	add	r26, r26
    15a4:	bb 1f       	adc	r27, r27
    15a6:	9b 01       	movw	r18, r22
    15a8:	ac 01       	movw	r20, r24
    15aa:	bf 57       	subi	r27, 0x7F	; 127
    15ac:	28 f4       	brcc	.+10     	; 0x15b8 <modf+0x1a>
    15ae:	22 27       	eor	r18, r18
    15b0:	33 27       	eor	r19, r19
    15b2:	44 27       	eor	r20, r20
    15b4:	50 78       	andi	r21, 0x80	; 128
    15b6:	20 c0       	rjmp	.+64     	; 0x15f8 <modf+0x5a>
    15b8:	b7 51       	subi	r27, 0x17	; 23
    15ba:	90 f4       	brcc	.+36     	; 0x15e0 <modf+0x42>
    15bc:	ab 2f       	mov	r26, r27
    15be:	00 24       	eor	r0, r0
    15c0:	46 95       	lsr	r20
    15c2:	37 95       	ror	r19
    15c4:	27 95       	ror	r18
    15c6:	01 1c       	adc	r0, r1
    15c8:	a3 95       	inc	r26
    15ca:	d2 f3       	brmi	.-12     	; 0x15c0 <modf+0x22>
    15cc:	00 20       	and	r0, r0
    15ce:	71 f0       	breq	.+28     	; 0x15ec <modf+0x4e>
    15d0:	22 0f       	add	r18, r18
    15d2:	33 1f       	adc	r19, r19
    15d4:	44 1f       	adc	r20, r20
    15d6:	b3 95       	inc	r27
    15d8:	da f3       	brmi	.-10     	; 0x15d0 <modf+0x32>
    15da:	0e d0       	rcall	.+28     	; 0x15f8 <modf+0x5a>
    15dc:	0c 94 43 08 	jmp	0x1086	; 0x1086 <__subsf3>
    15e0:	61 30       	cpi	r22, 0x01	; 1
    15e2:	71 05       	cpc	r23, r1
    15e4:	a0 e8       	ldi	r26, 0x80	; 128
    15e6:	8a 07       	cpc	r24, r26
    15e8:	b9 46       	sbci	r27, 0x69	; 105
    15ea:	30 f4       	brcc	.+12     	; 0x15f8 <modf+0x5a>
    15ec:	9b 01       	movw	r18, r22
    15ee:	ac 01       	movw	r20, r24
    15f0:	66 27       	eor	r22, r22
    15f2:	77 27       	eor	r23, r23
    15f4:	88 27       	eor	r24, r24
    15f6:	90 78       	andi	r25, 0x80	; 128
    15f8:	30 96       	adiw	r30, 0x00	; 0
    15fa:	21 f0       	breq	.+8      	; 0x1604 <modf+0x66>
    15fc:	20 83       	st	Z, r18
    15fe:	31 83       	std	Z+1, r19	; 0x01
    1600:	42 83       	std	Z+2, r20	; 0x02
    1602:	53 83       	std	Z+3, r21	; 0x03
    1604:	08 95       	ret

00001606 <__mulsf3>:
    1606:	0e 94 16 0b 	call	0x162c	; 0x162c <__mulsf3x>
    160a:	0c 94 4e 0a 	jmp	0x149c	; 0x149c <__fp_round>
    160e:	0e 94 40 0a 	call	0x1480	; 0x1480 <__fp_pscA>
    1612:	38 f0       	brcs	.+14     	; 0x1622 <__mulsf3+0x1c>
    1614:	0e 94 47 0a 	call	0x148e	; 0x148e <__fp_pscB>
    1618:	20 f0       	brcs	.+8      	; 0x1622 <__mulsf3+0x1c>
    161a:	95 23       	and	r25, r21
    161c:	11 f0       	breq	.+4      	; 0x1622 <__mulsf3+0x1c>
    161e:	0c 94 10 0a 	jmp	0x1420	; 0x1420 <__fp_inf>
    1622:	0c 94 16 0a 	jmp	0x142c	; 0x142c <__fp_nan>
    1626:	11 24       	eor	r1, r1
    1628:	0c 94 82 0a 	jmp	0x1504	; 0x1504 <__fp_szero>

0000162c <__mulsf3x>:
    162c:	0e 94 5f 0a 	call	0x14be	; 0x14be <__fp_split3>
    1630:	70 f3       	brcs	.-36     	; 0x160e <__mulsf3+0x8>

00001632 <__mulsf3_pse>:
    1632:	95 9f       	mul	r25, r21
    1634:	c1 f3       	breq	.-16     	; 0x1626 <__mulsf3+0x20>
    1636:	95 0f       	add	r25, r21
    1638:	50 e0       	ldi	r21, 0x00	; 0
    163a:	55 1f       	adc	r21, r21
    163c:	62 9f       	mul	r22, r18
    163e:	f0 01       	movw	r30, r0
    1640:	72 9f       	mul	r23, r18
    1642:	bb 27       	eor	r27, r27
    1644:	f0 0d       	add	r31, r0
    1646:	b1 1d       	adc	r27, r1
    1648:	63 9f       	mul	r22, r19
    164a:	aa 27       	eor	r26, r26
    164c:	f0 0d       	add	r31, r0
    164e:	b1 1d       	adc	r27, r1
    1650:	aa 1f       	adc	r26, r26
    1652:	64 9f       	mul	r22, r20
    1654:	66 27       	eor	r22, r22
    1656:	b0 0d       	add	r27, r0
    1658:	a1 1d       	adc	r26, r1
    165a:	66 1f       	adc	r22, r22
    165c:	82 9f       	mul	r24, r18
    165e:	22 27       	eor	r18, r18
    1660:	b0 0d       	add	r27, r0
    1662:	a1 1d       	adc	r26, r1
    1664:	62 1f       	adc	r22, r18
    1666:	73 9f       	mul	r23, r19
    1668:	b0 0d       	add	r27, r0
    166a:	a1 1d       	adc	r26, r1
    166c:	62 1f       	adc	r22, r18
    166e:	83 9f       	mul	r24, r19
    1670:	a0 0d       	add	r26, r0
    1672:	61 1d       	adc	r22, r1
    1674:	22 1f       	adc	r18, r18
    1676:	74 9f       	mul	r23, r20
    1678:	33 27       	eor	r19, r19
    167a:	a0 0d       	add	r26, r0
    167c:	61 1d       	adc	r22, r1
    167e:	23 1f       	adc	r18, r19
    1680:	84 9f       	mul	r24, r20
    1682:	60 0d       	add	r22, r0
    1684:	21 1d       	adc	r18, r1
    1686:	82 2f       	mov	r24, r18
    1688:	76 2f       	mov	r23, r22
    168a:	6a 2f       	mov	r22, r26
    168c:	11 24       	eor	r1, r1
    168e:	9f 57       	subi	r25, 0x7F	; 127
    1690:	50 40       	sbci	r21, 0x00	; 0
    1692:	9a f0       	brmi	.+38     	; 0x16ba <__mulsf3_pse+0x88>
    1694:	f1 f0       	breq	.+60     	; 0x16d2 <__mulsf3_pse+0xa0>
    1696:	88 23       	and	r24, r24
    1698:	4a f0       	brmi	.+18     	; 0x16ac <__mulsf3_pse+0x7a>
    169a:	ee 0f       	add	r30, r30
    169c:	ff 1f       	adc	r31, r31
    169e:	bb 1f       	adc	r27, r27
    16a0:	66 1f       	adc	r22, r22
    16a2:	77 1f       	adc	r23, r23
    16a4:	88 1f       	adc	r24, r24
    16a6:	91 50       	subi	r25, 0x01	; 1
    16a8:	50 40       	sbci	r21, 0x00	; 0
    16aa:	a9 f7       	brne	.-22     	; 0x1696 <__mulsf3_pse+0x64>
    16ac:	9e 3f       	cpi	r25, 0xFE	; 254
    16ae:	51 05       	cpc	r21, r1
    16b0:	80 f0       	brcs	.+32     	; 0x16d2 <__mulsf3_pse+0xa0>
    16b2:	0c 94 10 0a 	jmp	0x1420	; 0x1420 <__fp_inf>
    16b6:	0c 94 82 0a 	jmp	0x1504	; 0x1504 <__fp_szero>
    16ba:	5f 3f       	cpi	r21, 0xFF	; 255
    16bc:	e4 f3       	brlt	.-8      	; 0x16b6 <__mulsf3_pse+0x84>
    16be:	98 3e       	cpi	r25, 0xE8	; 232
    16c0:	d4 f3       	brlt	.-12     	; 0x16b6 <__mulsf3_pse+0x84>
    16c2:	86 95       	lsr	r24
    16c4:	77 95       	ror	r23
    16c6:	67 95       	ror	r22
    16c8:	b7 95       	ror	r27
    16ca:	f7 95       	ror	r31
    16cc:	e7 95       	ror	r30
    16ce:	9f 5f       	subi	r25, 0xFF	; 255
    16d0:	c1 f7       	brne	.-16     	; 0x16c2 <__mulsf3_pse+0x90>
    16d2:	fe 2b       	or	r31, r30
    16d4:	88 0f       	add	r24, r24
    16d6:	91 1d       	adc	r25, r1
    16d8:	96 95       	lsr	r25
    16da:	87 95       	ror	r24
    16dc:	97 f9       	bld	r25, 7
    16de:	08 95       	ret

000016e0 <sin>:
    16e0:	9f 93       	push	r25
    16e2:	0e 94 88 0b 	call	0x1710	; 0x1710 <__fp_rempio2>
    16e6:	0f 90       	pop	r0
    16e8:	07 fc       	sbrc	r0, 7
    16ea:	ee 5f       	subi	r30, 0xFE	; 254
    16ec:	0c 94 b1 0b 	jmp	0x1762	; 0x1762 <__fp_sinus>

000016f0 <__fp_mpack>:
    16f0:	9f 3f       	cpi	r25, 0xFF	; 255
    16f2:	31 f0       	breq	.+12     	; 0x1700 <__fp_mpack_finite+0xc>

000016f4 <__fp_mpack_finite>:
    16f4:	91 50       	subi	r25, 0x01	; 1
    16f6:	20 f4       	brcc	.+8      	; 0x1700 <__fp_mpack_finite+0xc>
    16f8:	87 95       	ror	r24
    16fa:	77 95       	ror	r23
    16fc:	67 95       	ror	r22
    16fe:	b7 95       	ror	r27
    1700:	88 0f       	add	r24, r24
    1702:	91 1d       	adc	r25, r1
    1704:	96 95       	lsr	r25
    1706:	87 95       	ror	r24
    1708:	97 f9       	bld	r25, 7
    170a:	08 95       	ret
    170c:	0c 94 16 0a 	jmp	0x142c	; 0x142c <__fp_nan>

00001710 <__fp_rempio2>:
    1710:	0e 94 67 0a 	call	0x14ce	; 0x14ce <__fp_splitA>
    1714:	d8 f3       	brcs	.-10     	; 0x170c <__fp_mpack_finite+0x18>
    1716:	e8 94       	clt
    1718:	e0 e0       	ldi	r30, 0x00	; 0
    171a:	bb 27       	eor	r27, r27
    171c:	9f 57       	subi	r25, 0x7F	; 127
    171e:	f0 f0       	brcs	.+60     	; 0x175c <__fp_rempio2+0x4c>
    1720:	2a ed       	ldi	r18, 0xDA	; 218
    1722:	3f e0       	ldi	r19, 0x0F	; 15
    1724:	49 ec       	ldi	r20, 0xC9	; 201
    1726:	06 c0       	rjmp	.+12     	; 0x1734 <__fp_rempio2+0x24>
    1728:	ee 0f       	add	r30, r30
    172a:	bb 0f       	add	r27, r27
    172c:	66 1f       	adc	r22, r22
    172e:	77 1f       	adc	r23, r23
    1730:	88 1f       	adc	r24, r24
    1732:	28 f0       	brcs	.+10     	; 0x173e <__fp_rempio2+0x2e>
    1734:	b2 3a       	cpi	r27, 0xA2	; 162
    1736:	62 07       	cpc	r22, r18
    1738:	73 07       	cpc	r23, r19
    173a:	84 07       	cpc	r24, r20
    173c:	28 f0       	brcs	.+10     	; 0x1748 <__fp_rempio2+0x38>
    173e:	b2 5a       	subi	r27, 0xA2	; 162
    1740:	62 0b       	sbc	r22, r18
    1742:	73 0b       	sbc	r23, r19
    1744:	84 0b       	sbc	r24, r20
    1746:	e3 95       	inc	r30
    1748:	9a 95       	dec	r25
    174a:	72 f7       	brpl	.-36     	; 0x1728 <__fp_rempio2+0x18>
    174c:	80 38       	cpi	r24, 0x80	; 128
    174e:	30 f4       	brcc	.+12     	; 0x175c <__fp_rempio2+0x4c>
    1750:	9a 95       	dec	r25
    1752:	bb 0f       	add	r27, r27
    1754:	66 1f       	adc	r22, r22
    1756:	77 1f       	adc	r23, r23
    1758:	88 1f       	adc	r24, r24
    175a:	d2 f7       	brpl	.-12     	; 0x1750 <__fp_rempio2+0x40>
    175c:	90 48       	sbci	r25, 0x80	; 128
    175e:	0c 94 7a 0b 	jmp	0x16f4	; 0x16f4 <__fp_mpack_finite>

00001762 <__fp_sinus>:
    1762:	ef 93       	push	r30
    1764:	e0 ff       	sbrs	r30, 0
    1766:	07 c0       	rjmp	.+14     	; 0x1776 <__fp_sinus+0x14>
    1768:	a2 ea       	ldi	r26, 0xA2	; 162
    176a:	2a ed       	ldi	r18, 0xDA	; 218
    176c:	3f e0       	ldi	r19, 0x0F	; 15
    176e:	49 ec       	ldi	r20, 0xC9	; 201
    1770:	5f eb       	ldi	r21, 0xBF	; 191
    1772:	0e 94 5b 08 	call	0x10b6	; 0x10b6 <__addsf3x>
    1776:	0e 94 4e 0a 	call	0x149c	; 0x149c <__fp_round>
    177a:	0f 90       	pop	r0
    177c:	03 94       	inc	r0
    177e:	01 fc       	sbrc	r0, 1
    1780:	90 58       	subi	r25, 0x80	; 128
    1782:	e4 ea       	ldi	r30, 0xA4	; 164
    1784:	f0 e0       	ldi	r31, 0x00	; 0
    1786:	0c 94 c5 0b 	jmp	0x178a	; 0x178a <__fp_powsodd>

0000178a <__fp_powsodd>:
    178a:	9f 93       	push	r25
    178c:	8f 93       	push	r24
    178e:	7f 93       	push	r23
    1790:	6f 93       	push	r22
    1792:	ff 93       	push	r31
    1794:	ef 93       	push	r30
    1796:	9b 01       	movw	r18, r22
    1798:	ac 01       	movw	r20, r24
    179a:	0e 94 03 0b 	call	0x1606	; 0x1606 <__mulsf3>
    179e:	ef 91       	pop	r30
    17a0:	ff 91       	pop	r31
    17a2:	0e 94 19 0a 	call	0x1432	; 0x1432 <__fp_powser>
    17a6:	2f 91       	pop	r18
    17a8:	3f 91       	pop	r19
    17aa:	4f 91       	pop	r20
    17ac:	5f 91       	pop	r21
    17ae:	0c 94 03 0b 	jmp	0x1606	; 0x1606 <__mulsf3>

000017b2 <__udivmodsi4>:
    17b2:	a1 e2       	ldi	r26, 0x21	; 33
    17b4:	1a 2e       	mov	r1, r26
    17b6:	aa 1b       	sub	r26, r26
    17b8:	bb 1b       	sub	r27, r27
    17ba:	fd 01       	movw	r30, r26
    17bc:	0d c0       	rjmp	.+26     	; 0x17d8 <__udivmodsi4_ep>

000017be <__udivmodsi4_loop>:
    17be:	aa 1f       	adc	r26, r26
    17c0:	bb 1f       	adc	r27, r27
    17c2:	ee 1f       	adc	r30, r30
    17c4:	ff 1f       	adc	r31, r31
    17c6:	a2 17       	cp	r26, r18
    17c8:	b3 07       	cpc	r27, r19
    17ca:	e4 07       	cpc	r30, r20
    17cc:	f5 07       	cpc	r31, r21
    17ce:	20 f0       	brcs	.+8      	; 0x17d8 <__udivmodsi4_ep>
    17d0:	a2 1b       	sub	r26, r18
    17d2:	b3 0b       	sbc	r27, r19
    17d4:	e4 0b       	sbc	r30, r20
    17d6:	f5 0b       	sbc	r31, r21

000017d8 <__udivmodsi4_ep>:
    17d8:	66 1f       	adc	r22, r22
    17da:	77 1f       	adc	r23, r23
    17dc:	88 1f       	adc	r24, r24
    17de:	99 1f       	adc	r25, r25
    17e0:	1a 94       	dec	r1
    17e2:	69 f7       	brne	.-38     	; 0x17be <__udivmodsi4_loop>
    17e4:	60 95       	com	r22
    17e6:	70 95       	com	r23
    17e8:	80 95       	com	r24
    17ea:	90 95       	com	r25
    17ec:	9b 01       	movw	r18, r22
    17ee:	ac 01       	movw	r20, r24
    17f0:	bd 01       	movw	r22, r26
    17f2:	cf 01       	movw	r24, r30
    17f4:	08 95       	ret

000017f6 <_exit>:
    17f6:	f8 94       	cli

000017f8 <__stop_program>:
    17f8:	ff cf       	rjmp	.-2      	; 0x17f8 <__stop_program>
