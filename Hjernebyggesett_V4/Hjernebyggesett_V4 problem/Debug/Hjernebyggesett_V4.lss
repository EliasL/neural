
Hjernebyggesett_V4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000016  00803800  00002648  000026fc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000025f4  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000054  0000a5f4  000025f4  000026a8  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .bss          0000005a  00803816  00803816  00002712  2**0
                  ALLOC
  4 .comment      0000005c  00000000  00000000  00002712  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00002770  2**2
                  CONTENTS, READONLY
  6 .debug_aranges 00000530  00000000  00000000  000027b0  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   000080f4  00000000  00000000  00002ce0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000387f  00000000  00000000  0000add4  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00002b1c  00000000  00000000  0000e653  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000009a8  00000000  00000000  00011170  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000033cc  00000000  00000000  00011b18  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    000019a9  00000000  00000000  00014ee4  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 000003a8  00000000  00000000  0001688d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 de 00 	jmp	0x1bc	; 0x1bc <__ctors_end>
       4:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
       8:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
       c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      10:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      14:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      18:	0c 94 2a 06 	jmp	0xc54	; 0xc54 <__vector_6>
      1c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      20:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      24:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      28:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      2c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      30:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      34:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      38:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      3c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      40:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      44:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      48:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      4c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      50:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      54:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      58:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      5c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      60:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      64:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      68:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      6c:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      70:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      74:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      78:	0c 94 fb 00 	jmp	0x1f6	; 0x1f6 <__bad_interrupt>
      7c:	07 63       	ori	r16, 0x37	; 55
      7e:	42 36       	cpi	r20, 0x62	; 98
      80:	b7 9b       	sbis	0x16, 7	; 22
      82:	d8 a7       	std	Y+40, r29	; 0x28
      84:	1a 39       	cpi	r17, 0x9A	; 154
      86:	68 56       	subi	r22, 0x68	; 104
      88:	18 ae       	std	Y+56, r1	; 0x38
      8a:	ba ab       	std	Y+50, r27	; 0x32
      8c:	55 8c       	ldd	r5, Z+29	; 0x1d
      8e:	1d 3c       	cpi	r17, 0xCD	; 205
      90:	b7 cc       	rjmp	.-1682   	; 0xfffffa00 <__eeprom_end+0xff7efa00>
      92:	57 63       	ori	r21, 0x37	; 55
      94:	bd 6d       	ori	r27, 0xDD	; 221
      96:	ed fd       	.word	0xfded	; ????
      98:	75 3e       	cpi	r23, 0xE5	; 229
      9a:	f6 17       	cp	r31, r22
      9c:	72 31       	cpi	r23, 0x12	; 18
      9e:	bf 00       	.word	0x00bf	; ????
      a0:	00 00       	nop
      a2:	80 3f       	cpi	r24, 0xF0	; 240
      a4:	05 a8       	ldd	r0, Z+53	; 0x35
      a6:	4c cd       	rjmp	.-1384   	; 0xfffffb40 <__eeprom_end+0xff7efb40>
      a8:	b2 d4       	rcall	.+2404   	; 0xa0e <tinyDebugger_send_double+0x6a>
      aa:	4e b9       	out	0x0e, r20	; 14
      ac:	38 36       	cpi	r19, 0x68	; 104
      ae:	a9 02       	muls	r26, r25
      b0:	0c 50       	subi	r16, 0x0C	; 12
      b2:	b9 91       	ld	r27, Y+
      b4:	86 88       	ldd	r8, Z+22	; 0x16
      b6:	08 3c       	cpi	r16, 0xC8	; 200
      b8:	a6 aa       	std	Z+54, r10	; 0x36
      ba:	aa 2a       	or	r10, r26
      bc:	be 00       	.word	0x00be	; ????
      be:	00 00       	nop
      c0:	80 3f       	cpi	r24, 0xF0	; 240

000000c2 <__trampolines_end>:
      c2:	00 40       	sbci	r16, 0x00	; 0
      c4:	7a 10       	cpse	r7, r10
      c6:	f3 5a       	subi	r31, 0xA3	; 163
      c8:	00 a0       	ldd	r0, Z+32	; 0x20
      ca:	72 4e       	sbci	r23, 0xE2	; 226
      cc:	18 09       	sbc	r17, r8
      ce:	00 10       	cpse	r0, r0
      d0:	a5 d4       	rcall	.+2378   	; 0xa1c <tinyDendrite_read_signals+0x2>
      d2:	e8 00       	.word	0x00e8	; ????
      d4:	00 e8       	ldi	r16, 0x80	; 128
      d6:	76 48       	sbci	r23, 0x86	; 134
      d8:	17 00       	.word	0x0017	; ????
      da:	00 e4       	ldi	r16, 0x40	; 64
      dc:	0b 54       	subi	r16, 0x4B	; 75
      de:	02 00       	.word	0x0002	; ????
      e0:	00 ca       	rjmp	.-3072   	; 0xfffff4e2 <__eeprom_end+0xff7ef4e2>
      e2:	9a 3b       	cpi	r25, 0xBA	; 186
      e4:	00 00       	nop
      e6:	00 e1       	ldi	r16, 0x10	; 16
      e8:	f5 05       	cpc	r31, r5
      ea:	00 00       	nop
      ec:	80 96       	adiw	r24, 0x20	; 32
      ee:	98 00       	.word	0x0098	; ????
      f0:	00 00       	nop
      f2:	40 42       	sbci	r20, 0x20	; 32
      f4:	0f 00       	.word	0x000f	; ????
      f6:	00 00       	nop
      f8:	a0 86       	std	Z+8, r10	; 0x08
      fa:	01 00       	.word	0x0001	; ????
      fc:	00 00       	nop
      fe:	10 27       	eor	r17, r16
     100:	00 00       	nop
     102:	00 00       	nop
     104:	e8 03       	fmulsu	r22, r16
     106:	00 00       	nop
     108:	00 00       	nop
     10a:	64 00       	.word	0x0064	; ????
     10c:	00 00       	nop
     10e:	00 00       	nop
     110:	0a 00       	.word	0x000a	; ????
     112:	00 00       	nop
     114:	00 00       	nop
     116:	01 00       	.word	0x0001	; ????
     118:	00 00       	nop
     11a:	00 00       	nop
     11c:	2c 76       	andi	r18, 0x6C	; 108
     11e:	d8 88       	ldd	r13, Y+16	; 0x10
     120:	dc 67       	ori	r29, 0x7C	; 124
     122:	4f 08       	sbc	r4, r15
     124:	23 df       	rcall	.-442    	; 0xffffff6c <__eeprom_end+0xff7eff6c>
     126:	c1 df       	rcall	.-126    	; 0xaa <__SREG__+0x6b>
     128:	ae 59       	subi	r26, 0x9E	; 158
     12a:	e1 b1       	in	r30, 0x01	; 1
     12c:	b7 96       	adiw	r30, 0x27	; 39
     12e:	e5 e3       	ldi	r30, 0x35	; 53
     130:	e4 53       	subi	r30, 0x34	; 52
     132:	c6 3a       	cpi	r28, 0xA6	; 166
     134:	e6 51       	subi	r30, 0x16	; 22
     136:	99 76       	andi	r25, 0x69	; 105
     138:	96 e8       	ldi	r25, 0x86	; 134
     13a:	e6 c2       	rjmp	.+1484   	; 0x708 <tinyAxon_update_potential+0xe4>
     13c:	84 26       	eor	r8, r20
     13e:	eb 89       	ldd	r30, Y+19	; 0x13
     140:	8c 9b       	sbis	0x11, 4	; 17
     142:	62 ed       	ldi	r22, 0xD2	; 210
     144:	40 7c       	andi	r20, 0xC0	; 192
     146:	6f fc       	.word	0xfc6f	; ????
     148:	ef bc       	out	0x2f, r14	; 47
     14a:	9c 9f       	mul	r25, r28
     14c:	40 f2       	brcs	.-112    	; 0xde <__trampolines_end+0x1c>
     14e:	ba a5       	ldd	r27, Y+42	; 0x2a
     150:	6f a5       	ldd	r22, Y+47	; 0x2f
     152:	f4 90       	lpm	r15, Z
     154:	05 5a       	subi	r16, 0xA5	; 165
     156:	2a f7       	brpl	.-54     	; 0x122 <__EEPROM_REGION_LENGTH__+0x22>
     158:	5c 93       	st	X, r21
     15a:	6b 6c       	ori	r22, 0xCB	; 203
     15c:	f9 67       	ori	r31, 0x79	; 121
     15e:	6d c1       	rjmp	.+730    	; 0x43a <DAC_0_initialization+0xe>
     160:	1b fc       	.word	0xfc1b	; ????
     162:	e0 e4       	ldi	r30, 0x40	; 64
     164:	0d 47       	sbci	r16, 0x7D	; 125
     166:	fe f5       	brtc	.+126    	; 0x1e6 <.do_clear_bss_loop>
     168:	20 e6       	ldi	r18, 0x60	; 96
     16a:	b5 00       	.word	0x00b5	; ????
     16c:	d0 ed       	ldi	r29, 0xD0	; 208
     16e:	90 2e       	mov	r9, r16
     170:	03 00       	.word	0x0003	; ????
     172:	94 35       	cpi	r25, 0x54	; 84
     174:	77 05       	cpc	r23, r7
     176:	00 80       	ld	r0, Z
     178:	84 1e       	adc	r8, r20
     17a:	08 00       	.word	0x0008	; ????
     17c:	00 20       	and	r0, r0
     17e:	4e 0a       	sbc	r4, r30
     180:	00 00       	nop
     182:	00 c8       	rjmp	.-4096   	; 0xfffff184 <__eeprom_end+0xff7ef184>
     184:	0c 33       	cpi	r16, 0x3C	; 60
     186:	33 33       	cpi	r19, 0x33	; 51
     188:	33 0f       	add	r19, r19
     18a:	98 6e       	ori	r25, 0xE8	; 232
     18c:	12 83       	std	Z+2, r17	; 0x02
     18e:	11 41       	sbci	r17, 0x11	; 17
     190:	ef 8d       	ldd	r30, Y+31	; 0x1f
     192:	21 14       	cp	r2, r1
     194:	89 3b       	cpi	r24, 0xB9	; 185
     196:	e6 55       	subi	r30, 0x56	; 86
     198:	16 cf       	rjmp	.-468    	; 0xffffffc6 <__eeprom_end+0xff7effc6>
     19a:	fe e6       	ldi	r31, 0x6E	; 110
     19c:	db 18       	sub	r13, r11
     19e:	d1 84       	ldd	r13, Z+9	; 0x09
     1a0:	4b 38       	cpi	r20, 0x8B	; 139
     1a2:	1b f7       	brvc	.-58     	; 0x16a <__EEPROM_REGION_LENGTH__+0x6a>
     1a4:	7c 1d       	adc	r23, r12
     1a6:	90 1d       	adc	r25, r0
     1a8:	a4 bb       	out	0x14, r26	; 20
     1aa:	e4 24       	eor	r14, r4
     1ac:	20 32       	cpi	r18, 0x20	; 32
     1ae:	84 72       	andi	r24, 0x24	; 36
     1b0:	5e 22       	and	r5, r30
     1b2:	81 00       	.word	0x0081	; ????
     1b4:	c9 f1       	breq	.+114    	; 0x228 <main+0x28>
     1b6:	24 ec       	ldi	r18, 0xC4	; 196
     1b8:	a1 e5       	ldi	r26, 0x51	; 81
     1ba:	3d 27       	eor	r19, r29

000001bc <__ctors_end>:
     1bc:	11 24       	eor	r1, r1
     1be:	1f be       	out	0x3f, r1	; 63
     1c0:	cf ef       	ldi	r28, 0xFF	; 255
     1c2:	cd bf       	out	0x3d, r28	; 61
     1c4:	df e3       	ldi	r29, 0x3F	; 63
     1c6:	de bf       	out	0x3e, r29	; 62

000001c8 <__do_copy_data>:
     1c8:	18 e3       	ldi	r17, 0x38	; 56
     1ca:	a0 e0       	ldi	r26, 0x00	; 0
     1cc:	b8 e3       	ldi	r27, 0x38	; 56
     1ce:	e8 e4       	ldi	r30, 0x48	; 72
     1d0:	f6 e2       	ldi	r31, 0x26	; 38
     1d2:	02 c0       	rjmp	.+4      	; 0x1d8 <__do_copy_data+0x10>
     1d4:	05 90       	lpm	r0, Z+
     1d6:	0d 92       	st	X+, r0
     1d8:	a6 31       	cpi	r26, 0x16	; 22
     1da:	b1 07       	cpc	r27, r17
     1dc:	d9 f7       	brne	.-10     	; 0x1d4 <__do_copy_data+0xc>

000001de <__do_clear_bss>:
     1de:	28 e3       	ldi	r18, 0x38	; 56
     1e0:	a6 e1       	ldi	r26, 0x16	; 22
     1e2:	b8 e3       	ldi	r27, 0x38	; 56
     1e4:	01 c0       	rjmp	.+2      	; 0x1e8 <.do_clear_bss_start>

000001e6 <.do_clear_bss_loop>:
     1e6:	1d 92       	st	X+, r1

000001e8 <.do_clear_bss_start>:
     1e8:	a0 37       	cpi	r26, 0x70	; 112
     1ea:	b2 07       	cpc	r27, r18
     1ec:	e1 f7       	brne	.-8      	; 0x1e6 <.do_clear_bss_loop>
     1ee:	0e 94 00 01 	call	0x200	; 0x200 <main>
     1f2:	0c 94 f8 12 	jmp	0x25f0	; 0x25f0 <_exit>

000001f6 <__bad_interrupt>:
     1f6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000001fa <atmel_start_init>:
/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
	system_init();
     1fa:	0e 94 22 02 	call	0x444	; 0x444 <system_init>
     1fe:	08 95       	ret

00000200 <main>:

int main(void)
{	
	
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
     200:	0e 94 fd 00 	call	0x1fa	; 0x1fa <atmel_start_init>
	For some reason, instead of the reference voltage being 4.32v, it is 3.3v. 
	A plausible explanation is that the microchip does not up the voltage, so that if the microchip is only ever 
	supplied with 3.3v, it will output 3.3v as the max.
	*/
	
	VREF.CTRLA |= VREF_DAC0REFSEL_4V34_gc;
     204:	e0 ea       	ldi	r30, 0xA0	; 160
     206:	f0 e0       	ldi	r31, 0x00	; 0
     208:	80 81       	ld	r24, Z
     20a:	83 60       	ori	r24, 0x03	; 3
     20c:	80 83       	st	Z, r24
	//tinyTester_test();
	
	while (1)
	{
		// We don't want to update the neuron too often because of various reasons. The tinyISR_getflag is set every ms, and so the loop is only run once every ms.  
		if(tinyISR_getflag())
     20e:	0e 94 58 06 	call	0xcb0	; 0xcb0 <tinyISR_getflag>
     212:	88 23       	and	r24, r24
     214:	e1 f3       	breq	.-8      	; 0x20e <main+0xe>
		{
			tinyCharge_update_charging_mode();
     216:	0e 94 7d 04 	call	0x8fa	; 0x8fa <tinyCharge_update_charging_mode>
			
			if(tinyCharge_is_connected_to_charger()){
     21a:	0e 94 42 04 	call	0x884	; 0x884 <tinyCharge_is_connected_to_charger>
     21e:	88 23       	and	r24, r24
     220:	b9 f0       	breq	.+46     	; 0x250 <main+0x50>
				// Charge loop
				
				if(tinyCharge_is_fully_charged()){
     222:	0e 94 45 04 	call	0x88a	; 0x88a <tinyCharge_is_fully_charged>
     226:	88 23       	and	r24, r24
     228:	49 f0       	breq	.+18     	; 0x23c <main+0x3c>
					// When the neuron is connected to a charger, and fully charged:
					tinyLED_set_color(INN_LED, CHARGING_DONE_COLOR);
     22a:	63 e0       	ldi	r22, 0x03	; 3
     22c:	80 e0       	ldi	r24, 0x00	; 0
     22e:	0e 94 9b 06 	call	0xd36	; 0xd36 <tinyLED_set_color>
					tinyLED_set_color(OUT_LED, LED_OFF);
     232:	60 e0       	ldi	r22, 0x00	; 0
     234:	81 e0       	ldi	r24, 0x01	; 1
     236:	0e 94 9b 06 	call	0xd36	; 0xd36 <tinyLED_set_color>
     23a:	11 c0       	rjmp	.+34     	; 0x25e <main+0x5e>
				}
				else{
					// When the neuron is charging and is not fully charged
					tinyLED_set_color_mode(OUT_LED, CHARGING_COLOR, SWING);
     23c:	43 e0       	ldi	r20, 0x03	; 3
     23e:	61 e0       	ldi	r22, 0x01	; 1
     240:	81 e0       	ldi	r24, 0x01	; 1
     242:	0e 94 77 06 	call	0xcee	; 0xcee <tinyLED_set_color_mode>
					tinyLED_set_color(INN_LED, LED_OFF);
     246:	60 e0       	ldi	r22, 0x00	; 0
     248:	80 e0       	ldi	r24, 0x00	; 0
     24a:	0e 94 9b 06 	call	0xd36	; 0xd36 <tinyLED_set_color>
     24e:	07 c0       	rjmp	.+14     	; 0x25e <main+0x5e>
				// Main loop			
				
				// Set LED
				// If the out led is turned LED_OFF, and the ping color is not disabled,
				// we turn on ping mode
				if(tinyLED_get_color(OUT_LED) == LED_OFF && PING_COLOR != LED_OFF){
     250:	81 e0       	ldi	r24, 0x01	; 1
     252:	0e 94 6f 06 	call	0xcde	; 0xcde <tinyLED_get_color>
					tinyLED_set_color_mode(OUT_LED, PING_COLOR, PING);
				}				
				
				// Update button	
				tinyButton_update();
     256:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <tinyButton_update>
				
				// Update the potential (This is where most of the important stuff happens)
				tinyPotential_update();
     25a:	0e 94 e5 08 	call	0x11ca	; 0x11ca <tinyPotential_update>
			}
			// Update LED
			tinyLED_update();
     25e:	0e 94 cf 06 	call	0xd9e	; 0xd9e <tinyLED_update>
				
			// Switch transistors
			tinyCharge_set_transistors();
     262:	0e 94 a5 04 	call	0x94a	; 0x94a <tinyCharge_set_transistors>
			
			// Prepare for next cycle
			tinyISR_setflag(false);
     266:	80 e0       	ldi	r24, 0x00	; 0
     268:	0e 94 55 06 	call	0xcaa	; 0xcaa <tinyISR_setflag>
			tinyDebugger_send_uint32("time", tinyTime_now());
     26c:	0e 94 dd 09 	call	0x13ba	; 0x13ba <tinyTime_now>
     270:	ab 01       	movw	r20, r22
     272:	bc 01       	movw	r22, r24
     274:	84 ef       	ldi	r24, 0xF4	; 244
     276:	95 ea       	ldi	r25, 0xA5	; 165
     278:	0e 94 af 04 	call	0x95e	; 0x95e <tinyDebugger_send_uint32>
			tinyDebugger_end_line();
     27c:	0e 94 08 05 	call	0xa10	; 0xa10 <tinyDebugger_end_line>
     280:	c6 cf       	rjmp	.-116    	; 0x20e <main+0xe>

00000282 <ADC_0_init>:
 * \return Conversion result read from the ADC_0 ADC module
 */
adc_result_t ADC_0_get_conversion_result(void)
{
	return (ADC1.RES);
}
     282:	e0 e4       	ldi	r30, 0x40	; 64
     284:	f6 e0       	ldi	r31, 0x06	; 6
     286:	80 e1       	ldi	r24, 0x10	; 16
     288:	82 83       	std	Z+2, r24	; 0x02
     28a:	85 e0       	ldi	r24, 0x05	; 5
     28c:	80 83       	st	Z, r24
     28e:	80 e0       	ldi	r24, 0x00	; 0
     290:	08 95       	ret

00000292 <ADC_0_is_conversion_done>:
     292:	80 91 4b 06 	lds	r24, 0x064B	; 0x80064b <__RODATA_PM_OFFSET__+0x7f864b>
     296:	81 70       	andi	r24, 0x01	; 1
     298:	08 95       	ret

0000029a <ADC_0_get_conversion>:
 *
 * \return Nothing
 */
void ADC_0_start_conversion(adc_1_channel_t channel)
{
	ADC1.MUXPOS  = channel;
     29a:	e0 e4       	ldi	r30, 0x40	; 64
     29c:	f6 e0       	ldi	r31, 0x06	; 6
     29e:	86 83       	std	Z+6, r24	; 0x06
	ADC1.COMMAND = ADC_STCONV_bm;
     2a0:	81 e0       	ldi	r24, 0x01	; 1
     2a2:	80 87       	std	Z+8, r24	; 0x08
adc_result_t ADC_0_get_conversion(adc_1_channel_t channel)
{
	adc_result_t res;

	ADC_0_start_conversion(channel);
	while (!ADC_0_is_conversion_done())
     2a4:	0e 94 49 01 	call	0x292	; 0x292 <ADC_0_is_conversion_done>
     2a8:	88 23       	and	r24, r24
     2aa:	e1 f3       	breq	.-8      	; 0x2a4 <ADC_0_get_conversion+0xa>
 *
 * \return Conversion result read from the ADC_0 ADC module
 */
adc_result_t ADC_0_get_conversion_result(void)
{
	return (ADC1.RES);
     2ac:	e0 e4       	ldi	r30, 0x40	; 64
     2ae:	f6 e0       	ldi	r31, 0x06	; 6
     2b0:	20 89       	ldd	r18, Z+16	; 0x10
     2b2:	31 89       	ldd	r19, Z+17	; 0x11

	ADC_0_start_conversion(channel);
	while (!ADC_0_is_conversion_done())
		;
	res = ADC_0_get_conversion_result();
	ADC1.INTFLAGS |= ADC_RESRDY_bm;
     2b4:	93 85       	ldd	r25, Z+11	; 0x0b
     2b6:	91 60       	ori	r25, 0x01	; 1
     2b8:	93 87       	std	Z+11, r25	; 0x0b
	return res;
}
     2ba:	c9 01       	movw	r24, r18
     2bc:	08 95       	ret

000002be <BOD_init>:
	//		 | BOD_VLMCFG_BELOW_gc; /* Interrupt when supply goes below VLM level */

	// BOD.VLMCTRLA = BOD_VLMLVL_5ABOVE_gc; /* VLM threshold 5% above BOD level */

	return 0;
}
     2be:	80 e0       	ldi	r24, 0x00	; 0
     2c0:	08 95       	ret

000002c2 <DIGITAL_GLUE_LOGIC_0_init>:

	// Enable Protected register, peripheral must be disabled (ENABLE=0, in TCD.LUT0CTRLA).

	// CCL.SEQCTRL0 = CCL_SEQSEL_DISABLE_gc /* Sequential logic disabled */;

	CCL.TRUTH0 = 168; /* Truth 0: 168 */
     2c2:	e0 ec       	ldi	r30, 0xC0	; 192
     2c4:	f1 e0       	ldi	r31, 0x01	; 1
     2c6:	28 ea       	ldi	r18, 0xA8	; 168
     2c8:	20 87       	std	Z+8, r18	; 0x08

	CCL.LUT0CTRLC = CCL_INSEL2_TCA0_gc /* TCA0 WO2 input source */;
     2ca:	98 e0       	ldi	r25, 0x08	; 8
     2cc:	97 83       	std	Z+7, r25	; 0x07

	CCL.LUT0CTRLB = CCL_INSEL0_SPI0_gc /* SPI0 SCK source */
     2ce:	8b eb       	ldi	r24, 0xBB	; 187
     2d0:	86 83       	std	Z+6, r24	; 0x06
	                | CCL_INSEL1_SPI0_gc /* SPI0 MOSI input source */;

	CCL.LUT0CTRLA = 0 << CCL_CLKSRC_bp       /* Clock Source Selection: disabled */
     2d2:	39 e0       	ldi	r19, 0x09	; 9
     2d4:	35 83       	std	Z+5, r19	; 0x05
	                | CCL_EDGEDET_DIS_gc     /* Edge detector is disabled */
	                | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	                | 1 << CCL_ENABLE_bp     /* LUT Enable: enabled */
	                | 1 << CCL_OUTEN_bp;     /* Output Enable: enabled */

	CCL.TRUTH1 = 168; /* Truth 1: 168 */
     2d6:	24 87       	std	Z+12, r18	; 0x0c

	CCL.LUT1CTRLC = CCL_INSEL2_TCA0_gc /* TCA0 WO2 input source */;
     2d8:	93 87       	std	Z+11, r25	; 0x0b

	CCL.LUT1CTRLB = CCL_INSEL0_SPI0_gc /* SPI0 SCK source */
     2da:	82 87       	std	Z+10, r24	; 0x0a
	//		 | CCL_EDGEDET_DIS_gc /* Edge detector is disabled */
	//		 | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	//		 | 0 << CCL_ENABLE_bp /* LUT Enable: disabled */
	//		 | 0 << CCL_OUTEN_bp; /* Output Enable: disabled */

	CCL.CTRLA = 1 << CCL_ENABLE_bp      /* Enable: enabled */
     2dc:	81 e4       	ldi	r24, 0x41	; 65
     2de:	80 83       	st	Z, r24
	            | 1 << CCL_RUNSTDBY_bp; /* Run in Standby: enabled */

	return 0;
}
     2e0:	80 e0       	ldi	r24, 0x00	; 0
     2e2:	08 95       	ret

000002e4 <CLKCTRL_init>:
 *       on calling convention. The memory model is not visible to the
 *       preprocessor, so it must be defined in the Assembler preprocessor directives.
 */
static inline void ccp_write_io(void *addr, uint8_t value)
{
	protected_write_io(addr, CCP_IOREG_gc, value);
     2e4:	47 e0       	ldi	r20, 0x07	; 7
     2e6:	68 ed       	ldi	r22, 0xD8	; 216
     2e8:	8c e7       	ldi	r24, 0x7C	; 124
     2ea:	90 e0       	ldi	r25, 0x00	; 0
     2ec:	0e 94 51 02 	call	0x4a2	; 0x4a2 <protected_write_io>
     2f0:	41 e0       	ldi	r20, 0x01	; 1
     2f2:	68 ed       	ldi	r22, 0xD8	; 216
     2f4:	81 e6       	ldi	r24, 0x61	; 97
     2f6:	90 e0       	ldi	r25, 0x00	; 0
     2f8:	0e 94 51 02 	call	0x4a2	; 0x4a2 <protected_write_io>
	//		 | 0 << CLKCTRL_CLKOUT_bp /* System clock out: disabled */);

	// ccp_write_io((void*)&(CLKCTRL.MCLKLOCK),0 << CLKCTRL_LOCKEN_bp /* lock enable: disabled */);

	return 0;
}
     2fc:	80 e0       	ldi	r24, 0x00	; 0
     2fe:	08 95       	ret

00000300 <CPUINT_init>:

	// CPUINT.LVL0PRI = 0x0 << CPUINT_LVL0PRI_gp; /* Interrupt Level Priority: 0x0 */

	// CPUINT.LVL1VEC = 0x0 << CPUINT_LVL1VEC_gp; /* Interrupt Vector with High Priority: 0x0 */

	ENABLE_INTERRUPTS();
     300:	78 94       	sei

	return 0;
}
     302:	80 e0       	ldi	r24, 0x00	; 0
     304:	08 95       	ret

00000306 <DAC_0_init>:
int8_t DAC_0_init()
{

	// DAC0.DATA = 0x0; /* DATA Register: 0x0 */

	DAC0.CTRLA = 1 << DAC_ENABLE_bp      /* DAC Enable: enabled */
     306:	81 e4       	ldi	r24, 0x41	; 65
     308:	80 93 a0 06 	sts	0x06A0, r24	; 0x8006a0 <__RODATA_PM_OFFSET__+0x7f86a0>
	             | 1 << DAC_OUTEN_bp     /* Output Buffer Enable: enabled */
	             | 0 << DAC_RUNSTDBY_bp; /* Run in Standby Mode: disabled */

	return 0;
}
     30c:	80 e0       	ldi	r24, 0x00	; 0
     30e:	08 95       	ret

00000310 <DAC_0_uninit>:
int8_t DAC_0_uninit()
{

	// DAC0.DATA = 0x0; /* DATA Register: 0x0 */

	DAC0.CTRLA = 1 << DAC_ENABLE_bp      /* DAC Enable: enabled */
     310:	81 e0       	ldi	r24, 0x01	; 1
     312:	80 93 a0 06 	sts	0x06A0, r24	; 0x8006a0 <__RODATA_PM_OFFSET__+0x7f86a0>
	| 0 << DAC_OUTEN_bp     /* Output Buffer Enable: disabled */
	| 0 << DAC_RUNSTDBY_bp; /* Run in Standby Mode: disabled */

	return 0;
}
     316:	80 e0       	ldi	r24, 0x00	; 0
     318:	08 95       	ret

0000031a <DAC_0_enable>:
 *
 * \return Nothing
 */
void DAC_0_enable()
{
	DAC0.CTRLA |= DAC_ENABLE_bm;
     31a:	e0 ea       	ldi	r30, 0xA0	; 160
     31c:	f6 e0       	ldi	r31, 0x06	; 6
     31e:	80 81       	ld	r24, Z
     320:	81 60       	ori	r24, 0x01	; 1
     322:	80 83       	st	Z, r24
     324:	08 95       	ret

00000326 <DAC_0_disable>:
 *
 * \return Nothing
 */
void DAC_0_disable()
{
	DAC0.CTRLA &= ~DAC_ENABLE_bm;
     326:	e0 ea       	ldi	r30, 0xA0	; 160
     328:	f6 e0       	ldi	r31, 0x06	; 6
     32a:	80 81       	ld	r24, Z
     32c:	8e 7f       	andi	r24, 0xFE	; 254
     32e:	80 83       	st	Z, r24
     330:	08 95       	ret

00000332 <DAC_0_set_output>:
 *
 * \return Nothing
 */
void DAC_0_set_output(dac_resolution_t value)
{
	DAC0.DATA = value;
     332:	80 93 a1 06 	sts	0x06A1, r24	; 0x8006a1 <__RODATA_PM_OFFSET__+0x7f86a1>
     336:	08 95       	ret

00000338 <mcu_init>:
#ifdef __cplusplus
extern "C" {
#endif

void mcu_init(void)
{
     338:	e0 e1       	ldi	r30, 0x10	; 16
     33a:	f4 e0       	ldi	r31, 0x04	; 4
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     33c:	80 81       	ld	r24, Z
     33e:	88 60       	ori	r24, 0x08	; 8
     340:	81 93       	st	Z+, r24
	 * disables all peripherals to save power. Driver shall enable
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
     342:	e8 31       	cpi	r30, 0x18	; 24
     344:	84 e0       	ldi	r24, 0x04	; 4
     346:	f8 07       	cpc	r31, r24
     348:	c9 f7       	brne	.-14     	; 0x33c <mcu_init+0x4>
     34a:	e0 e3       	ldi	r30, 0x30	; 48
     34c:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     34e:	80 81       	ld	r24, Z
     350:	88 60       	ori	r24, 0x08	; 8
     352:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     354:	e8 33       	cpi	r30, 0x38	; 56
     356:	84 e0       	ldi	r24, 0x04	; 4
     358:	f8 07       	cpc	r31, r24
     35a:	c9 f7       	brne	.-14     	; 0x34e <mcu_init+0x16>
     35c:	e0 e5       	ldi	r30, 0x50	; 80
     35e:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     360:	80 81       	ld	r24, Z
     362:	88 60       	ori	r24, 0x08	; 8
     364:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     366:	e8 35       	cpi	r30, 0x58	; 88
     368:	84 e0       	ldi	r24, 0x04	; 4
     36a:	f8 07       	cpc	r31, r24
     36c:	c9 f7       	brne	.-14     	; 0x360 <mcu_init+0x28>
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}
}
     36e:	08 95       	ret

00000370 <ADC_0_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     370:	e5 e1       	ldi	r30, 0x15	; 21
     372:	f4 e0       	ldi	r31, 0x04	; 4
     374:	80 81       	ld	r24, Z
     376:	88 7f       	andi	r24, 0xF8	; 248
     378:	84 60       	ori	r24, 0x04	; 4
     37a:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     37c:	80 81       	ld	r24, Z
     37e:	87 7f       	andi	r24, 0xF7	; 247
     380:	80 83       	st	Z, r24
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     382:	e7 e1       	ldi	r30, 0x17	; 23
     384:	f4 e0       	ldi	r31, 0x04	; 4
     386:	80 81       	ld	r24, Z
     388:	88 7f       	andi	r24, 0xF8	; 248
     38a:	84 60       	ori	r24, 0x04	; 4
     38c:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     38e:	80 81       	ld	r24, Z
     390:	87 7f       	andi	r24, 0xF7	; 247
     392:	80 83       	st	Z, r24
 */
static inline void PORTC_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     394:	e0 e5       	ldi	r30, 0x50	; 80
     396:	f4 e0       	ldi	r31, 0x04	; 4
     398:	80 81       	ld	r24, Z
     39a:	88 7f       	andi	r24, 0xF8	; 248
     39c:	84 60       	ori	r24, 0x04	; 4
     39e:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     3a0:	80 81       	ld	r24, Z
     3a2:	87 7f       	andi	r24, 0xF7	; 247
     3a4:	80 83       	st	Z, r24
 */
static inline void PORTC_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     3a6:	e1 e5       	ldi	r30, 0x51	; 81
     3a8:	f4 e0       	ldi	r31, 0x04	; 4
     3aa:	80 81       	ld	r24, Z
     3ac:	88 7f       	andi	r24, 0xF8	; 248
     3ae:	84 60       	ori	r24, 0x04	; 4
     3b0:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     3b2:	80 81       	ld	r24, Z
     3b4:	87 7f       	andi	r24, 0xF7	; 247
     3b6:	80 83       	st	Z, r24
 */
static inline void PORTC_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     3b8:	e3 e5       	ldi	r30, 0x53	; 83
     3ba:	f4 e0       	ldi	r31, 0x04	; 4
     3bc:	80 81       	ld	r24, Z
     3be:	88 7f       	andi	r24, 0xF8	; 248
     3c0:	84 60       	ori	r24, 0x04	; 4
     3c2:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     3c4:	80 81       	ld	r24, Z
     3c6:	87 7f       	andi	r24, 0xF7	; 247
     3c8:	80 83       	st	Z, r24
	// Disable digital input buffer
	DEN4_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	DEN4_PIN_set_pull_mode(PORT_PULL_OFF);

	ADC_0_init();
     3ca:	0e 94 41 01 	call	0x282	; 0x282 <ADC_0_init>
     3ce:	08 95       	ret

000003d0 <USART_0_initialization>:
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     3d0:	23 98       	cbi	0x04, 3	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     3d2:	e3 e3       	ldi	r30, 0x33	; 51
     3d4:	f4 e0       	ldi	r31, 0x04	; 4
     3d6:	80 81       	ld	r24, Z
     3d8:	87 7f       	andi	r24, 0xF7	; 247
     3da:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     3dc:	22 9a       	sbi	0x04, 2	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     3de:	2a 98       	cbi	0x05, 2	; 5
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	USART_0_init();
     3e0:	0e 94 8c 02 	call	0x518	; 0x518 <USART_0_init>
     3e4:	08 95       	ret

000003e6 <TIMER_0_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     3e6:	25 9a       	sbi	0x04, 5	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     3e8:	2d 98       	cbi	0x05, 5	; 5
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLC |= PORTMUX_TCA02_bm;
     3ea:	e0 e0       	ldi	r30, 0x00	; 0
     3ec:	f2 e0       	ldi	r31, 0x02	; 2
     3ee:	82 81       	ldd	r24, Z+2	; 0x02
     3f0:	84 60       	ori	r24, 0x04	; 4
     3f2:	82 83       	std	Z+2, r24	; 0x02

	TIMER_0_init();
     3f4:	0e 94 7c 02 	call	0x4f8	; 0x4f8 <TIMER_0_init>
     3f8:	08 95       	ret

000003fa <DIGITAL_GLUE_LOGIC_0_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     3fa:	24 9a       	sbi	0x04, 4	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     3fc:	2c 98       	cbi	0x05, 4	; 5
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLA |= PORTMUX_LUT0_bm;
     3fe:	e0 e0       	ldi	r30, 0x00	; 0
     400:	f2 e0       	ldi	r31, 0x02	; 2
     402:	80 81       	ld	r24, Z
     404:	80 61       	ori	r24, 0x10	; 16
     406:	80 83       	st	Z, r24

	DIGITAL_GLUE_LOGIC_0_init();
     408:	0e 94 61 01 	call	0x2c2	; 0x2c2 <DIGITAL_GLUE_LOGIC_0_init>
     40c:	08 95       	ret

0000040e <SPI_0_initialization>:
 */
static inline void PORTA_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
     40e:	02 98       	cbi	0x00, 2	; 0
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     410:	e2 e1       	ldi	r30, 0x12	; 18
     412:	f4 e0       	ldi	r31, 0x04	; 4
     414:	80 81       	ld	r24, Z
     416:	87 7f       	andi	r24, 0xF7	; 247
     418:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     41a:	01 9a       	sbi	0x00, 1	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     41c:	09 98       	cbi	0x01, 1	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     41e:	03 9a       	sbi	0x00, 3	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     420:	0b 98       	cbi	0x01, 3	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     422:	04 9a       	sbi	0x00, 4	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     424:	0c 98       	cbi	0x01, 4	; 1
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	SPI_0_init();
     426:	0e 94 74 02 	call	0x4e8	; 0x4e8 <SPI_0_init>
     42a:	08 95       	ret

0000042c <DAC_0_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     42c:	e6 e1       	ldi	r30, 0x16	; 22
     42e:	f4 e0       	ldi	r31, 0x04	; 4
     430:	80 81       	ld	r24, Z
     432:	88 7f       	andi	r24, 0xF8	; 248
     434:	84 60       	ori	r24, 0x04	; 4
     436:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     438:	80 81       	ld	r24, Z
     43a:	87 7f       	andi	r24, 0xF7	; 247
     43c:	80 83       	st	Z, r24
	// Disable digital input buffer
	AXON_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	AXON_PIN_set_pull_mode(PORT_PULL_OFF);

	DAC_0_init();
     43e:	0e 94 83 01 	call	0x306	; 0x306 <DAC_0_init>
     442:	08 95       	ret

00000444 <system_init>:
/**
 * \brief System initialization
 */
void system_init()
{
	mcu_init();
     444:	0e 94 9c 01 	call	0x338	; 0x338 <mcu_init>
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     448:	21 9a       	sbi	0x04, 1	; 4
 *                  false = Pin level set to "low" state
 */
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
     44a:	29 9a       	sbi	0x05, 1	; 5
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     44c:	26 98       	cbi	0x04, 6	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     44e:	e6 e3       	ldi	r30, 0x36	; 54
     450:	f4 e0       	ldi	r31, 0x04	; 4
     452:	80 81       	ld	r24, Z
     454:	87 7f       	andi	r24, 0xF7	; 247
     456:	80 83       	st	Z, r24
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     458:	27 98       	cbi	0x04, 7	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     45a:	e7 e3       	ldi	r30, 0x37	; 55
     45c:	f4 e0       	ldi	r31, 0x04	; 4
     45e:	80 81       	ld	r24, Z
     460:	87 7f       	andi	r24, 0xF7	; 247
     462:	80 83       	st	Z, r24
 */
static inline void PORTC_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
     464:	42 98       	cbi	0x08, 2	; 8
static inline void PORTC_set_pin_pull_mode(const uint8_t pin, const enum port_pull_mode pull_mode)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
     466:	e2 e5       	ldi	r30, 0x52	; 82
     468:	f4 e0       	ldi	r31, 0x04	; 4
     46a:	80 81       	ld	r24, Z
     46c:	88 60       	ori	r24, 0x08	; 8
     46e:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTC.DIR |= (1 << pin);
     470:	45 9a       	sbi	0x08, 5	; 8
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     472:	4d 9a       	sbi	0x09, 5	; 9
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    true);

	CLKCTRL_init();
     474:	0e 94 72 01 	call	0x2e4	; 0x2e4 <CLKCTRL_init>

	RTC_0_init();
     478:	0e 94 55 02 	call	0x4aa	; 0x4aa <RTC_0_init>

	ADC_0_initialization();
     47c:	0e 94 b8 01 	call	0x370	; 0x370 <ADC_0_initialization>

	USART_0_initialization();
     480:	0e 94 e8 01 	call	0x3d0	; 0x3d0 <USART_0_initialization>

	TIMER_0_initialization();
     484:	0e 94 f3 01 	call	0x3e6	; 0x3e6 <TIMER_0_initialization>

	DIGITAL_GLUE_LOGIC_0_initialization();
     488:	0e 94 fd 01 	call	0x3fa	; 0x3fa <DIGITAL_GLUE_LOGIC_0_initialization>

	SPI_0_initialization();
     48c:	0e 94 07 02 	call	0x40e	; 0x40e <SPI_0_initialization>

	DAC_0_initialization();
     490:	0e 94 16 02 	call	0x42c	; 0x42c <DAC_0_initialization>

	CPUINT_init();
     494:	0e 94 80 01 	call	0x300	; 0x300 <CPUINT_init>

	SLPCTRL_init();
     498:	0e 94 6f 02 	call	0x4de	; 0x4de <SLPCTRL_init>

	BOD_init();
     49c:	0e 94 5f 01 	call	0x2be	; 0x2be <BOD_init>
     4a0:	08 95       	ret

000004a2 <protected_write_io>:
#if defined(__GNUC__)
  
#ifdef RAMPZ
	out     _SFR_IO_ADDR(RAMPZ), r1         // Clear bits 23:16 of Z
#endif
	movw    r30, r24                // Load addr into Z
     4a2:	fc 01       	movw	r30, r24
	out     CCP, r22                // Start CCP handshake
     4a4:	64 bf       	out	0x34, r22	; 52
	st      Z, r20                  // Write value to I/O register
     4a6:	40 83       	st	Z, r20
	ret                             // Return to caller
     4a8:	08 95       	ret

000004aa <RTC_0_init>:
 * \return Initialization status.
 */
int8_t RTC_0_init()
{

	while (RTC.STATUS > 0) { /* Wait for all register to be synchronized */
     4aa:	e0 e4       	ldi	r30, 0x40	; 64
     4ac:	f1 e0       	ldi	r31, 0x01	; 1
     4ae:	81 81       	ldd	r24, Z+1	; 0x01
     4b0:	81 11       	cpse	r24, r1
     4b2:	fd cf       	rjmp	.-6      	; 0x4ae <RTC_0_init+0x4>
	}

	// RTC.CMP = 0x0; /* Compare: 0x0 */

	RTC.CNT = 0x20; /* Counter: 0x20 */
     4b4:	e0 e4       	ldi	r30, 0x40	; 64
     4b6:	f1 e0       	ldi	r31, 0x01	; 1
     4b8:	80 e2       	ldi	r24, 0x20	; 32
     4ba:	90 e0       	ldi	r25, 0x00	; 0
     4bc:	80 87       	std	Z+8, r24	; 0x08
     4be:	91 87       	std	Z+9, r25	; 0x09

	RTC.CTRLA = RTC_PRESCALER_DIV1_gc   /* 1 */
     4c0:	21 e8       	ldi	r18, 0x81	; 129
     4c2:	20 83       	st	Z, r18
	            | 1 << RTC_RTCEN_bp     /* Enable: enabled */
	            | 1 << RTC_RUNSTDBY_bp; /* Run In Standby: enabled */

	RTC.PER = 0x20; /* Period: 0x20 */
     4c4:	82 87       	std	Z+10, r24	; 0x0a
     4c6:	93 87       	std	Z+11, r25	; 0x0b

	// RTC.CLKSEL = RTC_CLKSEL_INT32K_gc; /* 32KHz Internal Ultra Low Power Oscillator (OSCULP32K) */

	RTC.DBGCTRL = 1 << RTC_DBGRUN_bp; /* Run in debug: enabled */
     4c8:	81 e0       	ldi	r24, 0x01	; 1
     4ca:	85 83       	std	Z+5, r24	; 0x05

	RTC.INTCTRL = 0 << RTC_CMP_bp    /* Compare Match Interrupt enable: disabled */
     4cc:	82 83       	std	Z+2, r24	; 0x02
	              | 1 << RTC_OVF_bp; /* Overflow Interrupt enable: enabled */

	while (RTC.PITSTATUS > 0) { /* Wait for all register to be synchronized */
     4ce:	81 89       	ldd	r24, Z+17	; 0x11
     4d0:	81 11       	cpse	r24, r1
     4d2:	fd cf       	rjmp	.-6      	; 0x4ce <RTC_0_init+0x24>
	}

	RTC.PITCTRLA = RTC_PERIOD_OFF_gc    /* Off */
     4d4:	81 e0       	ldi	r24, 0x01	; 1
     4d6:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <__RODATA_PM_OFFSET__+0x7f8150>
	// RTC.PITDBGCTRL = 0 << RTC_DBGRUN_bp; /* Run in debug: disabled */

	// RTC.PITINTCTRL = 0 << RTC_PI_bp; /* Periodic Interrupt: disabled */

	return 0;
}
     4da:	80 e0       	ldi	r24, 0x00	; 0
     4dc:	08 95       	ret

000004de <SLPCTRL_init>:
 * \return Initialization status.
 */
int8_t SLPCTRL_init()
{

	SLPCTRL.CTRLA = 1 << SLPCTRL_SEN_bp      /* Sleep enable: enabled */
     4de:	81 e0       	ldi	r24, 0x01	; 1
     4e0:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <__RODATA_PM_OFFSET__+0x7f8050>
	                | SLPCTRL_SMODE_IDLE_gc; /* Idle mode */

	return 0;
}
     4e4:	80 e0       	ldi	r24, 0x00	; 0
     4e6:	08 95       	ret

000004e8 <SPI_0_init>:
 * \return Initialization status
 */
int8_t SPI_0_init()
{

	SPI0.CTRLA = 0 << SPI_CLK2X_bp     /* Enable Double Speed: disabled */
     4e8:	e0 e2       	ldi	r30, 0x20	; 32
     4ea:	f8 e0       	ldi	r31, 0x08	; 8
     4ec:	83 e2       	ldi	r24, 0x23	; 35
     4ee:	80 83       	st	Z, r24
	             | 0 << SPI_DORD_bp    /* Data Order Setting: disabled */
	             | 1 << SPI_ENABLE_bp  /* Enable Module: enabled */
	             | 1 << SPI_MASTER_bp  /* SPI module in master mode */
	             | SPI_PRESC_DIV16_gc; /* System Clock / 16 */

	SPI0.CTRLB = 0 << SPI_BUFEN_bp   /* Buffer Mode Enable: disabled */
     4f0:	84 e0       	ldi	r24, 0x04	; 4
     4f2:	81 83       	std	Z+1, r24	; 0x01
	//		 | 0 << SPI_RXCIE_bp /* Receive Complete Interrupt Enable: disabled */
	//		 | 0 << SPI_SSIE_bp /* Slave Select Trigger Interrupt Enable: disabled */
	//		 | 0 << SPI_TXCIE_bp; /* Transfer Complete Interrupt Enable: disabled */

	return 0;
}
     4f4:	80 e0       	ldi	r24, 0x00	; 0
     4f6:	08 95       	ret

000004f8 <TIMER_0_init>:

	// TCA0.SINGLE.CMP0 = 0x0; /* Compare Register 0: 0x0 */

	// TCA0.SINGLE.CMP1 = 0x0; /* Compare Register 1: 0x0 */

	TCA0.SINGLE.CMP2 = 0x4; /* Compare Register 2: 0x4 */
     4f8:	e0 e0       	ldi	r30, 0x00	; 0
     4fa:	fa e0       	ldi	r31, 0x0A	; 10
     4fc:	84 e0       	ldi	r24, 0x04	; 4
     4fe:	90 e0       	ldi	r25, 0x00	; 0
     500:	84 a7       	std	Z+44, r24	; 0x2c
     502:	95 a7       	std	Z+45, r25	; 0x2d

	// TCA0.SINGLE.CNT = 0x0; /* Count: 0x0 */

	TCA0.SINGLE.CTRLB = 0 << TCA_SINGLE_ALUPD_bp            /* Auto Lock Update: disabled */
     504:	83 e4       	ldi	r24, 0x43	; 67
     506:	81 83       	std	Z+1, r24	; 0x01
	                    | 0 << TCA_SINGLE_CMP0EN_bp         /* Compare 0 Enable: disabled */
	                    | 0 << TCA_SINGLE_CMP1EN_bp         /* Compare 1 Enable: disabled */
	                    | 1 << TCA_SINGLE_CMP2EN_bp         /* Compare 2 Enable: enabled */
	                    | TCA_SINGLE_WGMODE_SINGLESLOPE_gc; /*  */

	TCA0.SINGLE.CTRLC = 0 << TCA_SINGLE_CMP0OV_bp    /* Compare 0 Waveform Output Value: disabled */
     508:	84 e0       	ldi	r24, 0x04	; 4
     50a:	82 83       	std	Z+2, r24	; 0x02
	// TCA0.SINGLE.INTCTRL = 0 << TCA_SINGLE_CMP0_bp /* Compare 0 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP1_bp /* Compare 1 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP2_bp /* Compare 2 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_OVF_bp; /* Overflow Interrupt: disabled */

	TCA0.SINGLE.PER = 0x7; /* Period: 0x7 */
     50c:	87 e0       	ldi	r24, 0x07	; 7
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	86 a3       	std	Z+38, r24	; 0x26
     512:	97 a3       	std	Z+39, r25	; 0x27

	// TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV1_gc /* System Clock */
	//		 | 0 << TCA_SINGLE_ENABLE_bp /* Module Enable: disabled */;

	return 0;
}
     514:	80 e0       	ldi	r24, 0x00	; 0
     516:	08 95       	ret

00000518 <USART_0_init>:
uint8_t USART_0_read()
{
	while (!(USART0.STATUS & USART_RXCIF_bm))
		;
	return USART0.RXDATAL;
}
     518:	e0 e0       	ldi	r30, 0x00	; 0
     51a:	f8 e0       	ldi	r31, 0x08	; 8
     51c:	8b e5       	ldi	r24, 0x5B	; 91
     51e:	91 e0       	ldi	r25, 0x01	; 1
     520:	80 87       	std	Z+8, r24	; 0x08
     522:	91 87       	std	Z+9, r25	; 0x09
     524:	80 ec       	ldi	r24, 0xC0	; 192
     526:	86 83       	std	Z+6, r24	; 0x06
     528:	80 e0       	ldi	r24, 0x00	; 0
     52a:	98 e3       	ldi	r25, 0x38	; 56
     52c:	80 93 6c 38 	sts	0x386C, r24	; 0x80386c <__iob+0x2>
     530:	90 93 6d 38 	sts	0x386D, r25	; 0x80386d <__iob+0x3>
     534:	80 e0       	ldi	r24, 0x00	; 0
     536:	08 95       	ret

00000538 <USART_0_write>:
 *
 * \return Nothing
 */
void USART_0_write(const uint8_t data)
{
	while (!(USART0.STATUS & USART_DREIF_bm))
     538:	e0 e0       	ldi	r30, 0x00	; 0
     53a:	f8 e0       	ldi	r31, 0x08	; 8
     53c:	94 81       	ldd	r25, Z+4	; 0x04
     53e:	95 ff       	sbrs	r25, 5
     540:	fd cf       	rjmp	.-6      	; 0x53c <USART_0_write+0x4>
		;
	USART0.TXDATAL = data;
     542:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <__RODATA_PM_OFFSET__+0x7f8802>
     546:	08 95       	ret

00000548 <USART_0_printCHAR>:

#if defined(__GNUC__)

int USART_0_printCHAR(char character, FILE *stream)
{
	USART_0_write(character);
     548:	0e 94 9c 02 	call	0x538	; 0x538 <USART_0_write>
	return 0;
}
     54c:	80 e0       	ldi	r24, 0x00	; 0
     54e:	90 e0       	ldi	r25, 0x00	; 0
     550:	08 95       	ret

00000552 <tinyAxon_add_pulse>:
{
	// We want to check each slot in the pulse_queue, and
	// if we find an empty slot (0), we add a pulse.
	for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
	{
		if(pulse_queue[i] == 0){
     552:	20 91 16 38 	lds	r18, 0x3816	; 0x803816 <__data_end>
     556:	30 91 17 38 	lds	r19, 0x3817	; 0x803817 <__data_end+0x1>
     55a:	23 2b       	or	r18, r19
     55c:	51 f0       	breq	.+20     	; 0x572 <tinyAxon_add_pulse+0x20>
     55e:	e8 e1       	ldi	r30, 0x18	; 24
     560:	f8 e3       	ldi	r31, 0x38	; 56
     562:	21 e0       	ldi	r18, 0x01	; 1
     564:	30 e0       	ldi	r19, 0x00	; 0
     566:	b9 01       	movw	r22, r18
     568:	41 91       	ld	r20, Z+
     56a:	51 91       	ld	r21, Z+
     56c:	45 2b       	or	r20, r21
     56e:	81 f4       	brne	.+32     	; 0x590 <tinyAxon_add_pulse+0x3e>
     570:	02 c0       	rjmp	.+4      	; 0x576 <tinyAxon_add_pulse+0x24>
     572:	60 e0       	ldi	r22, 0x00	; 0
     574:	70 e0       	ldi	r23, 0x00	; 0
			pulse_queue[i] = new_pulse;
     576:	66 0f       	add	r22, r22
     578:	77 1f       	adc	r23, r23
     57a:	fb 01       	movw	r30, r22
     57c:	ea 5e       	subi	r30, 0xEA	; 234
     57e:	f7 4c       	sbci	r31, 0xC7	; 199
     580:	80 83       	st	Z, r24
     582:	91 83       	std	Z+1, r25	; 0x01
			pulses_in_queue++;
     584:	80 91 2a 38 	lds	r24, 0x382A	; 0x80382a <pulses_in_queue>
     588:	8f 5f       	subi	r24, 0xFF	; 255
     58a:	80 93 2a 38 	sts	0x382A, r24	; 0x80382a <pulses_in_queue>
			// We return so we only ever add one
			break;
     58e:	08 95       	ret
     590:	2f 5f       	subi	r18, 0xFF	; 255
     592:	3f 4f       	sbci	r19, 0xFF	; 255
*/
static void tinyAxon_add_pulse(uint16_t new_pulse)
{
	// We want to check each slot in the pulse_queue, and
	// if we find an empty slot (0), we add a pulse.
	for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
     594:	2a 30       	cpi	r18, 0x0A	; 10
     596:	31 05       	cpc	r19, r1
     598:	31 f7       	brne	.-52     	; 0x566 <tinyAxon_add_pulse+0x14>
     59a:	08 95       	ret

0000059c <tinyAxon_is_firing>:
// DAC has no DAC_0_get_output, so we keep track of this here.
uint8_t axonOutputValue = 0;


_Bool tinyAxon_is_firing(){
	return axonOutputValue != NO_SIGNAL_OUTPUT;
     59c:	81 e0       	ldi	r24, 0x01	; 1
     59e:	90 91 2b 38 	lds	r25, 0x382B	; 0x80382b <axonOutputValue>
     5a2:	91 11       	cpse	r25, r1
     5a4:	01 c0       	rjmp	.+2      	; 0x5a8 <tinyAxon_is_firing+0xc>
     5a6:	80 e0       	ldi	r24, 0x00	; 0
}
     5a8:	08 95       	ret

000005aa <find_newest_pulse>:
uint8_t find_newest_pulse() {
	uint16_t max;
	uint8_t current_index = 0;
	uint8_t return_index = 0;
	
	max = pulse_queue[current_index];
     5aa:	40 91 16 38 	lds	r20, 0x3816	; 0x803816 <__data_end>
     5ae:	50 91 17 38 	lds	r21, 0x3817	; 0x803817 <__data_end+0x1>
     5b2:	e8 e1       	ldi	r30, 0x18	; 24
     5b4:	f8 e3       	ldi	r31, 0x38	; 56
	
// This function will be used with pulse_queue to find the newest pulse
uint8_t find_newest_pulse() {
	uint16_t max;
	uint8_t current_index = 0;
	uint8_t return_index = 0;
     5b6:	80 e0       	ldi	r24, 0x00	; 0
	
	max = pulse_queue[current_index];
	
	for (current_index = 1; current_index < MAX_NUMBER_OF_PULSES; current_index++) {
     5b8:	91 e0       	ldi	r25, 0x01	; 1
		if (pulse_queue[current_index] > max) {
     5ba:	21 91       	ld	r18, Z+
     5bc:	31 91       	ld	r19, Z+
     5be:	42 17       	cp	r20, r18
     5c0:	53 07       	cpc	r21, r19
     5c2:	10 f4       	brcc	.+4      	; 0x5c8 <find_newest_pulse+0x1e>
     5c4:	89 2f       	mov	r24, r25
			return_index = current_index;
			max = pulse_queue[current_index];
     5c6:	a9 01       	movw	r20, r18
	uint8_t current_index = 0;
	uint8_t return_index = 0;
	
	max = pulse_queue[current_index];
	
	for (current_index = 1; current_index < MAX_NUMBER_OF_PULSES; current_index++) {
     5c8:	9f 5f       	subi	r25, 0xFF	; 255
     5ca:	9a 30       	cpi	r25, 0x0A	; 10
     5cc:	b1 f7       	brne	.-20     	; 0x5ba <find_newest_pulse+0x10>
			return_index = current_index;
			max = pulse_queue[current_index];
		}
	}
	return return_index;
}
     5ce:	08 95       	ret

000005d0 <tinyAxon_stop_sending_pulse>:
	tinyLED_set_color_mode(OUT_LED, WHITE, FLASH_ONCE);
}

void tinyAxon_stop_sending_pulse()
{
	DAC_0_set_output(NO_SIGNAL_OUTPUT);
     5d0:	80 e0       	ldi	r24, 0x00	; 0
     5d2:	90 e0       	ldi	r25, 0x00	; 0
     5d4:	0e 94 99 01 	call	0x332	; 0x332 <DAC_0_set_output>
	axonOutputValue=NO_SIGNAL_OUTPUT;
     5d8:	10 92 2b 38 	sts	0x382B, r1	; 0x80382b <axonOutputValue>
     5dc:	08 95       	ret

000005de <tinyAxon_remove_pulse>:

/*
If the potential is very low, we want to try to remove a pulse.
*/
bool tinyAxon_remove_pulse(void)
{
     5de:	cf 93       	push	r28
	// We want to return a bool indicating whether or not a pulse actually was removed.
	if(pulses_in_queue == 0){
     5e0:	c0 91 2a 38 	lds	r28, 0x382A	; 0x80382a <pulses_in_queue>
     5e4:	cc 23       	and	r28, r28
     5e6:	c9 f0       	breq	.+50     	; 0x61a <tinyAxon_remove_pulse+0x3c>
		//There was no pulse to remove.
		return false;
	}
	else{
		// If we are to remove a pulse, we want to remove the one that will fire last.
		uint8_t pulse_index = find_newest_pulse();
     5e8:	0e 94 d5 02 	call	0x5aa	; 0x5aa <find_newest_pulse>
		uint16_t newest_pulse = pulse_queue[pulse_index];
     5ec:	90 e0       	ldi	r25, 0x00	; 0
     5ee:	fc 01       	movw	r30, r24
     5f0:	ee 0f       	add	r30, r30
     5f2:	ff 1f       	adc	r31, r31
     5f4:	ea 5e       	subi	r30, 0xEA	; 234
     5f6:	f7 4c       	sbci	r31, 0xC7	; 199
	
		// Now we want to check if the pulse is too far away to be affected by the low potential, or close enough that we decide to remove it.
		// (When we say that the pulse is too far away, it refers to the biological process of how the potential spreads from Dendrites to axon).
		if(newest_pulse > PULSE_NO_RETURN_TIME){
     5f8:	20 81       	ld	r18, Z
     5fa:	31 81       	ldd	r19, Z+1	; 0x01
     5fc:	2d 33       	cpi	r18, 0x3D	; 61
     5fe:	31 05       	cpc	r19, r1
     600:	70 f0       	brcs	.+28     	; 0x61e <tinyAxon_remove_pulse+0x40>
			// We decided to remove the pulse
			pulse_queue[pulse_index] = 0;
     602:	88 0f       	add	r24, r24
     604:	99 1f       	adc	r25, r25
     606:	fc 01       	movw	r30, r24
     608:	ea 5e       	subi	r30, 0xEA	; 234
     60a:	f7 4c       	sbci	r31, 0xC7	; 199
     60c:	10 82       	st	Z, r1
     60e:	11 82       	std	Z+1, r1	; 0x01
			pulses_in_queue--;
     610:	c1 50       	subi	r28, 0x01	; 1
     612:	c0 93 2a 38 	sts	0x382A, r28	; 0x80382a <pulses_in_queue>
			return true;
     616:	81 e0       	ldi	r24, 0x01	; 1
     618:	03 c0       	rjmp	.+6      	; 0x620 <tinyAxon_remove_pulse+0x42>
bool tinyAxon_remove_pulse(void)
{
	// We want to return a bool indicating whether or not a pulse actually was removed.
	if(pulses_in_queue == 0){
		//There was no pulse to remove.
		return false;
     61a:	80 e0       	ldi	r24, 0x00	; 0
     61c:	01 c0       	rjmp	.+2      	; 0x620 <tinyAxon_remove_pulse+0x42>
			pulses_in_queue--;
			return true;
		}
		// Here we have found that there is a pulse queued, but it is old enough to let pass anyway, so now we need to put it back into the queue.
		else{
			return false;
     61e:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     620:	cf 91       	pop	r28
     622:	08 95       	ret

00000624 <tinyAxon_update_potential>:
/*
Decides whether or not the axon should fire
If the axon does fire, the potential is reduced
*/
double tinyAxon_update_potential(double potential)
{	
     624:	cf 92       	push	r12
     626:	df 92       	push	r13
     628:	ef 92       	push	r14
     62a:	ff 92       	push	r15
     62c:	6b 01       	movw	r12, r22
     62e:	7c 01       	movw	r14, r24
	//While the neuron has enough potential to fire, we want to fire more
	while (potential >= THRESHOLD_POTENTIAL)
     630:	20 e0       	ldi	r18, 0x00	; 0
     632:	30 e0       	ldi	r19, 0x00	; 0
     634:	48 ec       	ldi	r20, 0xC8	; 200
     636:	51 e4       	ldi	r21, 0x41	; 65
     638:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__gesf2>
     63c:	88 23       	and	r24, r24
     63e:	bc f1       	brlt	.+110    	; 0x6ae <tinyAxon_update_potential+0x8a>
	{
		// We have to check if there are already queued pulses, so that the frequency never exceeds FIRE_DELAY
		if(pulses_in_queue>0){
     640:	80 91 2a 38 	lds	r24, 0x382A	; 0x80382a <pulses_in_queue>
     644:	88 23       	and	r24, r24
     646:	b1 f0       	breq	.+44     	; 0x674 <tinyAxon_update_potential+0x50>
			uint16_t newest_pulse = pulse_queue[find_newest_pulse()];
     648:	0e 94 d5 02 	call	0x5aa	; 0x5aa <find_newest_pulse>
     64c:	e8 2f       	mov	r30, r24
     64e:	f0 e0       	ldi	r31, 0x00	; 0
     650:	ee 0f       	add	r30, r30
     652:	ff 1f       	adc	r31, r31
     654:	ea 5e       	subi	r30, 0xEA	; 234
     656:	f7 4c       	sbci	r31, 0xC7	; 199
			
			// There is at least one pulse in the queue, and it is "so close", that we need to offset the new pulse, so that we keep at least
			// one FIRE_DELAY between each pulse
			if(newest_pulse + FIRE_DELAY > TRAVLE_DELAY){
     658:	80 81       	ld	r24, Z
     65a:	91 81       	ldd	r25, Z+1	; 0x01
     65c:	0a 96       	adiw	r24, 0x0a	; 10
     65e:	85 36       	cpi	r24, 0x65	; 101
     660:	91 05       	cpc	r25, r1
     662:	18 f0       	brcs	.+6      	; 0x66a <tinyAxon_update_potential+0x46>
				tinyAxon_add_pulse(newest_pulse + FIRE_DELAY);
     664:	0e 94 a9 02 	call	0x552	; 0x552 <tinyAxon_add_pulse>
     668:	09 c0       	rjmp	.+18     	; 0x67c <tinyAxon_update_potential+0x58>
			}
			// There is at least one pulse in the queue, but it's "far enough away" to ignore
			else{
				tinyAxon_add_pulse(TRAVLE_DELAY);
     66a:	84 e6       	ldi	r24, 0x64	; 100
     66c:	90 e0       	ldi	r25, 0x00	; 0
     66e:	0e 94 a9 02 	call	0x552	; 0x552 <tinyAxon_add_pulse>
     672:	04 c0       	rjmp	.+8      	; 0x67c <tinyAxon_update_potential+0x58>
			}
		}
		// There are no pulses in the queue, so we add a pulse as normal
		else{
			tinyAxon_add_pulse(TRAVLE_DELAY);		
     674:	84 e6       	ldi	r24, 0x64	; 100
     676:	90 e0       	ldi	r25, 0x00	; 0
     678:	0e 94 a9 02 	call	0x552	; 0x552 <tinyAxon_add_pulse>
		}
		
		potential += POSTFIRE_POTENTIAL_REACTION; // This is usually defined as a negative value, don't be confused by the +=
     67c:	20 e0       	ldi	r18, 0x00	; 0
     67e:	30 e0       	ldi	r19, 0x00	; 0
     680:	48 ec       	ldi	r20, 0xC8	; 200
     682:	51 e4       	ldi	r21, 0x41	; 65
     684:	c7 01       	movw	r24, r14
     686:	b6 01       	movw	r22, r12
     688:	0e 94 e6 09 	call	0x13cc	; 0x13cc <__subsf3>
     68c:	6b 01       	movw	r12, r22
     68e:	7c 01       	movw	r14, r24
		
		tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
     690:	45 e0       	ldi	r20, 0x05	; 5
     692:	63 e0       	ldi	r22, 0x03	; 3
     694:	80 e0       	ldi	r24, 0x00	; 0
     696:	0e 94 77 06 	call	0xcee	; 0xcee <tinyLED_set_color_mode>
If the axon does fire, the potential is reduced
*/
double tinyAxon_update_potential(double potential)
{	
	//While the neuron has enough potential to fire, we want to fire more
	while (potential >= THRESHOLD_POTENTIAL)
     69a:	20 e0       	ldi	r18, 0x00	; 0
     69c:	30 e0       	ldi	r19, 0x00	; 0
     69e:	48 ec       	ldi	r20, 0xC8	; 200
     6a0:	51 e4       	ldi	r21, 0x41	; 65
     6a2:	c7 01       	movw	r24, r14
     6a4:	b6 01       	movw	r22, r12
     6a6:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__gesf2>
     6aa:	88 23       	and	r24, r24
     6ac:	4c f6       	brge	.-110    	; 0x640 <tinyAxon_update_potential+0x1c>
		
		tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
	}
	
	// If the neuron has a very low potential, we want to remove a pulse from the queue (if there is one)
	if(potential < -THRESHOLD_POTENTIAL)
     6ae:	20 e0       	ldi	r18, 0x00	; 0
     6b0:	30 e0       	ldi	r19, 0x00	; 0
     6b2:	48 ec       	ldi	r20, 0xC8	; 200
     6b4:	51 ec       	ldi	r21, 0xC1	; 193
     6b6:	c7 01       	movw	r24, r14
     6b8:	b6 01       	movw	r22, r12
     6ba:	0e 94 53 0a 	call	0x14a6	; 0x14a6 <__cmpsf2>
     6be:	88 23       	and	r24, r24
     6c0:	0c f0       	brlt	.+2      	; 0x6c4 <tinyAxon_update_potential+0xa0>
     6c2:	46 c0       	rjmp	.+140    	; 0x750 <tinyAxon_update_potential+0x12c>
	{
		if(pulses_in_queue > 0) // Perhaps this should be a separate variable? For now, we will just simply use -THRESHOLD_POTENTIAL
     6c4:	80 91 2a 38 	lds	r24, 0x382A	; 0x80382a <pulses_in_queue>
     6c8:	88 23       	and	r24, r24
     6ca:	11 f1       	breq	.+68     	; 0x710 <tinyAxon_update_potential+0xec>
		{
			// The neurons potential is low enough to attempt to remove a queued fire (Fire less)
			if(tinyAxon_remove_pulse())
     6cc:	0e 94 ef 02 	call	0x5de	; 0x5de <tinyAxon_remove_pulse>
     6d0:	88 23       	and	r24, r24
     6d2:	f1 f1       	breq	.+124    	; 0x750 <tinyAxon_update_potential+0x12c>
			{
				// The potential has evened out a bit
				potential += THRESHOLD_POTENTIAL;
     6d4:	20 e0       	ldi	r18, 0x00	; 0
     6d6:	30 e0       	ldi	r19, 0x00	; 0
     6d8:	48 ec       	ldi	r20, 0xC8	; 200
     6da:	51 e4       	ldi	r21, 0x41	; 65
     6dc:	c7 01       	movw	r24, r14
     6de:	b6 01       	movw	r22, r12
     6e0:	0e 94 e7 09 	call	0x13ce	; 0x13ce <__addsf3>
     6e4:	6b 01       	movw	r12, r22
     6e6:	7c 01       	movw	r14, r24
     6e8:	33 c0       	rjmp	.+102    	; 0x750 <tinyAxon_update_potential+0x12c>
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
	{
		for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
		{
			if(pulse_queue[i] != 0){
     6ea:	80 81       	ld	r24, Z
     6ec:	91 81       	ldd	r25, Z+1	; 0x01
     6ee:	00 97       	sbiw	r24, 0x00	; 0
     6f0:	39 f0       	breq	.+14     	; 0x700 <tinyAxon_update_potential+0xdc>
				pulse_queue[i]--;
     6f2:	01 97       	sbiw	r24, 0x01	; 1
     6f4:	80 83       	st	Z, r24
     6f6:	91 83       	std	Z+1, r25	; 0x01
				
				// If the time went from 1 to 0, we fire the axon
				if(pulse_queue[i] == 0){
     6f8:	89 2b       	or	r24, r25
     6fa:	11 f4       	brne	.+4      	; 0x700 <tinyAxon_update_potential+0xdc>
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
	pulses_in_queue--;
     6fc:	41 50       	subi	r20, 0x01	; 1
Function to set firing.
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
     6fe:	51 e0       	ldi	r21, 0x01	; 1
     700:	32 96       	adiw	r30, 0x02	; 2
	}
	
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
	{
		for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
     702:	e2 17       	cp	r30, r18
     704:	f3 07       	cpc	r31, r19
     706:	89 f7       	brne	.-30     	; 0x6ea <tinyAxon_update_potential+0xc6>
     708:	50 93 2c 38 	sts	0x382C, r21	; 0x80382c <tinyAxon_should_fire>
     70c:	40 93 2a 38 	sts	0x382A, r20	; 0x80382a <pulses_in_queue>
The function should set the DAC to fire for two
update cycles once the pulse flag is set high.
*/
static void tinyAxon_update_pulse_transmitter(void)
{
	if (tinyAxon_should_fire)
     710:	80 91 2c 38 	lds	r24, 0x382C	; 0x80382c <tinyAxon_should_fire>
     714:	88 23       	and	r24, r24
     716:	91 f0       	breq	.+36     	; 0x73c <tinyAxon_update_potential+0x118>
	{
		tinyAxon_should_fire = false;
     718:	10 92 2c 38 	sts	0x382C, r1	; 0x80382c <tinyAxon_should_fire>
*/
static void tinyAxon_start_sending_pulse()
{
	if (NEURONTYPE == EXCITATORY_NEURON)
	{
		DAC_0_set_output(EXCITATORY_NEURON_OUTPUT);
     71c:	80 e8       	ldi	r24, 0x80	; 128
     71e:	90 e0       	ldi	r25, 0x00	; 0
     720:	0e 94 99 01 	call	0x332	; 0x332 <DAC_0_set_output>
		axonOutputValue=EXCITATORY_NEURON_OUTPUT;
     724:	80 e8       	ldi	r24, 0x80	; 128
     726:	80 93 2b 38 	sts	0x382B, r24	; 0x80382b <axonOutputValue>
	{
		DAC_0_set_output(INHIBITORY_NEURON_OUTPUT);
		axonOutputValue=INHIBITORY_NEURON_OUTPUT;
	}
	
	tinyLED_set_color_mode(OUT_LED, WHITE, FLASH_ONCE);
     72a:	45 e0       	ldi	r20, 0x05	; 5
     72c:	65 e0       	ldi	r22, 0x05	; 5
     72e:	81 e0       	ldi	r24, 0x01	; 1
     730:	0e 94 77 06 	call	0xcee	; 0xcee <tinyLED_set_color_mode>
{
	if (tinyAxon_should_fire)
	{
		tinyAxon_should_fire = false;
		tinyAxon_start_sending_pulse();
		tinyAxon_has_just_fired = true;
     734:	81 e0       	ldi	r24, 0x01	; 1
     736:	80 93 2d 38 	sts	0x382D, r24	; 0x80382d <tinyAxon_has_just_fired>
     73a:	15 c0       	rjmp	.+42     	; 0x766 <tinyAxon_update_potential+0x142>
		
	}
	else if (tinyAxon_has_just_fired)
     73c:	80 91 2d 38 	lds	r24, 0x382D	; 0x80382d <tinyAxon_has_just_fired>
     740:	88 23       	and	r24, r24
     742:	19 f0       	breq	.+6      	; 0x74a <tinyAxon_update_potential+0x126>
	{
		tinyAxon_has_just_fired = false;
     744:	10 92 2d 38 	sts	0x382D, r1	; 0x80382d <tinyAxon_has_just_fired>
     748:	0e c0       	rjmp	.+28     	; 0x766 <tinyAxon_update_potential+0x142>
	}
	else if (!tinyAxon_has_just_fired && !tinyAxon_should_fire)
	{
		tinyAxon_stop_sending_pulse();
     74a:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <tinyAxon_stop_sending_pulse>
     74e:	0b c0       	rjmp	.+22     	; 0x766 <tinyAxon_update_potential+0x142>
			}
		}
	}
	
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
     750:	40 91 2a 38 	lds	r20, 0x382A	; 0x80382a <pulses_in_queue>
     754:	44 23       	and	r20, r20
     756:	e1 f2       	breq	.-72     	; 0x710 <tinyAxon_update_potential+0xec>
     758:	50 91 2c 38 	lds	r21, 0x382C	; 0x80382c <tinyAxon_should_fire>
     75c:	e6 e1       	ldi	r30, 0x16	; 22
     75e:	f8 e3       	ldi	r31, 0x38	; 56
     760:	2a e2       	ldi	r18, 0x2A	; 42
     762:	38 e3       	ldi	r19, 0x38	; 56
     764:	c2 cf       	rjmp	.-124    	; 0x6ea <tinyAxon_update_potential+0xc6>
	}
	
	// Here we set the actual output of the DAC (Digital to Analog Converter)
	tinyAxon_update_pulse_transmitter();
	
	tinyDebugger_send_uint8("Axon", axonOutputValue);
     766:	60 91 2b 38 	lds	r22, 0x382B	; 0x80382b <axonOutputValue>
     76a:	89 ef       	ldi	r24, 0xF9	; 249
     76c:	95 ea       	ldi	r25, 0xA5	; 165
     76e:	0e 94 c1 04 	call	0x982	; 0x982 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("Pulses", pulses_in_queue);
     772:	60 91 2a 38 	lds	r22, 0x382A	; 0x80382a <pulses_in_queue>
     776:	8e ef       	ldi	r24, 0xFE	; 254
     778:	95 ea       	ldi	r25, 0xA5	; 165
     77a:	0e 94 c1 04 	call	0x982	; 0x982 <tinyDebugger_send_uint8>
	
	
	return potential;
}
     77e:	c7 01       	movw	r24, r14
     780:	b6 01       	movw	r22, r12
     782:	ff 90       	pop	r15
     784:	ef 90       	pop	r14
     786:	df 90       	pop	r13
     788:	cf 90       	pop	r12
     78a:	08 95       	ret

0000078c <tinyAxon_check_charge_level>:
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTB_get_pin_level(const uint8_t pin)
{
	return VPORTB.IN & (1 << pin);
     78c:	66 b1       	in	r22, 0x06	; 6

_Bool tinyAxon_check_charge_level(void)
{
	// We check the AXON_CHECK_PIN. If it is hight while the axon is not firing, it must be connected to a charger
	
	tinyDebugger_send_uint8("Pulses", AXON_CHECK_PIN_get_level());
     78e:	66 1f       	adc	r22, r22
     790:	66 27       	eor	r22, r22
     792:	66 1f       	adc	r22, r22
     794:	8e ef       	ldi	r24, 0xFE	; 254
     796:	95 ea       	ldi	r25, 0xA5	; 165
     798:	0e 94 c1 04 	call	0x982	; 0x982 <tinyDebugger_send_uint8>
	return (AXON_CHECK_PIN_get_level() && !tinyAxon_has_just_fired);
     79c:	37 9b       	sbis	0x06, 7	; 6
     79e:	05 c0       	rjmp	.+10     	; 0x7aa <tinyAxon_check_charge_level+0x1e>
     7a0:	90 91 2d 38 	lds	r25, 0x382D	; 0x80382d <tinyAxon_has_just_fired>
     7a4:	81 e0       	ldi	r24, 0x01	; 1
     7a6:	89 27       	eor	r24, r25
     7a8:	02 c0       	rjmp	.+4      	; 0x7ae <tinyAxon_check_charge_level+0x22>
     7aa:	80 e0       	ldi	r24, 0x00	; 0
     7ac:	90 e0       	ldi	r25, 0x00	; 0
     7ae:	81 70       	andi	r24, 0x01	; 1
     7b0:	08 95       	ret

000007b2 <tinyButton_update>:
/*
If the button has been let go, we change button_press to true. This only lasts one cycle, before it is set to false again.
If the button is held down for longer than PULSEMODE_BUTTON_PRESS_TIME, we toggle the pulse mode state.
*/
void tinyButton_update(void)
{
     7b2:	0f 93       	push	r16
     7b4:	1f 93       	push	r17
     7b6:	cf 93       	push	r28
     7b8:	df 93       	push	r29
	button_press = false;
     7ba:	10 92 33 38 	sts	0x3833, r1	; 0x803833 <button_press>
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTC_get_pin_level(const uint8_t pin)
{
	return VPORTC.IN & (1 << pin);
     7be:	8a b1       	in	r24, 0x0a	; 10
	_Bool button_is_pushed_down = !BUTTON_PIN_get_level(); // The digital port will be read as low if the button is pushed down.
     7c0:	d1 e0       	ldi	r29, 0x01	; 1
     7c2:	c8 2f       	mov	r28, r24
     7c4:	c4 70       	andi	r28, 0x04	; 4
     7c6:	82 fd       	sbrc	r24, 2
     7c8:	d0 e0       	ldi	r29, 0x00	; 0

	if (button_is_pushed_down && !button_was_pushed_down)
     7ca:	c1 11       	cpse	r28, r1
     7cc:	39 c0       	rjmp	.+114    	; 0x840 <__DATA_REGION_LENGTH__+0x40>
     7ce:	80 91 34 38 	lds	r24, 0x3834	; 0x803834 <button_was_pushed_down>
     7d2:	81 11       	cpse	r24, r1
     7d4:	0e c0       	rjmp	.+28     	; 0x7f2 <tinyButton_update+0x40>
	{
		tinyButton_start_time = tinyTime_now();
     7d6:	0e 94 dd 09 	call	0x13ba	; 0x13ba <tinyTime_now>
     7da:	60 93 2e 38 	sts	0x382E, r22	; 0x80382e <tinyButton_start_time>
     7de:	70 93 2f 38 	sts	0x382F, r23	; 0x80382f <tinyButton_start_time+0x1>
     7e2:	80 93 30 38 	sts	0x3830, r24	; 0x803830 <tinyButton_start_time+0x2>
     7e6:	90 93 31 38 	sts	0x3831, r25	; 0x803831 <tinyButton_start_time+0x3>
	}
	if (button_is_pushed_down && button_was_pushed_down)
     7ea:	80 91 34 38 	lds	r24, 0x3834	; 0x803834 <button_was_pushed_down>
     7ee:	88 23       	and	r24, r24
     7f0:	b9 f1       	breq	.+110    	; 0x860 <__DATA_REGION_LENGTH__+0x60>
	{
		if ((tinyTime_now() - tinyButton_start_time) > PULSEMODE_BUTTON_PRESS_TIME)
     7f2:	0e 94 dd 09 	call	0x13ba	; 0x13ba <tinyTime_now>
     7f6:	00 91 2e 38 	lds	r16, 0x382E	; 0x80382e <tinyButton_start_time>
     7fa:	10 91 2f 38 	lds	r17, 0x382F	; 0x80382f <tinyButton_start_time+0x1>
     7fe:	20 91 30 38 	lds	r18, 0x3830	; 0x803830 <tinyButton_start_time+0x2>
     802:	30 91 31 38 	lds	r19, 0x3831	; 0x803831 <tinyButton_start_time+0x3>
     806:	60 1b       	sub	r22, r16
     808:	71 0b       	sbc	r23, r17
     80a:	82 0b       	sbc	r24, r18
     80c:	93 0b       	sbc	r25, r19
     80e:	0e 94 33 0b 	call	0x1666	; 0x1666 <__floatunsisf>
     812:	20 e0       	ldi	r18, 0x00	; 0
     814:	30 e0       	ldi	r19, 0x00	; 0
     816:	48 ec       	ldi	r20, 0xC8	; 200
     818:	52 e4       	ldi	r21, 0x42	; 66
     81a:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__gesf2>
     81e:	18 16       	cp	r1, r24
     820:	7c f4       	brge	.+30     	; 0x840 <__DATA_REGION_LENGTH__+0x40>
		{
			tinyPulse_toggle_pulse_mode();
     822:	0e 94 6f 09 	call	0x12de	; 0x12de <tinyPulse_toggle_pulse_mode>
			tinyButton_start_time = tinyTime_now();
     826:	0e 94 dd 09 	call	0x13ba	; 0x13ba <tinyTime_now>
     82a:	60 93 2e 38 	sts	0x382E, r22	; 0x80382e <tinyButton_start_time>
     82e:	70 93 2f 38 	sts	0x382F, r23	; 0x80382f <tinyButton_start_time+0x1>
     832:	80 93 30 38 	sts	0x3830, r24	; 0x803830 <tinyButton_start_time+0x2>
     836:	90 93 31 38 	sts	0x3831, r25	; 0x803831 <tinyButton_start_time+0x3>
			// We don't want switching to pulse mode to count as a button press, so we ignore the next button press
			ignore_next_button_press = true;
     83a:	81 e0       	ldi	r24, 0x01	; 1
     83c:	80 93 32 38 	sts	0x3832, r24	; 0x803832 <ignore_next_button_press>
		}
	}
	if (!button_is_pushed_down && button_was_pushed_down)
     840:	cc 23       	and	r28, r28
     842:	71 f0       	breq	.+28     	; 0x860 <__DATA_REGION_LENGTH__+0x60>
     844:	80 91 34 38 	lds	r24, 0x3834	; 0x803834 <button_was_pushed_down>
     848:	88 23       	and	r24, r24
     84a:	51 f0       	breq	.+20     	; 0x860 <__DATA_REGION_LENGTH__+0x60>
	{
		if(!ignore_next_button_press){
     84c:	80 91 32 38 	lds	r24, 0x3832	; 0x803832 <ignore_next_button_press>
     850:	81 11       	cpse	r24, r1
     852:	04 c0       	rjmp	.+8      	; 0x85c <__DATA_REGION_LENGTH__+0x5c>
			button_press = true;
     854:	81 e0       	ldi	r24, 0x01	; 1
     856:	80 93 33 38 	sts	0x3833, r24	; 0x803833 <button_press>
     85a:	02 c0       	rjmp	.+4      	; 0x860 <__DATA_REGION_LENGTH__+0x60>
		}
		else{
			ignore_next_button_press = false;
     85c:	10 92 32 38 	sts	0x3832, r1	; 0x803832 <ignore_next_button_press>
		}
		
	}
	button_was_pushed_down = button_is_pushed_down;
     860:	d0 93 34 38 	sts	0x3834, r29	; 0x803834 <button_was_pushed_down>
}
     864:	df 91       	pop	r29
     866:	cf 91       	pop	r28
     868:	1f 91       	pop	r17
     86a:	0f 91       	pop	r16
     86c:	08 95       	ret

0000086e <tinyButton_update_potential>:

double tinyButton_update_potential(double potential){
	if(button_press){
     86e:	20 91 33 38 	lds	r18, 0x3833	; 0x803833 <button_press>
     872:	22 23       	and	r18, r18
     874:	31 f0       	breq	.+12     	; 0x882 <tinyButton_update_potential+0x14>
		potential += BUTTON_PRESS_REACTION;
     876:	20 e0       	ldi	r18, 0x00	; 0
     878:	30 e0       	ldi	r19, 0x00	; 0
     87a:	40 ed       	ldi	r20, 0xD0	; 208
     87c:	51 e4       	ldi	r21, 0x41	; 65
     87e:	0e 94 e7 09 	call	0x13ce	; 0x13ce <__addsf3>
	}
	return potential;
}
     882:	08 95       	ret

00000884 <tinyCharge_is_connected_to_charger>:
*/
uint8_t charge_counter = 0; 

_Bool tinyCharge_is_connected_to_charger(){
	return connected_to_charger;
}
     884:	80 91 59 38 	lds	r24, 0x3859	; 0x803859 <connected_to_charger>
     888:	08 95       	ret

0000088a <tinyCharge_is_fully_charged>:
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTB_get_pin_level(const uint8_t pin)
{
	return VPORTB.IN & (1 << pin);
     88a:	86 b1       	in	r24, 0x06	; 6

_Bool tinyCharge_is_fully_charged(){
	return CHARGING_STATUS_PIN_get_level();
}
     88c:	86 fb       	bst	r24, 6
     88e:	88 27       	eor	r24, r24
     890:	80 f9       	bld	r24, 0
     892:	08 95       	ret

00000894 <tinyCharge_DAC_dissable>:
void tinyCharge_DAC_dissable(){
	
	// We need some way to disable the DAC to prevent huge current draw when charging (64mA). When there is no code uploaded to the attiny, there is no problem.
	// We're going to try to enable the pin as a dendrite, since they seem to be doing fine. Completely uninitializing the pin probably caused a microchip to be fried.
	
	DAC_0_uninit();
     894:	0e 94 88 01 	call	0x310	; 0x310 <DAC_0_uninit>
	DAC_0_disable();
     898:	0e 94 93 01 	call	0x326	; 0x326 <DAC_0_disable>
     89c:	08 95       	ret

0000089e <tinyCharge_DAC_enable>:
void tinyCharge_DAC_enable(){
	
	// We need some way to disable the DAC to prevent huge current draw when charging (64mA). When there is no code uploaded to the attiny, there is no problem.
	// We're going to try to enable the pin as a dendrite, since they seem to be doing fine. Completely uninitializing the pin probably caused a microchip to be fried.
	
	DAC_0_init();
     89e:	0e 94 83 01 	call	0x306	; 0x306 <DAC_0_init>
	DAC_0_enable();
     8a2:	0e 94 8d 01 	call	0x31a	; 0x31a <DAC_0_enable>
     8a6:	08 95       	ret

000008a8 <tinyCharge_switch_mode>:
}


void tinyCharge_switch_mode(){
	
	if(connected_to_charger){
     8a8:	80 91 59 38 	lds	r24, 0x3859	; 0x803859 <connected_to_charger>
     8ac:	88 23       	and	r24, r24
     8ae:	89 f0       	breq	.+34     	; 0x8d2 <tinyCharge_switch_mode+0x2a>
		// Switch from main to charging mode
		
		// Set LED
		tinyLED_set_color_mode(OUT_LED, CHARGING_COLOR, SWING);
     8b0:	43 e0       	ldi	r20, 0x03	; 3
     8b2:	61 e0       	ldi	r22, 0x01	; 1
     8b4:	81 e0       	ldi	r24, 0x01	; 1
     8b6:	0e 94 77 06 	call	0xcee	; 0xcee <tinyLED_set_color_mode>
		tinyLED_set_color(INN_LED, LED_OFF);
     8ba:	60 e0       	ldi	r22, 0x00	; 0
     8bc:	80 e0       	ldi	r24, 0x00	; 0
     8be:	0e 94 9b 06 	call	0xd36	; 0xd36 <tinyLED_set_color>


		// Stop axon from firing
		// (There is a small chance that the neuron is put into charging mode as it is firing. The axon is then never told to stop firing)
		tinyAxon_stop_sending_pulse();
     8c2:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <tinyAxon_stop_sending_pulse>

		// disable DAC
		tinyCharge_DAC_dissable();
     8c6:	0e 94 4a 04 	call	0x894	; 0x894 <tinyCharge_DAC_dissable>
		
		// We also turn off pulse mode, because it's confusing if it suddenly comes on
		// after it has been charging
		tinyPulse_set_pulse_mode(false);
     8ca:	80 e0       	ldi	r24, 0x00	; 0
     8cc:	0e 94 8b 09 	call	0x1316	; 0x1316 <tinyPulse_set_pulse_mode>
     8d0:	08 95       	ret
	}
	else{
		// Switch from charge to main mode
		
		// Set LED
		tinyLED_set_color(OUT_LED, LED_OFF);
     8d2:	60 e0       	ldi	r22, 0x00	; 0
     8d4:	81 e0       	ldi	r24, 0x01	; 1
     8d6:	0e 94 9b 06 	call	0xd36	; 0xd36 <tinyLED_set_color>
		tinyLED_set_color(INN_LED, LED_OFF);
     8da:	60 e0       	ldi	r22, 0x00	; 0
     8dc:	80 e0       	ldi	r24, 0x00	; 0
     8de:	0e 94 9b 06 	call	0xd36	; 0xd36 <tinyLED_set_color>
		
		// enable DAC
		tinyCharge_DAC_enable();
     8e2:	0e 94 4f 04 	call	0x89e	; 0x89e <tinyCharge_DAC_enable>
     8e6:	08 95       	ret

000008e8 <tinyCharge_set_charging_mode>:
	}
}

void tinyCharge_set_charging_mode(_Bool charging_status){
	if(charging_status != connected_to_charger){
     8e8:	90 91 59 38 	lds	r25, 0x3859	; 0x803859 <connected_to_charger>
     8ec:	98 17       	cp	r25, r24
     8ee:	21 f0       	breq	.+8      	; 0x8f8 <tinyCharge_set_charging_mode+0x10>
		connected_to_charger = charging_status;
     8f0:	80 93 59 38 	sts	0x3859, r24	; 0x803859 <connected_to_charger>
		tinyCharge_switch_mode();
     8f4:	0e 94 54 04 	call	0x8a8	; 0x8a8 <tinyCharge_switch_mode>
     8f8:	08 95       	ret

000008fa <tinyCharge_update_charging_mode>:
*/
void tinyCharge_update_charging_mode(){
	// For complicated reasons, the axon_check_level will be high even when the charger is not connected
	// WHEN the neuron is in charging mode, hence we ignore the axon level when the neuron is in charging mode
	_Bool charging;
	if(connected_to_charger){
     8fa:	80 91 59 38 	lds	r24, 0x3859	; 0x803859 <connected_to_charger>
     8fe:	88 23       	and	r24, r24
     900:	19 f0       	breq	.+6      	; 0x908 <tinyCharge_update_charging_mode+0xe>
		charging = tinyDendrite_check_charge_level();
     902:	0e 94 2d 05 	call	0xa5a	; 0xa5a <tinyDendrite_check_charge_level>
     906:	0a c0       	rjmp	.+20     	; 0x91c <tinyCharge_update_charging_mode+0x22>
	} else{
		charging = tinyDendrite_check_charge_level() || tinyAxon_check_charge_level();
     908:	0e 94 2d 05 	call	0xa5a	; 0xa5a <tinyDendrite_check_charge_level>
     90c:	81 11       	cpse	r24, r1
     90e:	03 c0       	rjmp	.+6      	; 0x916 <tinyCharge_update_charging_mode+0x1c>
     910:	0e 94 c6 03 	call	0x78c	; 0x78c <tinyAxon_check_charge_level>
     914:	02 c0       	rjmp	.+4      	; 0x91a <tinyCharge_update_charging_mode+0x20>
     916:	81 e0       	ldi	r24, 0x01	; 1
     918:	90 e0       	ldi	r25, 0x00	; 0
     91a:	81 70       	andi	r24, 0x01	; 1
	}
	
	// In order to prevent the axon from stimulating itself, we only switch into charging mode when the conditions have been right for several cycles
	if(!connected_to_charger && charging){
     91c:	90 91 59 38 	lds	r25, 0x3859	; 0x803859 <connected_to_charger>
     920:	91 11       	cpse	r25, r1
     922:	10 c0       	rjmp	.+32     	; 0x944 <tinyCharge_update_charging_mode+0x4a>
     924:	88 23       	and	r24, r24
     926:	71 f0       	breq	.+28     	; 0x944 <tinyCharge_update_charging_mode+0x4a>
		charge_counter++;
     928:	80 91 35 38 	lds	r24, 0x3835	; 0x803835 <charge_counter>
     92c:	8f 5f       	subi	r24, 0xFF	; 255
		if(charge_counter > CYCLES_REQUIRED_FOR_CHARGING_MODE_SWITCH){
     92e:	8b 30       	cpi	r24, 0x0B	; 11
     930:	18 f4       	brcc	.+6      	; 0x938 <tinyCharge_update_charging_mode+0x3e>
		charging = tinyDendrite_check_charge_level() || tinyAxon_check_charge_level();
	}
	
	// In order to prevent the axon from stimulating itself, we only switch into charging mode when the conditions have been right for several cycles
	if(!connected_to_charger && charging){
		charge_counter++;
     932:	80 93 35 38 	sts	0x3835, r24	; 0x803835 <charge_counter>
     936:	08 95       	ret
		if(charge_counter > CYCLES_REQUIRED_FOR_CHARGING_MODE_SWITCH){
			charge_counter = 0;
     938:	10 92 35 38 	sts	0x3835, r1	; 0x803835 <charge_counter>
			tinyCharge_set_charging_mode(charging);
     93c:	81 e0       	ldi	r24, 0x01	; 1
     93e:	0e 94 74 04 	call	0x8e8	; 0x8e8 <tinyCharge_set_charging_mode>
     942:	08 95       	ret
		}
	}
	else{
		tinyCharge_set_charging_mode(charging);
     944:	0e 94 74 04 	call	0x8e8	; 0x8e8 <tinyCharge_set_charging_mode>
     948:	08 95       	ret

0000094a <tinyCharge_set_transistors>:
}



void tinyCharge_set_transistors(){
	if(connected_to_charger){
     94a:	80 91 59 38 	lds	r24, 0x3859	; 0x803859 <connected_to_charger>
     94e:	88 23       	and	r24, r24
     950:	19 f0       	breq	.+6      	; 0x958 <tinyCharge_set_transistors+0xe>
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
	} else {
		VPORTC.OUT &= ~(1 << pin);
     952:	4d 98       	cbi	0x09, 5	; 9
 *                  false = Pin level set to "low" state
 */
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
     954:	29 9a       	sbi	0x05, 1	; 5
     956:	08 95       	ret
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     958:	4d 9a       	sbi	0x09, 5	; 9
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     95a:	29 98       	cbi	0x05, 1	; 5
     95c:	08 95       	ret

0000095e <tinyDebugger_send_uint32>:
}
void tinyDebugger_send_string(const char* name, char * value){
	if(DEBUGGING){
		printf("%s:%s\t", name, value);
	}
}
     95e:	7f 93       	push	r23
     960:	6f 93       	push	r22
     962:	5f 93       	push	r21
     964:	4f 93       	push	r20
     966:	9f 93       	push	r25
     968:	8f 93       	push	r24
     96a:	8d e0       	ldi	r24, 0x0D	; 13
     96c:	96 ea       	ldi	r25, 0xA6	; 166
     96e:	9f 93       	push	r25
     970:	8f 93       	push	r24
     972:	0e 94 be 0d 	call	0x1b7c	; 0x1b7c <printf>
     976:	8d b7       	in	r24, 0x3d	; 61
     978:	9e b7       	in	r25, 0x3e	; 62
     97a:	08 96       	adiw	r24, 0x08	; 8
     97c:	8d bf       	out	0x3d, r24	; 61
     97e:	9e bf       	out	0x3e, r25	; 62
     980:	08 95       	ret

00000982 <tinyDebugger_send_uint8>:
     982:	1f 92       	push	r1
     984:	6f 93       	push	r22
     986:	9f 93       	push	r25
     988:	8f 93       	push	r24
     98a:	86 e1       	ldi	r24, 0x16	; 22
     98c:	96 ea       	ldi	r25, 0xA6	; 166
     98e:	9f 93       	push	r25
     990:	8f 93       	push	r24
     992:	0e 94 be 0d 	call	0x1b7c	; 0x1b7c <printf>
     996:	0f 90       	pop	r0
     998:	0f 90       	pop	r0
     99a:	0f 90       	pop	r0
     99c:	0f 90       	pop	r0
     99e:	0f 90       	pop	r0
     9a0:	0f 90       	pop	r0
     9a2:	08 95       	ret

000009a4 <tinyDebugger_send_double>:
     9a4:	cf 92       	push	r12
     9a6:	df 92       	push	r13
     9a8:	ef 92       	push	r14
     9aa:	ff 92       	push	r15
     9ac:	0f 93       	push	r16
     9ae:	1f 93       	push	r17
     9b0:	cf 93       	push	r28
     9b2:	df 93       	push	r29
     9b4:	cd b7       	in	r28, 0x3d	; 61
     9b6:	de b7       	in	r29, 0x3e	; 62
     9b8:	64 97       	sbiw	r28, 0x14	; 20
     9ba:	cd bf       	out	0x3d, r28	; 61
     9bc:	de bf       	out	0x3e, r29	; 62
     9be:	d8 2e       	mov	r13, r24
     9c0:	c9 2e       	mov	r12, r25
     9c2:	cb 01       	movw	r24, r22
     9c4:	ba 01       	movw	r22, r20
     9c6:	9e 01       	movw	r18, r28
     9c8:	2f 5f       	subi	r18, 0xFF	; 255
     9ca:	3f 4f       	sbci	r19, 0xFF	; 255
     9cc:	79 01       	movw	r14, r18
     9ce:	89 01       	movw	r16, r18
     9d0:	21 e0       	ldi	r18, 0x01	; 1
     9d2:	41 e0       	ldi	r20, 0x01	; 1
     9d4:	0e 94 9e 0d 	call	0x1b3c	; 0x1b3c <dtostrf>
     9d8:	ff 92       	push	r15
     9da:	ef 92       	push	r14
     9dc:	cf 92       	push	r12
     9de:	df 92       	push	r13
     9e0:	8e e1       	ldi	r24, 0x1E	; 30
     9e2:	96 ea       	ldi	r25, 0xA6	; 166
     9e4:	9f 93       	push	r25
     9e6:	8f 93       	push	r24
     9e8:	0e 94 be 0d 	call	0x1b7c	; 0x1b7c <printf>
     9ec:	0f 90       	pop	r0
     9ee:	0f 90       	pop	r0
     9f0:	0f 90       	pop	r0
     9f2:	0f 90       	pop	r0
     9f4:	0f 90       	pop	r0
     9f6:	0f 90       	pop	r0
     9f8:	64 96       	adiw	r28, 0x14	; 20
     9fa:	cd bf       	out	0x3d, r28	; 61
     9fc:	de bf       	out	0x3e, r29	; 62
     9fe:	df 91       	pop	r29
     a00:	cf 91       	pop	r28
     a02:	1f 91       	pop	r17
     a04:	0f 91       	pop	r16
     a06:	ff 90       	pop	r15
     a08:	ef 90       	pop	r14
     a0a:	df 90       	pop	r13
     a0c:	cf 90       	pop	r12
     a0e:	08 95       	ret

00000a10 <tinyDebugger_end_line>:
void tinyDebugger_end_line(){
	if(DEBUGGING){
		printf("\r\n");
     a10:	8d e2       	ldi	r24, 0x2D	; 45
     a12:	96 ea       	ldi	r25, 0xA6	; 166
     a14:	0e 94 d4 0d 	call	0x1ba8	; 0x1ba8 <puts>
     a18:	08 95       	ret

00000a1a <tinyDendrite_read_signals>:
	}
}

uint8_t tinyDendrite_get_value(uint8_t dendrite_number){
	return tinyDendrite_values[dendrite_number];
}
     a1a:	ef 92       	push	r14
     a1c:	ff 92       	push	r15
     a1e:	0f 93       	push	r16
     a20:	1f 93       	push	r17
     a22:	cf 93       	push	r28
     a24:	df 93       	push	r29
     a26:	ce e0       	ldi	r28, 0x0E	; 14
     a28:	d8 e3       	ldi	r29, 0x38	; 56
     a2a:	00 e4       	ldi	r16, 0x40	; 64
     a2c:	18 e3       	ldi	r17, 0x38	; 56
     a2e:	0f 2e       	mov	r0, r31
     a30:	f3 e1       	ldi	r31, 0x13	; 19
     a32:	ef 2e       	mov	r14, r31
     a34:	f8 e3       	ldi	r31, 0x38	; 56
     a36:	ff 2e       	mov	r15, r31
     a38:	f0 2d       	mov	r31, r0
     a3a:	89 91       	ld	r24, Y+
     a3c:	0e 94 4d 01 	call	0x29a	; 0x29a <ADC_0_get_conversion>
     a40:	f8 01       	movw	r30, r16
     a42:	81 93       	st	Z+, r24
     a44:	8f 01       	movw	r16, r30
     a46:	ce 15       	cp	r28, r14
     a48:	df 05       	cpc	r29, r15
     a4a:	b9 f7       	brne	.-18     	; 0xa3a <tinyDendrite_read_signals+0x20>
     a4c:	df 91       	pop	r29
     a4e:	cf 91       	pop	r28
     a50:	1f 91       	pop	r17
     a52:	0f 91       	pop	r16
     a54:	ff 90       	pop	r15
     a56:	ef 90       	pop	r14
     a58:	08 95       	ret

00000a5a <tinyDendrite_check_charge_level>:

_Bool tinyDendrite_check_charge_level(void)
{
     a5a:	cf 93       	push	r28
     a5c:	df 93       	push	r29
	_Bool charging = false;
	
	tinyDendrite_read_signals();
     a5e:	0e 94 0d 05 	call	0xa1a	; 0xa1a <tinyDendrite_read_signals>
     a62:	eb e3       	ldi	r30, 0x3B	; 59
     a64:	f8 e3       	ldi	r31, 0x38	; 56
     a66:	c6 e3       	ldi	r28, 0x36	; 54
     a68:	d8 e3       	ldi	r29, 0x38	; 56
     a6a:	a0 e4       	ldi	r26, 0x40	; 64
     a6c:	b8 e3       	ldi	r27, 0x38	; 56
     a6e:	20 e4       	ldi	r18, 0x40	; 64
     a70:	38 e3       	ldi	r19, 0x38	; 56
	return tinyDendrite_values[dendrite_number];
}

_Bool tinyDendrite_check_charge_level(void)
{
	_Bool charging = false;
     a72:	80 e0       	ldi	r24, 0x00	; 0
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = CHARGING;
     a74:	47 e0       	ldi	r20, 0x07	; 7
	_Bool charging = false;
	
	tinyDendrite_read_signals();
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
     a76:	90 81       	ld	r25, Z
     a78:	99 93       	st	Y+, r25
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
     a7a:	9d 91       	ld	r25, X+
     a7c:	99 3e       	cpi	r25, 0xE9	; 233
     a7e:	10 f0       	brcs	.+4      	; 0xa84 <tinyDendrite_check_charge_level+0x2a>
		{
			tinyDendrite_current_signals[i] = CHARGING;
     a80:	40 83       	st	Z, r20
			charging = true;
     a82:	81 e0       	ldi	r24, 0x01	; 1
     a84:	31 96       	adiw	r30, 0x01	; 1
_Bool tinyDendrite_check_charge_level(void)
{
	_Bool charging = false;
	
	tinyDendrite_read_signals();
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
     a86:	e2 17       	cp	r30, r18
     a88:	f3 07       	cpc	r31, r19
     a8a:	a9 f7       	brne	.-22     	; 0xa76 <tinyDendrite_check_charge_level+0x1c>
			tinyDendrite_current_signals[i] = CHARGING;
			charging = true;
		}
	}
	return charging;
}
     a8c:	df 91       	pop	r29
     a8e:	cf 91       	pop	r28
     a90:	08 95       	ret

00000a92 <tinyDendrite_update_signals>:

/*
This function converts the 8 bit value from the ADC into one of the signal types defined in DendriteSignal
*/
void tinyDendrite_update_signals(void)
{
     a92:	af 92       	push	r10
     a94:	bf 92       	push	r11
     a96:	df 92       	push	r13
     a98:	ef 92       	push	r14
     a9a:	ff 92       	push	r15
     a9c:	0f 93       	push	r16
     a9e:	1f 93       	push	r17
     aa0:	cf 93       	push	r28
     aa2:	df 93       	push	r29
	
	// This function does not read the dendrite values! Read_signals must be called somewhere prior to this function!
	// As of writing this, the update_charging_mode function in main runs check_charge_level, so 
	// the tinyDendrite_values are updated when update_signals is called later
	
	tinyDebugger_send_uint8("D1", tinyDendrite_values[0]);
     aa4:	c0 e4       	ldi	r28, 0x40	; 64
     aa6:	d8 e3       	ldi	r29, 0x38	; 56
     aa8:	68 81       	ld	r22, Y
     aaa:	8f e2       	ldi	r24, 0x2F	; 47
     aac:	96 ea       	ldi	r25, 0xA6	; 166
     aae:	0e 94 c1 04 	call	0x982	; 0x982 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D2", tinyDendrite_values[1]);
     ab2:	69 81       	ldd	r22, Y+1	; 0x01
     ab4:	82 e3       	ldi	r24, 0x32	; 50
     ab6:	96 ea       	ldi	r25, 0xA6	; 166
     ab8:	0e 94 c1 04 	call	0x982	; 0x982 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D3", tinyDendrite_values[2]);
     abc:	6a 81       	ldd	r22, Y+2	; 0x02
     abe:	85 e3       	ldi	r24, 0x35	; 53
     ac0:	96 ea       	ldi	r25, 0xA6	; 166
     ac2:	0e 94 c1 04 	call	0x982	; 0x982 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D4", tinyDendrite_values[3]);
     ac6:	6b 81       	ldd	r22, Y+3	; 0x03
     ac8:	88 e3       	ldi	r24, 0x38	; 56
     aca:	96 ea       	ldi	r25, 0xA6	; 166
     acc:	0e 94 c1 04 	call	0x982	; 0x982 <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D5", tinyDendrite_values[4]);
     ad0:	6c 81       	ldd	r22, Y+4	; 0x04
     ad2:	8b e3       	ldi	r24, 0x3B	; 59
     ad4:	96 ea       	ldi	r25, 0xA6	; 166
     ad6:	0e 94 c1 04 	call	0x982	; 0x982 <tinyDebugger_send_uint8>
     ada:	eb e3       	ldi	r30, 0x3B	; 59
     adc:	f8 e3       	ldi	r31, 0x38	; 56
     ade:	26 e3       	ldi	r18, 0x36	; 54
     ae0:	38 e3       	ldi	r19, 0x38	; 56
     ae2:	40 e4       	ldi	r20, 0x40	; 64
     ae4:	58 e3       	ldi	r21, 0x38	; 56
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     ae6:	dd 24       	eor	r13, r13
     ae8:	d3 94       	inc	r13
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
		}
		else if (tinyDendrite_values[i] > HIGH_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
     aea:	0f 2e       	mov	r0, r31
     aec:	f3 e0       	ldi	r31, 0x03	; 3
     aee:	ef 2e       	mov	r14, r31
     af0:	f0 2d       	mov	r31, r0
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     af2:	68 94       	set
     af4:	ff 24       	eor	r15, r15
     af6:	f1 f8       	bld	r15, 1
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     af8:	04 e0       	ldi	r16, 0x04	; 4
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     afa:	16 e0       	ldi	r17, 0x06	; 6
			// been moved to tinyDendrite_check_charging.
			//charging = true;
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     afc:	75 e0       	ldi	r23, 0x05	; 5
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = CHARGING;
     afe:	67 e0       	ldi	r22, 0x07	; 7
     b00:	5f 01       	movw	r10, r30
	tinyDebugger_send_uint8("D4", tinyDendrite_values[3]);
	tinyDebugger_send_uint8("D5", tinyDendrite_values[4]);
	
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
     b02:	80 81       	ld	r24, Z
     b04:	d9 01       	movw	r26, r18
     b06:	8d 93       	st	X+, r24
     b08:	9d 01       	movw	r18, r26
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
     b0a:	99 91       	ld	r25, Y+
     b0c:	99 3e       	cpi	r25, 0xE9	; 233
     b0e:	10 f0       	brcs	.+4      	; 0xb14 <tinyDendrite_update_signals+0x82>
		{
			tinyDendrite_current_signals[i] = CHARGING;
     b10:	60 83       	st	Z, r22
     b12:	19 c0       	rjmp	.+50     	; 0xb46 <tinyDendrite_update_signals+0xb4>
			// Previously, we used this function to check charging, but this has now
			// been moved to tinyDendrite_check_charging.
			//charging = true;
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
     b14:	98 3c       	cpi	r25, 0xC8	; 200
     b16:	10 f0       	brcs	.+4      	; 0xb1c <tinyDendrite_update_signals+0x8a>
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     b18:	70 83       	st	Z, r23
     b1a:	15 c0       	rjmp	.+42     	; 0xb46 <tinyDendrite_update_signals+0xb4>
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
     b1c:	97 3a       	cpi	r25, 0xA7	; 167
     b1e:	10 f0       	brcs	.+4      	; 0xb24 <tinyDendrite_update_signals+0x92>
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     b20:	10 83       	st	Z, r17
     b22:	11 c0       	rjmp	.+34     	; 0xb46 <tinyDendrite_update_signals+0xb4>
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
     b24:	95 38       	cpi	r25, 0x85	; 133
     b26:	10 f0       	brcs	.+4      	; 0xb2c <tinyDendrite_update_signals+0x9a>
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     b28:	00 83       	st	Z, r16
     b2a:	0d c0       	rjmp	.+26     	; 0xb46 <tinyDendrite_update_signals+0xb4>
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
     b2c:	94 36       	cpi	r25, 0x64	; 100
     b2e:	10 f0       	brcs	.+4      	; 0xb34 <tinyDendrite_update_signals+0xa2>
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     b30:	f0 82       	st	Z, r15
     b32:	09 c0       	rjmp	.+18     	; 0xb46 <tinyDendrite_update_signals+0xb4>
		}
		else if (tinyDendrite_values[i] > HIGH_INHIB_THRESHOLD)
     b34:	93 34       	cpi	r25, 0x43	; 67
     b36:	10 f0       	brcs	.+4      	; 0xb3c <tinyDendrite_update_signals+0xaa>
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
     b38:	e0 82       	st	Z, r14
     b3a:	05 c0       	rjmp	.+10     	; 0xb46 <tinyDendrite_update_signals+0xb4>
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
     b3c:	92 32       	cpi	r25, 0x22	; 34
     b3e:	10 f0       	brcs	.+4      	; 0xb44 <tinyDendrite_update_signals+0xb2>
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     b40:	d0 82       	st	Z, r13
     b42:	01 c0       	rjmp	.+2      	; 0xb46 <tinyDendrite_update_signals+0xb4>
		}
		else
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     b44:	10 82       	st	Z, r1
		}
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
     b46:	d5 01       	movw	r26, r10
     b48:	9c 91       	ld	r25, X
     b4a:	89 13       	cpse	r24, r25
     b4c:	01 c0       	rjmp	.+2      	; 0xb50 <tinyDendrite_update_signals+0xbe>
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     b4e:	1c 92       	st	X, r1
     b50:	31 96       	adiw	r30, 0x01	; 1
	tinyDebugger_send_uint8("D2", tinyDendrite_values[1]);
	tinyDebugger_send_uint8("D3", tinyDendrite_values[2]);
	tinyDebugger_send_uint8("D4", tinyDendrite_values[3]);
	tinyDebugger_send_uint8("D5", tinyDendrite_values[4]);
	
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
     b52:	e4 17       	cp	r30, r20
     b54:	f5 07       	cpc	r31, r21
     b56:	a1 f6       	brne	.-88     	; 0xb00 <tinyDendrite_update_signals+0x6e>
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
		}
	}
}
     b58:	df 91       	pop	r29
     b5a:	cf 91       	pop	r28
     b5c:	1f 91       	pop	r17
     b5e:	0f 91       	pop	r16
     b60:	ff 90       	pop	r15
     b62:	ef 90       	pop	r14
     b64:	df 90       	pop	r13
     b66:	bf 90       	pop	r11
     b68:	af 90       	pop	r10
     b6a:	08 95       	ret

00000b6c <tinyDendrite_get_potential>:
/*
This is the master function of the module that is callable from
outside. It uses the previously declared functions to return the potential.
*/
int16_t tinyDendrite_get_potential()
{
     b6c:	ef 92       	push	r14
     b6e:	ff 92       	push	r15
     b70:	0f 93       	push	r16
     b72:	1f 93       	push	r17
     b74:	cf 93       	push	r28
     b76:	df 93       	push	r29
	if(tinyAxon_is_firing() && IGNORE_INPUT_WHILE_FIRING){
     b78:	0e 94 ce 02 	call	0x59c	; 0x59c <tinyAxon_is_firing>
		
		return NO_SIGNAL_REACTION;
	}
	
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
     b7c:	0e 94 49 05 	call	0xa92	; 0xa92 <tinyDendrite_update_signals>
     b80:	cb e3       	ldi	r28, 0x3B	; 59
     b82:	d8 e3       	ldi	r29, 0x38	; 56
     b84:	0f 2e       	mov	r0, r31
     b86:	f0 e4       	ldi	r31, 0x40	; 64
     b88:	ef 2e       	mov	r14, r31
     b8a:	f8 e3       	ldi	r31, 0x38	; 56
     b8c:	ff 2e       	mov	r15, r31
     b8e:	f0 2d       	mov	r31, r0
	
	int16_t return_potential_val = 0;
     b90:	00 e0       	ldi	r16, 0x00	; 0
     b92:	10 e0       	ldi	r17, 0x00	; 0
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
	{
		switch(tinyDendrite_current_signals[i])
     b94:	89 91       	ld	r24, Y+
     b96:	83 30       	cpi	r24, 0x03	; 3
     b98:	19 f1       	breq	.+70     	; 0xbe0 <tinyDendrite_get_potential+0x74>
     b9a:	28 f4       	brcc	.+10     	; 0xba6 <tinyDendrite_get_potential+0x3a>
     b9c:	81 30       	cpi	r24, 0x01	; 1
     b9e:	81 f1       	breq	.+96     	; 0xc00 <tinyDendrite_get_potential+0x94>
     ba0:	82 30       	cpi	r24, 0x02	; 2
     ba2:	31 f1       	breq	.+76     	; 0xbf0 <tinyDendrite_get_potential+0x84>
     ba4:	34 c0       	rjmp	.+104    	; 0xc0e <tinyDendrite_get_potential+0xa2>
     ba6:	85 30       	cpi	r24, 0x05	; 5
     ba8:	59 f0       	breq	.+22     	; 0xbc0 <tinyDendrite_get_potential+0x54>
     baa:	90 f0       	brcs	.+36     	; 0xbd0 <tinyDendrite_get_potential+0x64>
     bac:	86 30       	cpi	r24, 0x06	; 6
     bae:	79 f5       	brne	.+94     	; 0xc0e <tinyDendrite_get_potential+0xa2>
		{
			case NO_SIGNAL:
				return_potential_val += NO_SIGNAL_REACTION;
				break;
			case HIGH_EXCITE:
				return_potential_val += HIGH_EXCITE_REACTION;
     bb0:	0c 5c       	subi	r16, 0xCC	; 204
     bb2:	1f 4f       	sbci	r17, 0xFF	; 255
				tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
     bb4:	45 e0       	ldi	r20, 0x05	; 5
     bb6:	63 e0       	ldi	r22, 0x03	; 3
     bb8:	80 e0       	ldi	r24, 0x00	; 0
     bba:	0e 94 77 06 	call	0xcee	; 0xcee <tinyLED_set_color_mode>
				break;
     bbe:	27 c0       	rjmp	.+78     	; 0xc0e <tinyDendrite_get_potential+0xa2>
			case NORMAL_EXCITE:
				return_potential_val += NORMAL_EXCITE_REACTION;
     bc0:	07 5e       	subi	r16, 0xE7	; 231
     bc2:	1f 4f       	sbci	r17, 0xFF	; 255
				tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
     bc4:	45 e0       	ldi	r20, 0x05	; 5
     bc6:	63 e0       	ldi	r22, 0x03	; 3
     bc8:	80 e0       	ldi	r24, 0x00	; 0
     bca:	0e 94 77 06 	call	0xcee	; 0xcee <tinyLED_set_color_mode>
				break;
     bce:	1f c0       	rjmp	.+62     	; 0xc0e <tinyDendrite_get_potential+0xa2>
			case LOW_EXCITE:
				return_potential_val += LOW_EXCITE_REACTION;
     bd0:	0c 5e       	subi	r16, 0xEC	; 236
     bd2:	1f 4f       	sbci	r17, 0xFF	; 255
				tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
     bd4:	45 e0       	ldi	r20, 0x05	; 5
     bd6:	63 e0       	ldi	r22, 0x03	; 3
     bd8:	80 e0       	ldi	r24, 0x00	; 0
     bda:	0e 94 77 06 	call	0xcee	; 0xcee <tinyLED_set_color_mode>
				break;
     bde:	17 c0       	rjmp	.+46     	; 0xc0e <tinyDendrite_get_potential+0xa2>
			case HIGH_INHIB:
				return_potential_val += HIGH_INHIB_REACTION;
     be0:	02 53       	subi	r16, 0x32	; 50
     be2:	11 09       	sbc	r17, r1
				tinyLED_set_color_mode(INN_LED, RED, FLASH_ONCE);
     be4:	45 e0       	ldi	r20, 0x05	; 5
     be6:	61 e0       	ldi	r22, 0x01	; 1
     be8:	80 e0       	ldi	r24, 0x00	; 0
     bea:	0e 94 77 06 	call	0xcee	; 0xcee <tinyLED_set_color_mode>
				break;
     bee:	0f c0       	rjmp	.+30     	; 0xc0e <tinyDendrite_get_potential+0xa2>
			case NORMAL_INHIB:
				return_potential_val += NORMAL_INHIB_REACTION;
     bf0:	09 51       	subi	r16, 0x19	; 25
     bf2:	11 09       	sbc	r17, r1
				tinyLED_set_color_mode(INN_LED, RED, FLASH_ONCE);
     bf4:	45 e0       	ldi	r20, 0x05	; 5
     bf6:	61 e0       	ldi	r22, 0x01	; 1
     bf8:	80 e0       	ldi	r24, 0x00	; 0
     bfa:	0e 94 77 06 	call	0xcee	; 0xcee <tinyLED_set_color_mode>
				break;
     bfe:	07 c0       	rjmp	.+14     	; 0xc0e <tinyDendrite_get_potential+0xa2>
			case LOW_INHIB:
				return_potential_val += LOW_INHIB_REACTION;
     c00:	04 51       	subi	r16, 0x14	; 20
     c02:	11 09       	sbc	r17, r1
				tinyLED_set_color_mode(INN_LED, RED, FLASH_ONCE);
     c04:	45 e0       	ldi	r20, 0x05	; 5
     c06:	61 e0       	ldi	r22, 0x01	; 1
     c08:	80 e0       	ldi	r24, 0x00	; 0
     c0a:	0e 94 77 06 	call	0xcee	; 0xcee <tinyLED_set_color_mode>
	
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
	
	int16_t return_potential_val = 0;
	for (uint8_t i = 0; i < DENDRITE_COUNT; i++)
     c0e:	ce 15       	cp	r28, r14
     c10:	df 05       	cpc	r29, r15
     c12:	09 f0       	breq	.+2      	; 0xc16 <tinyDendrite_get_potential+0xaa>
     c14:	bf cf       	rjmp	.-130    	; 0xb94 <tinyDendrite_get_potential+0x28>
		}
	}
	
	return return_potential_val;
	
}
     c16:	c8 01       	movw	r24, r16
     c18:	df 91       	pop	r29
     c1a:	cf 91       	pop	r28
     c1c:	1f 91       	pop	r17
     c1e:	0f 91       	pop	r16
     c20:	ff 90       	pop	r15
     c22:	ef 90       	pop	r14
     c24:	08 95       	ret

00000c26 <tinyDendrite_update_potential>:

double tinyDendrite_update_potential(double potential){
     c26:	cf 92       	push	r12
     c28:	df 92       	push	r13
     c2a:	ef 92       	push	r14
     c2c:	ff 92       	push	r15
     c2e:	6b 01       	movw	r12, r22
     c30:	7c 01       	movw	r14, r24
	
	int16_t potential_change = tinyDendrite_get_potential();
     c32:	0e 94 b6 05 	call	0xb6c	; 0xb6c <tinyDendrite_get_potential>
	potential += potential_change;
	return potential;
     c36:	bc 01       	movw	r22, r24
     c38:	99 0f       	add	r25, r25
     c3a:	88 0b       	sbc	r24, r24
     c3c:	99 0b       	sbc	r25, r25
     c3e:	0e 94 35 0b 	call	0x166a	; 0x166a <__floatsisf>
     c42:	a7 01       	movw	r20, r14
     c44:	96 01       	movw	r18, r12
     c46:	0e 94 e7 09 	call	0x13ce	; 0x13ce <__addsf3>
     c4a:	ff 90       	pop	r15
     c4c:	ef 90       	pop	r14
     c4e:	df 90       	pop	r13
     c50:	cf 90       	pop	r12
     c52:	08 95       	ret

00000c54 <__vector_6>:
This function is called every time the RTC (Real Time Clock) counter overflows.
With the current settings, it will be called every ms.
The RTC clock runs at 1kHz, and the number of cycles before overflow is set with RTC.PER = someHexValue (e.g. 0x20) in src/rtc.c
*/
ISR(RTC_CNT_vect)
{
     c54:	1f 92       	push	r1
     c56:	0f 92       	push	r0
     c58:	0f b6       	in	r0, 0x3f	; 63
     c5a:	0f 92       	push	r0
     c5c:	11 24       	eor	r1, r1
     c5e:	2f 93       	push	r18
     c60:	3f 93       	push	r19
     c62:	4f 93       	push	r20
     c64:	5f 93       	push	r21
     c66:	6f 93       	push	r22
     c68:	7f 93       	push	r23
     c6a:	8f 93       	push	r24
     c6c:	9f 93       	push	r25
     c6e:	af 93       	push	r26
     c70:	bf 93       	push	r27
     c72:	cf 93       	push	r28
     c74:	ef 93       	push	r30
     c76:	ff 93       	push	r31
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     c78:	c1 e0       	ldi	r28, 0x01	; 1
     c7a:	c0 93 45 38 	sts	0x3845, r28	; 0x803845 <tinyISR_interrupt_flag>
{
	// Set flag to let main loop run a new cycle
	tinyISR_setflag(true);
	
	// Timer counter incrementation
	tinyTime_counter_increment();
     c7e:	0e 94 c9 09 	call	0x1392	; 0x1392 <tinyTime_counter_increment>

	/* Overflow interrupt flag has to be cleared manually */
	RTC.INTFLAGS = RTC_OVF_bm;
     c82:	c0 93 43 01 	sts	0x0143, r28	; 0x800143 <__RODATA_PM_OFFSET__+0x7f8143>
}
     c86:	ff 91       	pop	r31
     c88:	ef 91       	pop	r30
     c8a:	cf 91       	pop	r28
     c8c:	bf 91       	pop	r27
     c8e:	af 91       	pop	r26
     c90:	9f 91       	pop	r25
     c92:	8f 91       	pop	r24
     c94:	7f 91       	pop	r23
     c96:	6f 91       	pop	r22
     c98:	5f 91       	pop	r21
     c9a:	4f 91       	pop	r20
     c9c:	3f 91       	pop	r19
     c9e:	2f 91       	pop	r18
     ca0:	0f 90       	pop	r0
     ca2:	0f be       	out	0x3f, r0	; 63
     ca4:	0f 90       	pop	r0
     ca6:	1f 90       	pop	r1
     ca8:	18 95       	reti

00000caa <tinyISR_setflag>:
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     caa:	80 93 45 38 	sts	0x3845, r24	; 0x803845 <tinyISR_interrupt_flag>
     cae:	08 95       	ret

00000cb0 <tinyISR_getflag>:
}

_Bool tinyISR_getflag(void)
{
	return tinyISR_interrupt_flag;
}
     cb0:	80 91 45 38 	lds	r24, 0x3845	; 0x803845 <tinyISR_interrupt_flag>
     cb4:	08 95       	ret

00000cb6 <tinyLED_SPIWriteByte>:
Function used to send a byte over SPI, which in turn gets
translated to the bit-sequence required by the LEDs over the CCL.
*/
static void tinyLED_SPIWriteByte(uint8_t byte)
{
	SPI0.INTFLAGS = SPI0_INTFLAGS; // clear the write collision flag to allow writing
     cb6:	90 91 23 08 	lds	r25, 0x0823	; 0x800823 <__RODATA_PM_OFFSET__+0x7f8823>
     cba:	90 93 23 08 	sts	0x0823, r25	; 0x800823 <__RODATA_PM_OFFSET__+0x7f8823>
	TCA0.SINGLE.CNT = 0; // reset TCA counter register to ensure the first rising edge of the PWM is predictable
     cbe:	e0 e0       	ldi	r30, 0x00	; 0
     cc0:	fa e0       	ldi	r31, 0x0A	; 10
     cc2:	10 a2       	std	Z+32, r1	; 0x20
     cc4:	11 a2       	std	Z+33, r1	; 0x21
	
	// start TCA
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 1 << TCA_SPLIT_ENABLE_bp;
     cc6:	91 e0       	ldi	r25, 0x01	; 1
     cc8:	90 83       	st	Z, r25
	SPI0_DATA = byte;
     cca:	80 93 24 08 	sts	0x0824, r24	; 0x800824 <__RODATA_PM_OFFSET__+0x7f8824>

	while((SPI0.INTFLAGS & SPI_RXCIE_bm) == 0){} // wait for transfer to complete
     cce:	e0 e2       	ldi	r30, 0x20	; 32
     cd0:	f8 e0       	ldi	r31, 0x08	; 8
     cd2:	83 81       	ldd	r24, Z+3	; 0x03
     cd4:	88 23       	and	r24, r24
     cd6:	ec f7       	brge	.-6      	; 0xcd2 <tinyLED_SPIWriteByte+0x1c>
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 0 << TCA_SPLIT_ENABLE_bp; //Stop TCA
     cd8:	10 92 00 0a 	sts	0x0A00, r1	; 0x800a00 <__RODATA_PM_OFFSET__+0x7f8a00>
     cdc:	08 95       	ret

00000cde <tinyLED_get_color>:
	tinyLED_set_color_mode(LED_id, color, STABLE);
}

enum Colors tinyLED_get_color(uint8_t LED_id)
{
	return tinyLED_settings[LED_id].color;
     cde:	e8 2f       	mov	r30, r24
     ce0:	f0 e0       	ldi	r31, 0x00	; 0
     ce2:	ee 0f       	add	r30, r30
     ce4:	ff 1f       	adc	r31, r31
     ce6:	ee 59       	subi	r30, 0x9E	; 158
     ce8:	f7 4c       	sbci	r31, 0xC7	; 199
}
     cea:	80 81       	ld	r24, Z
     cec:	08 95       	ret

00000cee <tinyLED_set_color_mode>:
{
	// If we are in pulse mode, we want to stay in pulse mode after we have flashed a light.
	// We do this by storing the previous mode in old settings.
	// However, it can happen that two flashes comes very quickly after one another, that leads
	// to an infinite flash loop, therefore, we only store the settings if it is not flash mode.
	if(tinyLED_settings[LED_id].mode != FLASH_ONCE){
     cee:	90 e0       	ldi	r25, 0x00	; 0
     cf0:	fc 01       	movw	r30, r24
     cf2:	ee 0f       	add	r30, r30
     cf4:	ff 1f       	adc	r31, r31
     cf6:	ee 59       	subi	r30, 0x9E	; 158
     cf8:	f7 4c       	sbci	r31, 0xC7	; 199
     cfa:	51 81       	ldd	r21, Z+1	; 0x01
     cfc:	55 30       	cpi	r21, 0x05	; 5
     cfe:	61 f0       	breq	.+24     	; 0xd18 <tinyLED_set_color_mode+0x2a>
		// We use two lines to avoid pointer trouble. (I'm not good with pointers)
		tinyLED_old_settings[LED_id].color = tinyLED_settings[LED_id].color;
     d00:	9c 01       	movw	r18, r24
     d02:	22 0f       	add	r18, r18
     d04:	33 1f       	adc	r19, r19
     d06:	f9 01       	movw	r30, r18
     d08:	ea 59       	subi	r30, 0x9A	; 154
     d0a:	f7 4c       	sbci	r31, 0xC7	; 199
     d0c:	d9 01       	movw	r26, r18
     d0e:	ae 59       	subi	r26, 0x9E	; 158
     d10:	b7 4c       	sbci	r27, 0xC7	; 199
     d12:	2c 91       	ld	r18, X
     d14:	20 83       	st	Z, r18
		tinyLED_old_settings[LED_id].mode = tinyLED_settings[LED_id].mode;
     d16:	51 83       	std	Z+1, r21	; 0x01
	}
	
	struct ColorSetting setting = {.color=color, .mode=mode};
	tinyLED_settings[LED_id] = setting;
     d18:	fc 01       	movw	r30, r24
     d1a:	ee 0f       	add	r30, r30
     d1c:	ff 1f       	adc	r31, r31
     d1e:	ee 59       	subi	r30, 0x9E	; 158
     d20:	f7 4c       	sbci	r31, 0xC7	; 199
     d22:	60 83       	st	Z, r22
     d24:	41 83       	std	Z+1, r20	; 0x01
	if (mode == FLASH_ONCE)
     d26:	45 30       	cpi	r20, 0x05	; 5
     d28:	29 f4       	brne	.+10     	; 0xd34 <tinyLED_set_color_mode+0x46>
	{
		tinyLED_flash_once_time[LED_id] = 1000*FLASH_TIME;
     d2a:	fc 01       	movw	r30, r24
     d2c:	e6 5a       	subi	r30, 0xA6	; 166
     d2e:	f7 4c       	sbci	r31, 0xC7	; 199
     d30:	2a e0       	ldi	r18, 0x0A	; 10
     d32:	20 83       	st	Z, r18
     d34:	08 95       	ret

00000d36 <tinyLED_set_color>:
/*
changes the values in the variables stored in the LED-array.
*/
void tinyLED_set_color(uint8_t LED_id, enum Colors color)
{
	tinyLED_set_color_mode(LED_id, color, STABLE);
     d36:	40 e0       	ldi	r20, 0x00	; 0
     d38:	0e 94 77 06 	call	0xcee	; 0xcee <tinyLED_set_color_mode>
     d3c:	08 95       	ret

00000d3e <tinyLED_RGB_Color_Compare>:
	return rgb_color;
			
};
// This might be cause of strange light behavior?
//Message		expected 'struct RGB_Color *' but argument is of type 'struct RGB_Color (*)[2]'	Hjernebyggesett_V4	C:\Users\Elias Lundheim\Documents\GitHub\neural\Hjernebyggesett_V4\Hjernebyggesett_V4\tinyLED\tinyLED.c	121
_Bool tinyLED_RGB_Color_Compare(struct RGB_Color (*a)[NUMBER_OF_LEDS], struct RGB_Color (*b)[NUMBER_OF_LEDS]){
     d3e:	dc 01       	movw	r26, r24
     d40:	fb 01       	movw	r30, r22
	for (int i=0; i<NUMBER_OF_LEDS; i++)
	{
		if(!((*a)[i].red==(*b)[i].red && (*a)[i].green==(*b)[i].green && (*a)[i].blue==(*b)[i].blue)){
     d42:	9c 91       	ld	r25, X
     d44:	80 81       	ld	r24, Z
     d46:	98 13       	cpse	r25, r24
     d48:	20 c0       	rjmp	.+64     	; 0xd8a <tinyLED_RGB_Color_Compare+0x4c>
     d4a:	11 96       	adiw	r26, 0x01	; 1
     d4c:	9c 91       	ld	r25, X
     d4e:	11 97       	sbiw	r26, 0x01	; 1
     d50:	81 81       	ldd	r24, Z+1	; 0x01
     d52:	98 13       	cpse	r25, r24
     d54:	1c c0       	rjmp	.+56     	; 0xd8e <tinyLED_RGB_Color_Compare+0x50>
     d56:	12 96       	adiw	r26, 0x02	; 2
     d58:	9c 91       	ld	r25, X
     d5a:	12 97       	sbiw	r26, 0x02	; 2
     d5c:	82 81       	ldd	r24, Z+2	; 0x02
     d5e:	98 13       	cpse	r25, r24
     d60:	18 c0       	rjmp	.+48     	; 0xd92 <tinyLED_RGB_Color_Compare+0x54>
     d62:	13 96       	adiw	r26, 0x03	; 3
     d64:	9c 91       	ld	r25, X
     d66:	13 97       	sbiw	r26, 0x03	; 3
     d68:	83 81       	ldd	r24, Z+3	; 0x03
     d6a:	98 13       	cpse	r25, r24
     d6c:	14 c0       	rjmp	.+40     	; 0xd96 <tinyLED_RGB_Color_Compare+0x58>
     d6e:	14 96       	adiw	r26, 0x04	; 4
     d70:	9c 91       	ld	r25, X
     d72:	14 97       	sbiw	r26, 0x04	; 4
     d74:	84 81       	ldd	r24, Z+4	; 0x04
     d76:	98 13       	cpse	r25, r24
     d78:	10 c0       	rjmp	.+32     	; 0xd9a <tinyLED_RGB_Color_Compare+0x5c>
     d7a:	81 e0       	ldi	r24, 0x01	; 1
     d7c:	15 96       	adiw	r26, 0x05	; 5
     d7e:	2c 91       	ld	r18, X
     d80:	95 81       	ldd	r25, Z+5	; 0x05
     d82:	29 17       	cp	r18, r25
     d84:	59 f0       	breq	.+22     	; 0xd9c <tinyLED_RGB_Color_Compare+0x5e>
     d86:	80 e0       	ldi	r24, 0x00	; 0
     d88:	08 95       	ret
			return false;
     d8a:	80 e0       	ldi	r24, 0x00	; 0
     d8c:	08 95       	ret
     d8e:	80 e0       	ldi	r24, 0x00	; 0
     d90:	08 95       	ret
     d92:	80 e0       	ldi	r24, 0x00	; 0
     d94:	08 95       	ret
     d96:	80 e0       	ldi	r24, 0x00	; 0
     d98:	08 95       	ret
     d9a:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	return true;
}
     d9c:	08 95       	ret

00000d9e <tinyLED_update>:
/*
function to write the current LED-array on to the LEDs and
effectively update the values stored in the LEDs to the values stored in the MCU.
*/
void tinyLED_update(void)
{
     d9e:	2f 92       	push	r2
     da0:	3f 92       	push	r3
     da2:	4f 92       	push	r4
     da4:	5f 92       	push	r5
     da6:	6f 92       	push	r6
     da8:	7f 92       	push	r7
     daa:	8f 92       	push	r8
     dac:	9f 92       	push	r9
     dae:	af 92       	push	r10
     db0:	bf 92       	push	r11
     db2:	cf 92       	push	r12
     db4:	df 92       	push	r13
     db6:	ef 92       	push	r14
     db8:	ff 92       	push	r15
     dba:	0f 93       	push	r16
     dbc:	1f 93       	push	r17
     dbe:	cf 93       	push	r28
     dc0:	df 93       	push	r29
     dc2:	cd b7       	in	r28, 0x3d	; 61
     dc4:	de b7       	in	r29, 0x3e	; 62
     dc6:	6f 97       	sbiw	r28, 0x1f	; 31
     dc8:	cd bf       	out	0x3d, r28	; 61
     dca:	de bf       	out	0x3e, r29	; 62
			
	uint32_t now = tinyTime_now();
     dcc:	0e 94 dd 09 	call	0x13ba	; 0x13ba <tinyTime_now>
     dd0:	6b 01       	movw	r12, r22
     dd2:	7c 01       	movw	r14, r24
	
	// This is a sin curve, but between 0 and 1 instead of -1 and 1
	double sinValue = 0.5+sin((double)now/(100*M_PI/SWING_RATE))/2;
     dd4:	0e 94 33 0b 	call	0x1666	; 0x1666 <__floatunsisf>
     dd8:	22 ed       	ldi	r18, 0xD2	; 210
     dda:	33 e5       	ldi	r19, 0x53	; 83
     ddc:	4b ef       	ldi	r20, 0xFB	; 251
     dde:	51 e4       	ldi	r21, 0x41	; 65
     de0:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <__divsf3>
     de4:	0e 94 13 0d 	call	0x1a26	; 0x1a26 <sin>
     de8:	20 e0       	ldi	r18, 0x00	; 0
     dea:	30 e0       	ldi	r19, 0x00	; 0
     dec:	40 e0       	ldi	r20, 0x00	; 0
     dee:	5f e3       	ldi	r21, 0x3F	; 63
     df0:	0e 94 a6 0c 	call	0x194c	; 0x194c <__mulsf3>
     df4:	20 e0       	ldi	r18, 0x00	; 0
     df6:	30 e0       	ldi	r19, 0x00	; 0
     df8:	40 e0       	ldi	r20, 0x00	; 0
     dfa:	5f e3       	ldi	r21, 0x3F	; 63
     dfc:	0e 94 e7 09 	call	0x13ce	; 0x13ce <__addsf3>
     e00:	6f 83       	std	Y+7, r22	; 0x07
     e02:	78 87       	std	Y+8, r23	; 0x08
     e04:	89 87       	std	Y+9, r24	; 0x09
     e06:	9a 87       	std	Y+10, r25	; 0x0a
	
	// If FLASH_RATE is one, then that means that the left side of the "<" will just count from 0 to 1000, and flash_on will be true for half of the time
	_Bool flash_on = now%(uint32_t)(1000/FLASH_RATE)  <   500/FLASH_RATE;
     e08:	c7 01       	movw	r24, r14
     e0a:	b6 01       	movw	r22, r12
     e0c:	22 e3       	ldi	r18, 0x32	; 50
     e0e:	30 e0       	ldi	r19, 0x00	; 0
     e10:	40 e0       	ldi	r20, 0x00	; 0
     e12:	50 e0       	ldi	r21, 0x00	; 0
     e14:	0e 94 7c 0d 	call	0x1af8	; 0x1af8 <__udivmodsi4>
     e18:	0e 94 33 0b 	call	0x1666	; 0x1666 <__floatunsisf>
     e1c:	20 e0       	ldi	r18, 0x00	; 0
     e1e:	30 e0       	ldi	r19, 0x00	; 0
     e20:	48 ec       	ldi	r20, 0xC8	; 200
     e22:	51 e4       	ldi	r21, 0x41	; 65
     e24:	0e 94 53 0a 	call	0x14a6	; 0x14a6 <__cmpsf2>
     e28:	88 1f       	adc	r24, r24
     e2a:	88 27       	eor	r24, r24
     e2c:	88 1f       	adc	r24, r24
     e2e:	8b 87       	std	Y+11, r24	; 0x0b
	
	// PING_RATE is usually small, so the left side counts to some large number. Since flash_time usually is also quite small,
	// the left side will usually be larger than the right
	_Bool ping_on =  now%(uint32_t)(1000/PING_RATE)   <   1000*FLASH_TIME;
     e30:	c7 01       	movw	r24, r14
     e32:	b6 01       	movw	r22, r12
     e34:	24 ef       	ldi	r18, 0xF4	; 244
     e36:	31 e0       	ldi	r19, 0x01	; 1
     e38:	40 e0       	ldi	r20, 0x00	; 0
     e3a:	50 e0       	ldi	r21, 0x00	; 0
     e3c:	0e 94 7c 0d 	call	0x1af8	; 0x1af8 <__udivmodsi4>
     e40:	0e 94 33 0b 	call	0x1666	; 0x1666 <__floatunsisf>
     e44:	20 e0       	ldi	r18, 0x00	; 0
     e46:	30 e0       	ldi	r19, 0x00	; 0
     e48:	40 e2       	ldi	r20, 0x20	; 32
     e4a:	51 e4       	ldi	r21, 0x41	; 65
     e4c:	0e 94 53 0a 	call	0x14a6	; 0x14a6 <__cmpsf2>
     e50:	88 1f       	adc	r24, r24
     e52:	88 27       	eor	r24, r24
     e54:	88 1f       	adc	r24, r24
     e56:	0f 2e       	mov	r0, r31
     e58:	f2 e6       	ldi	r31, 0x62	; 98
     e5a:	2f 2e       	mov	r2, r31
     e5c:	f8 e3       	ldi	r31, 0x38	; 56
     e5e:	3f 2e       	mov	r3, r31
     e60:	f0 2d       	mov	r31, r0
     e62:	9e 01       	movw	r18, r28
     e64:	2f 5f       	subi	r18, 0xFF	; 255
     e66:	3f 4f       	sbci	r19, 0xFF	; 255
     e68:	69 01       	movw	r12, r18
     e6a:	0f 2e       	mov	r0, r31
     e6c:	f6 e6       	ldi	r31, 0x66	; 102
     e6e:	af 2e       	mov	r10, r31
     e70:	f8 e3       	ldi	r31, 0x38	; 56
     e72:	bf 2e       	mov	r11, r31
     e74:	f0 2d       	mov	r31, r0
     e76:	0a e5       	ldi	r16, 0x5A	; 90
     e78:	18 e3       	ldi	r17, 0x38	; 56
     e7a:	0f 2e       	mov	r0, r31
     e7c:	f6 e6       	ldi	r31, 0x66	; 102
     e7e:	4f 2e       	mov	r4, r31
     e80:	f8 e3       	ldi	r31, 0x38	; 56
     e82:	5f 2e       	mov	r5, r31
     e84:	f0 2d       	mov	r31, r0
     e86:	39 01       	movw	r6, r18
			case SWING:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*sinValue, rgb_colors[i].green*sinValue, rgb_colors[i].blue*sinValue};
				break;
			case PING:
				// in the line below, fmin will either return 1 or 0, so each rgb color is either 0 or 255*PING_BRIGHTNESS
				rgb_colors[i] = (struct RGB_Color){255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].red)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].green)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].blue)*ping_on};
     e88:	28 2f       	mov	r18, r24
     e8a:	30 e0       	ldi	r19, 0x00	; 0
     e8c:	40 e0       	ldi	r20, 0x00	; 0
     e8e:	50 e0       	ldi	r21, 0x00	; 0
     e90:	28 8b       	std	Y+16, r18	; 0x10
     e92:	39 8b       	std	Y+17, r19	; 0x11
     e94:	4a 8b       	std	Y+18, r20	; 0x12
     e96:	5b 8b       	std	Y+19, r21	; 0x13
     e98:	f1 01       	movw	r30, r2
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 0 << TCA_SPLIT_ENABLE_bp; //Stop TCA
}

static struct RGB_Color tinyLED_enum_to_RGB_Color(enum Colors color){
	struct RGB_Color rgb_color;
	switch(color)
     e9a:	80 81       	ld	r24, Z
     e9c:	83 30       	cpi	r24, 0x03	; 3
     e9e:	79 f0       	breq	.+30     	; 0xebe <tinyLED_update+0x120>
     ea0:	28 f4       	brcc	.+10     	; 0xeac <tinyLED_update+0x10e>
     ea2:	81 30       	cpi	r24, 0x01	; 1
     ea4:	41 f0       	breq	.+16     	; 0xeb6 <tinyLED_update+0x118>
     ea6:	82 30       	cpi	r24, 0x02	; 2
     ea8:	89 f0       	breq	.+34     	; 0xecc <tinyLED_update+0x12e>
     eaa:	28 c0       	rjmp	.+80     	; 0xefc <tinyLED_update+0x15e>
     eac:	84 30       	cpi	r24, 0x04	; 4
     eae:	a9 f0       	breq	.+42     	; 0xeda <tinyLED_update+0x13c>
     eb0:	85 30       	cpi	r24, 0x05	; 5
     eb2:	d1 f0       	breq	.+52     	; 0xee8 <tinyLED_update+0x14a>
     eb4:	23 c0       	rjmp	.+70     	; 0xefc <tinyLED_update+0x15e>
	{
		case LED_OFF:
			rgb_color = (struct RGB_Color){0, 0, 0};
			break;
		case RED:
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 0, 0};
     eb6:	f1 2c       	mov	r15, r1
     eb8:	e1 2c       	mov	r14, r1
     eba:	69 e1       	ldi	r22, 0x19	; 25
     ebc:	22 c0       	rjmp	.+68     	; 0xf02 <tinyLED_update+0x164>
			break;
		case GREEN:
			rgb_color = (struct RGB_Color){0, 255*LED_BRIGHTNESS, 0};
     ebe:	f1 2c       	mov	r15, r1
     ec0:	0f 2e       	mov	r0, r31
     ec2:	f9 e1       	ldi	r31, 0x19	; 25
     ec4:	ef 2e       	mov	r14, r31
     ec6:	f0 2d       	mov	r31, r0
     ec8:	60 e0       	ldi	r22, 0x00	; 0
     eca:	1b c0       	rjmp	.+54     	; 0xf02 <tinyLED_update+0x164>
			break;
		case BLUE:
			rgb_color = (struct RGB_Color){0, 0, 255*LED_BRIGHTNESS};
     ecc:	0f 2e       	mov	r0, r31
     ece:	f9 e1       	ldi	r31, 0x19	; 25
     ed0:	ff 2e       	mov	r15, r31
     ed2:	f0 2d       	mov	r31, r0
     ed4:	e1 2c       	mov	r14, r1
     ed6:	60 e0       	ldi	r22, 0x00	; 0
     ed8:	14 c0       	rjmp	.+40     	; 0xf02 <tinyLED_update+0x164>
			break;
		case YELLOW:
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS, 0};
     eda:	f1 2c       	mov	r15, r1
     edc:	0f 2e       	mov	r0, r31
     ede:	f9 e1       	ldi	r31, 0x19	; 25
     ee0:	ef 2e       	mov	r14, r31
     ee2:	f0 2d       	mov	r31, r0
     ee4:	69 e1       	ldi	r22, 0x19	; 25
     ee6:	0d c0       	rjmp	.+26     	; 0xf02 <tinyLED_update+0x164>
			// Should the /3 be there? This requires testing.
			// After testing, findings were that at 0.1 brightness, one would see the three LEDs instead of one white led
			// We try with /2 instead.
			// We find that the best results come from not dividing by anything. At leasts in the lower brightness settings, and that
			// is where we suspect it will be most of the time. When we divide, the LEDs are so weak, that they appear as three lights instead of one.
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS};
     ee8:	0f 2e       	mov	r0, r31
     eea:	f9 e1       	ldi	r31, 0x19	; 25
     eec:	ff 2e       	mov	r15, r31
     eee:	f0 2d       	mov	r31, r0
     ef0:	0f 2e       	mov	r0, r31
     ef2:	f9 e1       	ldi	r31, 0x19	; 25
     ef4:	ef 2e       	mov	r14, r31
     ef6:	f0 2d       	mov	r31, r0
     ef8:	69 e1       	ldi	r22, 0x19	; 25
     efa:	03 c0       	rjmp	.+6      	; 0xf02 <tinyLED_update+0x164>
static struct RGB_Color tinyLED_enum_to_RGB_Color(enum Colors color){
	struct RGB_Color rgb_color;
	switch(color)
	{
		case LED_OFF:
			rgb_color = (struct RGB_Color){0, 0, 0};
     efc:	f1 2c       	mov	r15, r1
     efe:	e1 2c       	mov	r14, r1
     f00:	60 e0       	ldi	r22, 0x00	; 0
	
		
	for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
	{		
		// Convert enum to RGB_Color
		rgb_colors[i] = tinyLED_enum_to_RGB_Color(tinyLED_settings[i].color);
     f02:	d3 01       	movw	r26, r6
     f04:	6c 93       	st	X, r22
     f06:	11 96       	adiw	r26, 0x01	; 1
     f08:	ec 92       	st	X, r14
     f0a:	11 97       	sbiw	r26, 0x01	; 1
     f0c:	12 96       	adiw	r26, 0x02	; 2
     f0e:	fc 92       	st	X, r15
			
		// Adjust colors according to mode
		switch(tinyLED_settings[i].mode)
     f10:	81 81       	ldd	r24, Z+1	; 0x01
     f12:	83 30       	cpi	r24, 0x03	; 3
     f14:	09 f4       	brne	.+2      	; 0xf18 <tinyLED_update+0x17a>
     f16:	50 c0       	rjmp	.+160    	; 0xfb8 <tinyLED_update+0x21a>
     f18:	28 f4       	brcc	.+10     	; 0xf24 <tinyLED_update+0x186>
     f1a:	81 30       	cpi	r24, 0x01	; 1
     f1c:	51 f0       	breq	.+20     	; 0xf32 <tinyLED_update+0x194>
     f1e:	82 30       	cpi	r24, 0x02	; 2
     f20:	c9 f1       	breq	.+114    	; 0xf94 <tinyLED_update+0x1f6>
     f22:	05 c1       	rjmp	.+522    	; 0x112e <tinyLED_update+0x390>
     f24:	84 30       	cpi	r24, 0x04	; 4
     f26:	09 f4       	brne	.+2      	; 0xf2a <tinyLED_update+0x18c>
     f28:	78 c0       	rjmp	.+240    	; 0x101a <tinyLED_update+0x27c>
     f2a:	85 30       	cpi	r24, 0x05	; 5
     f2c:	09 f4       	brne	.+2      	; 0xf30 <tinyLED_update+0x192>
     f2e:	f2 c0       	rjmp	.+484    	; 0x1114 <tinyLED_update+0x376>
     f30:	fe c0       	rjmp	.+508    	; 0x112e <tinyLED_update+0x390>
		{
			case STABLE:
				break;
			case WEAK:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*WEAK_BRIGHTNESS, rgb_colors[i].green*WEAK_BRIGHTNESS, rgb_colors[i].blue*WEAK_BRIGHTNESS};
     f32:	70 e0       	ldi	r23, 0x00	; 0
     f34:	80 e0       	ldi	r24, 0x00	; 0
     f36:	90 e0       	ldi	r25, 0x00	; 0
     f38:	0e 94 35 0b 	call	0x166a	; 0x166a <__floatsisf>
     f3c:	2d ec       	ldi	r18, 0xCD	; 205
     f3e:	3c ec       	ldi	r19, 0xCC	; 204
     f40:	4c ec       	ldi	r20, 0xCC	; 204
     f42:	5d e3       	ldi	r21, 0x3D	; 61
     f44:	0e 94 a6 0c 	call	0x194c	; 0x194c <__mulsf3>
     f48:	0e 94 04 0b 	call	0x1608	; 0x1608 <__fixunssfsi>
     f4c:	f3 01       	movw	r30, r6
     f4e:	60 83       	st	Z, r22
     f50:	6e 2d       	mov	r22, r14
     f52:	70 e0       	ldi	r23, 0x00	; 0
     f54:	80 e0       	ldi	r24, 0x00	; 0
     f56:	90 e0       	ldi	r25, 0x00	; 0
     f58:	0e 94 35 0b 	call	0x166a	; 0x166a <__floatsisf>
     f5c:	2d ec       	ldi	r18, 0xCD	; 205
     f5e:	3c ec       	ldi	r19, 0xCC	; 204
     f60:	4c ec       	ldi	r20, 0xCC	; 204
     f62:	5d e3       	ldi	r21, 0x3D	; 61
     f64:	0e 94 a6 0c 	call	0x194c	; 0x194c <__mulsf3>
     f68:	0e 94 04 0b 	call	0x1608	; 0x1608 <__fixunssfsi>
     f6c:	d3 01       	movw	r26, r6
     f6e:	11 96       	adiw	r26, 0x01	; 1
     f70:	6c 93       	st	X, r22
     f72:	6f 2d       	mov	r22, r15
     f74:	70 e0       	ldi	r23, 0x00	; 0
     f76:	80 e0       	ldi	r24, 0x00	; 0
     f78:	90 e0       	ldi	r25, 0x00	; 0
     f7a:	0e 94 35 0b 	call	0x166a	; 0x166a <__floatsisf>
     f7e:	2d ec       	ldi	r18, 0xCD	; 205
     f80:	3c ec       	ldi	r19, 0xCC	; 204
     f82:	4c ec       	ldi	r20, 0xCC	; 204
     f84:	5d e3       	ldi	r21, 0x3D	; 61
     f86:	0e 94 a6 0c 	call	0x194c	; 0x194c <__mulsf3>
     f8a:	0e 94 04 0b 	call	0x1608	; 0x1608 <__fixunssfsi>
     f8e:	f3 01       	movw	r30, r6
     f90:	62 83       	std	Z+2, r22	; 0x02
				break;
     f92:	cd c0       	rjmp	.+410    	; 0x112e <tinyLED_update+0x390>
			case FLASH:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*flash_on, rgb_colors[i].green*flash_on, rgb_colors[i].blue*flash_on};
     f94:	fb 85       	ldd	r31, Y+11	; 0x0b
     f96:	f6 9f       	mul	r31, r22
     f98:	60 2d       	mov	r22, r0
     f9a:	11 24       	eor	r1, r1
     f9c:	d3 01       	movw	r26, r6
     f9e:	6c 93       	st	X, r22
     fa0:	fe 9d       	mul	r31, r14
     fa2:	e0 2c       	mov	r14, r0
     fa4:	11 24       	eor	r1, r1
     fa6:	11 96       	adiw	r26, 0x01	; 1
     fa8:	ec 92       	st	X, r14
     faa:	11 97       	sbiw	r26, 0x01	; 1
     fac:	ff 9d       	mul	r31, r15
     fae:	f0 2c       	mov	r15, r0
     fb0:	11 24       	eor	r1, r1
     fb2:	12 96       	adiw	r26, 0x02	; 2
     fb4:	fc 92       	st	X, r15
				break;
     fb6:	bb c0       	rjmp	.+374    	; 0x112e <tinyLED_update+0x390>
			case SWING:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*sinValue, rgb_colors[i].green*sinValue, rgb_colors[i].blue*sinValue};
     fb8:	70 e0       	ldi	r23, 0x00	; 0
     fba:	80 e0       	ldi	r24, 0x00	; 0
     fbc:	90 e0       	ldi	r25, 0x00	; 0
     fbe:	0e 94 35 0b 	call	0x166a	; 0x166a <__floatsisf>
     fc2:	2f 81       	ldd	r18, Y+7	; 0x07
     fc4:	38 85       	ldd	r19, Y+8	; 0x08
     fc6:	49 85       	ldd	r20, Y+9	; 0x09
     fc8:	5a 85       	ldd	r21, Y+10	; 0x0a
     fca:	0e 94 a6 0c 	call	0x194c	; 0x194c <__mulsf3>
     fce:	0e 94 04 0b 	call	0x1608	; 0x1608 <__fixunssfsi>
     fd2:	f3 01       	movw	r30, r6
     fd4:	60 83       	st	Z, r22
     fd6:	6e 2d       	mov	r22, r14
     fd8:	70 e0       	ldi	r23, 0x00	; 0
     fda:	80 e0       	ldi	r24, 0x00	; 0
     fdc:	90 e0       	ldi	r25, 0x00	; 0
     fde:	0e 94 35 0b 	call	0x166a	; 0x166a <__floatsisf>
     fe2:	2f 81       	ldd	r18, Y+7	; 0x07
     fe4:	38 85       	ldd	r19, Y+8	; 0x08
     fe6:	49 85       	ldd	r20, Y+9	; 0x09
     fe8:	5a 85       	ldd	r21, Y+10	; 0x0a
     fea:	0e 94 a6 0c 	call	0x194c	; 0x194c <__mulsf3>
     fee:	0e 94 04 0b 	call	0x1608	; 0x1608 <__fixunssfsi>
     ff2:	d3 01       	movw	r26, r6
     ff4:	11 96       	adiw	r26, 0x01	; 1
     ff6:	6c 93       	st	X, r22
     ff8:	6f 2d       	mov	r22, r15
     ffa:	70 e0       	ldi	r23, 0x00	; 0
     ffc:	80 e0       	ldi	r24, 0x00	; 0
     ffe:	90 e0       	ldi	r25, 0x00	; 0
    1000:	0e 94 35 0b 	call	0x166a	; 0x166a <__floatsisf>
    1004:	2f 81       	ldd	r18, Y+7	; 0x07
    1006:	38 85       	ldd	r19, Y+8	; 0x08
    1008:	49 85       	ldd	r20, Y+9	; 0x09
    100a:	5a 85       	ldd	r21, Y+10	; 0x0a
    100c:	0e 94 a6 0c 	call	0x194c	; 0x194c <__mulsf3>
    1010:	0e 94 04 0b 	call	0x1608	; 0x1608 <__fixunssfsi>
    1014:	f3 01       	movw	r30, r6
    1016:	62 83       	std	Z+2, r22	; 0x02
				break;
    1018:	8a c0       	rjmp	.+276    	; 0x112e <tinyLED_update+0x390>
			case PING:
				// in the line below, fmin will either return 1 or 0, so each rgb color is either 0 or 255*PING_BRIGHTNESS
				rgb_colors[i] = (struct RGB_Color){255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].red)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].green)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].blue)*ping_on};
    101a:	70 e0       	ldi	r23, 0x00	; 0
    101c:	80 e0       	ldi	r24, 0x00	; 0
    101e:	90 e0       	ldi	r25, 0x00	; 0
    1020:	0e 94 33 0b 	call	0x1666	; 0x1666 <__floatunsisf>
    1024:	9b 01       	movw	r18, r22
    1026:	ac 01       	movw	r20, r24
    1028:	60 e0       	ldi	r22, 0x00	; 0
    102a:	70 e0       	ldi	r23, 0x00	; 0
    102c:	80 e8       	ldi	r24, 0x80	; 128
    102e:	9f e3       	ldi	r25, 0x3F	; 63
    1030:	0e 94 70 0b 	call	0x16e0	; 0x16e0 <fmin>
    1034:	6c 8b       	std	Y+20, r22	; 0x14
    1036:	7d 8b       	std	Y+21, r23	; 0x15
    1038:	8e 8b       	std	Y+22, r24	; 0x16
    103a:	9f 8b       	std	Y+23, r25	; 0x17
    103c:	68 89       	ldd	r22, Y+16	; 0x10
    103e:	79 89       	ldd	r23, Y+17	; 0x11
    1040:	8a 89       	ldd	r24, Y+18	; 0x12
    1042:	9b 89       	ldd	r25, Y+19	; 0x13
    1044:	0e 94 35 0b 	call	0x166a	; 0x166a <__floatsisf>
    1048:	6c 87       	std	Y+12, r22	; 0x0c
    104a:	7d 87       	std	Y+13, r23	; 0x0d
    104c:	8e 87       	std	Y+14, r24	; 0x0e
    104e:	9f 87       	std	Y+15, r25	; 0x0f
    1050:	6e 2d       	mov	r22, r14
    1052:	70 e0       	ldi	r23, 0x00	; 0
    1054:	80 e0       	ldi	r24, 0x00	; 0
    1056:	90 e0       	ldi	r25, 0x00	; 0
    1058:	0e 94 33 0b 	call	0x1666	; 0x1666 <__floatunsisf>
    105c:	9b 01       	movw	r18, r22
    105e:	ac 01       	movw	r20, r24
    1060:	60 e0       	ldi	r22, 0x00	; 0
    1062:	70 e0       	ldi	r23, 0x00	; 0
    1064:	80 e8       	ldi	r24, 0x80	; 128
    1066:	9f e3       	ldi	r25, 0x3F	; 63
    1068:	0e 94 70 0b 	call	0x16e0	; 0x16e0 <fmin>
    106c:	68 8f       	std	Y+24, r22	; 0x18
    106e:	79 8f       	std	Y+25, r23	; 0x19
    1070:	8a 8f       	std	Y+26, r24	; 0x1a
    1072:	9b 8f       	std	Y+27, r25	; 0x1b
    1074:	6f 2d       	mov	r22, r15
    1076:	70 e0       	ldi	r23, 0x00	; 0
    1078:	80 e0       	ldi	r24, 0x00	; 0
    107a:	90 e0       	ldi	r25, 0x00	; 0
    107c:	0e 94 33 0b 	call	0x1666	; 0x1666 <__floatunsisf>
    1080:	9b 01       	movw	r18, r22
    1082:	ac 01       	movw	r20, r24
    1084:	60 e0       	ldi	r22, 0x00	; 0
    1086:	70 e0       	ldi	r23, 0x00	; 0
    1088:	80 e8       	ldi	r24, 0x80	; 128
    108a:	9f e3       	ldi	r25, 0x3F	; 63
    108c:	0e 94 70 0b 	call	0x16e0	; 0x16e0 <fmin>
    1090:	6c 8f       	std	Y+28, r22	; 0x1c
    1092:	7d 8f       	std	Y+29, r23	; 0x1d
    1094:	8e 8f       	std	Y+30, r24	; 0x1e
    1096:	9f 8f       	std	Y+31, r25	; 0x1f
    1098:	23 e3       	ldi	r18, 0x33	; 51
    109a:	33 e3       	ldi	r19, 0x33	; 51
    109c:	43 ea       	ldi	r20, 0xA3	; 163
    109e:	50 e4       	ldi	r21, 0x40	; 64
    10a0:	6c 89       	ldd	r22, Y+20	; 0x14
    10a2:	7d 89       	ldd	r23, Y+21	; 0x15
    10a4:	8e 89       	ldd	r24, Y+22	; 0x16
    10a6:	9f 89       	ldd	r25, Y+23	; 0x17
    10a8:	0e 94 a6 0c 	call	0x194c	; 0x194c <__mulsf3>
    10ac:	2c 85       	ldd	r18, Y+12	; 0x0c
    10ae:	3d 85       	ldd	r19, Y+13	; 0x0d
    10b0:	4e 85       	ldd	r20, Y+14	; 0x0e
    10b2:	5f 85       	ldd	r21, Y+15	; 0x0f
    10b4:	0e 94 a6 0c 	call	0x194c	; 0x194c <__mulsf3>
    10b8:	0e 94 04 0b 	call	0x1608	; 0x1608 <__fixunssfsi>
    10bc:	d3 01       	movw	r26, r6
    10be:	6c 93       	st	X, r22
    10c0:	23 e3       	ldi	r18, 0x33	; 51
    10c2:	33 e3       	ldi	r19, 0x33	; 51
    10c4:	43 ea       	ldi	r20, 0xA3	; 163
    10c6:	50 e4       	ldi	r21, 0x40	; 64
    10c8:	68 8d       	ldd	r22, Y+24	; 0x18
    10ca:	79 8d       	ldd	r23, Y+25	; 0x19
    10cc:	8a 8d       	ldd	r24, Y+26	; 0x1a
    10ce:	9b 8d       	ldd	r25, Y+27	; 0x1b
    10d0:	0e 94 a6 0c 	call	0x194c	; 0x194c <__mulsf3>
    10d4:	2c 85       	ldd	r18, Y+12	; 0x0c
    10d6:	3d 85       	ldd	r19, Y+13	; 0x0d
    10d8:	4e 85       	ldd	r20, Y+14	; 0x0e
    10da:	5f 85       	ldd	r21, Y+15	; 0x0f
    10dc:	0e 94 a6 0c 	call	0x194c	; 0x194c <__mulsf3>
    10e0:	0e 94 04 0b 	call	0x1608	; 0x1608 <__fixunssfsi>
    10e4:	f3 01       	movw	r30, r6
    10e6:	61 83       	std	Z+1, r22	; 0x01
    10e8:	23 e3       	ldi	r18, 0x33	; 51
    10ea:	33 e3       	ldi	r19, 0x33	; 51
    10ec:	43 ea       	ldi	r20, 0xA3	; 163
    10ee:	50 e4       	ldi	r21, 0x40	; 64
    10f0:	6c 8d       	ldd	r22, Y+28	; 0x1c
    10f2:	7d 8d       	ldd	r23, Y+29	; 0x1d
    10f4:	8e 8d       	ldd	r24, Y+30	; 0x1e
    10f6:	9f 8d       	ldd	r25, Y+31	; 0x1f
    10f8:	0e 94 a6 0c 	call	0x194c	; 0x194c <__mulsf3>
    10fc:	2c 85       	ldd	r18, Y+12	; 0x0c
    10fe:	3d 85       	ldd	r19, Y+13	; 0x0d
    1100:	4e 85       	ldd	r20, Y+14	; 0x0e
    1102:	5f 85       	ldd	r21, Y+15	; 0x0f
    1104:	0e 94 a6 0c 	call	0x194c	; 0x194c <__mulsf3>
    1108:	0e 94 04 0b 	call	0x1608	; 0x1608 <__fixunssfsi>
    110c:	d3 01       	movw	r26, r6
    110e:	12 96       	adiw	r26, 0x02	; 2
    1110:	6c 93       	st	X, r22
				break;
    1112:	0d c0       	rjmp	.+26     	; 0x112e <tinyLED_update+0x390>
			case FLASH_ONCE:
				if(tinyLED_flash_once_time[i]>0){
    1114:	d8 01       	movw	r26, r16
    1116:	8c 91       	ld	r24, X
    1118:	88 23       	and	r24, r24
    111a:	19 f0       	breq	.+6      	; 0x1122 <tinyLED_update+0x384>
					rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red, rgb_colors[i].green, rgb_colors[i].blue};
					tinyLED_flash_once_time[i]--;
    111c:	81 50       	subi	r24, 0x01	; 1
    111e:	8c 93       	st	X, r24
    1120:	06 c0       	rjmp	.+12     	; 0x112e <tinyLED_update+0x390>
				}
				else{
					// Here we return to the previous color and mode
					tinyLED_settings[i].color = tinyLED_old_settings[i].color;
    1122:	d5 01       	movw	r26, r10
    1124:	8c 91       	ld	r24, X
    1126:	80 83       	st	Z, r24
					tinyLED_settings[i].mode = tinyLED_old_settings[i].mode;
    1128:	11 96       	adiw	r26, 0x01	; 1
    112a:	8c 91       	ld	r24, X
    112c:	81 83       	std	Z+1, r24	; 0x01
    112e:	b2 e0       	ldi	r27, 0x02	; 2
    1130:	2b 0e       	add	r2, r27
    1132:	31 1c       	adc	r3, r1
    1134:	e3 e0       	ldi	r30, 0x03	; 3
    1136:	6e 0e       	add	r6, r30
    1138:	71 1c       	adc	r7, r1
    113a:	f2 e0       	ldi	r31, 0x02	; 2
    113c:	af 0e       	add	r10, r31
    113e:	b1 1c       	adc	r11, r1
    1140:	0f 5f       	subi	r16, 0xFF	; 255
    1142:	1f 4f       	sbci	r17, 0xFF	; 255
	
	// This is where we store all the actual color values we want to send to the LED
	struct RGB_Color rgb_colors[NUMBER_OF_LEDS];
	
		
	for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
    1144:	24 14       	cp	r2, r4
    1146:	35 04       	cpc	r3, r5
    1148:	09 f0       	breq	.+2      	; 0x114c <tinyLED_update+0x3ae>
    114a:	a6 ce       	rjmp	.-692    	; 0xe98 <tinyLED_update+0xfa>
				break;
		}
	}
	
	// We only write to the LEDs if there is something to change. (eg. in SWING mode, we update the LEDs almost every cycle)
	if(!tinyLED_RGB_Color_Compare(&rgb_colors, &tinyLED_old_colors)){
    114c:	6c e5       	ldi	r22, 0x5C	; 92
    114e:	78 e3       	ldi	r23, 0x38	; 56
    1150:	ce 01       	movw	r24, r28
    1152:	01 96       	adiw	r24, 0x01	; 1
    1154:	0e 94 9f 06 	call	0xd3e	; 0xd3e <tinyLED_RGB_Color_Compare>
    1158:	81 11       	cpse	r24, r1
    115a:	21 c0       	rjmp	.+66     	; 0x119e <tinyLED_update+0x400>
    115c:	0c e5       	ldi	r16, 0x5C	; 92
    115e:	18 e3       	ldi	r17, 0x38	; 56
    1160:	7e 01       	movw	r14, r28
    1162:	27 e0       	ldi	r18, 0x07	; 7
    1164:	e2 0e       	add	r14, r18
    1166:	f1 1c       	adc	r15, r1
		for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
		{
			// Write to LEDs
			//For some reason, the data-bus to the LEDs is serialized as GRB
			//which means the 24-bit data-bus will look like [Green[0:7], Red[0:7], Blue[0:7]]
			tinyLED_SPIWriteByte(rgb_colors[i].green);
    1168:	d6 01       	movw	r26, r12
    116a:	11 96       	adiw	r26, 0x01	; 1
    116c:	8c 91       	ld	r24, X
    116e:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <tinyLED_SPIWriteByte>
			tinyLED_SPIWriteByte(rgb_colors[i].red);
    1172:	f6 01       	movw	r30, r12
    1174:	80 81       	ld	r24, Z
    1176:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <tinyLED_SPIWriteByte>
			tinyLED_SPIWriteByte(rgb_colors[i].blue);
    117a:	d6 01       	movw	r26, r12
    117c:	12 96       	adiw	r26, 0x02	; 2
    117e:	8c 91       	ld	r24, X
    1180:	0e 94 5b 06 	call	0xcb6	; 0xcb6 <tinyLED_SPIWriteByte>
			tinyLED_old_colors[i] = rgb_colors[i];
    1184:	f6 01       	movw	r30, r12
    1186:	81 91       	ld	r24, Z+
    1188:	91 91       	ld	r25, Z+
    118a:	a1 91       	ld	r26, Z+
    118c:	6f 01       	movw	r12, r30
    118e:	f8 01       	movw	r30, r16
    1190:	81 93       	st	Z+, r24
    1192:	91 93       	st	Z+, r25
    1194:	a1 93       	st	Z+, r26
    1196:	8f 01       	movw	r16, r30
		}
	}
	
	// We only write to the LEDs if there is something to change. (eg. in SWING mode, we update the LEDs almost every cycle)
	if(!tinyLED_RGB_Color_Compare(&rgb_colors, &tinyLED_old_colors)){
		for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
    1198:	ce 14       	cp	r12, r14
    119a:	df 04       	cpc	r13, r15
    119c:	29 f7       	brne	.-54     	; 0x1168 <tinyLED_update+0x3ca>
			tinyLED_old_colors[i] = rgb_colors[i];
		}
		//tinyDebugger_send_uint8("LED1 color", tinyLED_settings[0].color);
		//tinyDebugger_send_uint8("LED2 color", tinyLED_settings[1].color);
	}
}
    119e:	6f 96       	adiw	r28, 0x1f	; 31
    11a0:	cd bf       	out	0x3d, r28	; 61
    11a2:	de bf       	out	0x3e, r29	; 62
    11a4:	df 91       	pop	r29
    11a6:	cf 91       	pop	r28
    11a8:	1f 91       	pop	r17
    11aa:	0f 91       	pop	r16
    11ac:	ff 90       	pop	r15
    11ae:	ef 90       	pop	r14
    11b0:	df 90       	pop	r13
    11b2:	cf 90       	pop	r12
    11b4:	bf 90       	pop	r11
    11b6:	af 90       	pop	r10
    11b8:	9f 90       	pop	r9
    11ba:	8f 90       	pop	r8
    11bc:	7f 90       	pop	r7
    11be:	6f 90       	pop	r6
    11c0:	5f 90       	pop	r5
    11c2:	4f 90       	pop	r4
    11c4:	3f 90       	pop	r3
    11c6:	2f 90       	pop	r2
    11c8:	08 95       	ret

000011ca <tinyPotential_update>:

/*
Update the potential
*/
void tinyPotential_update()
{
    11ca:	cf 92       	push	r12
    11cc:	df 92       	push	r13
    11ce:	ef 92       	push	r14
    11d0:	ff 92       	push	r15
Function to decay the potential towards 0
*/
static void tinyPotential_decay()
{
		
	uint8_t time_since_last_update = tinyTime_now() - previous_update_time;
    11d2:	0e 94 dd 09 	call	0x13ba	; 0x13ba <tinyTime_now>
	tinyPotential_potential *= (exp(-((float)time_since_last_update/(float)TINYPOTENTIAL_TIME_CONST)));
    11d6:	80 91 46 38 	lds	r24, 0x3846	; 0x803846 <previous_update_time>
    11da:	68 1b       	sub	r22, r24
    11dc:	70 e0       	ldi	r23, 0x00	; 0
    11de:	80 e0       	ldi	r24, 0x00	; 0
    11e0:	90 e0       	ldi	r25, 0x00	; 0
    11e2:	0e 94 33 0b 	call	0x1666	; 0x1666 <__floatunsisf>
    11e6:	20 e0       	ldi	r18, 0x00	; 0
    11e8:	30 e0       	ldi	r19, 0x00	; 0
    11ea:	48 ec       	ldi	r20, 0xC8	; 200
    11ec:	52 e4       	ldi	r21, 0x42	; 66
    11ee:	0e 94 58 0a 	call	0x14b0	; 0x14b0 <__divsf3>
    11f2:	90 58       	subi	r25, 0x80	; 128
    11f4:	0e 94 d2 0a 	call	0x15a4	; 0x15a4 <exp>
    11f8:	20 91 4a 38 	lds	r18, 0x384A	; 0x80384a <tinyPotential_potential>
    11fc:	30 91 4b 38 	lds	r19, 0x384B	; 0x80384b <tinyPotential_potential+0x1>
    1200:	40 91 4c 38 	lds	r20, 0x384C	; 0x80384c <tinyPotential_potential+0x2>
    1204:	50 91 4d 38 	lds	r21, 0x384D	; 0x80384d <tinyPotential_potential+0x3>
    1208:	0e 94 a6 0c 	call	0x194c	; 0x194c <__mulsf3>
    120c:	6b 01       	movw	r12, r22
    120e:	7c 01       	movw	r14, r24
	if(fabs(tinyPotential_potential)<0.1){
    1210:	9f 77       	andi	r25, 0x7F	; 127
    1212:	2d ec       	ldi	r18, 0xCD	; 205
    1214:	3c ec       	ldi	r19, 0xCC	; 204
    1216:	4c ec       	ldi	r20, 0xCC	; 204
    1218:	5d e3       	ldi	r21, 0x3D	; 61
    121a:	0e 94 53 0a 	call	0x14a6	; 0x14a6 <__cmpsf2>
    121e:	88 23       	and	r24, r24
    1220:	4c f0       	brlt	.+18     	; 0x1234 <tinyPotential_update+0x6a>
*/
static void tinyPotential_decay()
{
		
	uint8_t time_since_last_update = tinyTime_now() - previous_update_time;
	tinyPotential_potential *= (exp(-((float)time_since_last_update/(float)TINYPOTENTIAL_TIME_CONST)));
    1222:	c0 92 4a 38 	sts	0x384A, r12	; 0x80384a <tinyPotential_potential>
    1226:	d0 92 4b 38 	sts	0x384B, r13	; 0x80384b <tinyPotential_potential+0x1>
    122a:	e0 92 4c 38 	sts	0x384C, r14	; 0x80384c <tinyPotential_potential+0x2>
    122e:	f0 92 4d 38 	sts	0x384D, r15	; 0x80384d <tinyPotential_potential+0x3>
    1232:	08 c0       	rjmp	.+16     	; 0x1244 <tinyPotential_update+0x7a>
	if(fabs(tinyPotential_potential)<0.1){
		tinyPotential_potential=0;
    1234:	10 92 4a 38 	sts	0x384A, r1	; 0x80384a <tinyPotential_potential>
    1238:	10 92 4b 38 	sts	0x384B, r1	; 0x80384b <tinyPotential_potential+0x1>
    123c:	10 92 4c 38 	sts	0x384C, r1	; 0x80384c <tinyPotential_potential+0x2>
    1240:	10 92 4d 38 	sts	0x384D, r1	; 0x80384d <tinyPotential_potential+0x3>
	}
	previous_update_time = tinyTime_now();
    1244:	0e 94 dd 09 	call	0x13ba	; 0x13ba <tinyTime_now>
    1248:	60 93 46 38 	sts	0x3846, r22	; 0x803846 <previous_update_time>
    124c:	70 93 47 38 	sts	0x3847, r23	; 0x803847 <previous_update_time+0x1>
    1250:	80 93 48 38 	sts	0x3848, r24	; 0x803848 <previous_update_time+0x2>
    1254:	90 93 49 38 	sts	0x3849, r25	; 0x803849 <previous_update_time+0x3>
void tinyPotential_update()
{
	//Some of the potential in the neuron has decayed away
	tinyPotential_decay();
	// Update potential with values from Dendrites
	tinyPotential_potential = tinyDendrite_update_potential(tinyPotential_potential);
    1258:	60 91 4a 38 	lds	r22, 0x384A	; 0x80384a <tinyPotential_potential>
    125c:	70 91 4b 38 	lds	r23, 0x384B	; 0x80384b <tinyPotential_potential+0x1>
    1260:	80 91 4c 38 	lds	r24, 0x384C	; 0x80384c <tinyPotential_potential+0x2>
    1264:	90 91 4d 38 	lds	r25, 0x384D	; 0x80384d <tinyPotential_potential+0x3>
    1268:	0e 94 13 06 	call	0xc26	; 0xc26 <tinyDendrite_update_potential>
    126c:	60 93 4a 38 	sts	0x384A, r22	; 0x80384a <tinyPotential_potential>
    1270:	70 93 4b 38 	sts	0x384B, r23	; 0x80384b <tinyPotential_potential+0x1>
    1274:	80 93 4c 38 	sts	0x384C, r24	; 0x80384c <tinyPotential_potential+0x2>
    1278:	90 93 4d 38 	sts	0x384D, r25	; 0x80384d <tinyPotential_potential+0x3>
	
	// Update potential from button press
	tinyPotential_potential = tinyButton_update_potential(tinyPotential_potential);
    127c:	0e 94 37 04 	call	0x86e	; 0x86e <tinyButton_update_potential>
    1280:	60 93 4a 38 	sts	0x384A, r22	; 0x80384a <tinyPotential_potential>
    1284:	70 93 4b 38 	sts	0x384B, r23	; 0x80384b <tinyPotential_potential+0x1>
    1288:	80 93 4c 38 	sts	0x384C, r24	; 0x80384c <tinyPotential_potential+0x2>
    128c:	90 93 4d 38 	sts	0x384D, r25	; 0x80384d <tinyPotential_potential+0x3>
	
	// Update potential with values from spontaneous pulse.
	tinyPotential_potential = tinyPulse_update_potential(tinyPotential_potential);
    1290:	0e 94 91 09 	call	0x1322	; 0x1322 <tinyPulse_update_potential>
    1294:	ab 01       	movw	r20, r22
    1296:	bc 01       	movw	r22, r24
    1298:	40 93 4a 38 	sts	0x384A, r20	; 0x80384a <tinyPotential_potential>
    129c:	50 93 4b 38 	sts	0x384B, r21	; 0x80384b <tinyPotential_potential+0x1>
    12a0:	60 93 4c 38 	sts	0x384C, r22	; 0x80384c <tinyPotential_potential+0x2>
    12a4:	70 93 4d 38 	sts	0x384D, r23	; 0x80384d <tinyPotential_potential+0x3>
	
	tinyDebugger_send_double("Potential", tinyPotential_potential);
    12a8:	8e e3       	ldi	r24, 0x3E	; 62
    12aa:	96 ea       	ldi	r25, 0xA6	; 166
    12ac:	0e 94 d2 04 	call	0x9a4	; 0x9a4 <tinyDebugger_send_double>
	
	
	// Let the axon affect the potential
	// This is also where we decide whether or not the axon should fire
	tinyPotential_potential = tinyAxon_update_potential(tinyPotential_potential);
    12b0:	60 91 4a 38 	lds	r22, 0x384A	; 0x80384a <tinyPotential_potential>
    12b4:	70 91 4b 38 	lds	r23, 0x384B	; 0x80384b <tinyPotential_potential+0x1>
    12b8:	80 91 4c 38 	lds	r24, 0x384C	; 0x80384c <tinyPotential_potential+0x2>
    12bc:	90 91 4d 38 	lds	r25, 0x384D	; 0x80384d <tinyPotential_potential+0x3>
    12c0:	0e 94 12 03 	call	0x624	; 0x624 <tinyAxon_update_potential>
    12c4:	60 93 4a 38 	sts	0x384A, r22	; 0x80384a <tinyPotential_potential>
    12c8:	70 93 4b 38 	sts	0x384B, r23	; 0x80384b <tinyPotential_potential+0x1>
    12cc:	80 93 4c 38 	sts	0x384C, r24	; 0x80384c <tinyPotential_potential+0x2>
    12d0:	90 93 4d 38 	sts	0x384D, r25	; 0x80384d <tinyPotential_potential+0x3>
}
    12d4:	ff 90       	pop	r15
    12d6:	ef 90       	pop	r14
    12d8:	df 90       	pop	r13
    12da:	cf 90       	pop	r12
    12dc:	08 95       	ret

000012de <tinyPulse_toggle_pulse_mode>:
_Bool tinyPulse_is_in_pulse_mode(){
	return pulse_mode;
}

void tinyPulse_toggle_pulse_mode(){
	pulse_mode = !pulse_mode;
    12de:	90 91 54 38 	lds	r25, 0x3854	; 0x803854 <pulse_mode>
    12e2:	81 e0       	ldi	r24, 0x01	; 1
    12e4:	89 27       	eor	r24, r25
    12e6:	80 93 54 38 	sts	0x3854, r24	; 0x803854 <pulse_mode>
	
	if(tinyPulse_is_in_pulse_mode()){
    12ea:	88 23       	and	r24, r24
    12ec:	59 f0       	breq	.+22     	; 0x1304 <tinyPulse_toggle_pulse_mode+0x26>
		tinyLED_set_color_mode(OUT_LED, PULSEMODE_COLOR, WEAK);
    12ee:	41 e0       	ldi	r20, 0x01	; 1
    12f0:	62 e0       	ldi	r22, 0x02	; 2
    12f2:	81 e0       	ldi	r24, 0x01	; 1
    12f4:	0e 94 77 06 	call	0xcee	; 0xcee <tinyLED_set_color_mode>
		tinyLED_set_color_mode(INN_LED, PULSEMODE_COLOR, WEAK);
    12f8:	41 e0       	ldi	r20, 0x01	; 1
    12fa:	62 e0       	ldi	r22, 0x02	; 2
    12fc:	80 e0       	ldi	r24, 0x00	; 0
    12fe:	0e 94 77 06 	call	0xcee	; 0xcee <tinyLED_set_color_mode>
    1302:	08 95       	ret
	}
	else{
		tinyLED_set_color(OUT_LED, LED_OFF);
    1304:	60 e0       	ldi	r22, 0x00	; 0
    1306:	81 e0       	ldi	r24, 0x01	; 1
    1308:	0e 94 9b 06 	call	0xd36	; 0xd36 <tinyLED_set_color>
		tinyLED_set_color(INN_LED, LED_OFF);
    130c:	60 e0       	ldi	r22, 0x00	; 0
    130e:	80 e0       	ldi	r24, 0x00	; 0
    1310:	0e 94 9b 06 	call	0xd36	; 0xd36 <tinyLED_set_color>
    1314:	08 95       	ret

00001316 <tinyPulse_set_pulse_mode>:
	}
}

void tinyPulse_set_pulse_mode(_Bool mode){
	if (pulse_mode != mode)
    1316:	90 91 54 38 	lds	r25, 0x3854	; 0x803854 <pulse_mode>
    131a:	98 13       	cpse	r25, r24
	{
		tinyPulse_toggle_pulse_mode();
    131c:	0e 94 6f 09 	call	0x12de	; 0x12de <tinyPulse_toggle_pulse_mode>
    1320:	08 95       	ret

00001322 <tinyPulse_update_potential>:
	}
}

double tinyPulse_update_potential(double potential){
    1322:	cf 92       	push	r12
    1324:	df 92       	push	r13
    1326:	ef 92       	push	r14
    1328:	ff 92       	push	r15
    132a:	6b 01       	movw	r12, r22
    132c:	7c 01       	movw	r14, r24
	if(pulse_mode){
    132e:	80 91 54 38 	lds	r24, 0x3854	; 0x803854 <pulse_mode>
    1332:	88 23       	and	r24, r24
    1334:	39 f1       	breq	.+78     	; 0x1384 <tinyPulse_update_potential+0x62>
		
		time_since_last_pulse = tinyTime_now() - time_of_last_pulse;
    1336:	0e 94 dd 09 	call	0x13ba	; 0x13ba <tinyTime_now>
    133a:	20 91 50 38 	lds	r18, 0x3850	; 0x803850 <time_of_last_pulse>
    133e:	30 91 51 38 	lds	r19, 0x3851	; 0x803851 <time_of_last_pulse+0x1>
    1342:	62 1b       	sub	r22, r18
    1344:	73 0b       	sbc	r23, r19
    1346:	60 93 4e 38 	sts	0x384E, r22	; 0x80384e <time_since_last_pulse>
    134a:	70 93 4f 38 	sts	0x384F, r23	; 0x80384f <time_since_last_pulse+0x1>
		
		if(time_since_last_pulse >= ideal_time_between_pulses){
    134e:	80 91 13 38 	lds	r24, 0x3813	; 0x803813 <ideal_time_between_pulses>
    1352:	90 91 14 38 	lds	r25, 0x3814	; 0x803814 <ideal_time_between_pulses+0x1>
    1356:	68 17       	cp	r22, r24
    1358:	79 07       	cpc	r23, r25
    135a:	a0 f0       	brcs	.+40     	; 0x1384 <tinyPulse_update_potential+0x62>
			// This isn't actually a button press. You could have a separate variable for this, but it seems unnecessary.
			potential += BUTTON_PRESS_REACTION;
    135c:	20 e0       	ldi	r18, 0x00	; 0
    135e:	30 e0       	ldi	r19, 0x00	; 0
    1360:	40 ed       	ldi	r20, 0xD0	; 208
    1362:	51 e4       	ldi	r21, 0x41	; 65
    1364:	c7 01       	movw	r24, r14
    1366:	b6 01       	movw	r22, r12
    1368:	0e 94 e7 09 	call	0x13ce	; 0x13ce <__addsf3>
    136c:	6b 01       	movw	r12, r22
    136e:	7c 01       	movw	r14, r24
			time_of_last_pulse = tinyTime_now();			
    1370:	0e 94 dd 09 	call	0x13ba	; 0x13ba <tinyTime_now>
    1374:	60 93 50 38 	sts	0x3850, r22	; 0x803850 <time_of_last_pulse>
    1378:	70 93 51 38 	sts	0x3851, r23	; 0x803851 <time_of_last_pulse+0x1>
    137c:	80 93 52 38 	sts	0x3852, r24	; 0x803852 <time_of_last_pulse+0x2>
    1380:	90 93 53 38 	sts	0x3853, r25	; 0x803853 <time_of_last_pulse+0x3>
		}
	}
	return potential;
}
    1384:	c7 01       	movw	r24, r14
    1386:	b6 01       	movw	r22, r12
    1388:	ff 90       	pop	r15
    138a:	ef 90       	pop	r14
    138c:	df 90       	pop	r13
    138e:	cf 90       	pop	r12
    1390:	08 95       	ret

00001392 <tinyTime_counter_increment>:
If the Interrupt Service Routine is clocked by a crystal oscillator
it gives a very precise timer-counter.
*/
void tinyTime_counter_increment(void)
{
	time_counter++;
    1392:	80 91 55 38 	lds	r24, 0x3855	; 0x803855 <time_counter>
    1396:	90 91 56 38 	lds	r25, 0x3856	; 0x803856 <time_counter+0x1>
    139a:	a0 91 57 38 	lds	r26, 0x3857	; 0x803857 <time_counter+0x2>
    139e:	b0 91 58 38 	lds	r27, 0x3858	; 0x803858 <time_counter+0x3>
    13a2:	01 96       	adiw	r24, 0x01	; 1
    13a4:	a1 1d       	adc	r26, r1
    13a6:	b1 1d       	adc	r27, r1
    13a8:	80 93 55 38 	sts	0x3855, r24	; 0x803855 <time_counter>
    13ac:	90 93 56 38 	sts	0x3856, r25	; 0x803856 <time_counter+0x1>
    13b0:	a0 93 57 38 	sts	0x3857, r26	; 0x803857 <time_counter+0x2>
    13b4:	b0 93 58 38 	sts	0x3858, r27	; 0x803858 <time_counter+0x3>
    13b8:	08 95       	ret

000013ba <tinyTime_now>:
/*
This function is callable by external libraries to give them the counted time so far.
*/
uint32_t tinyTime_now(void)
{
	return time_counter;
    13ba:	60 91 55 38 	lds	r22, 0x3855	; 0x803855 <time_counter>
    13be:	70 91 56 38 	lds	r23, 0x3856	; 0x803856 <time_counter+0x1>
    13c2:	80 91 57 38 	lds	r24, 0x3857	; 0x803857 <time_counter+0x2>
    13c6:	90 91 58 38 	lds	r25, 0x3858	; 0x803858 <time_counter+0x3>
    13ca:	08 95       	ret

000013cc <__subsf3>:
    13cc:	50 58       	subi	r21, 0x80	; 128

000013ce <__addsf3>:
    13ce:	bb 27       	eor	r27, r27
    13d0:	aa 27       	eor	r26, r26
    13d2:	0e 94 fe 09 	call	0x13fc	; 0x13fc <__addsf3x>
    13d6:	0c 94 f1 0b 	jmp	0x17e2	; 0x17e2 <__fp_round>
    13da:	0e 94 e3 0b 	call	0x17c6	; 0x17c6 <__fp_pscA>
    13de:	38 f0       	brcs	.+14     	; 0x13ee <__addsf3+0x20>
    13e0:	0e 94 ea 0b 	call	0x17d4	; 0x17d4 <__fp_pscB>
    13e4:	20 f0       	brcs	.+8      	; 0x13ee <__addsf3+0x20>
    13e6:	39 f4       	brne	.+14     	; 0x13f6 <__addsf3+0x28>
    13e8:	9f 3f       	cpi	r25, 0xFF	; 255
    13ea:	19 f4       	brne	.+6      	; 0x13f2 <__addsf3+0x24>
    13ec:	26 f4       	brtc	.+8      	; 0x13f6 <__addsf3+0x28>
    13ee:	0c 94 b9 0b 	jmp	0x1772	; 0x1772 <__fp_nan>
    13f2:	0e f4       	brtc	.+2      	; 0x13f6 <__addsf3+0x28>
    13f4:	e0 95       	com	r30
    13f6:	e7 fb       	bst	r30, 7
    13f8:	0c 94 b3 0b 	jmp	0x1766	; 0x1766 <__fp_inf>

000013fc <__addsf3x>:
    13fc:	e9 2f       	mov	r30, r25
    13fe:	0e 94 02 0c 	call	0x1804	; 0x1804 <__fp_split3>
    1402:	58 f3       	brcs	.-42     	; 0x13da <__addsf3+0xc>
    1404:	ba 17       	cp	r27, r26
    1406:	62 07       	cpc	r22, r18
    1408:	73 07       	cpc	r23, r19
    140a:	84 07       	cpc	r24, r20
    140c:	95 07       	cpc	r25, r21
    140e:	20 f0       	brcs	.+8      	; 0x1418 <__addsf3x+0x1c>
    1410:	79 f4       	brne	.+30     	; 0x1430 <__addsf3x+0x34>
    1412:	a6 f5       	brtc	.+104    	; 0x147c <__addsf3x+0x80>
    1414:	0c 94 24 0c 	jmp	0x1848	; 0x1848 <__fp_zero>
    1418:	0e f4       	brtc	.+2      	; 0x141c <__addsf3x+0x20>
    141a:	e0 95       	com	r30
    141c:	0b 2e       	mov	r0, r27
    141e:	ba 2f       	mov	r27, r26
    1420:	a0 2d       	mov	r26, r0
    1422:	0b 01       	movw	r0, r22
    1424:	b9 01       	movw	r22, r18
    1426:	90 01       	movw	r18, r0
    1428:	0c 01       	movw	r0, r24
    142a:	ca 01       	movw	r24, r20
    142c:	a0 01       	movw	r20, r0
    142e:	11 24       	eor	r1, r1
    1430:	ff 27       	eor	r31, r31
    1432:	59 1b       	sub	r21, r25
    1434:	99 f0       	breq	.+38     	; 0x145c <__addsf3x+0x60>
    1436:	59 3f       	cpi	r21, 0xF9	; 249
    1438:	50 f4       	brcc	.+20     	; 0x144e <__addsf3x+0x52>
    143a:	50 3e       	cpi	r21, 0xE0	; 224
    143c:	68 f1       	brcs	.+90     	; 0x1498 <__addsf3x+0x9c>
    143e:	1a 16       	cp	r1, r26
    1440:	f0 40       	sbci	r31, 0x00	; 0
    1442:	a2 2f       	mov	r26, r18
    1444:	23 2f       	mov	r18, r19
    1446:	34 2f       	mov	r19, r20
    1448:	44 27       	eor	r20, r20
    144a:	58 5f       	subi	r21, 0xF8	; 248
    144c:	f3 cf       	rjmp	.-26     	; 0x1434 <__addsf3x+0x38>
    144e:	46 95       	lsr	r20
    1450:	37 95       	ror	r19
    1452:	27 95       	ror	r18
    1454:	a7 95       	ror	r26
    1456:	f0 40       	sbci	r31, 0x00	; 0
    1458:	53 95       	inc	r21
    145a:	c9 f7       	brne	.-14     	; 0x144e <__addsf3x+0x52>
    145c:	7e f4       	brtc	.+30     	; 0x147c <__addsf3x+0x80>
    145e:	1f 16       	cp	r1, r31
    1460:	ba 0b       	sbc	r27, r26
    1462:	62 0b       	sbc	r22, r18
    1464:	73 0b       	sbc	r23, r19
    1466:	84 0b       	sbc	r24, r20
    1468:	ba f0       	brmi	.+46     	; 0x1498 <__addsf3x+0x9c>
    146a:	91 50       	subi	r25, 0x01	; 1
    146c:	a1 f0       	breq	.+40     	; 0x1496 <__addsf3x+0x9a>
    146e:	ff 0f       	add	r31, r31
    1470:	bb 1f       	adc	r27, r27
    1472:	66 1f       	adc	r22, r22
    1474:	77 1f       	adc	r23, r23
    1476:	88 1f       	adc	r24, r24
    1478:	c2 f7       	brpl	.-16     	; 0x146a <__addsf3x+0x6e>
    147a:	0e c0       	rjmp	.+28     	; 0x1498 <__addsf3x+0x9c>
    147c:	ba 0f       	add	r27, r26
    147e:	62 1f       	adc	r22, r18
    1480:	73 1f       	adc	r23, r19
    1482:	84 1f       	adc	r24, r20
    1484:	48 f4       	brcc	.+18     	; 0x1498 <__addsf3x+0x9c>
    1486:	87 95       	ror	r24
    1488:	77 95       	ror	r23
    148a:	67 95       	ror	r22
    148c:	b7 95       	ror	r27
    148e:	f7 95       	ror	r31
    1490:	9e 3f       	cpi	r25, 0xFE	; 254
    1492:	08 f0       	brcs	.+2      	; 0x1496 <__addsf3x+0x9a>
    1494:	b0 cf       	rjmp	.-160    	; 0x13f6 <__addsf3+0x28>
    1496:	93 95       	inc	r25
    1498:	88 0f       	add	r24, r24
    149a:	08 f0       	brcs	.+2      	; 0x149e <__addsf3x+0xa2>
    149c:	99 27       	eor	r25, r25
    149e:	ee 0f       	add	r30, r30
    14a0:	97 95       	ror	r25
    14a2:	87 95       	ror	r24
    14a4:	08 95       	ret

000014a6 <__cmpsf2>:
    14a6:	0e 94 8f 0b 	call	0x171e	; 0x171e <__fp_cmp>
    14aa:	08 f4       	brcc	.+2      	; 0x14ae <__cmpsf2+0x8>
    14ac:	81 e0       	ldi	r24, 0x01	; 1
    14ae:	08 95       	ret

000014b0 <__divsf3>:
    14b0:	0e 94 6c 0a 	call	0x14d8	; 0x14d8 <__divsf3x>
    14b4:	0c 94 f1 0b 	jmp	0x17e2	; 0x17e2 <__fp_round>
    14b8:	0e 94 ea 0b 	call	0x17d4	; 0x17d4 <__fp_pscB>
    14bc:	58 f0       	brcs	.+22     	; 0x14d4 <__divsf3+0x24>
    14be:	0e 94 e3 0b 	call	0x17c6	; 0x17c6 <__fp_pscA>
    14c2:	40 f0       	brcs	.+16     	; 0x14d4 <__divsf3+0x24>
    14c4:	29 f4       	brne	.+10     	; 0x14d0 <__divsf3+0x20>
    14c6:	5f 3f       	cpi	r21, 0xFF	; 255
    14c8:	29 f0       	breq	.+10     	; 0x14d4 <__divsf3+0x24>
    14ca:	0c 94 b3 0b 	jmp	0x1766	; 0x1766 <__fp_inf>
    14ce:	51 11       	cpse	r21, r1
    14d0:	0c 94 25 0c 	jmp	0x184a	; 0x184a <__fp_szero>
    14d4:	0c 94 b9 0b 	jmp	0x1772	; 0x1772 <__fp_nan>

000014d8 <__divsf3x>:
    14d8:	0e 94 02 0c 	call	0x1804	; 0x1804 <__fp_split3>
    14dc:	68 f3       	brcs	.-38     	; 0x14b8 <__divsf3+0x8>

000014de <__divsf3_pse>:
    14de:	99 23       	and	r25, r25
    14e0:	b1 f3       	breq	.-20     	; 0x14ce <__divsf3+0x1e>
    14e2:	55 23       	and	r21, r21
    14e4:	91 f3       	breq	.-28     	; 0x14ca <__divsf3+0x1a>
    14e6:	95 1b       	sub	r25, r21
    14e8:	55 0b       	sbc	r21, r21
    14ea:	bb 27       	eor	r27, r27
    14ec:	aa 27       	eor	r26, r26
    14ee:	62 17       	cp	r22, r18
    14f0:	73 07       	cpc	r23, r19
    14f2:	84 07       	cpc	r24, r20
    14f4:	38 f0       	brcs	.+14     	; 0x1504 <__divsf3_pse+0x26>
    14f6:	9f 5f       	subi	r25, 0xFF	; 255
    14f8:	5f 4f       	sbci	r21, 0xFF	; 255
    14fa:	22 0f       	add	r18, r18
    14fc:	33 1f       	adc	r19, r19
    14fe:	44 1f       	adc	r20, r20
    1500:	aa 1f       	adc	r26, r26
    1502:	a9 f3       	breq	.-22     	; 0x14ee <__divsf3_pse+0x10>
    1504:	35 d0       	rcall	.+106    	; 0x1570 <__divsf3_pse+0x92>
    1506:	0e 2e       	mov	r0, r30
    1508:	3a f0       	brmi	.+14     	; 0x1518 <__divsf3_pse+0x3a>
    150a:	e0 e8       	ldi	r30, 0x80	; 128
    150c:	32 d0       	rcall	.+100    	; 0x1572 <__divsf3_pse+0x94>
    150e:	91 50       	subi	r25, 0x01	; 1
    1510:	50 40       	sbci	r21, 0x00	; 0
    1512:	e6 95       	lsr	r30
    1514:	00 1c       	adc	r0, r0
    1516:	ca f7       	brpl	.-14     	; 0x150a <__divsf3_pse+0x2c>
    1518:	2b d0       	rcall	.+86     	; 0x1570 <__divsf3_pse+0x92>
    151a:	fe 2f       	mov	r31, r30
    151c:	29 d0       	rcall	.+82     	; 0x1570 <__divsf3_pse+0x92>
    151e:	66 0f       	add	r22, r22
    1520:	77 1f       	adc	r23, r23
    1522:	88 1f       	adc	r24, r24
    1524:	bb 1f       	adc	r27, r27
    1526:	26 17       	cp	r18, r22
    1528:	37 07       	cpc	r19, r23
    152a:	48 07       	cpc	r20, r24
    152c:	ab 07       	cpc	r26, r27
    152e:	b0 e8       	ldi	r27, 0x80	; 128
    1530:	09 f0       	breq	.+2      	; 0x1534 <__divsf3_pse+0x56>
    1532:	bb 0b       	sbc	r27, r27
    1534:	80 2d       	mov	r24, r0
    1536:	bf 01       	movw	r22, r30
    1538:	ff 27       	eor	r31, r31
    153a:	93 58       	subi	r25, 0x83	; 131
    153c:	5f 4f       	sbci	r21, 0xFF	; 255
    153e:	3a f0       	brmi	.+14     	; 0x154e <__divsf3_pse+0x70>
    1540:	9e 3f       	cpi	r25, 0xFE	; 254
    1542:	51 05       	cpc	r21, r1
    1544:	78 f0       	brcs	.+30     	; 0x1564 <__divsf3_pse+0x86>
    1546:	0c 94 b3 0b 	jmp	0x1766	; 0x1766 <__fp_inf>
    154a:	0c 94 25 0c 	jmp	0x184a	; 0x184a <__fp_szero>
    154e:	5f 3f       	cpi	r21, 0xFF	; 255
    1550:	e4 f3       	brlt	.-8      	; 0x154a <__divsf3_pse+0x6c>
    1552:	98 3e       	cpi	r25, 0xE8	; 232
    1554:	d4 f3       	brlt	.-12     	; 0x154a <__divsf3_pse+0x6c>
    1556:	86 95       	lsr	r24
    1558:	77 95       	ror	r23
    155a:	67 95       	ror	r22
    155c:	b7 95       	ror	r27
    155e:	f7 95       	ror	r31
    1560:	9f 5f       	subi	r25, 0xFF	; 255
    1562:	c9 f7       	brne	.-14     	; 0x1556 <__divsf3_pse+0x78>
    1564:	88 0f       	add	r24, r24
    1566:	91 1d       	adc	r25, r1
    1568:	96 95       	lsr	r25
    156a:	87 95       	ror	r24
    156c:	97 f9       	bld	r25, 7
    156e:	08 95       	ret
    1570:	e1 e0       	ldi	r30, 0x01	; 1
    1572:	66 0f       	add	r22, r22
    1574:	77 1f       	adc	r23, r23
    1576:	88 1f       	adc	r24, r24
    1578:	bb 1f       	adc	r27, r27
    157a:	62 17       	cp	r22, r18
    157c:	73 07       	cpc	r23, r19
    157e:	84 07       	cpc	r24, r20
    1580:	ba 07       	cpc	r27, r26
    1582:	20 f0       	brcs	.+8      	; 0x158c <__divsf3_pse+0xae>
    1584:	62 1b       	sub	r22, r18
    1586:	73 0b       	sbc	r23, r19
    1588:	84 0b       	sbc	r24, r20
    158a:	ba 0b       	sbc	r27, r26
    158c:	ee 1f       	adc	r30, r30
    158e:	88 f7       	brcc	.-30     	; 0x1572 <__divsf3_pse+0x94>
    1590:	e0 95       	com	r30
    1592:	08 95       	ret
    1594:	29 f4       	brne	.+10     	; 0x15a0 <__divsf3_pse+0xc2>
    1596:	16 f0       	brts	.+4      	; 0x159c <__divsf3_pse+0xbe>
    1598:	0c 94 b3 0b 	jmp	0x1766	; 0x1766 <__fp_inf>
    159c:	0c 94 24 0c 	jmp	0x1848	; 0x1848 <__fp_zero>
    15a0:	0c 94 b9 0b 	jmp	0x1772	; 0x1772 <__fp_nan>

000015a4 <exp>:
    15a4:	0e 94 0a 0c 	call	0x1814	; 0x1814 <__fp_splitA>
    15a8:	a8 f3       	brcs	.-22     	; 0x1594 <__divsf3_pse+0xb6>
    15aa:	96 38       	cpi	r25, 0x86	; 134
    15ac:	a0 f7       	brcc	.-24     	; 0x1596 <__divsf3_pse+0xb8>
    15ae:	07 f8       	bld	r0, 7
    15b0:	0f 92       	push	r0
    15b2:	e8 94       	clt
    15b4:	2b e3       	ldi	r18, 0x3B	; 59
    15b6:	3a ea       	ldi	r19, 0xAA	; 170
    15b8:	48 eb       	ldi	r20, 0xB8	; 184
    15ba:	5f e7       	ldi	r21, 0x7F	; 127
    15bc:	0e 94 bc 0c 	call	0x1978	; 0x1978 <__mulsf3_pse>
    15c0:	0f 92       	push	r0
    15c2:	0f 92       	push	r0
    15c4:	0f 92       	push	r0
    15c6:	4d b7       	in	r20, 0x3d	; 61
    15c8:	5e b7       	in	r21, 0x3e	; 62
    15ca:	0f 92       	push	r0
    15cc:	0e 94 72 0c 	call	0x18e4	; 0x18e4 <modf>
    15d0:	ec e7       	ldi	r30, 0x7C	; 124
    15d2:	f0 e0       	ldi	r31, 0x00	; 0
    15d4:	0e 94 bc 0b 	call	0x1778	; 0x1778 <__fp_powser>
    15d8:	4f 91       	pop	r20
    15da:	5f 91       	pop	r21
    15dc:	ef 91       	pop	r30
    15de:	ff 91       	pop	r31
    15e0:	e5 95       	asr	r30
    15e2:	ee 1f       	adc	r30, r30
    15e4:	ff 1f       	adc	r31, r31
    15e6:	49 f0       	breq	.+18     	; 0x15fa <exp+0x56>
    15e8:	fe 57       	subi	r31, 0x7E	; 126
    15ea:	e0 68       	ori	r30, 0x80	; 128
    15ec:	44 27       	eor	r20, r20
    15ee:	ee 0f       	add	r30, r30
    15f0:	44 1f       	adc	r20, r20
    15f2:	fa 95       	dec	r31
    15f4:	e1 f7       	brne	.-8      	; 0x15ee <exp+0x4a>
    15f6:	41 95       	neg	r20
    15f8:	55 0b       	sbc	r21, r21
    15fa:	0e 94 3c 0c 	call	0x1878	; 0x1878 <ldexp>
    15fe:	0f 90       	pop	r0
    1600:	07 fe       	sbrs	r0, 7
    1602:	0c 94 30 0c 	jmp	0x1860	; 0x1860 <inverse>
    1606:	08 95       	ret

00001608 <__fixunssfsi>:
    1608:	0e 94 0a 0c 	call	0x1814	; 0x1814 <__fp_splitA>
    160c:	88 f0       	brcs	.+34     	; 0x1630 <__fixunssfsi+0x28>
    160e:	9f 57       	subi	r25, 0x7F	; 127
    1610:	98 f0       	brcs	.+38     	; 0x1638 <__fixunssfsi+0x30>
    1612:	b9 2f       	mov	r27, r25
    1614:	99 27       	eor	r25, r25
    1616:	b7 51       	subi	r27, 0x17	; 23
    1618:	b0 f0       	brcs	.+44     	; 0x1646 <__fixunssfsi+0x3e>
    161a:	e1 f0       	breq	.+56     	; 0x1654 <__fixunssfsi+0x4c>
    161c:	66 0f       	add	r22, r22
    161e:	77 1f       	adc	r23, r23
    1620:	88 1f       	adc	r24, r24
    1622:	99 1f       	adc	r25, r25
    1624:	1a f0       	brmi	.+6      	; 0x162c <__fixunssfsi+0x24>
    1626:	ba 95       	dec	r27
    1628:	c9 f7       	brne	.-14     	; 0x161c <__fixunssfsi+0x14>
    162a:	14 c0       	rjmp	.+40     	; 0x1654 <__fixunssfsi+0x4c>
    162c:	b1 30       	cpi	r27, 0x01	; 1
    162e:	91 f0       	breq	.+36     	; 0x1654 <__fixunssfsi+0x4c>
    1630:	0e 94 24 0c 	call	0x1848	; 0x1848 <__fp_zero>
    1634:	b1 e0       	ldi	r27, 0x01	; 1
    1636:	08 95       	ret
    1638:	0c 94 24 0c 	jmp	0x1848	; 0x1848 <__fp_zero>
    163c:	67 2f       	mov	r22, r23
    163e:	78 2f       	mov	r23, r24
    1640:	88 27       	eor	r24, r24
    1642:	b8 5f       	subi	r27, 0xF8	; 248
    1644:	39 f0       	breq	.+14     	; 0x1654 <__fixunssfsi+0x4c>
    1646:	b9 3f       	cpi	r27, 0xF9	; 249
    1648:	cc f3       	brlt	.-14     	; 0x163c <__fixunssfsi+0x34>
    164a:	86 95       	lsr	r24
    164c:	77 95       	ror	r23
    164e:	67 95       	ror	r22
    1650:	b3 95       	inc	r27
    1652:	d9 f7       	brne	.-10     	; 0x164a <__fixunssfsi+0x42>
    1654:	3e f4       	brtc	.+14     	; 0x1664 <__fixunssfsi+0x5c>
    1656:	90 95       	com	r25
    1658:	80 95       	com	r24
    165a:	70 95       	com	r23
    165c:	61 95       	neg	r22
    165e:	7f 4f       	sbci	r23, 0xFF	; 255
    1660:	8f 4f       	sbci	r24, 0xFF	; 255
    1662:	9f 4f       	sbci	r25, 0xFF	; 255
    1664:	08 95       	ret

00001666 <__floatunsisf>:
    1666:	e8 94       	clt
    1668:	09 c0       	rjmp	.+18     	; 0x167c <__floatsisf+0x12>

0000166a <__floatsisf>:
    166a:	97 fb       	bst	r25, 7
    166c:	3e f4       	brtc	.+14     	; 0x167c <__floatsisf+0x12>
    166e:	90 95       	com	r25
    1670:	80 95       	com	r24
    1672:	70 95       	com	r23
    1674:	61 95       	neg	r22
    1676:	7f 4f       	sbci	r23, 0xFF	; 255
    1678:	8f 4f       	sbci	r24, 0xFF	; 255
    167a:	9f 4f       	sbci	r25, 0xFF	; 255
    167c:	99 23       	and	r25, r25
    167e:	a9 f0       	breq	.+42     	; 0x16aa <__floatsisf+0x40>
    1680:	f9 2f       	mov	r31, r25
    1682:	96 e9       	ldi	r25, 0x96	; 150
    1684:	bb 27       	eor	r27, r27
    1686:	93 95       	inc	r25
    1688:	f6 95       	lsr	r31
    168a:	87 95       	ror	r24
    168c:	77 95       	ror	r23
    168e:	67 95       	ror	r22
    1690:	b7 95       	ror	r27
    1692:	f1 11       	cpse	r31, r1
    1694:	f8 cf       	rjmp	.-16     	; 0x1686 <__floatsisf+0x1c>
    1696:	fa f4       	brpl	.+62     	; 0x16d6 <__floatsisf+0x6c>
    1698:	bb 0f       	add	r27, r27
    169a:	11 f4       	brne	.+4      	; 0x16a0 <__floatsisf+0x36>
    169c:	60 ff       	sbrs	r22, 0
    169e:	1b c0       	rjmp	.+54     	; 0x16d6 <__floatsisf+0x6c>
    16a0:	6f 5f       	subi	r22, 0xFF	; 255
    16a2:	7f 4f       	sbci	r23, 0xFF	; 255
    16a4:	8f 4f       	sbci	r24, 0xFF	; 255
    16a6:	9f 4f       	sbci	r25, 0xFF	; 255
    16a8:	16 c0       	rjmp	.+44     	; 0x16d6 <__floatsisf+0x6c>
    16aa:	88 23       	and	r24, r24
    16ac:	11 f0       	breq	.+4      	; 0x16b2 <__floatsisf+0x48>
    16ae:	96 e9       	ldi	r25, 0x96	; 150
    16b0:	11 c0       	rjmp	.+34     	; 0x16d4 <__floatsisf+0x6a>
    16b2:	77 23       	and	r23, r23
    16b4:	21 f0       	breq	.+8      	; 0x16be <__floatsisf+0x54>
    16b6:	9e e8       	ldi	r25, 0x8E	; 142
    16b8:	87 2f       	mov	r24, r23
    16ba:	76 2f       	mov	r23, r22
    16bc:	05 c0       	rjmp	.+10     	; 0x16c8 <__floatsisf+0x5e>
    16be:	66 23       	and	r22, r22
    16c0:	71 f0       	breq	.+28     	; 0x16de <__floatsisf+0x74>
    16c2:	96 e8       	ldi	r25, 0x86	; 134
    16c4:	86 2f       	mov	r24, r22
    16c6:	70 e0       	ldi	r23, 0x00	; 0
    16c8:	60 e0       	ldi	r22, 0x00	; 0
    16ca:	2a f0       	brmi	.+10     	; 0x16d6 <__floatsisf+0x6c>
    16cc:	9a 95       	dec	r25
    16ce:	66 0f       	add	r22, r22
    16d0:	77 1f       	adc	r23, r23
    16d2:	88 1f       	adc	r24, r24
    16d4:	da f7       	brpl	.-10     	; 0x16cc <__floatsisf+0x62>
    16d6:	88 0f       	add	r24, r24
    16d8:	96 95       	lsr	r25
    16da:	87 95       	ror	r24
    16dc:	97 f9       	bld	r25, 7
    16de:	08 95       	ret

000016e0 <fmin>:
    16e0:	99 0f       	add	r25, r25
    16e2:	bb 0b       	sbc	r27, r27
    16e4:	55 0f       	add	r21, r21
    16e6:	aa 0b       	sbc	r26, r26
    16e8:	e0 e8       	ldi	r30, 0x80	; 128
    16ea:	fe ef       	ldi	r31, 0xFE	; 254
    16ec:	16 16       	cp	r1, r22
    16ee:	17 06       	cpc	r1, r23
    16f0:	e8 07       	cpc	r30, r24
    16f2:	f9 07       	cpc	r31, r25
    16f4:	70 f0       	brcs	.+28     	; 0x1712 <fmin+0x32>
    16f6:	12 16       	cp	r1, r18
    16f8:	13 06       	cpc	r1, r19
    16fa:	e4 07       	cpc	r30, r20
    16fc:	f5 07       	cpc	r31, r21
    16fe:	60 f0       	brcs	.+24     	; 0x1718 <fmin+0x38>
    1700:	ba 17       	cp	r27, r26
    1702:	54 f0       	brlt	.+20     	; 0x1718 <fmin+0x38>
    1704:	31 f4       	brne	.+12     	; 0x1712 <fmin+0x32>
    1706:	26 17       	cp	r18, r22
    1708:	37 07       	cpc	r19, r23
    170a:	48 07       	cpc	r20, r24
    170c:	59 07       	cpc	r21, r25
    170e:	a7 95       	ror	r26
    1710:	1b f4       	brvc	.+6      	; 0x1718 <fmin+0x38>
    1712:	b9 01       	movw	r22, r18
    1714:	ca 01       	movw	r24, r20
    1716:	ba 2f       	mov	r27, r26
    1718:	b6 95       	lsr	r27
    171a:	97 95       	ror	r25
    171c:	08 95       	ret

0000171e <__fp_cmp>:
    171e:	99 0f       	add	r25, r25
    1720:	00 08       	sbc	r0, r0
    1722:	55 0f       	add	r21, r21
    1724:	aa 0b       	sbc	r26, r26
    1726:	e0 e8       	ldi	r30, 0x80	; 128
    1728:	fe ef       	ldi	r31, 0xFE	; 254
    172a:	16 16       	cp	r1, r22
    172c:	17 06       	cpc	r1, r23
    172e:	e8 07       	cpc	r30, r24
    1730:	f9 07       	cpc	r31, r25
    1732:	c0 f0       	brcs	.+48     	; 0x1764 <__fp_cmp+0x46>
    1734:	12 16       	cp	r1, r18
    1736:	13 06       	cpc	r1, r19
    1738:	e4 07       	cpc	r30, r20
    173a:	f5 07       	cpc	r31, r21
    173c:	98 f0       	brcs	.+38     	; 0x1764 <__fp_cmp+0x46>
    173e:	62 1b       	sub	r22, r18
    1740:	73 0b       	sbc	r23, r19
    1742:	84 0b       	sbc	r24, r20
    1744:	95 0b       	sbc	r25, r21
    1746:	39 f4       	brne	.+14     	; 0x1756 <__fp_cmp+0x38>
    1748:	0a 26       	eor	r0, r26
    174a:	61 f0       	breq	.+24     	; 0x1764 <__fp_cmp+0x46>
    174c:	23 2b       	or	r18, r19
    174e:	24 2b       	or	r18, r20
    1750:	25 2b       	or	r18, r21
    1752:	21 f4       	brne	.+8      	; 0x175c <__fp_cmp+0x3e>
    1754:	08 95       	ret
    1756:	0a 26       	eor	r0, r26
    1758:	09 f4       	brne	.+2      	; 0x175c <__fp_cmp+0x3e>
    175a:	a1 40       	sbci	r26, 0x01	; 1
    175c:	a6 95       	lsr	r26
    175e:	8f ef       	ldi	r24, 0xFF	; 255
    1760:	81 1d       	adc	r24, r1
    1762:	81 1d       	adc	r24, r1
    1764:	08 95       	ret

00001766 <__fp_inf>:
    1766:	97 f9       	bld	r25, 7
    1768:	9f 67       	ori	r25, 0x7F	; 127
    176a:	80 e8       	ldi	r24, 0x80	; 128
    176c:	70 e0       	ldi	r23, 0x00	; 0
    176e:	60 e0       	ldi	r22, 0x00	; 0
    1770:	08 95       	ret

00001772 <__fp_nan>:
    1772:	9f ef       	ldi	r25, 0xFF	; 255
    1774:	80 ec       	ldi	r24, 0xC0	; 192
    1776:	08 95       	ret

00001778 <__fp_powser>:
    1778:	df 93       	push	r29
    177a:	cf 93       	push	r28
    177c:	1f 93       	push	r17
    177e:	0f 93       	push	r16
    1780:	ff 92       	push	r15
    1782:	ef 92       	push	r14
    1784:	df 92       	push	r13
    1786:	7b 01       	movw	r14, r22
    1788:	8c 01       	movw	r16, r24
    178a:	68 94       	set
    178c:	06 c0       	rjmp	.+12     	; 0x179a <__fp_powser+0x22>
    178e:	da 2e       	mov	r13, r26
    1790:	ef 01       	movw	r28, r30
    1792:	0e 94 b9 0c 	call	0x1972	; 0x1972 <__mulsf3x>
    1796:	fe 01       	movw	r30, r28
    1798:	e8 94       	clt
    179a:	a5 91       	lpm	r26, Z+
    179c:	25 91       	lpm	r18, Z+
    179e:	35 91       	lpm	r19, Z+
    17a0:	45 91       	lpm	r20, Z+
    17a2:	55 91       	lpm	r21, Z+
    17a4:	a6 f3       	brts	.-24     	; 0x178e <__fp_powser+0x16>
    17a6:	ef 01       	movw	r28, r30
    17a8:	0e 94 fe 09 	call	0x13fc	; 0x13fc <__addsf3x>
    17ac:	fe 01       	movw	r30, r28
    17ae:	97 01       	movw	r18, r14
    17b0:	a8 01       	movw	r20, r16
    17b2:	da 94       	dec	r13
    17b4:	69 f7       	brne	.-38     	; 0x1790 <__fp_powser+0x18>
    17b6:	df 90       	pop	r13
    17b8:	ef 90       	pop	r14
    17ba:	ff 90       	pop	r15
    17bc:	0f 91       	pop	r16
    17be:	1f 91       	pop	r17
    17c0:	cf 91       	pop	r28
    17c2:	df 91       	pop	r29
    17c4:	08 95       	ret

000017c6 <__fp_pscA>:
    17c6:	00 24       	eor	r0, r0
    17c8:	0a 94       	dec	r0
    17ca:	16 16       	cp	r1, r22
    17cc:	17 06       	cpc	r1, r23
    17ce:	18 06       	cpc	r1, r24
    17d0:	09 06       	cpc	r0, r25
    17d2:	08 95       	ret

000017d4 <__fp_pscB>:
    17d4:	00 24       	eor	r0, r0
    17d6:	0a 94       	dec	r0
    17d8:	12 16       	cp	r1, r18
    17da:	13 06       	cpc	r1, r19
    17dc:	14 06       	cpc	r1, r20
    17de:	05 06       	cpc	r0, r21
    17e0:	08 95       	ret

000017e2 <__fp_round>:
    17e2:	09 2e       	mov	r0, r25
    17e4:	03 94       	inc	r0
    17e6:	00 0c       	add	r0, r0
    17e8:	11 f4       	brne	.+4      	; 0x17ee <__fp_round+0xc>
    17ea:	88 23       	and	r24, r24
    17ec:	52 f0       	brmi	.+20     	; 0x1802 <__fp_round+0x20>
    17ee:	bb 0f       	add	r27, r27
    17f0:	40 f4       	brcc	.+16     	; 0x1802 <__fp_round+0x20>
    17f2:	bf 2b       	or	r27, r31
    17f4:	11 f4       	brne	.+4      	; 0x17fa <__fp_round+0x18>
    17f6:	60 ff       	sbrs	r22, 0
    17f8:	04 c0       	rjmp	.+8      	; 0x1802 <__fp_round+0x20>
    17fa:	6f 5f       	subi	r22, 0xFF	; 255
    17fc:	7f 4f       	sbci	r23, 0xFF	; 255
    17fe:	8f 4f       	sbci	r24, 0xFF	; 255
    1800:	9f 4f       	sbci	r25, 0xFF	; 255
    1802:	08 95       	ret

00001804 <__fp_split3>:
    1804:	57 fd       	sbrc	r21, 7
    1806:	90 58       	subi	r25, 0x80	; 128
    1808:	44 0f       	add	r20, r20
    180a:	55 1f       	adc	r21, r21
    180c:	59 f0       	breq	.+22     	; 0x1824 <__fp_splitA+0x10>
    180e:	5f 3f       	cpi	r21, 0xFF	; 255
    1810:	71 f0       	breq	.+28     	; 0x182e <__fp_splitA+0x1a>
    1812:	47 95       	ror	r20

00001814 <__fp_splitA>:
    1814:	88 0f       	add	r24, r24
    1816:	97 fb       	bst	r25, 7
    1818:	99 1f       	adc	r25, r25
    181a:	61 f0       	breq	.+24     	; 0x1834 <__fp_splitA+0x20>
    181c:	9f 3f       	cpi	r25, 0xFF	; 255
    181e:	79 f0       	breq	.+30     	; 0x183e <__fp_splitA+0x2a>
    1820:	87 95       	ror	r24
    1822:	08 95       	ret
    1824:	12 16       	cp	r1, r18
    1826:	13 06       	cpc	r1, r19
    1828:	14 06       	cpc	r1, r20
    182a:	55 1f       	adc	r21, r21
    182c:	f2 cf       	rjmp	.-28     	; 0x1812 <__fp_split3+0xe>
    182e:	46 95       	lsr	r20
    1830:	f1 df       	rcall	.-30     	; 0x1814 <__fp_splitA>
    1832:	08 c0       	rjmp	.+16     	; 0x1844 <__fp_splitA+0x30>
    1834:	16 16       	cp	r1, r22
    1836:	17 06       	cpc	r1, r23
    1838:	18 06       	cpc	r1, r24
    183a:	99 1f       	adc	r25, r25
    183c:	f1 cf       	rjmp	.-30     	; 0x1820 <__fp_splitA+0xc>
    183e:	86 95       	lsr	r24
    1840:	71 05       	cpc	r23, r1
    1842:	61 05       	cpc	r22, r1
    1844:	08 94       	sec
    1846:	08 95       	ret

00001848 <__fp_zero>:
    1848:	e8 94       	clt

0000184a <__fp_szero>:
    184a:	bb 27       	eor	r27, r27
    184c:	66 27       	eor	r22, r22
    184e:	77 27       	eor	r23, r23
    1850:	cb 01       	movw	r24, r22
    1852:	97 f9       	bld	r25, 7
    1854:	08 95       	ret

00001856 <__gesf2>:
    1856:	0e 94 8f 0b 	call	0x171e	; 0x171e <__fp_cmp>
    185a:	08 f4       	brcc	.+2      	; 0x185e <__gesf2+0x8>
    185c:	8f ef       	ldi	r24, 0xFF	; 255
    185e:	08 95       	ret

00001860 <inverse>:
    1860:	9b 01       	movw	r18, r22
    1862:	ac 01       	movw	r20, r24
    1864:	60 e0       	ldi	r22, 0x00	; 0
    1866:	70 e0       	ldi	r23, 0x00	; 0
    1868:	80 e8       	ldi	r24, 0x80	; 128
    186a:	9f e3       	ldi	r25, 0x3F	; 63
    186c:	0c 94 58 0a 	jmp	0x14b0	; 0x14b0 <__divsf3>
    1870:	0c 94 b3 0b 	jmp	0x1766	; 0x1766 <__fp_inf>
    1874:	0c 94 1b 0d 	jmp	0x1a36	; 0x1a36 <__fp_mpack>

00001878 <ldexp>:
    1878:	0e 94 0a 0c 	call	0x1814	; 0x1814 <__fp_splitA>
    187c:	d8 f3       	brcs	.-10     	; 0x1874 <inverse+0x14>
    187e:	99 23       	and	r25, r25
    1880:	c9 f3       	breq	.-14     	; 0x1874 <inverse+0x14>
    1882:	94 0f       	add	r25, r20
    1884:	51 1d       	adc	r21, r1
    1886:	a3 f3       	brvs	.-24     	; 0x1870 <inverse+0x10>
    1888:	91 50       	subi	r25, 0x01	; 1
    188a:	50 40       	sbci	r21, 0x00	; 0
    188c:	94 f0       	brlt	.+36     	; 0x18b2 <ldexp+0x3a>
    188e:	59 f0       	breq	.+22     	; 0x18a6 <ldexp+0x2e>
    1890:	88 23       	and	r24, r24
    1892:	32 f0       	brmi	.+12     	; 0x18a0 <ldexp+0x28>
    1894:	66 0f       	add	r22, r22
    1896:	77 1f       	adc	r23, r23
    1898:	88 1f       	adc	r24, r24
    189a:	91 50       	subi	r25, 0x01	; 1
    189c:	50 40       	sbci	r21, 0x00	; 0
    189e:	c1 f7       	brne	.-16     	; 0x1890 <ldexp+0x18>
    18a0:	9e 3f       	cpi	r25, 0xFE	; 254
    18a2:	51 05       	cpc	r21, r1
    18a4:	2c f7       	brge	.-54     	; 0x1870 <inverse+0x10>
    18a6:	88 0f       	add	r24, r24
    18a8:	91 1d       	adc	r25, r1
    18aa:	96 95       	lsr	r25
    18ac:	87 95       	ror	r24
    18ae:	97 f9       	bld	r25, 7
    18b0:	08 95       	ret
    18b2:	5f 3f       	cpi	r21, 0xFF	; 255
    18b4:	ac f0       	brlt	.+42     	; 0x18e0 <ldexp+0x68>
    18b6:	98 3e       	cpi	r25, 0xE8	; 232
    18b8:	9c f0       	brlt	.+38     	; 0x18e0 <ldexp+0x68>
    18ba:	bb 27       	eor	r27, r27
    18bc:	86 95       	lsr	r24
    18be:	77 95       	ror	r23
    18c0:	67 95       	ror	r22
    18c2:	b7 95       	ror	r27
    18c4:	08 f4       	brcc	.+2      	; 0x18c8 <ldexp+0x50>
    18c6:	b1 60       	ori	r27, 0x01	; 1
    18c8:	93 95       	inc	r25
    18ca:	c1 f7       	brne	.-16     	; 0x18bc <ldexp+0x44>
    18cc:	bb 0f       	add	r27, r27
    18ce:	58 f7       	brcc	.-42     	; 0x18a6 <ldexp+0x2e>
    18d0:	11 f4       	brne	.+4      	; 0x18d6 <ldexp+0x5e>
    18d2:	60 ff       	sbrs	r22, 0
    18d4:	e8 cf       	rjmp	.-48     	; 0x18a6 <ldexp+0x2e>
    18d6:	6f 5f       	subi	r22, 0xFF	; 255
    18d8:	7f 4f       	sbci	r23, 0xFF	; 255
    18da:	8f 4f       	sbci	r24, 0xFF	; 255
    18dc:	9f 4f       	sbci	r25, 0xFF	; 255
    18de:	e3 cf       	rjmp	.-58     	; 0x18a6 <ldexp+0x2e>
    18e0:	0c 94 25 0c 	jmp	0x184a	; 0x184a <__fp_szero>

000018e4 <modf>:
    18e4:	fa 01       	movw	r30, r20
    18e6:	dc 01       	movw	r26, r24
    18e8:	aa 0f       	add	r26, r26
    18ea:	bb 1f       	adc	r27, r27
    18ec:	9b 01       	movw	r18, r22
    18ee:	ac 01       	movw	r20, r24
    18f0:	bf 57       	subi	r27, 0x7F	; 127
    18f2:	28 f4       	brcc	.+10     	; 0x18fe <modf+0x1a>
    18f4:	22 27       	eor	r18, r18
    18f6:	33 27       	eor	r19, r19
    18f8:	44 27       	eor	r20, r20
    18fa:	50 78       	andi	r21, 0x80	; 128
    18fc:	20 c0       	rjmp	.+64     	; 0x193e <modf+0x5a>
    18fe:	b7 51       	subi	r27, 0x17	; 23
    1900:	90 f4       	brcc	.+36     	; 0x1926 <modf+0x42>
    1902:	ab 2f       	mov	r26, r27
    1904:	00 24       	eor	r0, r0
    1906:	46 95       	lsr	r20
    1908:	37 95       	ror	r19
    190a:	27 95       	ror	r18
    190c:	01 1c       	adc	r0, r1
    190e:	a3 95       	inc	r26
    1910:	d2 f3       	brmi	.-12     	; 0x1906 <modf+0x22>
    1912:	00 20       	and	r0, r0
    1914:	71 f0       	breq	.+28     	; 0x1932 <modf+0x4e>
    1916:	22 0f       	add	r18, r18
    1918:	33 1f       	adc	r19, r19
    191a:	44 1f       	adc	r20, r20
    191c:	b3 95       	inc	r27
    191e:	da f3       	brmi	.-10     	; 0x1916 <modf+0x32>
    1920:	0e d0       	rcall	.+28     	; 0x193e <modf+0x5a>
    1922:	0c 94 e6 09 	jmp	0x13cc	; 0x13cc <__subsf3>
    1926:	61 30       	cpi	r22, 0x01	; 1
    1928:	71 05       	cpc	r23, r1
    192a:	a0 e8       	ldi	r26, 0x80	; 128
    192c:	8a 07       	cpc	r24, r26
    192e:	b9 46       	sbci	r27, 0x69	; 105
    1930:	30 f4       	brcc	.+12     	; 0x193e <modf+0x5a>
    1932:	9b 01       	movw	r18, r22
    1934:	ac 01       	movw	r20, r24
    1936:	66 27       	eor	r22, r22
    1938:	77 27       	eor	r23, r23
    193a:	88 27       	eor	r24, r24
    193c:	90 78       	andi	r25, 0x80	; 128
    193e:	30 96       	adiw	r30, 0x00	; 0
    1940:	21 f0       	breq	.+8      	; 0x194a <modf+0x66>
    1942:	20 83       	st	Z, r18
    1944:	31 83       	std	Z+1, r19	; 0x01
    1946:	42 83       	std	Z+2, r20	; 0x02
    1948:	53 83       	std	Z+3, r21	; 0x03
    194a:	08 95       	ret

0000194c <__mulsf3>:
    194c:	0e 94 b9 0c 	call	0x1972	; 0x1972 <__mulsf3x>
    1950:	0c 94 f1 0b 	jmp	0x17e2	; 0x17e2 <__fp_round>
    1954:	0e 94 e3 0b 	call	0x17c6	; 0x17c6 <__fp_pscA>
    1958:	38 f0       	brcs	.+14     	; 0x1968 <__mulsf3+0x1c>
    195a:	0e 94 ea 0b 	call	0x17d4	; 0x17d4 <__fp_pscB>
    195e:	20 f0       	brcs	.+8      	; 0x1968 <__mulsf3+0x1c>
    1960:	95 23       	and	r25, r21
    1962:	11 f0       	breq	.+4      	; 0x1968 <__mulsf3+0x1c>
    1964:	0c 94 b3 0b 	jmp	0x1766	; 0x1766 <__fp_inf>
    1968:	0c 94 b9 0b 	jmp	0x1772	; 0x1772 <__fp_nan>
    196c:	11 24       	eor	r1, r1
    196e:	0c 94 25 0c 	jmp	0x184a	; 0x184a <__fp_szero>

00001972 <__mulsf3x>:
    1972:	0e 94 02 0c 	call	0x1804	; 0x1804 <__fp_split3>
    1976:	70 f3       	brcs	.-36     	; 0x1954 <__mulsf3+0x8>

00001978 <__mulsf3_pse>:
    1978:	95 9f       	mul	r25, r21
    197a:	c1 f3       	breq	.-16     	; 0x196c <__mulsf3+0x20>
    197c:	95 0f       	add	r25, r21
    197e:	50 e0       	ldi	r21, 0x00	; 0
    1980:	55 1f       	adc	r21, r21
    1982:	62 9f       	mul	r22, r18
    1984:	f0 01       	movw	r30, r0
    1986:	72 9f       	mul	r23, r18
    1988:	bb 27       	eor	r27, r27
    198a:	f0 0d       	add	r31, r0
    198c:	b1 1d       	adc	r27, r1
    198e:	63 9f       	mul	r22, r19
    1990:	aa 27       	eor	r26, r26
    1992:	f0 0d       	add	r31, r0
    1994:	b1 1d       	adc	r27, r1
    1996:	aa 1f       	adc	r26, r26
    1998:	64 9f       	mul	r22, r20
    199a:	66 27       	eor	r22, r22
    199c:	b0 0d       	add	r27, r0
    199e:	a1 1d       	adc	r26, r1
    19a0:	66 1f       	adc	r22, r22
    19a2:	82 9f       	mul	r24, r18
    19a4:	22 27       	eor	r18, r18
    19a6:	b0 0d       	add	r27, r0
    19a8:	a1 1d       	adc	r26, r1
    19aa:	62 1f       	adc	r22, r18
    19ac:	73 9f       	mul	r23, r19
    19ae:	b0 0d       	add	r27, r0
    19b0:	a1 1d       	adc	r26, r1
    19b2:	62 1f       	adc	r22, r18
    19b4:	83 9f       	mul	r24, r19
    19b6:	a0 0d       	add	r26, r0
    19b8:	61 1d       	adc	r22, r1
    19ba:	22 1f       	adc	r18, r18
    19bc:	74 9f       	mul	r23, r20
    19be:	33 27       	eor	r19, r19
    19c0:	a0 0d       	add	r26, r0
    19c2:	61 1d       	adc	r22, r1
    19c4:	23 1f       	adc	r18, r19
    19c6:	84 9f       	mul	r24, r20
    19c8:	60 0d       	add	r22, r0
    19ca:	21 1d       	adc	r18, r1
    19cc:	82 2f       	mov	r24, r18
    19ce:	76 2f       	mov	r23, r22
    19d0:	6a 2f       	mov	r22, r26
    19d2:	11 24       	eor	r1, r1
    19d4:	9f 57       	subi	r25, 0x7F	; 127
    19d6:	50 40       	sbci	r21, 0x00	; 0
    19d8:	9a f0       	brmi	.+38     	; 0x1a00 <__mulsf3_pse+0x88>
    19da:	f1 f0       	breq	.+60     	; 0x1a18 <__mulsf3_pse+0xa0>
    19dc:	88 23       	and	r24, r24
    19de:	4a f0       	brmi	.+18     	; 0x19f2 <__mulsf3_pse+0x7a>
    19e0:	ee 0f       	add	r30, r30
    19e2:	ff 1f       	adc	r31, r31
    19e4:	bb 1f       	adc	r27, r27
    19e6:	66 1f       	adc	r22, r22
    19e8:	77 1f       	adc	r23, r23
    19ea:	88 1f       	adc	r24, r24
    19ec:	91 50       	subi	r25, 0x01	; 1
    19ee:	50 40       	sbci	r21, 0x00	; 0
    19f0:	a9 f7       	brne	.-22     	; 0x19dc <__mulsf3_pse+0x64>
    19f2:	9e 3f       	cpi	r25, 0xFE	; 254
    19f4:	51 05       	cpc	r21, r1
    19f6:	80 f0       	brcs	.+32     	; 0x1a18 <__mulsf3_pse+0xa0>
    19f8:	0c 94 b3 0b 	jmp	0x1766	; 0x1766 <__fp_inf>
    19fc:	0c 94 25 0c 	jmp	0x184a	; 0x184a <__fp_szero>
    1a00:	5f 3f       	cpi	r21, 0xFF	; 255
    1a02:	e4 f3       	brlt	.-8      	; 0x19fc <__mulsf3_pse+0x84>
    1a04:	98 3e       	cpi	r25, 0xE8	; 232
    1a06:	d4 f3       	brlt	.-12     	; 0x19fc <__mulsf3_pse+0x84>
    1a08:	86 95       	lsr	r24
    1a0a:	77 95       	ror	r23
    1a0c:	67 95       	ror	r22
    1a0e:	b7 95       	ror	r27
    1a10:	f7 95       	ror	r31
    1a12:	e7 95       	ror	r30
    1a14:	9f 5f       	subi	r25, 0xFF	; 255
    1a16:	c1 f7       	brne	.-16     	; 0x1a08 <__mulsf3_pse+0x90>
    1a18:	fe 2b       	or	r31, r30
    1a1a:	88 0f       	add	r24, r24
    1a1c:	91 1d       	adc	r25, r1
    1a1e:	96 95       	lsr	r25
    1a20:	87 95       	ror	r24
    1a22:	97 f9       	bld	r25, 7
    1a24:	08 95       	ret

00001a26 <sin>:
    1a26:	9f 93       	push	r25
    1a28:	0e 94 2b 0d 	call	0x1a56	; 0x1a56 <__fp_rempio2>
    1a2c:	0f 90       	pop	r0
    1a2e:	07 fc       	sbrc	r0, 7
    1a30:	ee 5f       	subi	r30, 0xFE	; 254
    1a32:	0c 94 54 0d 	jmp	0x1aa8	; 0x1aa8 <__fp_sinus>

00001a36 <__fp_mpack>:
    1a36:	9f 3f       	cpi	r25, 0xFF	; 255
    1a38:	31 f0       	breq	.+12     	; 0x1a46 <__fp_mpack_finite+0xc>

00001a3a <__fp_mpack_finite>:
    1a3a:	91 50       	subi	r25, 0x01	; 1
    1a3c:	20 f4       	brcc	.+8      	; 0x1a46 <__fp_mpack_finite+0xc>
    1a3e:	87 95       	ror	r24
    1a40:	77 95       	ror	r23
    1a42:	67 95       	ror	r22
    1a44:	b7 95       	ror	r27
    1a46:	88 0f       	add	r24, r24
    1a48:	91 1d       	adc	r25, r1
    1a4a:	96 95       	lsr	r25
    1a4c:	87 95       	ror	r24
    1a4e:	97 f9       	bld	r25, 7
    1a50:	08 95       	ret
    1a52:	0c 94 b9 0b 	jmp	0x1772	; 0x1772 <__fp_nan>

00001a56 <__fp_rempio2>:
    1a56:	0e 94 0a 0c 	call	0x1814	; 0x1814 <__fp_splitA>
    1a5a:	d8 f3       	brcs	.-10     	; 0x1a52 <__fp_mpack_finite+0x18>
    1a5c:	e8 94       	clt
    1a5e:	e0 e0       	ldi	r30, 0x00	; 0
    1a60:	bb 27       	eor	r27, r27
    1a62:	9f 57       	subi	r25, 0x7F	; 127
    1a64:	f0 f0       	brcs	.+60     	; 0x1aa2 <__fp_rempio2+0x4c>
    1a66:	2a ed       	ldi	r18, 0xDA	; 218
    1a68:	3f e0       	ldi	r19, 0x0F	; 15
    1a6a:	49 ec       	ldi	r20, 0xC9	; 201
    1a6c:	06 c0       	rjmp	.+12     	; 0x1a7a <__fp_rempio2+0x24>
    1a6e:	ee 0f       	add	r30, r30
    1a70:	bb 0f       	add	r27, r27
    1a72:	66 1f       	adc	r22, r22
    1a74:	77 1f       	adc	r23, r23
    1a76:	88 1f       	adc	r24, r24
    1a78:	28 f0       	brcs	.+10     	; 0x1a84 <__fp_rempio2+0x2e>
    1a7a:	b2 3a       	cpi	r27, 0xA2	; 162
    1a7c:	62 07       	cpc	r22, r18
    1a7e:	73 07       	cpc	r23, r19
    1a80:	84 07       	cpc	r24, r20
    1a82:	28 f0       	brcs	.+10     	; 0x1a8e <__fp_rempio2+0x38>
    1a84:	b2 5a       	subi	r27, 0xA2	; 162
    1a86:	62 0b       	sbc	r22, r18
    1a88:	73 0b       	sbc	r23, r19
    1a8a:	84 0b       	sbc	r24, r20
    1a8c:	e3 95       	inc	r30
    1a8e:	9a 95       	dec	r25
    1a90:	72 f7       	brpl	.-36     	; 0x1a6e <__fp_rempio2+0x18>
    1a92:	80 38       	cpi	r24, 0x80	; 128
    1a94:	30 f4       	brcc	.+12     	; 0x1aa2 <__fp_rempio2+0x4c>
    1a96:	9a 95       	dec	r25
    1a98:	bb 0f       	add	r27, r27
    1a9a:	66 1f       	adc	r22, r22
    1a9c:	77 1f       	adc	r23, r23
    1a9e:	88 1f       	adc	r24, r24
    1aa0:	d2 f7       	brpl	.-12     	; 0x1a96 <__fp_rempio2+0x40>
    1aa2:	90 48       	sbci	r25, 0x80	; 128
    1aa4:	0c 94 1d 0d 	jmp	0x1a3a	; 0x1a3a <__fp_mpack_finite>

00001aa8 <__fp_sinus>:
    1aa8:	ef 93       	push	r30
    1aaa:	e0 ff       	sbrs	r30, 0
    1aac:	07 c0       	rjmp	.+14     	; 0x1abc <__fp_sinus+0x14>
    1aae:	a2 ea       	ldi	r26, 0xA2	; 162
    1ab0:	2a ed       	ldi	r18, 0xDA	; 218
    1ab2:	3f e0       	ldi	r19, 0x0F	; 15
    1ab4:	49 ec       	ldi	r20, 0xC9	; 201
    1ab6:	5f eb       	ldi	r21, 0xBF	; 191
    1ab8:	0e 94 fe 09 	call	0x13fc	; 0x13fc <__addsf3x>
    1abc:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <__fp_round>
    1ac0:	0f 90       	pop	r0
    1ac2:	03 94       	inc	r0
    1ac4:	01 fc       	sbrc	r0, 1
    1ac6:	90 58       	subi	r25, 0x80	; 128
    1ac8:	e4 ea       	ldi	r30, 0xA4	; 164
    1aca:	f0 e0       	ldi	r31, 0x00	; 0
    1acc:	0c 94 68 0d 	jmp	0x1ad0	; 0x1ad0 <__fp_powsodd>

00001ad0 <__fp_powsodd>:
    1ad0:	9f 93       	push	r25
    1ad2:	8f 93       	push	r24
    1ad4:	7f 93       	push	r23
    1ad6:	6f 93       	push	r22
    1ad8:	ff 93       	push	r31
    1ada:	ef 93       	push	r30
    1adc:	9b 01       	movw	r18, r22
    1ade:	ac 01       	movw	r20, r24
    1ae0:	0e 94 a6 0c 	call	0x194c	; 0x194c <__mulsf3>
    1ae4:	ef 91       	pop	r30
    1ae6:	ff 91       	pop	r31
    1ae8:	0e 94 bc 0b 	call	0x1778	; 0x1778 <__fp_powser>
    1aec:	2f 91       	pop	r18
    1aee:	3f 91       	pop	r19
    1af0:	4f 91       	pop	r20
    1af2:	5f 91       	pop	r21
    1af4:	0c 94 a6 0c 	jmp	0x194c	; 0x194c <__mulsf3>

00001af8 <__udivmodsi4>:
    1af8:	a1 e2       	ldi	r26, 0x21	; 33
    1afa:	1a 2e       	mov	r1, r26
    1afc:	aa 1b       	sub	r26, r26
    1afe:	bb 1b       	sub	r27, r27
    1b00:	fd 01       	movw	r30, r26
    1b02:	0d c0       	rjmp	.+26     	; 0x1b1e <__udivmodsi4_ep>

00001b04 <__udivmodsi4_loop>:
    1b04:	aa 1f       	adc	r26, r26
    1b06:	bb 1f       	adc	r27, r27
    1b08:	ee 1f       	adc	r30, r30
    1b0a:	ff 1f       	adc	r31, r31
    1b0c:	a2 17       	cp	r26, r18
    1b0e:	b3 07       	cpc	r27, r19
    1b10:	e4 07       	cpc	r30, r20
    1b12:	f5 07       	cpc	r31, r21
    1b14:	20 f0       	brcs	.+8      	; 0x1b1e <__udivmodsi4_ep>
    1b16:	a2 1b       	sub	r26, r18
    1b18:	b3 0b       	sbc	r27, r19
    1b1a:	e4 0b       	sbc	r30, r20
    1b1c:	f5 0b       	sbc	r31, r21

00001b1e <__udivmodsi4_ep>:
    1b1e:	66 1f       	adc	r22, r22
    1b20:	77 1f       	adc	r23, r23
    1b22:	88 1f       	adc	r24, r24
    1b24:	99 1f       	adc	r25, r25
    1b26:	1a 94       	dec	r1
    1b28:	69 f7       	brne	.-38     	; 0x1b04 <__udivmodsi4_loop>
    1b2a:	60 95       	com	r22
    1b2c:	70 95       	com	r23
    1b2e:	80 95       	com	r24
    1b30:	90 95       	com	r25
    1b32:	9b 01       	movw	r18, r22
    1b34:	ac 01       	movw	r20, r24
    1b36:	bd 01       	movw	r22, r26
    1b38:	cf 01       	movw	r24, r30
    1b3a:	08 95       	ret

00001b3c <dtostrf>:
    1b3c:	ef 92       	push	r14
    1b3e:	0f 93       	push	r16
    1b40:	1f 93       	push	r17
    1b42:	cf 93       	push	r28
    1b44:	df 93       	push	r29
    1b46:	e8 01       	movw	r28, r16
    1b48:	47 fd       	sbrc	r20, 7
    1b4a:	02 c0       	rjmp	.+4      	; 0x1b50 <dtostrf+0x14>
    1b4c:	34 e0       	ldi	r19, 0x04	; 4
    1b4e:	01 c0       	rjmp	.+2      	; 0x1b52 <dtostrf+0x16>
    1b50:	34 e1       	ldi	r19, 0x14	; 20
    1b52:	04 2e       	mov	r0, r20
    1b54:	00 0c       	add	r0, r0
    1b56:	55 0b       	sbc	r21, r21
    1b58:	57 ff       	sbrs	r21, 7
    1b5a:	03 c0       	rjmp	.+6      	; 0x1b62 <dtostrf+0x26>
    1b5c:	51 95       	neg	r21
    1b5e:	41 95       	neg	r20
    1b60:	51 09       	sbc	r21, r1
    1b62:	e3 2e       	mov	r14, r19
    1b64:	02 2f       	mov	r16, r18
    1b66:	24 2f       	mov	r18, r20
    1b68:	ae 01       	movw	r20, r28
    1b6a:	0e 94 e5 0f 	call	0x1fca	; 0x1fca <dtoa_prf>
    1b6e:	ce 01       	movw	r24, r28
    1b70:	df 91       	pop	r29
    1b72:	cf 91       	pop	r28
    1b74:	1f 91       	pop	r17
    1b76:	0f 91       	pop	r16
    1b78:	ef 90       	pop	r14
    1b7a:	08 95       	ret

00001b7c <printf>:
    1b7c:	a0 e0       	ldi	r26, 0x00	; 0
    1b7e:	b0 e0       	ldi	r27, 0x00	; 0
    1b80:	e4 ec       	ldi	r30, 0xC4	; 196
    1b82:	fd e0       	ldi	r31, 0x0D	; 13
    1b84:	0c 94 d7 12 	jmp	0x25ae	; 0x25ae <__prologue_saves__+0x20>
    1b88:	ae 01       	movw	r20, r28
    1b8a:	4b 5f       	subi	r20, 0xFB	; 251
    1b8c:	5f 4f       	sbci	r21, 0xFF	; 255
    1b8e:	fa 01       	movw	r30, r20
    1b90:	61 91       	ld	r22, Z+
    1b92:	71 91       	ld	r23, Z+
    1b94:	af 01       	movw	r20, r30
    1b96:	80 91 6c 38 	lds	r24, 0x386C	; 0x80386c <__iob+0x2>
    1b9a:	90 91 6d 38 	lds	r25, 0x386D	; 0x80386d <__iob+0x3>
    1b9e:	0e 94 04 0e 	call	0x1c08	; 0x1c08 <vfprintf>
    1ba2:	e2 e0       	ldi	r30, 0x02	; 2
    1ba4:	0c 94 f0 12 	jmp	0x25e0	; 0x25e0 <__epilogue_restores__+0x20>

00001ba8 <puts>:
    1ba8:	0f 93       	push	r16
    1baa:	1f 93       	push	r17
    1bac:	cf 93       	push	r28
    1bae:	df 93       	push	r29
    1bb0:	e0 91 6c 38 	lds	r30, 0x386C	; 0x80386c <__iob+0x2>
    1bb4:	f0 91 6d 38 	lds	r31, 0x386D	; 0x80386d <__iob+0x3>
    1bb8:	23 81       	ldd	r18, Z+3	; 0x03
    1bba:	21 ff       	sbrs	r18, 1
    1bbc:	1b c0       	rjmp	.+54     	; 0x1bf4 <puts+0x4c>
    1bbe:	8c 01       	movw	r16, r24
    1bc0:	d0 e0       	ldi	r29, 0x00	; 0
    1bc2:	c0 e0       	ldi	r28, 0x00	; 0
    1bc4:	f8 01       	movw	r30, r16
    1bc6:	81 91       	ld	r24, Z+
    1bc8:	8f 01       	movw	r16, r30
    1bca:	60 91 6c 38 	lds	r22, 0x386C	; 0x80386c <__iob+0x2>
    1bce:	70 91 6d 38 	lds	r23, 0x386D	; 0x80386d <__iob+0x3>
    1bd2:	db 01       	movw	r26, r22
    1bd4:	18 96       	adiw	r26, 0x08	; 8
    1bd6:	ed 91       	ld	r30, X+
    1bd8:	fc 91       	ld	r31, X
    1bda:	19 97       	sbiw	r26, 0x09	; 9
    1bdc:	88 23       	and	r24, r24
    1bde:	31 f0       	breq	.+12     	; 0x1bec <puts+0x44>
    1be0:	09 95       	icall
    1be2:	89 2b       	or	r24, r25
    1be4:	79 f3       	breq	.-34     	; 0x1bc4 <puts+0x1c>
    1be6:	df ef       	ldi	r29, 0xFF	; 255
    1be8:	cf ef       	ldi	r28, 0xFF	; 255
    1bea:	ec cf       	rjmp	.-40     	; 0x1bc4 <puts+0x1c>
    1bec:	8a e0       	ldi	r24, 0x0A	; 10
    1bee:	09 95       	icall
    1bf0:	89 2b       	or	r24, r25
    1bf2:	19 f0       	breq	.+6      	; 0x1bfa <puts+0x52>
    1bf4:	8f ef       	ldi	r24, 0xFF	; 255
    1bf6:	9f ef       	ldi	r25, 0xFF	; 255
    1bf8:	02 c0       	rjmp	.+4      	; 0x1bfe <puts+0x56>
    1bfa:	8d 2f       	mov	r24, r29
    1bfc:	9c 2f       	mov	r25, r28
    1bfe:	df 91       	pop	r29
    1c00:	cf 91       	pop	r28
    1c02:	1f 91       	pop	r17
    1c04:	0f 91       	pop	r16
    1c06:	08 95       	ret

00001c08 <vfprintf>:
    1c08:	ab e0       	ldi	r26, 0x0B	; 11
    1c0a:	b0 e0       	ldi	r27, 0x00	; 0
    1c0c:	ea e0       	ldi	r30, 0x0A	; 10
    1c0e:	fe e0       	ldi	r31, 0x0E	; 14
    1c10:	0c 94 c7 12 	jmp	0x258e	; 0x258e <__prologue_saves__>
    1c14:	6c 01       	movw	r12, r24
    1c16:	7b 01       	movw	r14, r22
    1c18:	8a 01       	movw	r16, r20
    1c1a:	fc 01       	movw	r30, r24
    1c1c:	16 82       	std	Z+6, r1	; 0x06
    1c1e:	17 82       	std	Z+7, r1	; 0x07
    1c20:	83 81       	ldd	r24, Z+3	; 0x03
    1c22:	81 ff       	sbrs	r24, 1
    1c24:	cc c1       	rjmp	.+920    	; 0x1fbe <vfprintf+0x3b6>
    1c26:	ce 01       	movw	r24, r28
    1c28:	01 96       	adiw	r24, 0x01	; 1
    1c2a:	3c 01       	movw	r6, r24
    1c2c:	f6 01       	movw	r30, r12
    1c2e:	93 81       	ldd	r25, Z+3	; 0x03
    1c30:	f7 01       	movw	r30, r14
    1c32:	93 fd       	sbrc	r25, 3
    1c34:	85 91       	lpm	r24, Z+
    1c36:	93 ff       	sbrs	r25, 3
    1c38:	81 91       	ld	r24, Z+
    1c3a:	7f 01       	movw	r14, r30
    1c3c:	88 23       	and	r24, r24
    1c3e:	09 f4       	brne	.+2      	; 0x1c42 <vfprintf+0x3a>
    1c40:	ba c1       	rjmp	.+884    	; 0x1fb6 <vfprintf+0x3ae>
    1c42:	85 32       	cpi	r24, 0x25	; 37
    1c44:	39 f4       	brne	.+14     	; 0x1c54 <vfprintf+0x4c>
    1c46:	93 fd       	sbrc	r25, 3
    1c48:	85 91       	lpm	r24, Z+
    1c4a:	93 ff       	sbrs	r25, 3
    1c4c:	81 91       	ld	r24, Z+
    1c4e:	7f 01       	movw	r14, r30
    1c50:	85 32       	cpi	r24, 0x25	; 37
    1c52:	29 f4       	brne	.+10     	; 0x1c5e <vfprintf+0x56>
    1c54:	b6 01       	movw	r22, r12
    1c56:	90 e0       	ldi	r25, 0x00	; 0
    1c58:	0e 94 2d 12 	call	0x245a	; 0x245a <fputc>
    1c5c:	e7 cf       	rjmp	.-50     	; 0x1c2c <vfprintf+0x24>
    1c5e:	91 2c       	mov	r9, r1
    1c60:	21 2c       	mov	r2, r1
    1c62:	31 2c       	mov	r3, r1
    1c64:	ff e1       	ldi	r31, 0x1F	; 31
    1c66:	f3 15       	cp	r31, r3
    1c68:	d8 f0       	brcs	.+54     	; 0x1ca0 <vfprintf+0x98>
    1c6a:	8b 32       	cpi	r24, 0x2B	; 43
    1c6c:	79 f0       	breq	.+30     	; 0x1c8c <vfprintf+0x84>
    1c6e:	38 f4       	brcc	.+14     	; 0x1c7e <vfprintf+0x76>
    1c70:	80 32       	cpi	r24, 0x20	; 32
    1c72:	79 f0       	breq	.+30     	; 0x1c92 <vfprintf+0x8a>
    1c74:	83 32       	cpi	r24, 0x23	; 35
    1c76:	a1 f4       	brne	.+40     	; 0x1ca0 <vfprintf+0x98>
    1c78:	23 2d       	mov	r18, r3
    1c7a:	20 61       	ori	r18, 0x10	; 16
    1c7c:	1d c0       	rjmp	.+58     	; 0x1cb8 <vfprintf+0xb0>
    1c7e:	8d 32       	cpi	r24, 0x2D	; 45
    1c80:	61 f0       	breq	.+24     	; 0x1c9a <vfprintf+0x92>
    1c82:	80 33       	cpi	r24, 0x30	; 48
    1c84:	69 f4       	brne	.+26     	; 0x1ca0 <vfprintf+0x98>
    1c86:	23 2d       	mov	r18, r3
    1c88:	21 60       	ori	r18, 0x01	; 1
    1c8a:	16 c0       	rjmp	.+44     	; 0x1cb8 <vfprintf+0xb0>
    1c8c:	83 2d       	mov	r24, r3
    1c8e:	82 60       	ori	r24, 0x02	; 2
    1c90:	38 2e       	mov	r3, r24
    1c92:	e3 2d       	mov	r30, r3
    1c94:	e4 60       	ori	r30, 0x04	; 4
    1c96:	3e 2e       	mov	r3, r30
    1c98:	2a c0       	rjmp	.+84     	; 0x1cee <vfprintf+0xe6>
    1c9a:	f3 2d       	mov	r31, r3
    1c9c:	f8 60       	ori	r31, 0x08	; 8
    1c9e:	1d c0       	rjmp	.+58     	; 0x1cda <vfprintf+0xd2>
    1ca0:	37 fc       	sbrc	r3, 7
    1ca2:	2d c0       	rjmp	.+90     	; 0x1cfe <vfprintf+0xf6>
    1ca4:	20 ed       	ldi	r18, 0xD0	; 208
    1ca6:	28 0f       	add	r18, r24
    1ca8:	2a 30       	cpi	r18, 0x0A	; 10
    1caa:	40 f0       	brcs	.+16     	; 0x1cbc <vfprintf+0xb4>
    1cac:	8e 32       	cpi	r24, 0x2E	; 46
    1cae:	b9 f4       	brne	.+46     	; 0x1cde <vfprintf+0xd6>
    1cb0:	36 fc       	sbrc	r3, 6
    1cb2:	81 c1       	rjmp	.+770    	; 0x1fb6 <vfprintf+0x3ae>
    1cb4:	23 2d       	mov	r18, r3
    1cb6:	20 64       	ori	r18, 0x40	; 64
    1cb8:	32 2e       	mov	r3, r18
    1cba:	19 c0       	rjmp	.+50     	; 0x1cee <vfprintf+0xe6>
    1cbc:	36 fe       	sbrs	r3, 6
    1cbe:	06 c0       	rjmp	.+12     	; 0x1ccc <vfprintf+0xc4>
    1cc0:	8a e0       	ldi	r24, 0x0A	; 10
    1cc2:	98 9e       	mul	r9, r24
    1cc4:	20 0d       	add	r18, r0
    1cc6:	11 24       	eor	r1, r1
    1cc8:	92 2e       	mov	r9, r18
    1cca:	11 c0       	rjmp	.+34     	; 0x1cee <vfprintf+0xe6>
    1ccc:	ea e0       	ldi	r30, 0x0A	; 10
    1cce:	2e 9e       	mul	r2, r30
    1cd0:	20 0d       	add	r18, r0
    1cd2:	11 24       	eor	r1, r1
    1cd4:	22 2e       	mov	r2, r18
    1cd6:	f3 2d       	mov	r31, r3
    1cd8:	f0 62       	ori	r31, 0x20	; 32
    1cda:	3f 2e       	mov	r3, r31
    1cdc:	08 c0       	rjmp	.+16     	; 0x1cee <vfprintf+0xe6>
    1cde:	8c 36       	cpi	r24, 0x6C	; 108
    1ce0:	21 f4       	brne	.+8      	; 0x1cea <vfprintf+0xe2>
    1ce2:	83 2d       	mov	r24, r3
    1ce4:	80 68       	ori	r24, 0x80	; 128
    1ce6:	38 2e       	mov	r3, r24
    1ce8:	02 c0       	rjmp	.+4      	; 0x1cee <vfprintf+0xe6>
    1cea:	88 36       	cpi	r24, 0x68	; 104
    1cec:	41 f4       	brne	.+16     	; 0x1cfe <vfprintf+0xf6>
    1cee:	f7 01       	movw	r30, r14
    1cf0:	93 fd       	sbrc	r25, 3
    1cf2:	85 91       	lpm	r24, Z+
    1cf4:	93 ff       	sbrs	r25, 3
    1cf6:	81 91       	ld	r24, Z+
    1cf8:	7f 01       	movw	r14, r30
    1cfa:	81 11       	cpse	r24, r1
    1cfc:	b3 cf       	rjmp	.-154    	; 0x1c64 <vfprintf+0x5c>
    1cfe:	98 2f       	mov	r25, r24
    1d00:	9f 7d       	andi	r25, 0xDF	; 223
    1d02:	95 54       	subi	r25, 0x45	; 69
    1d04:	93 30       	cpi	r25, 0x03	; 3
    1d06:	28 f4       	brcc	.+10     	; 0x1d12 <vfprintf+0x10a>
    1d08:	0c 5f       	subi	r16, 0xFC	; 252
    1d0a:	1f 4f       	sbci	r17, 0xFF	; 255
    1d0c:	9f e3       	ldi	r25, 0x3F	; 63
    1d0e:	99 83       	std	Y+1, r25	; 0x01
    1d10:	0d c0       	rjmp	.+26     	; 0x1d2c <vfprintf+0x124>
    1d12:	83 36       	cpi	r24, 0x63	; 99
    1d14:	31 f0       	breq	.+12     	; 0x1d22 <vfprintf+0x11a>
    1d16:	83 37       	cpi	r24, 0x73	; 115
    1d18:	71 f0       	breq	.+28     	; 0x1d36 <vfprintf+0x12e>
    1d1a:	83 35       	cpi	r24, 0x53	; 83
    1d1c:	09 f0       	breq	.+2      	; 0x1d20 <vfprintf+0x118>
    1d1e:	59 c0       	rjmp	.+178    	; 0x1dd2 <vfprintf+0x1ca>
    1d20:	21 c0       	rjmp	.+66     	; 0x1d64 <vfprintf+0x15c>
    1d22:	f8 01       	movw	r30, r16
    1d24:	80 81       	ld	r24, Z
    1d26:	89 83       	std	Y+1, r24	; 0x01
    1d28:	0e 5f       	subi	r16, 0xFE	; 254
    1d2a:	1f 4f       	sbci	r17, 0xFF	; 255
    1d2c:	88 24       	eor	r8, r8
    1d2e:	83 94       	inc	r8
    1d30:	91 2c       	mov	r9, r1
    1d32:	53 01       	movw	r10, r6
    1d34:	13 c0       	rjmp	.+38     	; 0x1d5c <vfprintf+0x154>
    1d36:	28 01       	movw	r4, r16
    1d38:	f2 e0       	ldi	r31, 0x02	; 2
    1d3a:	4f 0e       	add	r4, r31
    1d3c:	51 1c       	adc	r5, r1
    1d3e:	f8 01       	movw	r30, r16
    1d40:	a0 80       	ld	r10, Z
    1d42:	b1 80       	ldd	r11, Z+1	; 0x01
    1d44:	36 fe       	sbrs	r3, 6
    1d46:	03 c0       	rjmp	.+6      	; 0x1d4e <vfprintf+0x146>
    1d48:	69 2d       	mov	r22, r9
    1d4a:	70 e0       	ldi	r23, 0x00	; 0
    1d4c:	02 c0       	rjmp	.+4      	; 0x1d52 <vfprintf+0x14a>
    1d4e:	6f ef       	ldi	r22, 0xFF	; 255
    1d50:	7f ef       	ldi	r23, 0xFF	; 255
    1d52:	c5 01       	movw	r24, r10
    1d54:	0e 94 22 12 	call	0x2444	; 0x2444 <strnlen>
    1d58:	4c 01       	movw	r8, r24
    1d5a:	82 01       	movw	r16, r4
    1d5c:	f3 2d       	mov	r31, r3
    1d5e:	ff 77       	andi	r31, 0x7F	; 127
    1d60:	3f 2e       	mov	r3, r31
    1d62:	16 c0       	rjmp	.+44     	; 0x1d90 <vfprintf+0x188>
    1d64:	28 01       	movw	r4, r16
    1d66:	22 e0       	ldi	r18, 0x02	; 2
    1d68:	42 0e       	add	r4, r18
    1d6a:	51 1c       	adc	r5, r1
    1d6c:	f8 01       	movw	r30, r16
    1d6e:	a0 80       	ld	r10, Z
    1d70:	b1 80       	ldd	r11, Z+1	; 0x01
    1d72:	36 fe       	sbrs	r3, 6
    1d74:	03 c0       	rjmp	.+6      	; 0x1d7c <vfprintf+0x174>
    1d76:	69 2d       	mov	r22, r9
    1d78:	70 e0       	ldi	r23, 0x00	; 0
    1d7a:	02 c0       	rjmp	.+4      	; 0x1d80 <vfprintf+0x178>
    1d7c:	6f ef       	ldi	r22, 0xFF	; 255
    1d7e:	7f ef       	ldi	r23, 0xFF	; 255
    1d80:	c5 01       	movw	r24, r10
    1d82:	0e 94 17 12 	call	0x242e	; 0x242e <strnlen_P>
    1d86:	4c 01       	movw	r8, r24
    1d88:	f3 2d       	mov	r31, r3
    1d8a:	f0 68       	ori	r31, 0x80	; 128
    1d8c:	3f 2e       	mov	r3, r31
    1d8e:	82 01       	movw	r16, r4
    1d90:	33 fc       	sbrc	r3, 3
    1d92:	1b c0       	rjmp	.+54     	; 0x1dca <vfprintf+0x1c2>
    1d94:	82 2d       	mov	r24, r2
    1d96:	90 e0       	ldi	r25, 0x00	; 0
    1d98:	88 16       	cp	r8, r24
    1d9a:	99 06       	cpc	r9, r25
    1d9c:	b0 f4       	brcc	.+44     	; 0x1dca <vfprintf+0x1c2>
    1d9e:	b6 01       	movw	r22, r12
    1da0:	80 e2       	ldi	r24, 0x20	; 32
    1da2:	90 e0       	ldi	r25, 0x00	; 0
    1da4:	0e 94 2d 12 	call	0x245a	; 0x245a <fputc>
    1da8:	2a 94       	dec	r2
    1daa:	f4 cf       	rjmp	.-24     	; 0x1d94 <vfprintf+0x18c>
    1dac:	f5 01       	movw	r30, r10
    1dae:	37 fc       	sbrc	r3, 7
    1db0:	85 91       	lpm	r24, Z+
    1db2:	37 fe       	sbrs	r3, 7
    1db4:	81 91       	ld	r24, Z+
    1db6:	5f 01       	movw	r10, r30
    1db8:	b6 01       	movw	r22, r12
    1dba:	90 e0       	ldi	r25, 0x00	; 0
    1dbc:	0e 94 2d 12 	call	0x245a	; 0x245a <fputc>
    1dc0:	21 10       	cpse	r2, r1
    1dc2:	2a 94       	dec	r2
    1dc4:	21 e0       	ldi	r18, 0x01	; 1
    1dc6:	82 1a       	sub	r8, r18
    1dc8:	91 08       	sbc	r9, r1
    1dca:	81 14       	cp	r8, r1
    1dcc:	91 04       	cpc	r9, r1
    1dce:	71 f7       	brne	.-36     	; 0x1dac <vfprintf+0x1a4>
    1dd0:	e8 c0       	rjmp	.+464    	; 0x1fa2 <vfprintf+0x39a>
    1dd2:	84 36       	cpi	r24, 0x64	; 100
    1dd4:	11 f0       	breq	.+4      	; 0x1dda <vfprintf+0x1d2>
    1dd6:	89 36       	cpi	r24, 0x69	; 105
    1dd8:	41 f5       	brne	.+80     	; 0x1e2a <vfprintf+0x222>
    1dda:	f8 01       	movw	r30, r16
    1ddc:	37 fe       	sbrs	r3, 7
    1dde:	07 c0       	rjmp	.+14     	; 0x1dee <vfprintf+0x1e6>
    1de0:	60 81       	ld	r22, Z
    1de2:	71 81       	ldd	r23, Z+1	; 0x01
    1de4:	82 81       	ldd	r24, Z+2	; 0x02
    1de6:	93 81       	ldd	r25, Z+3	; 0x03
    1de8:	0c 5f       	subi	r16, 0xFC	; 252
    1dea:	1f 4f       	sbci	r17, 0xFF	; 255
    1dec:	08 c0       	rjmp	.+16     	; 0x1dfe <vfprintf+0x1f6>
    1dee:	60 81       	ld	r22, Z
    1df0:	71 81       	ldd	r23, Z+1	; 0x01
    1df2:	07 2e       	mov	r0, r23
    1df4:	00 0c       	add	r0, r0
    1df6:	88 0b       	sbc	r24, r24
    1df8:	99 0b       	sbc	r25, r25
    1dfa:	0e 5f       	subi	r16, 0xFE	; 254
    1dfc:	1f 4f       	sbci	r17, 0xFF	; 255
    1dfe:	f3 2d       	mov	r31, r3
    1e00:	ff 76       	andi	r31, 0x6F	; 111
    1e02:	3f 2e       	mov	r3, r31
    1e04:	97 ff       	sbrs	r25, 7
    1e06:	09 c0       	rjmp	.+18     	; 0x1e1a <vfprintf+0x212>
    1e08:	90 95       	com	r25
    1e0a:	80 95       	com	r24
    1e0c:	70 95       	com	r23
    1e0e:	61 95       	neg	r22
    1e10:	7f 4f       	sbci	r23, 0xFF	; 255
    1e12:	8f 4f       	sbci	r24, 0xFF	; 255
    1e14:	9f 4f       	sbci	r25, 0xFF	; 255
    1e16:	f0 68       	ori	r31, 0x80	; 128
    1e18:	3f 2e       	mov	r3, r31
    1e1a:	2a e0       	ldi	r18, 0x0A	; 10
    1e1c:	30 e0       	ldi	r19, 0x00	; 0
    1e1e:	a3 01       	movw	r20, r6
    1e20:	0e 94 69 12 	call	0x24d2	; 0x24d2 <__ultoa_invert>
    1e24:	88 2e       	mov	r8, r24
    1e26:	86 18       	sub	r8, r6
    1e28:	45 c0       	rjmp	.+138    	; 0x1eb4 <vfprintf+0x2ac>
    1e2a:	85 37       	cpi	r24, 0x75	; 117
    1e2c:	31 f4       	brne	.+12     	; 0x1e3a <vfprintf+0x232>
    1e2e:	23 2d       	mov	r18, r3
    1e30:	2f 7e       	andi	r18, 0xEF	; 239
    1e32:	b2 2e       	mov	r11, r18
    1e34:	2a e0       	ldi	r18, 0x0A	; 10
    1e36:	30 e0       	ldi	r19, 0x00	; 0
    1e38:	25 c0       	rjmp	.+74     	; 0x1e84 <vfprintf+0x27c>
    1e3a:	93 2d       	mov	r25, r3
    1e3c:	99 7f       	andi	r25, 0xF9	; 249
    1e3e:	b9 2e       	mov	r11, r25
    1e40:	8f 36       	cpi	r24, 0x6F	; 111
    1e42:	c1 f0       	breq	.+48     	; 0x1e74 <vfprintf+0x26c>
    1e44:	18 f4       	brcc	.+6      	; 0x1e4c <vfprintf+0x244>
    1e46:	88 35       	cpi	r24, 0x58	; 88
    1e48:	79 f0       	breq	.+30     	; 0x1e68 <vfprintf+0x260>
    1e4a:	b5 c0       	rjmp	.+362    	; 0x1fb6 <vfprintf+0x3ae>
    1e4c:	80 37       	cpi	r24, 0x70	; 112
    1e4e:	19 f0       	breq	.+6      	; 0x1e56 <vfprintf+0x24e>
    1e50:	88 37       	cpi	r24, 0x78	; 120
    1e52:	21 f0       	breq	.+8      	; 0x1e5c <vfprintf+0x254>
    1e54:	b0 c0       	rjmp	.+352    	; 0x1fb6 <vfprintf+0x3ae>
    1e56:	e9 2f       	mov	r30, r25
    1e58:	e0 61       	ori	r30, 0x10	; 16
    1e5a:	be 2e       	mov	r11, r30
    1e5c:	b4 fe       	sbrs	r11, 4
    1e5e:	0d c0       	rjmp	.+26     	; 0x1e7a <vfprintf+0x272>
    1e60:	fb 2d       	mov	r31, r11
    1e62:	f4 60       	ori	r31, 0x04	; 4
    1e64:	bf 2e       	mov	r11, r31
    1e66:	09 c0       	rjmp	.+18     	; 0x1e7a <vfprintf+0x272>
    1e68:	34 fe       	sbrs	r3, 4
    1e6a:	0a c0       	rjmp	.+20     	; 0x1e80 <vfprintf+0x278>
    1e6c:	29 2f       	mov	r18, r25
    1e6e:	26 60       	ori	r18, 0x06	; 6
    1e70:	b2 2e       	mov	r11, r18
    1e72:	06 c0       	rjmp	.+12     	; 0x1e80 <vfprintf+0x278>
    1e74:	28 e0       	ldi	r18, 0x08	; 8
    1e76:	30 e0       	ldi	r19, 0x00	; 0
    1e78:	05 c0       	rjmp	.+10     	; 0x1e84 <vfprintf+0x27c>
    1e7a:	20 e1       	ldi	r18, 0x10	; 16
    1e7c:	30 e0       	ldi	r19, 0x00	; 0
    1e7e:	02 c0       	rjmp	.+4      	; 0x1e84 <vfprintf+0x27c>
    1e80:	20 e1       	ldi	r18, 0x10	; 16
    1e82:	32 e0       	ldi	r19, 0x02	; 2
    1e84:	f8 01       	movw	r30, r16
    1e86:	b7 fe       	sbrs	r11, 7
    1e88:	07 c0       	rjmp	.+14     	; 0x1e98 <vfprintf+0x290>
    1e8a:	60 81       	ld	r22, Z
    1e8c:	71 81       	ldd	r23, Z+1	; 0x01
    1e8e:	82 81       	ldd	r24, Z+2	; 0x02
    1e90:	93 81       	ldd	r25, Z+3	; 0x03
    1e92:	0c 5f       	subi	r16, 0xFC	; 252
    1e94:	1f 4f       	sbci	r17, 0xFF	; 255
    1e96:	06 c0       	rjmp	.+12     	; 0x1ea4 <vfprintf+0x29c>
    1e98:	60 81       	ld	r22, Z
    1e9a:	71 81       	ldd	r23, Z+1	; 0x01
    1e9c:	80 e0       	ldi	r24, 0x00	; 0
    1e9e:	90 e0       	ldi	r25, 0x00	; 0
    1ea0:	0e 5f       	subi	r16, 0xFE	; 254
    1ea2:	1f 4f       	sbci	r17, 0xFF	; 255
    1ea4:	a3 01       	movw	r20, r6
    1ea6:	0e 94 69 12 	call	0x24d2	; 0x24d2 <__ultoa_invert>
    1eaa:	88 2e       	mov	r8, r24
    1eac:	86 18       	sub	r8, r6
    1eae:	fb 2d       	mov	r31, r11
    1eb0:	ff 77       	andi	r31, 0x7F	; 127
    1eb2:	3f 2e       	mov	r3, r31
    1eb4:	36 fe       	sbrs	r3, 6
    1eb6:	0d c0       	rjmp	.+26     	; 0x1ed2 <vfprintf+0x2ca>
    1eb8:	23 2d       	mov	r18, r3
    1eba:	2e 7f       	andi	r18, 0xFE	; 254
    1ebc:	a2 2e       	mov	r10, r18
    1ebe:	89 14       	cp	r8, r9
    1ec0:	58 f4       	brcc	.+22     	; 0x1ed8 <vfprintf+0x2d0>
    1ec2:	34 fe       	sbrs	r3, 4
    1ec4:	0b c0       	rjmp	.+22     	; 0x1edc <vfprintf+0x2d4>
    1ec6:	32 fc       	sbrc	r3, 2
    1ec8:	09 c0       	rjmp	.+18     	; 0x1edc <vfprintf+0x2d4>
    1eca:	83 2d       	mov	r24, r3
    1ecc:	8e 7e       	andi	r24, 0xEE	; 238
    1ece:	a8 2e       	mov	r10, r24
    1ed0:	05 c0       	rjmp	.+10     	; 0x1edc <vfprintf+0x2d4>
    1ed2:	b8 2c       	mov	r11, r8
    1ed4:	a3 2c       	mov	r10, r3
    1ed6:	03 c0       	rjmp	.+6      	; 0x1ede <vfprintf+0x2d6>
    1ed8:	b8 2c       	mov	r11, r8
    1eda:	01 c0       	rjmp	.+2      	; 0x1ede <vfprintf+0x2d6>
    1edc:	b9 2c       	mov	r11, r9
    1ede:	a4 fe       	sbrs	r10, 4
    1ee0:	0f c0       	rjmp	.+30     	; 0x1f00 <vfprintf+0x2f8>
    1ee2:	fe 01       	movw	r30, r28
    1ee4:	e8 0d       	add	r30, r8
    1ee6:	f1 1d       	adc	r31, r1
    1ee8:	80 81       	ld	r24, Z
    1eea:	80 33       	cpi	r24, 0x30	; 48
    1eec:	21 f4       	brne	.+8      	; 0x1ef6 <vfprintf+0x2ee>
    1eee:	9a 2d       	mov	r25, r10
    1ef0:	99 7e       	andi	r25, 0xE9	; 233
    1ef2:	a9 2e       	mov	r10, r25
    1ef4:	09 c0       	rjmp	.+18     	; 0x1f08 <vfprintf+0x300>
    1ef6:	a2 fe       	sbrs	r10, 2
    1ef8:	06 c0       	rjmp	.+12     	; 0x1f06 <vfprintf+0x2fe>
    1efa:	b3 94       	inc	r11
    1efc:	b3 94       	inc	r11
    1efe:	04 c0       	rjmp	.+8      	; 0x1f08 <vfprintf+0x300>
    1f00:	8a 2d       	mov	r24, r10
    1f02:	86 78       	andi	r24, 0x86	; 134
    1f04:	09 f0       	breq	.+2      	; 0x1f08 <vfprintf+0x300>
    1f06:	b3 94       	inc	r11
    1f08:	a3 fc       	sbrc	r10, 3
    1f0a:	11 c0       	rjmp	.+34     	; 0x1f2e <vfprintf+0x326>
    1f0c:	a0 fe       	sbrs	r10, 0
    1f0e:	06 c0       	rjmp	.+12     	; 0x1f1c <vfprintf+0x314>
    1f10:	b2 14       	cp	r11, r2
    1f12:	88 f4       	brcc	.+34     	; 0x1f36 <vfprintf+0x32e>
    1f14:	28 0c       	add	r2, r8
    1f16:	92 2c       	mov	r9, r2
    1f18:	9b 18       	sub	r9, r11
    1f1a:	0e c0       	rjmp	.+28     	; 0x1f38 <vfprintf+0x330>
    1f1c:	b2 14       	cp	r11, r2
    1f1e:	60 f4       	brcc	.+24     	; 0x1f38 <vfprintf+0x330>
    1f20:	b6 01       	movw	r22, r12
    1f22:	80 e2       	ldi	r24, 0x20	; 32
    1f24:	90 e0       	ldi	r25, 0x00	; 0
    1f26:	0e 94 2d 12 	call	0x245a	; 0x245a <fputc>
    1f2a:	b3 94       	inc	r11
    1f2c:	f7 cf       	rjmp	.-18     	; 0x1f1c <vfprintf+0x314>
    1f2e:	b2 14       	cp	r11, r2
    1f30:	18 f4       	brcc	.+6      	; 0x1f38 <vfprintf+0x330>
    1f32:	2b 18       	sub	r2, r11
    1f34:	02 c0       	rjmp	.+4      	; 0x1f3a <vfprintf+0x332>
    1f36:	98 2c       	mov	r9, r8
    1f38:	21 2c       	mov	r2, r1
    1f3a:	a4 fe       	sbrs	r10, 4
    1f3c:	10 c0       	rjmp	.+32     	; 0x1f5e <vfprintf+0x356>
    1f3e:	b6 01       	movw	r22, r12
    1f40:	80 e3       	ldi	r24, 0x30	; 48
    1f42:	90 e0       	ldi	r25, 0x00	; 0
    1f44:	0e 94 2d 12 	call	0x245a	; 0x245a <fputc>
    1f48:	a2 fe       	sbrs	r10, 2
    1f4a:	17 c0       	rjmp	.+46     	; 0x1f7a <vfprintf+0x372>
    1f4c:	a1 fc       	sbrc	r10, 1
    1f4e:	03 c0       	rjmp	.+6      	; 0x1f56 <vfprintf+0x34e>
    1f50:	88 e7       	ldi	r24, 0x78	; 120
    1f52:	90 e0       	ldi	r25, 0x00	; 0
    1f54:	02 c0       	rjmp	.+4      	; 0x1f5a <vfprintf+0x352>
    1f56:	88 e5       	ldi	r24, 0x58	; 88
    1f58:	90 e0       	ldi	r25, 0x00	; 0
    1f5a:	b6 01       	movw	r22, r12
    1f5c:	0c c0       	rjmp	.+24     	; 0x1f76 <vfprintf+0x36e>
    1f5e:	8a 2d       	mov	r24, r10
    1f60:	86 78       	andi	r24, 0x86	; 134
    1f62:	59 f0       	breq	.+22     	; 0x1f7a <vfprintf+0x372>
    1f64:	a1 fe       	sbrs	r10, 1
    1f66:	02 c0       	rjmp	.+4      	; 0x1f6c <vfprintf+0x364>
    1f68:	8b e2       	ldi	r24, 0x2B	; 43
    1f6a:	01 c0       	rjmp	.+2      	; 0x1f6e <vfprintf+0x366>
    1f6c:	80 e2       	ldi	r24, 0x20	; 32
    1f6e:	a7 fc       	sbrc	r10, 7
    1f70:	8d e2       	ldi	r24, 0x2D	; 45
    1f72:	b6 01       	movw	r22, r12
    1f74:	90 e0       	ldi	r25, 0x00	; 0
    1f76:	0e 94 2d 12 	call	0x245a	; 0x245a <fputc>
    1f7a:	89 14       	cp	r8, r9
    1f7c:	38 f4       	brcc	.+14     	; 0x1f8c <vfprintf+0x384>
    1f7e:	b6 01       	movw	r22, r12
    1f80:	80 e3       	ldi	r24, 0x30	; 48
    1f82:	90 e0       	ldi	r25, 0x00	; 0
    1f84:	0e 94 2d 12 	call	0x245a	; 0x245a <fputc>
    1f88:	9a 94       	dec	r9
    1f8a:	f7 cf       	rjmp	.-18     	; 0x1f7a <vfprintf+0x372>
    1f8c:	8a 94       	dec	r8
    1f8e:	f3 01       	movw	r30, r6
    1f90:	e8 0d       	add	r30, r8
    1f92:	f1 1d       	adc	r31, r1
    1f94:	80 81       	ld	r24, Z
    1f96:	b6 01       	movw	r22, r12
    1f98:	90 e0       	ldi	r25, 0x00	; 0
    1f9a:	0e 94 2d 12 	call	0x245a	; 0x245a <fputc>
    1f9e:	81 10       	cpse	r8, r1
    1fa0:	f5 cf       	rjmp	.-22     	; 0x1f8c <vfprintf+0x384>
    1fa2:	22 20       	and	r2, r2
    1fa4:	09 f4       	brne	.+2      	; 0x1fa8 <vfprintf+0x3a0>
    1fa6:	42 ce       	rjmp	.-892    	; 0x1c2c <vfprintf+0x24>
    1fa8:	b6 01       	movw	r22, r12
    1faa:	80 e2       	ldi	r24, 0x20	; 32
    1fac:	90 e0       	ldi	r25, 0x00	; 0
    1fae:	0e 94 2d 12 	call	0x245a	; 0x245a <fputc>
    1fb2:	2a 94       	dec	r2
    1fb4:	f6 cf       	rjmp	.-20     	; 0x1fa2 <vfprintf+0x39a>
    1fb6:	f6 01       	movw	r30, r12
    1fb8:	86 81       	ldd	r24, Z+6	; 0x06
    1fba:	97 81       	ldd	r25, Z+7	; 0x07
    1fbc:	02 c0       	rjmp	.+4      	; 0x1fc2 <vfprintf+0x3ba>
    1fbe:	8f ef       	ldi	r24, 0xFF	; 255
    1fc0:	9f ef       	ldi	r25, 0xFF	; 255
    1fc2:	2b 96       	adiw	r28, 0x0b	; 11
    1fc4:	e2 e1       	ldi	r30, 0x12	; 18
    1fc6:	0c 94 e0 12 	jmp	0x25c0	; 0x25c0 <__epilogue_restores__>

00001fca <dtoa_prf>:
    1fca:	a9 e0       	ldi	r26, 0x09	; 9
    1fcc:	b0 e0       	ldi	r27, 0x00	; 0
    1fce:	eb ee       	ldi	r30, 0xEB	; 235
    1fd0:	ff e0       	ldi	r31, 0x0F	; 15
    1fd2:	0c 94 cd 12 	jmp	0x259a	; 0x259a <__prologue_saves__+0xc>
    1fd6:	6a 01       	movw	r12, r20
    1fd8:	12 2f       	mov	r17, r18
    1fda:	b0 2e       	mov	r11, r16
    1fdc:	2b e3       	ldi	r18, 0x3B	; 59
    1fde:	20 17       	cp	r18, r16
    1fe0:	20 f0       	brcs	.+8      	; 0x1fea <dtoa_prf+0x20>
    1fe2:	ff 24       	eor	r15, r15
    1fe4:	f3 94       	inc	r15
    1fe6:	f0 0e       	add	r15, r16
    1fe8:	02 c0       	rjmp	.+4      	; 0x1fee <dtoa_prf+0x24>
    1fea:	2c e3       	ldi	r18, 0x3C	; 60
    1fec:	f2 2e       	mov	r15, r18
    1fee:	0f 2d       	mov	r16, r15
    1ff0:	27 e0       	ldi	r18, 0x07	; 7
    1ff2:	ae 01       	movw	r20, r28
    1ff4:	4f 5f       	subi	r20, 0xFF	; 255
    1ff6:	5f 4f       	sbci	r21, 0xFF	; 255
    1ff8:	0e 94 3f 11 	call	0x227e	; 0x227e <__ftoa_engine>
    1ffc:	bc 01       	movw	r22, r24
    1ffe:	49 81       	ldd	r20, Y+1	; 0x01
    2000:	84 2f       	mov	r24, r20
    2002:	89 70       	andi	r24, 0x09	; 9
    2004:	81 30       	cpi	r24, 0x01	; 1
    2006:	31 f0       	breq	.+12     	; 0x2014 <dtoa_prf+0x4a>
    2008:	e1 fc       	sbrc	r14, 1
    200a:	06 c0       	rjmp	.+12     	; 0x2018 <dtoa_prf+0x4e>
    200c:	e0 fe       	sbrs	r14, 0
    200e:	06 c0       	rjmp	.+12     	; 0x201c <dtoa_prf+0x52>
    2010:	90 e2       	ldi	r25, 0x20	; 32
    2012:	05 c0       	rjmp	.+10     	; 0x201e <dtoa_prf+0x54>
    2014:	9d e2       	ldi	r25, 0x2D	; 45
    2016:	03 c0       	rjmp	.+6      	; 0x201e <dtoa_prf+0x54>
    2018:	9b e2       	ldi	r25, 0x2B	; 43
    201a:	01 c0       	rjmp	.+2      	; 0x201e <dtoa_prf+0x54>
    201c:	90 e0       	ldi	r25, 0x00	; 0
    201e:	5e 2d       	mov	r21, r14
    2020:	50 71       	andi	r21, 0x10	; 16
    2022:	43 ff       	sbrs	r20, 3
    2024:	3c c0       	rjmp	.+120    	; 0x209e <dtoa_prf+0xd4>
    2026:	91 11       	cpse	r25, r1
    2028:	02 c0       	rjmp	.+4      	; 0x202e <dtoa_prf+0x64>
    202a:	83 e0       	ldi	r24, 0x03	; 3
    202c:	01 c0       	rjmp	.+2      	; 0x2030 <dtoa_prf+0x66>
    202e:	84 e0       	ldi	r24, 0x04	; 4
    2030:	81 17       	cp	r24, r17
    2032:	18 f4       	brcc	.+6      	; 0x203a <dtoa_prf+0x70>
    2034:	21 2f       	mov	r18, r17
    2036:	28 1b       	sub	r18, r24
    2038:	01 c0       	rjmp	.+2      	; 0x203c <dtoa_prf+0x72>
    203a:	20 e0       	ldi	r18, 0x00	; 0
    203c:	51 11       	cpse	r21, r1
    203e:	0b c0       	rjmp	.+22     	; 0x2056 <dtoa_prf+0x8c>
    2040:	f6 01       	movw	r30, r12
    2042:	82 2f       	mov	r24, r18
    2044:	30 e2       	ldi	r19, 0x20	; 32
    2046:	88 23       	and	r24, r24
    2048:	19 f0       	breq	.+6      	; 0x2050 <dtoa_prf+0x86>
    204a:	31 93       	st	Z+, r19
    204c:	81 50       	subi	r24, 0x01	; 1
    204e:	fb cf       	rjmp	.-10     	; 0x2046 <dtoa_prf+0x7c>
    2050:	c2 0e       	add	r12, r18
    2052:	d1 1c       	adc	r13, r1
    2054:	20 e0       	ldi	r18, 0x00	; 0
    2056:	99 23       	and	r25, r25
    2058:	29 f0       	breq	.+10     	; 0x2064 <dtoa_prf+0x9a>
    205a:	d6 01       	movw	r26, r12
    205c:	9c 93       	st	X, r25
    205e:	f6 01       	movw	r30, r12
    2060:	31 96       	adiw	r30, 0x01	; 1
    2062:	6f 01       	movw	r12, r30
    2064:	c6 01       	movw	r24, r12
    2066:	03 96       	adiw	r24, 0x03	; 3
    2068:	e2 fe       	sbrs	r14, 2
    206a:	0a c0       	rjmp	.+20     	; 0x2080 <dtoa_prf+0xb6>
    206c:	3e e4       	ldi	r19, 0x4E	; 78
    206e:	d6 01       	movw	r26, r12
    2070:	3c 93       	st	X, r19
    2072:	41 e4       	ldi	r20, 0x41	; 65
    2074:	11 96       	adiw	r26, 0x01	; 1
    2076:	4c 93       	st	X, r20
    2078:	11 97       	sbiw	r26, 0x01	; 1
    207a:	12 96       	adiw	r26, 0x02	; 2
    207c:	3c 93       	st	X, r19
    207e:	06 c0       	rjmp	.+12     	; 0x208c <dtoa_prf+0xc2>
    2080:	3e e6       	ldi	r19, 0x6E	; 110
    2082:	f6 01       	movw	r30, r12
    2084:	30 83       	st	Z, r19
    2086:	41 e6       	ldi	r20, 0x61	; 97
    2088:	41 83       	std	Z+1, r20	; 0x01
    208a:	32 83       	std	Z+2, r19	; 0x02
    208c:	fc 01       	movw	r30, r24
    208e:	32 2f       	mov	r19, r18
    2090:	40 e2       	ldi	r20, 0x20	; 32
    2092:	33 23       	and	r19, r19
    2094:	09 f4       	brne	.+2      	; 0x2098 <dtoa_prf+0xce>
    2096:	42 c0       	rjmp	.+132    	; 0x211c <dtoa_prf+0x152>
    2098:	41 93       	st	Z+, r20
    209a:	31 50       	subi	r19, 0x01	; 1
    209c:	fa cf       	rjmp	.-12     	; 0x2092 <dtoa_prf+0xc8>
    209e:	42 ff       	sbrs	r20, 2
    20a0:	44 c0       	rjmp	.+136    	; 0x212a <dtoa_prf+0x160>
    20a2:	91 11       	cpse	r25, r1
    20a4:	02 c0       	rjmp	.+4      	; 0x20aa <dtoa_prf+0xe0>
    20a6:	83 e0       	ldi	r24, 0x03	; 3
    20a8:	01 c0       	rjmp	.+2      	; 0x20ac <dtoa_prf+0xe2>
    20aa:	84 e0       	ldi	r24, 0x04	; 4
    20ac:	81 17       	cp	r24, r17
    20ae:	18 f4       	brcc	.+6      	; 0x20b6 <dtoa_prf+0xec>
    20b0:	21 2f       	mov	r18, r17
    20b2:	28 1b       	sub	r18, r24
    20b4:	01 c0       	rjmp	.+2      	; 0x20b8 <dtoa_prf+0xee>
    20b6:	20 e0       	ldi	r18, 0x00	; 0
    20b8:	51 11       	cpse	r21, r1
    20ba:	0b c0       	rjmp	.+22     	; 0x20d2 <dtoa_prf+0x108>
    20bc:	f6 01       	movw	r30, r12
    20be:	82 2f       	mov	r24, r18
    20c0:	30 e2       	ldi	r19, 0x20	; 32
    20c2:	88 23       	and	r24, r24
    20c4:	19 f0       	breq	.+6      	; 0x20cc <dtoa_prf+0x102>
    20c6:	31 93       	st	Z+, r19
    20c8:	81 50       	subi	r24, 0x01	; 1
    20ca:	fb cf       	rjmp	.-10     	; 0x20c2 <dtoa_prf+0xf8>
    20cc:	c2 0e       	add	r12, r18
    20ce:	d1 1c       	adc	r13, r1
    20d0:	20 e0       	ldi	r18, 0x00	; 0
    20d2:	99 23       	and	r25, r25
    20d4:	29 f0       	breq	.+10     	; 0x20e0 <dtoa_prf+0x116>
    20d6:	d6 01       	movw	r26, r12
    20d8:	9c 93       	st	X, r25
    20da:	f6 01       	movw	r30, r12
    20dc:	31 96       	adiw	r30, 0x01	; 1
    20de:	6f 01       	movw	r12, r30
    20e0:	c6 01       	movw	r24, r12
    20e2:	03 96       	adiw	r24, 0x03	; 3
    20e4:	e2 fe       	sbrs	r14, 2
    20e6:	0b c0       	rjmp	.+22     	; 0x20fe <dtoa_prf+0x134>
    20e8:	39 e4       	ldi	r19, 0x49	; 73
    20ea:	d6 01       	movw	r26, r12
    20ec:	3c 93       	st	X, r19
    20ee:	3e e4       	ldi	r19, 0x4E	; 78
    20f0:	11 96       	adiw	r26, 0x01	; 1
    20f2:	3c 93       	st	X, r19
    20f4:	11 97       	sbiw	r26, 0x01	; 1
    20f6:	36 e4       	ldi	r19, 0x46	; 70
    20f8:	12 96       	adiw	r26, 0x02	; 2
    20fa:	3c 93       	st	X, r19
    20fc:	07 c0       	rjmp	.+14     	; 0x210c <dtoa_prf+0x142>
    20fe:	39 e6       	ldi	r19, 0x69	; 105
    2100:	f6 01       	movw	r30, r12
    2102:	30 83       	st	Z, r19
    2104:	3e e6       	ldi	r19, 0x6E	; 110
    2106:	31 83       	std	Z+1, r19	; 0x01
    2108:	36 e6       	ldi	r19, 0x66	; 102
    210a:	32 83       	std	Z+2, r19	; 0x02
    210c:	fc 01       	movw	r30, r24
    210e:	32 2f       	mov	r19, r18
    2110:	40 e2       	ldi	r20, 0x20	; 32
    2112:	33 23       	and	r19, r19
    2114:	19 f0       	breq	.+6      	; 0x211c <dtoa_prf+0x152>
    2116:	41 93       	st	Z+, r20
    2118:	31 50       	subi	r19, 0x01	; 1
    211a:	fb cf       	rjmp	.-10     	; 0x2112 <dtoa_prf+0x148>
    211c:	fc 01       	movw	r30, r24
    211e:	e2 0f       	add	r30, r18
    2120:	f1 1d       	adc	r31, r1
    2122:	10 82       	st	Z, r1
    2124:	8e ef       	ldi	r24, 0xFE	; 254
    2126:	9f ef       	ldi	r25, 0xFF	; 255
    2128:	a6 c0       	rjmp	.+332    	; 0x2276 <dtoa_prf+0x2ac>
    212a:	21 e0       	ldi	r18, 0x01	; 1
    212c:	30 e0       	ldi	r19, 0x00	; 0
    212e:	91 11       	cpse	r25, r1
    2130:	02 c0       	rjmp	.+4      	; 0x2136 <dtoa_prf+0x16c>
    2132:	20 e0       	ldi	r18, 0x00	; 0
    2134:	30 e0       	ldi	r19, 0x00	; 0
    2136:	16 16       	cp	r1, r22
    2138:	17 06       	cpc	r1, r23
    213a:	1c f4       	brge	.+6      	; 0x2142 <dtoa_prf+0x178>
    213c:	fb 01       	movw	r30, r22
    213e:	31 96       	adiw	r30, 0x01	; 1
    2140:	02 c0       	rjmp	.+4      	; 0x2146 <dtoa_prf+0x17c>
    2142:	e1 e0       	ldi	r30, 0x01	; 1
    2144:	f0 e0       	ldi	r31, 0x00	; 0
    2146:	2e 0f       	add	r18, r30
    2148:	3f 1f       	adc	r19, r31
    214a:	bb 20       	and	r11, r11
    214c:	21 f0       	breq	.+8      	; 0x2156 <dtoa_prf+0x18c>
    214e:	eb 2d       	mov	r30, r11
    2150:	f0 e0       	ldi	r31, 0x00	; 0
    2152:	31 96       	adiw	r30, 0x01	; 1
    2154:	02 c0       	rjmp	.+4      	; 0x215a <dtoa_prf+0x190>
    2156:	e0 e0       	ldi	r30, 0x00	; 0
    2158:	f0 e0       	ldi	r31, 0x00	; 0
    215a:	2e 0f       	add	r18, r30
    215c:	3f 1f       	adc	r19, r31
    215e:	e1 2f       	mov	r30, r17
    2160:	f0 e0       	ldi	r31, 0x00	; 0
    2162:	2e 17       	cp	r18, r30
    2164:	3f 07       	cpc	r19, r31
    2166:	1c f4       	brge	.+6      	; 0x216e <dtoa_prf+0x1a4>
    2168:	12 1b       	sub	r17, r18
    216a:	21 2f       	mov	r18, r17
    216c:	01 c0       	rjmp	.+2      	; 0x2170 <dtoa_prf+0x1a6>
    216e:	20 e0       	ldi	r18, 0x00	; 0
    2170:	8e 2d       	mov	r24, r14
    2172:	88 71       	andi	r24, 0x18	; 24
    2174:	59 f4       	brne	.+22     	; 0x218c <dtoa_prf+0x1c2>
    2176:	f6 01       	movw	r30, r12
    2178:	82 2f       	mov	r24, r18
    217a:	30 e2       	ldi	r19, 0x20	; 32
    217c:	88 23       	and	r24, r24
    217e:	19 f0       	breq	.+6      	; 0x2186 <dtoa_prf+0x1bc>
    2180:	31 93       	st	Z+, r19
    2182:	81 50       	subi	r24, 0x01	; 1
    2184:	fb cf       	rjmp	.-10     	; 0x217c <dtoa_prf+0x1b2>
    2186:	c2 0e       	add	r12, r18
    2188:	d1 1c       	adc	r13, r1
    218a:	20 e0       	ldi	r18, 0x00	; 0
    218c:	99 23       	and	r25, r25
    218e:	29 f0       	breq	.+10     	; 0x219a <dtoa_prf+0x1d0>
    2190:	d6 01       	movw	r26, r12
    2192:	9c 93       	st	X, r25
    2194:	f6 01       	movw	r30, r12
    2196:	31 96       	adiw	r30, 0x01	; 1
    2198:	6f 01       	movw	r12, r30
    219a:	51 11       	cpse	r21, r1
    219c:	0b c0       	rjmp	.+22     	; 0x21b4 <dtoa_prf+0x1ea>
    219e:	f6 01       	movw	r30, r12
    21a0:	82 2f       	mov	r24, r18
    21a2:	90 e3       	ldi	r25, 0x30	; 48
    21a4:	88 23       	and	r24, r24
    21a6:	19 f0       	breq	.+6      	; 0x21ae <dtoa_prf+0x1e4>
    21a8:	91 93       	st	Z+, r25
    21aa:	81 50       	subi	r24, 0x01	; 1
    21ac:	fb cf       	rjmp	.-10     	; 0x21a4 <dtoa_prf+0x1da>
    21ae:	c2 0e       	add	r12, r18
    21b0:	d1 1c       	adc	r13, r1
    21b2:	20 e0       	ldi	r18, 0x00	; 0
    21b4:	0f 2d       	mov	r16, r15
    21b6:	06 0f       	add	r16, r22
    21b8:	9a 81       	ldd	r25, Y+2	; 0x02
    21ba:	34 2f       	mov	r19, r20
    21bc:	30 71       	andi	r19, 0x10	; 16
    21be:	44 ff       	sbrs	r20, 4
    21c0:	03 c0       	rjmp	.+6      	; 0x21c8 <dtoa_prf+0x1fe>
    21c2:	91 33       	cpi	r25, 0x31	; 49
    21c4:	09 f4       	brne	.+2      	; 0x21c8 <dtoa_prf+0x1fe>
    21c6:	01 50       	subi	r16, 0x01	; 1
    21c8:	10 16       	cp	r1, r16
    21ca:	24 f4       	brge	.+8      	; 0x21d4 <dtoa_prf+0x20a>
    21cc:	09 30       	cpi	r16, 0x09	; 9
    21ce:	18 f0       	brcs	.+6      	; 0x21d6 <dtoa_prf+0x20c>
    21d0:	08 e0       	ldi	r16, 0x08	; 8
    21d2:	01 c0       	rjmp	.+2      	; 0x21d6 <dtoa_prf+0x20c>
    21d4:	01 e0       	ldi	r16, 0x01	; 1
    21d6:	ab 01       	movw	r20, r22
    21d8:	77 ff       	sbrs	r23, 7
    21da:	02 c0       	rjmp	.+4      	; 0x21e0 <dtoa_prf+0x216>
    21dc:	40 e0       	ldi	r20, 0x00	; 0
    21de:	50 e0       	ldi	r21, 0x00	; 0
    21e0:	fb 01       	movw	r30, r22
    21e2:	e4 1b       	sub	r30, r20
    21e4:	f5 0b       	sbc	r31, r21
    21e6:	a1 e0       	ldi	r26, 0x01	; 1
    21e8:	b0 e0       	ldi	r27, 0x00	; 0
    21ea:	ac 0f       	add	r26, r28
    21ec:	bd 1f       	adc	r27, r29
    21ee:	ea 0f       	add	r30, r26
    21f0:	fb 1f       	adc	r31, r27
    21f2:	8e e2       	ldi	r24, 0x2E	; 46
    21f4:	a8 2e       	mov	r10, r24
    21f6:	4b 01       	movw	r8, r22
    21f8:	80 1a       	sub	r8, r16
    21fa:	91 08       	sbc	r9, r1
    21fc:	0b 2d       	mov	r16, r11
    21fe:	10 e0       	ldi	r17, 0x00	; 0
    2200:	11 95       	neg	r17
    2202:	01 95       	neg	r16
    2204:	11 09       	sbc	r17, r1
    2206:	4f 3f       	cpi	r20, 0xFF	; 255
    2208:	bf ef       	ldi	r27, 0xFF	; 255
    220a:	5b 07       	cpc	r21, r27
    220c:	21 f4       	brne	.+8      	; 0x2216 <dtoa_prf+0x24c>
    220e:	d6 01       	movw	r26, r12
    2210:	ac 92       	st	X, r10
    2212:	11 96       	adiw	r26, 0x01	; 1
    2214:	6d 01       	movw	r12, r26
    2216:	64 17       	cp	r22, r20
    2218:	75 07       	cpc	r23, r21
    221a:	2c f0       	brlt	.+10     	; 0x2226 <dtoa_prf+0x25c>
    221c:	84 16       	cp	r8, r20
    221e:	95 06       	cpc	r9, r21
    2220:	14 f4       	brge	.+4      	; 0x2226 <dtoa_prf+0x25c>
    2222:	81 81       	ldd	r24, Z+1	; 0x01
    2224:	01 c0       	rjmp	.+2      	; 0x2228 <dtoa_prf+0x25e>
    2226:	80 e3       	ldi	r24, 0x30	; 48
    2228:	41 50       	subi	r20, 0x01	; 1
    222a:	51 09       	sbc	r21, r1
    222c:	31 96       	adiw	r30, 0x01	; 1
    222e:	d6 01       	movw	r26, r12
    2230:	11 96       	adiw	r26, 0x01	; 1
    2232:	7d 01       	movw	r14, r26
    2234:	40 17       	cp	r20, r16
    2236:	51 07       	cpc	r21, r17
    2238:	24 f0       	brlt	.+8      	; 0x2242 <dtoa_prf+0x278>
    223a:	d6 01       	movw	r26, r12
    223c:	8c 93       	st	X, r24
    223e:	67 01       	movw	r12, r14
    2240:	e2 cf       	rjmp	.-60     	; 0x2206 <dtoa_prf+0x23c>
    2242:	64 17       	cp	r22, r20
    2244:	75 07       	cpc	r23, r21
    2246:	39 f4       	brne	.+14     	; 0x2256 <dtoa_prf+0x28c>
    2248:	96 33       	cpi	r25, 0x36	; 54
    224a:	20 f4       	brcc	.+8      	; 0x2254 <dtoa_prf+0x28a>
    224c:	95 33       	cpi	r25, 0x35	; 53
    224e:	19 f4       	brne	.+6      	; 0x2256 <dtoa_prf+0x28c>
    2250:	31 11       	cpse	r19, r1
    2252:	01 c0       	rjmp	.+2      	; 0x2256 <dtoa_prf+0x28c>
    2254:	81 e3       	ldi	r24, 0x31	; 49
    2256:	f6 01       	movw	r30, r12
    2258:	80 83       	st	Z, r24
    225a:	f7 01       	movw	r30, r14
    225c:	82 2f       	mov	r24, r18
    225e:	90 e2       	ldi	r25, 0x20	; 32
    2260:	88 23       	and	r24, r24
    2262:	19 f0       	breq	.+6      	; 0x226a <dtoa_prf+0x2a0>
    2264:	91 93       	st	Z+, r25
    2266:	81 50       	subi	r24, 0x01	; 1
    2268:	fb cf       	rjmp	.-10     	; 0x2260 <dtoa_prf+0x296>
    226a:	f7 01       	movw	r30, r14
    226c:	e2 0f       	add	r30, r18
    226e:	f1 1d       	adc	r31, r1
    2270:	10 82       	st	Z, r1
    2272:	80 e0       	ldi	r24, 0x00	; 0
    2274:	90 e0       	ldi	r25, 0x00	; 0
    2276:	29 96       	adiw	r28, 0x09	; 9
    2278:	ec e0       	ldi	r30, 0x0C	; 12
    227a:	0c 94 e6 12 	jmp	0x25cc	; 0x25cc <__epilogue_restores__+0xc>

0000227e <__ftoa_engine>:
    227e:	28 30       	cpi	r18, 0x08	; 8
    2280:	08 f0       	brcs	.+2      	; 0x2284 <__ftoa_engine+0x6>
    2282:	27 e0       	ldi	r18, 0x07	; 7
    2284:	33 27       	eor	r19, r19
    2286:	da 01       	movw	r26, r20
    2288:	99 0f       	add	r25, r25
    228a:	31 1d       	adc	r19, r1
    228c:	87 fd       	sbrc	r24, 7
    228e:	91 60       	ori	r25, 0x01	; 1
    2290:	00 96       	adiw	r24, 0x00	; 0
    2292:	61 05       	cpc	r22, r1
    2294:	71 05       	cpc	r23, r1
    2296:	39 f4       	brne	.+14     	; 0x22a6 <__ftoa_engine+0x28>
    2298:	32 60       	ori	r19, 0x02	; 2
    229a:	2e 5f       	subi	r18, 0xFE	; 254
    229c:	3d 93       	st	X+, r19
    229e:	30 e3       	ldi	r19, 0x30	; 48
    22a0:	2a 95       	dec	r18
    22a2:	e1 f7       	brne	.-8      	; 0x229c <__ftoa_engine+0x1e>
    22a4:	08 95       	ret
    22a6:	9f 3f       	cpi	r25, 0xFF	; 255
    22a8:	30 f0       	brcs	.+12     	; 0x22b6 <__ftoa_engine+0x38>
    22aa:	80 38       	cpi	r24, 0x80	; 128
    22ac:	71 05       	cpc	r23, r1
    22ae:	61 05       	cpc	r22, r1
    22b0:	09 f0       	breq	.+2      	; 0x22b4 <__ftoa_engine+0x36>
    22b2:	3c 5f       	subi	r19, 0xFC	; 252
    22b4:	3c 5f       	subi	r19, 0xFC	; 252
    22b6:	3d 93       	st	X+, r19
    22b8:	91 30       	cpi	r25, 0x01	; 1
    22ba:	08 f0       	brcs	.+2      	; 0x22be <__ftoa_engine+0x40>
    22bc:	80 68       	ori	r24, 0x80	; 128
    22be:	91 1d       	adc	r25, r1
    22c0:	df 93       	push	r29
    22c2:	cf 93       	push	r28
    22c4:	1f 93       	push	r17
    22c6:	0f 93       	push	r16
    22c8:	ff 92       	push	r15
    22ca:	ef 92       	push	r14
    22cc:	19 2f       	mov	r17, r25
    22ce:	98 7f       	andi	r25, 0xF8	; 248
    22d0:	96 95       	lsr	r25
    22d2:	e9 2f       	mov	r30, r25
    22d4:	96 95       	lsr	r25
    22d6:	96 95       	lsr	r25
    22d8:	e9 0f       	add	r30, r25
    22da:	ff 27       	eor	r31, r31
    22dc:	e4 5e       	subi	r30, 0xE4	; 228
    22de:	fe 4f       	sbci	r31, 0xFE	; 254
    22e0:	99 27       	eor	r25, r25
    22e2:	33 27       	eor	r19, r19
    22e4:	ee 24       	eor	r14, r14
    22e6:	ff 24       	eor	r15, r15
    22e8:	a7 01       	movw	r20, r14
    22ea:	e7 01       	movw	r28, r14
    22ec:	05 90       	lpm	r0, Z+
    22ee:	08 94       	sec
    22f0:	07 94       	ror	r0
    22f2:	28 f4       	brcc	.+10     	; 0x22fe <__ftoa_engine+0x80>
    22f4:	36 0f       	add	r19, r22
    22f6:	e7 1e       	adc	r14, r23
    22f8:	f8 1e       	adc	r15, r24
    22fa:	49 1f       	adc	r20, r25
    22fc:	51 1d       	adc	r21, r1
    22fe:	66 0f       	add	r22, r22
    2300:	77 1f       	adc	r23, r23
    2302:	88 1f       	adc	r24, r24
    2304:	99 1f       	adc	r25, r25
    2306:	06 94       	lsr	r0
    2308:	a1 f7       	brne	.-24     	; 0x22f2 <__ftoa_engine+0x74>
    230a:	05 90       	lpm	r0, Z+
    230c:	07 94       	ror	r0
    230e:	28 f4       	brcc	.+10     	; 0x231a <__ftoa_engine+0x9c>
    2310:	e7 0e       	add	r14, r23
    2312:	f8 1e       	adc	r15, r24
    2314:	49 1f       	adc	r20, r25
    2316:	56 1f       	adc	r21, r22
    2318:	c1 1d       	adc	r28, r1
    231a:	77 0f       	add	r23, r23
    231c:	88 1f       	adc	r24, r24
    231e:	99 1f       	adc	r25, r25
    2320:	66 1f       	adc	r22, r22
    2322:	06 94       	lsr	r0
    2324:	a1 f7       	brne	.-24     	; 0x230e <__ftoa_engine+0x90>
    2326:	05 90       	lpm	r0, Z+
    2328:	07 94       	ror	r0
    232a:	28 f4       	brcc	.+10     	; 0x2336 <__ftoa_engine+0xb8>
    232c:	f8 0e       	add	r15, r24
    232e:	49 1f       	adc	r20, r25
    2330:	56 1f       	adc	r21, r22
    2332:	c7 1f       	adc	r28, r23
    2334:	d1 1d       	adc	r29, r1
    2336:	88 0f       	add	r24, r24
    2338:	99 1f       	adc	r25, r25
    233a:	66 1f       	adc	r22, r22
    233c:	77 1f       	adc	r23, r23
    233e:	06 94       	lsr	r0
    2340:	a1 f7       	brne	.-24     	; 0x232a <__ftoa_engine+0xac>
    2342:	05 90       	lpm	r0, Z+
    2344:	07 94       	ror	r0
    2346:	20 f4       	brcc	.+8      	; 0x2350 <__ftoa_engine+0xd2>
    2348:	49 0f       	add	r20, r25
    234a:	56 1f       	adc	r21, r22
    234c:	c7 1f       	adc	r28, r23
    234e:	d8 1f       	adc	r29, r24
    2350:	99 0f       	add	r25, r25
    2352:	66 1f       	adc	r22, r22
    2354:	77 1f       	adc	r23, r23
    2356:	88 1f       	adc	r24, r24
    2358:	06 94       	lsr	r0
    235a:	a9 f7       	brne	.-22     	; 0x2346 <__ftoa_engine+0xc8>
    235c:	84 91       	lpm	r24, Z
    235e:	10 95       	com	r17
    2360:	17 70       	andi	r17, 0x07	; 7
    2362:	41 f0       	breq	.+16     	; 0x2374 <__ftoa_engine+0xf6>
    2364:	d6 95       	lsr	r29
    2366:	c7 95       	ror	r28
    2368:	57 95       	ror	r21
    236a:	47 95       	ror	r20
    236c:	f7 94       	ror	r15
    236e:	e7 94       	ror	r14
    2370:	1a 95       	dec	r17
    2372:	c1 f7       	brne	.-16     	; 0x2364 <__ftoa_engine+0xe6>
    2374:	e2 ec       	ldi	r30, 0xC2	; 194
    2376:	f0 e0       	ldi	r31, 0x00	; 0
    2378:	68 94       	set
    237a:	15 90       	lpm	r1, Z+
    237c:	15 91       	lpm	r17, Z+
    237e:	35 91       	lpm	r19, Z+
    2380:	65 91       	lpm	r22, Z+
    2382:	95 91       	lpm	r25, Z+
    2384:	05 90       	lpm	r0, Z+
    2386:	7f e2       	ldi	r23, 0x2F	; 47
    2388:	73 95       	inc	r23
    238a:	e1 18       	sub	r14, r1
    238c:	f1 0a       	sbc	r15, r17
    238e:	43 0b       	sbc	r20, r19
    2390:	56 0b       	sbc	r21, r22
    2392:	c9 0b       	sbc	r28, r25
    2394:	d0 09       	sbc	r29, r0
    2396:	c0 f7       	brcc	.-16     	; 0x2388 <__ftoa_engine+0x10a>
    2398:	e1 0c       	add	r14, r1
    239a:	f1 1e       	adc	r15, r17
    239c:	43 1f       	adc	r20, r19
    239e:	56 1f       	adc	r21, r22
    23a0:	c9 1f       	adc	r28, r25
    23a2:	d0 1d       	adc	r29, r0
    23a4:	7e f4       	brtc	.+30     	; 0x23c4 <__ftoa_engine+0x146>
    23a6:	70 33       	cpi	r23, 0x30	; 48
    23a8:	11 f4       	brne	.+4      	; 0x23ae <__ftoa_engine+0x130>
    23aa:	8a 95       	dec	r24
    23ac:	e6 cf       	rjmp	.-52     	; 0x237a <__ftoa_engine+0xfc>
    23ae:	e8 94       	clt
    23b0:	01 50       	subi	r16, 0x01	; 1
    23b2:	30 f0       	brcs	.+12     	; 0x23c0 <__ftoa_engine+0x142>
    23b4:	08 0f       	add	r16, r24
    23b6:	0a f4       	brpl	.+2      	; 0x23ba <__ftoa_engine+0x13c>
    23b8:	00 27       	eor	r16, r16
    23ba:	02 17       	cp	r16, r18
    23bc:	08 f4       	brcc	.+2      	; 0x23c0 <__ftoa_engine+0x142>
    23be:	20 2f       	mov	r18, r16
    23c0:	23 95       	inc	r18
    23c2:	02 2f       	mov	r16, r18
    23c4:	7a 33       	cpi	r23, 0x3A	; 58
    23c6:	28 f0       	brcs	.+10     	; 0x23d2 <__ftoa_engine+0x154>
    23c8:	79 e3       	ldi	r23, 0x39	; 57
    23ca:	7d 93       	st	X+, r23
    23cc:	2a 95       	dec	r18
    23ce:	e9 f7       	brne	.-6      	; 0x23ca <__ftoa_engine+0x14c>
    23d0:	10 c0       	rjmp	.+32     	; 0x23f2 <__ftoa_engine+0x174>
    23d2:	7d 93       	st	X+, r23
    23d4:	2a 95       	dec	r18
    23d6:	89 f6       	brne	.-94     	; 0x237a <__ftoa_engine+0xfc>
    23d8:	06 94       	lsr	r0
    23da:	97 95       	ror	r25
    23dc:	67 95       	ror	r22
    23de:	37 95       	ror	r19
    23e0:	17 95       	ror	r17
    23e2:	17 94       	ror	r1
    23e4:	e1 18       	sub	r14, r1
    23e6:	f1 0a       	sbc	r15, r17
    23e8:	43 0b       	sbc	r20, r19
    23ea:	56 0b       	sbc	r21, r22
    23ec:	c9 0b       	sbc	r28, r25
    23ee:	d0 09       	sbc	r29, r0
    23f0:	98 f0       	brcs	.+38     	; 0x2418 <__ftoa_engine+0x19a>
    23f2:	23 95       	inc	r18
    23f4:	7e 91       	ld	r23, -X
    23f6:	73 95       	inc	r23
    23f8:	7a 33       	cpi	r23, 0x3A	; 58
    23fa:	08 f0       	brcs	.+2      	; 0x23fe <__ftoa_engine+0x180>
    23fc:	70 e3       	ldi	r23, 0x30	; 48
    23fe:	7c 93       	st	X, r23
    2400:	20 13       	cpse	r18, r16
    2402:	b8 f7       	brcc	.-18     	; 0x23f2 <__ftoa_engine+0x174>
    2404:	7e 91       	ld	r23, -X
    2406:	70 61       	ori	r23, 0x10	; 16
    2408:	7d 93       	st	X+, r23
    240a:	30 f0       	brcs	.+12     	; 0x2418 <__ftoa_engine+0x19a>
    240c:	83 95       	inc	r24
    240e:	71 e3       	ldi	r23, 0x31	; 49
    2410:	7d 93       	st	X+, r23
    2412:	70 e3       	ldi	r23, 0x30	; 48
    2414:	2a 95       	dec	r18
    2416:	e1 f7       	brne	.-8      	; 0x2410 <__ftoa_engine+0x192>
    2418:	11 24       	eor	r1, r1
    241a:	ef 90       	pop	r14
    241c:	ff 90       	pop	r15
    241e:	0f 91       	pop	r16
    2420:	1f 91       	pop	r17
    2422:	cf 91       	pop	r28
    2424:	df 91       	pop	r29
    2426:	99 27       	eor	r25, r25
    2428:	87 fd       	sbrc	r24, 7
    242a:	90 95       	com	r25
    242c:	08 95       	ret

0000242e <strnlen_P>:
    242e:	fc 01       	movw	r30, r24
    2430:	05 90       	lpm	r0, Z+
    2432:	61 50       	subi	r22, 0x01	; 1
    2434:	70 40       	sbci	r23, 0x00	; 0
    2436:	01 10       	cpse	r0, r1
    2438:	d8 f7       	brcc	.-10     	; 0x2430 <strnlen_P+0x2>
    243a:	80 95       	com	r24
    243c:	90 95       	com	r25
    243e:	8e 0f       	add	r24, r30
    2440:	9f 1f       	adc	r25, r31
    2442:	08 95       	ret

00002444 <strnlen>:
    2444:	fc 01       	movw	r30, r24
    2446:	61 50       	subi	r22, 0x01	; 1
    2448:	70 40       	sbci	r23, 0x00	; 0
    244a:	01 90       	ld	r0, Z+
    244c:	01 10       	cpse	r0, r1
    244e:	d8 f7       	brcc	.-10     	; 0x2446 <strnlen+0x2>
    2450:	80 95       	com	r24
    2452:	90 95       	com	r25
    2454:	8e 0f       	add	r24, r30
    2456:	9f 1f       	adc	r25, r31
    2458:	08 95       	ret

0000245a <fputc>:
    245a:	0f 93       	push	r16
    245c:	1f 93       	push	r17
    245e:	cf 93       	push	r28
    2460:	df 93       	push	r29
    2462:	fb 01       	movw	r30, r22
    2464:	23 81       	ldd	r18, Z+3	; 0x03
    2466:	21 fd       	sbrc	r18, 1
    2468:	03 c0       	rjmp	.+6      	; 0x2470 <fputc+0x16>
    246a:	8f ef       	ldi	r24, 0xFF	; 255
    246c:	9f ef       	ldi	r25, 0xFF	; 255
    246e:	2c c0       	rjmp	.+88     	; 0x24c8 <fputc+0x6e>
    2470:	22 ff       	sbrs	r18, 2
    2472:	16 c0       	rjmp	.+44     	; 0x24a0 <fputc+0x46>
    2474:	46 81       	ldd	r20, Z+6	; 0x06
    2476:	57 81       	ldd	r21, Z+7	; 0x07
    2478:	24 81       	ldd	r18, Z+4	; 0x04
    247a:	35 81       	ldd	r19, Z+5	; 0x05
    247c:	42 17       	cp	r20, r18
    247e:	53 07       	cpc	r21, r19
    2480:	44 f4       	brge	.+16     	; 0x2492 <fputc+0x38>
    2482:	a0 81       	ld	r26, Z
    2484:	b1 81       	ldd	r27, Z+1	; 0x01
    2486:	9d 01       	movw	r18, r26
    2488:	2f 5f       	subi	r18, 0xFF	; 255
    248a:	3f 4f       	sbci	r19, 0xFF	; 255
    248c:	20 83       	st	Z, r18
    248e:	31 83       	std	Z+1, r19	; 0x01
    2490:	8c 93       	st	X, r24
    2492:	26 81       	ldd	r18, Z+6	; 0x06
    2494:	37 81       	ldd	r19, Z+7	; 0x07
    2496:	2f 5f       	subi	r18, 0xFF	; 255
    2498:	3f 4f       	sbci	r19, 0xFF	; 255
    249a:	26 83       	std	Z+6, r18	; 0x06
    249c:	37 83       	std	Z+7, r19	; 0x07
    249e:	14 c0       	rjmp	.+40     	; 0x24c8 <fputc+0x6e>
    24a0:	8b 01       	movw	r16, r22
    24a2:	ec 01       	movw	r28, r24
    24a4:	fb 01       	movw	r30, r22
    24a6:	00 84       	ldd	r0, Z+8	; 0x08
    24a8:	f1 85       	ldd	r31, Z+9	; 0x09
    24aa:	e0 2d       	mov	r30, r0
    24ac:	09 95       	icall
    24ae:	89 2b       	or	r24, r25
    24b0:	e1 f6       	brne	.-72     	; 0x246a <fputc+0x10>
    24b2:	d8 01       	movw	r26, r16
    24b4:	16 96       	adiw	r26, 0x06	; 6
    24b6:	8d 91       	ld	r24, X+
    24b8:	9c 91       	ld	r25, X
    24ba:	17 97       	sbiw	r26, 0x07	; 7
    24bc:	01 96       	adiw	r24, 0x01	; 1
    24be:	16 96       	adiw	r26, 0x06	; 6
    24c0:	8d 93       	st	X+, r24
    24c2:	9c 93       	st	X, r25
    24c4:	17 97       	sbiw	r26, 0x07	; 7
    24c6:	ce 01       	movw	r24, r28
    24c8:	df 91       	pop	r29
    24ca:	cf 91       	pop	r28
    24cc:	1f 91       	pop	r17
    24ce:	0f 91       	pop	r16
    24d0:	08 95       	ret

000024d2 <__ultoa_invert>:
    24d2:	fa 01       	movw	r30, r20
    24d4:	aa 27       	eor	r26, r26
    24d6:	28 30       	cpi	r18, 0x08	; 8
    24d8:	51 f1       	breq	.+84     	; 0x252e <__ultoa_invert+0x5c>
    24da:	20 31       	cpi	r18, 0x10	; 16
    24dc:	81 f1       	breq	.+96     	; 0x253e <__ultoa_invert+0x6c>
    24de:	e8 94       	clt
    24e0:	6f 93       	push	r22
    24e2:	6e 7f       	andi	r22, 0xFE	; 254
    24e4:	6e 5f       	subi	r22, 0xFE	; 254
    24e6:	7f 4f       	sbci	r23, 0xFF	; 255
    24e8:	8f 4f       	sbci	r24, 0xFF	; 255
    24ea:	9f 4f       	sbci	r25, 0xFF	; 255
    24ec:	af 4f       	sbci	r26, 0xFF	; 255
    24ee:	b1 e0       	ldi	r27, 0x01	; 1
    24f0:	3e d0       	rcall	.+124    	; 0x256e <__ultoa_invert+0x9c>
    24f2:	b4 e0       	ldi	r27, 0x04	; 4
    24f4:	3c d0       	rcall	.+120    	; 0x256e <__ultoa_invert+0x9c>
    24f6:	67 0f       	add	r22, r23
    24f8:	78 1f       	adc	r23, r24
    24fa:	89 1f       	adc	r24, r25
    24fc:	9a 1f       	adc	r25, r26
    24fe:	a1 1d       	adc	r26, r1
    2500:	68 0f       	add	r22, r24
    2502:	79 1f       	adc	r23, r25
    2504:	8a 1f       	adc	r24, r26
    2506:	91 1d       	adc	r25, r1
    2508:	a1 1d       	adc	r26, r1
    250a:	6a 0f       	add	r22, r26
    250c:	71 1d       	adc	r23, r1
    250e:	81 1d       	adc	r24, r1
    2510:	91 1d       	adc	r25, r1
    2512:	a1 1d       	adc	r26, r1
    2514:	20 d0       	rcall	.+64     	; 0x2556 <__ultoa_invert+0x84>
    2516:	09 f4       	brne	.+2      	; 0x251a <__ultoa_invert+0x48>
    2518:	68 94       	set
    251a:	3f 91       	pop	r19
    251c:	2a e0       	ldi	r18, 0x0A	; 10
    251e:	26 9f       	mul	r18, r22
    2520:	11 24       	eor	r1, r1
    2522:	30 19       	sub	r19, r0
    2524:	30 5d       	subi	r19, 0xD0	; 208
    2526:	31 93       	st	Z+, r19
    2528:	de f6       	brtc	.-74     	; 0x24e0 <__ultoa_invert+0xe>
    252a:	cf 01       	movw	r24, r30
    252c:	08 95       	ret
    252e:	46 2f       	mov	r20, r22
    2530:	47 70       	andi	r20, 0x07	; 7
    2532:	40 5d       	subi	r20, 0xD0	; 208
    2534:	41 93       	st	Z+, r20
    2536:	b3 e0       	ldi	r27, 0x03	; 3
    2538:	0f d0       	rcall	.+30     	; 0x2558 <__ultoa_invert+0x86>
    253a:	c9 f7       	brne	.-14     	; 0x252e <__ultoa_invert+0x5c>
    253c:	f6 cf       	rjmp	.-20     	; 0x252a <__ultoa_invert+0x58>
    253e:	46 2f       	mov	r20, r22
    2540:	4f 70       	andi	r20, 0x0F	; 15
    2542:	40 5d       	subi	r20, 0xD0	; 208
    2544:	4a 33       	cpi	r20, 0x3A	; 58
    2546:	18 f0       	brcs	.+6      	; 0x254e <__ultoa_invert+0x7c>
    2548:	49 5d       	subi	r20, 0xD9	; 217
    254a:	31 fd       	sbrc	r19, 1
    254c:	40 52       	subi	r20, 0x20	; 32
    254e:	41 93       	st	Z+, r20
    2550:	02 d0       	rcall	.+4      	; 0x2556 <__ultoa_invert+0x84>
    2552:	a9 f7       	brne	.-22     	; 0x253e <__ultoa_invert+0x6c>
    2554:	ea cf       	rjmp	.-44     	; 0x252a <__ultoa_invert+0x58>
    2556:	b4 e0       	ldi	r27, 0x04	; 4
    2558:	a6 95       	lsr	r26
    255a:	97 95       	ror	r25
    255c:	87 95       	ror	r24
    255e:	77 95       	ror	r23
    2560:	67 95       	ror	r22
    2562:	ba 95       	dec	r27
    2564:	c9 f7       	brne	.-14     	; 0x2558 <__ultoa_invert+0x86>
    2566:	00 97       	sbiw	r24, 0x00	; 0
    2568:	61 05       	cpc	r22, r1
    256a:	71 05       	cpc	r23, r1
    256c:	08 95       	ret
    256e:	9b 01       	movw	r18, r22
    2570:	ac 01       	movw	r20, r24
    2572:	0a 2e       	mov	r0, r26
    2574:	06 94       	lsr	r0
    2576:	57 95       	ror	r21
    2578:	47 95       	ror	r20
    257a:	37 95       	ror	r19
    257c:	27 95       	ror	r18
    257e:	ba 95       	dec	r27
    2580:	c9 f7       	brne	.-14     	; 0x2574 <__ultoa_invert+0xa2>
    2582:	62 0f       	add	r22, r18
    2584:	73 1f       	adc	r23, r19
    2586:	84 1f       	adc	r24, r20
    2588:	95 1f       	adc	r25, r21
    258a:	a0 1d       	adc	r26, r0
    258c:	08 95       	ret

0000258e <__prologue_saves__>:
    258e:	2f 92       	push	r2
    2590:	3f 92       	push	r3
    2592:	4f 92       	push	r4
    2594:	5f 92       	push	r5
    2596:	6f 92       	push	r6
    2598:	7f 92       	push	r7
    259a:	8f 92       	push	r8
    259c:	9f 92       	push	r9
    259e:	af 92       	push	r10
    25a0:	bf 92       	push	r11
    25a2:	cf 92       	push	r12
    25a4:	df 92       	push	r13
    25a6:	ef 92       	push	r14
    25a8:	ff 92       	push	r15
    25aa:	0f 93       	push	r16
    25ac:	1f 93       	push	r17
    25ae:	cf 93       	push	r28
    25b0:	df 93       	push	r29
    25b2:	cd b7       	in	r28, 0x3d	; 61
    25b4:	de b7       	in	r29, 0x3e	; 62
    25b6:	ca 1b       	sub	r28, r26
    25b8:	db 0b       	sbc	r29, r27
    25ba:	cd bf       	out	0x3d, r28	; 61
    25bc:	de bf       	out	0x3e, r29	; 62
    25be:	09 94       	ijmp

000025c0 <__epilogue_restores__>:
    25c0:	2a 88       	ldd	r2, Y+18	; 0x12
    25c2:	39 88       	ldd	r3, Y+17	; 0x11
    25c4:	48 88       	ldd	r4, Y+16	; 0x10
    25c6:	5f 84       	ldd	r5, Y+15	; 0x0f
    25c8:	6e 84       	ldd	r6, Y+14	; 0x0e
    25ca:	7d 84       	ldd	r7, Y+13	; 0x0d
    25cc:	8c 84       	ldd	r8, Y+12	; 0x0c
    25ce:	9b 84       	ldd	r9, Y+11	; 0x0b
    25d0:	aa 84       	ldd	r10, Y+10	; 0x0a
    25d2:	b9 84       	ldd	r11, Y+9	; 0x09
    25d4:	c8 84       	ldd	r12, Y+8	; 0x08
    25d6:	df 80       	ldd	r13, Y+7	; 0x07
    25d8:	ee 80       	ldd	r14, Y+6	; 0x06
    25da:	fd 80       	ldd	r15, Y+5	; 0x05
    25dc:	0c 81       	ldd	r16, Y+4	; 0x04
    25de:	1b 81       	ldd	r17, Y+3	; 0x03
    25e0:	aa 81       	ldd	r26, Y+2	; 0x02
    25e2:	b9 81       	ldd	r27, Y+1	; 0x01
    25e4:	ce 0f       	add	r28, r30
    25e6:	d1 1d       	adc	r29, r1
    25e8:	cd bf       	out	0x3d, r28	; 61
    25ea:	de bf       	out	0x3e, r29	; 62
    25ec:	ed 01       	movw	r28, r26
    25ee:	08 95       	ret

000025f0 <_exit>:
    25f0:	f8 94       	cli

000025f2 <__stop_program>:
    25f2:	ff cf       	rjmp	.-2      	; 0x25f2 <__stop_program>
