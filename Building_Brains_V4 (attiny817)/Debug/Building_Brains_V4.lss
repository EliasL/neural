
Building_Brains_V4.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000016  00803800  0000177c  00001830  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000173a  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000042  0000973a  0000173a  000017ee  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .bss          00000055  00803816  00803816  00001846  2**0
                  ALLOC
  4 .comment      00000030  00000000  00000000  00001846  2**0
                  CONTENTS, READONLY
  5 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001878  2**2
                  CONTENTS, READONLY
  6 .debug_aranges 000004c8  00000000  00000000  000018b8  2**3
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000868d  00000000  00000000  00001d80  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0000368f  00000000  00000000  0000a40d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000028ad  00000000  00000000  0000da9c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000007fc  00000000  00000000  0001034c  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00003491  00000000  00000000  00010b48  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000135f  00000000  00000000  00013fd9  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000340  00000000  00000000  00015338  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 61 00 	jmp	0xc2	; 0xc2 <__ctors_end>
       4:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
       8:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
       c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      10:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      14:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      18:	0c 94 22 07 	jmp	0xe44	; 0xe44 <__vector_6>
      1c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      20:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      24:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      28:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      2c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      30:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      34:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      38:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      3c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      40:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      44:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      48:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      4c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      50:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      54:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      58:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      5c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      60:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      64:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      68:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      6c:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      70:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      74:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      78:	0c 94 7e 00 	jmp	0xfc	; 0xfc <__bad_interrupt>
      7c:	07 63       	ori	r16, 0x37	; 55
      7e:	42 36       	cpi	r20, 0x62	; 98
      80:	b7 9b       	sbis	0x16, 7	; 22
      82:	d8 a7       	std	Y+40, r29	; 0x28
      84:	1a 39       	cpi	r17, 0x9A	; 154
      86:	68 56       	subi	r22, 0x68	; 104
      88:	18 ae       	std	Y+56, r1	; 0x38
      8a:	ba ab       	std	Y+50, r27	; 0x32
      8c:	55 8c       	ldd	r5, Z+29	; 0x1d
      8e:	1d 3c       	cpi	r17, 0xCD	; 205
      90:	b7 cc       	rjmp	.-1682   	; 0xfffffa00 <__eeprom_end+0xff7efa00>
      92:	57 63       	ori	r21, 0x37	; 55
      94:	bd 6d       	ori	r27, 0xDD	; 221
      96:	ed fd       	.word	0xfded	; ????
      98:	75 3e       	cpi	r23, 0xE5	; 229
      9a:	f6 17       	cp	r31, r22
      9c:	72 31       	cpi	r23, 0x12	; 18
      9e:	bf 00       	.word	0x00bf	; ????
      a0:	00 00       	nop
      a2:	80 3f       	cpi	r24, 0xF0	; 240
      a4:	05 a8       	ldd	r0, Z+53	; 0x35
      a6:	4c cd       	rjmp	.-1384   	; 0xfffffb40 <__eeprom_end+0xff7efb40>
      a8:	b2 d4       	rcall	.+2404   	; 0xa0e <tinyLED_update+0x336>
      aa:	4e b9       	out	0x0e, r20	; 14
      ac:	38 36       	cpi	r19, 0x68	; 104
      ae:	a9 02       	muls	r26, r25
      b0:	0c 50       	subi	r16, 0x0C	; 12
      b2:	b9 91       	ld	r27, Y+
      b4:	86 88       	ldd	r8, Z+22	; 0x16
      b6:	08 3c       	cpi	r16, 0xC8	; 200
      b8:	a6 aa       	std	Z+54, r10	; 0x36
      ba:	aa 2a       	or	r10, r26
      bc:	be 00       	.word	0x00be	; ????
      be:	00 00       	nop
      c0:	80 3f       	cpi	r24, 0xF0	; 240

000000c2 <__ctors_end>:
      c2:	11 24       	eor	r1, r1
      c4:	1f be       	out	0x3f, r1	; 63
      c6:	cf ef       	ldi	r28, 0xFF	; 255
      c8:	cd bf       	out	0x3d, r28	; 61
      ca:	df e3       	ldi	r29, 0x3F	; 63
      cc:	de bf       	out	0x3e, r29	; 62

000000ce <__do_copy_data>:
      ce:	18 e3       	ldi	r17, 0x38	; 56
      d0:	a0 e0       	ldi	r26, 0x00	; 0
      d2:	b8 e3       	ldi	r27, 0x38	; 56
      d4:	ec e7       	ldi	r30, 0x7C	; 124
      d6:	f7 e1       	ldi	r31, 0x17	; 23
      d8:	02 c0       	rjmp	.+4      	; 0xde <__do_copy_data+0x10>
      da:	05 90       	lpm	r0, Z+
      dc:	0d 92       	st	X+, r0
      de:	a6 31       	cpi	r26, 0x16	; 22
      e0:	b1 07       	cpc	r27, r17
      e2:	d9 f7       	brne	.-10     	; 0xda <__do_copy_data+0xc>

000000e4 <__do_clear_bss>:
      e4:	28 e3       	ldi	r18, 0x38	; 56
      e6:	a6 e1       	ldi	r26, 0x16	; 22
      e8:	b8 e3       	ldi	r27, 0x38	; 56
      ea:	01 c0       	rjmp	.+2      	; 0xee <.do_clear_bss_start>

000000ec <.do_clear_bss_loop>:
      ec:	1d 92       	st	X+, r1

000000ee <.do_clear_bss_start>:
      ee:	ab 36       	cpi	r26, 0x6B	; 107
      f0:	b2 07       	cpc	r27, r18
      f2:	e1 f7       	brne	.-8      	; 0xec <.do_clear_bss_loop>
      f4:	0e 94 6c 02 	call	0x4d8	; 0x4d8 <main>
      f8:	0c 94 9b 0b 	jmp	0x1736	; 0x1736 <_exit>

000000fc <__bad_interrupt>:
      fc:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000100 <atmel_start_init>:
/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
	system_init();
     100:	0e 94 50 01 	call	0x2a0	; 0x2a0 <system_init>
     104:	08 95       	ret

00000106 <ADC_init>:
 * \return Conversion result read from the ADC ADC module
 */
adc_result_t ADC_get_conversion_result(void)
{
	return (ADC0.RES);
}
     106:	85 e0       	ldi	r24, 0x05	; 5
     108:	80 93 00 06 	sts	0x0600, r24	; 0x800600 <__TEXT_REGION_LENGTH__+0x700600>
     10c:	80 e0       	ldi	r24, 0x00	; 0
     10e:	08 95       	ret

00000110 <ADC_is_conversion_done>:
     110:	80 91 0b 06 	lds	r24, 0x060B	; 0x80060b <__TEXT_REGION_LENGTH__+0x70060b>
     114:	81 70       	andi	r24, 0x01	; 1
     116:	08 95       	ret

00000118 <ADC_get_conversion>:
 *
 * \return Nothing
 */
void ADC_start_conversion(adc_0_channel_t channel)
{
	ADC0.MUXPOS  = channel;
     118:	e0 e0       	ldi	r30, 0x00	; 0
     11a:	f6 e0       	ldi	r31, 0x06	; 6
     11c:	86 83       	std	Z+6, r24	; 0x06
	ADC0.COMMAND = ADC_STCONV_bm;
     11e:	81 e0       	ldi	r24, 0x01	; 1
     120:	80 87       	std	Z+8, r24	; 0x08
adc_result_t ADC_get_conversion(adc_0_channel_t channel)
{
	adc_result_t res;

	ADC_start_conversion(channel);
	while (!ADC_is_conversion_done())
     122:	0e 94 88 00 	call	0x110	; 0x110 <ADC_is_conversion_done>
     126:	88 23       	and	r24, r24
     128:	e1 f3       	breq	.-8      	; 0x122 <ADC_get_conversion+0xa>
 *
 * \return Conversion result read from the ADC ADC module
 */
adc_result_t ADC_get_conversion_result(void)
{
	return (ADC0.RES);
     12a:	e0 e0       	ldi	r30, 0x00	; 0
     12c:	f6 e0       	ldi	r31, 0x06	; 6
     12e:	20 89       	ldd	r18, Z+16	; 0x10
     130:	31 89       	ldd	r19, Z+17	; 0x11

	ADC_start_conversion(channel);
	while (!ADC_is_conversion_done())
		;
	res = ADC_get_conversion_result();
	ADC0.INTFLAGS |= ADC_RESRDY_bm;
     132:	93 85       	ldd	r25, Z+11	; 0x0b
     134:	91 60       	ori	r25, 0x01	; 1
     136:	93 87       	std	Z+11, r25	; 0x0b
	return res;
}
     138:	c9 01       	movw	r24, r18
     13a:	08 95       	ret

0000013c <BOD_init>:
int8_t BOD_init()
{

	// ccp_write_io((void*)&(BOD.CTRLA),BOD_SLEEP_DIS_gc /* Disabled */);

	BOD.INTCTRL = 0 << BOD_VLMIE_bp      /* voltage level monitor interrrupt enable: disabled */
     13c:	82 e0       	ldi	r24, 0x02	; 2
     13e:	80 93 89 00 	sts	0x0089, r24	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
	              | BOD_VLMCFG_ABOVE_gc; /* Interrupt when supply goes above VLM level */

	// BOD.VLMCTRLA = BOD_VLMLVL_5ABOVE_gc; /* VLM threshold 5% above BOD level */

	return 0;
}
     142:	80 e0       	ldi	r24, 0x00	; 0
     144:	08 95       	ret

00000146 <DIGGSIGG_init>:
	//		 | CCL_EDGEDET_DIS_gc /* Edge detector is disabled */
	//		 | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	//		 | 0 << CCL_ENABLE_bp /* LUT Enable: disabled */
	//		 | 0 << CCL_OUTEN_bp; /* Output Enable: disabled */

	CCL.TRUTH1 = 168; /* Truth 1: 168 */
     146:	e0 ec       	ldi	r30, 0xC0	; 192
     148:	f1 e0       	ldi	r31, 0x01	; 1
     14a:	88 ea       	ldi	r24, 0xA8	; 168
     14c:	84 87       	std	Z+12, r24	; 0x0c

	CCL.LUT1CTRLC = CCL_INSEL2_TCA0_gc /* TCA0 WO2 input source */;
     14e:	88 e0       	ldi	r24, 0x08	; 8
     150:	83 87       	std	Z+11, r24	; 0x0b

	CCL.LUT1CTRLB = CCL_INSEL0_SPI0_gc /* SPI0 SCK source */
     152:	8b eb       	ldi	r24, 0xBB	; 187
     154:	82 87       	std	Z+10, r24	; 0x0a
	                | CCL_INSEL1_SPI0_gc /* SPI0 MOSI input source */;

	CCL.LUT1CTRLA = 0 << CCL_CLKSRC_bp       /* Clock Source Selection: disabled */
     156:	89 e0       	ldi	r24, 0x09	; 9
     158:	81 87       	std	Z+9, r24	; 0x09
	                | CCL_EDGEDET_DIS_gc     /* Edge detector is disabled */
	                | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	                | 1 << CCL_ENABLE_bp     /* LUT Enable: enabled */
	                | 1 << CCL_OUTEN_bp;     /* Output Enable: enabled */

	CCL.CTRLA = 1 << CCL_ENABLE_bp      /* Enable: enabled */
     15a:	81 e4       	ldi	r24, 0x41	; 65
     15c:	80 83       	st	Z, r24
	            | 1 << CCL_RUNSTDBY_bp; /* Run in Standby: enabled */

	return 0;
}
     15e:	80 e0       	ldi	r24, 0x00	; 0
     160:	08 95       	ret

00000162 <CLKCTRL_init>:
 *       on calling convention. The memory model is not visible to the
 *       preprocessor, so it must be defined in the Assembler preprocessor directives.
 */
static inline void ccp_write_io(void *addr, uint8_t value)
{
	protected_write_io(addr, CCP_IOREG_gc, value);
     162:	47 e0       	ldi	r20, 0x07	; 7
     164:	68 ed       	ldi	r22, 0xD8	; 216
     166:	8c e7       	ldi	r24, 0x7C	; 124
     168:	90 e0       	ldi	r25, 0x00	; 0
     16a:	0e 94 7d 01 	call	0x2fa	; 0x2fa <protected_write_io>
     16e:	41 e0       	ldi	r20, 0x01	; 1
     170:	68 ed       	ldi	r22, 0xD8	; 216
     172:	81 e6       	ldi	r24, 0x61	; 97
     174:	90 e0       	ldi	r25, 0x00	; 0
     176:	0e 94 7d 01 	call	0x2fa	; 0x2fa <protected_write_io>
	//		 | 0 << CLKCTRL_CLKOUT_bp /* System clock out: disabled */);

	// ccp_write_io((void*)&(CLKCTRL.MCLKLOCK),0 << CLKCTRL_LOCKEN_bp /* lock enable: disabled */);

	return 0;
}
     17a:	80 e0       	ldi	r24, 0x00	; 0
     17c:	08 95       	ret

0000017e <CPUINT_init>:

	// CPUINT.LVL0PRI = 0x0 << CPUINT_LVL0PRI_gp; /* Interrupt Level Priority: 0x0 */

	// CPUINT.LVL1VEC = 0x0 << CPUINT_LVL1VEC_gp; /* Interrupt Vector with High Priority: 0x0 */

	ENABLE_INTERRUPTS();
     17e:	78 94       	sei

	return 0;
}
     180:	80 e0       	ldi	r24, 0x00	; 0
     182:	08 95       	ret

00000184 <DAC_init>:
 *
 * \return Nothing
 */
void DAC_disable()
{
	DAC0.CTRLA &= ~DAC_ENABLE_bm;
     184:	81 e4       	ldi	r24, 0x41	; 65
     186:	80 93 a0 06 	sts	0x06A0, r24	; 0x8006a0 <__TEXT_REGION_LENGTH__+0x7006a0>
     18a:	80 e0       	ldi	r24, 0x00	; 0
     18c:	08 95       	ret

0000018e <DAC_set_output>:
 *
 * \return Nothing
 */
void DAC_set_output(dac_resolution_t value)
{
	DAC0.DATA = value;
     18e:	80 93 a1 06 	sts	0x06A1, r24	; 0x8006a1 <__TEXT_REGION_LENGTH__+0x7006a1>
     192:	08 95       	ret

00000194 <mcu_init>:
#ifdef __cplusplus
extern "C" {
#endif

void mcu_init(void)
{
     194:	e0 e1       	ldi	r30, 0x10	; 16
     196:	f4 e0       	ldi	r31, 0x04	; 4
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     198:	80 81       	ld	r24, Z
     19a:	88 60       	ori	r24, 0x08	; 8
     19c:	81 93       	st	Z+, r24
	 * disables all peripherals to save power. Driver shall enable
	 * peripheral if used */

	/* Set all pins to low power mode */

	for (uint8_t i = 0; i < 8; i++) {
     19e:	e8 31       	cpi	r30, 0x18	; 24
     1a0:	84 e0       	ldi	r24, 0x04	; 4
     1a2:	f8 07       	cpc	r31, r24
     1a4:	c9 f7       	brne	.-14     	; 0x198 <mcu_init+0x4>
     1a6:	e0 e3       	ldi	r30, 0x30	; 48
     1a8:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     1aa:	80 81       	ld	r24, Z
     1ac:	88 60       	ori	r24, 0x08	; 8
     1ae:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTA + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     1b0:	e8 33       	cpi	r30, 0x38	; 56
     1b2:	84 e0       	ldi	r24, 0x04	; 4
     1b4:	f8 07       	cpc	r31, r24
     1b6:	c9 f7       	brne	.-14     	; 0x1aa <mcu_init+0x16>
     1b8:	e0 e5       	ldi	r30, 0x50	; 80
     1ba:	f4 e0       	ldi	r31, 0x04	; 4
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
     1bc:	80 81       	ld	r24, Z
     1be:	88 60       	ori	r24, 0x08	; 8
     1c0:	81 93       	st	Z+, r24

	for (uint8_t i = 0; i < 8; i++) {
		*((uint8_t *)&PORTB + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}

	for (uint8_t i = 0; i < 8; i++) {
     1c2:	e8 35       	cpi	r30, 0x58	; 88
     1c4:	84 e0       	ldi	r24, 0x04	; 4
     1c6:	f8 07       	cpc	r31, r24
     1c8:	c9 f7       	brne	.-14     	; 0x1bc <mcu_init+0x28>
		*((uint8_t *)&PORTC + 0x10 + i) |= 1 << PORT_PULLUPEN_bp;
	}
}
     1ca:	08 95       	ret

000001cc <ADC_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     1cc:	e5 e1       	ldi	r30, 0x15	; 21
     1ce:	f4 e0       	ldi	r31, 0x04	; 4
     1d0:	80 81       	ld	r24, Z
     1d2:	88 7f       	andi	r24, 0xF8	; 248
     1d4:	84 60       	ori	r24, 0x04	; 4
     1d6:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     1d8:	80 81       	ld	r24, Z
     1da:	87 7f       	andi	r24, 0xF7	; 247
     1dc:	80 83       	st	Z, r24
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     1de:	e7 e1       	ldi	r30, 0x17	; 23
     1e0:	f4 e0       	ldi	r31, 0x04	; 4
     1e2:	80 81       	ld	r24, Z
     1e4:	88 7f       	andi	r24, 0xF8	; 248
     1e6:	84 60       	ori	r24, 0x04	; 4
     1e8:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     1ea:	80 81       	ld	r24, Z
     1ec:	87 7f       	andi	r24, 0xF7	; 247
     1ee:	80 83       	st	Z, r24
 */
static inline void PORTB_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     1f0:	e4 e3       	ldi	r30, 0x34	; 52
     1f2:	f4 e0       	ldi	r31, 0x04	; 4
     1f4:	80 81       	ld	r24, Z
     1f6:	88 7f       	andi	r24, 0xF8	; 248
     1f8:	84 60       	ori	r24, 0x04	; 4
     1fa:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     1fc:	80 81       	ld	r24, Z
     1fe:	87 7f       	andi	r24, 0xF7	; 247
     200:	80 83       	st	Z, r24
 */
static inline void PORTB_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     202:	e1 e3       	ldi	r30, 0x31	; 49
     204:	f4 e0       	ldi	r31, 0x04	; 4
     206:	80 81       	ld	r24, Z
     208:	88 7f       	andi	r24, 0xF8	; 248
     20a:	84 60       	ori	r24, 0x04	; 4
     20c:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     20e:	80 81       	ld	r24, Z
     210:	87 7f       	andi	r24, 0xF7	; 247
     212:	80 83       	st	Z, r24
 */
static inline void PORTB_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     214:	e0 e3       	ldi	r30, 0x30	; 48
     216:	f4 e0       	ldi	r31, 0x04	; 4
     218:	80 81       	ld	r24, Z
     21a:	88 7f       	andi	r24, 0xF8	; 248
     21c:	84 60       	ori	r24, 0x04	; 4
     21e:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     220:	80 81       	ld	r24, Z
     222:	87 7f       	andi	r24, 0xF7	; 247
     224:	80 83       	st	Z, r24
	// Disable digital input buffer
	DEN4_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	DEN4_PIN_set_pull_mode(PORT_PULL_OFF);

	ADC_init();
     226:	0e 94 83 00 	call	0x106	; 0x106 <ADC_init>
     22a:	08 95       	ret

0000022c <USART_0_initialization>:
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     22c:	23 98       	cbi	0x04, 3	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     22e:	e3 e3       	ldi	r30, 0x33	; 51
     230:	f4 e0       	ldi	r31, 0x04	; 4
     232:	80 81       	ld	r24, Z
     234:	87 7f       	andi	r24, 0xF7	; 247
     236:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     238:	22 9a       	sbi	0x04, 2	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     23a:	2a 98       	cbi	0x05, 2	; 5
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	USART_0_init();
     23c:	0e 94 b7 01 	call	0x36e	; 0x36e <USART_0_init>
     240:	08 95       	ret

00000242 <TIMER_0_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTB.DIR |= (1 << pin);
     242:	25 9a       	sbi	0x04, 5	; 4
static inline void PORTB_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTB.OUT |= (1 << pin);
	} else {
		VPORTB.OUT &= ~(1 << pin);
     244:	2d 98       	cbi	0x05, 5	; 5
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLC |= PORTMUX_TCA02_bm;
     246:	e0 e0       	ldi	r30, 0x00	; 0
     248:	f2 e0       	ldi	r31, 0x02	; 2
     24a:	82 81       	ldd	r24, Z+2	; 0x02
     24c:	84 60       	ori	r24, 0x04	; 4
     24e:	82 83       	std	Z+2, r24	; 0x02

	TIMER_0_init();
     250:	0e 94 a7 01 	call	0x34e	; 0x34e <TIMER_0_init>
     254:	08 95       	ret

00000256 <DIGGSIGG_initialization>:
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTC.DIR |= (1 << pin);
     256:	41 9a       	sbi	0x08, 1	; 8
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
	} else {
		VPORTC.OUT &= ~(1 << pin);
     258:	49 98       	cbi	0x09, 1	; 9
	    // <false"> Low
	    // <true"> High
	    false);

	/* set the alternate pin mux */
	PORTMUX.CTRLA |= PORTMUX_LUT1_bm;
     25a:	e0 e0       	ldi	r30, 0x00	; 0
     25c:	f2 e0       	ldi	r31, 0x02	; 2
     25e:	80 81       	ld	r24, Z
     260:	80 62       	ori	r24, 0x20	; 32
     262:	80 83       	st	Z, r24

	DIGGSIGG_init();
     264:	0e 94 a3 00 	call	0x146	; 0x146 <DIGGSIGG_init>
     268:	08 95       	ret

0000026a <SPI_0_initialization>:
 */
static inline void PORTA_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
     26a:	02 98       	cbi	0x00, 2	; 0
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     26c:	e2 e1       	ldi	r30, 0x12	; 18
     26e:	f4 e0       	ldi	r31, 0x04	; 4
     270:	80 81       	ld	r24, Z
     272:	87 7f       	andi	r24, 0xF7	; 247
     274:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     276:	01 9a       	sbi	0x00, 1	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     278:	09 98       	cbi	0x01, 1	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     27a:	03 9a       	sbi	0x00, 3	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     27c:	0b 98       	cbi	0x01, 3	; 1
	switch (dir) {
	case PORT_DIR_IN:
		VPORTA.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTA.DIR |= (1 << pin);
     27e:	04 9a       	sbi	0x00, 4	; 0
static inline void PORTA_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTA.OUT |= (1 << pin);
	} else {
		VPORTA.OUT &= ~(1 << pin);
     280:	0c 98       	cbi	0x01, 4	; 1
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    false);

	SPI_0_init();
     282:	0e 94 9f 01 	call	0x33e	; 0x33e <SPI_0_init>
     286:	08 95       	ret

00000288 <DAC_initialization>:
 */
static inline void PORTA_pin_set_isc(const uint8_t pin, const PORT_ISC_t isc)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	*port_pin_ctrl = (*port_pin_ctrl & ~PORT_ISC_gm) | isc;
     288:	e6 e1       	ldi	r30, 0x16	; 22
     28a:	f4 e0       	ldi	r31, 0x04	; 4
     28c:	80 81       	ld	r24, Z
     28e:	88 7f       	andi	r24, 0xF8	; 248
     290:	84 60       	ori	r24, 0x04	; 4
     292:	80 83       	st	Z, r24
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTA + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     294:	80 81       	ld	r24, Z
     296:	87 7f       	andi	r24, 0xF7	; 247
     298:	80 83       	st	Z, r24
	// Disable digital input buffer
	AXON_PIN_set_isc(PORT_ISC_INPUT_DISABLE_gc);
	// Disable pull-up resistor
	AXON_PIN_set_pull_mode(PORT_PULL_OFF);

	DAC_init();
     29a:	0e 94 c2 00 	call	0x184	; 0x184 <DAC_init>
     29e:	08 95       	ret

000002a0 <system_init>:
/**
 * \brief System initialization
 */
void system_init()
{
	mcu_init();
     2a0:	0e 94 ca 00 	call	0x194	; 0x194 <mcu_init>
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     2a4:	26 98       	cbi	0x04, 6	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2a6:	e6 e3       	ldi	r30, 0x36	; 54
     2a8:	f4 e0       	ldi	r31, 0x04	; 4
     2aa:	80 81       	ld	r24, Z
     2ac:	87 7f       	andi	r24, 0xF7	; 247
     2ae:	80 83       	st	Z, r24
 */
static inline void PORTB_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTB.DIR &= ~(1 << pin);
     2b0:	27 98       	cbi	0x04, 7	; 4
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTB + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
	} else if (pull_mode == PORT_PULL_OFF) {
		*port_pin_ctrl &= ~PORT_PULLUPEN_bm;
     2b2:	e7 e3       	ldi	r30, 0x37	; 55
     2b4:	f4 e0       	ldi	r31, 0x04	; 4
     2b6:	80 81       	ld	r24, Z
     2b8:	87 7f       	andi	r24, 0xF7	; 247
     2ba:	80 83       	st	Z, r24
 */
static inline void PORTC_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
     2bc:	42 98       	cbi	0x08, 2	; 8
static inline void PORTC_set_pin_pull_mode(const uint8_t pin, const enum port_pull_mode pull_mode)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
     2be:	e2 e5       	ldi	r30, 0x52	; 82
     2c0:	f4 e0       	ldi	r31, 0x04	; 4
     2c2:	80 81       	ld	r24, Z
     2c4:	88 60       	ori	r24, 0x08	; 8
     2c6:	80 83       	st	Z, r24
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
		break;
	case PORT_DIR_OUT:
		VPORTC.DIR |= (1 << pin);
     2c8:	45 9a       	sbi	0x08, 5	; 8
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     2ca:	4d 9a       	sbi	0x09, 5	; 9
	    // <id> pad_initial_level
	    // <false"> Low
	    // <true"> High
	    true);

	CLKCTRL_init();
     2cc:	0e 94 b1 00 	call	0x162	; 0x162 <CLKCTRL_init>

	RTC_init();
     2d0:	0e 94 81 01 	call	0x302	; 0x302 <RTC_init>

	ADC_initialization();
     2d4:	0e 94 e6 00 	call	0x1cc	; 0x1cc <ADC_initialization>

	USART_0_initialization();
     2d8:	0e 94 16 01 	call	0x22c	; 0x22c <USART_0_initialization>

	TIMER_0_initialization();
     2dc:	0e 94 21 01 	call	0x242	; 0x242 <TIMER_0_initialization>

	DIGGSIGG_initialization();
     2e0:	0e 94 2b 01 	call	0x256	; 0x256 <DIGGSIGG_initialization>

	SPI_0_initialization();
     2e4:	0e 94 35 01 	call	0x26a	; 0x26a <SPI_0_initialization>

	DAC_initialization();
     2e8:	0e 94 44 01 	call	0x288	; 0x288 <DAC_initialization>

	CPUINT_init();
     2ec:	0e 94 bf 00 	call	0x17e	; 0x17e <CPUINT_init>

	SLPCTRL_init();
     2f0:	0e 94 9d 01 	call	0x33a	; 0x33a <SLPCTRL_init>

	BOD_init();
     2f4:	0e 94 9e 00 	call	0x13c	; 0x13c <BOD_init>
     2f8:	08 95       	ret

000002fa <protected_write_io>:
#if defined(__GNUC__)
  
#ifdef RAMPZ
	out     _SFR_IO_ADDR(RAMPZ), r1         // Clear bits 23:16 of Z
#endif
	movw    r30, r24                // Load addr into Z
     2fa:	fc 01       	movw	r30, r24
	out     CCP, r22                // Start CCP handshake
     2fc:	64 bf       	out	0x34, r22	; 52
	st      Z, r20                  // Write value to I/O register
     2fe:	40 83       	st	Z, r20
	ret                             // Return to caller
     300:	08 95       	ret

00000302 <RTC_init>:
 * \return Initialization status.
 */
int8_t RTC_init()
{

	while (RTC.STATUS > 0) { /* Wait for all register to be synchronized */
     302:	e0 e4       	ldi	r30, 0x40	; 64
     304:	f1 e0       	ldi	r31, 0x01	; 1
     306:	81 81       	ldd	r24, Z+1	; 0x01
     308:	81 11       	cpse	r24, r1
     30a:	fd cf       	rjmp	.-6      	; 0x306 <RTC_init+0x4>
	}

	// RTC.CMP = 0x0; /* Compare: 0x0 */

	RTC.CNT = 0x20; /* Counter: 0x20 */
     30c:	e0 e4       	ldi	r30, 0x40	; 64
     30e:	f1 e0       	ldi	r31, 0x01	; 1
     310:	80 e2       	ldi	r24, 0x20	; 32
     312:	90 e0       	ldi	r25, 0x00	; 0
     314:	80 87       	std	Z+8, r24	; 0x08
     316:	91 87       	std	Z+9, r25	; 0x09

	RTC.CTRLA = RTC_PRESCALER_DIV1_gc   /* 1 */
     318:	81 e8       	ldi	r24, 0x81	; 129
     31a:	80 83       	st	Z, r24
	            | 1 << RTC_RTCEN_bp     /* Enable: enabled */
	            | 1 << RTC_RUNSTDBY_bp; /* Run In Standby: enabled */

	RTC.PER = 0x20 / TIMESCALE; /* Period: 0x20 */
     31c:	80 e4       	ldi	r24, 0x40	; 64
     31e:	90 e0       	ldi	r25, 0x00	; 0
     320:	82 87       	std	Z+10, r24	; 0x0a
     322:	93 87       	std	Z+11, r25	; 0x0b

	// RTC.CLKSEL = RTC_CLKSEL_INT32K_gc; /* 32KHz Internal Ultra Low Power Oscillator (OSCULP32K) */

	RTC.DBGCTRL = 1 << RTC_DBGRUN_bp; /* Run in debug: enabled */
     324:	81 e0       	ldi	r24, 0x01	; 1
     326:	85 83       	std	Z+5, r24	; 0x05

	RTC.INTCTRL = 0 << RTC_CMP_bp    /* Compare Match Interrupt enable: disabled */
     328:	82 83       	std	Z+2, r24	; 0x02
	              | 1 << RTC_OVF_bp; /* Overflow Interrupt enable: enabled */

	while (RTC.PITSTATUS > 0) { /* Wait for all register to be synchronized */
     32a:	81 89       	ldd	r24, Z+17	; 0x11
     32c:	81 11       	cpse	r24, r1
     32e:	fd cf       	rjmp	.-6      	; 0x32a <RTC_init+0x28>
	}

	RTC.PITCTRLA = RTC_PERIOD_OFF_gc    /* Off */
     330:	81 e0       	ldi	r24, 0x01	; 1
     332:	80 93 50 01 	sts	0x0150, r24	; 0x800150 <__TEXT_REGION_LENGTH__+0x700150>
	// RTC.PITDBGCTRL = 0 << RTC_DBGRUN_bp; /* Run in debug: disabled */

	// RTC.PITINTCTRL = 0 << RTC_PI_bp; /* Periodic Interrupt: disabled */

	return 0;
}
     336:	80 e0       	ldi	r24, 0x00	; 0
     338:	08 95       	ret

0000033a <SLPCTRL_init>:

	// SLPCTRL.CTRLA = 0 << SLPCTRL_SEN_bp /* Sleep enable: disabled */
	//		 | SLPCTRL_SMODE_IDLE_gc; /* Idle mode */

	return 0;
}
     33a:	80 e0       	ldi	r24, 0x00	; 0
     33c:	08 95       	ret

0000033e <SPI_0_init>:
 * \return Initialization status
 */
int8_t SPI_0_init()
{

	SPI0.CTRLA = 0 << SPI_CLK2X_bp     /* Enable Double Speed: disabled */
     33e:	e0 e2       	ldi	r30, 0x20	; 32
     340:	f8 e0       	ldi	r31, 0x08	; 8
     342:	83 e2       	ldi	r24, 0x23	; 35
     344:	80 83       	st	Z, r24
	             | 0 << SPI_DORD_bp    /* Data Order Setting: disabled */
	             | 1 << SPI_ENABLE_bp  /* Enable Module: enabled */
	             | 1 << SPI_MASTER_bp  /* SPI module in master mode */
	             | SPI_PRESC_DIV16_gc; /* System Clock / 16 */

	SPI0.CTRLB = 0 << SPI_BUFEN_bp   /* Buffer Mode Enable: disabled */
     346:	84 e0       	ldi	r24, 0x04	; 4
     348:	81 83       	std	Z+1, r24	; 0x01
	//		 | 0 << SPI_RXCIE_bp /* Receive Complete Interrupt Enable: disabled */
	//		 | 0 << SPI_SSIE_bp /* Slave Select Trigger Interrupt Enable: disabled */
	//		 | 0 << SPI_TXCIE_bp; /* Transfer Complete Interrupt Enable: disabled */

	return 0;
}
     34a:	80 e0       	ldi	r24, 0x00	; 0
     34c:	08 95       	ret

0000034e <TIMER_0_init>:

	// TCA0.SINGLE.CMP0 = 0x0; /* Compare Register 0: 0x0 */

	// TCA0.SINGLE.CMP1 = 0x0; /* Compare Register 1: 0x0 */

	TCA0.SINGLE.CMP2 = 0x4; /* Compare Register 2: 0x4 */
     34e:	e0 e0       	ldi	r30, 0x00	; 0
     350:	fa e0       	ldi	r31, 0x0A	; 10
     352:	84 e0       	ldi	r24, 0x04	; 4
     354:	90 e0       	ldi	r25, 0x00	; 0
     356:	84 a7       	std	Z+44, r24	; 0x2c
     358:	95 a7       	std	Z+45, r25	; 0x2d

	// TCA0.SINGLE.CNT = 0x0; /* Count: 0x0 */

	TCA0.SINGLE.CTRLB = 0 << TCA_SINGLE_ALUPD_bp            /* Auto Lock Update: disabled */
     35a:	83 e4       	ldi	r24, 0x43	; 67
     35c:	81 83       	std	Z+1, r24	; 0x01
	                    | 0 << TCA_SINGLE_CMP0EN_bp         /* Compare 0 Enable: disabled */
	                    | 0 << TCA_SINGLE_CMP1EN_bp         /* Compare 1 Enable: disabled */
	                    | 1 << TCA_SINGLE_CMP2EN_bp         /* Compare 2 Enable: enabled */
	                    | TCA_SINGLE_WGMODE_SINGLESLOPE_gc; /*  */

	TCA0.SINGLE.CTRLC = 0 << TCA_SINGLE_CMP0OV_bp    /* Compare 0 Waveform Output Value: disabled */
     35e:	84 e0       	ldi	r24, 0x04	; 4
     360:	82 83       	std	Z+2, r24	; 0x02
	// TCA0.SINGLE.INTCTRL = 0 << TCA_SINGLE_CMP0_bp /* Compare 0 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP1_bp /* Compare 1 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP2_bp /* Compare 2 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_OVF_bp; /* Overflow Interrupt: disabled */

	TCA0.SINGLE.PER = 0x7; /* Period: 0x7 */
     362:	87 e0       	ldi	r24, 0x07	; 7
     364:	90 e0       	ldi	r25, 0x00	; 0
     366:	86 a3       	std	Z+38, r24	; 0x26
     368:	97 a3       	std	Z+39, r25	; 0x27

	// TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV1_gc /* System Clock */
	//		 | 0 << TCA_SINGLE_ENABLE_bp; /* Module Enable: disabled */

	return 0;
}
     36a:	80 e0       	ldi	r24, 0x00	; 0
     36c:	08 95       	ret

0000036e <USART_0_init>:
uint8_t USART_0_read()
{
	while (!(USART0.STATUS & USART_RXCIF_bm))
		;
	return USART0.RXDATAL;
}
     36e:	e0 e0       	ldi	r30, 0x00	; 0
     370:	f8 e0       	ldi	r31, 0x08	; 8
     372:	87 e4       	ldi	r24, 0x47	; 71
     374:	90 e1       	ldi	r25, 0x10	; 16
     376:	80 87       	std	Z+8, r24	; 0x08
     378:	91 87       	std	Z+9, r25	; 0x09
     37a:	80 ec       	ldi	r24, 0xC0	; 192
     37c:	86 83       	std	Z+6, r24	; 0x06
     37e:	80 e0       	ldi	r24, 0x00	; 0
     380:	98 e3       	ldi	r25, 0x38	; 56
     382:	80 93 67 38 	sts	0x3867, r24	; 0x803867 <__iob+0x2>
     386:	90 93 68 38 	sts	0x3868, r25	; 0x803868 <__iob+0x3>
     38a:	80 e0       	ldi	r24, 0x00	; 0
     38c:	08 95       	ret

0000038e <USART_0_write>:
 *
 * \return Nothing
 */
void USART_0_write(const uint8_t data)
{
	while (!(USART0.STATUS & USART_DREIF_bm))
     38e:	e0 e0       	ldi	r30, 0x00	; 0
     390:	f8 e0       	ldi	r31, 0x08	; 8
     392:	94 81       	ldd	r25, Z+4	; 0x04
     394:	95 ff       	sbrs	r25, 5
     396:	fd cf       	rjmp	.-6      	; 0x392 <USART_0_write+0x4>
		;
	USART0.TXDATAL = data;
     398:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <__TEXT_REGION_LENGTH__+0x700802>
     39c:	08 95       	ret

0000039e <USART_0_printCHAR>:

#if defined(__GNUC__)

int USART_0_printCHAR(char character, FILE *stream)
{
	USART_0_write(character);
     39e:	0e 94 c7 01 	call	0x38e	; 0x38e <USART_0_write>
	return 0;
}
     3a2:	80 e0       	ldi	r24, 0x00	; 0
     3a4:	90 e0       	ldi	r25, 0x00	; 0
     3a6:	08 95       	ret

000003a8 <tinyCharge_is_connected_to_charger>:

_Bool connected_to_charger;

_Bool tinyCharge_is_connected_to_charger(){
	return connected_to_charger;
}
     3a8:	80 91 58 38 	lds	r24, 0x3858	; 0x803858 <connected_to_charger>
     3ac:	08 95       	ret

000003ae <tinyCharge_is_fully_charged>:
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTB_get_pin_level(const uint8_t pin)
{
	return VPORTB.IN & (1 << pin);
     3ae:	86 b1       	in	r24, 0x06	; 6

_Bool tinyCharge_is_fully_charged(){
	return CHARGING_STATUS_PIN_get_level();
}
     3b0:	88 1f       	adc	r24, r24
     3b2:	88 27       	eor	r24, r24
     3b4:	88 1f       	adc	r24, r24
     3b6:	08 95       	ret

000003b8 <tinyCharge_switch_mode>:
	}
}

void tinyCharge_switch_mode(){
	
	if(connected_to_charger){
     3b8:	80 91 58 38 	lds	r24, 0x3858	; 0x803858 <connected_to_charger>
     3bc:	88 23       	and	r24, r24
     3be:	51 f0       	breq	.+20     	; 0x3d4 <tinyCharge_switch_mode+0x1c>
		// Switch from main to charging mode
		
		// Set LED
		tinyLED_set_color(OUT_LED, OFF);
     3c0:	60 e0       	ldi	r22, 0x00	; 0
     3c2:	80 e0       	ldi	r24, 0x00	; 0
     3c4:	0e 94 1b 03 	call	0x636	; 0x636 <tinyLED_set_color>
		tinyLED_set_color_mode(INN_LED, CHARGING_COLOR, SWING);
     3c8:	42 e0       	ldi	r20, 0x02	; 2
     3ca:	61 e0       	ldi	r22, 0x01	; 1
     3cc:	81 e0       	ldi	r24, 0x01	; 1
     3ce:	0e 94 2c 03 	call	0x658	; 0x658 <tinyLED_set_color_mode>
     3d2:	08 95       	ret
	}
	else{
		// Switch from charge to main mode
		
		// Set LED
		tinyLED_set_color(OUT_LED, OFF);
     3d4:	60 e0       	ldi	r22, 0x00	; 0
     3d6:	80 e0       	ldi	r24, 0x00	; 0
     3d8:	0e 94 1b 03 	call	0x636	; 0x636 <tinyLED_set_color>
		tinyLED_set_color(INN_LED, OFF);
     3dc:	60 e0       	ldi	r22, 0x00	; 0
     3de:	81 e0       	ldi	r24, 0x01	; 1
     3e0:	0e 94 1b 03 	call	0x636	; 0x636 <tinyLED_set_color>
     3e4:	08 95       	ret

000003e6 <tinyCharge_set_charging_mode>:
_Bool tinyCharge_is_fully_charged(){
	return CHARGING_STATUS_PIN_get_level();
}

void tinyCharge_set_charging_mode(_Bool charging_status){
	if(charging_status != connected_to_charger){
     3e6:	90 91 58 38 	lds	r25, 0x3858	; 0x803858 <connected_to_charger>
     3ea:	98 17       	cp	r25, r24
     3ec:	21 f0       	breq	.+8      	; 0x3f6 <tinyCharge_set_charging_mode+0x10>
		connected_to_charger = charging_status;
     3ee:	80 93 58 38 	sts	0x3858, r24	; 0x803858 <connected_to_charger>
		tinyCharge_switch_mode();
     3f2:	0e 94 dc 01 	call	0x3b8	; 0x3b8 <tinyCharge_switch_mode>
     3f6:	08 95       	ret

000003f8 <tinyCharge_set_transistors>:
	}
}


void tinyCharge_set_transistors(){
	if(connected_to_charger){
     3f8:	80 91 58 38 	lds	r24, 0x3858	; 0x803858 <connected_to_charger>
     3fc:	88 23       	and	r24, r24
     3fe:	11 f0       	breq	.+4      	; 0x404 <__LOCK_REGION_LENGTH__+0x4>
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
	} else {
		VPORTC.OUT &= ~(1 << pin);
     400:	4d 98       	cbi	0x09, 5	; 9
     402:	08 95       	ret
 *                  false = Pin level set to "low" state
 */
static inline void PORTC_set_pin_level(const uint8_t pin, const bool level)
{
	if (level == true) {
		VPORTC.OUT |= (1 << pin);
     404:	4d 9a       	sbi	0x09, 5	; 9
     406:	08 95       	ret

00000408 <tinyDebugger_send_uint32>:
		char number[20]; // Arbitrary max
		dtostrf(value,1,NUMBER_OF_DECIMALS, number);
		printf("%s:%5s\t", name, number);
	}
}
void tinyDebugger_send_string(const char* name, char * value){
     408:	08 95       	ret

0000040a <tinyDebugger_send_uint8>:
     40a:	08 95       	ret

0000040c <tinyDebugger_send_double>:
     40c:	08 95       	ret

0000040e <tinyDebugger_end_line>:
}
void tinyDebugger_end_line(){
	if(DEBUGGING && tinyDebugger_send_message){
		printf("\r\n");
	}
	tinyDebugger_print_attempts++;
     40e:	80 91 16 38 	lds	r24, 0x3816	; 0x803816 <__data_end>
     412:	8f 5f       	subi	r24, 0xFF	; 255
     414:	80 93 16 38 	sts	0x3816, r24	; 0x803816 <__data_end>
	tinyDebugger_send_message = tinyDebugger_print_attempts%DEBUG_EVERY == 0;
     418:	81 e0       	ldi	r24, 0x01	; 1
     41a:	80 93 0e 38 	sts	0x380E, r24	; 0x80380e <tinyDebugger_send_message>
     41e:	08 95       	ret

00000420 <tinyPulse_toggle_pulse_mode>:
uint32_t time_of_last_pulse = 0;
uint16_t time_since_last_pulse = 0;
uint16_t ideal_time_between_pulses = 1000/PULSEMODE_FREQUENCY;

void tinyPulse_toggle_pulse_mode(){
	pulse_mode = !pulse_mode;
     420:	90 91 1d 38 	lds	r25, 0x381D	; 0x80381d <pulse_mode>
     424:	81 e0       	ldi	r24, 0x01	; 1
     426:	89 27       	eor	r24, r25
     428:	80 93 1d 38 	sts	0x381D, r24	; 0x80381d <pulse_mode>
     42c:	08 95       	ret

0000042e <tinyPulse_update_potential>:
}

double tinyPulse_update_potential(double potential){
     42e:	cf 92       	push	r12
     430:	df 92       	push	r13
     432:	ef 92       	push	r14
     434:	ff 92       	push	r15
     436:	6b 01       	movw	r12, r22
     438:	7c 01       	movw	r14, r24
	if(pulse_mode){
     43a:	80 91 1d 38 	lds	r24, 0x381D	; 0x80381d <pulse_mode>
     43e:	88 23       	and	r24, r24
     440:	39 f1       	breq	.+78     	; 0x490 <tinyPulse_update_potential+0x62>
		
		time_since_last_pulse = tinyTime_now() - time_of_last_pulse;
     442:	0e 94 63 02 	call	0x4c6	; 0x4c6 <tinyTime_now>
     446:	20 91 19 38 	lds	r18, 0x3819	; 0x803819 <time_of_last_pulse>
     44a:	30 91 1a 38 	lds	r19, 0x381A	; 0x80381a <time_of_last_pulse+0x1>
     44e:	62 1b       	sub	r22, r18
     450:	73 0b       	sbc	r23, r19
     452:	60 93 17 38 	sts	0x3817, r22	; 0x803817 <time_since_last_pulse>
     456:	70 93 18 38 	sts	0x3818, r23	; 0x803818 <time_since_last_pulse+0x1>
		
		if(time_since_last_pulse >= ideal_time_between_pulses){
     45a:	80 91 0f 38 	lds	r24, 0x380F	; 0x80380f <ideal_time_between_pulses>
     45e:	90 91 10 38 	lds	r25, 0x3810	; 0x803810 <ideal_time_between_pulses+0x1>
     462:	68 17       	cp	r22, r24
     464:	79 07       	cpc	r23, r25
     466:	a0 f0       	brcs	.+40     	; 0x490 <tinyPulse_update_potential+0x62>
			// This isn't actually a button press. You could have a separate variable for this, but it seems unnecessary.
			potential += BUTTON_PRESS_REACTION;
     468:	20 e0       	ldi	r18, 0x00	; 0
     46a:	30 e0       	ldi	r19, 0x00	; 0
     46c:	40 ed       	ldi	r20, 0xD0	; 208
     46e:	51 e4       	ldi	r21, 0x41	; 65
     470:	c7 01       	movw	r24, r14
     472:	b6 01       	movw	r22, r12
     474:	0e 94 e4 07 	call	0xfc8	; 0xfc8 <__addsf3>
     478:	6b 01       	movw	r12, r22
     47a:	7c 01       	movw	r14, r24
			time_of_last_pulse = tinyTime_now();			
     47c:	0e 94 63 02 	call	0x4c6	; 0x4c6 <tinyTime_now>
     480:	60 93 19 38 	sts	0x3819, r22	; 0x803819 <time_of_last_pulse>
     484:	70 93 1a 38 	sts	0x381A, r23	; 0x80381a <time_of_last_pulse+0x1>
     488:	80 93 1b 38 	sts	0x381B, r24	; 0x80381b <time_of_last_pulse+0x2>
     48c:	90 93 1c 38 	sts	0x381C, r25	; 0x80381c <time_of_last_pulse+0x3>
		}
	}
	return potential;
}
     490:	c7 01       	movw	r24, r14
     492:	b6 01       	movw	r22, r12
     494:	ff 90       	pop	r15
     496:	ef 90       	pop	r14
     498:	df 90       	pop	r13
     49a:	cf 90       	pop	r12
     49c:	08 95       	ret

0000049e <tinyTime_counter_increment>:
If the Interrupt Service Routine is clocked by a crystal oscillator
it gives a very precise timer-counter.
*/
void tinyTime_counter_increment(void)
{
	time_counter++;
     49e:	80 91 1e 38 	lds	r24, 0x381E	; 0x80381e <time_counter>
     4a2:	90 91 1f 38 	lds	r25, 0x381F	; 0x80381f <time_counter+0x1>
     4a6:	a0 91 20 38 	lds	r26, 0x3820	; 0x803820 <time_counter+0x2>
     4aa:	b0 91 21 38 	lds	r27, 0x3821	; 0x803821 <time_counter+0x3>
     4ae:	01 96       	adiw	r24, 0x01	; 1
     4b0:	a1 1d       	adc	r26, r1
     4b2:	b1 1d       	adc	r27, r1
     4b4:	80 93 1e 38 	sts	0x381E, r24	; 0x80381e <time_counter>
     4b8:	90 93 1f 38 	sts	0x381F, r25	; 0x80381f <time_counter+0x1>
     4bc:	a0 93 20 38 	sts	0x3820, r26	; 0x803820 <time_counter+0x2>
     4c0:	b0 93 21 38 	sts	0x3821, r27	; 0x803821 <time_counter+0x3>
     4c4:	08 95       	ret

000004c6 <tinyTime_now>:
/*
This function is callable by external libraries to give them the counted time so far.
*/
uint32_t tinyTime_now(void)
{
	return time_counter;
     4c6:	60 91 1e 38 	lds	r22, 0x381E	; 0x80381e <time_counter>
     4ca:	70 91 1f 38 	lds	r23, 0x381F	; 0x80381f <time_counter+0x1>
     4ce:	80 91 20 38 	lds	r24, 0x3820	; 0x803820 <time_counter+0x2>
     4d2:	90 91 21 38 	lds	r25, 0x3821	; 0x803821 <time_counter+0x3>
     4d6:	08 95       	ret

000004d8 <main>:

int main(void)
{	
	
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
     4d8:	0e 94 80 00 	call	0x100	; 0x100 <atmel_start_init>
	For some reason, instead of the reference voltage being 4.32v, it is 3.3v. 
	A plausible explanation is that the microchip does not up the voltage, so that if the microchip is only ever 
	supplied with 3.3v, it will output 3.3v as the max.
	*/
	
	VREF.CTRLA |= VREF_ADC0REFSEL_2V5_gc;
     4dc:	e0 ea       	ldi	r30, 0xA0	; 160
     4de:	f0 e0       	ldi	r31, 0x00	; 0
     4e0:	80 81       	ld	r24, Z
     4e2:	80 62       	ori	r24, 0x20	; 32
     4e4:	80 83       	st	Z, r24
	VREF.CTRLA |= VREF_DAC0REFSEL_4V34_gc;
     4e6:	80 81       	ld	r24, Z
     4e8:	83 60       	ori	r24, 0x03	; 3
     4ea:	80 83       	st	Z, r24
	 
	while (1)
	{
		// We don't want to update the neuron too often because of various reasons. The tinyISR_getflag is set every ms, and so the loop is only run once every ms.  
		if(tinyISR_getflag())
     4ec:	0e 94 50 07 	call	0xea0	; 0xea0 <tinyISR_getflag>
     4f0:	88 23       	and	r24, r24
     4f2:	e1 f3       	breq	.-8      	; 0x4ec <main+0x14>
		{			
			
			if(tinyCharge_is_connected_to_charger()){
     4f4:	0e 94 d4 01 	call	0x3a8	; 0x3a8 <tinyCharge_is_connected_to_charger>
     4f8:	88 23       	and	r24, r24
     4fa:	59 f0       	breq	.+22     	; 0x512 <main+0x3a>
				// Charge loop
				
				if(tinyCharge_is_fully_charged()){
     4fc:	0e 94 d7 01 	call	0x3ae	; 0x3ae <tinyCharge_is_fully_charged>
     500:	88 23       	and	r24, r24
     502:	21 f0       	breq	.+8      	; 0x50c <main+0x34>
					tinyLED_set_color(OUT_LED, CHARGING_DONE_COLOR);
     504:	63 e0       	ldi	r22, 0x03	; 3
     506:	80 e0       	ldi	r24, 0x00	; 0
     508:	0e 94 1b 03 	call	0x636	; 0x636 <tinyLED_set_color>
				}				
				// We check the Dendrites in order to detect if we have stopped charging
				tinyDendrite_update_signals();
     50c:	0e 94 54 06 	call	0xca8	; 0xca8 <tinyDendrite_update_signals>
     510:	0d c0       	rjmp	.+26     	; 0x52c <main+0x54>
			}
			else{
				// Main loop			
				
				// Set LED
				if(tinyLED_get_color(OUT_LED) == OFF){
     512:	80 e0       	ldi	r24, 0x00	; 0
     514:	0e 94 24 03 	call	0x648	; 0x648 <tinyLED_get_color>
     518:	81 11       	cpse	r24, r1
     51a:	04 c0       	rjmp	.+8      	; 0x524 <main+0x4c>
					tinyLED_set_color_mode(OUT_LED, PING_COLOR, PING);
     51c:	43 e0       	ldi	r20, 0x03	; 3
     51e:	62 e0       	ldi	r22, 0x02	; 2
     520:	0e 94 2c 03 	call	0x658	; 0x658 <tinyLED_set_color_mode>
				}
				
				// Update button	
				tinyButton_update();
     524:	0e 94 a8 02 	call	0x550	; 0x550 <tinyButton_update>
				
				// Update the potential (This is where most of the important stuff happens)
				tinyPotential_update();
     528:	0e 94 53 07 	call	0xea6	; 0xea6 <tinyPotential_update>
			}
			// Update LED
			tinyLED_update();
     52c:	0e 94 6c 03 	call	0x6d8	; 0x6d8 <tinyLED_update>
				
			// Switch transistors
			tinyCharge_set_transistors();
     530:	0e 94 fc 01 	call	0x3f8	; 0x3f8 <tinyCharge_set_transistors>
			
			// Prepare for next cycle
			tinyISR_setflag(false);
     534:	80 e0       	ldi	r24, 0x00	; 0
     536:	0e 94 4d 07 	call	0xe9a	; 0xe9a <tinyISR_setflag>
			tinyDebugger_send_uint32("time", tinyTime_now());
     53a:	0e 94 63 02 	call	0x4c6	; 0x4c6 <tinyTime_now>
     53e:	ab 01       	movw	r20, r22
     540:	bc 01       	movw	r22, r24
     542:	8a e3       	ldi	r24, 0x3A	; 58
     544:	97 e9       	ldi	r25, 0x97	; 151
     546:	0e 94 04 02 	call	0x408	; 0x408 <tinyDebugger_send_uint32>
			tinyDebugger_end_line();
     54a:	0e 94 07 02 	call	0x40e	; 0x40e <tinyDebugger_end_line>
     54e:	ce cf       	rjmp	.-100    	; 0x4ec <main+0x14>

00000550 <tinyButton_update>:
/*
If the button has been let go, we change button_press to true. This only lasts one cycle, before it is set to false again.
If the button is held down for longer than PULSEMODE_BUTTON_PRESS_TIME, we toggle the pulse mode state.
*/
void tinyButton_update(void)
{
     550:	0f 93       	push	r16
     552:	1f 93       	push	r17
     554:	cf 93       	push	r28
     556:	df 93       	push	r29
	button_press = false;
     558:	10 92 26 38 	sts	0x3826, r1	; 0x803826 <button_press>
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTC_get_pin_level(const uint8_t pin)
{
	return VPORTC.IN & (1 << pin);
     55c:	8a b1       	in	r24, 0x0a	; 10
	_Bool button_is_pushed_down = !BUTTON_PIN_get_level(); // The digital port will be read as low if the button is pushed down.
     55e:	d1 e0       	ldi	r29, 0x01	; 1
     560:	c8 2f       	mov	r28, r24
     562:	c4 70       	andi	r28, 0x04	; 4
     564:	82 fd       	sbrc	r24, 2
     566:	d0 e0       	ldi	r29, 0x00	; 0

	if (button_is_pushed_down && !button_was_pushed_down)
     568:	c1 11       	cpse	r28, r1
     56a:	36 c0       	rjmp	.+108    	; 0x5d8 <tinyButton_update+0x88>
     56c:	80 91 27 38 	lds	r24, 0x3827	; 0x803827 <button_was_pushed_down>
     570:	81 11       	cpse	r24, r1
     572:	0e c0       	rjmp	.+28     	; 0x590 <tinyButton_update+0x40>
	{
		tinyButton_start_time = tinyTime_now();
     574:	0e 94 63 02 	call	0x4c6	; 0x4c6 <tinyTime_now>
     578:	60 93 22 38 	sts	0x3822, r22	; 0x803822 <tinyButton_start_time>
     57c:	70 93 23 38 	sts	0x3823, r23	; 0x803823 <tinyButton_start_time+0x1>
     580:	80 93 24 38 	sts	0x3824, r24	; 0x803824 <tinyButton_start_time+0x2>
     584:	90 93 25 38 	sts	0x3825, r25	; 0x803825 <tinyButton_start_time+0x3>
	}
	if (button_is_pushed_down && button_was_pushed_down)
     588:	80 91 27 38 	lds	r24, 0x3827	; 0x803827 <button_was_pushed_down>
     58c:	88 23       	and	r24, r24
     58e:	69 f1       	breq	.+90     	; 0x5ea <tinyButton_update+0x9a>
	{
		if ((tinyTime_now() - tinyButton_start_time) > PULSEMODE_BUTTON_PRESS_TIME)
     590:	0e 94 63 02 	call	0x4c6	; 0x4c6 <tinyTime_now>
     594:	00 91 22 38 	lds	r16, 0x3822	; 0x803822 <tinyButton_start_time>
     598:	10 91 23 38 	lds	r17, 0x3823	; 0x803823 <tinyButton_start_time+0x1>
     59c:	20 91 24 38 	lds	r18, 0x3824	; 0x803824 <tinyButton_start_time+0x2>
     5a0:	30 91 25 38 	lds	r19, 0x3825	; 0x803825 <tinyButton_start_time+0x3>
     5a4:	60 1b       	sub	r22, r16
     5a6:	71 0b       	sbc	r23, r17
     5a8:	82 0b       	sbc	r24, r18
     5aa:	93 0b       	sbc	r25, r19
     5ac:	0e 94 30 09 	call	0x1260	; 0x1260 <__floatunsisf>
     5b0:	20 e0       	ldi	r18, 0x00	; 0
     5b2:	30 e0       	ldi	r19, 0x00	; 0
     5b4:	4a e7       	ldi	r20, 0x7A	; 122
     5b6:	54 e4       	ldi	r21, 0x44	; 68
     5b8:	0e 94 28 0a 	call	0x1450	; 0x1450 <__gesf2>
     5bc:	18 16       	cp	r1, r24
     5be:	64 f4       	brge	.+24     	; 0x5d8 <tinyButton_update+0x88>
		{
			tinyPulse_toggle_pulse_mode();
     5c0:	0e 94 10 02 	call	0x420	; 0x420 <tinyPulse_toggle_pulse_mode>
			tinyButton_start_time = tinyTime_now();
     5c4:	0e 94 63 02 	call	0x4c6	; 0x4c6 <tinyTime_now>
     5c8:	60 93 22 38 	sts	0x3822, r22	; 0x803822 <tinyButton_start_time>
     5cc:	70 93 23 38 	sts	0x3823, r23	; 0x803823 <tinyButton_start_time+0x1>
     5d0:	80 93 24 38 	sts	0x3824, r24	; 0x803824 <tinyButton_start_time+0x2>
     5d4:	90 93 25 38 	sts	0x3825, r25	; 0x803825 <tinyButton_start_time+0x3>
		}
	}
	if (!button_is_pushed_down && button_was_pushed_down)
     5d8:	cc 23       	and	r28, r28
     5da:	39 f0       	breq	.+14     	; 0x5ea <tinyButton_update+0x9a>
     5dc:	80 91 27 38 	lds	r24, 0x3827	; 0x803827 <button_was_pushed_down>
     5e0:	88 23       	and	r24, r24
     5e2:	19 f0       	breq	.+6      	; 0x5ea <tinyButton_update+0x9a>
	{
		button_press = true;
     5e4:	81 e0       	ldi	r24, 0x01	; 1
     5e6:	80 93 26 38 	sts	0x3826, r24	; 0x803826 <button_press>
	}
	button_was_pushed_down = button_is_pushed_down;
     5ea:	d0 93 27 38 	sts	0x3827, r29	; 0x803827 <button_was_pushed_down>
}
     5ee:	df 91       	pop	r29
     5f0:	cf 91       	pop	r28
     5f2:	1f 91       	pop	r17
     5f4:	0f 91       	pop	r16
     5f6:	08 95       	ret

000005f8 <tinyButton_update_potential>:

double tinyButton_update_potential(double potential){
	if(button_press){
     5f8:	20 91 26 38 	lds	r18, 0x3826	; 0x803826 <button_press>
     5fc:	22 23       	and	r18, r18
     5fe:	31 f0       	breq	.+12     	; 0x60c <tinyButton_update_potential+0x14>
		potential += BUTTON_PRESS_REACTION;
     600:	20 e0       	ldi	r18, 0x00	; 0
     602:	30 e0       	ldi	r19, 0x00	; 0
     604:	40 ed       	ldi	r20, 0xD0	; 208
     606:	51 e4       	ldi	r21, 0x41	; 65
     608:	0e 94 e4 07 	call	0xfc8	; 0xfc8 <__addsf3>
	}
	return potential;
}
     60c:	08 95       	ret

0000060e <tinyLED_SPIWriteByte>:
Function used to send a byte over SPI, which in turn gets
translated to the bit-sequence required by the LEDs over the CCL.
*/
static void tinyLED_SPIWriteByte(uint8_t byte)
{
	SPI0.INTFLAGS = SPI0_INTFLAGS; // clear the write collision flag to allow writing
     60e:	90 91 23 08 	lds	r25, 0x0823	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
     612:	90 93 23 08 	sts	0x0823, r25	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
	TCA0.SINGLE.CNT = 0; // reset TCA counter register to ensure the first rising edge of the PWM is predictable
     616:	e0 e0       	ldi	r30, 0x00	; 0
     618:	fa e0       	ldi	r31, 0x0A	; 10
     61a:	10 a2       	std	Z+32, r1	; 0x20
     61c:	11 a2       	std	Z+33, r1	; 0x21
	
	// start TCA
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 1 << TCA_SPLIT_ENABLE_bp;
     61e:	91 e0       	ldi	r25, 0x01	; 1
     620:	90 83       	st	Z, r25
	SPI0_DATA = byte;
     622:	80 93 24 08 	sts	0x0824, r24	; 0x800824 <__TEXT_REGION_LENGTH__+0x700824>

	while((SPI0.INTFLAGS & SPI_RXCIE_bm) == 0){} // wait for transfer to complete
     626:	e0 e2       	ldi	r30, 0x20	; 32
     628:	f8 e0       	ldi	r31, 0x08	; 8
     62a:	83 81       	ldd	r24, Z+3	; 0x03
     62c:	88 23       	and	r24, r24
     62e:	ec f7       	brge	.-6      	; 0x62a <tinyLED_SPIWriteByte+0x1c>
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 0 << TCA_SPLIT_ENABLE_bp; //Stop TCA
     630:	10 92 00 0a 	sts	0x0A00, r1	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
     634:	08 95       	ret

00000636 <tinyLED_set_color>:
changes the values in the variables stored in the LED-array.
*/
void tinyLED_set_color_mode(uint8_t LED_id, enum Colors color, enum ColorModes mode)
{
	struct ColorSetting setting = {.color=color, .mode=mode};
	tinyLED_colors[LED_id] = setting;
     636:	e8 2f       	mov	r30, r24
     638:	f0 e0       	ldi	r31, 0x00	; 0
     63a:	ee 0f       	add	r30, r30
     63c:	ff 1f       	adc	r31, r31
     63e:	ef 59       	subi	r30, 0x9F	; 159
     640:	f7 4c       	sbci	r31, 0xC7	; 199
     642:	60 83       	st	Z, r22
     644:	11 82       	std	Z+1, r1	; 0x01
     646:	08 95       	ret

00000648 <tinyLED_get_color>:
	tinyLED_set_color_mode(LED_id, color, STABLE);
}

enum Colors tinyLED_get_color(uint8_t LED_id)
{
	return tinyLED_colors[LED_id].color;
     648:	e8 2f       	mov	r30, r24
     64a:	f0 e0       	ldi	r31, 0x00	; 0
     64c:	ee 0f       	add	r30, r30
     64e:	ff 1f       	adc	r31, r31
     650:	ef 59       	subi	r30, 0x9F	; 159
     652:	f7 4c       	sbci	r31, 0xC7	; 199
}
     654:	80 81       	ld	r24, Z
     656:	08 95       	ret

00000658 <tinyLED_set_color_mode>:
changes the values in the variables stored in the LED-array.
*/
void tinyLED_set_color_mode(uint8_t LED_id, enum Colors color, enum ColorModes mode)
{
	struct ColorSetting setting = {.color=color, .mode=mode};
	tinyLED_colors[LED_id] = setting;
     658:	90 e0       	ldi	r25, 0x00	; 0
     65a:	fc 01       	movw	r30, r24
     65c:	ee 0f       	add	r30, r30
     65e:	ff 1f       	adc	r31, r31
     660:	ef 59       	subi	r30, 0x9F	; 159
     662:	f7 4c       	sbci	r31, 0xC7	; 199
     664:	60 83       	st	Z, r22
     666:	41 83       	std	Z+1, r20	; 0x01
	if (mode == FLASH_ONCE)
     668:	44 30       	cpi	r20, 0x04	; 4
     66a:	29 f4       	brne	.+10     	; 0x676 <tinyLED_set_color_mode+0x1e>
	{
		tinyLED_flash_once_time[LED_id] = 1000*FLASH_TIME;
     66c:	fc 01       	movw	r30, r24
     66e:	e7 5a       	subi	r30, 0xA7	; 167
     670:	f7 4c       	sbci	r31, 0xC7	; 199
     672:	24 e6       	ldi	r18, 0x64	; 100
     674:	20 83       	st	Z, r18
     676:	08 95       	ret

00000678 <tinyLED_RGB_Color_Compare>:
	}
	return rgb_color;
			
};

_Bool tinyLED_RGB_Color_Compare(struct RGB_Color* a, struct RGB_Color* b){
     678:	dc 01       	movw	r26, r24
     67a:	fb 01       	movw	r30, r22
	for (int i=0; i<NUMBER_OF_LEDS; i++)
	{
		if(!(a[i].red==b[i].red && a[i].green==b[i].green && a[i].blue==b[i].blue)){
     67c:	9c 91       	ld	r25, X
     67e:	80 81       	ld	r24, Z
     680:	98 13       	cpse	r25, r24
     682:	20 c0       	rjmp	.+64     	; 0x6c4 <tinyLED_RGB_Color_Compare+0x4c>
     684:	11 96       	adiw	r26, 0x01	; 1
     686:	9c 91       	ld	r25, X
     688:	11 97       	sbiw	r26, 0x01	; 1
     68a:	81 81       	ldd	r24, Z+1	; 0x01
     68c:	98 13       	cpse	r25, r24
     68e:	1c c0       	rjmp	.+56     	; 0x6c8 <tinyLED_RGB_Color_Compare+0x50>
     690:	12 96       	adiw	r26, 0x02	; 2
     692:	9c 91       	ld	r25, X
     694:	12 97       	sbiw	r26, 0x02	; 2
     696:	82 81       	ldd	r24, Z+2	; 0x02
     698:	98 13       	cpse	r25, r24
     69a:	18 c0       	rjmp	.+48     	; 0x6cc <tinyLED_RGB_Color_Compare+0x54>
     69c:	13 96       	adiw	r26, 0x03	; 3
     69e:	9c 91       	ld	r25, X
     6a0:	13 97       	sbiw	r26, 0x03	; 3
     6a2:	83 81       	ldd	r24, Z+3	; 0x03
     6a4:	98 13       	cpse	r25, r24
     6a6:	14 c0       	rjmp	.+40     	; 0x6d0 <tinyLED_RGB_Color_Compare+0x58>
     6a8:	14 96       	adiw	r26, 0x04	; 4
     6aa:	9c 91       	ld	r25, X
     6ac:	14 97       	sbiw	r26, 0x04	; 4
     6ae:	84 81       	ldd	r24, Z+4	; 0x04
     6b0:	98 13       	cpse	r25, r24
     6b2:	10 c0       	rjmp	.+32     	; 0x6d4 <tinyLED_RGB_Color_Compare+0x5c>
     6b4:	81 e0       	ldi	r24, 0x01	; 1
     6b6:	15 96       	adiw	r26, 0x05	; 5
     6b8:	2c 91       	ld	r18, X
     6ba:	95 81       	ldd	r25, Z+5	; 0x05
     6bc:	29 17       	cp	r18, r25
     6be:	59 f0       	breq	.+22     	; 0x6d6 <tinyLED_RGB_Color_Compare+0x5e>
     6c0:	80 e0       	ldi	r24, 0x00	; 0
     6c2:	08 95       	ret
			return false;
     6c4:	80 e0       	ldi	r24, 0x00	; 0
     6c6:	08 95       	ret
     6c8:	80 e0       	ldi	r24, 0x00	; 0
     6ca:	08 95       	ret
     6cc:	80 e0       	ldi	r24, 0x00	; 0
     6ce:	08 95       	ret
     6d0:	80 e0       	ldi	r24, 0x00	; 0
     6d2:	08 95       	ret
     6d4:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	return true;
}
     6d6:	08 95       	ret

000006d8 <tinyLED_update>:
/*
function to write the current LED-array on to the LEDs and
effectively update the values stored in the LEDs to the values stored in the MCU.
*/
void tinyLED_update(void)
{
     6d8:	2f 92       	push	r2
     6da:	3f 92       	push	r3
     6dc:	4f 92       	push	r4
     6de:	5f 92       	push	r5
     6e0:	6f 92       	push	r6
     6e2:	7f 92       	push	r7
     6e4:	8f 92       	push	r8
     6e6:	9f 92       	push	r9
     6e8:	af 92       	push	r10
     6ea:	bf 92       	push	r11
     6ec:	cf 92       	push	r12
     6ee:	df 92       	push	r13
     6f0:	ef 92       	push	r14
     6f2:	ff 92       	push	r15
     6f4:	0f 93       	push	r16
     6f6:	1f 93       	push	r17
     6f8:	cf 93       	push	r28
     6fa:	df 93       	push	r29
     6fc:	cd b7       	in	r28, 0x3d	; 61
     6fe:	de b7       	in	r29, 0x3e	; 62
     700:	6e 97       	sbiw	r28, 0x1e	; 30
     702:	cd bf       	out	0x3d, r28	; 61
     704:	de bf       	out	0x3e, r29	; 62
			
	uint32_t now = tinyTime_now();
     706:	0e 94 63 02 	call	0x4c6	; 0x4c6 <tinyTime_now>
     70a:	6b 01       	movw	r12, r22
     70c:	7c 01       	movw	r14, r24
	double sinValue = 1+sin((double)now/(100*M_PI/SWING_RATE));
     70e:	0e 94 30 09 	call	0x1260	; 0x1260 <__floatunsisf>
     712:	23 e6       	ldi	r18, 0x63	; 99
     714:	34 e1       	ldi	r19, 0x14	; 20
     716:	4d e9       	ldi	r20, 0x9D	; 157
     718:	53 e4       	ldi	r21, 0x43	; 67
     71a:	0e 94 55 08 	call	0x10aa	; 0x10aa <__divsf3>
     71e:	0e 94 10 0b 	call	0x1620	; 0x1620 <sin>
     722:	20 e0       	ldi	r18, 0x00	; 0
     724:	30 e0       	ldi	r19, 0x00	; 0
     726:	40 e8       	ldi	r20, 0x80	; 128
     728:	5f e3       	ldi	r21, 0x3F	; 63
     72a:	0e 94 e4 07 	call	0xfc8	; 0xfc8 <__addsf3>
     72e:	69 87       	std	Y+9, r22	; 0x09
     730:	7a 87       	std	Y+10, r23	; 0x0a
     732:	8b 87       	std	Y+11, r24	; 0x0b
     734:	9c 87       	std	Y+12, r25	; 0x0c
	_Bool flash_on = now%(uint32_t)(1000/FLASH_RATE)   <   500/FLASH_RATE;
     736:	c7 01       	movw	r24, r14
     738:	b6 01       	movw	r22, r12
     73a:	24 ef       	ldi	r18, 0xF4	; 244
     73c:	31 e0       	ldi	r19, 0x01	; 1
     73e:	40 e0       	ldi	r20, 0x00	; 0
     740:	50 e0       	ldi	r21, 0x00	; 0
     742:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <__udivmodsi4>
     746:	0e 94 30 09 	call	0x1260	; 0x1260 <__floatunsisf>
     74a:	20 e0       	ldi	r18, 0x00	; 0
     74c:	30 e0       	ldi	r19, 0x00	; 0
     74e:	4a e7       	ldi	r20, 0x7A	; 122
     750:	53 e4       	ldi	r21, 0x43	; 67
     752:	0e 94 50 08 	call	0x10a0	; 0x10a0 <__cmpsf2>
     756:	88 1f       	adc	r24, r24
     758:	88 27       	eor	r24, r24
     75a:	88 1f       	adc	r24, r24
     75c:	8f 83       	std	Y+7, r24	; 0x07
	_Bool ping_on = now%(uint32_t)(1000/PING_RATE)   <   1000*FLASH_TIME;
     75e:	c7 01       	movw	r24, r14
     760:	b6 01       	movw	r22, r12
     762:	28 e8       	ldi	r18, 0x88	; 136
     764:	33 e1       	ldi	r19, 0x13	; 19
     766:	40 e0       	ldi	r20, 0x00	; 0
     768:	50 e0       	ldi	r21, 0x00	; 0
     76a:	0e 94 79 0b 	call	0x16f2	; 0x16f2 <__udivmodsi4>
     76e:	0e 94 30 09 	call	0x1260	; 0x1260 <__floatunsisf>
     772:	20 e0       	ldi	r18, 0x00	; 0
     774:	30 e0       	ldi	r19, 0x00	; 0
     776:	48 ec       	ldi	r20, 0xC8	; 200
     778:	52 e4       	ldi	r21, 0x42	; 66
     77a:	0e 94 50 08 	call	0x10a0	; 0x10a0 <__cmpsf2>
     77e:	88 1f       	adc	r24, r24
     780:	88 27       	eor	r24, r24
     782:	88 1f       	adc	r24, r24
     784:	01 e6       	ldi	r16, 0x61	; 97
     786:	18 e3       	ldi	r17, 0x38	; 56
     788:	9e 01       	movw	r18, r28
     78a:	2f 5f       	subi	r18, 0xFF	; 255
     78c:	3f 4f       	sbci	r19, 0xFF	; 255
     78e:	0f 2e       	mov	r0, r31
     790:	f9 e5       	ldi	r31, 0x59	; 89
     792:	4f 2e       	mov	r4, r31
     794:	f8 e3       	ldi	r31, 0x38	; 56
     796:	5f 2e       	mov	r5, r31
     798:	f0 2d       	mov	r31, r0
     79a:	0f 2e       	mov	r0, r31
     79c:	f5 e6       	ldi	r31, 0x65	; 101
     79e:	6f 2e       	mov	r6, r31
     7a0:	f8 e3       	ldi	r31, 0x38	; 56
     7a2:	7f 2e       	mov	r7, r31
     7a4:	f0 2d       	mov	r31, r0
     7a6:	19 01       	movw	r2, r18
			case SWING:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*sinValue, rgb_colors[i].green*sinValue, rgb_colors[i].blue*sinValue};
				break;
			case PING:
				// in the line below, fmin will either return 1 or 0, so each rgb color is either 0 or 255*PING_BRIGHTNESS
				rgb_colors[i] = (struct RGB_Color){255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].red)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].green)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].blue)*ping_on};
     7a8:	88 2e       	mov	r8, r24
     7aa:	91 2c       	mov	r9, r1
     7ac:	a1 2c       	mov	r10, r1
     7ae:	b1 2c       	mov	r11, r1
     7b0:	2d 87       	std	Y+13, r18	; 0x0d
     7b2:	3e 87       	std	Y+14, r19	; 0x0e
     7b4:	df 80       	ldd	r13, Y+7	; 0x07
     7b6:	f8 01       	movw	r30, r16
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 0 << TCA_SPLIT_ENABLE_bp; //Stop TCA
}

static struct RGB_Color tinyLED_enum_to_RGB_Color(enum Colors color){
	struct RGB_Color rgb_color;
	switch(color)
     7b8:	80 81       	ld	r24, Z
     7ba:	82 30       	cpi	r24, 0x02	; 2
     7bc:	a1 f0       	breq	.+40     	; 0x7e6 <tinyLED_update+0x10e>
     7be:	18 f4       	brcc	.+6      	; 0x7c6 <tinyLED_update+0xee>
     7c0:	81 30       	cpi	r24, 0x01	; 1
     7c2:	31 f0       	breq	.+12     	; 0x7d0 <tinyLED_update+0xf8>
     7c4:	21 c0       	rjmp	.+66     	; 0x808 <tinyLED_update+0x130>
     7c6:	83 30       	cpi	r24, 0x03	; 3
     7c8:	39 f0       	breq	.+14     	; 0x7d8 <tinyLED_update+0x100>
     7ca:	84 30       	cpi	r24, 0x04	; 4
     7cc:	99 f0       	breq	.+38     	; 0x7f4 <tinyLED_update+0x11c>
     7ce:	1c c0       	rjmp	.+56     	; 0x808 <tinyLED_update+0x130>
	{
		case OFF:
			rgb_color = (struct RGB_Color){0, 0, 0};
			break;
		case RED:
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 0, 0};
     7d0:	f1 2c       	mov	r15, r1
     7d2:	e1 2c       	mov	r14, r1
     7d4:	69 e1       	ldi	r22, 0x19	; 25
     7d6:	1b c0       	rjmp	.+54     	; 0x80e <tinyLED_update+0x136>
			break;
		case GREEN:
			rgb_color = (struct RGB_Color){0, 255*LED_BRIGHTNESS, 0};
     7d8:	f1 2c       	mov	r15, r1
     7da:	0f 2e       	mov	r0, r31
     7dc:	f9 e1       	ldi	r31, 0x19	; 25
     7de:	ef 2e       	mov	r14, r31
     7e0:	f0 2d       	mov	r31, r0
     7e2:	60 e0       	ldi	r22, 0x00	; 0
     7e4:	14 c0       	rjmp	.+40     	; 0x80e <tinyLED_update+0x136>
			break;
		case BLUE:
			rgb_color = (struct RGB_Color){0, 0, 255*LED_BRIGHTNESS};
     7e6:	0f 2e       	mov	r0, r31
     7e8:	f9 e1       	ldi	r31, 0x19	; 25
     7ea:	ff 2e       	mov	r15, r31
     7ec:	f0 2d       	mov	r31, r0
     7ee:	e1 2c       	mov	r14, r1
     7f0:	60 e0       	ldi	r22, 0x00	; 0
     7f2:	0d c0       	rjmp	.+26     	; 0x80e <tinyLED_update+0x136>
			// Should the /3 be there? This requires testing.
			// After testing, findings were that at 0.1 brightness, one would see the three LEDs instead of one white led
			// We try with /2 instead.
			// We find that the best results come from not dividing by anything. At leasts in the lower brightness settings, and that
			// is where we suspect it will be most of the time.
			rgb_color = (struct RGB_Color){255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS, 255*LED_BRIGHTNESS};
     7f4:	0f 2e       	mov	r0, r31
     7f6:	f9 e1       	ldi	r31, 0x19	; 25
     7f8:	ff 2e       	mov	r15, r31
     7fa:	f0 2d       	mov	r31, r0
     7fc:	0f 2e       	mov	r0, r31
     7fe:	f9 e1       	ldi	r31, 0x19	; 25
     800:	ef 2e       	mov	r14, r31
     802:	f0 2d       	mov	r31, r0
     804:	69 e1       	ldi	r22, 0x19	; 25
     806:	03 c0       	rjmp	.+6      	; 0x80e <tinyLED_update+0x136>
static struct RGB_Color tinyLED_enum_to_RGB_Color(enum Colors color){
	struct RGB_Color rgb_color;
	switch(color)
	{
		case OFF:
			rgb_color = (struct RGB_Color){0, 0, 0};
     808:	f1 2c       	mov	r15, r1
     80a:	e1 2c       	mov	r14, r1
     80c:	60 e0       	ldi	r22, 0x00	; 0
     80e:	2f 82       	std	Y+7, r2	; 0x07
     810:	38 86       	std	Y+8, r3	; 0x08
	
		
	for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
	{		
		// Convert enum to RGB_Color
		rgb_colors[i] = tinyLED_enum_to_RGB_Color(tinyLED_colors[i].color);
     812:	d1 01       	movw	r26, r2
     814:	6c 93       	st	X, r22
     816:	11 96       	adiw	r26, 0x01	; 1
     818:	ec 92       	st	X, r14
     81a:	11 97       	sbiw	r26, 0x01	; 1
     81c:	12 96       	adiw	r26, 0x02	; 2
     81e:	fc 92       	st	X, r15
			
		// Adjust colors according to mode
		switch(tinyLED_colors[i].mode)
     820:	81 81       	ldd	r24, Z+1	; 0x01
     822:	82 30       	cpi	r24, 0x02	; 2
     824:	d1 f0       	breq	.+52     	; 0x85a <tinyLED_update+0x182>
     826:	18 f4       	brcc	.+6      	; 0x82e <tinyLED_update+0x156>
     828:	81 30       	cpi	r24, 0x01	; 1
     82a:	41 f0       	breq	.+16     	; 0x83c <tinyLED_update+0x164>
     82c:	cd c0       	rjmp	.+410    	; 0x9c8 <tinyLED_update+0x2f0>
     82e:	83 30       	cpi	r24, 0x03	; 3
     830:	09 f4       	brne	.+2      	; 0x834 <tinyLED_update+0x15c>
     832:	44 c0       	rjmp	.+136    	; 0x8bc <tinyLED_update+0x1e4>
     834:	84 30       	cpi	r24, 0x04	; 4
     836:	09 f4       	brne	.+2      	; 0x83a <tinyLED_update+0x162>
     838:	bf c0       	rjmp	.+382    	; 0x9b8 <tinyLED_update+0x2e0>
     83a:	c6 c0       	rjmp	.+396    	; 0x9c8 <tinyLED_update+0x2f0>
		{
			case STABLE:
				break;
			case FLASH:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*flash_on, rgb_colors[i].green*flash_on, rgb_colors[i].blue*flash_on};
     83c:	d6 9e       	mul	r13, r22
     83e:	60 2d       	mov	r22, r0
     840:	11 24       	eor	r1, r1
     842:	ef 81       	ldd	r30, Y+7	; 0x07
     844:	f8 85       	ldd	r31, Y+8	; 0x08
     846:	60 83       	st	Z, r22
     848:	de 9c       	mul	r13, r14
     84a:	e0 2c       	mov	r14, r0
     84c:	11 24       	eor	r1, r1
     84e:	e1 82       	std	Z+1, r14	; 0x01
     850:	df 9c       	mul	r13, r15
     852:	f0 2c       	mov	r15, r0
     854:	11 24       	eor	r1, r1
     856:	f2 82       	std	Z+2, r15	; 0x02
				break;
     858:	b7 c0       	rjmp	.+366    	; 0x9c8 <tinyLED_update+0x2f0>
			case SWING:
				rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red*sinValue, rgb_colors[i].green*sinValue, rgb_colors[i].blue*sinValue};
     85a:	70 e0       	ldi	r23, 0x00	; 0
     85c:	80 e0       	ldi	r24, 0x00	; 0
     85e:	90 e0       	ldi	r25, 0x00	; 0
     860:	0e 94 32 09 	call	0x1264	; 0x1264 <__floatsisf>
     864:	29 85       	ldd	r18, Y+9	; 0x09
     866:	3a 85       	ldd	r19, Y+10	; 0x0a
     868:	4b 85       	ldd	r20, Y+11	; 0x0b
     86a:	5c 85       	ldd	r21, Y+12	; 0x0c
     86c:	0e 94 a3 0a 	call	0x1546	; 0x1546 <__mulsf3>
     870:	0e 94 01 09 	call	0x1202	; 0x1202 <__fixunssfsi>
     874:	d1 01       	movw	r26, r2
     876:	6c 93       	st	X, r22
     878:	6e 2d       	mov	r22, r14
     87a:	70 e0       	ldi	r23, 0x00	; 0
     87c:	80 e0       	ldi	r24, 0x00	; 0
     87e:	90 e0       	ldi	r25, 0x00	; 0
     880:	0e 94 32 09 	call	0x1264	; 0x1264 <__floatsisf>
     884:	29 85       	ldd	r18, Y+9	; 0x09
     886:	3a 85       	ldd	r19, Y+10	; 0x0a
     888:	4b 85       	ldd	r20, Y+11	; 0x0b
     88a:	5c 85       	ldd	r21, Y+12	; 0x0c
     88c:	0e 94 a3 0a 	call	0x1546	; 0x1546 <__mulsf3>
     890:	0e 94 01 09 	call	0x1202	; 0x1202 <__fixunssfsi>
     894:	f1 01       	movw	r30, r2
     896:	61 83       	std	Z+1, r22	; 0x01
     898:	6f 2d       	mov	r22, r15
     89a:	70 e0       	ldi	r23, 0x00	; 0
     89c:	80 e0       	ldi	r24, 0x00	; 0
     89e:	90 e0       	ldi	r25, 0x00	; 0
     8a0:	0e 94 32 09 	call	0x1264	; 0x1264 <__floatsisf>
     8a4:	29 85       	ldd	r18, Y+9	; 0x09
     8a6:	3a 85       	ldd	r19, Y+10	; 0x0a
     8a8:	4b 85       	ldd	r20, Y+11	; 0x0b
     8aa:	5c 85       	ldd	r21, Y+12	; 0x0c
     8ac:	0e 94 a3 0a 	call	0x1546	; 0x1546 <__mulsf3>
     8b0:	0e 94 01 09 	call	0x1202	; 0x1202 <__fixunssfsi>
     8b4:	d1 01       	movw	r26, r2
     8b6:	12 96       	adiw	r26, 0x02	; 2
     8b8:	6c 93       	st	X, r22
				break;
     8ba:	86 c0       	rjmp	.+268    	; 0x9c8 <tinyLED_update+0x2f0>
			case PING:
				// in the line below, fmin will either return 1 or 0, so each rgb color is either 0 or 255*PING_BRIGHTNESS
				rgb_colors[i] = (struct RGB_Color){255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].red)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].green)*ping_on, 255*PING_BRIGHTNESS*fmin(1,rgb_colors[i].blue)*ping_on};
     8bc:	70 e0       	ldi	r23, 0x00	; 0
     8be:	80 e0       	ldi	r24, 0x00	; 0
     8c0:	90 e0       	ldi	r25, 0x00	; 0
     8c2:	0e 94 30 09 	call	0x1260	; 0x1260 <__floatunsisf>
     8c6:	9b 01       	movw	r18, r22
     8c8:	ac 01       	movw	r20, r24
     8ca:	60 e0       	ldi	r22, 0x00	; 0
     8cc:	70 e0       	ldi	r23, 0x00	; 0
     8ce:	80 e8       	ldi	r24, 0x80	; 128
     8d0:	9f e3       	ldi	r25, 0x3F	; 63
     8d2:	0e 94 6d 09 	call	0x12da	; 0x12da <fmin>
     8d6:	6b 8b       	std	Y+19, r22	; 0x13
     8d8:	7c 8b       	std	Y+20, r23	; 0x14
     8da:	8d 8b       	std	Y+21, r24	; 0x15
     8dc:	9e 8b       	std	Y+22, r25	; 0x16
     8de:	c5 01       	movw	r24, r10
     8e0:	b4 01       	movw	r22, r8
     8e2:	0e 94 32 09 	call	0x1264	; 0x1264 <__floatsisf>
     8e6:	6f 87       	std	Y+15, r22	; 0x0f
     8e8:	78 8b       	std	Y+16, r23	; 0x10
     8ea:	89 8b       	std	Y+17, r24	; 0x11
     8ec:	9a 8b       	std	Y+18, r25	; 0x12
     8ee:	6e 2d       	mov	r22, r14
     8f0:	70 e0       	ldi	r23, 0x00	; 0
     8f2:	80 e0       	ldi	r24, 0x00	; 0
     8f4:	90 e0       	ldi	r25, 0x00	; 0
     8f6:	0e 94 30 09 	call	0x1260	; 0x1260 <__floatunsisf>
     8fa:	9b 01       	movw	r18, r22
     8fc:	ac 01       	movw	r20, r24
     8fe:	60 e0       	ldi	r22, 0x00	; 0
     900:	70 e0       	ldi	r23, 0x00	; 0
     902:	80 e8       	ldi	r24, 0x80	; 128
     904:	9f e3       	ldi	r25, 0x3F	; 63
     906:	0e 94 6d 09 	call	0x12da	; 0x12da <fmin>
     90a:	6f 8b       	std	Y+23, r22	; 0x17
     90c:	78 8f       	std	Y+24, r23	; 0x18
     90e:	89 8f       	std	Y+25, r24	; 0x19
     910:	9a 8f       	std	Y+26, r25	; 0x1a
     912:	6f 2d       	mov	r22, r15
     914:	70 e0       	ldi	r23, 0x00	; 0
     916:	80 e0       	ldi	r24, 0x00	; 0
     918:	90 e0       	ldi	r25, 0x00	; 0
     91a:	0e 94 30 09 	call	0x1260	; 0x1260 <__floatunsisf>
     91e:	9b 01       	movw	r18, r22
     920:	ac 01       	movw	r20, r24
     922:	60 e0       	ldi	r22, 0x00	; 0
     924:	70 e0       	ldi	r23, 0x00	; 0
     926:	80 e8       	ldi	r24, 0x80	; 128
     928:	9f e3       	ldi	r25, 0x3F	; 63
     92a:	0e 94 6d 09 	call	0x12da	; 0x12da <fmin>
     92e:	6b 8f       	std	Y+27, r22	; 0x1b
     930:	7c 8f       	std	Y+28, r23	; 0x1c
     932:	8d 8f       	std	Y+29, r24	; 0x1d
     934:	9e 8f       	std	Y+30, r25	; 0x1e
     936:	23 e3       	ldi	r18, 0x33	; 51
     938:	33 e3       	ldi	r19, 0x33	; 51
     93a:	43 ea       	ldi	r20, 0xA3	; 163
     93c:	50 e4       	ldi	r21, 0x40	; 64
     93e:	6b 89       	ldd	r22, Y+19	; 0x13
     940:	7c 89       	ldd	r23, Y+20	; 0x14
     942:	8d 89       	ldd	r24, Y+21	; 0x15
     944:	9e 89       	ldd	r25, Y+22	; 0x16
     946:	0e 94 a3 0a 	call	0x1546	; 0x1546 <__mulsf3>
     94a:	2f 85       	ldd	r18, Y+15	; 0x0f
     94c:	38 89       	ldd	r19, Y+16	; 0x10
     94e:	49 89       	ldd	r20, Y+17	; 0x11
     950:	5a 89       	ldd	r21, Y+18	; 0x12
     952:	0e 94 a3 0a 	call	0x1546	; 0x1546 <__mulsf3>
     956:	0e 94 01 09 	call	0x1202	; 0x1202 <__fixunssfsi>
     95a:	ef 81       	ldd	r30, Y+7	; 0x07
     95c:	f8 85       	ldd	r31, Y+8	; 0x08
     95e:	60 83       	st	Z, r22
     960:	23 e3       	ldi	r18, 0x33	; 51
     962:	33 e3       	ldi	r19, 0x33	; 51
     964:	43 ea       	ldi	r20, 0xA3	; 163
     966:	50 e4       	ldi	r21, 0x40	; 64
     968:	6f 89       	ldd	r22, Y+23	; 0x17
     96a:	78 8d       	ldd	r23, Y+24	; 0x18
     96c:	89 8d       	ldd	r24, Y+25	; 0x19
     96e:	9a 8d       	ldd	r25, Y+26	; 0x1a
     970:	0e 94 a3 0a 	call	0x1546	; 0x1546 <__mulsf3>
     974:	2f 85       	ldd	r18, Y+15	; 0x0f
     976:	38 89       	ldd	r19, Y+16	; 0x10
     978:	49 89       	ldd	r20, Y+17	; 0x11
     97a:	5a 89       	ldd	r21, Y+18	; 0x12
     97c:	0e 94 a3 0a 	call	0x1546	; 0x1546 <__mulsf3>
     980:	0e 94 01 09 	call	0x1202	; 0x1202 <__fixunssfsi>
     984:	af 81       	ldd	r26, Y+7	; 0x07
     986:	b8 85       	ldd	r27, Y+8	; 0x08
     988:	11 96       	adiw	r26, 0x01	; 1
     98a:	6c 93       	st	X, r22
     98c:	23 e3       	ldi	r18, 0x33	; 51
     98e:	33 e3       	ldi	r19, 0x33	; 51
     990:	43 ea       	ldi	r20, 0xA3	; 163
     992:	50 e4       	ldi	r21, 0x40	; 64
     994:	6b 8d       	ldd	r22, Y+27	; 0x1b
     996:	7c 8d       	ldd	r23, Y+28	; 0x1c
     998:	8d 8d       	ldd	r24, Y+29	; 0x1d
     99a:	9e 8d       	ldd	r25, Y+30	; 0x1e
     99c:	0e 94 a3 0a 	call	0x1546	; 0x1546 <__mulsf3>
     9a0:	2f 85       	ldd	r18, Y+15	; 0x0f
     9a2:	38 89       	ldd	r19, Y+16	; 0x10
     9a4:	49 89       	ldd	r20, Y+17	; 0x11
     9a6:	5a 89       	ldd	r21, Y+18	; 0x12
     9a8:	0e 94 a3 0a 	call	0x1546	; 0x1546 <__mulsf3>
     9ac:	0e 94 01 09 	call	0x1202	; 0x1202 <__fixunssfsi>
     9b0:	ef 81       	ldd	r30, Y+7	; 0x07
     9b2:	f8 85       	ldd	r31, Y+8	; 0x08
     9b4:	62 83       	std	Z+2, r22	; 0x02
				break;
     9b6:	08 c0       	rjmp	.+16     	; 0x9c8 <tinyLED_update+0x2f0>
			case FLASH_ONCE:
				if(tinyLED_flash_once_time[i]>0){
     9b8:	d2 01       	movw	r26, r4
     9ba:	8c 91       	ld	r24, X
     9bc:	88 23       	and	r24, r24
     9be:	19 f0       	breq	.+6      	; 0x9c6 <tinyLED_update+0x2ee>
					rgb_colors[i] = (struct RGB_Color){rgb_colors[i].red, rgb_colors[i].green, rgb_colors[i].blue};
					tinyLED_flash_once_time[i]--;
     9c0:	81 50       	subi	r24, 0x01	; 1
     9c2:	8c 93       	st	X, r24
     9c4:	01 c0       	rjmp	.+2      	; 0x9c8 <tinyLED_update+0x2f0>
				}
				else{
					tinyLED_colors[i].color = OFF;
     9c6:	10 82       	st	Z, r1
     9c8:	0e 5f       	subi	r16, 0xFE	; 254
     9ca:	1f 4f       	sbci	r17, 0xFF	; 255
     9cc:	b3 e0       	ldi	r27, 0x03	; 3
     9ce:	2b 0e       	add	r2, r27
     9d0:	31 1c       	adc	r3, r1
     9d2:	ef ef       	ldi	r30, 0xFF	; 255
     9d4:	4e 1a       	sub	r4, r30
     9d6:	5e 0a       	sbc	r5, r30
	_Bool flash_on = now%(uint32_t)(1000/FLASH_RATE)   <   500/FLASH_RATE;
	_Bool ping_on = now%(uint32_t)(1000/PING_RATE)   <   1000*FLASH_TIME;
	struct RGB_Color rgb_colors[NUMBER_OF_LEDS];
	
		
	for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
     9d8:	06 15       	cp	r16, r6
     9da:	17 05       	cpc	r17, r7
     9dc:	09 f0       	breq	.+2      	; 0x9e0 <tinyLED_update+0x308>
     9de:	eb ce       	rjmp	.-554    	; 0x7b6 <tinyLED_update+0xde>
     9e0:	cd 84       	ldd	r12, Y+13	; 0x0d
     9e2:	de 84       	ldd	r13, Y+14	; 0x0e
				break;
		}
	}
	
	// We only write to the LEDs if there is something to change. (In SWING mode, we update the LEDs every cycle)
	if(!tinyLED_RGB_Color_Compare(&rgb_colors, &tinyLED_old_colors)){
     9e4:	6b e5       	ldi	r22, 0x5B	; 91
     9e6:	78 e3       	ldi	r23, 0x38	; 56
     9e8:	ce 01       	movw	r24, r28
     9ea:	01 96       	adiw	r24, 0x01	; 1
     9ec:	0e 94 3c 03 	call	0x678	; 0x678 <tinyLED_RGB_Color_Compare>
     9f0:	81 11       	cpse	r24, r1
     9f2:	2f c0       	rjmp	.+94     	; 0xa52 <tinyLED_update+0x37a>
     9f4:	0b e5       	ldi	r16, 0x5B	; 91
     9f6:	18 e3       	ldi	r17, 0x38	; 56
     9f8:	7e 01       	movw	r14, r28
     9fa:	f7 e0       	ldi	r31, 0x07	; 7
     9fc:	ef 0e       	add	r14, r31
     9fe:	f1 1c       	adc	r15, r1
		for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
		{
			// Write to LEDs
			//For some reason, the data-bus to the LEDs is serialized as GRB
			//which means the 24-bit data-bus will look like [Green[0:7], Red[0:7], Blue[0:7]]
			tinyLED_SPIWriteByte(rgb_colors[i].green);
     a00:	d6 01       	movw	r26, r12
     a02:	11 96       	adiw	r26, 0x01	; 1
     a04:	8c 91       	ld	r24, X
     a06:	0e 94 07 03 	call	0x60e	; 0x60e <tinyLED_SPIWriteByte>
			tinyLED_SPIWriteByte(rgb_colors[i].red);
     a0a:	f6 01       	movw	r30, r12
     a0c:	80 81       	ld	r24, Z
     a0e:	0e 94 07 03 	call	0x60e	; 0x60e <tinyLED_SPIWriteByte>
			tinyLED_SPIWriteByte(rgb_colors[i].blue);
     a12:	d6 01       	movw	r26, r12
     a14:	12 96       	adiw	r26, 0x02	; 2
     a16:	8c 91       	ld	r24, X
     a18:	0e 94 07 03 	call	0x60e	; 0x60e <tinyLED_SPIWriteByte>
			tinyLED_old_colors[i] = rgb_colors[i];
     a1c:	f6 01       	movw	r30, r12
     a1e:	81 91       	ld	r24, Z+
     a20:	91 91       	ld	r25, Z+
     a22:	a1 91       	ld	r26, Z+
     a24:	6f 01       	movw	r12, r30
     a26:	f8 01       	movw	r30, r16
     a28:	81 93       	st	Z+, r24
     a2a:	91 93       	st	Z+, r25
     a2c:	a1 93       	st	Z+, r26
     a2e:	8f 01       	movw	r16, r30
		}
	}
	
	// We only write to the LEDs if there is something to change. (In SWING mode, we update the LEDs every cycle)
	if(!tinyLED_RGB_Color_Compare(&rgb_colors, &tinyLED_old_colors)){
		for (uint8_t i = 0; i < NUMBER_OF_LEDS; i++)
     a30:	ce 14       	cp	r12, r14
     a32:	df 04       	cpc	r13, r15
     a34:	29 f7       	brne	.-54     	; 0xa00 <tinyLED_update+0x328>
			tinyLED_SPIWriteByte(rgb_colors[i].green);
			tinyLED_SPIWriteByte(rgb_colors[i].red);
			tinyLED_SPIWriteByte(rgb_colors[i].blue);
			tinyLED_old_colors[i] = rgb_colors[i];
	}
		tinyDebugger_send_uint8("LED1 color", tinyLED_colors[0].color);
     a36:	01 e6       	ldi	r16, 0x61	; 97
     a38:	18 e3       	ldi	r17, 0x38	; 56
     a3a:	d8 01       	movw	r26, r16
     a3c:	6c 91       	ld	r22, X
     a3e:	8f e3       	ldi	r24, 0x3F	; 63
     a40:	97 e9       	ldi	r25, 0x97	; 151
     a42:	0e 94 05 02 	call	0x40a	; 0x40a <tinyDebugger_send_uint8>
		tinyDebugger_send_uint8("LED2 color", tinyLED_colors[1].color);
     a46:	f8 01       	movw	r30, r16
     a48:	62 81       	ldd	r22, Z+2	; 0x02
     a4a:	8a e4       	ldi	r24, 0x4A	; 74
     a4c:	97 e9       	ldi	r25, 0x97	; 151
     a4e:	0e 94 05 02 	call	0x40a	; 0x40a <tinyDebugger_send_uint8>
	}
}
     a52:	6e 96       	adiw	r28, 0x1e	; 30
     a54:	cd bf       	out	0x3d, r28	; 61
     a56:	de bf       	out	0x3e, r29	; 62
     a58:	df 91       	pop	r29
     a5a:	cf 91       	pop	r28
     a5c:	1f 91       	pop	r17
     a5e:	0f 91       	pop	r16
     a60:	ff 90       	pop	r15
     a62:	ef 90       	pop	r14
     a64:	df 90       	pop	r13
     a66:	cf 90       	pop	r12
     a68:	bf 90       	pop	r11
     a6a:	af 90       	pop	r10
     a6c:	9f 90       	pop	r9
     a6e:	8f 90       	pop	r8
     a70:	7f 90       	pop	r7
     a72:	6f 90       	pop	r6
     a74:	5f 90       	pop	r5
     a76:	4f 90       	pop	r4
     a78:	3f 90       	pop	r3
     a7a:	2f 90       	pop	r2
     a7c:	08 95       	ret

00000a7e <tinyAxon_add_pulse>:
{
	// We want to check each slot in the pulse_queue, and
	// if we find an empty slot (0), we add a pulse.
	for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
	{
		if(pulse_queue[i] == 0){
     a7e:	20 91 29 38 	lds	r18, 0x3829	; 0x803829 <pulse_queue>
     a82:	30 91 2a 38 	lds	r19, 0x382A	; 0x80382a <pulse_queue+0x1>
     a86:	23 2b       	or	r18, r19
     a88:	51 f0       	breq	.+20     	; 0xa9e <tinyAxon_add_pulse+0x20>
     a8a:	eb e2       	ldi	r30, 0x2B	; 43
     a8c:	f8 e3       	ldi	r31, 0x38	; 56
     a8e:	21 e0       	ldi	r18, 0x01	; 1
     a90:	30 e0       	ldi	r19, 0x00	; 0
     a92:	b9 01       	movw	r22, r18
     a94:	41 91       	ld	r20, Z+
     a96:	51 91       	ld	r21, Z+
     a98:	45 2b       	or	r20, r21
     a9a:	81 f4       	brne	.+32     	; 0xabc <tinyAxon_add_pulse+0x3e>
     a9c:	02 c0       	rjmp	.+4      	; 0xaa2 <tinyAxon_add_pulse+0x24>
     a9e:	60 e0       	ldi	r22, 0x00	; 0
     aa0:	70 e0       	ldi	r23, 0x00	; 0
			pulse_queue[i] = new_pulse;
     aa2:	66 0f       	add	r22, r22
     aa4:	77 1f       	adc	r23, r23
     aa6:	fb 01       	movw	r30, r22
     aa8:	e7 5d       	subi	r30, 0xD7	; 215
     aaa:	f7 4c       	sbci	r31, 0xC7	; 199
     aac:	80 83       	st	Z, r24
     aae:	91 83       	std	Z+1, r25	; 0x01
			pulses_in_queue++;
     ab0:	80 91 3d 38 	lds	r24, 0x383D	; 0x80383d <pulses_in_queue>
     ab4:	8f 5f       	subi	r24, 0xFF	; 255
     ab6:	80 93 3d 38 	sts	0x383D, r24	; 0x80383d <pulses_in_queue>
			// We return so we only ever add one
			break;
     aba:	08 95       	ret
     abc:	2f 5f       	subi	r18, 0xFF	; 255
     abe:	3f 4f       	sbci	r19, 0xFF	; 255
*/
static void tinyAxon_add_pulse(uint16_t new_pulse)
{
	// We want to check each slot in the pulse_queue, and
	// if we find an empty slot (0), we add a pulse.
	for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
     ac0:	2a 30       	cpi	r18, 0x0A	; 10
     ac2:	31 05       	cpc	r19, r1
     ac4:	31 f7       	brne	.-52     	; 0xa92 <tinyAxon_add_pulse+0x14>
     ac6:	08 95       	ret

00000ac8 <find_newest_pulse>:
uint8_t find_newest_pulse() {
	uint16_t max;
	uint8_t current_index = 0;
	uint8_t return_index = 0;
	
	max = pulse_queue[current_index];
     ac8:	40 91 29 38 	lds	r20, 0x3829	; 0x803829 <pulse_queue>
     acc:	50 91 2a 38 	lds	r21, 0x382A	; 0x80382a <pulse_queue+0x1>
     ad0:	eb e2       	ldi	r30, 0x2B	; 43
     ad2:	f8 e3       	ldi	r31, 0x38	; 56
	
// This function will be used with pulse_queue to find the newest pulse
uint8_t find_newest_pulse() {
	uint16_t max;
	uint8_t current_index = 0;
	uint8_t return_index = 0;
     ad4:	80 e0       	ldi	r24, 0x00	; 0
	
	max = pulse_queue[current_index];
	
	for (current_index = 1; current_index < MAX_NUMBER_OF_PULSES; current_index++) {
     ad6:	91 e0       	ldi	r25, 0x01	; 1
		if (pulse_queue[current_index] > max) {
     ad8:	21 91       	ld	r18, Z+
     ada:	31 91       	ld	r19, Z+
     adc:	42 17       	cp	r20, r18
     ade:	53 07       	cpc	r21, r19
     ae0:	10 f4       	brcc	.+4      	; 0xae6 <find_newest_pulse+0x1e>
     ae2:	89 2f       	mov	r24, r25
			return_index = current_index;
			max = pulse_queue[current_index];
     ae4:	a9 01       	movw	r20, r18
	uint8_t current_index = 0;
	uint8_t return_index = 0;
	
	max = pulse_queue[current_index];
	
	for (current_index = 1; current_index < MAX_NUMBER_OF_PULSES; current_index++) {
     ae6:	9f 5f       	subi	r25, 0xFF	; 255
     ae8:	9a 30       	cpi	r25, 0x0A	; 10
     aea:	b1 f7       	brne	.-20     	; 0xad8 <find_newest_pulse+0x10>
			return_index = current_index;
			max = pulse_queue[current_index];
		}
	}
	return return_index;
}
     aec:	08 95       	ret

00000aee <tinyAxon_remove_pulse>:

/*
If the potential is very low, we want to try to remove a pulse.
*/
bool tinyAxon_remove_pulse(void)
{
     aee:	cf 93       	push	r28
	// We want to return a bool indicating whether or not a pulse actually was removed.
	if(pulses_in_queue == 0){
     af0:	c0 91 3d 38 	lds	r28, 0x383D	; 0x80383d <pulses_in_queue>
     af4:	cc 23       	and	r28, r28
     af6:	c9 f0       	breq	.+50     	; 0xb2a <tinyAxon_remove_pulse+0x3c>
		//There was no pulse to remove.
		return false;
	}
	else{
		// If we are to remove a pulse, we want to remove the one that will fire last.
		uint8_t pulse_index = find_newest_pulse();
     af8:	0e 94 64 05 	call	0xac8	; 0xac8 <find_newest_pulse>
		uint16_t newest_pulse = pulse_queue[pulse_index];
     afc:	90 e0       	ldi	r25, 0x00	; 0
     afe:	fc 01       	movw	r30, r24
     b00:	ee 0f       	add	r30, r30
     b02:	ff 1f       	adc	r31, r31
     b04:	e7 5d       	subi	r30, 0xD7	; 215
     b06:	f7 4c       	sbci	r31, 0xC7	; 199
	
		// Now we want to check if the pulse is too far away to be affected by the low potential, or close enough that we decide to remove it.
		// (When we say that the pulse is too far away, it refers to the biological process of how the potential spreads from Dendrites to axon).
		if(newest_pulse > PULSE_NO_RETURN_TIME){
     b08:	20 81       	ld	r18, Z
     b0a:	31 81       	ldd	r19, Z+1	; 0x01
     b0c:	2d 33       	cpi	r18, 0x3D	; 61
     b0e:	31 05       	cpc	r19, r1
     b10:	70 f0       	brcs	.+28     	; 0xb2e <tinyAxon_remove_pulse+0x40>
			// We decided to remove the pulse
			pulse_queue[pulse_index] = 0;
     b12:	88 0f       	add	r24, r24
     b14:	99 1f       	adc	r25, r25
     b16:	fc 01       	movw	r30, r24
     b18:	e7 5d       	subi	r30, 0xD7	; 215
     b1a:	f7 4c       	sbci	r31, 0xC7	; 199
     b1c:	10 82       	st	Z, r1
     b1e:	11 82       	std	Z+1, r1	; 0x01
			pulses_in_queue--;
     b20:	c1 50       	subi	r28, 0x01	; 1
     b22:	c0 93 3d 38 	sts	0x383D, r28	; 0x80383d <pulses_in_queue>
			return true;
     b26:	81 e0       	ldi	r24, 0x01	; 1
     b28:	03 c0       	rjmp	.+6      	; 0xb30 <tinyAxon_remove_pulse+0x42>
bool tinyAxon_remove_pulse(void)
{
	// We want to return a bool indicating whether or not a pulse actually was removed.
	if(pulses_in_queue == 0){
		//There was no pulse to remove.
		return false;
     b2a:	80 e0       	ldi	r24, 0x00	; 0
     b2c:	01 c0       	rjmp	.+2      	; 0xb30 <tinyAxon_remove_pulse+0x42>
			pulses_in_queue--;
			return true;
		}
		// Here we have found that there is a pulse queued, but it is old enough to let pass anyway, so now we need to put it back into the queue.
		else{
			return false;
     b2e:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     b30:	cf 91       	pop	r28
     b32:	08 95       	ret

00000b34 <tinyAxon_update_potential>:
/*
Decides whether or not the axon should fire
If the axon does fire, the potential is reduced
*/
double tinyAxon_update_potential(double potential)
{	
     b34:	cf 92       	push	r12
     b36:	df 92       	push	r13
     b38:	ef 92       	push	r14
     b3a:	ff 92       	push	r15
     b3c:	6b 01       	movw	r12, r22
     b3e:	7c 01       	movw	r14, r24
	//While the neuron has enough potential to fire, we want to fire more
	while (potential > THRESHOLD_POTENTIAL)
     b40:	20 e0       	ldi	r18, 0x00	; 0
     b42:	30 e0       	ldi	r19, 0x00	; 0
     b44:	48 ec       	ldi	r20, 0xC8	; 200
     b46:	51 e4       	ldi	r21, 0x41	; 65
     b48:	0e 94 28 0a 	call	0x1450	; 0x1450 <__gesf2>
     b4c:	18 16       	cp	r1, r24
     b4e:	bc f5       	brge	.+110    	; 0xbbe <tinyAxon_update_potential+0x8a>
	{
		// We have to check if there are already queued pulses, so that the frequency never exceeds FIRE_DELAY
		if(pulses_in_queue>0){
     b50:	80 91 3d 38 	lds	r24, 0x383D	; 0x80383d <pulses_in_queue>
     b54:	88 23       	and	r24, r24
     b56:	b1 f0       	breq	.+44     	; 0xb84 <tinyAxon_update_potential+0x50>
			uint16_t newest_pulse = pulse_queue[find_newest_pulse()];
     b58:	0e 94 64 05 	call	0xac8	; 0xac8 <find_newest_pulse>
     b5c:	e8 2f       	mov	r30, r24
     b5e:	f0 e0       	ldi	r31, 0x00	; 0
     b60:	ee 0f       	add	r30, r30
     b62:	ff 1f       	adc	r31, r31
     b64:	e7 5d       	subi	r30, 0xD7	; 215
     b66:	f7 4c       	sbci	r31, 0xC7	; 199
			
			// There is at least one pulse in the queue, and it is so close, that we need to offset the new pulse, so that we keep at least
			// one FIRE_DELAY between each pulse
			if(newest_pulse + FIRE_DELAY > TRAVLE_DELAY){
     b68:	80 81       	ld	r24, Z
     b6a:	91 81       	ldd	r25, Z+1	; 0x01
     b6c:	c2 96       	adiw	r24, 0x32	; 50
     b6e:	85 36       	cpi	r24, 0x65	; 101
     b70:	91 05       	cpc	r25, r1
     b72:	18 f0       	brcs	.+6      	; 0xb7a <tinyAxon_update_potential+0x46>
				tinyAxon_add_pulse(newest_pulse + FIRE_DELAY);
     b74:	0e 94 3f 05 	call	0xa7e	; 0xa7e <tinyAxon_add_pulse>
     b78:	09 c0       	rjmp	.+18     	; 0xb8c <tinyAxon_update_potential+0x58>
			}
			// There is at least one pulse in the queue, but it's far enough away to ignore
			else{
				tinyAxon_add_pulse(TRAVLE_DELAY);
     b7a:	84 e6       	ldi	r24, 0x64	; 100
     b7c:	90 e0       	ldi	r25, 0x00	; 0
     b7e:	0e 94 3f 05 	call	0xa7e	; 0xa7e <tinyAxon_add_pulse>
     b82:	04 c0       	rjmp	.+8      	; 0xb8c <tinyAxon_update_potential+0x58>
			}
		}
		// There are no pulses in the queue, so we add a pulse as normal
		else{
			tinyAxon_add_pulse(TRAVLE_DELAY);		
     b84:	84 e6       	ldi	r24, 0x64	; 100
     b86:	90 e0       	ldi	r25, 0x00	; 0
     b88:	0e 94 3f 05 	call	0xa7e	; 0xa7e <tinyAxon_add_pulse>
		}
		
		potential += POSTFIRE_POTENTIAL_REACTION; // This is usually defined as a negative value, don't be confused by the +=
     b8c:	20 e0       	ldi	r18, 0x00	; 0
     b8e:	30 e0       	ldi	r19, 0x00	; 0
     b90:	40 ef       	ldi	r20, 0xF0	; 240
     b92:	51 e4       	ldi	r21, 0x41	; 65
     b94:	c7 01       	movw	r24, r14
     b96:	b6 01       	movw	r22, r12
     b98:	0e 94 e3 07 	call	0xfc6	; 0xfc6 <__subsf3>
     b9c:	6b 01       	movw	r12, r22
     b9e:	7c 01       	movw	r14, r24
		
		tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
     ba0:	44 e0       	ldi	r20, 0x04	; 4
     ba2:	63 e0       	ldi	r22, 0x03	; 3
     ba4:	81 e0       	ldi	r24, 0x01	; 1
     ba6:	0e 94 2c 03 	call	0x658	; 0x658 <tinyLED_set_color_mode>
If the axon does fire, the potential is reduced
*/
double tinyAxon_update_potential(double potential)
{	
	//While the neuron has enough potential to fire, we want to fire more
	while (potential > THRESHOLD_POTENTIAL)
     baa:	20 e0       	ldi	r18, 0x00	; 0
     bac:	30 e0       	ldi	r19, 0x00	; 0
     bae:	48 ec       	ldi	r20, 0xC8	; 200
     bb0:	51 e4       	ldi	r21, 0x41	; 65
     bb2:	c7 01       	movw	r24, r14
     bb4:	b6 01       	movw	r22, r12
     bb6:	0e 94 28 0a 	call	0x1450	; 0x1450 <__gesf2>
     bba:	18 16       	cp	r1, r24
     bbc:	4c f2       	brlt	.-110    	; 0xb50 <tinyAxon_update_potential+0x1c>
		
		tinyLED_set_color_mode(INN_LED, GREEN, FLASH_ONCE);
	}
	
	// If the neuron has a very low potential, we want to remove a pulse from the queue (if there is one)
	if(potential < -THRESHOLD_POTENTIAL && pulses_in_queue > 0) // Perhaps this should be a separate variable? For now, we will just simply use -THRESHOLD_POTENTIAL
     bbe:	20 e0       	ldi	r18, 0x00	; 0
     bc0:	30 e0       	ldi	r19, 0x00	; 0
     bc2:	48 ec       	ldi	r20, 0xC8	; 200
     bc4:	51 ec       	ldi	r21, 0xC1	; 193
     bc6:	c7 01       	movw	r24, r14
     bc8:	b6 01       	movw	r22, r12
     bca:	0e 94 50 08 	call	0x10a0	; 0x10a0 <__cmpsf2>
     bce:	88 23       	and	r24, r24
     bd0:	0c f0       	brlt	.+2      	; 0xbd4 <tinyAxon_update_potential+0xa0>
     bd2:	4b c0       	rjmp	.+150    	; 0xc6a <tinyAxon_update_potential+0x136>
     bd4:	80 91 3d 38 	lds	r24, 0x383D	; 0x80383d <pulses_in_queue>
     bd8:	88 23       	and	r24, r24
     bda:	19 f1       	breq	.+70     	; 0xc22 <tinyAxon_update_potential+0xee>
	{
		// The neurons potential is low enough to attempt to remove a queued fire (Fire less)
		if(tinyAxon_remove_pulse())
     bdc:	0e 94 77 05 	call	0xaee	; 0xaee <tinyAxon_remove_pulse>
     be0:	88 23       	and	r24, r24
     be2:	09 f4       	brne	.+2      	; 0xbe6 <tinyAxon_update_potential+0xb2>
     be4:	42 c0       	rjmp	.+132    	; 0xc6a <tinyAxon_update_potential+0x136>
		{
			// The potential has evened out a bit
			potential += THRESHOLD_POTENTIAL;
     be6:	20 e0       	ldi	r18, 0x00	; 0
     be8:	30 e0       	ldi	r19, 0x00	; 0
     bea:	48 ec       	ldi	r20, 0xC8	; 200
     bec:	51 e4       	ldi	r21, 0x41	; 65
     bee:	c7 01       	movw	r24, r14
     bf0:	b6 01       	movw	r22, r12
     bf2:	0e 94 e4 07 	call	0xfc8	; 0xfc8 <__addsf3>
     bf6:	6b 01       	movw	r12, r22
     bf8:	7c 01       	movw	r14, r24
     bfa:	37 c0       	rjmp	.+110    	; 0xc6a <tinyAxon_update_potential+0x136>
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
	{
		for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
		{
			if(pulse_queue[i] != 0){
     bfc:	80 81       	ld	r24, Z
     bfe:	91 81       	ldd	r25, Z+1	; 0x01
     c00:	00 97       	sbiw	r24, 0x00	; 0
     c02:	39 f0       	breq	.+14     	; 0xc12 <tinyAxon_update_potential+0xde>
				pulse_queue[i]--;
     c04:	01 97       	sbiw	r24, 0x01	; 1
     c06:	80 83       	st	Z, r24
     c08:	91 83       	std	Z+1, r25	; 0x01
				
				// If the time went from 1 to 0, we fire the axon
				if(pulse_queue[i] == 0){
     c0a:	89 2b       	or	r24, r25
     c0c:	11 f4       	brne	.+4      	; 0xc12 <tinyAxon_update_potential+0xde>
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
	pulses_in_queue--;
     c0e:	41 50       	subi	r20, 0x01	; 1
Function to set firing.
Function also updates the pulse queue accordingly.
*/
static void tinyAxon_fire_pulse()
{
	tinyAxon_should_fire = true;
     c10:	51 e0       	ldi	r21, 0x01	; 1
     c12:	32 96       	adiw	r30, 0x02	; 2
	}
	
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
	{
		for (uint8_t i = 0; i<MAX_NUMBER_OF_PULSES; i++)
     c14:	e2 17       	cp	r30, r18
     c16:	f3 07       	cpc	r31, r19
     c18:	89 f7       	brne	.-30     	; 0xbfc <tinyAxon_update_potential+0xc8>
     c1a:	50 93 3e 38 	sts	0x383E, r21	; 0x80383e <tinyAxon_should_fire>
     c1e:	40 93 3d 38 	sts	0x383D, r20	; 0x80383d <pulses_in_queue>
The function should set the DAC to fire for two
update cycles once the pulse flag is set high.
*/
static void tinyAxon_update_pulse_transmitter(void)
{
	if (tinyAxon_should_fire)
     c22:	80 91 3e 38 	lds	r24, 0x383E	; 0x80383e <tinyAxon_should_fire>
     c26:	88 23       	and	r24, r24
     c28:	91 f0       	breq	.+36     	; 0xc4e <tinyAxon_update_potential+0x11a>
	{
		tinyAxon_should_fire = false;
     c2a:	10 92 3e 38 	sts	0x383E, r1	; 0x80383e <tinyAxon_should_fire>
		tinyAxon_has_fired = true;
     c2e:	81 e0       	ldi	r24, 0x01	; 1
     c30:	80 93 3f 38 	sts	0x383F, r24	; 0x80383f <tinyAxon_has_fired>
*/
static void tinyAxon_start_sending_pulse()
{
	if (NEURONTYPE == EXCITATORY_NEURON)
	{
		DAC_set_output(EXCITATORY_NEURON_OUTPUT);
     c34:	8f ef       	ldi	r24, 0xFF	; 255
     c36:	90 e0       	ldi	r25, 0x00	; 0
     c38:	0e 94 c7 00 	call	0x18e	; 0x18e <DAC_set_output>
		axonOutputValue=EXCITATORY_NEURON_OUTPUT;
     c3c:	8f ef       	ldi	r24, 0xFF	; 255
     c3e:	80 93 28 38 	sts	0x3828, r24	; 0x803828 <axonOutputValue>
	{
		DAC_set_output(INHIBITORY_NEURON_OUTPUT);
		axonOutputValue=INHIBITORY_NEURON_OUTPUT;
	}
	
	tinyLED_set_color_mode(OUT_LED, WHITE, FLASH_ONCE);
     c42:	44 e0       	ldi	r20, 0x04	; 4
     c44:	64 e0       	ldi	r22, 0x04	; 4
     c46:	80 e0       	ldi	r24, 0x00	; 0
     c48:	0e 94 2c 03 	call	0x658	; 0x658 <tinyLED_set_color_mode>
     c4c:	19 c0       	rjmp	.+50     	; 0xc80 <tinyAxon_update_potential+0x14c>
		tinyAxon_should_fire = false;
		tinyAxon_has_fired = true;
		
		tinyAxon_start_sending_pulse();
	}
	else if (tinyAxon_has_fired)
     c4e:	80 91 3f 38 	lds	r24, 0x383F	; 0x80383f <tinyAxon_has_fired>
     c52:	88 23       	and	r24, r24
     c54:	19 f0       	breq	.+6      	; 0xc5c <tinyAxon_update_potential+0x128>
	{
		tinyAxon_has_fired = false;
     c56:	10 92 3f 38 	sts	0x383F, r1	; 0x80383f <tinyAxon_has_fired>
     c5a:	12 c0       	rjmp	.+36     	; 0xc80 <tinyAxon_update_potential+0x14c>
	tinyLED_set_color_mode(OUT_LED, WHITE, FLASH_ONCE);
}

static void tinyAxon_stop_sending_pulse()
{
	DAC_set_output(NO_SIGNAL_OUTPUT);
     c5c:	80 e0       	ldi	r24, 0x00	; 0
     c5e:	90 e0       	ldi	r25, 0x00	; 0
     c60:	0e 94 c7 00 	call	0x18e	; 0x18e <DAC_set_output>
	axonOutputValue=NO_SIGNAL_OUTPUT;
     c64:	10 92 28 38 	sts	0x3828, r1	; 0x803828 <axonOutputValue>
     c68:	0b c0       	rjmp	.+22     	; 0xc80 <tinyAxon_update_potential+0x14c>
			potential += THRESHOLD_POTENTIAL;
		}
	}
	
	// If there are pulses in the queue, we want to reduce the time in each of the pulse_queue elements
	if (pulses_in_queue > 0)
     c6a:	40 91 3d 38 	lds	r20, 0x383D	; 0x80383d <pulses_in_queue>
     c6e:	44 23       	and	r20, r20
     c70:	c1 f2       	breq	.-80     	; 0xc22 <tinyAxon_update_potential+0xee>
     c72:	50 91 3e 38 	lds	r21, 0x383E	; 0x80383e <tinyAxon_should_fire>
     c76:	e9 e2       	ldi	r30, 0x29	; 41
     c78:	f8 e3       	ldi	r31, 0x38	; 56
     c7a:	2d e3       	ldi	r18, 0x3D	; 61
     c7c:	38 e3       	ldi	r19, 0x38	; 56
     c7e:	be cf       	rjmp	.-132    	; 0xbfc <tinyAxon_update_potential+0xc8>
 *
 * Reads the level on pins connected to a port
 */
static inline bool PORTB_get_pin_level(const uint8_t pin)
{
	return VPORTB.IN & (1 << pin);
     c80:	86 b1       	in	r24, 0x06	; 6
	// We need to check if the axon is connected to a charger. We do this by checking the AXON_CHECK_PIN. If it is hight while the axon is not firing, it must be connected to a charger
	if(AXON_CHECK_PIN_get_level() && !tinyAxon_should_fire){
		//tinyCharge_set_charging_mode(true);
	}
	
	tinyDebugger_send_uint8("Axon", axonOutputValue);
     c82:	60 91 28 38 	lds	r22, 0x3828	; 0x803828 <axonOutputValue>
     c86:	85 e5       	ldi	r24, 0x55	; 85
     c88:	97 e9       	ldi	r25, 0x97	; 151
     c8a:	0e 94 05 02 	call	0x40a	; 0x40a <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("Pulses", pulses_in_queue);
     c8e:	60 91 3d 38 	lds	r22, 0x383D	; 0x80383d <pulses_in_queue>
     c92:	8a e5       	ldi	r24, 0x5A	; 90
     c94:	97 e9       	ldi	r25, 0x97	; 151
     c96:	0e 94 05 02 	call	0x40a	; 0x40a <tinyDebugger_send_uint8>
	
	return potential;
}
     c9a:	c7 01       	movw	r24, r14
     c9c:	b6 01       	movw	r22, r12
     c9e:	ff 90       	pop	r15
     ca0:	ef 90       	pop	r14
     ca2:	df 90       	pop	r13
     ca4:	cf 90       	pop	r12
     ca6:	08 95       	ret

00000ca8 <tinyDendrite_update_signals>:
/*
This function converts the 8 bit value from the ADC into one of the signal types defined in DendriteSignal
We also update the charging state
*/
void tinyDendrite_update_signals(void)
{
     ca8:	af 92       	push	r10
     caa:	bf 92       	push	r11
     cac:	cf 92       	push	r12
     cae:	df 92       	push	r13
     cb0:	ef 92       	push	r14
     cb2:	ff 92       	push	r15
     cb4:	0f 93       	push	r16
     cb6:	1f 93       	push	r17
     cb8:	cf 93       	push	r28
     cba:	df 93       	push	r29
     cbc:	c1 e1       	ldi	r28, 0x11	; 17
     cbe:	d8 e3       	ldi	r29, 0x38	; 56
     cc0:	0a e4       	ldi	r16, 0x4A	; 74
     cc2:	18 e3       	ldi	r17, 0x38	; 56
     cc4:	0f 2e       	mov	r0, r31
     cc6:	f6 e1       	ldi	r31, 0x16	; 22
     cc8:	cf 2e       	mov	r12, r31
     cca:	f8 e3       	ldi	r31, 0x38	; 56
     ccc:	df 2e       	mov	r13, r31
     cce:	f0 2d       	mov	r31, r0
     cd0:	78 01       	movw	r14, r16
*/
static void tinyDendrite_read_signals(void)
{
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_values[i] = ADC_get_conversion(Dendrite_ports[i]);
     cd2:	89 91       	ld	r24, Y+
     cd4:	0e 94 8c 00 	call	0x118	; 0x118 <ADC_get_conversion>
     cd8:	d7 01       	movw	r26, r14
     cda:	8d 93       	st	X+, r24
     cdc:	7d 01       	movw	r14, r26
/*
This function reads the voltage at the Dendrite inputs with the ADC
*/
static void tinyDendrite_read_signals(void)
{
	for (int i = 0; i < TINYDENDRITE_COUNT; i++)
     cde:	cc 15       	cp	r28, r12
     ce0:	dd 05       	cpc	r29, r13
     ce2:	b9 f7       	brne	.-18     	; 0xcd2 <tinyDendrite_update_signals+0x2a>
	{
		tinyDendrite_values[i] = ADC_get_conversion(Dendrite_ports[i]);
	}
	tinyDebugger_send_uint8("D1", tinyDendrite_values[0]);
     ce4:	ca e4       	ldi	r28, 0x4A	; 74
     ce6:	d8 e3       	ldi	r29, 0x38	; 56
     ce8:	68 81       	ld	r22, Y
     cea:	81 e6       	ldi	r24, 0x61	; 97
     cec:	97 e9       	ldi	r25, 0x97	; 151
     cee:	0e 94 05 02 	call	0x40a	; 0x40a <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D2", tinyDendrite_values[1]);
     cf2:	69 81       	ldd	r22, Y+1	; 0x01
     cf4:	84 e6       	ldi	r24, 0x64	; 100
     cf6:	97 e9       	ldi	r25, 0x97	; 151
     cf8:	0e 94 05 02 	call	0x40a	; 0x40a <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D3", tinyDendrite_values[2]);
     cfc:	6a 81       	ldd	r22, Y+2	; 0x02
     cfe:	87 e6       	ldi	r24, 0x67	; 103
     d00:	97 e9       	ldi	r25, 0x97	; 151
     d02:	0e 94 05 02 	call	0x40a	; 0x40a <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D4", tinyDendrite_values[3]);
     d06:	6b 81       	ldd	r22, Y+3	; 0x03
     d08:	8a e6       	ldi	r24, 0x6A	; 106
     d0a:	97 e9       	ldi	r25, 0x97	; 151
     d0c:	0e 94 05 02 	call	0x40a	; 0x40a <tinyDebugger_send_uint8>
	tinyDebugger_send_uint8("D5", tinyDendrite_values[4]);
     d10:	6c 81       	ldd	r22, Y+4	; 0x04
     d12:	8d e6       	ldi	r24, 0x6D	; 109
     d14:	97 e9       	ldi	r25, 0x97	; 151
     d16:	0e 94 05 02 	call	0x40a	; 0x40a <tinyDebugger_send_uint8>
     d1a:	e5 e4       	ldi	r30, 0x45	; 69
     d1c:	f8 e3       	ldi	r31, 0x38	; 56
     d1e:	c0 e4       	ldi	r28, 0x40	; 64
     d20:	d8 e3       	ldi	r29, 0x38	; 56
     d22:	4a e4       	ldi	r20, 0x4A	; 74
     d24:	58 e3       	ldi	r21, 0x38	; 56
{
	
	//Read the analog voltage values on each of the Dendrites
	tinyDendrite_read_signals();
	
	_Bool charging = false;
     d26:	80 e0       	ldi	r24, 0x00	; 0
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     d28:	31 e0       	ldi	r19, 0x01	; 1
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
		}
		else if (tinyDendrite_values[i] > HIGH_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
     d2a:	0f 2e       	mov	r0, r31
     d2c:	f3 e0       	ldi	r31, 0x03	; 3
     d2e:	cf 2e       	mov	r12, r31
     d30:	f0 2d       	mov	r31, r0
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     d32:	68 94       	set
     d34:	dd 24       	eor	r13, r13
     d36:	d1 f8       	bld	r13, 1
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     d38:	68 94       	set
     d3a:	ee 24       	eor	r14, r14
     d3c:	e2 f8       	bld	r14, 2
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     d3e:	0f 2e       	mov	r0, r31
     d40:	f6 e0       	ldi	r31, 0x06	; 6
     d42:	ff 2e       	mov	r15, r31
     d44:	f0 2d       	mov	r31, r0
			tinyDendrite_current_signals[i] = CHARGING;
			charging = true;
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     d46:	75 e0       	ldi	r23, 0x05	; 5
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
		{
			tinyDendrite_current_signals[i] = CHARGING;
     d48:	67 e0       	ldi	r22, 0x07	; 7
     d4a:	5f 01       	movw	r10, r30
	
	_Bool charging = false;
	
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		tinyDendrite_previous_signals[i] = tinyDendrite_current_signals[i];
     d4c:	90 81       	ld	r25, Z
     d4e:	99 93       	st	Y+, r25
		if (tinyDendrite_values[i] > CHARGING_THRESHOLD)
     d50:	d8 01       	movw	r26, r16
     d52:	2d 91       	ld	r18, X+
     d54:	8d 01       	movw	r16, r26
     d56:	29 3e       	cpi	r18, 0xE9	; 233
     d58:	18 f0       	brcs	.+6      	; 0xd60 <tinyDendrite_update_signals+0xb8>
		{
			tinyDendrite_current_signals[i] = CHARGING;
     d5a:	60 83       	st	Z, r22
			charging = true;
     d5c:	83 2f       	mov	r24, r19
     d5e:	19 c0       	rjmp	.+50     	; 0xd92 <tinyDendrite_update_signals+0xea>
		}
		else if (tinyDendrite_values[i] > NORMAL_EXCITE_THRESHOLD)
     d60:	28 3c       	cpi	r18, 0xC8	; 200
     d62:	10 f0       	brcs	.+4      	; 0xd68 <tinyDendrite_update_signals+0xc0>
		{
			tinyDendrite_current_signals[i] = NORMAL_EXCITE;
     d64:	70 83       	st	Z, r23
     d66:	15 c0       	rjmp	.+42     	; 0xd92 <tinyDendrite_update_signals+0xea>
		}
		else if (tinyDendrite_values[i] > HIGH_EXCITE_THRESHOLD)
     d68:	27 3a       	cpi	r18, 0xA7	; 167
     d6a:	10 f0       	brcs	.+4      	; 0xd70 <tinyDendrite_update_signals+0xc8>
		{
			tinyDendrite_current_signals[i] = HIGH_EXCITE;
     d6c:	f0 82       	st	Z, r15
     d6e:	11 c0       	rjmp	.+34     	; 0xd92 <tinyDendrite_update_signals+0xea>
		}
		else if (tinyDendrite_values[i] > LOW_EXCITE_THRESHOLD)
     d70:	25 38       	cpi	r18, 0x85	; 133
     d72:	10 f0       	brcs	.+4      	; 0xd78 <tinyDendrite_update_signals+0xd0>
		{
			tinyDendrite_current_signals[i] = LOW_EXCITE;
     d74:	e0 82       	st	Z, r14
     d76:	0d c0       	rjmp	.+26     	; 0xd92 <tinyDendrite_update_signals+0xea>
		}
		else if (tinyDendrite_values[i] > NORMAL_INHIB_THRESHOLD)
     d78:	24 36       	cpi	r18, 0x64	; 100
     d7a:	10 f0       	brcs	.+4      	; 0xd80 <tinyDendrite_update_signals+0xd8>
		{
			tinyDendrite_current_signals[i] = NORMAL_INHIB;
     d7c:	d0 82       	st	Z, r13
     d7e:	09 c0       	rjmp	.+18     	; 0xd92 <tinyDendrite_update_signals+0xea>
		}
		else if (tinyDendrite_values[i] > HIGH_INHIB_THRESHOLD)
     d80:	23 34       	cpi	r18, 0x43	; 67
     d82:	10 f0       	brcs	.+4      	; 0xd88 <tinyDendrite_update_signals+0xe0>
		{
			tinyDendrite_current_signals[i] = HIGH_INHIB;
     d84:	c0 82       	st	Z, r12
     d86:	05 c0       	rjmp	.+10     	; 0xd92 <tinyDendrite_update_signals+0xea>
		}
		else if (tinyDendrite_values[i] > LOW_INHIB_THRESHOLD)
     d88:	22 32       	cpi	r18, 0x22	; 34
     d8a:	10 f0       	brcs	.+4      	; 0xd90 <tinyDendrite_update_signals+0xe8>
		{
			tinyDendrite_current_signals[i] = LOW_INHIB;
     d8c:	30 83       	st	Z, r19
     d8e:	01 c0       	rjmp	.+2      	; 0xd92 <tinyDendrite_update_signals+0xea>
		}
		else
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     d90:	10 82       	st	Z, r1
		}
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
     d92:	d5 01       	movw	r26, r10
     d94:	2c 91       	ld	r18, X
     d96:	92 13       	cpse	r25, r18
     d98:	01 c0       	rjmp	.+2      	; 0xd9c <tinyDendrite_update_signals+0xf4>
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
     d9a:	1c 92       	st	X, r1
     d9c:	31 96       	adiw	r30, 0x01	; 1
	//Read the analog voltage values on each of the Dendrites
	tinyDendrite_read_signals();
	
	_Bool charging = false;
	
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
     d9e:	e4 17       	cp	r30, r20
     da0:	f5 07       	cpc	r31, r21
     da2:	99 f6       	brne	.-90     	; 0xd4a <tinyDendrite_update_signals+0xa2>
		if (tinyDendrite_current_signals[i] == tinyDendrite_previous_signals[i])
		{
			tinyDendrite_current_signals[i] = NO_SIGNAL;
		}
	}
	tinyCharge_set_charging_mode(charging);
     da4:	0e 94 f3 01 	call	0x3e6	; 0x3e6 <tinyCharge_set_charging_mode>
}
     da8:	df 91       	pop	r29
     daa:	cf 91       	pop	r28
     dac:	1f 91       	pop	r17
     dae:	0f 91       	pop	r16
     db0:	ff 90       	pop	r15
     db2:	ef 90       	pop	r14
     db4:	df 90       	pop	r13
     db6:	cf 90       	pop	r12
     db8:	bf 90       	pop	r11
     dba:	af 90       	pop	r10
     dbc:	08 95       	ret

00000dbe <tinyDendrite_get_potential>:
outside. It uses the previously declared functions to return the potential.
*/
int16_t tinyDendrite_get_potential()
{
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
     dbe:	0e 94 54 06 	call	0xca8	; 0xca8 <tinyDendrite_update_signals>
     dc2:	e5 e4       	ldi	r30, 0x45	; 69
     dc4:	f8 e3       	ldi	r31, 0x38	; 56
     dc6:	4a e4       	ldi	r20, 0x4A	; 74
     dc8:	58 e3       	ldi	r21, 0x38	; 56
	
	int16_t return_potential_val = 0;
     dca:	20 e0       	ldi	r18, 0x00	; 0
     dcc:	30 e0       	ldi	r19, 0x00	; 0
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
	{
		switch(tinyDendrite_current_signals[i])
     dce:	91 91       	ld	r25, Z+
     dd0:	93 30       	cpi	r25, 0x03	; 3
     dd2:	a1 f0       	breq	.+40     	; 0xdfc <tinyDendrite_get_potential+0x3e>
     dd4:	28 f4       	brcc	.+10     	; 0xde0 <tinyDendrite_get_potential+0x22>
     dd6:	91 30       	cpi	r25, 0x01	; 1
     dd8:	b9 f0       	breq	.+46     	; 0xe08 <tinyDendrite_get_potential+0x4a>
     dda:	92 30       	cpi	r25, 0x02	; 2
     ddc:	91 f0       	breq	.+36     	; 0xe02 <tinyDendrite_get_potential+0x44>
     dde:	16 c0       	rjmp	.+44     	; 0xe0c <tinyDendrite_get_potential+0x4e>
     de0:	95 30       	cpi	r25, 0x05	; 5
     de2:	31 f0       	breq	.+12     	; 0xdf0 <tinyDendrite_get_potential+0x32>
     de4:	40 f0       	brcs	.+16     	; 0xdf6 <tinyDendrite_get_potential+0x38>
     de6:	96 30       	cpi	r25, 0x06	; 6
     de8:	89 f4       	brne	.+34     	; 0xe0c <tinyDendrite_get_potential+0x4e>
		{
			case NO_SIGNAL:
				return_potential_val += NO_SIGNAL_REACTION;
				break;
			case HIGH_EXCITE:
				return_potential_val += HIGH_EXCITE_REACTION;
     dea:	2c 5c       	subi	r18, 0xCC	; 204
     dec:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     dee:	0e c0       	rjmp	.+28     	; 0xe0c <tinyDendrite_get_potential+0x4e>
			case NORMAL_EXCITE:
				return_potential_val += NORMAL_EXCITE_REACTION;
     df0:	26 5e       	subi	r18, 0xE6	; 230
     df2:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     df4:	0b c0       	rjmp	.+22     	; 0xe0c <tinyDendrite_get_potential+0x4e>
			case LOW_EXCITE:
				return_potential_val += LOW_EXCITE_REACTION;
     df6:	2c 5e       	subi	r18, 0xEC	; 236
     df8:	3f 4f       	sbci	r19, 0xFF	; 255
				break;
     dfa:	08 c0       	rjmp	.+16     	; 0xe0c <tinyDendrite_get_potential+0x4e>
			case HIGH_INHIB:
				return_potential_val += HIGH_INHIB_REACTION;
     dfc:	22 53       	subi	r18, 0x32	; 50
     dfe:	31 09       	sbc	r19, r1
				break;
     e00:	05 c0       	rjmp	.+10     	; 0xe0c <tinyDendrite_get_potential+0x4e>
			case NORMAL_INHIB:
				return_potential_val += NORMAL_INHIB_REACTION;
     e02:	2a 51       	subi	r18, 0x1A	; 26
     e04:	31 09       	sbc	r19, r1
				break;
     e06:	02 c0       	rjmp	.+4      	; 0xe0c <tinyDendrite_get_potential+0x4e>
			case LOW_INHIB:
				return_potential_val += LOW_INHIB_REACTION;
     e08:	24 51       	subi	r18, 0x14	; 20
     e0a:	31 09       	sbc	r19, r1
{
	//Convert the digital value to the various signals defined in DendriteSignalType
	tinyDendrite_update_signals();
	
	int16_t return_potential_val = 0;
	for (uint8_t i = 0; i < TINYDENDRITE_COUNT; i++)
     e0c:	e4 17       	cp	r30, r20
     e0e:	f5 07       	cpc	r31, r21
     e10:	f1 f6       	brne	.-68     	; 0xdce <tinyDendrite_get_potential+0x10>
			default:
				break;
		}
	}
	return return_potential_val;
}
     e12:	c9 01       	movw	r24, r18
     e14:	08 95       	ret

00000e16 <tinyDendrite_update_potential>:

double tinyDendrite_update_potential(double potential){
     e16:	cf 92       	push	r12
     e18:	df 92       	push	r13
     e1a:	ef 92       	push	r14
     e1c:	ff 92       	push	r15
     e1e:	6b 01       	movw	r12, r22
     e20:	7c 01       	movw	r14, r24
	
	int16_t potential_change = tinyDendrite_get_potential();
     e22:	0e 94 df 06 	call	0xdbe	; 0xdbe <tinyDendrite_get_potential>
	potential += potential_change;
	return potential;
     e26:	bc 01       	movw	r22, r24
     e28:	99 0f       	add	r25, r25
     e2a:	88 0b       	sbc	r24, r24
     e2c:	99 0b       	sbc	r25, r25
     e2e:	0e 94 32 09 	call	0x1264	; 0x1264 <__floatsisf>
     e32:	a7 01       	movw	r20, r14
     e34:	96 01       	movw	r18, r12
     e36:	0e 94 e4 07 	call	0xfc8	; 0xfc8 <__addsf3>
     e3a:	ff 90       	pop	r15
     e3c:	ef 90       	pop	r14
     e3e:	df 90       	pop	r13
     e40:	cf 90       	pop	r12
     e42:	08 95       	ret

00000e44 <__vector_6>:
This function is called every time the RTC (Real Time Clock) counter overflows.
With the current settings, it will be called every ms.
The RTC clock runs at 1kHz, and the number of cycles before overflow is set with RTC.PER = someHexValue (e.g. 0x20) in src/rtc.c
*/
ISR(RTC_CNT_vect)
{
     e44:	1f 92       	push	r1
     e46:	0f 92       	push	r0
     e48:	0f b6       	in	r0, 0x3f	; 63
     e4a:	0f 92       	push	r0
     e4c:	11 24       	eor	r1, r1
     e4e:	2f 93       	push	r18
     e50:	3f 93       	push	r19
     e52:	4f 93       	push	r20
     e54:	5f 93       	push	r21
     e56:	6f 93       	push	r22
     e58:	7f 93       	push	r23
     e5a:	8f 93       	push	r24
     e5c:	9f 93       	push	r25
     e5e:	af 93       	push	r26
     e60:	bf 93       	push	r27
     e62:	cf 93       	push	r28
     e64:	ef 93       	push	r30
     e66:	ff 93       	push	r31
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     e68:	c1 e0       	ldi	r28, 0x01	; 1
     e6a:	c0 93 4f 38 	sts	0x384F, r28	; 0x80384f <tinyISR_interrupt_flag>
{
	// Set flag to let main loop run a new cycle
	tinyISR_setflag(true);
	
	// Timer counter incrementation
	tinyTime_counter_increment();
     e6e:	0e 94 4f 02 	call	0x49e	; 0x49e <tinyTime_counter_increment>

	/* Overflow interrupt flag has to be cleared manually */
	RTC.INTFLAGS = RTC_OVF_bm;
     e72:	c0 93 43 01 	sts	0x0143, r28	; 0x800143 <__TEXT_REGION_LENGTH__+0x700143>
}
     e76:	ff 91       	pop	r31
     e78:	ef 91       	pop	r30
     e7a:	cf 91       	pop	r28
     e7c:	bf 91       	pop	r27
     e7e:	af 91       	pop	r26
     e80:	9f 91       	pop	r25
     e82:	8f 91       	pop	r24
     e84:	7f 91       	pop	r23
     e86:	6f 91       	pop	r22
     e88:	5f 91       	pop	r21
     e8a:	4f 91       	pop	r20
     e8c:	3f 91       	pop	r19
     e8e:	2f 91       	pop	r18
     e90:	0f 90       	pop	r0
     e92:	0f be       	out	0x3f, r0	; 63
     e94:	0f 90       	pop	r0
     e96:	1f 90       	pop	r1
     e98:	18 95       	reti

00000e9a <tinyISR_setflag>:
static _Bool tinyISR_interrupt_flag = false;


void tinyISR_setflag(_Bool new_flag_val)
{
	tinyISR_interrupt_flag = new_flag_val;
     e9a:	80 93 4f 38 	sts	0x384F, r24	; 0x80384f <tinyISR_interrupt_flag>
     e9e:	08 95       	ret

00000ea0 <tinyISR_getflag>:
}

_Bool tinyISR_getflag(void)
{
	return tinyISR_interrupt_flag;
}
     ea0:	80 91 4f 38 	lds	r24, 0x384F	; 0x80384f <tinyISR_interrupt_flag>
     ea4:	08 95       	ret

00000ea6 <tinyPotential_update>:

/*
Update the potential
*/
void tinyPotential_update()
{
     ea6:	cf 92       	push	r12
     ea8:	df 92       	push	r13
     eaa:	ef 92       	push	r14
     eac:	ff 92       	push	r15
Function to decay the potential towards 0
*/
static void tinyPotential_decay()
{
		
	uint8_t time_since_last_update = tinyTime_now() - previous_update_time;
     eae:	0e 94 63 02 	call	0x4c6	; 0x4c6 <tinyTime_now>
	tinyPotential_potential *= (exp(-((float)time_since_last_update/(float)TINYPOTENTIAL_TIME_CONST)));
     eb2:	80 91 50 38 	lds	r24, 0x3850	; 0x803850 <previous_update_time>
     eb6:	68 1b       	sub	r22, r24
     eb8:	70 e0       	ldi	r23, 0x00	; 0
     eba:	80 e0       	ldi	r24, 0x00	; 0
     ebc:	90 e0       	ldi	r25, 0x00	; 0
     ebe:	0e 94 30 09 	call	0x1260	; 0x1260 <__floatunsisf>
     ec2:	20 e0       	ldi	r18, 0x00	; 0
     ec4:	30 e0       	ldi	r19, 0x00	; 0
     ec6:	48 ec       	ldi	r20, 0xC8	; 200
     ec8:	52 e4       	ldi	r21, 0x42	; 66
     eca:	0e 94 55 08 	call	0x10aa	; 0x10aa <__divsf3>
     ece:	90 58       	subi	r25, 0x80	; 128
     ed0:	0e 94 cf 08 	call	0x119e	; 0x119e <exp>
     ed4:	20 91 54 38 	lds	r18, 0x3854	; 0x803854 <tinyPotential_potential>
     ed8:	30 91 55 38 	lds	r19, 0x3855	; 0x803855 <tinyPotential_potential+0x1>
     edc:	40 91 56 38 	lds	r20, 0x3856	; 0x803856 <tinyPotential_potential+0x2>
     ee0:	50 91 57 38 	lds	r21, 0x3857	; 0x803857 <tinyPotential_potential+0x3>
     ee4:	0e 94 a3 0a 	call	0x1546	; 0x1546 <__mulsf3>
     ee8:	6b 01       	movw	r12, r22
     eea:	7c 01       	movw	r14, r24
	if(fabs(tinyPotential_potential)<0.1){
     eec:	9f 77       	andi	r25, 0x7F	; 127
     eee:	2d ec       	ldi	r18, 0xCD	; 205
     ef0:	3c ec       	ldi	r19, 0xCC	; 204
     ef2:	4c ec       	ldi	r20, 0xCC	; 204
     ef4:	5d e3       	ldi	r21, 0x3D	; 61
     ef6:	0e 94 50 08 	call	0x10a0	; 0x10a0 <__cmpsf2>
     efa:	88 23       	and	r24, r24
     efc:	4c f0       	brlt	.+18     	; 0xf10 <tinyPotential_update+0x6a>
*/
static void tinyPotential_decay()
{
		
	uint8_t time_since_last_update = tinyTime_now() - previous_update_time;
	tinyPotential_potential *= (exp(-((float)time_since_last_update/(float)TINYPOTENTIAL_TIME_CONST)));
     efe:	c0 92 54 38 	sts	0x3854, r12	; 0x803854 <tinyPotential_potential>
     f02:	d0 92 55 38 	sts	0x3855, r13	; 0x803855 <tinyPotential_potential+0x1>
     f06:	e0 92 56 38 	sts	0x3856, r14	; 0x803856 <tinyPotential_potential+0x2>
     f0a:	f0 92 57 38 	sts	0x3857, r15	; 0x803857 <tinyPotential_potential+0x3>
     f0e:	08 c0       	rjmp	.+16     	; 0xf20 <tinyPotential_update+0x7a>
	if(fabs(tinyPotential_potential)<0.1){
		tinyPotential_potential=0;
     f10:	10 92 54 38 	sts	0x3854, r1	; 0x803854 <tinyPotential_potential>
     f14:	10 92 55 38 	sts	0x3855, r1	; 0x803855 <tinyPotential_potential+0x1>
     f18:	10 92 56 38 	sts	0x3856, r1	; 0x803856 <tinyPotential_potential+0x2>
     f1c:	10 92 57 38 	sts	0x3857, r1	; 0x803857 <tinyPotential_potential+0x3>
	}
	previous_update_time = tinyTime_now();
     f20:	0e 94 63 02 	call	0x4c6	; 0x4c6 <tinyTime_now>
     f24:	60 93 50 38 	sts	0x3850, r22	; 0x803850 <previous_update_time>
     f28:	70 93 51 38 	sts	0x3851, r23	; 0x803851 <previous_update_time+0x1>
     f2c:	80 93 52 38 	sts	0x3852, r24	; 0x803852 <previous_update_time+0x2>
     f30:	90 93 53 38 	sts	0x3853, r25	; 0x803853 <previous_update_time+0x3>
void tinyPotential_update()
{
	//Some of the potential in the neuron has decayed away
	tinyPotential_decay();
	// Update potential with values from Dendrites
	tinyPotential_potential = tinyDendrite_update_potential(tinyPotential_potential);
     f34:	60 91 54 38 	lds	r22, 0x3854	; 0x803854 <tinyPotential_potential>
     f38:	70 91 55 38 	lds	r23, 0x3855	; 0x803855 <tinyPotential_potential+0x1>
     f3c:	80 91 56 38 	lds	r24, 0x3856	; 0x803856 <tinyPotential_potential+0x2>
     f40:	90 91 57 38 	lds	r25, 0x3857	; 0x803857 <tinyPotential_potential+0x3>
     f44:	0e 94 0b 07 	call	0xe16	; 0xe16 <tinyDendrite_update_potential>
     f48:	ab 01       	movw	r20, r22
     f4a:	bc 01       	movw	r22, r24
     f4c:	40 93 54 38 	sts	0x3854, r20	; 0x803854 <tinyPotential_potential>
     f50:	50 93 55 38 	sts	0x3855, r21	; 0x803855 <tinyPotential_potential+0x1>
     f54:	60 93 56 38 	sts	0x3856, r22	; 0x803856 <tinyPotential_potential+0x2>
     f58:	70 93 57 38 	sts	0x3857, r23	; 0x803857 <tinyPotential_potential+0x3>
	tinyDebugger_send_double("DendP", tinyPotential_potential);
     f5c:	80 e7       	ldi	r24, 0x70	; 112
     f5e:	97 e9       	ldi	r25, 0x97	; 151
     f60:	0e 94 06 02 	call	0x40c	; 0x40c <tinyDebugger_send_double>
	
	// Update potential from button press
	tinyPotential_potential = tinyButton_update_potential(tinyPotential_potential);
     f64:	60 91 54 38 	lds	r22, 0x3854	; 0x803854 <tinyPotential_potential>
     f68:	70 91 55 38 	lds	r23, 0x3855	; 0x803855 <tinyPotential_potential+0x1>
     f6c:	80 91 56 38 	lds	r24, 0x3856	; 0x803856 <tinyPotential_potential+0x2>
     f70:	90 91 57 38 	lds	r25, 0x3857	; 0x803857 <tinyPotential_potential+0x3>
     f74:	0e 94 fc 02 	call	0x5f8	; 0x5f8 <tinyButton_update_potential>
     f78:	60 93 54 38 	sts	0x3854, r22	; 0x803854 <tinyPotential_potential>
     f7c:	70 93 55 38 	sts	0x3855, r23	; 0x803855 <tinyPotential_potential+0x1>
     f80:	80 93 56 38 	sts	0x3856, r24	; 0x803856 <tinyPotential_potential+0x2>
     f84:	90 93 57 38 	sts	0x3857, r25	; 0x803857 <tinyPotential_potential+0x3>
	
	// Update potential with values from spontaneous pulse.
	tinyPotential_potential = tinyPulse_update_potential(tinyPotential_potential);
     f88:	0e 94 17 02 	call	0x42e	; 0x42e <tinyPulse_update_potential>
     f8c:	60 93 54 38 	sts	0x3854, r22	; 0x803854 <tinyPotential_potential>
     f90:	70 93 55 38 	sts	0x3855, r23	; 0x803855 <tinyPotential_potential+0x1>
     f94:	80 93 56 38 	sts	0x3856, r24	; 0x803856 <tinyPotential_potential+0x2>
     f98:	90 93 57 38 	sts	0x3857, r25	; 0x803857 <tinyPotential_potential+0x3>
	
	// Let the axon affect the potential
	// This is also where we decide whether or not the axon should fire
	tinyPotential_potential = tinyAxon_update_potential(tinyPotential_potential);
     f9c:	0e 94 9a 05 	call	0xb34	; 0xb34 <tinyAxon_update_potential>
     fa0:	ab 01       	movw	r20, r22
     fa2:	bc 01       	movw	r22, r24
     fa4:	40 93 54 38 	sts	0x3854, r20	; 0x803854 <tinyPotential_potential>
     fa8:	50 93 55 38 	sts	0x3855, r21	; 0x803855 <tinyPotential_potential+0x1>
     fac:	60 93 56 38 	sts	0x3856, r22	; 0x803856 <tinyPotential_potential+0x2>
     fb0:	70 93 57 38 	sts	0x3857, r23	; 0x803857 <tinyPotential_potential+0x3>
	tinyDebugger_send_double("AxonP", tinyPotential_potential);
     fb4:	86 e7       	ldi	r24, 0x76	; 118
     fb6:	97 e9       	ldi	r25, 0x97	; 151
     fb8:	0e 94 06 02 	call	0x40c	; 0x40c <tinyDebugger_send_double>
}
     fbc:	ff 90       	pop	r15
     fbe:	ef 90       	pop	r14
     fc0:	df 90       	pop	r13
     fc2:	cf 90       	pop	r12
     fc4:	08 95       	ret

00000fc6 <__subsf3>:
     fc6:	50 58       	subi	r21, 0x80	; 128

00000fc8 <__addsf3>:
     fc8:	bb 27       	eor	r27, r27
     fca:	aa 27       	eor	r26, r26
     fcc:	0e 94 fb 07 	call	0xff6	; 0xff6 <__addsf3x>
     fd0:	0c 94 ee 09 	jmp	0x13dc	; 0x13dc <__fp_round>
     fd4:	0e 94 e0 09 	call	0x13c0	; 0x13c0 <__fp_pscA>
     fd8:	38 f0       	brcs	.+14     	; 0xfe8 <__addsf3+0x20>
     fda:	0e 94 e7 09 	call	0x13ce	; 0x13ce <__fp_pscB>
     fde:	20 f0       	brcs	.+8      	; 0xfe8 <__addsf3+0x20>
     fe0:	39 f4       	brne	.+14     	; 0xff0 <__addsf3+0x28>
     fe2:	9f 3f       	cpi	r25, 0xFF	; 255
     fe4:	19 f4       	brne	.+6      	; 0xfec <__addsf3+0x24>
     fe6:	26 f4       	brtc	.+8      	; 0xff0 <__addsf3+0x28>
     fe8:	0c 94 b6 09 	jmp	0x136c	; 0x136c <__fp_nan>
     fec:	0e f4       	brtc	.+2      	; 0xff0 <__addsf3+0x28>
     fee:	e0 95       	com	r30
     ff0:	e7 fb       	bst	r30, 7
     ff2:	0c 94 b0 09 	jmp	0x1360	; 0x1360 <__fp_inf>

00000ff6 <__addsf3x>:
     ff6:	e9 2f       	mov	r30, r25
     ff8:	0e 94 ff 09 	call	0x13fe	; 0x13fe <__fp_split3>
     ffc:	58 f3       	brcs	.-42     	; 0xfd4 <__addsf3+0xc>
     ffe:	ba 17       	cp	r27, r26
    1000:	62 07       	cpc	r22, r18
    1002:	73 07       	cpc	r23, r19
    1004:	84 07       	cpc	r24, r20
    1006:	95 07       	cpc	r25, r21
    1008:	20 f0       	brcs	.+8      	; 0x1012 <__addsf3x+0x1c>
    100a:	79 f4       	brne	.+30     	; 0x102a <__addsf3x+0x34>
    100c:	a6 f5       	brtc	.+104    	; 0x1076 <__addsf3x+0x80>
    100e:	0c 94 21 0a 	jmp	0x1442	; 0x1442 <__fp_zero>
    1012:	0e f4       	brtc	.+2      	; 0x1016 <__addsf3x+0x20>
    1014:	e0 95       	com	r30
    1016:	0b 2e       	mov	r0, r27
    1018:	ba 2f       	mov	r27, r26
    101a:	a0 2d       	mov	r26, r0
    101c:	0b 01       	movw	r0, r22
    101e:	b9 01       	movw	r22, r18
    1020:	90 01       	movw	r18, r0
    1022:	0c 01       	movw	r0, r24
    1024:	ca 01       	movw	r24, r20
    1026:	a0 01       	movw	r20, r0
    1028:	11 24       	eor	r1, r1
    102a:	ff 27       	eor	r31, r31
    102c:	59 1b       	sub	r21, r25
    102e:	99 f0       	breq	.+38     	; 0x1056 <__addsf3x+0x60>
    1030:	59 3f       	cpi	r21, 0xF9	; 249
    1032:	50 f4       	brcc	.+20     	; 0x1048 <__addsf3x+0x52>
    1034:	50 3e       	cpi	r21, 0xE0	; 224
    1036:	68 f1       	brcs	.+90     	; 0x1092 <__addsf3x+0x9c>
    1038:	1a 16       	cp	r1, r26
    103a:	f0 40       	sbci	r31, 0x00	; 0
    103c:	a2 2f       	mov	r26, r18
    103e:	23 2f       	mov	r18, r19
    1040:	34 2f       	mov	r19, r20
    1042:	44 27       	eor	r20, r20
    1044:	58 5f       	subi	r21, 0xF8	; 248
    1046:	f3 cf       	rjmp	.-26     	; 0x102e <__addsf3x+0x38>
    1048:	46 95       	lsr	r20
    104a:	37 95       	ror	r19
    104c:	27 95       	ror	r18
    104e:	a7 95       	ror	r26
    1050:	f0 40       	sbci	r31, 0x00	; 0
    1052:	53 95       	inc	r21
    1054:	c9 f7       	brne	.-14     	; 0x1048 <__addsf3x+0x52>
    1056:	7e f4       	brtc	.+30     	; 0x1076 <__addsf3x+0x80>
    1058:	1f 16       	cp	r1, r31
    105a:	ba 0b       	sbc	r27, r26
    105c:	62 0b       	sbc	r22, r18
    105e:	73 0b       	sbc	r23, r19
    1060:	84 0b       	sbc	r24, r20
    1062:	ba f0       	brmi	.+46     	; 0x1092 <__addsf3x+0x9c>
    1064:	91 50       	subi	r25, 0x01	; 1
    1066:	a1 f0       	breq	.+40     	; 0x1090 <__addsf3x+0x9a>
    1068:	ff 0f       	add	r31, r31
    106a:	bb 1f       	adc	r27, r27
    106c:	66 1f       	adc	r22, r22
    106e:	77 1f       	adc	r23, r23
    1070:	88 1f       	adc	r24, r24
    1072:	c2 f7       	brpl	.-16     	; 0x1064 <__addsf3x+0x6e>
    1074:	0e c0       	rjmp	.+28     	; 0x1092 <__addsf3x+0x9c>
    1076:	ba 0f       	add	r27, r26
    1078:	62 1f       	adc	r22, r18
    107a:	73 1f       	adc	r23, r19
    107c:	84 1f       	adc	r24, r20
    107e:	48 f4       	brcc	.+18     	; 0x1092 <__addsf3x+0x9c>
    1080:	87 95       	ror	r24
    1082:	77 95       	ror	r23
    1084:	67 95       	ror	r22
    1086:	b7 95       	ror	r27
    1088:	f7 95       	ror	r31
    108a:	9e 3f       	cpi	r25, 0xFE	; 254
    108c:	08 f0       	brcs	.+2      	; 0x1090 <__addsf3x+0x9a>
    108e:	b0 cf       	rjmp	.-160    	; 0xff0 <__addsf3+0x28>
    1090:	93 95       	inc	r25
    1092:	88 0f       	add	r24, r24
    1094:	08 f0       	brcs	.+2      	; 0x1098 <__addsf3x+0xa2>
    1096:	99 27       	eor	r25, r25
    1098:	ee 0f       	add	r30, r30
    109a:	97 95       	ror	r25
    109c:	87 95       	ror	r24
    109e:	08 95       	ret

000010a0 <__cmpsf2>:
    10a0:	0e 94 8c 09 	call	0x1318	; 0x1318 <__fp_cmp>
    10a4:	08 f4       	brcc	.+2      	; 0x10a8 <__cmpsf2+0x8>
    10a6:	81 e0       	ldi	r24, 0x01	; 1
    10a8:	08 95       	ret

000010aa <__divsf3>:
    10aa:	0e 94 69 08 	call	0x10d2	; 0x10d2 <__divsf3x>
    10ae:	0c 94 ee 09 	jmp	0x13dc	; 0x13dc <__fp_round>
    10b2:	0e 94 e7 09 	call	0x13ce	; 0x13ce <__fp_pscB>
    10b6:	58 f0       	brcs	.+22     	; 0x10ce <__divsf3+0x24>
    10b8:	0e 94 e0 09 	call	0x13c0	; 0x13c0 <__fp_pscA>
    10bc:	40 f0       	brcs	.+16     	; 0x10ce <__divsf3+0x24>
    10be:	29 f4       	brne	.+10     	; 0x10ca <__divsf3+0x20>
    10c0:	5f 3f       	cpi	r21, 0xFF	; 255
    10c2:	29 f0       	breq	.+10     	; 0x10ce <__divsf3+0x24>
    10c4:	0c 94 b0 09 	jmp	0x1360	; 0x1360 <__fp_inf>
    10c8:	51 11       	cpse	r21, r1
    10ca:	0c 94 22 0a 	jmp	0x1444	; 0x1444 <__fp_szero>
    10ce:	0c 94 b6 09 	jmp	0x136c	; 0x136c <__fp_nan>

000010d2 <__divsf3x>:
    10d2:	0e 94 ff 09 	call	0x13fe	; 0x13fe <__fp_split3>
    10d6:	68 f3       	brcs	.-38     	; 0x10b2 <__divsf3+0x8>

000010d8 <__divsf3_pse>:
    10d8:	99 23       	and	r25, r25
    10da:	b1 f3       	breq	.-20     	; 0x10c8 <__divsf3+0x1e>
    10dc:	55 23       	and	r21, r21
    10de:	91 f3       	breq	.-28     	; 0x10c4 <__divsf3+0x1a>
    10e0:	95 1b       	sub	r25, r21
    10e2:	55 0b       	sbc	r21, r21
    10e4:	bb 27       	eor	r27, r27
    10e6:	aa 27       	eor	r26, r26
    10e8:	62 17       	cp	r22, r18
    10ea:	73 07       	cpc	r23, r19
    10ec:	84 07       	cpc	r24, r20
    10ee:	38 f0       	brcs	.+14     	; 0x10fe <__divsf3_pse+0x26>
    10f0:	9f 5f       	subi	r25, 0xFF	; 255
    10f2:	5f 4f       	sbci	r21, 0xFF	; 255
    10f4:	22 0f       	add	r18, r18
    10f6:	33 1f       	adc	r19, r19
    10f8:	44 1f       	adc	r20, r20
    10fa:	aa 1f       	adc	r26, r26
    10fc:	a9 f3       	breq	.-22     	; 0x10e8 <__divsf3_pse+0x10>
    10fe:	35 d0       	rcall	.+106    	; 0x116a <__divsf3_pse+0x92>
    1100:	0e 2e       	mov	r0, r30
    1102:	3a f0       	brmi	.+14     	; 0x1112 <__divsf3_pse+0x3a>
    1104:	e0 e8       	ldi	r30, 0x80	; 128
    1106:	32 d0       	rcall	.+100    	; 0x116c <__divsf3_pse+0x94>
    1108:	91 50       	subi	r25, 0x01	; 1
    110a:	50 40       	sbci	r21, 0x00	; 0
    110c:	e6 95       	lsr	r30
    110e:	00 1c       	adc	r0, r0
    1110:	ca f7       	brpl	.-14     	; 0x1104 <__divsf3_pse+0x2c>
    1112:	2b d0       	rcall	.+86     	; 0x116a <__divsf3_pse+0x92>
    1114:	fe 2f       	mov	r31, r30
    1116:	29 d0       	rcall	.+82     	; 0x116a <__divsf3_pse+0x92>
    1118:	66 0f       	add	r22, r22
    111a:	77 1f       	adc	r23, r23
    111c:	88 1f       	adc	r24, r24
    111e:	bb 1f       	adc	r27, r27
    1120:	26 17       	cp	r18, r22
    1122:	37 07       	cpc	r19, r23
    1124:	48 07       	cpc	r20, r24
    1126:	ab 07       	cpc	r26, r27
    1128:	b0 e8       	ldi	r27, 0x80	; 128
    112a:	09 f0       	breq	.+2      	; 0x112e <__divsf3_pse+0x56>
    112c:	bb 0b       	sbc	r27, r27
    112e:	80 2d       	mov	r24, r0
    1130:	bf 01       	movw	r22, r30
    1132:	ff 27       	eor	r31, r31
    1134:	93 58       	subi	r25, 0x83	; 131
    1136:	5f 4f       	sbci	r21, 0xFF	; 255
    1138:	3a f0       	brmi	.+14     	; 0x1148 <__divsf3_pse+0x70>
    113a:	9e 3f       	cpi	r25, 0xFE	; 254
    113c:	51 05       	cpc	r21, r1
    113e:	78 f0       	brcs	.+30     	; 0x115e <__divsf3_pse+0x86>
    1140:	0c 94 b0 09 	jmp	0x1360	; 0x1360 <__fp_inf>
    1144:	0c 94 22 0a 	jmp	0x1444	; 0x1444 <__fp_szero>
    1148:	5f 3f       	cpi	r21, 0xFF	; 255
    114a:	e4 f3       	brlt	.-8      	; 0x1144 <__divsf3_pse+0x6c>
    114c:	98 3e       	cpi	r25, 0xE8	; 232
    114e:	d4 f3       	brlt	.-12     	; 0x1144 <__divsf3_pse+0x6c>
    1150:	86 95       	lsr	r24
    1152:	77 95       	ror	r23
    1154:	67 95       	ror	r22
    1156:	b7 95       	ror	r27
    1158:	f7 95       	ror	r31
    115a:	9f 5f       	subi	r25, 0xFF	; 255
    115c:	c9 f7       	brne	.-14     	; 0x1150 <__divsf3_pse+0x78>
    115e:	88 0f       	add	r24, r24
    1160:	91 1d       	adc	r25, r1
    1162:	96 95       	lsr	r25
    1164:	87 95       	ror	r24
    1166:	97 f9       	bld	r25, 7
    1168:	08 95       	ret
    116a:	e1 e0       	ldi	r30, 0x01	; 1
    116c:	66 0f       	add	r22, r22
    116e:	77 1f       	adc	r23, r23
    1170:	88 1f       	adc	r24, r24
    1172:	bb 1f       	adc	r27, r27
    1174:	62 17       	cp	r22, r18
    1176:	73 07       	cpc	r23, r19
    1178:	84 07       	cpc	r24, r20
    117a:	ba 07       	cpc	r27, r26
    117c:	20 f0       	brcs	.+8      	; 0x1186 <__divsf3_pse+0xae>
    117e:	62 1b       	sub	r22, r18
    1180:	73 0b       	sbc	r23, r19
    1182:	84 0b       	sbc	r24, r20
    1184:	ba 0b       	sbc	r27, r26
    1186:	ee 1f       	adc	r30, r30
    1188:	88 f7       	brcc	.-30     	; 0x116c <__divsf3_pse+0x94>
    118a:	e0 95       	com	r30
    118c:	08 95       	ret
    118e:	29 f4       	brne	.+10     	; 0x119a <__divsf3_pse+0xc2>
    1190:	16 f0       	brts	.+4      	; 0x1196 <__divsf3_pse+0xbe>
    1192:	0c 94 b0 09 	jmp	0x1360	; 0x1360 <__fp_inf>
    1196:	0c 94 21 0a 	jmp	0x1442	; 0x1442 <__fp_zero>
    119a:	0c 94 b6 09 	jmp	0x136c	; 0x136c <__fp_nan>

0000119e <exp>:
    119e:	0e 94 07 0a 	call	0x140e	; 0x140e <__fp_splitA>
    11a2:	a8 f3       	brcs	.-22     	; 0x118e <__divsf3_pse+0xb6>
    11a4:	96 38       	cpi	r25, 0x86	; 134
    11a6:	a0 f7       	brcc	.-24     	; 0x1190 <__divsf3_pse+0xb8>
    11a8:	07 f8       	bld	r0, 7
    11aa:	0f 92       	push	r0
    11ac:	e8 94       	clt
    11ae:	2b e3       	ldi	r18, 0x3B	; 59
    11b0:	3a ea       	ldi	r19, 0xAA	; 170
    11b2:	48 eb       	ldi	r20, 0xB8	; 184
    11b4:	5f e7       	ldi	r21, 0x7F	; 127
    11b6:	0e 94 b9 0a 	call	0x1572	; 0x1572 <__mulsf3_pse>
    11ba:	0f 92       	push	r0
    11bc:	0f 92       	push	r0
    11be:	0f 92       	push	r0
    11c0:	4d b7       	in	r20, 0x3d	; 61
    11c2:	5e b7       	in	r21, 0x3e	; 62
    11c4:	0f 92       	push	r0
    11c6:	0e 94 6f 0a 	call	0x14de	; 0x14de <modf>
    11ca:	ec e7       	ldi	r30, 0x7C	; 124
    11cc:	f0 e0       	ldi	r31, 0x00	; 0
    11ce:	0e 94 b9 09 	call	0x1372	; 0x1372 <__fp_powser>
    11d2:	4f 91       	pop	r20
    11d4:	5f 91       	pop	r21
    11d6:	ef 91       	pop	r30
    11d8:	ff 91       	pop	r31
    11da:	e5 95       	asr	r30
    11dc:	ee 1f       	adc	r30, r30
    11de:	ff 1f       	adc	r31, r31
    11e0:	49 f0       	breq	.+18     	; 0x11f4 <exp+0x56>
    11e2:	fe 57       	subi	r31, 0x7E	; 126
    11e4:	e0 68       	ori	r30, 0x80	; 128
    11e6:	44 27       	eor	r20, r20
    11e8:	ee 0f       	add	r30, r30
    11ea:	44 1f       	adc	r20, r20
    11ec:	fa 95       	dec	r31
    11ee:	e1 f7       	brne	.-8      	; 0x11e8 <exp+0x4a>
    11f0:	41 95       	neg	r20
    11f2:	55 0b       	sbc	r21, r21
    11f4:	0e 94 39 0a 	call	0x1472	; 0x1472 <ldexp>
    11f8:	0f 90       	pop	r0
    11fa:	07 fe       	sbrs	r0, 7
    11fc:	0c 94 2d 0a 	jmp	0x145a	; 0x145a <inverse>
    1200:	08 95       	ret

00001202 <__fixunssfsi>:
    1202:	0e 94 07 0a 	call	0x140e	; 0x140e <__fp_splitA>
    1206:	88 f0       	brcs	.+34     	; 0x122a <__fixunssfsi+0x28>
    1208:	9f 57       	subi	r25, 0x7F	; 127
    120a:	98 f0       	brcs	.+38     	; 0x1232 <__fixunssfsi+0x30>
    120c:	b9 2f       	mov	r27, r25
    120e:	99 27       	eor	r25, r25
    1210:	b7 51       	subi	r27, 0x17	; 23
    1212:	b0 f0       	brcs	.+44     	; 0x1240 <__fixunssfsi+0x3e>
    1214:	e1 f0       	breq	.+56     	; 0x124e <__fixunssfsi+0x4c>
    1216:	66 0f       	add	r22, r22
    1218:	77 1f       	adc	r23, r23
    121a:	88 1f       	adc	r24, r24
    121c:	99 1f       	adc	r25, r25
    121e:	1a f0       	brmi	.+6      	; 0x1226 <__fixunssfsi+0x24>
    1220:	ba 95       	dec	r27
    1222:	c9 f7       	brne	.-14     	; 0x1216 <__fixunssfsi+0x14>
    1224:	14 c0       	rjmp	.+40     	; 0x124e <__fixunssfsi+0x4c>
    1226:	b1 30       	cpi	r27, 0x01	; 1
    1228:	91 f0       	breq	.+36     	; 0x124e <__fixunssfsi+0x4c>
    122a:	0e 94 21 0a 	call	0x1442	; 0x1442 <__fp_zero>
    122e:	b1 e0       	ldi	r27, 0x01	; 1
    1230:	08 95       	ret
    1232:	0c 94 21 0a 	jmp	0x1442	; 0x1442 <__fp_zero>
    1236:	67 2f       	mov	r22, r23
    1238:	78 2f       	mov	r23, r24
    123a:	88 27       	eor	r24, r24
    123c:	b8 5f       	subi	r27, 0xF8	; 248
    123e:	39 f0       	breq	.+14     	; 0x124e <__fixunssfsi+0x4c>
    1240:	b9 3f       	cpi	r27, 0xF9	; 249
    1242:	cc f3       	brlt	.-14     	; 0x1236 <__fixunssfsi+0x34>
    1244:	86 95       	lsr	r24
    1246:	77 95       	ror	r23
    1248:	67 95       	ror	r22
    124a:	b3 95       	inc	r27
    124c:	d9 f7       	brne	.-10     	; 0x1244 <__fixunssfsi+0x42>
    124e:	3e f4       	brtc	.+14     	; 0x125e <__fixunssfsi+0x5c>
    1250:	90 95       	com	r25
    1252:	80 95       	com	r24
    1254:	70 95       	com	r23
    1256:	61 95       	neg	r22
    1258:	7f 4f       	sbci	r23, 0xFF	; 255
    125a:	8f 4f       	sbci	r24, 0xFF	; 255
    125c:	9f 4f       	sbci	r25, 0xFF	; 255
    125e:	08 95       	ret

00001260 <__floatunsisf>:
    1260:	e8 94       	clt
    1262:	09 c0       	rjmp	.+18     	; 0x1276 <__floatsisf+0x12>

00001264 <__floatsisf>:
    1264:	97 fb       	bst	r25, 7
    1266:	3e f4       	brtc	.+14     	; 0x1276 <__floatsisf+0x12>
    1268:	90 95       	com	r25
    126a:	80 95       	com	r24
    126c:	70 95       	com	r23
    126e:	61 95       	neg	r22
    1270:	7f 4f       	sbci	r23, 0xFF	; 255
    1272:	8f 4f       	sbci	r24, 0xFF	; 255
    1274:	9f 4f       	sbci	r25, 0xFF	; 255
    1276:	99 23       	and	r25, r25
    1278:	a9 f0       	breq	.+42     	; 0x12a4 <__floatsisf+0x40>
    127a:	f9 2f       	mov	r31, r25
    127c:	96 e9       	ldi	r25, 0x96	; 150
    127e:	bb 27       	eor	r27, r27
    1280:	93 95       	inc	r25
    1282:	f6 95       	lsr	r31
    1284:	87 95       	ror	r24
    1286:	77 95       	ror	r23
    1288:	67 95       	ror	r22
    128a:	b7 95       	ror	r27
    128c:	f1 11       	cpse	r31, r1
    128e:	f8 cf       	rjmp	.-16     	; 0x1280 <__floatsisf+0x1c>
    1290:	fa f4       	brpl	.+62     	; 0x12d0 <__floatsisf+0x6c>
    1292:	bb 0f       	add	r27, r27
    1294:	11 f4       	brne	.+4      	; 0x129a <__floatsisf+0x36>
    1296:	60 ff       	sbrs	r22, 0
    1298:	1b c0       	rjmp	.+54     	; 0x12d0 <__floatsisf+0x6c>
    129a:	6f 5f       	subi	r22, 0xFF	; 255
    129c:	7f 4f       	sbci	r23, 0xFF	; 255
    129e:	8f 4f       	sbci	r24, 0xFF	; 255
    12a0:	9f 4f       	sbci	r25, 0xFF	; 255
    12a2:	16 c0       	rjmp	.+44     	; 0x12d0 <__floatsisf+0x6c>
    12a4:	88 23       	and	r24, r24
    12a6:	11 f0       	breq	.+4      	; 0x12ac <__floatsisf+0x48>
    12a8:	96 e9       	ldi	r25, 0x96	; 150
    12aa:	11 c0       	rjmp	.+34     	; 0x12ce <__floatsisf+0x6a>
    12ac:	77 23       	and	r23, r23
    12ae:	21 f0       	breq	.+8      	; 0x12b8 <__floatsisf+0x54>
    12b0:	9e e8       	ldi	r25, 0x8E	; 142
    12b2:	87 2f       	mov	r24, r23
    12b4:	76 2f       	mov	r23, r22
    12b6:	05 c0       	rjmp	.+10     	; 0x12c2 <__floatsisf+0x5e>
    12b8:	66 23       	and	r22, r22
    12ba:	71 f0       	breq	.+28     	; 0x12d8 <__floatsisf+0x74>
    12bc:	96 e8       	ldi	r25, 0x86	; 134
    12be:	86 2f       	mov	r24, r22
    12c0:	70 e0       	ldi	r23, 0x00	; 0
    12c2:	60 e0       	ldi	r22, 0x00	; 0
    12c4:	2a f0       	brmi	.+10     	; 0x12d0 <__floatsisf+0x6c>
    12c6:	9a 95       	dec	r25
    12c8:	66 0f       	add	r22, r22
    12ca:	77 1f       	adc	r23, r23
    12cc:	88 1f       	adc	r24, r24
    12ce:	da f7       	brpl	.-10     	; 0x12c6 <__floatsisf+0x62>
    12d0:	88 0f       	add	r24, r24
    12d2:	96 95       	lsr	r25
    12d4:	87 95       	ror	r24
    12d6:	97 f9       	bld	r25, 7
    12d8:	08 95       	ret

000012da <fmin>:
    12da:	99 0f       	add	r25, r25
    12dc:	bb 0b       	sbc	r27, r27
    12de:	55 0f       	add	r21, r21
    12e0:	aa 0b       	sbc	r26, r26
    12e2:	e0 e8       	ldi	r30, 0x80	; 128
    12e4:	fe ef       	ldi	r31, 0xFE	; 254
    12e6:	16 16       	cp	r1, r22
    12e8:	17 06       	cpc	r1, r23
    12ea:	e8 07       	cpc	r30, r24
    12ec:	f9 07       	cpc	r31, r25
    12ee:	70 f0       	brcs	.+28     	; 0x130c <fmin+0x32>
    12f0:	12 16       	cp	r1, r18
    12f2:	13 06       	cpc	r1, r19
    12f4:	e4 07       	cpc	r30, r20
    12f6:	f5 07       	cpc	r31, r21
    12f8:	60 f0       	brcs	.+24     	; 0x1312 <fmin+0x38>
    12fa:	ba 17       	cp	r27, r26
    12fc:	54 f0       	brlt	.+20     	; 0x1312 <fmin+0x38>
    12fe:	31 f4       	brne	.+12     	; 0x130c <fmin+0x32>
    1300:	26 17       	cp	r18, r22
    1302:	37 07       	cpc	r19, r23
    1304:	48 07       	cpc	r20, r24
    1306:	59 07       	cpc	r21, r25
    1308:	a7 95       	ror	r26
    130a:	1b f4       	brvc	.+6      	; 0x1312 <fmin+0x38>
    130c:	b9 01       	movw	r22, r18
    130e:	ca 01       	movw	r24, r20
    1310:	ba 2f       	mov	r27, r26
    1312:	b6 95       	lsr	r27
    1314:	97 95       	ror	r25
    1316:	08 95       	ret

00001318 <__fp_cmp>:
    1318:	99 0f       	add	r25, r25
    131a:	00 08       	sbc	r0, r0
    131c:	55 0f       	add	r21, r21
    131e:	aa 0b       	sbc	r26, r26
    1320:	e0 e8       	ldi	r30, 0x80	; 128
    1322:	fe ef       	ldi	r31, 0xFE	; 254
    1324:	16 16       	cp	r1, r22
    1326:	17 06       	cpc	r1, r23
    1328:	e8 07       	cpc	r30, r24
    132a:	f9 07       	cpc	r31, r25
    132c:	c0 f0       	brcs	.+48     	; 0x135e <__fp_cmp+0x46>
    132e:	12 16       	cp	r1, r18
    1330:	13 06       	cpc	r1, r19
    1332:	e4 07       	cpc	r30, r20
    1334:	f5 07       	cpc	r31, r21
    1336:	98 f0       	brcs	.+38     	; 0x135e <__fp_cmp+0x46>
    1338:	62 1b       	sub	r22, r18
    133a:	73 0b       	sbc	r23, r19
    133c:	84 0b       	sbc	r24, r20
    133e:	95 0b       	sbc	r25, r21
    1340:	39 f4       	brne	.+14     	; 0x1350 <__fp_cmp+0x38>
    1342:	0a 26       	eor	r0, r26
    1344:	61 f0       	breq	.+24     	; 0x135e <__fp_cmp+0x46>
    1346:	23 2b       	or	r18, r19
    1348:	24 2b       	or	r18, r20
    134a:	25 2b       	or	r18, r21
    134c:	21 f4       	brne	.+8      	; 0x1356 <__fp_cmp+0x3e>
    134e:	08 95       	ret
    1350:	0a 26       	eor	r0, r26
    1352:	09 f4       	brne	.+2      	; 0x1356 <__fp_cmp+0x3e>
    1354:	a1 40       	sbci	r26, 0x01	; 1
    1356:	a6 95       	lsr	r26
    1358:	8f ef       	ldi	r24, 0xFF	; 255
    135a:	81 1d       	adc	r24, r1
    135c:	81 1d       	adc	r24, r1
    135e:	08 95       	ret

00001360 <__fp_inf>:
    1360:	97 f9       	bld	r25, 7
    1362:	9f 67       	ori	r25, 0x7F	; 127
    1364:	80 e8       	ldi	r24, 0x80	; 128
    1366:	70 e0       	ldi	r23, 0x00	; 0
    1368:	60 e0       	ldi	r22, 0x00	; 0
    136a:	08 95       	ret

0000136c <__fp_nan>:
    136c:	9f ef       	ldi	r25, 0xFF	; 255
    136e:	80 ec       	ldi	r24, 0xC0	; 192
    1370:	08 95       	ret

00001372 <__fp_powser>:
    1372:	df 93       	push	r29
    1374:	cf 93       	push	r28
    1376:	1f 93       	push	r17
    1378:	0f 93       	push	r16
    137a:	ff 92       	push	r15
    137c:	ef 92       	push	r14
    137e:	df 92       	push	r13
    1380:	7b 01       	movw	r14, r22
    1382:	8c 01       	movw	r16, r24
    1384:	68 94       	set
    1386:	06 c0       	rjmp	.+12     	; 0x1394 <__fp_powser+0x22>
    1388:	da 2e       	mov	r13, r26
    138a:	ef 01       	movw	r28, r30
    138c:	0e 94 b6 0a 	call	0x156c	; 0x156c <__mulsf3x>
    1390:	fe 01       	movw	r30, r28
    1392:	e8 94       	clt
    1394:	a5 91       	lpm	r26, Z+
    1396:	25 91       	lpm	r18, Z+
    1398:	35 91       	lpm	r19, Z+
    139a:	45 91       	lpm	r20, Z+
    139c:	55 91       	lpm	r21, Z+
    139e:	a6 f3       	brts	.-24     	; 0x1388 <__fp_powser+0x16>
    13a0:	ef 01       	movw	r28, r30
    13a2:	0e 94 fb 07 	call	0xff6	; 0xff6 <__addsf3x>
    13a6:	fe 01       	movw	r30, r28
    13a8:	97 01       	movw	r18, r14
    13aa:	a8 01       	movw	r20, r16
    13ac:	da 94       	dec	r13
    13ae:	69 f7       	brne	.-38     	; 0x138a <__fp_powser+0x18>
    13b0:	df 90       	pop	r13
    13b2:	ef 90       	pop	r14
    13b4:	ff 90       	pop	r15
    13b6:	0f 91       	pop	r16
    13b8:	1f 91       	pop	r17
    13ba:	cf 91       	pop	r28
    13bc:	df 91       	pop	r29
    13be:	08 95       	ret

000013c0 <__fp_pscA>:
    13c0:	00 24       	eor	r0, r0
    13c2:	0a 94       	dec	r0
    13c4:	16 16       	cp	r1, r22
    13c6:	17 06       	cpc	r1, r23
    13c8:	18 06       	cpc	r1, r24
    13ca:	09 06       	cpc	r0, r25
    13cc:	08 95       	ret

000013ce <__fp_pscB>:
    13ce:	00 24       	eor	r0, r0
    13d0:	0a 94       	dec	r0
    13d2:	12 16       	cp	r1, r18
    13d4:	13 06       	cpc	r1, r19
    13d6:	14 06       	cpc	r1, r20
    13d8:	05 06       	cpc	r0, r21
    13da:	08 95       	ret

000013dc <__fp_round>:
    13dc:	09 2e       	mov	r0, r25
    13de:	03 94       	inc	r0
    13e0:	00 0c       	add	r0, r0
    13e2:	11 f4       	brne	.+4      	; 0x13e8 <__fp_round+0xc>
    13e4:	88 23       	and	r24, r24
    13e6:	52 f0       	brmi	.+20     	; 0x13fc <__fp_round+0x20>
    13e8:	bb 0f       	add	r27, r27
    13ea:	40 f4       	brcc	.+16     	; 0x13fc <__fp_round+0x20>
    13ec:	bf 2b       	or	r27, r31
    13ee:	11 f4       	brne	.+4      	; 0x13f4 <__fp_round+0x18>
    13f0:	60 ff       	sbrs	r22, 0
    13f2:	04 c0       	rjmp	.+8      	; 0x13fc <__fp_round+0x20>
    13f4:	6f 5f       	subi	r22, 0xFF	; 255
    13f6:	7f 4f       	sbci	r23, 0xFF	; 255
    13f8:	8f 4f       	sbci	r24, 0xFF	; 255
    13fa:	9f 4f       	sbci	r25, 0xFF	; 255
    13fc:	08 95       	ret

000013fe <__fp_split3>:
    13fe:	57 fd       	sbrc	r21, 7
    1400:	90 58       	subi	r25, 0x80	; 128
    1402:	44 0f       	add	r20, r20
    1404:	55 1f       	adc	r21, r21
    1406:	59 f0       	breq	.+22     	; 0x141e <__fp_splitA+0x10>
    1408:	5f 3f       	cpi	r21, 0xFF	; 255
    140a:	71 f0       	breq	.+28     	; 0x1428 <__fp_splitA+0x1a>
    140c:	47 95       	ror	r20

0000140e <__fp_splitA>:
    140e:	88 0f       	add	r24, r24
    1410:	97 fb       	bst	r25, 7
    1412:	99 1f       	adc	r25, r25
    1414:	61 f0       	breq	.+24     	; 0x142e <__fp_splitA+0x20>
    1416:	9f 3f       	cpi	r25, 0xFF	; 255
    1418:	79 f0       	breq	.+30     	; 0x1438 <__fp_splitA+0x2a>
    141a:	87 95       	ror	r24
    141c:	08 95       	ret
    141e:	12 16       	cp	r1, r18
    1420:	13 06       	cpc	r1, r19
    1422:	14 06       	cpc	r1, r20
    1424:	55 1f       	adc	r21, r21
    1426:	f2 cf       	rjmp	.-28     	; 0x140c <__fp_split3+0xe>
    1428:	46 95       	lsr	r20
    142a:	f1 df       	rcall	.-30     	; 0x140e <__fp_splitA>
    142c:	08 c0       	rjmp	.+16     	; 0x143e <__fp_splitA+0x30>
    142e:	16 16       	cp	r1, r22
    1430:	17 06       	cpc	r1, r23
    1432:	18 06       	cpc	r1, r24
    1434:	99 1f       	adc	r25, r25
    1436:	f1 cf       	rjmp	.-30     	; 0x141a <__fp_splitA+0xc>
    1438:	86 95       	lsr	r24
    143a:	71 05       	cpc	r23, r1
    143c:	61 05       	cpc	r22, r1
    143e:	08 94       	sec
    1440:	08 95       	ret

00001442 <__fp_zero>:
    1442:	e8 94       	clt

00001444 <__fp_szero>:
    1444:	bb 27       	eor	r27, r27
    1446:	66 27       	eor	r22, r22
    1448:	77 27       	eor	r23, r23
    144a:	cb 01       	movw	r24, r22
    144c:	97 f9       	bld	r25, 7
    144e:	08 95       	ret

00001450 <__gesf2>:
    1450:	0e 94 8c 09 	call	0x1318	; 0x1318 <__fp_cmp>
    1454:	08 f4       	brcc	.+2      	; 0x1458 <__gesf2+0x8>
    1456:	8f ef       	ldi	r24, 0xFF	; 255
    1458:	08 95       	ret

0000145a <inverse>:
    145a:	9b 01       	movw	r18, r22
    145c:	ac 01       	movw	r20, r24
    145e:	60 e0       	ldi	r22, 0x00	; 0
    1460:	70 e0       	ldi	r23, 0x00	; 0
    1462:	80 e8       	ldi	r24, 0x80	; 128
    1464:	9f e3       	ldi	r25, 0x3F	; 63
    1466:	0c 94 55 08 	jmp	0x10aa	; 0x10aa <__divsf3>
    146a:	0c 94 b0 09 	jmp	0x1360	; 0x1360 <__fp_inf>
    146e:	0c 94 18 0b 	jmp	0x1630	; 0x1630 <__fp_mpack>

00001472 <ldexp>:
    1472:	0e 94 07 0a 	call	0x140e	; 0x140e <__fp_splitA>
    1476:	d8 f3       	brcs	.-10     	; 0x146e <inverse+0x14>
    1478:	99 23       	and	r25, r25
    147a:	c9 f3       	breq	.-14     	; 0x146e <inverse+0x14>
    147c:	94 0f       	add	r25, r20
    147e:	51 1d       	adc	r21, r1
    1480:	a3 f3       	brvs	.-24     	; 0x146a <inverse+0x10>
    1482:	91 50       	subi	r25, 0x01	; 1
    1484:	50 40       	sbci	r21, 0x00	; 0
    1486:	94 f0       	brlt	.+36     	; 0x14ac <ldexp+0x3a>
    1488:	59 f0       	breq	.+22     	; 0x14a0 <ldexp+0x2e>
    148a:	88 23       	and	r24, r24
    148c:	32 f0       	brmi	.+12     	; 0x149a <ldexp+0x28>
    148e:	66 0f       	add	r22, r22
    1490:	77 1f       	adc	r23, r23
    1492:	88 1f       	adc	r24, r24
    1494:	91 50       	subi	r25, 0x01	; 1
    1496:	50 40       	sbci	r21, 0x00	; 0
    1498:	c1 f7       	brne	.-16     	; 0x148a <ldexp+0x18>
    149a:	9e 3f       	cpi	r25, 0xFE	; 254
    149c:	51 05       	cpc	r21, r1
    149e:	2c f7       	brge	.-54     	; 0x146a <inverse+0x10>
    14a0:	88 0f       	add	r24, r24
    14a2:	91 1d       	adc	r25, r1
    14a4:	96 95       	lsr	r25
    14a6:	87 95       	ror	r24
    14a8:	97 f9       	bld	r25, 7
    14aa:	08 95       	ret
    14ac:	5f 3f       	cpi	r21, 0xFF	; 255
    14ae:	ac f0       	brlt	.+42     	; 0x14da <ldexp+0x68>
    14b0:	98 3e       	cpi	r25, 0xE8	; 232
    14b2:	9c f0       	brlt	.+38     	; 0x14da <ldexp+0x68>
    14b4:	bb 27       	eor	r27, r27
    14b6:	86 95       	lsr	r24
    14b8:	77 95       	ror	r23
    14ba:	67 95       	ror	r22
    14bc:	b7 95       	ror	r27
    14be:	08 f4       	brcc	.+2      	; 0x14c2 <ldexp+0x50>
    14c0:	b1 60       	ori	r27, 0x01	; 1
    14c2:	93 95       	inc	r25
    14c4:	c1 f7       	brne	.-16     	; 0x14b6 <ldexp+0x44>
    14c6:	bb 0f       	add	r27, r27
    14c8:	58 f7       	brcc	.-42     	; 0x14a0 <ldexp+0x2e>
    14ca:	11 f4       	brne	.+4      	; 0x14d0 <ldexp+0x5e>
    14cc:	60 ff       	sbrs	r22, 0
    14ce:	e8 cf       	rjmp	.-48     	; 0x14a0 <ldexp+0x2e>
    14d0:	6f 5f       	subi	r22, 0xFF	; 255
    14d2:	7f 4f       	sbci	r23, 0xFF	; 255
    14d4:	8f 4f       	sbci	r24, 0xFF	; 255
    14d6:	9f 4f       	sbci	r25, 0xFF	; 255
    14d8:	e3 cf       	rjmp	.-58     	; 0x14a0 <ldexp+0x2e>
    14da:	0c 94 22 0a 	jmp	0x1444	; 0x1444 <__fp_szero>

000014de <modf>:
    14de:	fa 01       	movw	r30, r20
    14e0:	dc 01       	movw	r26, r24
    14e2:	aa 0f       	add	r26, r26
    14e4:	bb 1f       	adc	r27, r27
    14e6:	9b 01       	movw	r18, r22
    14e8:	ac 01       	movw	r20, r24
    14ea:	bf 57       	subi	r27, 0x7F	; 127
    14ec:	28 f4       	brcc	.+10     	; 0x14f8 <modf+0x1a>
    14ee:	22 27       	eor	r18, r18
    14f0:	33 27       	eor	r19, r19
    14f2:	44 27       	eor	r20, r20
    14f4:	50 78       	andi	r21, 0x80	; 128
    14f6:	20 c0       	rjmp	.+64     	; 0x1538 <modf+0x5a>
    14f8:	b7 51       	subi	r27, 0x17	; 23
    14fa:	90 f4       	brcc	.+36     	; 0x1520 <modf+0x42>
    14fc:	ab 2f       	mov	r26, r27
    14fe:	00 24       	eor	r0, r0
    1500:	46 95       	lsr	r20
    1502:	37 95       	ror	r19
    1504:	27 95       	ror	r18
    1506:	01 1c       	adc	r0, r1
    1508:	a3 95       	inc	r26
    150a:	d2 f3       	brmi	.-12     	; 0x1500 <modf+0x22>
    150c:	00 20       	and	r0, r0
    150e:	71 f0       	breq	.+28     	; 0x152c <modf+0x4e>
    1510:	22 0f       	add	r18, r18
    1512:	33 1f       	adc	r19, r19
    1514:	44 1f       	adc	r20, r20
    1516:	b3 95       	inc	r27
    1518:	da f3       	brmi	.-10     	; 0x1510 <modf+0x32>
    151a:	0e d0       	rcall	.+28     	; 0x1538 <modf+0x5a>
    151c:	0c 94 e3 07 	jmp	0xfc6	; 0xfc6 <__subsf3>
    1520:	61 30       	cpi	r22, 0x01	; 1
    1522:	71 05       	cpc	r23, r1
    1524:	a0 e8       	ldi	r26, 0x80	; 128
    1526:	8a 07       	cpc	r24, r26
    1528:	b9 46       	sbci	r27, 0x69	; 105
    152a:	30 f4       	brcc	.+12     	; 0x1538 <modf+0x5a>
    152c:	9b 01       	movw	r18, r22
    152e:	ac 01       	movw	r20, r24
    1530:	66 27       	eor	r22, r22
    1532:	77 27       	eor	r23, r23
    1534:	88 27       	eor	r24, r24
    1536:	90 78       	andi	r25, 0x80	; 128
    1538:	30 96       	adiw	r30, 0x00	; 0
    153a:	21 f0       	breq	.+8      	; 0x1544 <modf+0x66>
    153c:	20 83       	st	Z, r18
    153e:	31 83       	std	Z+1, r19	; 0x01
    1540:	42 83       	std	Z+2, r20	; 0x02
    1542:	53 83       	std	Z+3, r21	; 0x03
    1544:	08 95       	ret

00001546 <__mulsf3>:
    1546:	0e 94 b6 0a 	call	0x156c	; 0x156c <__mulsf3x>
    154a:	0c 94 ee 09 	jmp	0x13dc	; 0x13dc <__fp_round>
    154e:	0e 94 e0 09 	call	0x13c0	; 0x13c0 <__fp_pscA>
    1552:	38 f0       	brcs	.+14     	; 0x1562 <__mulsf3+0x1c>
    1554:	0e 94 e7 09 	call	0x13ce	; 0x13ce <__fp_pscB>
    1558:	20 f0       	brcs	.+8      	; 0x1562 <__mulsf3+0x1c>
    155a:	95 23       	and	r25, r21
    155c:	11 f0       	breq	.+4      	; 0x1562 <__mulsf3+0x1c>
    155e:	0c 94 b0 09 	jmp	0x1360	; 0x1360 <__fp_inf>
    1562:	0c 94 b6 09 	jmp	0x136c	; 0x136c <__fp_nan>
    1566:	11 24       	eor	r1, r1
    1568:	0c 94 22 0a 	jmp	0x1444	; 0x1444 <__fp_szero>

0000156c <__mulsf3x>:
    156c:	0e 94 ff 09 	call	0x13fe	; 0x13fe <__fp_split3>
    1570:	70 f3       	brcs	.-36     	; 0x154e <__mulsf3+0x8>

00001572 <__mulsf3_pse>:
    1572:	95 9f       	mul	r25, r21
    1574:	c1 f3       	breq	.-16     	; 0x1566 <__mulsf3+0x20>
    1576:	95 0f       	add	r25, r21
    1578:	50 e0       	ldi	r21, 0x00	; 0
    157a:	55 1f       	adc	r21, r21
    157c:	62 9f       	mul	r22, r18
    157e:	f0 01       	movw	r30, r0
    1580:	72 9f       	mul	r23, r18
    1582:	bb 27       	eor	r27, r27
    1584:	f0 0d       	add	r31, r0
    1586:	b1 1d       	adc	r27, r1
    1588:	63 9f       	mul	r22, r19
    158a:	aa 27       	eor	r26, r26
    158c:	f0 0d       	add	r31, r0
    158e:	b1 1d       	adc	r27, r1
    1590:	aa 1f       	adc	r26, r26
    1592:	64 9f       	mul	r22, r20
    1594:	66 27       	eor	r22, r22
    1596:	b0 0d       	add	r27, r0
    1598:	a1 1d       	adc	r26, r1
    159a:	66 1f       	adc	r22, r22
    159c:	82 9f       	mul	r24, r18
    159e:	22 27       	eor	r18, r18
    15a0:	b0 0d       	add	r27, r0
    15a2:	a1 1d       	adc	r26, r1
    15a4:	62 1f       	adc	r22, r18
    15a6:	73 9f       	mul	r23, r19
    15a8:	b0 0d       	add	r27, r0
    15aa:	a1 1d       	adc	r26, r1
    15ac:	62 1f       	adc	r22, r18
    15ae:	83 9f       	mul	r24, r19
    15b0:	a0 0d       	add	r26, r0
    15b2:	61 1d       	adc	r22, r1
    15b4:	22 1f       	adc	r18, r18
    15b6:	74 9f       	mul	r23, r20
    15b8:	33 27       	eor	r19, r19
    15ba:	a0 0d       	add	r26, r0
    15bc:	61 1d       	adc	r22, r1
    15be:	23 1f       	adc	r18, r19
    15c0:	84 9f       	mul	r24, r20
    15c2:	60 0d       	add	r22, r0
    15c4:	21 1d       	adc	r18, r1
    15c6:	82 2f       	mov	r24, r18
    15c8:	76 2f       	mov	r23, r22
    15ca:	6a 2f       	mov	r22, r26
    15cc:	11 24       	eor	r1, r1
    15ce:	9f 57       	subi	r25, 0x7F	; 127
    15d0:	50 40       	sbci	r21, 0x00	; 0
    15d2:	9a f0       	brmi	.+38     	; 0x15fa <__mulsf3_pse+0x88>
    15d4:	f1 f0       	breq	.+60     	; 0x1612 <__mulsf3_pse+0xa0>
    15d6:	88 23       	and	r24, r24
    15d8:	4a f0       	brmi	.+18     	; 0x15ec <__mulsf3_pse+0x7a>
    15da:	ee 0f       	add	r30, r30
    15dc:	ff 1f       	adc	r31, r31
    15de:	bb 1f       	adc	r27, r27
    15e0:	66 1f       	adc	r22, r22
    15e2:	77 1f       	adc	r23, r23
    15e4:	88 1f       	adc	r24, r24
    15e6:	91 50       	subi	r25, 0x01	; 1
    15e8:	50 40       	sbci	r21, 0x00	; 0
    15ea:	a9 f7       	brne	.-22     	; 0x15d6 <__mulsf3_pse+0x64>
    15ec:	9e 3f       	cpi	r25, 0xFE	; 254
    15ee:	51 05       	cpc	r21, r1
    15f0:	80 f0       	brcs	.+32     	; 0x1612 <__mulsf3_pse+0xa0>
    15f2:	0c 94 b0 09 	jmp	0x1360	; 0x1360 <__fp_inf>
    15f6:	0c 94 22 0a 	jmp	0x1444	; 0x1444 <__fp_szero>
    15fa:	5f 3f       	cpi	r21, 0xFF	; 255
    15fc:	e4 f3       	brlt	.-8      	; 0x15f6 <__mulsf3_pse+0x84>
    15fe:	98 3e       	cpi	r25, 0xE8	; 232
    1600:	d4 f3       	brlt	.-12     	; 0x15f6 <__mulsf3_pse+0x84>
    1602:	86 95       	lsr	r24
    1604:	77 95       	ror	r23
    1606:	67 95       	ror	r22
    1608:	b7 95       	ror	r27
    160a:	f7 95       	ror	r31
    160c:	e7 95       	ror	r30
    160e:	9f 5f       	subi	r25, 0xFF	; 255
    1610:	c1 f7       	brne	.-16     	; 0x1602 <__mulsf3_pse+0x90>
    1612:	fe 2b       	or	r31, r30
    1614:	88 0f       	add	r24, r24
    1616:	91 1d       	adc	r25, r1
    1618:	96 95       	lsr	r25
    161a:	87 95       	ror	r24
    161c:	97 f9       	bld	r25, 7
    161e:	08 95       	ret

00001620 <sin>:
    1620:	9f 93       	push	r25
    1622:	0e 94 28 0b 	call	0x1650	; 0x1650 <__fp_rempio2>
    1626:	0f 90       	pop	r0
    1628:	07 fc       	sbrc	r0, 7
    162a:	ee 5f       	subi	r30, 0xFE	; 254
    162c:	0c 94 51 0b 	jmp	0x16a2	; 0x16a2 <__fp_sinus>

00001630 <__fp_mpack>:
    1630:	9f 3f       	cpi	r25, 0xFF	; 255
    1632:	31 f0       	breq	.+12     	; 0x1640 <__fp_mpack_finite+0xc>

00001634 <__fp_mpack_finite>:
    1634:	91 50       	subi	r25, 0x01	; 1
    1636:	20 f4       	brcc	.+8      	; 0x1640 <__fp_mpack_finite+0xc>
    1638:	87 95       	ror	r24
    163a:	77 95       	ror	r23
    163c:	67 95       	ror	r22
    163e:	b7 95       	ror	r27
    1640:	88 0f       	add	r24, r24
    1642:	91 1d       	adc	r25, r1
    1644:	96 95       	lsr	r25
    1646:	87 95       	ror	r24
    1648:	97 f9       	bld	r25, 7
    164a:	08 95       	ret
    164c:	0c 94 b6 09 	jmp	0x136c	; 0x136c <__fp_nan>

00001650 <__fp_rempio2>:
    1650:	0e 94 07 0a 	call	0x140e	; 0x140e <__fp_splitA>
    1654:	d8 f3       	brcs	.-10     	; 0x164c <__fp_mpack_finite+0x18>
    1656:	e8 94       	clt
    1658:	e0 e0       	ldi	r30, 0x00	; 0
    165a:	bb 27       	eor	r27, r27
    165c:	9f 57       	subi	r25, 0x7F	; 127
    165e:	f0 f0       	brcs	.+60     	; 0x169c <__fp_rempio2+0x4c>
    1660:	2a ed       	ldi	r18, 0xDA	; 218
    1662:	3f e0       	ldi	r19, 0x0F	; 15
    1664:	49 ec       	ldi	r20, 0xC9	; 201
    1666:	06 c0       	rjmp	.+12     	; 0x1674 <__fp_rempio2+0x24>
    1668:	ee 0f       	add	r30, r30
    166a:	bb 0f       	add	r27, r27
    166c:	66 1f       	adc	r22, r22
    166e:	77 1f       	adc	r23, r23
    1670:	88 1f       	adc	r24, r24
    1672:	28 f0       	brcs	.+10     	; 0x167e <__fp_rempio2+0x2e>
    1674:	b2 3a       	cpi	r27, 0xA2	; 162
    1676:	62 07       	cpc	r22, r18
    1678:	73 07       	cpc	r23, r19
    167a:	84 07       	cpc	r24, r20
    167c:	28 f0       	brcs	.+10     	; 0x1688 <__fp_rempio2+0x38>
    167e:	b2 5a       	subi	r27, 0xA2	; 162
    1680:	62 0b       	sbc	r22, r18
    1682:	73 0b       	sbc	r23, r19
    1684:	84 0b       	sbc	r24, r20
    1686:	e3 95       	inc	r30
    1688:	9a 95       	dec	r25
    168a:	72 f7       	brpl	.-36     	; 0x1668 <__fp_rempio2+0x18>
    168c:	80 38       	cpi	r24, 0x80	; 128
    168e:	30 f4       	brcc	.+12     	; 0x169c <__fp_rempio2+0x4c>
    1690:	9a 95       	dec	r25
    1692:	bb 0f       	add	r27, r27
    1694:	66 1f       	adc	r22, r22
    1696:	77 1f       	adc	r23, r23
    1698:	88 1f       	adc	r24, r24
    169a:	d2 f7       	brpl	.-12     	; 0x1690 <__fp_rempio2+0x40>
    169c:	90 48       	sbci	r25, 0x80	; 128
    169e:	0c 94 1a 0b 	jmp	0x1634	; 0x1634 <__fp_mpack_finite>

000016a2 <__fp_sinus>:
    16a2:	ef 93       	push	r30
    16a4:	e0 ff       	sbrs	r30, 0
    16a6:	07 c0       	rjmp	.+14     	; 0x16b6 <__fp_sinus+0x14>
    16a8:	a2 ea       	ldi	r26, 0xA2	; 162
    16aa:	2a ed       	ldi	r18, 0xDA	; 218
    16ac:	3f e0       	ldi	r19, 0x0F	; 15
    16ae:	49 ec       	ldi	r20, 0xC9	; 201
    16b0:	5f eb       	ldi	r21, 0xBF	; 191
    16b2:	0e 94 fb 07 	call	0xff6	; 0xff6 <__addsf3x>
    16b6:	0e 94 ee 09 	call	0x13dc	; 0x13dc <__fp_round>
    16ba:	0f 90       	pop	r0
    16bc:	03 94       	inc	r0
    16be:	01 fc       	sbrc	r0, 1
    16c0:	90 58       	subi	r25, 0x80	; 128
    16c2:	e4 ea       	ldi	r30, 0xA4	; 164
    16c4:	f0 e0       	ldi	r31, 0x00	; 0
    16c6:	0c 94 65 0b 	jmp	0x16ca	; 0x16ca <__fp_powsodd>

000016ca <__fp_powsodd>:
    16ca:	9f 93       	push	r25
    16cc:	8f 93       	push	r24
    16ce:	7f 93       	push	r23
    16d0:	6f 93       	push	r22
    16d2:	ff 93       	push	r31
    16d4:	ef 93       	push	r30
    16d6:	9b 01       	movw	r18, r22
    16d8:	ac 01       	movw	r20, r24
    16da:	0e 94 a3 0a 	call	0x1546	; 0x1546 <__mulsf3>
    16de:	ef 91       	pop	r30
    16e0:	ff 91       	pop	r31
    16e2:	0e 94 b9 09 	call	0x1372	; 0x1372 <__fp_powser>
    16e6:	2f 91       	pop	r18
    16e8:	3f 91       	pop	r19
    16ea:	4f 91       	pop	r20
    16ec:	5f 91       	pop	r21
    16ee:	0c 94 a3 0a 	jmp	0x1546	; 0x1546 <__mulsf3>

000016f2 <__udivmodsi4>:
    16f2:	a1 e2       	ldi	r26, 0x21	; 33
    16f4:	1a 2e       	mov	r1, r26
    16f6:	aa 1b       	sub	r26, r26
    16f8:	bb 1b       	sub	r27, r27
    16fa:	fd 01       	movw	r30, r26
    16fc:	0d c0       	rjmp	.+26     	; 0x1718 <__udivmodsi4_ep>

000016fe <__udivmodsi4_loop>:
    16fe:	aa 1f       	adc	r26, r26
    1700:	bb 1f       	adc	r27, r27
    1702:	ee 1f       	adc	r30, r30
    1704:	ff 1f       	adc	r31, r31
    1706:	a2 17       	cp	r26, r18
    1708:	b3 07       	cpc	r27, r19
    170a:	e4 07       	cpc	r30, r20
    170c:	f5 07       	cpc	r31, r21
    170e:	20 f0       	brcs	.+8      	; 0x1718 <__udivmodsi4_ep>
    1710:	a2 1b       	sub	r26, r18
    1712:	b3 0b       	sbc	r27, r19
    1714:	e4 0b       	sbc	r30, r20
    1716:	f5 0b       	sbc	r31, r21

00001718 <__udivmodsi4_ep>:
    1718:	66 1f       	adc	r22, r22
    171a:	77 1f       	adc	r23, r23
    171c:	88 1f       	adc	r24, r24
    171e:	99 1f       	adc	r25, r25
    1720:	1a 94       	dec	r1
    1722:	69 f7       	brne	.-38     	; 0x16fe <__udivmodsi4_loop>
    1724:	60 95       	com	r22
    1726:	70 95       	com	r23
    1728:	80 95       	com	r24
    172a:	90 95       	com	r25
    172c:	9b 01       	movw	r18, r22
    172e:	ac 01       	movw	r20, r24
    1730:	bd 01       	movw	r22, r26
    1732:	cf 01       	movw	r24, r30
    1734:	08 95       	ret

00001736 <_exit>:
    1736:	f8 94       	cli

00001738 <__stop_program>:
    1738:	ff cf       	rjmp	.-2      	; 0x1738 <__stop_program>
