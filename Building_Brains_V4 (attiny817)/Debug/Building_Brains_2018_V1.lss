
Building_Brains_2018_V1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000006  00803e00  00000dfa  00000e8e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000dfa  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000027  00803e06  00803e06  00000e94  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00000e94  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00000ec4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000358  00000000  00000000  00000f00  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00006268  00000000  00000000  00001258  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000279d  00000000  00000000  000074c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000018d1  00000000  00000000  00009c5d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000053c  00000000  00000000  0000b530  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002767  00000000  00000000  0000ba6c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000bcb  00000000  00000000  0000e1d3  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000248  00000000  00000000  0000ed9e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	2d c0       	rjmp	.+90     	; 0x5c <__ctors_end>
   2:	47 c0       	rjmp	.+142    	; 0x92 <__bad_interrupt>
   4:	46 c0       	rjmp	.+140    	; 0x92 <__bad_interrupt>
   6:	45 c0       	rjmp	.+138    	; 0x92 <__bad_interrupt>
   8:	44 c0       	rjmp	.+136    	; 0x92 <__bad_interrupt>
   a:	43 c0       	rjmp	.+134    	; 0x92 <__bad_interrupt>
   c:	45 c0       	rjmp	.+138    	; 0x98 <__vector_6>
   e:	41 c0       	rjmp	.+130    	; 0x92 <__bad_interrupt>
  10:	40 c0       	rjmp	.+128    	; 0x92 <__bad_interrupt>
  12:	3f c0       	rjmp	.+126    	; 0x92 <__bad_interrupt>
  14:	3e c0       	rjmp	.+124    	; 0x92 <__bad_interrupt>
  16:	3d c0       	rjmp	.+122    	; 0x92 <__bad_interrupt>
  18:	3c c0       	rjmp	.+120    	; 0x92 <__bad_interrupt>
  1a:	3b c0       	rjmp	.+118    	; 0x92 <__bad_interrupt>
  1c:	3a c0       	rjmp	.+116    	; 0x92 <__bad_interrupt>
  1e:	39 c0       	rjmp	.+114    	; 0x92 <__bad_interrupt>
  20:	38 c0       	rjmp	.+112    	; 0x92 <__bad_interrupt>
  22:	37 c0       	rjmp	.+110    	; 0x92 <__bad_interrupt>
  24:	36 c0       	rjmp	.+108    	; 0x92 <__bad_interrupt>
  26:	35 c0       	rjmp	.+106    	; 0x92 <__bad_interrupt>
  28:	34 c0       	rjmp	.+104    	; 0x92 <__bad_interrupt>
  2a:	33 c0       	rjmp	.+102    	; 0x92 <__bad_interrupt>
  2c:	32 c0       	rjmp	.+100    	; 0x92 <__bad_interrupt>
  2e:	31 c0       	rjmp	.+98     	; 0x92 <__bad_interrupt>
  30:	30 c0       	rjmp	.+96     	; 0x92 <__bad_interrupt>
  32:	2f c0       	rjmp	.+94     	; 0x92 <__bad_interrupt>
  34:	07 63       	ori	r16, 0x37	; 55
  36:	42 36       	cpi	r20, 0x62	; 98
  38:	b7 9b       	sbis	0x16, 7	; 22
  3a:	d8 a7       	std	Y+40, r29	; 0x28
  3c:	1a 39       	cpi	r17, 0x9A	; 154
  3e:	68 56       	subi	r22, 0x68	; 104
  40:	18 ae       	std	Y+56, r1	; 0x38
  42:	ba ab       	std	Y+50, r27	; 0x32
  44:	55 8c       	ldd	r5, Z+29	; 0x1d
  46:	1d 3c       	cpi	r17, 0xCD	; 205
  48:	b7 cc       	rjmp	.-1682   	; 0xfffff9b8 <__eeprom_end+0xff7ef9b8>
  4a:	57 63       	ori	r21, 0x37	; 55
  4c:	bd 6d       	ori	r27, 0xDD	; 221
  4e:	ed fd       	.word	0xfded	; ????
  50:	75 3e       	cpi	r23, 0xE5	; 229
  52:	f6 17       	cp	r31, r22
  54:	72 31       	cpi	r23, 0x12	; 18
  56:	bf 00       	.word	0x00bf	; ????
  58:	00 00       	nop
  5a:	80 3f       	cpi	r24, 0xF0	; 240

0000005c <__ctors_end>:
  5c:	11 24       	eor	r1, r1
  5e:	1f be       	out	0x3f, r1	; 63
  60:	cf ef       	ldi	r28, 0xFF	; 255
  62:	cd bf       	out	0x3d, r28	; 61
  64:	df e3       	ldi	r29, 0x3F	; 63
  66:	de bf       	out	0x3e, r29	; 62

00000068 <__do_copy_data>:
  68:	1e e3       	ldi	r17, 0x3E	; 62
  6a:	a0 e0       	ldi	r26, 0x00	; 0
  6c:	be e3       	ldi	r27, 0x3E	; 62
  6e:	ea ef       	ldi	r30, 0xFA	; 250
  70:	fd e0       	ldi	r31, 0x0D	; 13
  72:	02 c0       	rjmp	.+4      	; 0x78 <__do_copy_data+0x10>
  74:	05 90       	lpm	r0, Z+
  76:	0d 92       	st	X+, r0
  78:	a6 30       	cpi	r26, 0x06	; 6
  7a:	b1 07       	cpc	r27, r17
  7c:	d9 f7       	brne	.-10     	; 0x74 <__do_copy_data+0xc>

0000007e <__do_clear_bss>:
  7e:	2e e3       	ldi	r18, 0x3E	; 62
  80:	a6 e0       	ldi	r26, 0x06	; 6
  82:	be e3       	ldi	r27, 0x3E	; 62
  84:	01 c0       	rjmp	.+2      	; 0x88 <.do_clear_bss_start>

00000086 <.do_clear_bss_loop>:
  86:	1d 92       	st	X+, r1

00000088 <.do_clear_bss_start>:
  88:	ad 32       	cpi	r26, 0x2D	; 45
  8a:	b2 07       	cpc	r27, r18
  8c:	e1 f7       	brne	.-8      	; 0x86 <.do_clear_bss_loop>
  8e:	2b d0       	rcall	.+86     	; 0xe6 <main>
  90:	b2 c6       	rjmp	.+3428   	; 0xdf6 <_exit>

00000092 <__bad_interrupt>:
  92:	b6 cf       	rjmp	.-148    	; 0x0 <__vectors>

00000094 <atmel_start_init>:
/**
 * Initializes MCU, drivers and middleware in the project
**/
void atmel_start_init(void)
{
	system_init();
  94:	b5 d1       	rcall	.+874    	; 0x400 <system_init>
  96:	08 95       	ret

00000098 <__vector_6>:
#include <compiler.h>
#include <stdbool.h>
#include "tiny_timed_ISR/tiny_timed_ISR.h"

ISR(RTC_CNT_vect)
{
  98:	1f 92       	push	r1
  9a:	0f 92       	push	r0
  9c:	0f b6       	in	r0, 0x3f	; 63
  9e:	0f 92       	push	r0
  a0:	11 24       	eor	r1, r1
  a2:	2f 93       	push	r18
  a4:	3f 93       	push	r19
  a6:	4f 93       	push	r20
  a8:	5f 93       	push	r21
  aa:	6f 93       	push	r22
  ac:	7f 93       	push	r23
  ae:	8f 93       	push	r24
  b0:	9f 93       	push	r25
  b2:	af 93       	push	r26
  b4:	bf 93       	push	r27
  b6:	ef 93       	push	r30
  b8:	ff 93       	push	r31
	tiny_timed_ISR_setflag(true);
  ba:	81 e0       	ldi	r24, 0x01	; 1
  bc:	98 d2       	rcall	.+1328   	; 0x5ee <tiny_timed_ISR_setflag>
	/* Insert your RTC Overflow interrupt handling code */
	/* Overflow interrupt flag has to be cleared manually */
	RTC.INTFLAGS = RTC_OVF_bm;
  be:	81 e0       	ldi	r24, 0x01	; 1
  c0:	80 93 43 01 	sts	0x0143, r24	; 0x800143 <__TEXT_REGION_LENGTH__+0x700143>
}
  c4:	ff 91       	pop	r31
  c6:	ef 91       	pop	r30
  c8:	bf 91       	pop	r27
  ca:	af 91       	pop	r26
  cc:	9f 91       	pop	r25
  ce:	8f 91       	pop	r24
  d0:	7f 91       	pop	r23
  d2:	6f 91       	pop	r22
  d4:	5f 91       	pop	r21
  d6:	4f 91       	pop	r20
  d8:	3f 91       	pop	r19
  da:	2f 91       	pop	r18
  dc:	0f 90       	pop	r0
  de:	0f be       	out	0x3f, r0	; 63
  e0:	0f 90       	pop	r0
  e2:	1f 90       	pop	r1
  e4:	18 95       	reti

000000e6 <main>:


int main(void)
{
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
  e6:	d6 df       	rcall	.-84     	; 0x94 <atmel_start_init>
	VREF.CTRLA = 0x33;//sets reference voltage to 4.32 Volts. This is done to ensure relatively low interference from
  e8:	83 e3       	ldi	r24, 0x33	; 51
  ea:	80 93 a0 00 	sts	0x00A0, r24	; 0x8000a0 <__TEXT_REGION_LENGTH__+0x7000a0>
	//nearby induced magnetic fields from high voltage AC-signals, such as outlets or transformers.
	while (1)
	{
		if(tiny_timed_ISR_getflag())
  ee:	82 d2       	rcall	.+1284   	; 0x5f4 <tiny_timed_ISR_getflag>
  f0:	88 23       	and	r24, r24
  f2:	e9 f3       	breq	.-6      	; 0xee <main+0x8>
		{
			tiny_potential_master_update(1);
  f4:	60 e0       	ldi	r22, 0x00	; 0
  f6:	70 e0       	ldi	r23, 0x00	; 0
  f8:	80 e8       	ldi	r24, 0x80	; 128
  fa:	9f e3       	ldi	r25, 0x3F	; 63
  fc:	7e d2       	rcall	.+1276   	; 0x5fa <tiny_potential_master_update>
			tiny_timed_ISR_setflag(false);
  fe:	80 e0       	ldi	r24, 0x00	; 0
 100:	76 d2       	rcall	.+1260   	; 0x5ee <tiny_timed_ISR_setflag>
 102:	f5 cf       	rjmp	.-22     	; 0xee <main+0x8>

00000104 <Potential_to_RGB_write_potential_on_LEDs>:
		tinyCCLRGB_uploadColorsToLeds();
	}
}

void Potential_to_RGB_write_potential_on_LEDs(double potential, _Bool fire)
{
 104:	8f 92       	push	r8
 106:	9f 92       	push	r9
 108:	af 92       	push	r10
 10a:	bf 92       	push	r11
 10c:	cf 92       	push	r12
 10e:	df 92       	push	r13
 110:	ef 92       	push	r14
 112:	ff 92       	push	r15
 114:	0f 93       	push	r16
 116:	1f 93       	push	r17
 118:	cf 93       	push	r28
 11a:	df 93       	push	r29
 11c:	4b 01       	movw	r8, r22
 11e:	5c 01       	movw	r10, r24
	if (fire)
 120:	44 23       	and	r20, r20
 122:	59 f0       	breq	.+22     	; 0x13a <Potential_to_RGB_write_potential_on_LEDs+0x36>
 124:	c0 e0       	ldi	r28, 0x00	; 0
//and so another update to the LEDs will have to be called to restore them to normal function again.
static void set_LED_fire(void)
{
	for (int i = 0; i < number_of_leds; i++)
	{
		tinyCCLRGB_setColor(i, max_brightness, max_brightness, max_brightness);//This can be set to whatever people like
 126:	20 e3       	ldi	r18, 0x30	; 48
 128:	40 e3       	ldi	r20, 0x30	; 48
 12a:	60 e3       	ldi	r22, 0x30	; 48
 12c:	8c 2f       	mov	r24, r28
 12e:	c0 d1       	rcall	.+896    	; 0x4b0 <tinyCCLRGB_setColor>
		//currently I'm in the "all LEDs should be white while firing"-camp, so that's why it's like this.
		tinyCCLRGB_uploadColorsToLeds();
 130:	cc d1       	rcall	.+920    	; 0x4ca <tinyCCLRGB_uploadColorsToLeds>
 132:	cf 5f       	subi	r28, 0xFF	; 255

//this function should be called on to represent that the LEDs have fired, the function will only write to the LEDs once
//and so another update to the LEDs will have to be called to restore them to normal function again.
static void set_LED_fire(void)
{
	for (int i = 0; i < number_of_leds; i++)
 134:	c6 30       	cpi	r28, 0x06	; 6
 136:	b9 f7       	brne	.-18     	; 0x126 <Potential_to_RGB_write_potential_on_LEDs+0x22>
 138:	ad c0       	rjmp	.+346    	; 0x294 <Potential_to_RGB_write_potential_on_LEDs+0x190>
And the absolute value of the potential should then be linearly displayed along the LEDs.
This, of course is just a prototype and the final decision lies with the design team as well as the group.
I'm only programming this right now so that I've got some base to work on for later.*/
static void potential_to_rgb(double potential)
{
	uint8_t base = abs(floor(potential/8.33333));//base is the amount of LEDs that is turned on max brightness
 13a:	22 e5       	ldi	r18, 0x52	; 82
 13c:	35 e5       	ldi	r19, 0x55	; 85
 13e:	45 e0       	ldi	r20, 0x05	; 5
 140:	51 e4       	ldi	r21, 0x41	; 65
 142:	3a d3       	rcall	.+1652   	; 0x7b8 <__divsf3>
 144:	58 d4       	rcall	.+2224   	; 0x9f6 <floor>
 146:	e4 d3       	rcall	.+1992   	; 0x910 <__fixsfsi>
 148:	8b 01       	movw	r16, r22
 14a:	77 23       	and	r23, r23
 14c:	24 f4       	brge	.+8      	; 0x156 <Potential_to_RGB_write_potential_on_LEDs+0x52>
 14e:	00 27       	eor	r16, r16
 150:	11 27       	eor	r17, r17
 152:	06 1b       	sub	r16, r22
 154:	17 0b       	sbc	r17, r23
 156:	d0 2e       	mov	r13, r16
 158:	11 27       	eor	r17, r17
	
	uint8_t top_floor = abs(round((potential-base)*max_brightness/8.33333));//residual light will be in the top LED decided by how "charged" the upperbound LED should be.
 15a:	b8 01       	movw	r22, r16
 15c:	01 2e       	mov	r0, r17
 15e:	00 0c       	add	r0, r0
 160:	88 0b       	sbc	r24, r24
 162:	99 0b       	sbc	r25, r25
 164:	0d d4       	rcall	.+2074   	; 0x980 <__floatsisf>
 166:	9b 01       	movw	r18, r22
 168:	ac 01       	movw	r20, r24
 16a:	c5 01       	movw	r24, r10
 16c:	b4 01       	movw	r22, r8
 16e:	b2 d2       	rcall	.+1380   	; 0x6d4 <__subsf3>
 170:	20 e0       	ldi	r18, 0x00	; 0
 172:	30 e0       	ldi	r19, 0x00	; 0
 174:	40 e4       	ldi	r20, 0x40	; 64
 176:	52 e4       	ldi	r21, 0x42	; 66
 178:	ad d5       	rcall	.+2906   	; 0xcd4 <__mulsf3>
 17a:	22 e5       	ldi	r18, 0x52	; 82
 17c:	35 e5       	ldi	r19, 0x55	; 85
 17e:	45 e0       	ldi	r20, 0x05	; 5
 180:	51 e4       	ldi	r21, 0x41	; 65
 182:	1a d3       	rcall	.+1588   	; 0x7b8 <__divsf3>
 184:	14 d6       	rcall	.+3112   	; 0xdae <round>
	//By residual light I mean the light that is not dispayed by just maxing the lower LEDs, each LEDs brightness covers about 8.33333 worth of absolute "potential", so to speak.
	if(base > 3)
 186:	23 e0       	ldi	r18, 0x03	; 3
 188:	2d 15       	cp	r18, r13
 18a:	08 f4       	brcc	.+2      	; 0x18e <Potential_to_RGB_write_potential_on_LEDs+0x8a>
 18c:	72 c0       	rjmp	.+228    	; 0x272 <Potential_to_RGB_write_potential_on_LEDs+0x16e>
I'm only programming this right now so that I've got some base to work on for later.*/
static void potential_to_rgb(double potential)
{
	uint8_t base = abs(floor(potential/8.33333));//base is the amount of LEDs that is turned on max brightness
	
	uint8_t top_floor = abs(round((potential-base)*max_brightness/8.33333));//residual light will be in the top LED decided by how "charged" the upperbound LED should be.
 18e:	c0 d3       	rcall	.+1920   	; 0x910 <__fixsfsi>
 190:	ab 01       	movw	r20, r22
 192:	77 23       	and	r23, r23
 194:	24 f4       	brge	.+8      	; 0x19e <Potential_to_RGB_write_potential_on_LEDs+0x9a>
 196:	44 27       	eor	r20, r20
 198:	55 27       	eor	r21, r21
 19a:	46 1b       	sub	r20, r22
 19c:	57 0b       	sbc	r21, r23
 19e:	c4 2e       	mov	r12, r20
	if(base > 3)
	{
		base = 2;//covering extreme negative values.
		top_floor = max_brightness;//there needs to be a top_floor included so we don't have to rewrite the entire functionality for one case.
	}
	if(potential < 0)//potential is negative => red color
 1a0:	20 e0       	ldi	r18, 0x00	; 0
 1a2:	30 e0       	ldi	r19, 0x00	; 0
 1a4:	a9 01       	movw	r20, r18
 1a6:	c5 01       	movw	r24, r10
 1a8:	b4 01       	movw	r22, r8
 1aa:	01 d3       	rcall	.+1538   	; 0x7ae <__cmpsf2>
 1ac:	88 23       	and	r24, r24
 1ae:	44 f5       	brge	.+80     	; 0x200 <Potential_to_RGB_write_potential_on_LEDs+0xfc>
	{
		for (int i = 0; i < base; i++)
 1b0:	10 16       	cp	r1, r16
 1b2:	11 06       	cpc	r1, r17
 1b4:	54 f0       	brlt	.+20     	; 0x1ca <Potential_to_RGB_write_potential_on_LEDs+0xc6>
 1b6:	1e c0       	rjmp	.+60     	; 0x1f4 <Potential_to_RGB_write_potential_on_LEDs+0xf0>
 1b8:	02 e0       	ldi	r16, 0x02	; 2
 1ba:	10 e0       	ldi	r17, 0x00	; 0
	uint8_t top_floor = abs(round((potential-base)*max_brightness/8.33333));//residual light will be in the top LED decided by how "charged" the upperbound LED should be.
	//By residual light I mean the light that is not dispayed by just maxing the lower LEDs, each LEDs brightness covers about 8.33333 worth of absolute "potential", so to speak.
	if(base > 3)
	{
		base = 2;//covering extreme negative values.
		top_floor = max_brightness;//there needs to be a top_floor included so we don't have to rewrite the entire functionality for one case.
 1bc:	0f 2e       	mov	r0, r31
 1be:	f0 e3       	ldi	r31, 0x30	; 48
 1c0:	cf 2e       	mov	r12, r31
 1c2:	f0 2d       	mov	r31, r0
	
	uint8_t top_floor = abs(round((potential-base)*max_brightness/8.33333));//residual light will be in the top LED decided by how "charged" the upperbound LED should be.
	//By residual light I mean the light that is not dispayed by just maxing the lower LEDs, each LEDs brightness covers about 8.33333 worth of absolute "potential", so to speak.
	if(base > 3)
	{
		base = 2;//covering extreme negative values.
 1c4:	68 94       	set
 1c6:	dd 24       	eor	r13, r13
 1c8:	d1 f8       	bld	r13, 1
 1ca:	0f 2e       	mov	r0, r31
 1cc:	f3 e0       	ldi	r31, 0x03	; 3
 1ce:	ff 2e       	mov	r15, r31
 1d0:	f0 2d       	mov	r31, r0
 1d2:	c0 e0       	ldi	r28, 0x00	; 0
 1d4:	d0 e0       	ldi	r29, 0x00	; 0
	}
	if(potential < 0)//potential is negative => red color
	{
		for (int i = 0; i < base; i++)
		{
			tinyCCLRGB_setColor(i, max_brightness, 0x0, 0x0);
 1d6:	20 e0       	ldi	r18, 0x00	; 0
 1d8:	40 e0       	ldi	r20, 0x00	; 0
 1da:	60 e3       	ldi	r22, 0x30	; 48
 1dc:	8c 2f       	mov	r24, r28
 1de:	68 d1       	rcall	.+720    	; 0x4b0 <tinyCCLRGB_setColor>
			tinyCCLRGB_setColor(i+3, max_brightness, 0x0, 0x0);//when programming I've made the assumption that the LEDs will be put on the PCB so that the upper LEDs is LED[0:2]
 1e0:	20 e0       	ldi	r18, 0x00	; 0
 1e2:	40 e0       	ldi	r20, 0x00	; 0
 1e4:	60 e3       	ldi	r22, 0x30	; 48
 1e6:	8f 2d       	mov	r24, r15
 1e8:	63 d1       	rcall	.+710    	; 0x4b0 <tinyCCLRGB_setColor>
		base = 2;//covering extreme negative values.
		top_floor = max_brightness;//there needs to be a top_floor included so we don't have to rewrite the entire functionality for one case.
	}
	if(potential < 0)//potential is negative => red color
	{
		for (int i = 0; i < base; i++)
 1ea:	21 96       	adiw	r28, 0x01	; 1
 1ec:	f3 94       	inc	r15
 1ee:	c0 17       	cp	r28, r16
 1f0:	d1 07       	cpc	r29, r17
 1f2:	8c f3       	brlt	.-30     	; 0x1d6 <Potential_to_RGB_write_potential_on_LEDs+0xd2>
		{
			tinyCCLRGB_setColor(i, max_brightness, 0x0, 0x0);
			tinyCCLRGB_setColor(i+3, max_brightness, 0x0, 0x0);//when programming I've made the assumption that the LEDs will be put on the PCB so that the upper LEDs is LED[0:2]
			//and lower LED is LED[3:5]
		}
		tinyCCLRGB_setColor(base+1, top_floor, 0x0, 0x0);
 1f4:	20 e0       	ldi	r18, 0x00	; 0
 1f6:	40 e0       	ldi	r20, 0x00	; 0
 1f8:	6c 2d       	mov	r22, r12
 1fa:	81 e0       	ldi	r24, 0x01	; 1
 1fc:	8d 0d       	add	r24, r13
 1fe:	58 d1       	rcall	.+688    	; 0x4b0 <tinyCCLRGB_setColor>
	}
	if (potential > 0)//potential is positive => positive color.
 200:	20 e0       	ldi	r18, 0x00	; 0
 202:	30 e0       	ldi	r19, 0x00	; 0
 204:	a9 01       	movw	r20, r18
 206:	c5 01       	movw	r24, r10
 208:	b4 01       	movw	r22, r8
 20a:	e9 d4       	rcall	.+2514   	; 0xbde <__gesf2>
 20c:	18 16       	cp	r1, r24
 20e:	0c f0       	brlt	.+2      	; 0x212 <Potential_to_RGB_write_potential_on_LEDs+0x10e>
 210:	41 c0       	rjmp	.+130    	; 0x294 <Potential_to_RGB_write_potential_on_LEDs+0x190>
	{
		for (int i = 0; i< base; i++)
 212:	ed 2c       	mov	r14, r13
 214:	f1 2c       	mov	r15, r1
 216:	1e 14       	cp	r1, r14
 218:	1f 04       	cpc	r1, r15
 21a:	64 f0       	brlt	.+24     	; 0x234 <Potential_to_RGB_write_potential_on_LEDs+0x130>
 21c:	1d c0       	rjmp	.+58     	; 0x258 <Potential_to_RGB_write_potential_on_LEDs+0x154>
	uint8_t top_floor = abs(round((potential-base)*max_brightness/8.33333));//residual light will be in the top LED decided by how "charged" the upperbound LED should be.
	//By residual light I mean the light that is not dispayed by just maxing the lower LEDs, each LEDs brightness covers about 8.33333 worth of absolute "potential", so to speak.
	if(base > 3)
	{
		base = 2;//covering extreme negative values.
		top_floor = max_brightness;//there needs to be a top_floor included so we don't have to rewrite the entire functionality for one case.
 21e:	0f 2e       	mov	r0, r31
 220:	f0 e3       	ldi	r31, 0x30	; 48
 222:	cf 2e       	mov	r12, r31
 224:	f0 2d       	mov	r31, r0
		}
		tinyCCLRGB_setColor(base+1, top_floor, 0x0, 0x0);
	}
	if (potential > 0)//potential is positive => positive color.
	{
		for (int i = 0; i< base; i++)
 226:	68 94       	set
 228:	ee 24       	eor	r14, r14
 22a:	e1 f8       	bld	r14, 1
 22c:	f1 2c       	mov	r15, r1
	
	uint8_t top_floor = abs(round((potential-base)*max_brightness/8.33333));//residual light will be in the top LED decided by how "charged" the upperbound LED should be.
	//By residual light I mean the light that is not dispayed by just maxing the lower LEDs, each LEDs brightness covers about 8.33333 worth of absolute "potential", so to speak.
	if(base > 3)
	{
		base = 2;//covering extreme negative values.
 22e:	68 94       	set
 230:	dd 24       	eor	r13, r13
 232:	d1 f8       	bld	r13, 1
 234:	13 e0       	ldi	r17, 0x03	; 3
 236:	c0 e0       	ldi	r28, 0x00	; 0
 238:	d0 e0       	ldi	r29, 0x00	; 0
	}
	if (potential > 0)//potential is positive => positive color.
	{
		for (int i = 0; i< base; i++)
		{
			tinyCCLRGB_setColor(i, 0x0, max_brightness, 0x0);
 23a:	20 e0       	ldi	r18, 0x00	; 0
 23c:	40 e3       	ldi	r20, 0x30	; 48
 23e:	60 e0       	ldi	r22, 0x00	; 0
 240:	8c 2f       	mov	r24, r28
 242:	36 d1       	rcall	.+620    	; 0x4b0 <tinyCCLRGB_setColor>
			tinyCCLRGB_setColor(i+3, 0x0, max_brightness, 0x0);
 244:	20 e0       	ldi	r18, 0x00	; 0
 246:	40 e3       	ldi	r20, 0x30	; 48
 248:	60 e0       	ldi	r22, 0x00	; 0
 24a:	81 2f       	mov	r24, r17
 24c:	31 d1       	rcall	.+610    	; 0x4b0 <tinyCCLRGB_setColor>
		}
		tinyCCLRGB_setColor(base+1, top_floor, 0x0, 0x0);
	}
	if (potential > 0)//potential is positive => positive color.
	{
		for (int i = 0; i< base; i++)
 24e:	21 96       	adiw	r28, 0x01	; 1
 250:	1f 5f       	subi	r17, 0xFF	; 255
 252:	ce 15       	cp	r28, r14
 254:	df 05       	cpc	r29, r15
 256:	89 f7       	brne	.-30     	; 0x23a <Potential_to_RGB_write_potential_on_LEDs+0x136>
		{
			tinyCCLRGB_setColor(i, 0x0, max_brightness, 0x0);
			tinyCCLRGB_setColor(i+3, 0x0, max_brightness, 0x0);
		}
		tinyCCLRGB_setColor(base+1, 0x0, top_floor, 0x0);
 258:	20 e0       	ldi	r18, 0x00	; 0
 25a:	4c 2d       	mov	r20, r12
 25c:	60 e0       	ldi	r22, 0x00	; 0
 25e:	81 e0       	ldi	r24, 0x01	; 1
 260:	8d 0d       	add	r24, r13
 262:	26 d1       	rcall	.+588    	; 0x4b0 <tinyCCLRGB_setColor>
		tinyCCLRGB_setColor(base+4, 0x0, top_floor, 0x0);
 264:	20 e0       	ldi	r18, 0x00	; 0
 266:	4c 2d       	mov	r20, r12
 268:	60 e0       	ldi	r22, 0x00	; 0
 26a:	84 e0       	ldi	r24, 0x04	; 4
 26c:	8d 0d       	add	r24, r13
 26e:	20 d1       	rcall	.+576    	; 0x4b0 <tinyCCLRGB_setColor>
	}
	else
	{
		potential_to_rgb(potential);
	}
 270:	11 c0       	rjmp	.+34     	; 0x294 <Potential_to_RGB_write_potential_on_LEDs+0x190>
	if(base > 3)
	{
		base = 2;//covering extreme negative values.
		top_floor = max_brightness;//there needs to be a top_floor included so we don't have to rewrite the entire functionality for one case.
	}
	if(potential < 0)//potential is negative => red color
 272:	20 e0       	ldi	r18, 0x00	; 0
 274:	30 e0       	ldi	r19, 0x00	; 0
 276:	a9 01       	movw	r20, r18
 278:	c5 01       	movw	r24, r10
 27a:	b4 01       	movw	r22, r8
 27c:	98 d2       	rcall	.+1328   	; 0x7ae <__cmpsf2>
 27e:	88 23       	and	r24, r24
 280:	0c f4       	brge	.+2      	; 0x284 <Potential_to_RGB_write_potential_on_LEDs+0x180>
 282:	9a cf       	rjmp	.-204    	; 0x1b8 <Potential_to_RGB_write_potential_on_LEDs+0xb4>
			tinyCCLRGB_setColor(i+3, max_brightness, 0x0, 0x0);//when programming I've made the assumption that the LEDs will be put on the PCB so that the upper LEDs is LED[0:2]
			//and lower LED is LED[3:5]
		}
		tinyCCLRGB_setColor(base+1, top_floor, 0x0, 0x0);
	}
	if (potential > 0)//potential is positive => positive color.
 284:	20 e0       	ldi	r18, 0x00	; 0
 286:	30 e0       	ldi	r19, 0x00	; 0
 288:	a9 01       	movw	r20, r18
 28a:	c5 01       	movw	r24, r10
 28c:	b4 01       	movw	r22, r8
 28e:	a7 d4       	rcall	.+2382   	; 0xbde <__gesf2>
 290:	18 16       	cp	r1, r24
 292:	2c f2       	brlt	.-118    	; 0x21e <Potential_to_RGB_write_potential_on_LEDs+0x11a>
	}
	else
	{
		potential_to_rgb(potential);
	}
 294:	df 91       	pop	r29
 296:	cf 91       	pop	r28
 298:	1f 91       	pop	r17
 29a:	0f 91       	pop	r16
 29c:	ff 90       	pop	r15
 29e:	ef 90       	pop	r14
 2a0:	df 90       	pop	r13
 2a2:	cf 90       	pop	r12
 2a4:	bf 90       	pop	r11
 2a6:	af 90       	pop	r10
 2a8:	9f 90       	pop	r9
 2aa:	8f 90       	pop	r8
 2ac:	08 95       	ret

000002ae <ADC_init>:
 * \return Conversion result read from the ADC ADC module
 */
adc_result_t ADC_get_conversion_result(void)
{
	return (ADC0.RES);
}
 2ae:	85 e0       	ldi	r24, 0x05	; 5
 2b0:	80 93 00 06 	sts	0x0600, r24	; 0x800600 <__TEXT_REGION_LENGTH__+0x700600>
 2b4:	80 e0       	ldi	r24, 0x00	; 0
 2b6:	08 95       	ret

000002b8 <ADC_is_conversion_done>:
 2b8:	80 91 0b 06 	lds	r24, 0x060B	; 0x80060b <__TEXT_REGION_LENGTH__+0x70060b>
 2bc:	81 70       	andi	r24, 0x01	; 1
 2be:	08 95       	ret

000002c0 <ADC_get_conversion>:
 *
 * \return Nothing
 */
void ADC_start_conversion(adc_0_channel_t channel)
{
	ADC0.MUXPOS  = channel;
 2c0:	e0 e0       	ldi	r30, 0x00	; 0
 2c2:	f6 e0       	ldi	r31, 0x06	; 6
 2c4:	86 83       	std	Z+6, r24	; 0x06
	ADC0.COMMAND = ADC_STCONV_bm;
 2c6:	81 e0       	ldi	r24, 0x01	; 1
 2c8:	80 87       	std	Z+8, r24	; 0x08
adc_result_t ADC_get_conversion(adc_0_channel_t channel)
{
	adc_result_t res;

	ADC_start_conversion(channel);
	while (!ADC_is_conversion_done())
 2ca:	f6 df       	rcall	.-20     	; 0x2b8 <ADC_is_conversion_done>
 2cc:	88 23       	and	r24, r24
 2ce:	e9 f3       	breq	.-6      	; 0x2ca <ADC_get_conversion+0xa>
 *
 * \return Conversion result read from the ADC ADC module
 */
adc_result_t ADC_get_conversion_result(void)
{
	return (ADC0.RES);
 2d0:	e0 e0       	ldi	r30, 0x00	; 0
 2d2:	f6 e0       	ldi	r31, 0x06	; 6
 2d4:	20 89       	ldd	r18, Z+16	; 0x10
 2d6:	31 89       	ldd	r19, Z+17	; 0x11

	ADC_start_conversion(channel);
	while (!ADC_is_conversion_done())
		;
	res = ADC_get_conversion_result();
	ADC0.INTFLAGS |= ADC_RESRDY_bm;
 2d8:	93 85       	ldd	r25, Z+11	; 0x0b
 2da:	91 60       	ori	r25, 0x01	; 1
 2dc:	93 87       	std	Z+11, r25	; 0x0b
	return res;
}
 2de:	c9 01       	movw	r24, r18
 2e0:	08 95       	ret

000002e2 <BOD_init>:
	//		 | BOD_VLMCFG_ABOVE_gc; /* Interrupt when supply goes above VLM level */

	// BOD.VLMCTRLA = BOD_VLMLVL_5ABOVE_gc; /* VLM threshold 5% above BOD level */

	return 0;
}
 2e2:	80 e0       	ldi	r24, 0x00	; 0
 2e4:	08 95       	ret

000002e6 <DIGGSIGG_init>:
	//		 | CCL_EDGEDET_DIS_gc /* Edge detector is disabled */
	//		 | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	//		 | 0 << CCL_ENABLE_bp /* LUT Enable: disabled */
	//		 | 0 << CCL_OUTEN_bp; /* Output Enable: disabled */

	CCL.TRUTH1 = 168; /* Truth 1: 168 */
 2e6:	e0 ec       	ldi	r30, 0xC0	; 192
 2e8:	f1 e0       	ldi	r31, 0x01	; 1
 2ea:	88 ea       	ldi	r24, 0xA8	; 168
 2ec:	84 87       	std	Z+12, r24	; 0x0c

	CCL.LUT1CTRLC = CCL_INSEL2_TCA0_gc /* TCA0 WO2 input source */;
 2ee:	88 e0       	ldi	r24, 0x08	; 8
 2f0:	83 87       	std	Z+11, r24	; 0x0b

	CCL.LUT1CTRLB = CCL_INSEL0_SPI0_gc /* SPI0 SCK source */
 2f2:	8b eb       	ldi	r24, 0xBB	; 187
 2f4:	82 87       	std	Z+10, r24	; 0x0a
	                | CCL_INSEL1_SPI0_gc /* SPI0 MOSI input source */;

	CCL.LUT1CTRLA = 0 << CCL_CLKSRC_bp       /* Clock Source Selection: disabled */
 2f6:	89 e0       	ldi	r24, 0x09	; 9
 2f8:	81 87       	std	Z+9, r24	; 0x09
	                | CCL_EDGEDET_DIS_gc     /* Edge detector is disabled */
	                | CCL_FILTSEL_DISABLE_gc /* Filter disabled */
	                | 1 << CCL_ENABLE_bp     /* LUT Enable: enabled */
	                | 1 << CCL_OUTEN_bp;     /* Output Enable: enabled */

	CCL.CTRLA = 1 << CCL_ENABLE_bp      /* Enable: enabled */
 2fa:	81 e4       	ldi	r24, 0x41	; 65
 2fc:	80 83       	st	Z, r24
	            | 1 << CCL_RUNSTDBY_bp; /* Run in Standby: enabled */

	return 0;
}
 2fe:	80 e0       	ldi	r24, 0x00	; 0
 300:	08 95       	ret

00000302 <CLKCTRL_init>:
 *       on calling convention. The memory model is not visible to the
 *       preprocessor, so it must be defined in the Assembler preprocessor directives.
 */
static inline void ccp_write_io(void *addr, uint8_t value)
{
	protected_write_io(addr, CCP_IOREG_gc, value);
 302:	47 e0       	ldi	r20, 0x07	; 7
 304:	68 ed       	ldi	r22, 0xD8	; 216
 306:	8c e7       	ldi	r24, 0x7C	; 124
 308:	90 e0       	ldi	r25, 0x00	; 0
 30a:	8c d0       	rcall	.+280    	; 0x424 <protected_write_io>
 30c:	41 e0       	ldi	r20, 0x01	; 1
 30e:	68 ed       	ldi	r22, 0xD8	; 216
 310:	81 e6       	ldi	r24, 0x61	; 97
 312:	90 e0       	ldi	r25, 0x00	; 0
 314:	87 d0       	rcall	.+270    	; 0x424 <protected_write_io>
	//		 | 0 << CLKCTRL_CLKOUT_bp /* System clock out: disabled */);

	// ccp_write_io((void*)&(CLKCTRL.MCLKLOCK),0 << CLKCTRL_LOCKEN_bp /* lock enable: disabled */);

	return 0;
}
 316:	80 e0       	ldi	r24, 0x00	; 0
 318:	08 95       	ret

0000031a <CPUINT_init>:

	// CPUINT.LVL0PRI = 0x0 << CPUINT_LVL0PRI_gp; /* Interrupt Level Priority: 0x0 */

	// CPUINT.LVL1VEC = 0x0 << CPUINT_LVL1VEC_gp; /* Interrupt Vector with High Priority: 0x0 */

	ENABLE_INTERRUPTS();
 31a:	78 94       	sei

	return 0;
}
 31c:	80 e0       	ldi	r24, 0x00	; 0
 31e:	08 95       	ret

00000320 <DAC_init>:
int8_t DAC_init()
{

	// DAC0.DATA = 0x0; /* DATA Register: 0x0 */

	DAC0.CTRLA = 1 << DAC_ENABLE_bp      /* DAC Enable: enabled */
 320:	81 e4       	ldi	r24, 0x41	; 65
 322:	80 93 80 06 	sts	0x0680, r24	; 0x800680 <__TEXT_REGION_LENGTH__+0x700680>
	             | 1 << DAC_OUTEN_bp     /* Output Buffer Enable: enabled */
	             | 0 << DAC_RUNSTDBY_bp; /* Run in Standby Mode: disabled */

	return 0;
}
 326:	80 e0       	ldi	r24, 0x00	; 0
 328:	08 95       	ret

0000032a <mcu_init>:

/* configure pins and initialize registers */
void DAC_initialization(void)
{

	DAC_init();
 32a:	e0 e1       	ldi	r30, 0x10	; 16
 32c:	f4 e0       	ldi	r31, 0x04	; 4
 32e:	80 81       	ld	r24, Z
 330:	88 60       	ori	r24, 0x08	; 8
 332:	81 93       	st	Z+, r24
 334:	e8 31       	cpi	r30, 0x18	; 24
 336:	84 e0       	ldi	r24, 0x04	; 4
 338:	f8 07       	cpc	r31, r24
 33a:	c9 f7       	brne	.-14     	; 0x32e <mcu_init+0x4>
 33c:	e0 e3       	ldi	r30, 0x30	; 48
 33e:	f4 e0       	ldi	r31, 0x04	; 4
 340:	80 81       	ld	r24, Z
 342:	88 60       	ori	r24, 0x08	; 8
 344:	81 93       	st	Z+, r24
 346:	e8 33       	cpi	r30, 0x38	; 56
 348:	84 e0       	ldi	r24, 0x04	; 4
 34a:	f8 07       	cpc	r31, r24
 34c:	c9 f7       	brne	.-14     	; 0x340 <mcu_init+0x16>
 34e:	e0 e5       	ldi	r30, 0x50	; 80
 350:	f4 e0       	ldi	r31, 0x04	; 4
 352:	80 81       	ld	r24, Z
 354:	88 60       	ori	r24, 0x08	; 8
 356:	81 93       	st	Z+, r24
 358:	e8 35       	cpi	r30, 0x58	; 88
 35a:	84 e0       	ldi	r24, 0x04	; 4
 35c:	f8 07       	cpc	r31, r24
 35e:	c9 f7       	brne	.-14     	; 0x352 <mcu_init+0x28>
 360:	08 95       	ret

00000362 <ADC_initialization>:
 362:	e5 e1       	ldi	r30, 0x15	; 21
 364:	f4 e0       	ldi	r31, 0x04	; 4
 366:	80 81       	ld	r24, Z
 368:	88 7f       	andi	r24, 0xF8	; 248
 36a:	84 60       	ori	r24, 0x04	; 4
 36c:	80 83       	st	Z, r24
 36e:	80 81       	ld	r24, Z
 370:	87 7f       	andi	r24, 0xF7	; 247
 372:	80 83       	st	Z, r24
 374:	e7 e1       	ldi	r30, 0x17	; 23
 376:	f4 e0       	ldi	r31, 0x04	; 4
 378:	80 81       	ld	r24, Z
 37a:	88 7f       	andi	r24, 0xF8	; 248
 37c:	84 60       	ori	r24, 0x04	; 4
 37e:	80 83       	st	Z, r24
 380:	80 81       	ld	r24, Z
 382:	87 7f       	andi	r24, 0xF7	; 247
 384:	80 83       	st	Z, r24
 386:	e4 e3       	ldi	r30, 0x34	; 52
 388:	f4 e0       	ldi	r31, 0x04	; 4
 38a:	80 81       	ld	r24, Z
 38c:	88 7f       	andi	r24, 0xF8	; 248
 38e:	84 60       	ori	r24, 0x04	; 4
 390:	80 83       	st	Z, r24
 392:	80 81       	ld	r24, Z
 394:	87 7f       	andi	r24, 0xF7	; 247
 396:	80 83       	st	Z, r24
 398:	e1 e3       	ldi	r30, 0x31	; 49
 39a:	f4 e0       	ldi	r31, 0x04	; 4
 39c:	80 81       	ld	r24, Z
 39e:	88 7f       	andi	r24, 0xF8	; 248
 3a0:	84 60       	ori	r24, 0x04	; 4
 3a2:	80 83       	st	Z, r24
 3a4:	80 81       	ld	r24, Z
 3a6:	87 7f       	andi	r24, 0xF7	; 247
 3a8:	80 83       	st	Z, r24
 3aa:	e0 e3       	ldi	r30, 0x30	; 48
 3ac:	f4 e0       	ldi	r31, 0x04	; 4
 3ae:	80 81       	ld	r24, Z
 3b0:	88 7f       	andi	r24, 0xF8	; 248
 3b2:	84 60       	ori	r24, 0x04	; 4
 3b4:	80 83       	st	Z, r24
 3b6:	80 81       	ld	r24, Z
 3b8:	87 7f       	andi	r24, 0xF7	; 247
 3ba:	80 83       	st	Z, r24
 3bc:	78 df       	rcall	.-272    	; 0x2ae <ADC_init>
 3be:	08 95       	ret

000003c0 <TIMER_0_initialization>:
 3c0:	25 9a       	sbi	0x04, 5	; 4
 3c2:	2d 98       	cbi	0x05, 5	; 5
 3c4:	e0 e0       	ldi	r30, 0x00	; 0
 3c6:	f2 e0       	ldi	r31, 0x02	; 2
 3c8:	82 81       	ldd	r24, Z+2	; 0x02
 3ca:	84 60       	ori	r24, 0x04	; 4
 3cc:	82 83       	std	Z+2, r24	; 0x02
 3ce:	4c d0       	rcall	.+152    	; 0x468 <TIMER_0_init>
 3d0:	08 95       	ret

000003d2 <DIGGSIGG_initialization>:
 3d2:	41 9a       	sbi	0x08, 1	; 8
 3d4:	49 98       	cbi	0x09, 1	; 9
 3d6:	e0 e0       	ldi	r30, 0x00	; 0
 3d8:	f2 e0       	ldi	r31, 0x02	; 2
 3da:	80 81       	ld	r24, Z
 3dc:	80 62       	ori	r24, 0x20	; 32
 3de:	80 83       	st	Z, r24
 3e0:	82 df       	rcall	.-252    	; 0x2e6 <DIGGSIGG_init>
 3e2:	08 95       	ret

000003e4 <SPI_0_initialization>:
 3e4:	02 98       	cbi	0x00, 2	; 0
 3e6:	e2 e1       	ldi	r30, 0x12	; 18
 3e8:	f4 e0       	ldi	r31, 0x04	; 4
 3ea:	80 81       	ld	r24, Z
 3ec:	87 7f       	andi	r24, 0xF7	; 247
 3ee:	80 83       	st	Z, r24
 3f0:	01 9a       	sbi	0x00, 1	; 0
 3f2:	09 98       	cbi	0x01, 1	; 1
 3f4:	03 9a       	sbi	0x00, 3	; 0
 3f6:	0b 98       	cbi	0x01, 3	; 1
 3f8:	04 9a       	sbi	0x00, 4	; 0
 3fa:	0c 98       	cbi	0x01, 4	; 1
 3fc:	2d d0       	rcall	.+90     	; 0x458 <SPI_0_init>
 3fe:	08 95       	ret

00000400 <system_init>:
/**
 * \brief System initialization
 */
void system_init()
{
	mcu_init();
 400:	94 df       	rcall	.-216    	; 0x32a <mcu_init>
 */
static inline void PORTC_set_pin_dir(const uint8_t pin, const enum port_dir dir)
{
	switch (dir) {
	case PORT_DIR_IN:
		VPORTC.DIR &= ~(1 << pin);
 402:	42 98       	cbi	0x08, 2	; 8
static inline void PORTC_set_pin_pull_mode(const uint8_t pin, const enum port_pull_mode pull_mode)
{
	volatile uint8_t *port_pin_ctrl = ((uint8_t *)&PORTC + 0x10 + pin);

	if (pull_mode == PORT_PULL_UP) {
		*port_pin_ctrl |= PORT_PULLUPEN_bm;
 404:	e2 e5       	ldi	r30, 0x52	; 82
 406:	f4 e0       	ldi	r31, 0x04	; 4
 408:	80 81       	ld	r24, Z
 40a:	88 60       	ori	r24, 0x08	; 8
 40c:	80 83       	st	Z, r24
	    // <id> pad_pull_config
	    // <PORT_PULL_OFF"> Off
	    // <PORT_PULL_UP"> Pull-up
	    PORT_PULL_UP);

	CLKCTRL_init();
 40e:	79 df       	rcall	.-270    	; 0x302 <CLKCTRL_init>

	RTC_init();
 410:	0d d0       	rcall	.+26     	; 0x42c <RTC_init>

	ADC_initialization();
 412:	a7 df       	rcall	.-178    	; 0x362 <ADC_initialization>

	TIMER_0_initialization();
 414:	d5 df       	rcall	.-86     	; 0x3c0 <TIMER_0_initialization>

	DIGGSIGG_initialization();
 416:	dd df       	rcall	.-70     	; 0x3d2 <DIGGSIGG_initialization>

	SPI_0_initialization();
 418:	e5 df       	rcall	.-54     	; 0x3e4 <SPI_0_initialization>

/* configure pins and initialize registers */
void DAC_initialization(void)
{

	DAC_init();
 41a:	82 df       	rcall	.-252    	; 0x320 <DAC_init>

	SPI_0_initialization();

	DAC_initialization();

	CPUINT_init();
 41c:	7e df       	rcall	.-260    	; 0x31a <CPUINT_init>

	SLPCTRL_init();
 41e:	1a d0       	rcall	.+52     	; 0x454 <SLPCTRL_init>

	BOD_init();
 420:	60 df       	rcall	.-320    	; 0x2e2 <BOD_init>
 422:	08 95       	ret

00000424 <protected_write_io>:
#if defined(__GNUC__)
  
#ifdef RAMPZ
	out     _SFR_IO_ADDR(RAMPZ), r1         // Clear bits 23:16 of Z
#endif
	movw    r30, r24                // Load addr into Z
 424:	fc 01       	movw	r30, r24
	out     CCP, r22                // Start CCP handshake
 426:	64 bf       	out	0x34, r22	; 52
	st      Z, r20                  // Write value to I/O register
 428:	40 83       	st	Z, r20
	ret                             // Return to caller
 42a:	08 95       	ret

0000042c <RTC_init>:
 * \return Initialization status.
 */
int8_t RTC_init()
{

	while (RTC.STATUS > 0) { /* Wait for all register to be synchronized */
 42c:	e0 e4       	ldi	r30, 0x40	; 64
 42e:	f1 e0       	ldi	r31, 0x01	; 1
 430:	81 81       	ldd	r24, Z+1	; 0x01
 432:	81 11       	cpse	r24, r1
 434:	fd cf       	rjmp	.-6      	; 0x430 <RTC_init+0x4>

	// RTC.CMP = 0x0; /* Compare: 0x0 */

	// RTC.CNT = 0x0; /* Counter: 0x0 */

	RTC.CTRLA = RTC_PRESCALER_DIV32_gc  /* 32 */
 436:	e0 e4       	ldi	r30, 0x40	; 64
 438:	f1 e0       	ldi	r31, 0x01	; 1
 43a:	89 ea       	ldi	r24, 0xA9	; 169
 43c:	80 83       	st	Z, r24
	            | 1 << RTC_RTCEN_bp     /* Enable: enabled */
	            | 1 << RTC_RUNSTDBY_bp; /* Run In Standby: enabled */

	RTC.PER = 0x1; /* Period: 0x1 */
 43e:	81 e0       	ldi	r24, 0x01	; 1
 440:	90 e0       	ldi	r25, 0x00	; 0
 442:	82 87       	std	Z+10, r24	; 0x0a
 444:	93 87       	std	Z+11, r25	; 0x0b

	RTC.CLKSEL = RTC_CLKSEL_TOSC32K_gc; /* 32.768kHz External Crystal Oscillator (XOSC32K) */
 446:	82 e0       	ldi	r24, 0x02	; 2
 448:	87 83       	std	Z+7, r24	; 0x07

	RTC.DBGCTRL = 1 << RTC_DBGRUN_bp; /* Run in debug: enabled */
 44a:	81 e0       	ldi	r24, 0x01	; 1
 44c:	85 83       	std	Z+5, r24	; 0x05

	RTC.INTCTRL = 0 << RTC_CMP_bp    /* Compare Match Interrupt enable: disabled */
 44e:	82 83       	std	Z+2, r24	; 0x02
	// RTC.PITDBGCTRL = 0 << RTC_DBGRUN_bp; /* Run in debug: disabled */

	// RTC.PITINTCTRL = 0 << RTC_PI_bp; /* Periodic Interrupt: disabled */

	return 0;
}
 450:	80 e0       	ldi	r24, 0x00	; 0
 452:	08 95       	ret

00000454 <SLPCTRL_init>:

	// SLPCTRL.CTRLA = 0 << SLPCTRL_SEN_bp /* Sleep enable: disabled */
	//		 | SLPCTRL_SMODE_IDLE_gc; /* Idle mode */

	return 0;
}
 454:	80 e0       	ldi	r24, 0x00	; 0
 456:	08 95       	ret

00000458 <SPI_0_init>:
 * \return Initialization status
 */
int8_t SPI_0_init()
{

	SPI0.CTRLA = 0 << SPI_CLK2X_bp     /* Enable Double Speed: disabled */
 458:	e0 e2       	ldi	r30, 0x20	; 32
 45a:	f8 e0       	ldi	r31, 0x08	; 8
 45c:	83 e2       	ldi	r24, 0x23	; 35
 45e:	80 83       	st	Z, r24
	             | 0 << SPI_DORD_bp    /* Data Order Setting: disabled */
	             | 1 << SPI_ENABLE_bp  /* Enable Module: enabled */
	             | 1 << SPI_MASTER_bp  /* SPI module in master mode */
	             | SPI_PRESC_DIV16_gc; /* System Clock / 16 */

	SPI0.CTRLB = 0 << SPI_BUFEN_bp   /* Buffer Mode Enable: disabled */
 460:	84 e0       	ldi	r24, 0x04	; 4
 462:	81 83       	std	Z+1, r24	; 0x01
	//		 | 0 << SPI_RXCIE_bp /* Receive Complete Interrupt Enable: disabled */
	//		 | 0 << SPI_SSIE_bp /* Slave Select Trigger Interrupt Enable: disabled */
	//		 | 0 << SPI_TXCIE_bp; /* Transfer Complete Interrupt Enable: disabled */

	return 0;
}
 464:	80 e0       	ldi	r24, 0x00	; 0
 466:	08 95       	ret

00000468 <TIMER_0_init>:

	// TCA0.SINGLE.CMP0 = 0x0; /* Compare Register 0: 0x0 */

	// TCA0.SINGLE.CMP1 = 0x0; /* Compare Register 1: 0x0 */

	TCA0.SINGLE.CMP2 = 0x4; /* Compare Register 2: 0x4 */
 468:	e0 e0       	ldi	r30, 0x00	; 0
 46a:	fa e0       	ldi	r31, 0x0A	; 10
 46c:	84 e0       	ldi	r24, 0x04	; 4
 46e:	90 e0       	ldi	r25, 0x00	; 0
 470:	84 a7       	std	Z+44, r24	; 0x2c
 472:	95 a7       	std	Z+45, r25	; 0x2d

	// TCA0.SINGLE.CNT = 0x0; /* Count: 0x0 */

	TCA0.SINGLE.CTRLB = 0 << TCA_SINGLE_ALUPD_bp            /* Auto Lock Update: disabled */
 474:	83 e4       	ldi	r24, 0x43	; 67
 476:	81 83       	std	Z+1, r24	; 0x01
	                    | 0 << TCA_SINGLE_CMP0EN_bp         /* Compare 0 Enable: disabled */
	                    | 0 << TCA_SINGLE_CMP1EN_bp         /* Compare 1 Enable: disabled */
	                    | 1 << TCA_SINGLE_CMP2EN_bp         /* Compare 2 Enable: enabled */
	                    | TCA_SINGLE_WGMODE_SINGLESLOPE_gc; /*  */

	TCA0.SINGLE.CTRLC = 0 << TCA_SINGLE_CMP0OV_bp    /* Compare 0 Waveform Output Value: disabled */
 478:	84 e0       	ldi	r24, 0x04	; 4
 47a:	82 83       	std	Z+2, r24	; 0x02
	// TCA0.SINGLE.INTCTRL = 0 << TCA_SINGLE_CMP0_bp /* Compare 0 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP1_bp /* Compare 1 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_CMP2_bp /* Compare 2 Interrupt: disabled */
	//		 | 0 << TCA_SINGLE_OVF_bp; /* Overflow Interrupt: disabled */

	TCA0.SINGLE.PER = 0x7; /* Period: 0x7 */
 47c:	87 e0       	ldi	r24, 0x07	; 7
 47e:	90 e0       	ldi	r25, 0x00	; 0
 480:	86 a3       	std	Z+38, r24	; 0x26
 482:	97 a3       	std	Z+39, r25	; 0x27

	// TCA0.SINGLE.CTRLA = TCA_SINGLE_CLKSEL_DIV1_gc /* System Clock */
	//		 | 0 << TCA_SINGLE_ENABLE_bp; /* Module Enable: disabled */

	return 0;
}
 484:	80 e0       	ldi	r24, 0x00	; 0
 486:	08 95       	ret

00000488 <tinyCCLRGB_SPIWriteByte>:

static struct tinyCCLRGB_color tinyCCLRGB_colors[tinyCCLRGB_ledCount];


void tinyCCLRGB_init(uint8_t ledNumber)
{
 488:	90 91 23 08 	lds	r25, 0x0823	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
 48c:	90 93 23 08 	sts	0x0823, r25	; 0x800823 <__TEXT_REGION_LENGTH__+0x700823>
 490:	e0 e0       	ldi	r30, 0x00	; 0
 492:	fa e0       	ldi	r31, 0x0A	; 10
 494:	10 a2       	std	Z+32, r1	; 0x20
 496:	11 a2       	std	Z+33, r1	; 0x21
 498:	91 e0       	ldi	r25, 0x01	; 1
 49a:	90 83       	st	Z, r25
 49c:	80 93 24 08 	sts	0x0824, r24	; 0x800824 <__TEXT_REGION_LENGTH__+0x700824>
 4a0:	e0 e2       	ldi	r30, 0x20	; 32
 4a2:	f8 e0       	ldi	r31, 0x08	; 8
 4a4:	83 81       	ldd	r24, Z+3	; 0x03
 4a6:	88 23       	and	r24, r24
 4a8:	ec f7       	brge	.-6      	; 0x4a4 <tinyCCLRGB_SPIWriteByte+0x1c>
 4aa:	10 92 00 0a 	sts	0x0A00, r1	; 0x800a00 <__TEXT_REGION_LENGTH__+0x700a00>
 4ae:	08 95       	ret

000004b0 <tinyCCLRGB_setColor>:
	// TODO: Set up SPI, PWM and CCL here
}

void tinyCCLRGB_setColor(uint8_t led, uint8_t red, uint8_t green, uint8_t blue) 
{
	tinyCCLRGB_colors[led].red = red;
 4b0:	90 e0       	ldi	r25, 0x00	; 0
 4b2:	fc 01       	movw	r30, r24
 4b4:	ee 0f       	add	r30, r30
 4b6:	ff 1f       	adc	r31, r31
 4b8:	8e 0f       	add	r24, r30
 4ba:	9f 1f       	adc	r25, r31
 4bc:	fc 01       	movw	r30, r24
 4be:	ea 5f       	subi	r30, 0xFA	; 250
 4c0:	f1 4c       	sbci	r31, 0xC1	; 193
 4c2:	60 83       	st	Z, r22
	tinyCCLRGB_colors[led].green = green;
 4c4:	41 83       	std	Z+1, r20	; 0x01
	tinyCCLRGB_colors[led].blue = blue;
 4c6:	22 83       	std	Z+2, r18	; 0x02
 4c8:	08 95       	ret

000004ca <tinyCCLRGB_uploadColorsToLeds>:
	TCA0.SINGLE.CTRLA = TCA_SPLIT_CLKSEL_DIV1_gc | 0 << TCA_SPLIT_ENABLE_bp; //Stop TCA
}

//function to write to the ledpins, using CCL with different PWM-signals to create a readable signal for the LEDs.
void tinyCCLRGB_uploadColorsToLeds(void)
{
 4ca:	0f 93       	push	r16
 4cc:	1f 93       	push	r17
 4ce:	cf 93       	push	r28
 4d0:	df 93       	push	r29
 4d2:	c6 e0       	ldi	r28, 0x06	; 6
 4d4:	de e3       	ldi	r29, 0x3E	; 62
 4d6:	08 e1       	ldi	r16, 0x18	; 24
 4d8:	1e e3       	ldi	r17, 0x3E	; 62
	for (uint8_t i = 0; i < tinyCCLRGB_ledCount; i++)
	{
		//For some reason unknown to the writer the data-bus to the LEDs is serialized as GRB
		//which means the 24-bit data-bus will look like  (Green[0:7], Red[0:7], Blue[0:7])
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].green);
 4da:	89 81       	ldd	r24, Y+1	; 0x01
 4dc:	d5 df       	rcall	.-86     	; 0x488 <tinyCCLRGB_SPIWriteByte>
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].red);
 4de:	88 81       	ld	r24, Y
 4e0:	d3 df       	rcall	.-90     	; 0x488 <tinyCCLRGB_SPIWriteByte>
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].blue);
 4e2:	8a 81       	ldd	r24, Y+2	; 0x02
 4e4:	d1 df       	rcall	.-94     	; 0x488 <tinyCCLRGB_SPIWriteByte>
 4e6:	23 96       	adiw	r28, 0x03	; 3
}

//function to write to the ledpins, using CCL with different PWM-signals to create a readable signal for the LEDs.
void tinyCCLRGB_uploadColorsToLeds(void)
{
	for (uint8_t i = 0; i < tinyCCLRGB_ledCount; i++)
 4e8:	c0 17       	cp	r28, r16
 4ea:	d1 07       	cpc	r29, r17
 4ec:	b1 f7       	brne	.-20     	; 0x4da <tinyCCLRGB_uploadColorsToLeds+0x10>
		//which means the 24-bit data-bus will look like  (Green[0:7], Red[0:7], Blue[0:7])
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].green);
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].red);
		tinyCCLRGB_SPIWriteByte(tinyCCLRGB_colors[i].blue);
	}
 4ee:	df 91       	pop	r29
 4f0:	cf 91       	pop	r28
 4f2:	1f 91       	pop	r17
 4f4:	0f 91       	pop	r16
 4f6:	08 95       	ret

000004f8 <tiny_DAC_axon_set_fire>:
}


void tiny_DAC_axon_set_fire()
{
	tiny_DAC_axon_fire = true;
 4f8:	81 e0       	ldi	r24, 0x01	; 1
 4fa:	80 93 18 3e 	sts	0x3E18, r24	; 0x803e18 <tiny_DAC_axon_fire>
 4fe:	08 95       	ret

00000500 <tiny_ADC_dendrite_delta_potential>:
		}
	}
}

int8_t tiny_ADC_dendrite_delta_potential()
{
 500:	8f 92       	push	r8
 502:	9f 92       	push	r9
 504:	af 92       	push	r10
 506:	bf 92       	push	r11
 508:	cf 92       	push	r12
 50a:	df 92       	push	r13
 50c:	ef 92       	push	r14
 50e:	ff 92       	push	r15
 510:	0f 93       	push	r16
 512:	1f 93       	push	r17
 514:	cf 93       	push	r28
 516:	df 93       	push	r29
 518:	c0 e0       	ldi	r28, 0x00	; 0
 51a:	de e3       	ldi	r29, 0x3E	; 62
 51c:	0f 2e       	mov	r0, r31
 51e:	f3 e2       	ldi	r31, 0x23	; 35
 520:	ef 2e       	mov	r14, r31
 522:	fe e3       	ldi	r31, 0x3E	; 62
 524:	ff 2e       	mov	r15, r31
 526:	f0 2d       	mov	r31, r0
 528:	0f 2e       	mov	r0, r31
 52a:	f5 e0       	ldi	r31, 0x05	; 5
 52c:	cf 2e       	mov	r12, r31
 52e:	fe e3       	ldi	r31, 0x3E	; 62
 530:	df 2e       	mov	r13, r31
 532:	f0 2d       	mov	r31, r0
 534:	87 01       	movw	r16, r14

static void tiny_ADC_dendrites_update_values(void)
{
	for (int i = 0; i < tiny_ADC_dendrite_number; i++)
	{
		tiny_ADC_values[i] = ADC_get_conversion(dendrite_ports[i]);
 536:	89 91       	ld	r24, Y+
 538:	c3 de       	rcall	.-634    	; 0x2c0 <ADC_get_conversion>
 53a:	f8 01       	movw	r30, r16
 53c:	81 93       	st	Z+, r24
 53e:	8f 01       	movw	r16, r30
enum tiny_ADC_dendrite_signal_type tiny_ADC_dendrite_prev_signals[5] = {no_signal};


static void tiny_ADC_dendrites_update_values(void)
{
	for (int i = 0; i < tiny_ADC_dendrite_number; i++)
 540:	cc 15       	cp	r28, r12
 542:	dd 05       	cpc	r29, r13
 544:	c1 f7       	brne	.-16     	; 0x536 <tiny_ADC_dendrite_delta_potential+0x36>
 546:	0e e1       	ldi	r16, 0x1E	; 30
 548:	1e e3       	ldi	r17, 0x3E	; 62
 54a:	0f 2e       	mov	r0, r31
 54c:	f9 e1       	ldi	r31, 0x19	; 25
 54e:	af 2e       	mov	r10, r31
 550:	fe e3       	ldi	r31, 0x3E	; 62
 552:	bf 2e       	mov	r11, r31
 554:	f0 2d       	mov	r31, r0
 556:	0f 2e       	mov	r0, r31
 558:	f3 e2       	ldi	r31, 0x23	; 35
 55a:	cf 2e       	mov	r12, r31
 55c:	fe e3       	ldi	r31, 0x3E	; 62
 55e:	df 2e       	mov	r13, r31
 560:	f0 2d       	mov	r31, r0
 562:	e8 01       	movw	r28, r16
static void tiny_ADC_update_signal(void)
{
	for (int i = 0; i < tiny_ADC_dendrite_number; i++)
	{
		tiny_ADC_dendrite_prev_signals[i] = tiny_ADC_dendrite_cur_signals[i];
		tiny_ADC_dendrite_cur_signals[i] = floor(tiny_ADC_values[i] / 51);
 564:	0f 2e       	mov	r0, r31
 566:	f1 ea       	ldi	r31, 0xA1	; 161
 568:	8f 2e       	mov	r8, r31
 56a:	f0 2d       	mov	r31, r0

static void tiny_ADC_update_signal(void)
{
	for (int i = 0; i < tiny_ADC_dendrite_number; i++)
	{
		tiny_ADC_dendrite_prev_signals[i] = tiny_ADC_dendrite_cur_signals[i];
 56c:	98 80       	ld	r9, Y
 56e:	f5 01       	movw	r30, r10
 570:	91 92       	st	Z+, r9
 572:	5f 01       	movw	r10, r30
		tiny_ADC_dendrite_cur_signals[i] = floor(tiny_ADC_values[i] / 51);
 574:	f7 01       	movw	r30, r14
 576:	61 91       	ld	r22, Z+
 578:	7f 01       	movw	r14, r30
 57a:	68 9d       	mul	r22, r8
 57c:	61 2d       	mov	r22, r1
 57e:	11 24       	eor	r1, r1
 580:	62 95       	swap	r22
 582:	66 95       	lsr	r22
 584:	67 70       	andi	r22, 0x07	; 7
 586:	70 e0       	ldi	r23, 0x00	; 0
 588:	80 e0       	ldi	r24, 0x00	; 0
 58a:	90 e0       	ldi	r25, 0x00	; 0
 58c:	f9 d1       	rcall	.+1010   	; 0x980 <__floatsisf>
 58e:	33 d2       	rcall	.+1126   	; 0x9f6 <floor>
 590:	c6 d1       	rcall	.+908    	; 0x91e <__fixunssfsi>
		if (tiny_ADC_dendrite_cur_signals[i] == tiny_ADC_dendrite_prev_signals[i])
 592:	96 16       	cp	r9, r22
 594:	11 f0       	breq	.+4      	; 0x59a <tiny_ADC_dendrite_delta_potential+0x9a>
static void tiny_ADC_update_signal(void)
{
	for (int i = 0; i < tiny_ADC_dendrite_number; i++)
	{
		tiny_ADC_dendrite_prev_signals[i] = tiny_ADC_dendrite_cur_signals[i];
		tiny_ADC_dendrite_cur_signals[i] = floor(tiny_ADC_values[i] / 51);
 596:	68 83       	st	Y, r22
 598:	01 c0       	rjmp	.+2      	; 0x59c <tiny_ADC_dendrite_delta_potential+0x9c>
		if (tiny_ADC_dendrite_cur_signals[i] == tiny_ADC_dendrite_prev_signals[i])
		{
			tiny_ADC_dendrite_cur_signals[i] = no_signal;
 59a:	18 82       	st	Y, r1
 59c:	21 96       	adiw	r28, 0x01	; 1
	}
}

static void tiny_ADC_update_signal(void)
{
	for (int i = 0; i < tiny_ADC_dendrite_number; i++)
 59e:	cc 15       	cp	r28, r12
 5a0:	dd 05       	cpc	r29, r13
 5a2:	21 f7       	brne	.-56     	; 0x56c <tiny_ADC_dendrite_delta_potential+0x6c>
 5a4:	80 e0       	ldi	r24, 0x00	; 0
	tiny_ADC_dendrites_update_values();
	tiny_ADC_update_signal();
	uint8_t return_potential_val = 0;
	for (int i = 0; i < tiny_ADC_dendrite_number; i++)
	{
		switch(tiny_ADC_dendrite_cur_signals[i])
 5a6:	f8 01       	movw	r30, r16
 5a8:	91 91       	ld	r25, Z+
 5aa:	8f 01       	movw	r16, r30
 5ac:	92 30       	cpi	r25, 0x02	; 2
 5ae:	61 f0       	breq	.+24     	; 0x5c8 <tiny_ADC_dendrite_delta_potential+0xc8>
 5b0:	18 f4       	brcc	.+6      	; 0x5b8 <tiny_ADC_dendrite_delta_potential+0xb8>
 5b2:	91 30       	cpi	r25, 0x01	; 1
 5b4:	59 f0       	breq	.+22     	; 0x5cc <tiny_ADC_dendrite_delta_potential+0xcc>
 5b6:	0b c0       	rjmp	.+22     	; 0x5ce <tiny_ADC_dendrite_delta_potential+0xce>
 5b8:	93 30       	cpi	r25, 0x03	; 3
 5ba:	21 f0       	breq	.+8      	; 0x5c4 <tiny_ADC_dendrite_delta_potential+0xc4>
 5bc:	94 30       	cpi	r25, 0x04	; 4
 5be:	39 f4       	brne	.+14     	; 0x5ce <tiny_ADC_dendrite_delta_potential+0xce>
		{
			case no_signal:
				break;
			case high_excite_signal:
				return_potential_val += 26;
 5c0:	86 5e       	subi	r24, 0xE6	; 230
				break;
 5c2:	05 c0       	rjmp	.+10     	; 0x5ce <tiny_ADC_dendrite_delta_potential+0xce>
			case low_excite_signal:
				return_potential_val += 20;
 5c4:	8c 5e       	subi	r24, 0xEC	; 236
				break;
 5c6:	03 c0       	rjmp	.+6      	; 0x5ce <tiny_ADC_dendrite_delta_potential+0xce>
			case high_inhib_signal:
				return_potential_val -= 26;
 5c8:	8a 51       	subi	r24, 0x1A	; 26
				break;
 5ca:	01 c0       	rjmp	.+2      	; 0x5ce <tiny_ADC_dendrite_delta_potential+0xce>
			case low_inhib_signal:
				return_potential_val -=20;
 5cc:	84 51       	subi	r24, 0x14	; 20
int8_t tiny_ADC_dendrite_delta_potential()
{
	tiny_ADC_dendrites_update_values();
	tiny_ADC_update_signal();
	uint8_t return_potential_val = 0;
	for (int i = 0; i < tiny_ADC_dendrite_number; i++)
 5ce:	0c 15       	cp	r16, r12
 5d0:	1d 05       	cpc	r17, r13
 5d2:	49 f7       	brne	.-46     	; 0x5a6 <tiny_ADC_dendrite_delta_potential+0xa6>
			default:
				break;
		}
	}
	return return_potential_val;
}
 5d4:	df 91       	pop	r29
 5d6:	cf 91       	pop	r28
 5d8:	1f 91       	pop	r17
 5da:	0f 91       	pop	r16
 5dc:	ff 90       	pop	r15
 5de:	ef 90       	pop	r14
 5e0:	df 90       	pop	r13
 5e2:	cf 90       	pop	r12
 5e4:	bf 90       	pop	r11
 5e6:	af 90       	pop	r10
 5e8:	9f 90       	pop	r9
 5ea:	8f 90       	pop	r8
 5ec:	08 95       	ret

000005ee <tiny_timed_ISR_setflag>:
static _Bool tiny_timed_ISR_interruptflag = false;


void tiny_timed_ISR_setflag(_Bool new_flag_val)
{
	tiny_timed_ISR_interruptflag = new_flag_val;
 5ee:	80 93 28 3e 	sts	0x3E28, r24	; 0x803e28 <tiny_timed_ISR_interruptflag>
 5f2:	08 95       	ret

000005f4 <tiny_timed_ISR_getflag>:
}

_Bool tiny_timed_ISR_getflag(void)
{
	return tiny_timed_ISR_interruptflag;
 5f4:	80 91 28 3e 	lds	r24, 0x3E28	; 0x803e28 <tiny_timed_ISR_interruptflag>
 5f8:	08 95       	ret

000005fa <tiny_potential_master_update>:
{
	tiny_potential *= (1-exp(-(time_since_last_update/tiny_potential_time_const)));
}

void tiny_potential_master_update(double time_since_last_update)
{
 5fa:	8f 92       	push	r8
 5fc:	9f 92       	push	r9
 5fe:	af 92       	push	r10
 600:	bf 92       	push	r11
 602:	cf 92       	push	r12
 604:	df 92       	push	r13
 606:	ef 92       	push	r14
 608:	ff 92       	push	r15
 60a:	4b 01       	movw	r8, r22
 60c:	5c 01       	movw	r10, r24
	tiny_potential_manual_update(tiny_ADC_dendrite_delta_potential());//update potential from dendrites
 60e:	78 df       	rcall	.-272    	; 0x500 <tiny_ADC_dendrite_delta_potential>
#define post_fire_potential -80 //post-fire-potential is described as -80mV in the specs.

//update potential manually when a pulse is recieved or something else.
static void tiny_potential_manual_update(int8_t delta_potential)
{
	tiny_potential += delta_potential;
 610:	68 2f       	mov	r22, r24
 612:	88 0f       	add	r24, r24
 614:	77 0b       	sbc	r23, r23
 616:	88 0b       	sbc	r24, r24
 618:	99 0b       	sbc	r25, r25
 61a:	b2 d1       	rcall	.+868    	; 0x980 <__floatsisf>
 61c:	20 91 29 3e 	lds	r18, 0x3E29	; 0x803e29 <tiny_potential>
 620:	30 91 2a 3e 	lds	r19, 0x3E2A	; 0x803e2a <tiny_potential+0x1>
 624:	40 91 2b 3e 	lds	r20, 0x3E2B	; 0x803e2b <tiny_potential+0x2>
 628:	50 91 2c 3e 	lds	r21, 0x3E2C	; 0x803e2c <tiny_potential+0x3>
 62c:	54 d0       	rcall	.+168    	; 0x6d6 <__addsf3>
 62e:	6b 01       	movw	r12, r22
 630:	7c 01       	movw	r14, r24
 632:	60 93 29 3e 	sts	0x3E29, r22	; 0x803e29 <tiny_potential>
 636:	70 93 2a 3e 	sts	0x3E2A, r23	; 0x803e2a <tiny_potential+0x1>
 63a:	80 93 2b 3e 	sts	0x3E2B, r24	; 0x803e2b <tiny_potential+0x2>
 63e:	90 93 2c 3e 	sts	0x3E2C, r25	; 0x803e2c <tiny_potential+0x3>
}

void tiny_potential_master_update(double time_since_last_update)
{
	tiny_potential_manual_update(tiny_ADC_dendrite_delta_potential());//update potential from dendrites
	if (tiny_potential > 25)
 642:	20 e0       	ldi	r18, 0x00	; 0
 644:	30 e0       	ldi	r19, 0x00	; 0
 646:	48 ec       	ldi	r20, 0xC8	; 200
 648:	51 e4       	ldi	r21, 0x41	; 65
 64a:	c9 d2       	rcall	.+1426   	; 0xbde <__gesf2>
 64c:	18 16       	cp	r1, r24
 64e:	94 f4       	brge	.+36     	; 0x674 <tiny_potential_master_update+0x7a>
	{
		tiny_DAC_axon_set_fire();
 650:	53 df       	rcall	.-346    	; 0x4f8 <tiny_DAC_axon_set_fire>
}

//function to set 
static void tiny_potential_manual_set(int8_t new_potential)
{
	tiny_potential = new_potential;
 652:	80 e0       	ldi	r24, 0x00	; 0
 654:	90 e0       	ldi	r25, 0x00	; 0
 656:	a0 ea       	ldi	r26, 0xA0	; 160
 658:	b2 ec       	ldi	r27, 0xC2	; 194
 65a:	80 93 29 3e 	sts	0x3E29, r24	; 0x803e29 <tiny_potential>
 65e:	90 93 2a 3e 	sts	0x3E2A, r25	; 0x803e2a <tiny_potential+0x1>
 662:	a0 93 2b 3e 	sts	0x3E2B, r26	; 0x803e2b <tiny_potential+0x2>
 666:	b0 93 2c 3e 	sts	0x3E2C, r27	; 0x803e2c <tiny_potential+0x3>
	tiny_potential_manual_update(tiny_ADC_dendrite_delta_potential());//update potential from dendrites
	if (tiny_potential > 25)
	{
		tiny_DAC_axon_set_fire();
		tiny_potential_manual_set(post_fire_potential);
		Potential_to_RGB_write_potential_on_LEDs(tiny_potential, true);
 66a:	41 e0       	ldi	r20, 0x01	; 1
 66c:	bc 01       	movw	r22, r24
 66e:	cd 01       	movw	r24, r26
 670:	49 dd       	rcall	.-1390   	; 0x104 <Potential_to_RGB_write_potential_on_LEDs>
 672:	04 c0       	rjmp	.+8      	; 0x67c <tiny_potential_master_update+0x82>
	}
	else
	{
		Potential_to_RGB_write_potential_on_LEDs(tiny_potential, false);
 674:	40 e0       	ldi	r20, 0x00	; 0
 676:	c7 01       	movw	r24, r14
 678:	b6 01       	movw	r22, r12
 67a:	44 dd       	rcall	.-1400   	; 0x104 <Potential_to_RGB_write_potential_on_LEDs>


//function to update potential as it should decay over time and converge towards 0.
static void tiny_potential_time_update(double time_since_last_update)//time since last update will have to be given in ms, and therefore needs precision.
{
	tiny_potential *= (1-exp(-(time_since_last_update/tiny_potential_time_const)));
 67c:	20 e0       	ldi	r18, 0x00	; 0
 67e:	30 e0       	ldi	r19, 0x00	; 0
 680:	48 e4       	ldi	r20, 0x48	; 72
 682:	52 e4       	ldi	r21, 0x42	; 66
 684:	c5 01       	movw	r24, r10
 686:	b4 01       	movw	r22, r8
 688:	97 d0       	rcall	.+302    	; 0x7b8 <__divsf3>
 68a:	90 58       	subi	r25, 0x80	; 128
 68c:	0f d1       	rcall	.+542    	; 0x8ac <exp>
 68e:	9b 01       	movw	r18, r22
 690:	ac 01       	movw	r20, r24
 692:	60 e0       	ldi	r22, 0x00	; 0
 694:	70 e0       	ldi	r23, 0x00	; 0
 696:	80 e8       	ldi	r24, 0x80	; 128
 698:	9f e3       	ldi	r25, 0x3F	; 63
 69a:	1c d0       	rcall	.+56     	; 0x6d4 <__subsf3>
 69c:	9b 01       	movw	r18, r22
 69e:	ac 01       	movw	r20, r24
 6a0:	60 91 29 3e 	lds	r22, 0x3E29	; 0x803e29 <tiny_potential>
 6a4:	70 91 2a 3e 	lds	r23, 0x3E2A	; 0x803e2a <tiny_potential+0x1>
 6a8:	80 91 2b 3e 	lds	r24, 0x3E2B	; 0x803e2b <tiny_potential+0x2>
 6ac:	90 91 2c 3e 	lds	r25, 0x3E2C	; 0x803e2c <tiny_potential+0x3>
 6b0:	11 d3       	rcall	.+1570   	; 0xcd4 <__mulsf3>
 6b2:	60 93 29 3e 	sts	0x3E29, r22	; 0x803e29 <tiny_potential>
 6b6:	70 93 2a 3e 	sts	0x3E2A, r23	; 0x803e2a <tiny_potential+0x1>
 6ba:	80 93 2b 3e 	sts	0x3E2B, r24	; 0x803e2b <tiny_potential+0x2>
 6be:	90 93 2c 3e 	sts	0x3E2C, r25	; 0x803e2c <tiny_potential+0x3>
	else
	{
		Potential_to_RGB_write_potential_on_LEDs(tiny_potential, false);
	}
	tiny_potential_time_update(time_since_last_update);
}
 6c2:	ff 90       	pop	r15
 6c4:	ef 90       	pop	r14
 6c6:	df 90       	pop	r13
 6c8:	cf 90       	pop	r12
 6ca:	bf 90       	pop	r11
 6cc:	af 90       	pop	r10
 6ce:	9f 90       	pop	r9
 6d0:	8f 90       	pop	r8
 6d2:	08 95       	ret

000006d4 <__subsf3>:
 6d4:	50 58       	subi	r21, 0x80	; 128

000006d6 <__addsf3>:
 6d6:	bb 27       	eor	r27, r27
 6d8:	aa 27       	eor	r26, r26
 6da:	0e 94 82 03 	call	0x704	; 0x704 <__addsf3x>
 6de:	0c 94 9d 05 	jmp	0xb3a	; 0xb3a <__fp_round>
 6e2:	0e 94 8f 05 	call	0xb1e	; 0xb1e <__fp_pscA>
 6e6:	38 f0       	brcs	.+14     	; 0x6f6 <__addsf3+0x20>
 6e8:	0e 94 96 05 	call	0xb2c	; 0xb2c <__fp_pscB>
 6ec:	20 f0       	brcs	.+8      	; 0x6f6 <__addsf3+0x20>
 6ee:	39 f4       	brne	.+14     	; 0x6fe <__addsf3+0x28>
 6f0:	9f 3f       	cpi	r25, 0xFF	; 255
 6f2:	19 f4       	brne	.+6      	; 0x6fa <__addsf3+0x24>
 6f4:	26 f4       	brtc	.+8      	; 0x6fe <__addsf3+0x28>
 6f6:	0c 94 65 05 	jmp	0xaca	; 0xaca <__fp_nan>
 6fa:	0e f4       	brtc	.+2      	; 0x6fe <__addsf3+0x28>
 6fc:	e0 95       	com	r30
 6fe:	e7 fb       	bst	r30, 7
 700:	0c 94 36 05 	jmp	0xa6c	; 0xa6c <__fp_inf>

00000704 <__addsf3x>:
 704:	e9 2f       	mov	r30, r25
 706:	0e 94 ae 05 	call	0xb5c	; 0xb5c <__fp_split3>
 70a:	58 f3       	brcs	.-42     	; 0x6e2 <__addsf3+0xc>
 70c:	ba 17       	cp	r27, r26
 70e:	62 07       	cpc	r22, r18
 710:	73 07       	cpc	r23, r19
 712:	84 07       	cpc	r24, r20
 714:	95 07       	cpc	r25, r21
 716:	20 f0       	brcs	.+8      	; 0x720 <__addsf3x+0x1c>
 718:	79 f4       	brne	.+30     	; 0x738 <__addsf3x+0x34>
 71a:	a6 f5       	brtc	.+104    	; 0x784 <__addsf3x+0x80>
 71c:	0c 94 e8 05 	jmp	0xbd0	; 0xbd0 <__fp_zero>
 720:	0e f4       	brtc	.+2      	; 0x724 <__addsf3x+0x20>
 722:	e0 95       	com	r30
 724:	0b 2e       	mov	r0, r27
 726:	ba 2f       	mov	r27, r26
 728:	a0 2d       	mov	r26, r0
 72a:	0b 01       	movw	r0, r22
 72c:	b9 01       	movw	r22, r18
 72e:	90 01       	movw	r18, r0
 730:	0c 01       	movw	r0, r24
 732:	ca 01       	movw	r24, r20
 734:	a0 01       	movw	r20, r0
 736:	11 24       	eor	r1, r1
 738:	ff 27       	eor	r31, r31
 73a:	59 1b       	sub	r21, r25
 73c:	99 f0       	breq	.+38     	; 0x764 <__addsf3x+0x60>
 73e:	59 3f       	cpi	r21, 0xF9	; 249
 740:	50 f4       	brcc	.+20     	; 0x756 <__addsf3x+0x52>
 742:	50 3e       	cpi	r21, 0xE0	; 224
 744:	68 f1       	brcs	.+90     	; 0x7a0 <__addsf3x+0x9c>
 746:	1a 16       	cp	r1, r26
 748:	f0 40       	sbci	r31, 0x00	; 0
 74a:	a2 2f       	mov	r26, r18
 74c:	23 2f       	mov	r18, r19
 74e:	34 2f       	mov	r19, r20
 750:	44 27       	eor	r20, r20
 752:	58 5f       	subi	r21, 0xF8	; 248
 754:	f3 cf       	rjmp	.-26     	; 0x73c <__addsf3x+0x38>
 756:	46 95       	lsr	r20
 758:	37 95       	ror	r19
 75a:	27 95       	ror	r18
 75c:	a7 95       	ror	r26
 75e:	f0 40       	sbci	r31, 0x00	; 0
 760:	53 95       	inc	r21
 762:	c9 f7       	brne	.-14     	; 0x756 <__addsf3x+0x52>
 764:	7e f4       	brtc	.+30     	; 0x784 <__addsf3x+0x80>
 766:	1f 16       	cp	r1, r31
 768:	ba 0b       	sbc	r27, r26
 76a:	62 0b       	sbc	r22, r18
 76c:	73 0b       	sbc	r23, r19
 76e:	84 0b       	sbc	r24, r20
 770:	ba f0       	brmi	.+46     	; 0x7a0 <__addsf3x+0x9c>
 772:	91 50       	subi	r25, 0x01	; 1
 774:	a1 f0       	breq	.+40     	; 0x79e <__addsf3x+0x9a>
 776:	ff 0f       	add	r31, r31
 778:	bb 1f       	adc	r27, r27
 77a:	66 1f       	adc	r22, r22
 77c:	77 1f       	adc	r23, r23
 77e:	88 1f       	adc	r24, r24
 780:	c2 f7       	brpl	.-16     	; 0x772 <__addsf3x+0x6e>
 782:	0e c0       	rjmp	.+28     	; 0x7a0 <__addsf3x+0x9c>
 784:	ba 0f       	add	r27, r26
 786:	62 1f       	adc	r22, r18
 788:	73 1f       	adc	r23, r19
 78a:	84 1f       	adc	r24, r20
 78c:	48 f4       	brcc	.+18     	; 0x7a0 <__addsf3x+0x9c>
 78e:	87 95       	ror	r24
 790:	77 95       	ror	r23
 792:	67 95       	ror	r22
 794:	b7 95       	ror	r27
 796:	f7 95       	ror	r31
 798:	9e 3f       	cpi	r25, 0xFE	; 254
 79a:	08 f0       	brcs	.+2      	; 0x79e <__addsf3x+0x9a>
 79c:	b0 cf       	rjmp	.-160    	; 0x6fe <__addsf3+0x28>
 79e:	93 95       	inc	r25
 7a0:	88 0f       	add	r24, r24
 7a2:	08 f0       	brcs	.+2      	; 0x7a6 <__addsf3x+0xa2>
 7a4:	99 27       	eor	r25, r25
 7a6:	ee 0f       	add	r30, r30
 7a8:	97 95       	ror	r25
 7aa:	87 95       	ror	r24
 7ac:	08 95       	ret

000007ae <__cmpsf2>:
 7ae:	0e 94 12 05 	call	0xa24	; 0xa24 <__fp_cmp>
 7b2:	08 f4       	brcc	.+2      	; 0x7b6 <__cmpsf2+0x8>
 7b4:	81 e0       	ldi	r24, 0x01	; 1
 7b6:	08 95       	ret

000007b8 <__divsf3>:
 7b8:	0e 94 f0 03 	call	0x7e0	; 0x7e0 <__divsf3x>
 7bc:	0c 94 9d 05 	jmp	0xb3a	; 0xb3a <__fp_round>
 7c0:	0e 94 96 05 	call	0xb2c	; 0xb2c <__fp_pscB>
 7c4:	58 f0       	brcs	.+22     	; 0x7dc <__divsf3+0x24>
 7c6:	0e 94 8f 05 	call	0xb1e	; 0xb1e <__fp_pscA>
 7ca:	40 f0       	brcs	.+16     	; 0x7dc <__divsf3+0x24>
 7cc:	29 f4       	brne	.+10     	; 0x7d8 <__divsf3+0x20>
 7ce:	5f 3f       	cpi	r21, 0xFF	; 255
 7d0:	29 f0       	breq	.+10     	; 0x7dc <__divsf3+0x24>
 7d2:	0c 94 36 05 	jmp	0xa6c	; 0xa6c <__fp_inf>
 7d6:	51 11       	cpse	r21, r1
 7d8:	0c 94 e9 05 	jmp	0xbd2	; 0xbd2 <__fp_szero>
 7dc:	0c 94 65 05 	jmp	0xaca	; 0xaca <__fp_nan>

000007e0 <__divsf3x>:
 7e0:	0e 94 ae 05 	call	0xb5c	; 0xb5c <__fp_split3>
 7e4:	68 f3       	brcs	.-38     	; 0x7c0 <__divsf3+0x8>

000007e6 <__divsf3_pse>:
 7e6:	99 23       	and	r25, r25
 7e8:	b1 f3       	breq	.-20     	; 0x7d6 <__divsf3+0x1e>
 7ea:	55 23       	and	r21, r21
 7ec:	91 f3       	breq	.-28     	; 0x7d2 <__divsf3+0x1a>
 7ee:	95 1b       	sub	r25, r21
 7f0:	55 0b       	sbc	r21, r21
 7f2:	bb 27       	eor	r27, r27
 7f4:	aa 27       	eor	r26, r26
 7f6:	62 17       	cp	r22, r18
 7f8:	73 07       	cpc	r23, r19
 7fa:	84 07       	cpc	r24, r20
 7fc:	38 f0       	brcs	.+14     	; 0x80c <__divsf3_pse+0x26>
 7fe:	9f 5f       	subi	r25, 0xFF	; 255
 800:	5f 4f       	sbci	r21, 0xFF	; 255
 802:	22 0f       	add	r18, r18
 804:	33 1f       	adc	r19, r19
 806:	44 1f       	adc	r20, r20
 808:	aa 1f       	adc	r26, r26
 80a:	a9 f3       	breq	.-22     	; 0x7f6 <__divsf3_pse+0x10>
 80c:	35 d0       	rcall	.+106    	; 0x878 <__divsf3_pse+0x92>
 80e:	0e 2e       	mov	r0, r30
 810:	3a f0       	brmi	.+14     	; 0x820 <__divsf3_pse+0x3a>
 812:	e0 e8       	ldi	r30, 0x80	; 128
 814:	32 d0       	rcall	.+100    	; 0x87a <__divsf3_pse+0x94>
 816:	91 50       	subi	r25, 0x01	; 1
 818:	50 40       	sbci	r21, 0x00	; 0
 81a:	e6 95       	lsr	r30
 81c:	00 1c       	adc	r0, r0
 81e:	ca f7       	brpl	.-14     	; 0x812 <__divsf3_pse+0x2c>
 820:	2b d0       	rcall	.+86     	; 0x878 <__divsf3_pse+0x92>
 822:	fe 2f       	mov	r31, r30
 824:	29 d0       	rcall	.+82     	; 0x878 <__divsf3_pse+0x92>
 826:	66 0f       	add	r22, r22
 828:	77 1f       	adc	r23, r23
 82a:	88 1f       	adc	r24, r24
 82c:	bb 1f       	adc	r27, r27
 82e:	26 17       	cp	r18, r22
 830:	37 07       	cpc	r19, r23
 832:	48 07       	cpc	r20, r24
 834:	ab 07       	cpc	r26, r27
 836:	b0 e8       	ldi	r27, 0x80	; 128
 838:	09 f0       	breq	.+2      	; 0x83c <__divsf3_pse+0x56>
 83a:	bb 0b       	sbc	r27, r27
 83c:	80 2d       	mov	r24, r0
 83e:	bf 01       	movw	r22, r30
 840:	ff 27       	eor	r31, r31
 842:	93 58       	subi	r25, 0x83	; 131
 844:	5f 4f       	sbci	r21, 0xFF	; 255
 846:	3a f0       	brmi	.+14     	; 0x856 <__divsf3_pse+0x70>
 848:	9e 3f       	cpi	r25, 0xFE	; 254
 84a:	51 05       	cpc	r21, r1
 84c:	78 f0       	brcs	.+30     	; 0x86c <__divsf3_pse+0x86>
 84e:	0c 94 36 05 	jmp	0xa6c	; 0xa6c <__fp_inf>
 852:	0c 94 e9 05 	jmp	0xbd2	; 0xbd2 <__fp_szero>
 856:	5f 3f       	cpi	r21, 0xFF	; 255
 858:	e4 f3       	brlt	.-8      	; 0x852 <__divsf3_pse+0x6c>
 85a:	98 3e       	cpi	r25, 0xE8	; 232
 85c:	d4 f3       	brlt	.-12     	; 0x852 <__divsf3_pse+0x6c>
 85e:	86 95       	lsr	r24
 860:	77 95       	ror	r23
 862:	67 95       	ror	r22
 864:	b7 95       	ror	r27
 866:	f7 95       	ror	r31
 868:	9f 5f       	subi	r25, 0xFF	; 255
 86a:	c9 f7       	brne	.-14     	; 0x85e <__divsf3_pse+0x78>
 86c:	88 0f       	add	r24, r24
 86e:	91 1d       	adc	r25, r1
 870:	96 95       	lsr	r25
 872:	87 95       	ror	r24
 874:	97 f9       	bld	r25, 7
 876:	08 95       	ret
 878:	e1 e0       	ldi	r30, 0x01	; 1
 87a:	66 0f       	add	r22, r22
 87c:	77 1f       	adc	r23, r23
 87e:	88 1f       	adc	r24, r24
 880:	bb 1f       	adc	r27, r27
 882:	62 17       	cp	r22, r18
 884:	73 07       	cpc	r23, r19
 886:	84 07       	cpc	r24, r20
 888:	ba 07       	cpc	r27, r26
 88a:	20 f0       	brcs	.+8      	; 0x894 <__divsf3_pse+0xae>
 88c:	62 1b       	sub	r22, r18
 88e:	73 0b       	sbc	r23, r19
 890:	84 0b       	sbc	r24, r20
 892:	ba 0b       	sbc	r27, r26
 894:	ee 1f       	adc	r30, r30
 896:	88 f7       	brcc	.-30     	; 0x87a <__divsf3_pse+0x94>
 898:	e0 95       	com	r30
 89a:	08 95       	ret
 89c:	29 f4       	brne	.+10     	; 0x8a8 <__divsf3_pse+0xc2>
 89e:	16 f0       	brts	.+4      	; 0x8a4 <__divsf3_pse+0xbe>
 8a0:	0c 94 36 05 	jmp	0xa6c	; 0xa6c <__fp_inf>
 8a4:	0c 94 e8 05 	jmp	0xbd0	; 0xbd0 <__fp_zero>
 8a8:	0c 94 65 05 	jmp	0xaca	; 0xaca <__fp_nan>

000008ac <exp>:
 8ac:	0e 94 b6 05 	call	0xb6c	; 0xb6c <__fp_splitA>
 8b0:	a8 f3       	brcs	.-22     	; 0x89c <__divsf3_pse+0xb6>
 8b2:	96 38       	cpi	r25, 0x86	; 134
 8b4:	a0 f7       	brcc	.-24     	; 0x89e <__divsf3_pse+0xb8>
 8b6:	07 f8       	bld	r0, 7
 8b8:	0f 92       	push	r0
 8ba:	e8 94       	clt
 8bc:	2b e3       	ldi	r18, 0x3B	; 59
 8be:	3a ea       	ldi	r19, 0xAA	; 170
 8c0:	48 eb       	ldi	r20, 0xB8	; 184
 8c2:	5f e7       	ldi	r21, 0x7F	; 127
 8c4:	0e 94 80 06 	call	0xd00	; 0xd00 <__mulsf3_pse>
 8c8:	0f 92       	push	r0
 8ca:	0f 92       	push	r0
 8cc:	0f 92       	push	r0
 8ce:	4d b7       	in	r20, 0x3d	; 61
 8d0:	5e b7       	in	r21, 0x3e	; 62
 8d2:	0f 92       	push	r0
 8d4:	0e 94 36 06 	call	0xc6c	; 0xc6c <modf>
 8d8:	e4 e3       	ldi	r30, 0x34	; 52
 8da:	f0 e0       	ldi	r31, 0x00	; 0
 8dc:	0e 94 68 05 	call	0xad0	; 0xad0 <__fp_powser>
 8e0:	4f 91       	pop	r20
 8e2:	5f 91       	pop	r21
 8e4:	ef 91       	pop	r30
 8e6:	ff 91       	pop	r31
 8e8:	e5 95       	asr	r30
 8ea:	ee 1f       	adc	r30, r30
 8ec:	ff 1f       	adc	r31, r31
 8ee:	49 f0       	breq	.+18     	; 0x902 <exp+0x56>
 8f0:	fe 57       	subi	r31, 0x7E	; 126
 8f2:	e0 68       	ori	r30, 0x80	; 128
 8f4:	44 27       	eor	r20, r20
 8f6:	ee 0f       	add	r30, r30
 8f8:	44 1f       	adc	r20, r20
 8fa:	fa 95       	dec	r31
 8fc:	e1 f7       	brne	.-8      	; 0x8f6 <exp+0x4a>
 8fe:	41 95       	neg	r20
 900:	55 0b       	sbc	r21, r21
 902:	0e 94 00 06 	call	0xc00	; 0xc00 <ldexp>
 906:	0f 90       	pop	r0
 908:	07 fe       	sbrs	r0, 7
 90a:	0c 94 f4 05 	jmp	0xbe8	; 0xbe8 <inverse>
 90e:	08 95       	ret

00000910 <__fixsfsi>:
 910:	0e 94 8f 04 	call	0x91e	; 0x91e <__fixunssfsi>
 914:	68 94       	set
 916:	b1 11       	cpse	r27, r1
 918:	0c 94 e9 05 	jmp	0xbd2	; 0xbd2 <__fp_szero>
 91c:	08 95       	ret

0000091e <__fixunssfsi>:
 91e:	0e 94 b6 05 	call	0xb6c	; 0xb6c <__fp_splitA>
 922:	88 f0       	brcs	.+34     	; 0x946 <__fixunssfsi+0x28>
 924:	9f 57       	subi	r25, 0x7F	; 127
 926:	98 f0       	brcs	.+38     	; 0x94e <__fixunssfsi+0x30>
 928:	b9 2f       	mov	r27, r25
 92a:	99 27       	eor	r25, r25
 92c:	b7 51       	subi	r27, 0x17	; 23
 92e:	b0 f0       	brcs	.+44     	; 0x95c <__fixunssfsi+0x3e>
 930:	e1 f0       	breq	.+56     	; 0x96a <__fixunssfsi+0x4c>
 932:	66 0f       	add	r22, r22
 934:	77 1f       	adc	r23, r23
 936:	88 1f       	adc	r24, r24
 938:	99 1f       	adc	r25, r25
 93a:	1a f0       	brmi	.+6      	; 0x942 <__fixunssfsi+0x24>
 93c:	ba 95       	dec	r27
 93e:	c9 f7       	brne	.-14     	; 0x932 <__fixunssfsi+0x14>
 940:	14 c0       	rjmp	.+40     	; 0x96a <__fixunssfsi+0x4c>
 942:	b1 30       	cpi	r27, 0x01	; 1
 944:	91 f0       	breq	.+36     	; 0x96a <__fixunssfsi+0x4c>
 946:	0e 94 e8 05 	call	0xbd0	; 0xbd0 <__fp_zero>
 94a:	b1 e0       	ldi	r27, 0x01	; 1
 94c:	08 95       	ret
 94e:	0c 94 e8 05 	jmp	0xbd0	; 0xbd0 <__fp_zero>
 952:	67 2f       	mov	r22, r23
 954:	78 2f       	mov	r23, r24
 956:	88 27       	eor	r24, r24
 958:	b8 5f       	subi	r27, 0xF8	; 248
 95a:	39 f0       	breq	.+14     	; 0x96a <__fixunssfsi+0x4c>
 95c:	b9 3f       	cpi	r27, 0xF9	; 249
 95e:	cc f3       	brlt	.-14     	; 0x952 <__fixunssfsi+0x34>
 960:	86 95       	lsr	r24
 962:	77 95       	ror	r23
 964:	67 95       	ror	r22
 966:	b3 95       	inc	r27
 968:	d9 f7       	brne	.-10     	; 0x960 <__fixunssfsi+0x42>
 96a:	3e f4       	brtc	.+14     	; 0x97a <__fixunssfsi+0x5c>
 96c:	90 95       	com	r25
 96e:	80 95       	com	r24
 970:	70 95       	com	r23
 972:	61 95       	neg	r22
 974:	7f 4f       	sbci	r23, 0xFF	; 255
 976:	8f 4f       	sbci	r24, 0xFF	; 255
 978:	9f 4f       	sbci	r25, 0xFF	; 255
 97a:	08 95       	ret

0000097c <__floatunsisf>:
 97c:	e8 94       	clt
 97e:	09 c0       	rjmp	.+18     	; 0x992 <__floatsisf+0x12>

00000980 <__floatsisf>:
 980:	97 fb       	bst	r25, 7
 982:	3e f4       	brtc	.+14     	; 0x992 <__floatsisf+0x12>
 984:	90 95       	com	r25
 986:	80 95       	com	r24
 988:	70 95       	com	r23
 98a:	61 95       	neg	r22
 98c:	7f 4f       	sbci	r23, 0xFF	; 255
 98e:	8f 4f       	sbci	r24, 0xFF	; 255
 990:	9f 4f       	sbci	r25, 0xFF	; 255
 992:	99 23       	and	r25, r25
 994:	a9 f0       	breq	.+42     	; 0x9c0 <__floatsisf+0x40>
 996:	f9 2f       	mov	r31, r25
 998:	96 e9       	ldi	r25, 0x96	; 150
 99a:	bb 27       	eor	r27, r27
 99c:	93 95       	inc	r25
 99e:	f6 95       	lsr	r31
 9a0:	87 95       	ror	r24
 9a2:	77 95       	ror	r23
 9a4:	67 95       	ror	r22
 9a6:	b7 95       	ror	r27
 9a8:	f1 11       	cpse	r31, r1
 9aa:	f8 cf       	rjmp	.-16     	; 0x99c <__floatsisf+0x1c>
 9ac:	fa f4       	brpl	.+62     	; 0x9ec <__floatsisf+0x6c>
 9ae:	bb 0f       	add	r27, r27
 9b0:	11 f4       	brne	.+4      	; 0x9b6 <__floatsisf+0x36>
 9b2:	60 ff       	sbrs	r22, 0
 9b4:	1b c0       	rjmp	.+54     	; 0x9ec <__floatsisf+0x6c>
 9b6:	6f 5f       	subi	r22, 0xFF	; 255
 9b8:	7f 4f       	sbci	r23, 0xFF	; 255
 9ba:	8f 4f       	sbci	r24, 0xFF	; 255
 9bc:	9f 4f       	sbci	r25, 0xFF	; 255
 9be:	16 c0       	rjmp	.+44     	; 0x9ec <__floatsisf+0x6c>
 9c0:	88 23       	and	r24, r24
 9c2:	11 f0       	breq	.+4      	; 0x9c8 <__floatsisf+0x48>
 9c4:	96 e9       	ldi	r25, 0x96	; 150
 9c6:	11 c0       	rjmp	.+34     	; 0x9ea <__floatsisf+0x6a>
 9c8:	77 23       	and	r23, r23
 9ca:	21 f0       	breq	.+8      	; 0x9d4 <__floatsisf+0x54>
 9cc:	9e e8       	ldi	r25, 0x8E	; 142
 9ce:	87 2f       	mov	r24, r23
 9d0:	76 2f       	mov	r23, r22
 9d2:	05 c0       	rjmp	.+10     	; 0x9de <__floatsisf+0x5e>
 9d4:	66 23       	and	r22, r22
 9d6:	71 f0       	breq	.+28     	; 0x9f4 <__floatsisf+0x74>
 9d8:	96 e8       	ldi	r25, 0x86	; 134
 9da:	86 2f       	mov	r24, r22
 9dc:	70 e0       	ldi	r23, 0x00	; 0
 9de:	60 e0       	ldi	r22, 0x00	; 0
 9e0:	2a f0       	brmi	.+10     	; 0x9ec <__floatsisf+0x6c>
 9e2:	9a 95       	dec	r25
 9e4:	66 0f       	add	r22, r22
 9e6:	77 1f       	adc	r23, r23
 9e8:	88 1f       	adc	r24, r24
 9ea:	da f7       	brpl	.-10     	; 0x9e2 <__floatsisf+0x62>
 9ec:	88 0f       	add	r24, r24
 9ee:	96 95       	lsr	r25
 9f0:	87 95       	ror	r24
 9f2:	97 f9       	bld	r25, 7
 9f4:	08 95       	ret

000009f6 <floor>:
 9f6:	0e 94 d0 05 	call	0xba0	; 0xba0 <__fp_trunc>
 9fa:	90 f0       	brcs	.+36     	; 0xa20 <floor+0x2a>
 9fc:	9f 37       	cpi	r25, 0x7F	; 127
 9fe:	48 f4       	brcc	.+18     	; 0xa12 <floor+0x1c>
 a00:	91 11       	cpse	r25, r1
 a02:	16 f0       	brts	.+4      	; 0xa08 <floor+0x12>
 a04:	0c 94 e9 05 	jmp	0xbd2	; 0xbd2 <__fp_szero>
 a08:	60 e0       	ldi	r22, 0x00	; 0
 a0a:	70 e0       	ldi	r23, 0x00	; 0
 a0c:	80 e8       	ldi	r24, 0x80	; 128
 a0e:	9f eb       	ldi	r25, 0xBF	; 191
 a10:	08 95       	ret
 a12:	26 f4       	brtc	.+8      	; 0xa1c <floor+0x26>
 a14:	1b 16       	cp	r1, r27
 a16:	61 1d       	adc	r22, r1
 a18:	71 1d       	adc	r23, r1
 a1a:	81 1d       	adc	r24, r1
 a1c:	0c 94 3c 05 	jmp	0xa78	; 0xa78 <__fp_mintl>
 a20:	0c 94 57 05 	jmp	0xaae	; 0xaae <__fp_mpack>

00000a24 <__fp_cmp>:
 a24:	99 0f       	add	r25, r25
 a26:	00 08       	sbc	r0, r0
 a28:	55 0f       	add	r21, r21
 a2a:	aa 0b       	sbc	r26, r26
 a2c:	e0 e8       	ldi	r30, 0x80	; 128
 a2e:	fe ef       	ldi	r31, 0xFE	; 254
 a30:	16 16       	cp	r1, r22
 a32:	17 06       	cpc	r1, r23
 a34:	e8 07       	cpc	r30, r24
 a36:	f9 07       	cpc	r31, r25
 a38:	c0 f0       	brcs	.+48     	; 0xa6a <__fp_cmp+0x46>
 a3a:	12 16       	cp	r1, r18
 a3c:	13 06       	cpc	r1, r19
 a3e:	e4 07       	cpc	r30, r20
 a40:	f5 07       	cpc	r31, r21
 a42:	98 f0       	brcs	.+38     	; 0xa6a <__fp_cmp+0x46>
 a44:	62 1b       	sub	r22, r18
 a46:	73 0b       	sbc	r23, r19
 a48:	84 0b       	sbc	r24, r20
 a4a:	95 0b       	sbc	r25, r21
 a4c:	39 f4       	brne	.+14     	; 0xa5c <__fp_cmp+0x38>
 a4e:	0a 26       	eor	r0, r26
 a50:	61 f0       	breq	.+24     	; 0xa6a <__fp_cmp+0x46>
 a52:	23 2b       	or	r18, r19
 a54:	24 2b       	or	r18, r20
 a56:	25 2b       	or	r18, r21
 a58:	21 f4       	brne	.+8      	; 0xa62 <__fp_cmp+0x3e>
 a5a:	08 95       	ret
 a5c:	0a 26       	eor	r0, r26
 a5e:	09 f4       	brne	.+2      	; 0xa62 <__fp_cmp+0x3e>
 a60:	a1 40       	sbci	r26, 0x01	; 1
 a62:	a6 95       	lsr	r26
 a64:	8f ef       	ldi	r24, 0xFF	; 255
 a66:	81 1d       	adc	r24, r1
 a68:	81 1d       	adc	r24, r1
 a6a:	08 95       	ret

00000a6c <__fp_inf>:
 a6c:	97 f9       	bld	r25, 7
 a6e:	9f 67       	ori	r25, 0x7F	; 127
 a70:	80 e8       	ldi	r24, 0x80	; 128
 a72:	70 e0       	ldi	r23, 0x00	; 0
 a74:	60 e0       	ldi	r22, 0x00	; 0
 a76:	08 95       	ret

00000a78 <__fp_mintl>:
 a78:	88 23       	and	r24, r24
 a7a:	71 f4       	brne	.+28     	; 0xa98 <__fp_mintl+0x20>
 a7c:	77 23       	and	r23, r23
 a7e:	21 f0       	breq	.+8      	; 0xa88 <__fp_mintl+0x10>
 a80:	98 50       	subi	r25, 0x08	; 8
 a82:	87 2b       	or	r24, r23
 a84:	76 2f       	mov	r23, r22
 a86:	07 c0       	rjmp	.+14     	; 0xa96 <__fp_mintl+0x1e>
 a88:	66 23       	and	r22, r22
 a8a:	11 f4       	brne	.+4      	; 0xa90 <__fp_mintl+0x18>
 a8c:	99 27       	eor	r25, r25
 a8e:	0d c0       	rjmp	.+26     	; 0xaaa <__fp_mintl+0x32>
 a90:	90 51       	subi	r25, 0x10	; 16
 a92:	86 2b       	or	r24, r22
 a94:	70 e0       	ldi	r23, 0x00	; 0
 a96:	60 e0       	ldi	r22, 0x00	; 0
 a98:	2a f0       	brmi	.+10     	; 0xaa4 <__fp_mintl+0x2c>
 a9a:	9a 95       	dec	r25
 a9c:	66 0f       	add	r22, r22
 a9e:	77 1f       	adc	r23, r23
 aa0:	88 1f       	adc	r24, r24
 aa2:	da f7       	brpl	.-10     	; 0xa9a <__fp_mintl+0x22>
 aa4:	88 0f       	add	r24, r24
 aa6:	96 95       	lsr	r25
 aa8:	87 95       	ror	r24
 aaa:	97 f9       	bld	r25, 7
 aac:	08 95       	ret

00000aae <__fp_mpack>:
 aae:	9f 3f       	cpi	r25, 0xFF	; 255
 ab0:	31 f0       	breq	.+12     	; 0xabe <__fp_mpack_finite+0xc>

00000ab2 <__fp_mpack_finite>:
 ab2:	91 50       	subi	r25, 0x01	; 1
 ab4:	20 f4       	brcc	.+8      	; 0xabe <__fp_mpack_finite+0xc>
 ab6:	87 95       	ror	r24
 ab8:	77 95       	ror	r23
 aba:	67 95       	ror	r22
 abc:	b7 95       	ror	r27
 abe:	88 0f       	add	r24, r24
 ac0:	91 1d       	adc	r25, r1
 ac2:	96 95       	lsr	r25
 ac4:	87 95       	ror	r24
 ac6:	97 f9       	bld	r25, 7
 ac8:	08 95       	ret

00000aca <__fp_nan>:
 aca:	9f ef       	ldi	r25, 0xFF	; 255
 acc:	80 ec       	ldi	r24, 0xC0	; 192
 ace:	08 95       	ret

00000ad0 <__fp_powser>:
 ad0:	df 93       	push	r29
 ad2:	cf 93       	push	r28
 ad4:	1f 93       	push	r17
 ad6:	0f 93       	push	r16
 ad8:	ff 92       	push	r15
 ada:	ef 92       	push	r14
 adc:	df 92       	push	r13
 ade:	7b 01       	movw	r14, r22
 ae0:	8c 01       	movw	r16, r24
 ae2:	68 94       	set
 ae4:	06 c0       	rjmp	.+12     	; 0xaf2 <__fp_powser+0x22>
 ae6:	da 2e       	mov	r13, r26
 ae8:	ef 01       	movw	r28, r30
 aea:	0e 94 7d 06 	call	0xcfa	; 0xcfa <__mulsf3x>
 aee:	fe 01       	movw	r30, r28
 af0:	e8 94       	clt
 af2:	a5 91       	lpm	r26, Z+
 af4:	25 91       	lpm	r18, Z+
 af6:	35 91       	lpm	r19, Z+
 af8:	45 91       	lpm	r20, Z+
 afa:	55 91       	lpm	r21, Z+
 afc:	a6 f3       	brts	.-24     	; 0xae6 <__fp_powser+0x16>
 afe:	ef 01       	movw	r28, r30
 b00:	0e 94 82 03 	call	0x704	; 0x704 <__addsf3x>
 b04:	fe 01       	movw	r30, r28
 b06:	97 01       	movw	r18, r14
 b08:	a8 01       	movw	r20, r16
 b0a:	da 94       	dec	r13
 b0c:	69 f7       	brne	.-38     	; 0xae8 <__fp_powser+0x18>
 b0e:	df 90       	pop	r13
 b10:	ef 90       	pop	r14
 b12:	ff 90       	pop	r15
 b14:	0f 91       	pop	r16
 b16:	1f 91       	pop	r17
 b18:	cf 91       	pop	r28
 b1a:	df 91       	pop	r29
 b1c:	08 95       	ret

00000b1e <__fp_pscA>:
 b1e:	00 24       	eor	r0, r0
 b20:	0a 94       	dec	r0
 b22:	16 16       	cp	r1, r22
 b24:	17 06       	cpc	r1, r23
 b26:	18 06       	cpc	r1, r24
 b28:	09 06       	cpc	r0, r25
 b2a:	08 95       	ret

00000b2c <__fp_pscB>:
 b2c:	00 24       	eor	r0, r0
 b2e:	0a 94       	dec	r0
 b30:	12 16       	cp	r1, r18
 b32:	13 06       	cpc	r1, r19
 b34:	14 06       	cpc	r1, r20
 b36:	05 06       	cpc	r0, r21
 b38:	08 95       	ret

00000b3a <__fp_round>:
 b3a:	09 2e       	mov	r0, r25
 b3c:	03 94       	inc	r0
 b3e:	00 0c       	add	r0, r0
 b40:	11 f4       	brne	.+4      	; 0xb46 <__fp_round+0xc>
 b42:	88 23       	and	r24, r24
 b44:	52 f0       	brmi	.+20     	; 0xb5a <__fp_round+0x20>
 b46:	bb 0f       	add	r27, r27
 b48:	40 f4       	brcc	.+16     	; 0xb5a <__fp_round+0x20>
 b4a:	bf 2b       	or	r27, r31
 b4c:	11 f4       	brne	.+4      	; 0xb52 <__fp_round+0x18>
 b4e:	60 ff       	sbrs	r22, 0
 b50:	04 c0       	rjmp	.+8      	; 0xb5a <__fp_round+0x20>
 b52:	6f 5f       	subi	r22, 0xFF	; 255
 b54:	7f 4f       	sbci	r23, 0xFF	; 255
 b56:	8f 4f       	sbci	r24, 0xFF	; 255
 b58:	9f 4f       	sbci	r25, 0xFF	; 255
 b5a:	08 95       	ret

00000b5c <__fp_split3>:
 b5c:	57 fd       	sbrc	r21, 7
 b5e:	90 58       	subi	r25, 0x80	; 128
 b60:	44 0f       	add	r20, r20
 b62:	55 1f       	adc	r21, r21
 b64:	59 f0       	breq	.+22     	; 0xb7c <__fp_splitA+0x10>
 b66:	5f 3f       	cpi	r21, 0xFF	; 255
 b68:	71 f0       	breq	.+28     	; 0xb86 <__fp_splitA+0x1a>
 b6a:	47 95       	ror	r20

00000b6c <__fp_splitA>:
 b6c:	88 0f       	add	r24, r24
 b6e:	97 fb       	bst	r25, 7
 b70:	99 1f       	adc	r25, r25
 b72:	61 f0       	breq	.+24     	; 0xb8c <__fp_splitA+0x20>
 b74:	9f 3f       	cpi	r25, 0xFF	; 255
 b76:	79 f0       	breq	.+30     	; 0xb96 <__fp_splitA+0x2a>
 b78:	87 95       	ror	r24
 b7a:	08 95       	ret
 b7c:	12 16       	cp	r1, r18
 b7e:	13 06       	cpc	r1, r19
 b80:	14 06       	cpc	r1, r20
 b82:	55 1f       	adc	r21, r21
 b84:	f2 cf       	rjmp	.-28     	; 0xb6a <__fp_split3+0xe>
 b86:	46 95       	lsr	r20
 b88:	f1 df       	rcall	.-30     	; 0xb6c <__fp_splitA>
 b8a:	08 c0       	rjmp	.+16     	; 0xb9c <__fp_splitA+0x30>
 b8c:	16 16       	cp	r1, r22
 b8e:	17 06       	cpc	r1, r23
 b90:	18 06       	cpc	r1, r24
 b92:	99 1f       	adc	r25, r25
 b94:	f1 cf       	rjmp	.-30     	; 0xb78 <__fp_splitA+0xc>
 b96:	86 95       	lsr	r24
 b98:	71 05       	cpc	r23, r1
 b9a:	61 05       	cpc	r22, r1
 b9c:	08 94       	sec
 b9e:	08 95       	ret

00000ba0 <__fp_trunc>:
 ba0:	0e 94 b6 05 	call	0xb6c	; 0xb6c <__fp_splitA>
 ba4:	a0 f0       	brcs	.+40     	; 0xbce <__fp_trunc+0x2e>
 ba6:	be e7       	ldi	r27, 0x7E	; 126
 ba8:	b9 17       	cp	r27, r25
 baa:	88 f4       	brcc	.+34     	; 0xbce <__fp_trunc+0x2e>
 bac:	bb 27       	eor	r27, r27
 bae:	9f 38       	cpi	r25, 0x8F	; 143
 bb0:	60 f4       	brcc	.+24     	; 0xbca <__fp_trunc+0x2a>
 bb2:	16 16       	cp	r1, r22
 bb4:	b1 1d       	adc	r27, r1
 bb6:	67 2f       	mov	r22, r23
 bb8:	78 2f       	mov	r23, r24
 bba:	88 27       	eor	r24, r24
 bbc:	98 5f       	subi	r25, 0xF8	; 248
 bbe:	f7 cf       	rjmp	.-18     	; 0xbae <__fp_trunc+0xe>
 bc0:	86 95       	lsr	r24
 bc2:	77 95       	ror	r23
 bc4:	67 95       	ror	r22
 bc6:	b1 1d       	adc	r27, r1
 bc8:	93 95       	inc	r25
 bca:	96 39       	cpi	r25, 0x96	; 150
 bcc:	c8 f3       	brcs	.-14     	; 0xbc0 <__fp_trunc+0x20>
 bce:	08 95       	ret

00000bd0 <__fp_zero>:
 bd0:	e8 94       	clt

00000bd2 <__fp_szero>:
 bd2:	bb 27       	eor	r27, r27
 bd4:	66 27       	eor	r22, r22
 bd6:	77 27       	eor	r23, r23
 bd8:	cb 01       	movw	r24, r22
 bda:	97 f9       	bld	r25, 7
 bdc:	08 95       	ret

00000bde <__gesf2>:
 bde:	0e 94 12 05 	call	0xa24	; 0xa24 <__fp_cmp>
 be2:	08 f4       	brcc	.+2      	; 0xbe6 <__gesf2+0x8>
 be4:	8f ef       	ldi	r24, 0xFF	; 255
 be6:	08 95       	ret

00000be8 <inverse>:
 be8:	9b 01       	movw	r18, r22
 bea:	ac 01       	movw	r20, r24
 bec:	60 e0       	ldi	r22, 0x00	; 0
 bee:	70 e0       	ldi	r23, 0x00	; 0
 bf0:	80 e8       	ldi	r24, 0x80	; 128
 bf2:	9f e3       	ldi	r25, 0x3F	; 63
 bf4:	0c 94 dc 03 	jmp	0x7b8	; 0x7b8 <__divsf3>
 bf8:	0c 94 36 05 	jmp	0xa6c	; 0xa6c <__fp_inf>
 bfc:	0c 94 57 05 	jmp	0xaae	; 0xaae <__fp_mpack>

00000c00 <ldexp>:
 c00:	0e 94 b6 05 	call	0xb6c	; 0xb6c <__fp_splitA>
 c04:	d8 f3       	brcs	.-10     	; 0xbfc <inverse+0x14>
 c06:	99 23       	and	r25, r25
 c08:	c9 f3       	breq	.-14     	; 0xbfc <inverse+0x14>
 c0a:	94 0f       	add	r25, r20
 c0c:	51 1d       	adc	r21, r1
 c0e:	a3 f3       	brvs	.-24     	; 0xbf8 <inverse+0x10>
 c10:	91 50       	subi	r25, 0x01	; 1
 c12:	50 40       	sbci	r21, 0x00	; 0
 c14:	94 f0       	brlt	.+36     	; 0xc3a <ldexp+0x3a>
 c16:	59 f0       	breq	.+22     	; 0xc2e <ldexp+0x2e>
 c18:	88 23       	and	r24, r24
 c1a:	32 f0       	brmi	.+12     	; 0xc28 <ldexp+0x28>
 c1c:	66 0f       	add	r22, r22
 c1e:	77 1f       	adc	r23, r23
 c20:	88 1f       	adc	r24, r24
 c22:	91 50       	subi	r25, 0x01	; 1
 c24:	50 40       	sbci	r21, 0x00	; 0
 c26:	c1 f7       	brne	.-16     	; 0xc18 <ldexp+0x18>
 c28:	9e 3f       	cpi	r25, 0xFE	; 254
 c2a:	51 05       	cpc	r21, r1
 c2c:	2c f7       	brge	.-54     	; 0xbf8 <inverse+0x10>
 c2e:	88 0f       	add	r24, r24
 c30:	91 1d       	adc	r25, r1
 c32:	96 95       	lsr	r25
 c34:	87 95       	ror	r24
 c36:	97 f9       	bld	r25, 7
 c38:	08 95       	ret
 c3a:	5f 3f       	cpi	r21, 0xFF	; 255
 c3c:	ac f0       	brlt	.+42     	; 0xc68 <ldexp+0x68>
 c3e:	98 3e       	cpi	r25, 0xE8	; 232
 c40:	9c f0       	brlt	.+38     	; 0xc68 <ldexp+0x68>
 c42:	bb 27       	eor	r27, r27
 c44:	86 95       	lsr	r24
 c46:	77 95       	ror	r23
 c48:	67 95       	ror	r22
 c4a:	b7 95       	ror	r27
 c4c:	08 f4       	brcc	.+2      	; 0xc50 <ldexp+0x50>
 c4e:	b1 60       	ori	r27, 0x01	; 1
 c50:	93 95       	inc	r25
 c52:	c1 f7       	brne	.-16     	; 0xc44 <ldexp+0x44>
 c54:	bb 0f       	add	r27, r27
 c56:	58 f7       	brcc	.-42     	; 0xc2e <ldexp+0x2e>
 c58:	11 f4       	brne	.+4      	; 0xc5e <ldexp+0x5e>
 c5a:	60 ff       	sbrs	r22, 0
 c5c:	e8 cf       	rjmp	.-48     	; 0xc2e <ldexp+0x2e>
 c5e:	6f 5f       	subi	r22, 0xFF	; 255
 c60:	7f 4f       	sbci	r23, 0xFF	; 255
 c62:	8f 4f       	sbci	r24, 0xFF	; 255
 c64:	9f 4f       	sbci	r25, 0xFF	; 255
 c66:	e3 cf       	rjmp	.-58     	; 0xc2e <ldexp+0x2e>
 c68:	0c 94 e9 05 	jmp	0xbd2	; 0xbd2 <__fp_szero>

00000c6c <modf>:
 c6c:	fa 01       	movw	r30, r20
 c6e:	dc 01       	movw	r26, r24
 c70:	aa 0f       	add	r26, r26
 c72:	bb 1f       	adc	r27, r27
 c74:	9b 01       	movw	r18, r22
 c76:	ac 01       	movw	r20, r24
 c78:	bf 57       	subi	r27, 0x7F	; 127
 c7a:	28 f4       	brcc	.+10     	; 0xc86 <modf+0x1a>
 c7c:	22 27       	eor	r18, r18
 c7e:	33 27       	eor	r19, r19
 c80:	44 27       	eor	r20, r20
 c82:	50 78       	andi	r21, 0x80	; 128
 c84:	20 c0       	rjmp	.+64     	; 0xcc6 <modf+0x5a>
 c86:	b7 51       	subi	r27, 0x17	; 23
 c88:	90 f4       	brcc	.+36     	; 0xcae <modf+0x42>
 c8a:	ab 2f       	mov	r26, r27
 c8c:	00 24       	eor	r0, r0
 c8e:	46 95       	lsr	r20
 c90:	37 95       	ror	r19
 c92:	27 95       	ror	r18
 c94:	01 1c       	adc	r0, r1
 c96:	a3 95       	inc	r26
 c98:	d2 f3       	brmi	.-12     	; 0xc8e <modf+0x22>
 c9a:	00 20       	and	r0, r0
 c9c:	71 f0       	breq	.+28     	; 0xcba <modf+0x4e>
 c9e:	22 0f       	add	r18, r18
 ca0:	33 1f       	adc	r19, r19
 ca2:	44 1f       	adc	r20, r20
 ca4:	b3 95       	inc	r27
 ca6:	da f3       	brmi	.-10     	; 0xc9e <modf+0x32>
 ca8:	0e d0       	rcall	.+28     	; 0xcc6 <modf+0x5a>
 caa:	0c 94 6a 03 	jmp	0x6d4	; 0x6d4 <__subsf3>
 cae:	61 30       	cpi	r22, 0x01	; 1
 cb0:	71 05       	cpc	r23, r1
 cb2:	a0 e8       	ldi	r26, 0x80	; 128
 cb4:	8a 07       	cpc	r24, r26
 cb6:	b9 46       	sbci	r27, 0x69	; 105
 cb8:	30 f4       	brcc	.+12     	; 0xcc6 <modf+0x5a>
 cba:	9b 01       	movw	r18, r22
 cbc:	ac 01       	movw	r20, r24
 cbe:	66 27       	eor	r22, r22
 cc0:	77 27       	eor	r23, r23
 cc2:	88 27       	eor	r24, r24
 cc4:	90 78       	andi	r25, 0x80	; 128
 cc6:	30 96       	adiw	r30, 0x00	; 0
 cc8:	21 f0       	breq	.+8      	; 0xcd2 <modf+0x66>
 cca:	20 83       	st	Z, r18
 ccc:	31 83       	std	Z+1, r19	; 0x01
 cce:	42 83       	std	Z+2, r20	; 0x02
 cd0:	53 83       	std	Z+3, r21	; 0x03
 cd2:	08 95       	ret

00000cd4 <__mulsf3>:
 cd4:	0e 94 7d 06 	call	0xcfa	; 0xcfa <__mulsf3x>
 cd8:	0c 94 9d 05 	jmp	0xb3a	; 0xb3a <__fp_round>
 cdc:	0e 94 8f 05 	call	0xb1e	; 0xb1e <__fp_pscA>
 ce0:	38 f0       	brcs	.+14     	; 0xcf0 <__mulsf3+0x1c>
 ce2:	0e 94 96 05 	call	0xb2c	; 0xb2c <__fp_pscB>
 ce6:	20 f0       	brcs	.+8      	; 0xcf0 <__mulsf3+0x1c>
 ce8:	95 23       	and	r25, r21
 cea:	11 f0       	breq	.+4      	; 0xcf0 <__mulsf3+0x1c>
 cec:	0c 94 36 05 	jmp	0xa6c	; 0xa6c <__fp_inf>
 cf0:	0c 94 65 05 	jmp	0xaca	; 0xaca <__fp_nan>
 cf4:	11 24       	eor	r1, r1
 cf6:	0c 94 e9 05 	jmp	0xbd2	; 0xbd2 <__fp_szero>

00000cfa <__mulsf3x>:
 cfa:	0e 94 ae 05 	call	0xb5c	; 0xb5c <__fp_split3>
 cfe:	70 f3       	brcs	.-36     	; 0xcdc <__mulsf3+0x8>

00000d00 <__mulsf3_pse>:
 d00:	95 9f       	mul	r25, r21
 d02:	c1 f3       	breq	.-16     	; 0xcf4 <__mulsf3+0x20>
 d04:	95 0f       	add	r25, r21
 d06:	50 e0       	ldi	r21, 0x00	; 0
 d08:	55 1f       	adc	r21, r21
 d0a:	62 9f       	mul	r22, r18
 d0c:	f0 01       	movw	r30, r0
 d0e:	72 9f       	mul	r23, r18
 d10:	bb 27       	eor	r27, r27
 d12:	f0 0d       	add	r31, r0
 d14:	b1 1d       	adc	r27, r1
 d16:	63 9f       	mul	r22, r19
 d18:	aa 27       	eor	r26, r26
 d1a:	f0 0d       	add	r31, r0
 d1c:	b1 1d       	adc	r27, r1
 d1e:	aa 1f       	adc	r26, r26
 d20:	64 9f       	mul	r22, r20
 d22:	66 27       	eor	r22, r22
 d24:	b0 0d       	add	r27, r0
 d26:	a1 1d       	adc	r26, r1
 d28:	66 1f       	adc	r22, r22
 d2a:	82 9f       	mul	r24, r18
 d2c:	22 27       	eor	r18, r18
 d2e:	b0 0d       	add	r27, r0
 d30:	a1 1d       	adc	r26, r1
 d32:	62 1f       	adc	r22, r18
 d34:	73 9f       	mul	r23, r19
 d36:	b0 0d       	add	r27, r0
 d38:	a1 1d       	adc	r26, r1
 d3a:	62 1f       	adc	r22, r18
 d3c:	83 9f       	mul	r24, r19
 d3e:	a0 0d       	add	r26, r0
 d40:	61 1d       	adc	r22, r1
 d42:	22 1f       	adc	r18, r18
 d44:	74 9f       	mul	r23, r20
 d46:	33 27       	eor	r19, r19
 d48:	a0 0d       	add	r26, r0
 d4a:	61 1d       	adc	r22, r1
 d4c:	23 1f       	adc	r18, r19
 d4e:	84 9f       	mul	r24, r20
 d50:	60 0d       	add	r22, r0
 d52:	21 1d       	adc	r18, r1
 d54:	82 2f       	mov	r24, r18
 d56:	76 2f       	mov	r23, r22
 d58:	6a 2f       	mov	r22, r26
 d5a:	11 24       	eor	r1, r1
 d5c:	9f 57       	subi	r25, 0x7F	; 127
 d5e:	50 40       	sbci	r21, 0x00	; 0
 d60:	9a f0       	brmi	.+38     	; 0xd88 <__mulsf3_pse+0x88>
 d62:	f1 f0       	breq	.+60     	; 0xda0 <__mulsf3_pse+0xa0>
 d64:	88 23       	and	r24, r24
 d66:	4a f0       	brmi	.+18     	; 0xd7a <__mulsf3_pse+0x7a>
 d68:	ee 0f       	add	r30, r30
 d6a:	ff 1f       	adc	r31, r31
 d6c:	bb 1f       	adc	r27, r27
 d6e:	66 1f       	adc	r22, r22
 d70:	77 1f       	adc	r23, r23
 d72:	88 1f       	adc	r24, r24
 d74:	91 50       	subi	r25, 0x01	; 1
 d76:	50 40       	sbci	r21, 0x00	; 0
 d78:	a9 f7       	brne	.-22     	; 0xd64 <__mulsf3_pse+0x64>
 d7a:	9e 3f       	cpi	r25, 0xFE	; 254
 d7c:	51 05       	cpc	r21, r1
 d7e:	80 f0       	brcs	.+32     	; 0xda0 <__mulsf3_pse+0xa0>
 d80:	0c 94 36 05 	jmp	0xa6c	; 0xa6c <__fp_inf>
 d84:	0c 94 e9 05 	jmp	0xbd2	; 0xbd2 <__fp_szero>
 d88:	5f 3f       	cpi	r21, 0xFF	; 255
 d8a:	e4 f3       	brlt	.-8      	; 0xd84 <__mulsf3_pse+0x84>
 d8c:	98 3e       	cpi	r25, 0xE8	; 232
 d8e:	d4 f3       	brlt	.-12     	; 0xd84 <__mulsf3_pse+0x84>
 d90:	86 95       	lsr	r24
 d92:	77 95       	ror	r23
 d94:	67 95       	ror	r22
 d96:	b7 95       	ror	r27
 d98:	f7 95       	ror	r31
 d9a:	e7 95       	ror	r30
 d9c:	9f 5f       	subi	r25, 0xFF	; 255
 d9e:	c1 f7       	brne	.-16     	; 0xd90 <__mulsf3_pse+0x90>
 da0:	fe 2b       	or	r31, r30
 da2:	88 0f       	add	r24, r24
 da4:	91 1d       	adc	r25, r1
 da6:	96 95       	lsr	r25
 da8:	87 95       	ror	r24
 daa:	97 f9       	bld	r25, 7
 dac:	08 95       	ret

00000dae <round>:
 dae:	0e 94 b6 05 	call	0xb6c	; 0xb6c <__fp_splitA>
 db2:	e8 f0       	brcs	.+58     	; 0xdee <round+0x40>
 db4:	9e 37       	cpi	r25, 0x7E	; 126
 db6:	e8 f0       	brcs	.+58     	; 0xdf2 <round+0x44>
 db8:	96 39       	cpi	r25, 0x96	; 150
 dba:	b8 f4       	brcc	.+46     	; 0xdea <round+0x3c>
 dbc:	9e 38       	cpi	r25, 0x8E	; 142
 dbe:	48 f4       	brcc	.+18     	; 0xdd2 <round+0x24>
 dc0:	67 2f       	mov	r22, r23
 dc2:	78 2f       	mov	r23, r24
 dc4:	88 27       	eor	r24, r24
 dc6:	98 5f       	subi	r25, 0xF8	; 248
 dc8:	f9 cf       	rjmp	.-14     	; 0xdbc <round+0xe>
 dca:	86 95       	lsr	r24
 dcc:	77 95       	ror	r23
 dce:	67 95       	ror	r22
 dd0:	93 95       	inc	r25
 dd2:	95 39       	cpi	r25, 0x95	; 149
 dd4:	d0 f3       	brcs	.-12     	; 0xdca <round+0x1c>
 dd6:	b6 2f       	mov	r27, r22
 dd8:	b1 70       	andi	r27, 0x01	; 1
 dda:	6b 0f       	add	r22, r27
 ddc:	71 1d       	adc	r23, r1
 dde:	81 1d       	adc	r24, r1
 de0:	20 f4       	brcc	.+8      	; 0xdea <round+0x3c>
 de2:	87 95       	ror	r24
 de4:	77 95       	ror	r23
 de6:	67 95       	ror	r22
 de8:	93 95       	inc	r25
 dea:	0c 94 3c 05 	jmp	0xa78	; 0xa78 <__fp_mintl>
 dee:	0c 94 57 05 	jmp	0xaae	; 0xaae <__fp_mpack>
 df2:	0c 94 e9 05 	jmp	0xbd2	; 0xbd2 <__fp_szero>

00000df6 <_exit>:
 df6:	f8 94       	cli

00000df8 <__stop_program>:
 df8:	ff cf       	rjmp	.-2      	; 0xdf8 <__stop_program>
